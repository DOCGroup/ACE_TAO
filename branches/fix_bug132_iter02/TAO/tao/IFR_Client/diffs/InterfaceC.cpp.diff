--- InterfaceC.cpp	Fri Jan 12 21:21:46 2001
+++ ..\InterfaceC.cpp	Fri Jan 12 21:33:01 2001
@@ -1,6 +1,6 @@
 // -*- C++ -*-
 //
-// $Id$
+/* $Id$ */
 
 // ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
 // TAO and the TAO IDL Compiler have been developed by:
@@ -20,6 +20,8 @@
 //     http://www.cs.wustl.edu/~schmidt/TAO.html
 
 #include "InterfaceC.h"
+#include "tao/Stub.h"
+#include "tao/Invocation.h"
 
 #if TAO_HAS_INTERCEPTORS == 1
 #include "tao/RequestInfo_Util.h"
@@ -74,64 +76,25 @@
   12, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657300),  // name = dk_Provides
   8, ACE_NTOHL (0x646b5f55), ACE_NTOHL (0x73657300),  // name = dk_Uses
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_DefinitionKind (CORBA::tk_enum, sizeof (_oc_IR_DefinitionKind), (char *) &_oc_IR_DefinitionKind, 0, sizeof (IR::DefinitionKind));
+static CORBA::TypeCode _tc_TAO_tc_IR_DefinitionKind (CORBA::tk_enum, sizeof (_oc_IR_DefinitionKind), (char *) &_oc_IR_DefinitionKind, 0, sizeof (IR_DefinitionKind));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
 TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_DefinitionKind, &_tc_TAO_tc_IR_DefinitionKind)
 TAO_NAMESPACE_END
-static const CORBA::Long _oc_CORBA_Identifier[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
-  11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-  CORBA::tk_string, 
-  0U, // string length
-};
-static CORBA::TypeCode _tc_TAO_tc_CORBA_Identifier (CORBA::tk_alias, sizeof (_oc_CORBA_Identifier), (char *) &_oc_CORBA_Identifier, 0, sizeof (CORBA::Identifier));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (CORBA)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Identifier, &_tc_TAO_tc_CORBA_Identifier)
-TAO_NAMESPACE_END
-static const CORBA::Long _oc_CORBA_ScopedName[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5363), ACE_NTOHL (0x6f706564), ACE_NTOHL (0x4e616d65), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/ScopedName:1.0
-  11, ACE_NTOHL (0x53636f70), ACE_NTOHL (0x65644e61), ACE_NTOHL (0x6d650000),  // name = ScopedName
-  CORBA::tk_string, 
-  0U, // string length
-};
-static CORBA::TypeCode _tc_TAO_tc_CORBA_ScopedName (CORBA::tk_alias, sizeof (_oc_CORBA_ScopedName), (char *) &_oc_CORBA_ScopedName, 0, sizeof (CORBA::ScopedName));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (CORBA)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ScopedName, &_tc_TAO_tc_CORBA_ScopedName)
-TAO_NAMESPACE_END
-static const CORBA::Long _oc_CORBA_RepositoryId[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
-  13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-  CORBA::tk_string, 
-  0U, // string length
-};
-static CORBA::TypeCode _tc_TAO_tc_CORBA_RepositoryId (CORBA::tk_alias, sizeof (_oc_CORBA_RepositoryId), (char *) &_oc_CORBA_RepositoryId, 0, sizeof (CORBA::RepositoryId));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (CORBA)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RepositoryId, &_tc_TAO_tc_CORBA_RepositoryId)
-TAO_NAMESPACE_END
 
 ///////////////////////////////////////////////////////////////////////
 //                Base & Remote Proxy  Implementation. 
 //
 
-CORBA::_TAO_IRObject_Proxy_Impl::_TAO_IRObject_Proxy_Impl (void)
+_TAO_IRObject_Proxy_Impl::_TAO_IRObject_Proxy_Impl (void)
 {}
 
-CORBA::_TAO_IRObject_Remote_Proxy_Impl::_TAO_IRObject_Remote_Proxy_Impl (void)
+_TAO_IRObject_Remote_Proxy_Impl::_TAO_IRObject_Remote_Proxy_Impl (void)
 {}
 
 // Remote Implementation of the IDL interface methods
 
-IR::DefinitionKind CORBA::_TAO_IRObject_Remote_Proxy_Impl::def_kind (
+IR_DefinitionKind _TAO_IRObject_Remote_Proxy_Impl::def_kind (
     CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -140,7 +103,7 @@
   ))
 {
   
-  IR::DefinitionKind _tao_retval = (IR::DefinitionKind)0;
+  IR_DefinitionKind _tao_retval = (IR_DefinitionKind)0;
   
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
@@ -156,151 +119,57 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      CORBA::IRObject::TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_retval)
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::DefinitionKind  _tao_retval_info = _tao_retval;
-               ri.result (_tao_retval_info);
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        ACE_CHECK_RETURN  (_tao_retval);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              _tao_retval
+            );
         }
-      
-      break;
-    }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_retval)
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                _tao_retval
+              );
+          }
+        break;
+      }
   return _tao_retval;
 }
 
-void CORBA::_TAO_IRObject_Remote_Proxy_Impl::destroy (
+void _TAO_IRObject_Remote_Proxy_Impl::destroy (
     CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
-{
-  
-
-  
-  
+{  
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW (CORBA::INTERNAL ());
@@ -314,120 +183,36 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      CORBA::IRObject::TAO_ClientRequestInfo_CORBA_IRObject_destroy ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        ACE_CHECK;
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
         }
-      
-      break;
-    }
-  
+        
+        break;
+      }
 }
 
 
@@ -440,32 +225,32 @@
 //           Remote & Base  Proxy Broker Implementation
 //
 
-CORBA::_TAO_IRObject_Proxy_Broker::_TAO_IRObject_Proxy_Broker (void)
+_TAO_IRObject_Proxy_Broker::_TAO_IRObject_Proxy_Broker (void)
 {
 }
 
-CORBA::_TAO_IRObject_Proxy_Broker::~_TAO_IRObject_Proxy_Broker (void)
+_TAO_IRObject_Proxy_Broker::~_TAO_IRObject_Proxy_Broker (void)
 {
 }
 
-// Factory Member function Implementation.
-CORBA::_TAO_IRObject_Remote_Proxy_Broker *CORBA::_TAO_IRObject_Remote_Proxy_Broker::the_TAO_IRObject_Remote_Proxy_Broker (void)
+// Factory function Implementation.
+_TAO_IRObject_Remote_Proxy_Broker *the_TAO_IRObject_Remote_Proxy_Broker (void)
 {
-  static ::CORBA::_TAO_IRObject_Remote_Proxy_Broker remote_proxy_broker;
+  static ::_TAO_IRObject_Remote_Proxy_Broker remote_proxy_broker;
   return &remote_proxy_broker;
 }
 
-CORBA::_TAO_IRObject_Remote_Proxy_Broker::_TAO_IRObject_Remote_Proxy_Broker (void)
+_TAO_IRObject_Remote_Proxy_Broker::_TAO_IRObject_Remote_Proxy_Broker (void)
 {
 }
 
-CORBA::_TAO_IRObject_Remote_Proxy_Broker::~_TAO_IRObject_Remote_Proxy_Broker (void)
+_TAO_IRObject_Remote_Proxy_Broker::~_TAO_IRObject_Remote_Proxy_Broker (void)
 {
 }
 
-CORBA::_TAO_IRObject_Proxy_Impl&
-CORBA::_TAO_IRObject_Remote_Proxy_Broker::select_proxy (
-  ::CORBA::IRObject *object,
+_TAO_IRObject_Proxy_Impl&
+_TAO_IRObject_Remote_Proxy_Broker::select_proxy (
+  CORBA_IRObject *object,
   CORBA::Environment &ACE_TRY_ENV
 )
 {
@@ -481,139 +266,140 @@
 
 
 // default constructor
-CORBA::IRObject::IRObject (int collocated)
+CORBA_IRObject::CORBA_IRObject (int collocated)
 {
   this->_tao_setup_collocation (collocated);
 }
 
 // destructor
-CORBA::IRObject::~IRObject (void)
+CORBA_IRObject::~CORBA_IRObject (void)
 {}
 
 void
-CORBA::IRObject::_tao_setup_collocation (int collocated)
+CORBA_IRObject::_tao_setup_collocation (int collocated)
 {
   if (collocated)
     this->the_TAO_IRObject_Proxy_Broker_ =
-      ::CORBA__TAO_IRObject_Proxy_Broker_Factory_function_pointer (this);
+      _TAO_IRObject_Proxy_Broker_Factory_function_pointer (this);
   else
     this->the_TAO_IRObject_Proxy_Broker_ =
-      ::CORBA::_TAO_IRObject_Remote_Proxy_Broker::the_TAO_IRObject_Remote_Proxy_Broker ();
+      the_TAO_IRObject_Remote_Proxy_Broker ();
   
-  }
   
-  void CORBA::IRObject::_tao_any_destructor (void *x)
-  {
-    IRObject *tmp = ACE_static_cast (IRObject*,x);
-    CORBA::release (tmp);
-  }
+}
 
-  CORBA::IRObject_ptr CORBA::IRObject::_narrow (
-      CORBA::Object_ptr obj,
-      CORBA::Environment &ACE_TRY_ENV
-    )
-  {
-    if (CORBA::is_nil (obj))
-      return IRObject::_nil ();
-    if (! obj->_is_local ())
+void CORBA_IRObject::_tao_any_destructor (void *x)
+{
+  CORBA_IRObject *tmp = ACE_static_cast (CORBA_IRObject*,x);
+  CORBA::release (tmp);
+}
+
+CORBA_IRObject_ptr CORBA_IRObject::_narrow (
+    CORBA::Object_ptr obj,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+{
+  if (CORBA::is_nil (obj))
+    return CORBA_IRObject::_nil ();
+  if (! obj->_is_local ())
+    {
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/IRObject:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (CORBA_IRObject::_nil ());
+      if (is_a == 0)
+        return CORBA_IRObject::_nil ();
+    }
+  return CORBA_IRObject::_unchecked_narrow (obj, ACE_TRY_ENV);
+}
+
+CORBA_IRObject_ptr CORBA_IRObject::_unchecked_narrow (
+    CORBA::Object_ptr obj,
+    CORBA::Environment &
+  )
+{
+  if (CORBA::is_nil (obj))
+    return CORBA_IRObject::_nil ();
+  if (! obj->_is_local ())
+    {
+      TAO_Stub* stub = obj->_stubobj ();
+      if (stub)
+        stub->_incr_refcnt ();
+      CORBA_IRObject_ptr default_proxy = CORBA_IRObject::_nil ();
+
+      if (
+          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
+          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
+          obj->_is_collocated () && _TAO_IRObject_Proxy_Broker_Factory_function_pointer != 0
+        )
       {
-        CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/IRObject:1.0", ACE_TRY_ENV);
-        ACE_CHECK_RETURN (IRObject::_nil ());
-        if (is_a == 0)
-          return IRObject::_nil ();
+        ACE_NEW_RETURN (
+          default_proxy,
+          CORBA_IRObject (
+            stub,
+            1,
+            obj->_servant ()),
+            
+          CORBA_IRObject::_nil ());
+        }
+      if (CORBA::is_nil (default_proxy))
+        ACE_NEW_RETURN (default_proxy, CORBA_IRObject (stub, 0, obj->_servant ()), CORBA_IRObject::_nil ());
+        return default_proxy;
       }
-    return IRObject::_unchecked_narrow (obj, ACE_TRY_ENV);
-  }
-  
-  CORBA::IRObject_ptr CORBA::IRObject::_unchecked_narrow (
-      CORBA::Object_ptr obj,
-      CORBA::Environment &
-    )
-  {
-    if (CORBA::is_nil (obj))
-      return IRObject::_nil ();
-    if (! obj->_is_local ())
-      {
-        TAO_Stub* stub = obj->_stubobj ();
-        if (stub)
-          stub->_incr_refcnt ();
-        IRObject_ptr default_proxy = IRObject::_nil ();
-
-        if (
-            !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
-            stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-            obj->_is_collocated () &&CORBA__TAO_IRObject_Proxy_Broker_Factory_function_pointer != 0
-          )
-        {
-          ACE_NEW_RETURN (
-            default_proxy,
-            ::CORBA::IRObject (
-              stub,
-              1,
-              obj->_servant ()),
-              
-            IRObject::_nil ());
-          }
-        if (CORBA::is_nil (default_proxy))
-          ACE_NEW_RETURN (default_proxy, ::CORBA::IRObject (stub, 0, obj->_servant ()), IRObject::_nil ());
-          return default_proxy;
-        }
-      else 
-        return
-          ACE_reinterpret_cast
-            (
-              IRObject_ptr,
-                obj->_tao_QueryInterface
-                  (
-                    ACE_reinterpret_cast
-                      (
-                        ptr_arith_t,
-                        &IRObject::_narrow
-                      )
-                  )
-            );
+    else 
+      return
+        ACE_reinterpret_cast
+          (
+            CORBA_IRObject_ptr,
+              obj->_tao_QueryInterface
+                (
+                  ACE_reinterpret_cast
+                    (
+                      ptr_arith_t,
+                      &CORBA_IRObject::_narrow
+                    )
+                )
+          );
+}
+
+CORBA_IRObject_ptr
+CORBA_IRObject::_duplicate (CORBA_IRObject_ptr obj)
+{
+  if (!CORBA::is_nil (obj))
+    obj->_add_ref ();
+  return obj;
 }
 
-  CORBA::IRObject_ptr
-  CORBA::IRObject::_duplicate (IRObject_ptr obj)
-  {
-    if (!CORBA::is_nil (obj))
-      obj->_add_ref ();
-    return obj;
-  }
-  
-    CORBA::Boolean CORBA::IRObject::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
-  {
-    if (
-      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
-      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
+CORBA::Boolean CORBA_IRObject::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+{
+  if (
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
   return 1; // success using local knowledge
-    else
-      return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
-  }
+  else
+    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
+}
 
-  void *CORBA::IRObject::_tao_QueryInterface (ptr_arith_t type)
-  {
-    void *retv = 0;
-    if (type == ACE_reinterpret_cast
-      (ptr_arith_t,
-        &ACE_NESTED_CLASS (::CORBA, IRObject)::_narrow))
-      retv = ACE_reinterpret_cast (void*, this);
-    else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
-      retv = ACE_reinterpret_cast (void *,
-        ACE_static_cast (CORBA::Object_ptr, this));
-      
-    if (retv)
-      this->_add_ref ();
-    return retv;
-  }
+void *CORBA_IRObject::_tao_QueryInterface (ptr_arith_t type)
+{
+  void *retv = 0;
+  if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &CORBA_IRObject::_narrow))
+    retv = ACE_reinterpret_cast (void*, this);
+  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
+    retv = ACE_reinterpret_cast (void *,
+      ACE_static_cast (CORBA::Object_ptr, this));
+    
+  if (retv)
+    this->_add_ref ();
+  return retv;
+}
 
-  const char* CORBA::IRObject::_interface_repository_id (void) const
-  {
-    return "IDL:omg.org/CORBA/IRObject:1.0";
-  }
+const char* CORBA_IRObject::_interface_repository_id (void) const
+{
+  return "IDL:omg.org/CORBA/IRObject:1.0";
+}
 
-IR::DefinitionKind CORBA::IRObject::def_kind (
+IR_DefinitionKind CORBA_IRObject::def_kind (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -627,7 +413,7 @@
     );
 }
 
-void CORBA::IRObject::destroy (
+void CORBA_IRObject::destroy (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -641,211 +427,66 @@
     );
 }
 
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-CORBA::IRObject::TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get::TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-CORBA::IRObject::TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-CORBA::IRObject::TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-CORBA::IRObject::TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-CORBA::IRObject::TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get::result (IR::DefinitionKind result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-CORBA::IRObject::TAO_ClientRequestInfo_CORBA_IRObject_destroy::TAO_ClientRequestInfo_CORBA_IRObject_destroy (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-CORBA::IRObject::TAO_ClientRequestInfo_CORBA_IRObject_destroy::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-CORBA::IRObject::TAO_ClientRequestInfo_CORBA_IRObject_destroy::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-CORBA::IRObject::TAO_ClientRequestInfo_CORBA_IRObject_destroy::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
-}
-
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_CORBA_IRObject[] =
+static const CORBA::Long _oc_IR_Identifier[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
-  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4952), ACE_NTOHL (0x4f626a65), ACE_NTOHL (0x63743a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/IRObject:1.0
-  9, ACE_NTOHL (0x49524f62), ACE_NTOHL (0x6a656374), ACE_NTOHL (0x0),  // name = IRObject
+  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+  11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+  CORBA::tk_alias, // typecode kind for typedefs
+  68, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
+    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+    CORBA::tk_string,
+    0U, // string length
+
 };
-static CORBA::TypeCode _tc_TAO_tc_CORBA_IRObject (CORBA::tk_objref, sizeof (_oc_CORBA_IRObject), (char *) &_oc_CORBA_IRObject, 0, sizeof (CORBA::IRObject));
+static CORBA::TypeCode _tc_TAO_tc_IR_Identifier (CORBA::tk_alias, sizeof (_oc_IR_Identifier), (char *) &_oc_IR_Identifier, 0, sizeof (IR::Identifier));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (CORBA)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_IRObject, &_tc_TAO_tc_CORBA_IRObject)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Identifier, &_tc_TAO_tc_IR_Identifier)
 TAO_NAMESPACE_END
-static const CORBA::Long _oc_CORBA_ValueModifier[] =
+
+static const CORBA::Long _oc_IR_ScopedName[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
-  36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5661), ACE_NTOHL (0x6c75654d), ACE_NTOHL (0x6f646966), ACE_NTOHL (0x6965723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ValueModifier:1.0
-  14, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ValueModifier
-  CORBA::tk_short,
+  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x636f7065), ACE_NTOHL (0x644e616d), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ScopedName:1.0
+  11, ACE_NTOHL (0x53636f70), ACE_NTOHL (0x65644e61), ACE_NTOHL (0x6d650000),  // name = ScopedName
+  CORBA::tk_alias, // typecode kind for typedefs
+  68, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5363), ACE_NTOHL (0x6f706564), ACE_NTOHL (0x4e616d65), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/ScopedName:1.0
+    11, ACE_NTOHL (0x53636f70), ACE_NTOHL (0x65644e61), ACE_NTOHL (0x6d650000),  // name = ScopedName
+    CORBA::tk_string,
+    0U, // string length
 
 };
-static CORBA::TypeCode _tc_TAO_tc_CORBA_ValueModifier (CORBA::tk_alias, sizeof (_oc_CORBA_ValueModifier), (char *) &_oc_CORBA_ValueModifier, 0, sizeof (CORBA::ValueModifier));
+static CORBA::TypeCode _tc_TAO_tc_IR_ScopedName (CORBA::tk_alias, sizeof (_oc_IR_ScopedName), (char *) &_oc_IR_ScopedName, 0, sizeof (IR::ScopedName));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (CORBA)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueModifier, &_tc_TAO_tc_CORBA_ValueModifier)
-TAO_NAMESPACE_END
-TAO_NAMESPACE_TYPE (const CORBA::Short)
-TAO_NAMESPACE_BEGIN (CORBA)
-TAO_NAMESPACE_DEFINE (const CORBA::Short, VM_NONE, 0)
-TAO_NAMESPACE_END
-TAO_NAMESPACE_TYPE (const CORBA::Short)
-TAO_NAMESPACE_BEGIN (CORBA)
-TAO_NAMESPACE_DEFINE (const CORBA::Short, VM_CUSTOM, 1)
-TAO_NAMESPACE_END
-TAO_NAMESPACE_TYPE (const CORBA::Short)
-TAO_NAMESPACE_BEGIN (CORBA)
-TAO_NAMESPACE_DEFINE (const CORBA::Short, VM_ABSTRACT, 2)
-TAO_NAMESPACE_END
-TAO_NAMESPACE_TYPE (const CORBA::Short)
-TAO_NAMESPACE_BEGIN (CORBA)
-TAO_NAMESPACE_DEFINE (const CORBA::Short, VM_TRUNCATABLE, 3)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ScopedName, &_tc_TAO_tc_IR_ScopedName)
 TAO_NAMESPACE_END
-static const CORBA::Long _oc_CORBA_Visibility[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5669), ACE_NTOHL (0x73696269), ACE_NTOHL (0x6c697479), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Visibility:1.0
-  11, ACE_NTOHL (0x56697369), ACE_NTOHL (0x62696c69), ACE_NTOHL (0x74790000),  // name = Visibility
-  CORBA::tk_short,
 
-};
-static CORBA::TypeCode _tc_TAO_tc_CORBA_Visibility (CORBA::tk_alias, sizeof (_oc_CORBA_Visibility), (char *) &_oc_CORBA_Visibility, 0, sizeof (CORBA::Visibility));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (CORBA)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Visibility, &_tc_TAO_tc_CORBA_Visibility)
-TAO_NAMESPACE_END
-TAO_NAMESPACE_TYPE (const CORBA::Short)
-TAO_NAMESPACE_BEGIN (CORBA)
-TAO_NAMESPACE_DEFINE (const CORBA::Short, PRIVATE_MEMBER, 0)
-TAO_NAMESPACE_END
-TAO_NAMESPACE_TYPE (const CORBA::Short)
-TAO_NAMESPACE_BEGIN (CORBA)
-TAO_NAMESPACE_DEFINE (const CORBA::Short, PUBLIC_MEMBER, 1)
-TAO_NAMESPACE_END
-static const CORBA::Long _oc_IR_Identifier[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-  11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-  CORBA::tk_string, 
-  0U, // string length
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_Identifier (CORBA::tk_alias, sizeof (_oc_IR_Identifier), (char *) &_oc_IR_Identifier, 0, sizeof (IR::Identifier));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Identifier, &_tc_TAO_tc_IR_Identifier)
-TAO_NAMESPACE_END
-static const CORBA::Long _oc_IR_ScopedName[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x636f7065), ACE_NTOHL (0x644e616d), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ScopedName:1.0
-  11, ACE_NTOHL (0x53636f70), ACE_NTOHL (0x65644e61), ACE_NTOHL (0x6d650000),  // name = ScopedName
-  CORBA::tk_string, 
-  0U, // string length
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_ScopedName (CORBA::tk_alias, sizeof (_oc_IR_ScopedName), (char *) &_oc_IR_ScopedName, 0, sizeof (IR::ScopedName));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ScopedName, &_tc_TAO_tc_IR_ScopedName)
-TAO_NAMESPACE_END
 static const CORBA::Long _oc_IR_RepositoryId[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
   32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-  13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-  CORBA::tk_string, 
-  0U, // string length
+  13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = IR_RepositoryId
+  CORBA::tk_alias, // typecode kind for typedefs
+  72, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
+    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = IR_RepositoryId
+    CORBA::tk_string,
+    0U, // string length
+
 };
 static CORBA::TypeCode _tc_TAO_tc_IR_RepositoryId (CORBA::tk_alias, sizeof (_oc_IR_RepositoryId), (char *) &_oc_IR_RepositoryId, 0, sizeof (IR::RepositoryId));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
 TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RepositoryId, &_tc_TAO_tc_IR_RepositoryId)
 TAO_NAMESPACE_END
+
 static const CORBA::Long _oc_IR_VersionSpec[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
@@ -864,15 +505,15 @@
 //                Base & Remote Proxy  Implementation. 
 //
 
-IR::_TAO_Contained_Proxy_Impl::_TAO_Contained_Proxy_Impl (void)
+_TAO_Contained_Proxy_Impl::_TAO_Contained_Proxy_Impl (void)
 {}
 
-IR::_TAO_Contained_Remote_Proxy_Impl::_TAO_Contained_Remote_Proxy_Impl (void)
+_TAO_Contained_Remote_Proxy_Impl::_TAO_Contained_Remote_Proxy_Impl (void)
 {}
 
 // Remote Implementation of the IDL interface methods
 
-char * IR::_TAO_Contained_Remote_Proxy_Impl::id (
+char * _TAO_Contained_Remote_Proxy_Impl::id (
     CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -897,141 +538,50 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Contained::TAO_ClientRequestInfo_IR_Contained_id_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              char * _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
         }
-      
-      break;
-    }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
   return _tao_safe_retval._retn ();
 }
 
-void IR::_TAO_Contained_Remote_Proxy_Impl::id (
+void _TAO_Contained_Remote_Proxy_Impl::id (
     CORBA_Object *_collocated_tao_target_,
     const char * id,
     CORBA::Environment &ACE_TRY_ENV
@@ -1039,11 +589,7 @@
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
-{
-  
-
-  
-  
+{  
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW (CORBA::INTERNAL ());
@@ -1057,144 +603,57 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Contained::TAO_ClientRequestInfo_IR_Contained_id_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        id,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << id)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << id)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
       
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
         }
-      
-      break;
-    }
-  
+        
+        break;
+      }
 }
 
-char * IR::_TAO_Contained_Remote_Proxy_Impl::name (
+char * _TAO_Contained_Remote_Proxy_Impl::name (
     CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
-{
-  
+{  
   CORBA::String_var _tao_safe_retval;
-  
-  
+    
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
@@ -1208,141 +667,50 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Contained::TAO_ClientRequestInfo_IR_Contained_name_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              char * _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
         }
-      
-      break;
-    }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
   return _tao_safe_retval._retn ();
 }
 
-void IR::_TAO_Contained_Remote_Proxy_Impl::name (
+void _TAO_Contained_Remote_Proxy_Impl::name (
     CORBA_Object *_collocated_tao_target_,
     const char * name,
     CORBA::Environment &ACE_TRY_ENV
@@ -1350,11 +718,7 @@
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
-{
-  
-
-  
-  
+{  
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW (CORBA::INTERNAL ());
@@ -1368,135 +732,50 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Contained::TAO_ClientRequestInfo_IR_Contained_name_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        name,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << name)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << name)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
       
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
         }
-      
-      break;
-    }
-  
+        
+        break;
+      }
 }
 
-char * IR::_TAO_Contained_Remote_Proxy_Impl::version (
+char * _TAO_Contained_Remote_Proxy_Impl::version (
     CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
+   CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
@@ -1519,141 +798,50 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Contained::TAO_ClientRequestInfo_IR_Contained_version_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              char * _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
         }
-      
-      break;
-    }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
   return _tao_safe_retval._retn ();
 }
 
-void IR::_TAO_Contained_Remote_Proxy_Impl::version (
+void _TAO_Contained_Remote_Proxy_Impl::version (
     CORBA_Object *_collocated_tao_target_,
     const char * version,
     CORBA::Environment &ACE_TRY_ENV
@@ -1661,15 +849,10 @@
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
-{
-  
-
-  
-  
+{ 
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW (CORBA::INTERNAL ());
-
   
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
@@ -1679,149 +862,62 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Contained::TAO_ClientRequestInfo_IR_Contained_version_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        version,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << version)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << version)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
       
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
         }
-      
-      break;
-    }
-  
+        
+        break;
+      }
 }
 
-IR::Container_ptr IR::_TAO_Contained_Remote_Proxy_Impl::defined_in (
+IR_Container_ptr _TAO_Contained_Remote_Proxy_Impl::defined_in (
     CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
-{
-  
-  IR::Container_ptr _tao_retval = IR::Container::_nil ();
-  IR::Container_var _tao_safe_retval (_tao_retval);
+{  
+  IR_Container_ptr _tao_retval = IR_Container::_nil ();
+  IR_Container_var _tao_safe_retval (_tao_retval);
   
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
   
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
@@ -1831,156 +927,62 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Contained::TAO_ClientRequestInfo_IR_Contained_defined_in_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::Container_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
         }
-      
-      break;
-    }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
   return _tao_safe_retval._retn ();
 }
 
-char * IR::_TAO_Contained_Remote_Proxy_Impl::absolute_name (
+char * _TAO_Contained_Remote_Proxy_Impl::absolute_name (
     CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
-{
-  
+{  
   CORBA::String_var _tao_safe_retval;
-  
-  
+    
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
   
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
@@ -1990,157 +992,63 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Contained::TAO_ClientRequestInfo_IR_Contained_absolute_name_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              char * _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
         }
-      
-      break;
-    }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
   return _tao_safe_retval._retn ();
 }
 
-IR::Repository_ptr IR::_TAO_Contained_Remote_Proxy_Impl::containing_repository (
+IR_Repository_ptr _TAO_Contained_Remote_Proxy_Impl::containing_repository (
     CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
-{
-  
-  IR::Repository_ptr _tao_retval = IR::Repository::_nil ();
-  IR::Repository_var _tao_safe_retval (_tao_retval);
-  
-  
+{ 
+  IR_Repository_ptr _tao_retval = IR_Repository::_nil ();
+  IR_Repository_var _tao_safe_retval (_tao_retval);
+    
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
   
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
@@ -2150,158 +1058,65 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Contained::TAO_ClientRequestInfo_IR_Contained_containing_repository_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::Repository_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
         }
-      
-      break;
-    }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
   return _tao_safe_retval._retn ();
 }
 
-IR::Contained::Description * IR::_TAO_Contained_Remote_Proxy_Impl::describe (
+IR_Contained::Description * _TAO_Contained_Remote_Proxy_Impl::describe (
     CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
-{
-  
-  IR::Contained::Description *_tao_retval = 0;
+{  
+  IR_Contained::Description *_tao_retval = 0;
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
   
-  ACE_NEW_RETURN (_tao_retval, IR::Contained::Description, _tao_retval);
-  IR::Contained::Description_var _tao_safe_retval (_tao_retval);
+  ACE_NEW_RETURN (_tao_retval, IR_Contained::Description, _tao_retval);
+  IR_Contained::Description_var _tao_safe_retval (_tao_retval);
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
       "describe",
@@ -2310,143 +1125,52 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Contained::TAO_ClientRequestInfo_IR_Contained_describe ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::Contained::Description * _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
         }
-      
-      break;
-    }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
   return _tao_safe_retval._retn ();
 }
 
-void IR::_TAO_Contained_Remote_Proxy_Impl::move (
+void _TAO_Contained_Remote_Proxy_Impl::move (
     CORBA_Object *_collocated_tao_target_,
-    IR::Container_ptr new_container,
+    IR_Container_ptr new_container,
     const char * new_name,
     const char * new_version,
     CORBA::Environment &ACE_TRY_ENV
@@ -2454,16 +1178,11 @@
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
-{
-  
-
-  
-  
+{  
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW (CORBA::INTERNAL ());
-
-  
+ 
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
       "move",
@@ -2472,134 +1191,47 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Contained::TAO_ClientRequestInfo_IR_Contained_move ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        new_container,
-        new_name,
-        new_version,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << new_container) &&
-              (_tao_out << new_name) &&
-              (_tao_out << new_version)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << new_container) &&
+              (_tao_out << new_name) &&
+              (_tao_out << new_version)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
       
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
         }
-      
-      break;
-    }
-  
+        
+        break;
+      }
 }
 
 
@@ -2612,32 +1244,32 @@
 //           Remote & Base  Proxy Broker Implementation
 //
 
-IR::_TAO_Contained_Proxy_Broker::_TAO_Contained_Proxy_Broker (void)
+_TAO_Contained_Proxy_Broker::_TAO_Contained_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_Contained_Proxy_Broker::~_TAO_Contained_Proxy_Broker (void)
+_TAO_Contained_Proxy_Broker::~_TAO_Contained_Proxy_Broker (void)
 {
 }
 
-// Factory Member function Implementation.
-IR::_TAO_Contained_Remote_Proxy_Broker *IR::_TAO_Contained_Remote_Proxy_Broker::the_TAO_Contained_Remote_Proxy_Broker (void)
+// Factory function Implementation.
+_TAO_Contained_Remote_Proxy_Broker *the_TAO_Contained_Remote_Proxy_Broker (void)
 {
-  static ::IR::_TAO_Contained_Remote_Proxy_Broker remote_proxy_broker;
+  static ::_TAO_Contained_Remote_Proxy_Broker remote_proxy_broker;
   return &remote_proxy_broker;
 }
 
-IR::_TAO_Contained_Remote_Proxy_Broker::_TAO_Contained_Remote_Proxy_Broker (void)
+_TAO_Contained_Remote_Proxy_Broker::_TAO_Contained_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_Contained_Remote_Proxy_Broker::~_TAO_Contained_Remote_Proxy_Broker (void)
+_TAO_Contained_Remote_Proxy_Broker::~_TAO_Contained_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_Contained_Proxy_Impl&
-IR::_TAO_Contained_Remote_Proxy_Broker::select_proxy (
-  ::IR::Contained *object,
+_TAO_Contained_Proxy_Impl&
+_TAO_Contained_Remote_Proxy_Broker::select_proxy (
+  IR_Contained *object,
   CORBA::Environment &ACE_TRY_ENV
 )
 {
@@ -2653,109 +1285,109 @@
 
 
 // default constructor
-IR::Contained::Contained (int collocated)
+IR_Contained::IR_Contained (int collocated)
 {
   this->_tao_setup_collocation (collocated);
 }
 
 // destructor
-IR::Contained::~Contained (void)
+IR_Contained::~IR_Contained (void)
 {}
 
 void
-IR::Contained::_tao_setup_collocation (int collocated)
+IR_Contained::_tao_setup_collocation (int collocated)
 {
   if (collocated)
     this->the_TAO_Contained_Proxy_Broker_ =
-      ::IR__TAO_Contained_Proxy_Broker_Factory_function_pointer (this);
+      _TAO_Contained_Proxy_Broker_Factory_function_pointer (this);
   else
     this->the_TAO_Contained_Proxy_Broker_ =
-      ::IR::_TAO_Contained_Remote_Proxy_Broker::the_TAO_Contained_Remote_Proxy_Broker ();
+      ::the_TAO_Contained_Remote_Proxy_Broker ();
   
-  ACE_NESTED_CLASS (CORBA, IRObject)::_tao_setup_collocation (collocated);
+  CORBA_IRObject::_tao_setup_collocation (collocated);  
 }
 
-void IR::Contained::_tao_any_destructor (void *x)
+void IR_Contained::_tao_any_destructor (void *x)
 {
-  Contained *tmp = ACE_static_cast (Contained*,x);
+  IR_Contained *tmp = ACE_static_cast (IR_Contained*,x);
   CORBA::release (tmp);
 }
 
-IR::Contained_ptr IR::Contained::_narrow (
+IR_Contained_ptr IR_Contained::_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
 {
   if (CORBA::is_nil (obj))
-    return Contained::_nil ();
+    return IR_Contained::_nil ();
   if (! obj->_is_local ())
     {
       CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/Contained:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (Contained::_nil ());
+      ACE_CHECK_RETURN (IR_Contained::_nil ());
       if (is_a == 0)
-        return Contained::_nil ();
+        return IR_Contained::_nil ();
     }
-  return Contained::_unchecked_narrow (obj, ACE_TRY_ENV);
+  return IR_Contained::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::Contained_ptr IR::Contained::_unchecked_narrow (
+IR_Contained_ptr IR_Contained::_unchecked_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &
   )
 {
   if (CORBA::is_nil (obj))
-    return Contained::_nil ();
+    return IR_Contained::_nil ();
   if (! obj->_is_local ())
     {
       TAO_Stub* stub = obj->_stubobj ();
       if (stub)
         stub->_incr_refcnt ();
-      Contained_ptr default_proxy = Contained::_nil ();
+      IR_Contained_ptr default_proxy = IR_Contained::_nil ();
 
       if (
           !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
           stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_Contained_Proxy_Broker_Factory_function_pointer != 0
+          obj->_is_collocated () &&_TAO_Contained_Proxy_Broker_Factory_function_pointer != 0
         )
       {
         ACE_NEW_RETURN (
           default_proxy,
-          ::IR::Contained (
+          IR_Contained (
             stub,
             1,
             obj->_servant ()),
             
-          Contained::_nil ());
+          IR_Contained::_nil ());
         }
       if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::Contained (stub, 0, obj->_servant ()), Contained::_nil ());
+        ACE_NEW_RETURN (default_proxy, IR_Contained (stub, 0, obj->_servant ()), IR_Contained::_nil ());
         return default_proxy;
       }
     else 
       return
         ACE_reinterpret_cast
           (
-            Contained_ptr,
+            IR_Contained_ptr,
               obj->_tao_QueryInterface
                 (
                   ACE_reinterpret_cast
                     (
                       ptr_arith_t,
-                      &Contained::_narrow
+                      &IR_Contained::_narrow
                     )
                 )
           );
 }
 
-IR::Contained_ptr
-IR::Contained::_duplicate (Contained_ptr obj)
+IR_Contained_ptr
+IR_Contained::_duplicate (IR_Contained_ptr obj)
 {
   if (!CORBA::is_nil (obj))
     obj->_add_ref ();
   return obj;
 }
 
-CORBA::Boolean IR::Contained::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+CORBA::Boolean IR_Contained::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
   if (
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
@@ -2766,22 +1398,22 @@
     return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
 }
 
-void *IR::Contained::_tao_QueryInterface (ptr_arith_t type)
+void *IR_Contained::_tao_QueryInterface (ptr_arith_t type)
 {
   void *retv = 0;
   if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Contained)::_narrow))
+      &IR_Contained::_narrow))
     retv = ACE_reinterpret_cast (void*, this);
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
+      &CORBA_IRObject::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            CORBA::IRObject_ptr,
+            CORBA_IRObject_ptr,
             this
           )
       );
@@ -2794,34 +1426,32 @@
   return retv;
 }
 
-const char* IR::Contained::_interface_repository_id (void) const
+const char* IR_Contained::_interface_repository_id (void) const
 {
   return "IDL:omg.org/IR/Contained:1.0";
 }
 
-char * IR::Contained::id (
+char * IR_Contained::id (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
-{
-  
+{  
   return this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).id (
       this,
       ACE_TRY_ENV
     );
 }
 
-void IR::Contained::id (
+void IR_Contained::id (
     const char * id,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
-{
-  
+{  
   this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).id (
       this,
       id,
@@ -2829,7 +1459,7 @@
     );
 }
 
-char * IR::Contained::name (
+char * IR_Contained::name (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -2843,15 +1473,14 @@
     );
 }
 
-void IR::Contained::name (
+void IR_Contained::name (
     const char * name,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
-{
-  
+{  
   this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).name (
       this,
       name,
@@ -2859,29 +1488,27 @@
     );
 }
 
-char * IR::Contained::version (
+char * IR_Contained::version (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
-{
-  
+{  
   return this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).version (
       this,
       ACE_TRY_ENV
     );
 }
 
-void IR::Contained::version (
+void IR_Contained::version (
     const char * version,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
-{
-  
+{  
   this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).version (
       this,
       version,
@@ -2889,42 +1516,39 @@
     );
 }
 
-IR::Container_ptr IR::Contained::defined_in (
+IR_Container_ptr IR_Contained::defined_in (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
-{
-  
+{  
   return this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).defined_in (
       this,
       ACE_TRY_ENV
     );
 }
 
-char * IR::Contained::absolute_name (
+char * IR_Contained::absolute_name (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
-{
-  
+{  
   return this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).absolute_name (
       this,
       ACE_TRY_ENV
     );
 }
 
-IR::Repository_ptr IR::Contained::containing_repository (
+IR_Repository_ptr IR_Contained::containing_repository (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
-{
-  
+{  
   return this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).containing_repository (
       this,
       ACE_TRY_ENV
@@ -2983,31 +1607,30 @@
   CORBA::tk_any,
 
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_Contained_Description (CORBA::tk_struct, sizeof (_oc_IR_Contained_Description), (char *) &_oc_IR_Contained_Description, 0, sizeof (IR::Contained::Description));
-CORBA::TypeCode_ptr IR::Contained::_tc_Description = &_tc_TAO_tc_IR_Contained_Description;
+static CORBA::TypeCode _tc_TAO_tc_IR_Contained_Description (CORBA::tk_struct, sizeof (_oc_IR_Contained_Description), (char *) &_oc_IR_Contained_Description, 0, sizeof (IR_Contained::Description));
+CORBA::TypeCode_ptr IR_Contained::_tc_Description = &_tc_TAO_tc_IR_Contained_Description;
 
-void IR::Contained::Description::_tao_any_destructor (void *x)
+void IR_Contained::Description::_tao_any_destructor (void *x)
 {
   Description *tmp = ACE_static_cast (Description*,x);
   delete tmp;
 }
 
-IR::Contained::Description * IR::Contained::describe (
+IR_Contained::Description * IR_Contained::describe (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
-{
-  
+{  
   return this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).describe (
       this,
       ACE_TRY_ENV
     );
 }
 
-void IR::Contained::move (
-    IR::Container_ptr new_container,
+void IR_Contained::move (
+    IR_Container_ptr new_container,
     const char * new_name,
     const char * new_version,
     CORBA::Environment &ACE_TRY_ENV
@@ -3015,8 +1638,7 @@
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
-{
-  
+{  
   this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).move (
       this,
       new_container,
@@ -3026,782 +1648,140 @@
     );
 }
 
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_id_get::TAO_ClientRequestInfo_IR_Contained_id_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_id_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_id_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_id_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_id_get::result (char * result)
+static const CORBA::Long _oc_IR_Contained[] =
 {
-  // update the result 
-  this->_result = result;
-}
-
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_id_set::TAO_ClientRequestInfo_IR_Contained_id_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * id,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    id_ (id)
-{}
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7461), ACE_NTOHL (0x696e6564), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/Contained:1.0
+  10, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x64000000),  // name = IR_Contained
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_Contained (CORBA::tk_objref, sizeof (_oc_IR_Contained), (char *) &_oc_IR_Contained, 0, sizeof (IR_Contained));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Contained, &_tc_TAO_tc_IR_Contained)
+TAO_NAMESPACE_END
 
-Dynamic::ParameterList *
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_id_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
+  // The Base_Sequence functions, please see tao/Sequence.h
+  void
+  _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::_allocate_buffer (CORBA::ULong length)
+  {
+    IR_InterfaceDef **tmp = 0;
+    tmp = _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::allocbuf (length);
     
-  CORBA::ULong length_id = parameter_list->length ();
-  parameter_list->length (length_id + 1);
-  (*parameter_list)[length_id].argument <<= id_;
-  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_id_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_id_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
-}
-
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_name_get::TAO_ClientRequestInfo_IR_Contained_name_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_name_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_name_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_name_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_name_get::result (char * result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_name_set::TAO_ClientRequestInfo_IR_Contained_name_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * name,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    name_ (name)
-{}
-
-Dynamic::ParameterList *
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_name_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_name = parameter_list->length ();
-  parameter_list->length (length_name + 1);
-  (*parameter_list)[length_name].argument <<= name_;
-  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_name_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_name_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
-}
-
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_version_get::TAO_ClientRequestInfo_IR_Contained_version_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_version_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_version_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_version_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_version_get::result (char * result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_version_set::TAO_ClientRequestInfo_IR_Contained_version_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * version,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    version_ (version)
-{}
-
-Dynamic::ParameterList *
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_version_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_version = parameter_list->length ();
-  parameter_list->length (length_version + 1);
-  (*parameter_list)[length_version].argument <<= version_;
-  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_version_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_version_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
-}
-
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_defined_in_get::TAO_ClientRequestInfo_IR_Contained_defined_in_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_defined_in_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_defined_in_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_defined_in_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_defined_in_get::result (IR::Container_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_absolute_name_get::TAO_ClientRequestInfo_IR_Contained_absolute_name_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_absolute_name_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_absolute_name_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_absolute_name_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_absolute_name_get::result (char * result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_containing_repository_get::TAO_ClientRequestInfo_IR_Contained_containing_repository_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_containing_repository_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_containing_repository_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_containing_repository_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_containing_repository_get::result (IR::Repository_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_describe::TAO_ClientRequestInfo_IR_Contained_describe (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_describe::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_describe::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_describe::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_describe::result (ACE_NESTED_CLASS (IR::Contained,Description) * result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_move::TAO_ClientRequestInfo_IR_Contained_move (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    IR::Container_ptr new_container,
-    const char * new_name,
-    const char * new_version,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    new_container_ (new_container),
-    new_name_ (new_name),
-    new_version_ (new_version)
-{}
-
-Dynamic::ParameterList *
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_move::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_new_container = parameter_list->length ();
-  parameter_list->length (length_new_container + 1);
-  (*parameter_list)[length_new_container].argument <<=  this->new_container_;
-  
-  (*parameter_list)[length_new_container].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_new_name = parameter_list->length ();
-  parameter_list->length (length_new_name + 1);
-  (*parameter_list)[length_new_name].argument <<= new_name_;
-  (*parameter_list)[length_new_name].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_new_version = parameter_list->length ();
-  parameter_list->length (length_new_version + 1);
-  (*parameter_list)[length_new_version].argument <<= new_version_;
-  (*parameter_list)[length_new_version].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_move::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::Contained::TAO_ClientRequestInfo_IR_Contained_move::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
-}
-
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_Contained[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7461), ACE_NTOHL (0x696e6564), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/Contained:1.0
-  10, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x64000000),  // name = Contained
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_Contained (CORBA::tk_objref, sizeof (_oc_IR_Contained), (char *) &_oc_IR_Contained, 0, sizeof (IR::Contained));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Contained, &_tc_TAO_tc_IR_Contained)
-TAO_NAMESPACE_END
-
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  
-#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_INTERFACEDEFSEQ_CS_)
-#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_INTERFACEDEFSEQ_CS_
-
-  // The Base_Sequence functions, please see tao/Sequence.h
-  void
-  IR::_TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::_allocate_buffer (CORBA::ULong length)
-  {
-    IR::InterfaceDef **tmp = 0;
-    tmp = _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::allocbuf (length);
-    
-    if (this->buffer_ != 0)
-    {
-      IR::InterfaceDef **old = ACE_reinterpret_cast (IR::InterfaceDef**, this->buffer_);
-      for (CORBA::ULong i = 0; i < this->length_; ++i)
-        if (!this->release_)
-          tmp[i] = IR::InterfaceDef::_duplicate (old[i]);
-        else
-          tmp[i] = old[i];
-        
-      if (this->release_)
-        delete[] old;
-      
-    }
-    this->buffer_ = tmp;
-  }
+    if (this->buffer_ != 0)
+    {
+      IR_InterfaceDef **old = ACE_reinterpret_cast (IR_InterfaceDef**, this->buffer_);
+      for (CORBA::ULong i = 0; i < this->length_; ++i)
+        if (!this->release_)
+          tmp[i] = IR_InterfaceDef::_duplicate (old[i]);
+        else
+          tmp[i] = old[i];
+        
+      if (this->release_)
+        delete[] old;
+      
+    }
+    this->buffer_ = tmp;
+  }
   
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::_deallocate_buffer (void)
+  _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::_deallocate_buffer (void)
   {
     if (this->buffer_ == 0 || this->release_ == 0)
       return;
-    IR::InterfaceDef **tmp = ACE_reinterpret_cast (IR::InterfaceDef**, this->buffer_);
+    IR_InterfaceDef **tmp = ACE_reinterpret_cast (IR_InterfaceDef**, this->buffer_);
     for (CORBA::ULong i = 0; i < this->length_; ++i)
     {
       CORBA::release (tmp[i]);
-      tmp[i] = IR::InterfaceDef::_nil ();
+      tmp[i] = IR_InterfaceDef::_nil ();
     }
     _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::freebuf (tmp);
     this->buffer_ = 0;
   }
   
-  IR::_TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::~_TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq (void)
+  _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::~_TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq (void)
   {
     this->_deallocate_buffer ();
   }
   
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
+  _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
   {
-    IR::InterfaceDef **tmp = ACE_reinterpret_cast (IR::InterfaceDef**, this->buffer_);
+    IR_InterfaceDef **tmp = ACE_reinterpret_cast (IR_InterfaceDef**, this->buffer_);
     
     for (CORBA::ULong i = nl; i < ol; ++i)
     {
       CORBA::release (tmp[i]);
-      tmp[i] = IR::InterfaceDef::_nil ();
+      tmp[i] = IR_InterfaceDef::_nil ();
     }
   }
   void 
-  IR::_TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::_downcast (
+  _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::_downcast (
       void* target,
       CORBA_Object *src,
       CORBA_Environment &ACE_TRY_ENV
     )
   {
-    IR::InterfaceDef **tmp = ACE_static_cast (IR::InterfaceDef**, target);
-    *tmp = IR::InterfaceDef::_narrow (src, ACE_TRY_ENV);
+    IR_InterfaceDef **tmp = ACE_static_cast (IR_InterfaceDef**, target);
+    *tmp = IR_InterfaceDef::_narrow (src, ACE_TRY_ENV);
   }
 
   CORBA_Object*
-  IR::_TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::_upcast (void *src) const
+  _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::_upcast (void *src) const
   {
-    IR::InterfaceDef **tmp = ACE_static_cast (IR::InterfaceDef**, src);
+    IR_InterfaceDef **tmp = ACE_static_cast (IR_InterfaceDef**, src);
     return *tmp;
   }
   
-#endif /* end #if !defined */
-
-
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 
-#if !defined (_IR_INTERFACEDEFSEQ_CS_)
-#define _IR_INTERFACEDEFSEQ_CS_
-
 // *************************************************************
-// IR::InterfaceDefSeq
+// IR_InterfaceDefSeq
 // *************************************************************
 
-IR::InterfaceDefSeq::InterfaceDefSeq (void)
+IR_InterfaceDefSeq::IR_InterfaceDefSeq (void)
 {}
-IR::InterfaceDefSeq::InterfaceDefSeq (CORBA::ULong max) // uses max size
+IR_InterfaceDefSeq::IR_InterfaceDefSeq (CORBA::ULong max) // uses max size
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::InterfaceDef,IR::InterfaceDef_var>
+  TAO_Unbounded_Object_Sequence<IR_InterfaceDef,IR_InterfaceDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max)
 {}
-IR::InterfaceDefSeq::InterfaceDefSeq (CORBA::ULong max, CORBA::ULong length, IR::InterfaceDef_ptr *buffer, CORBA::Boolean release)
+IR_InterfaceDefSeq::IR_InterfaceDefSeq (CORBA::ULong max, CORBA::ULong length, IR_InterfaceDef_ptr *buffer, CORBA::Boolean release)
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::InterfaceDef,IR::InterfaceDef_var>
+  TAO_Unbounded_Object_Sequence<IR_InterfaceDef,IR_InterfaceDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max, length, buffer, release)
 {}
-IR::InterfaceDefSeq::InterfaceDefSeq (const InterfaceDefSeq &seq) // copy ctor
+IR_InterfaceDefSeq::IR_InterfaceDefSeq (const IR_InterfaceDefSeq &seq) // copy ctor
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::InterfaceDef,IR::InterfaceDef_var>
+  TAO_Unbounded_Object_Sequence<IR_InterfaceDef,IR_InterfaceDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (seq)
 {}
-IR::InterfaceDefSeq::~InterfaceDefSeq (void) // dtor
+IR_InterfaceDefSeq::~IR_InterfaceDefSeq (void) // dtor
 {}
-void IR::InterfaceDefSeq::_tao_any_destructor (void *x)
+void IR_InterfaceDefSeq::_tao_any_destructor (void *x)
 {
-  InterfaceDefSeq *tmp = ACE_static_cast (InterfaceDefSeq*,x);
+  IR_InterfaceDefSeq *tmp = ACE_static_cast (IR_InterfaceDefSeq*,x);
   delete tmp;
 }
 
-
-#endif /* end #if !defined */
-
 static const CORBA::Long _oc_IR_InterfaceDefSeq[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
   35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/InterfaceDefSeq:1.0
-  16, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x53657100),  // name = InterfaceDefSeq
+  16, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x53657100),  // name = IR_InterfaceDefSeq
   CORBA::tk_sequence, // typecode kind
   76, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
@@ -3809,12 +1789,12 @@
     60, // encapsulation length
       TAO_ENCAP_BYTE_ORDER, // byte order
       32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/InterfaceDef:1.0
-      13, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = InterfaceDef
+      13, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = IR_InterfaceDef
 
     0U,
 
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_InterfaceDefSeq (CORBA::tk_alias, sizeof (_oc_IR_InterfaceDefSeq), (char *) &_oc_IR_InterfaceDefSeq, 0, sizeof (IR::InterfaceDefSeq));
+static CORBA::TypeCode _tc_TAO_tc_IR_InterfaceDefSeq (CORBA::tk_alias, sizeof (_oc_IR_InterfaceDefSeq), (char *) &_oc_IR_InterfaceDefSeq, 0, sizeof (IR_InterfaceDefSeq));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
 TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_InterfaceDefSeq, &_tc_TAO_tc_IR_InterfaceDefSeq)
@@ -3822,22 +1802,19 @@
 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   
-#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_VALUEDEFSEQ_CS_)
-#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_VALUEDEFSEQ_CS_
-
   // The Base_Sequence functions, please see tao/Sequence.h
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::_allocate_buffer (CORBA::ULong length)
+  _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::_allocate_buffer (CORBA::ULong length)
   {
-    IR::ValueDef **tmp = 0;
+    IR_ValueDef **tmp = 0;
     tmp = _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::allocbuf (length);
     
     if (this->buffer_ != 0)
     {
-      IR::ValueDef **old = ACE_reinterpret_cast (IR::ValueDef**, this->buffer_);
+      IR_ValueDef **old = ACE_reinterpret_cast (IR_ValueDef**, this->buffer_);
       for (CORBA::ULong i = 0; i < this->length_; ++i)
         if (!this->release_)
-          tmp[i] = IR::ValueDef::_duplicate (old[i]);
+          tmp[i] = IR_ValueDef::_duplicate (old[i]);
         else
           tmp[i] = old[i];
         
@@ -3849,111 +1826,102 @@
   }
   
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::_deallocate_buffer (void)
+  _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::_deallocate_buffer (void)
   {
     if (this->buffer_ == 0 || this->release_ == 0)
       return;
-    IR::ValueDef **tmp = ACE_reinterpret_cast (IR::ValueDef**, this->buffer_);
+    IR_ValueDef **tmp = ACE_reinterpret_cast (IR_ValueDef**, this->buffer_);
     for (CORBA::ULong i = 0; i < this->length_; ++i)
     {
       CORBA::release (tmp[i]);
-      tmp[i] = IR::ValueDef::_nil ();
+      tmp[i] = IR_ValueDef::_nil ();
     }
     _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::freebuf (tmp);
     this->buffer_ = 0;
   }
   
-  IR::_TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::~_TAO_Unbounded_Object_Sequence_IR_ValueDefSeq (void)
+  _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::~_TAO_Unbounded_Object_Sequence_IR_ValueDefSeq (void)
   {
     this->_deallocate_buffer ();
   }
   
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
+  _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
   {
-    IR::ValueDef **tmp = ACE_reinterpret_cast (IR::ValueDef**, this->buffer_);
+    IR_ValueDef **tmp = ACE_reinterpret_cast (IR_ValueDef**, this->buffer_);
     
     for (CORBA::ULong i = nl; i < ol; ++i)
     {
       CORBA::release (tmp[i]);
-      tmp[i] = IR::ValueDef::_nil ();
+      tmp[i] = IR_ValueDef::_nil ();
     }
   }
   void 
-  IR::_TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::_downcast (
+  _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::_downcast (
       void* target,
       CORBA_Object *src,
       CORBA_Environment &ACE_TRY_ENV
     )
   {
-    IR::ValueDef **tmp = ACE_static_cast (IR::ValueDef**, target);
-    *tmp = IR::ValueDef::_narrow (src, ACE_TRY_ENV);
+    IR_ValueDef **tmp = ACE_static_cast (IR_ValueDef**, target);
+    *tmp = IR_ValueDef::_narrow (src, ACE_TRY_ENV);
   }
 
   CORBA_Object*
-  IR::_TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::_upcast (void *src) const
+  _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::_upcast (void *src) const
   {
-    IR::ValueDef **tmp = ACE_static_cast (IR::ValueDef**, src);
+    IR_ValueDef **tmp = ACE_static_cast (IR_ValueDef**, src);
     return *tmp;
   }
   
-#endif /* end #if !defined */
-
-
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 
-#if !defined (_IR_VALUEDEFSEQ_CS_)
-#define _IR_VALUEDEFSEQ_CS_
-
 // *************************************************************
-// IR::ValueDefSeq
+// IR_ValueDefSeq
 // *************************************************************
 
-IR::ValueDefSeq::ValueDefSeq (void)
+IR_ValueDefSeq::IR_ValueDefSeq (void)
 {}
-IR::ValueDefSeq::ValueDefSeq (CORBA::ULong max) // uses max size
+IR_ValueDefSeq::IR_ValueDefSeq (CORBA::ULong max) // uses max size
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::ValueDef,IR::ValueDef_var>
+  TAO_Unbounded_Object_Sequence<IR_ValueDef,IR_ValueDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max)
 {}
-IR::ValueDefSeq::ValueDefSeq (CORBA::ULong max, CORBA::ULong length, IR::ValueDef_ptr *buffer, CORBA::Boolean release)
+IR_ValueDefSeq::IR_ValueDefSeq (CORBA::ULong max, CORBA::ULong length, IR_ValueDef_ptr *buffer, CORBA::Boolean release)
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::ValueDef,IR::ValueDef_var>
+  TAO_Unbounded_Object_Sequence<IR_ValueDef,IR_ValueDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max, length, buffer, release)
 {}
-IR::ValueDefSeq::ValueDefSeq (const ValueDefSeq &seq) // copy ctor
+IR_ValueDefSeq::IR_ValueDefSeq (const IR_ValueDefSeq &seq) // copy ctor
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::ValueDef,IR::ValueDef_var>
+  TAO_Unbounded_Object_Sequence<IR_ValueDef,IR_ValueDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (seq)
 {}
-IR::ValueDefSeq::~ValueDefSeq (void) // dtor
+IR_ValueDefSeq::~IR_ValueDefSeq (void) // dtor
 {}
-void IR::ValueDefSeq::_tao_any_destructor (void *x)
+void IR_ValueDefSeq::_tao_any_destructor (void *x)
 {
-  ValueDefSeq *tmp = ACE_static_cast (ValueDefSeq*,x);
+  IR_ValueDefSeq *tmp = ACE_static_cast (IR_ValueDefSeq*,x);
   delete tmp;
 }
 
-
-#endif /* end #if !defined */
-
 static const CORBA::Long _oc_IR_ValueDefSeq[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
   31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ValueDefSeq:1.0
-  12, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446566), ACE_NTOHL (0x53657100),  // name = ValueDefSeq
+  12, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446566), ACE_NTOHL (0x53657100),  // name = IR_ValueDefSeq
   CORBA::tk_sequence, // typecode kind
   68, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
@@ -3961,12 +1929,12 @@
     52, // encapsulation length
       TAO_ENCAP_BYTE_ORDER, // byte order
       28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ValueDef:1.0
-      9, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = ValueDef
+      9, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = IR_ValueDef
 
     0U,
 
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_ValueDefSeq (CORBA::tk_alias, sizeof (_oc_IR_ValueDefSeq), (char *) &_oc_IR_ValueDefSeq, 0, sizeof (IR::ValueDefSeq));
+static CORBA::TypeCode _tc_TAO_tc_IR_ValueDefSeq (CORBA::tk_alias, sizeof (_oc_IR_ValueDefSeq), (char *) &_oc_IR_ValueDefSeq, 0, sizeof (IR_ValueDefSeq));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
 TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueDefSeq, &_tc_TAO_tc_IR_ValueDefSeq)
@@ -3974,22 +1942,19 @@
 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   
-#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_COMPONENTDEFSEQ_CS_)
-#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_COMPONENTDEFSEQ_CS_
-
   // The Base_Sequence functions, please see tao/Sequence.h
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_allocate_buffer (CORBA::ULong length)
+  _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_allocate_buffer (CORBA::ULong length)
   {
-    IR::ComponentDef **tmp = 0;
+    IR_ComponentDef **tmp = 0;
     tmp = _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::allocbuf (length);
     
     if (this->buffer_ != 0)
     {
-      IR::ComponentDef **old = ACE_reinterpret_cast (IR::ComponentDef**, this->buffer_);
+      IR_ComponentDef **old = ACE_reinterpret_cast (IR_ComponentDef**, this->buffer_);
       for (CORBA::ULong i = 0; i < this->length_; ++i)
         if (!this->release_)
-          tmp[i] = IR::ComponentDef::_duplicate (old[i]);
+          tmp[i] = IR_ComponentDef::_duplicate (old[i]);
         else
           tmp[i] = old[i];
         
@@ -4001,111 +1966,102 @@
   }
   
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_deallocate_buffer (void)
+  _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_deallocate_buffer (void)
   {
     if (this->buffer_ == 0 || this->release_ == 0)
       return;
-    IR::ComponentDef **tmp = ACE_reinterpret_cast (IR::ComponentDef**, this->buffer_);
+    IR_ComponentDef **tmp = ACE_reinterpret_cast (IR_ComponentDef**, this->buffer_);
     for (CORBA::ULong i = 0; i < this->length_; ++i)
     {
       CORBA::release (tmp[i]);
-      tmp[i] = IR::ComponentDef::_nil ();
+      tmp[i] = IR_ComponentDef::_nil ();
     }
     _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::freebuf (tmp);
     this->buffer_ = 0;
   }
   
-  IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::~_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq (void)
+  _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::~_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq (void)
   {
     this->_deallocate_buffer ();
   }
   
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
+  _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
   {
-    IR::ComponentDef **tmp = ACE_reinterpret_cast (IR::ComponentDef**, this->buffer_);
+    IR_ComponentDef **tmp = ACE_reinterpret_cast (IR_ComponentDef**, this->buffer_);
     
     for (CORBA::ULong i = nl; i < ol; ++i)
     {
       CORBA::release (tmp[i]);
-      tmp[i] = IR::ComponentDef::_nil ();
+      tmp[i] = IR_ComponentDef::_nil ();
     }
   }
   void 
-  IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_downcast (
+  _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_downcast (
       void* target,
       CORBA_Object *src,
       CORBA_Environment &ACE_TRY_ENV
     )
   {
-    IR::ComponentDef **tmp = ACE_static_cast (IR::ComponentDef**, target);
-    *tmp = IR::ComponentDef::_narrow (src, ACE_TRY_ENV);
+    IR_ComponentDef **tmp = ACE_static_cast (IR_ComponentDef**, target);
+    *tmp = IR_ComponentDef::_narrow (src, ACE_TRY_ENV);
   }
 
   CORBA_Object*
-  IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_upcast (void *src) const
+  _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_upcast (void *src) const
   {
-    IR::ComponentDef **tmp = ACE_static_cast (IR::ComponentDef**, src);
+    IR_ComponentDef **tmp = ACE_static_cast (IR_ComponentDef**, src);
     return *tmp;
   }
   
-#endif /* end #if !defined */
-
-
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 
-#if !defined (_IR_COMPONENTDEFSEQ_CS_)
-#define _IR_COMPONENTDEFSEQ_CS_
-
 // *************************************************************
-// IR::ComponentDefSeq
+// IR_ComponentDefSeq
 // *************************************************************
 
-IR::ComponentDefSeq::ComponentDefSeq (void)
+IR_ComponentDefSeq::IR_ComponentDefSeq (void)
 {}
-IR::ComponentDefSeq::ComponentDefSeq (CORBA::ULong max) // uses max size
+IR_ComponentDefSeq::IR_ComponentDefSeq (CORBA::ULong max) // uses max size
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::ComponentDef,IR::ComponentDef_var>
+  TAO_Unbounded_Object_Sequence<IR_ComponentDef,IR_ComponentDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max)
 {}
-IR::ComponentDefSeq::ComponentDefSeq (CORBA::ULong max, CORBA::ULong length, IR::ComponentDef_ptr *buffer, CORBA::Boolean release)
+IR_ComponentDefSeq::IR_ComponentDefSeq (CORBA::ULong max, CORBA::ULong length, IR_ComponentDef_ptr *buffer, CORBA::Boolean release)
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::ComponentDef,IR::ComponentDef_var>
+  TAO_Unbounded_Object_Sequence<IR_ComponentDef,IR_ComponentDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max, length, buffer, release)
 {}
-IR::ComponentDefSeq::ComponentDefSeq (const ComponentDefSeq &seq) // copy ctor
+IR_ComponentDefSeq::IR_ComponentDefSeq (const IR_ComponentDefSeq &seq) // copy ctor
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::ComponentDef,IR::ComponentDef_var>
+  TAO_Unbounded_Object_Sequence<IR_ComponentDef,IR_ComponentDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (seq)
 {}
-IR::ComponentDefSeq::~ComponentDefSeq (void) // dtor
+IR_ComponentDefSeq::~IR_ComponentDefSeq (void) // dtor
 {}
-void IR::ComponentDefSeq::_tao_any_destructor (void *x)
+void IR_ComponentDefSeq::_tao_any_destructor (void *x)
 {
-  ComponentDefSeq *tmp = ACE_static_cast (ComponentDefSeq*,x);
+  IR_ComponentDefSeq *tmp = ACE_static_cast (IR_ComponentDefSeq*,x);
   delete tmp;
 }
 
-
-#endif /* end #if !defined */
-
 static const CORBA::Long _oc_IR_ComponentDefSeq[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
   35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6d706f), ACE_NTOHL (0x6e656e74), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ComponentDefSeq:1.0
-  16, ACE_NTOHL (0x436f6d70), ACE_NTOHL (0x6f6e656e), ACE_NTOHL (0x74446566), ACE_NTOHL (0x53657100),  // name = ComponentDefSeq
+  16, ACE_NTOHL (0x436f6d70), ACE_NTOHL (0x6f6e656e), ACE_NTOHL (0x74446566), ACE_NTOHL (0x53657100),  // name = IR_ComponentDefSeq
   CORBA::tk_sequence, // typecode kind
   76, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
@@ -4113,12 +2069,12 @@
     60, // encapsulation length
       TAO_ENCAP_BYTE_ORDER, // byte order
       32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6d706f), ACE_NTOHL (0x6e656e74), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ComponentDef:1.0
-      13, ACE_NTOHL (0x436f6d70), ACE_NTOHL (0x6f6e656e), ACE_NTOHL (0x74446566), ACE_NTOHL (0x0),  // name = ComponentDef
+      13, ACE_NTOHL (0x436f6d70), ACE_NTOHL (0x6f6e656e), ACE_NTOHL (0x74446566), ACE_NTOHL (0x0),  // name = IR_ComponentDef
 
     0U,
 
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_ComponentDefSeq (CORBA::tk_alias, sizeof (_oc_IR_ComponentDefSeq), (char *) &_oc_IR_ComponentDefSeq, 0, sizeof (IR::ComponentDefSeq));
+static CORBA::TypeCode _tc_TAO_tc_IR_ComponentDefSeq (CORBA::tk_alias, sizeof (_oc_IR_ComponentDefSeq), (char *) &_oc_IR_ComponentDefSeq, 0, sizeof (IR_ComponentDefSeq));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
 TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ComponentDefSeq, &_tc_TAO_tc_IR_ComponentDefSeq)
@@ -4126,22 +2082,19 @@
 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   
-#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_PROVIDESDEFSEQ_CS_)
-#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_PROVIDESDEFSEQ_CS_
-
   // The Base_Sequence functions, please see tao/Sequence.h
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_allocate_buffer (CORBA::ULong length)
+  _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_allocate_buffer (CORBA::ULong length)
   {
-    IR::ProvidesDef **tmp = 0;
+    IR_ProvidesDef **tmp = 0;
     tmp = _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::allocbuf (length);
     
     if (this->buffer_ != 0)
     {
-      IR::ProvidesDef **old = ACE_reinterpret_cast (IR::ProvidesDef**, this->buffer_);
+      IR_ProvidesDef **old = ACE_reinterpret_cast (IR_ProvidesDef**, this->buffer_);
       for (CORBA::ULong i = 0; i < this->length_; ++i)
         if (!this->release_)
-          tmp[i] = IR::ProvidesDef::_duplicate (old[i]);
+          tmp[i] = IR_ProvidesDef::_duplicate (old[i]);
         else
           tmp[i] = old[i];
         
@@ -4153,111 +2106,102 @@
   }
   
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_deallocate_buffer (void)
+  _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_deallocate_buffer (void)
   {
     if (this->buffer_ == 0 || this->release_ == 0)
       return;
-    IR::ProvidesDef **tmp = ACE_reinterpret_cast (IR::ProvidesDef**, this->buffer_);
+    IR_ProvidesDef **tmp = ACE_reinterpret_cast (IR_ProvidesDef**, this->buffer_);
     for (CORBA::ULong i = 0; i < this->length_; ++i)
     {
       CORBA::release (tmp[i]);
-      tmp[i] = IR::ProvidesDef::_nil ();
+      tmp[i] = IR_ProvidesDef::_nil ();
     }
     _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::freebuf (tmp);
     this->buffer_ = 0;
   }
   
-  IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::~_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq (void)
+  _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::~_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq (void)
   {
     this->_deallocate_buffer ();
   }
   
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
+  _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
   {
-    IR::ProvidesDef **tmp = ACE_reinterpret_cast (IR::ProvidesDef**, this->buffer_);
+    IR_ProvidesDef **tmp = ACE_reinterpret_cast (IR_ProvidesDef**, this->buffer_);
     
     for (CORBA::ULong i = nl; i < ol; ++i)
     {
       CORBA::release (tmp[i]);
-      tmp[i] = IR::ProvidesDef::_nil ();
+      tmp[i] = IR_ProvidesDef::_nil ();
     }
   }
   void 
-  IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_downcast (
+  _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_downcast (
       void* target,
       CORBA_Object *src,
       CORBA_Environment &ACE_TRY_ENV
     )
   {
-    IR::ProvidesDef **tmp = ACE_static_cast (IR::ProvidesDef**, target);
-    *tmp = IR::ProvidesDef::_narrow (src, ACE_TRY_ENV);
+    IR_ProvidesDef **tmp = ACE_static_cast (IR_ProvidesDef**, target);
+    *tmp = IR_ProvidesDef::_narrow (src, ACE_TRY_ENV);
   }
 
   CORBA_Object*
-  IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_upcast (void *src) const
+  _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_upcast (void *src) const
   {
-    IR::ProvidesDef **tmp = ACE_static_cast (IR::ProvidesDef**, src);
+    IR_ProvidesDef **tmp = ACE_static_cast (IR_ProvidesDef**, src);
     return *tmp;
   }
   
-#endif /* end #if !defined */
-
-
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 
-#if !defined (_IR_PROVIDESDEFSEQ_CS_)
-#define _IR_PROVIDESDEFSEQ_CS_
-
 // *************************************************************
-// IR::ProvidesDefSeq
+// IR_ProvidesDefSeq
 // *************************************************************
 
-IR::ProvidesDefSeq::ProvidesDefSeq (void)
+IR_ProvidesDefSeq::IR_ProvidesDefSeq (void)
 {}
-IR::ProvidesDefSeq::ProvidesDefSeq (CORBA::ULong max) // uses max size
+IR_ProvidesDefSeq::IR_ProvidesDefSeq (CORBA::ULong max) // uses max size
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::ProvidesDef,IR::ProvidesDef_var>
+  TAO_Unbounded_Object_Sequence<IR_ProvidesDef,IR_ProvidesDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max)
 {}
-IR::ProvidesDefSeq::ProvidesDefSeq (CORBA::ULong max, CORBA::ULong length, IR::ProvidesDef_ptr *buffer, CORBA::Boolean release)
+IR_ProvidesDefSeq::IR_ProvidesDefSeq (CORBA::ULong max, CORBA::ULong length, IR_ProvidesDef_ptr *buffer, CORBA::Boolean release)
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::ProvidesDef,IR::ProvidesDef_var>
+  TAO_Unbounded_Object_Sequence<IR_ProvidesDef,IR_ProvidesDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max, length, buffer, release)
 {}
-IR::ProvidesDefSeq::ProvidesDefSeq (const ProvidesDefSeq &seq) // copy ctor
+IR_ProvidesDefSeq::IR_ProvidesDefSeq (const IR_ProvidesDefSeq &seq) // copy ctor
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::ProvidesDef,IR::ProvidesDef_var>
+  TAO_Unbounded_Object_Sequence<IR_ProvidesDef,IR_ProvidesDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (seq)
 {}
-IR::ProvidesDefSeq::~ProvidesDefSeq (void) // dtor
+IR_ProvidesDefSeq::~IR_ProvidesDefSeq (void) // dtor
 {}
-void IR::ProvidesDefSeq::_tao_any_destructor (void *x)
+void IR_ProvidesDefSeq::_tao_any_destructor (void *x)
 {
-  ProvidesDefSeq *tmp = ACE_static_cast (ProvidesDefSeq*,x);
+  IR_ProvidesDefSeq *tmp = ACE_static_cast (IR_ProvidesDefSeq*,x);
   delete tmp;
 }
 
-
-#endif /* end #if !defined */
-
 static const CORBA::Long _oc_IR_ProvidesDefSeq[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
   34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657344), ACE_NTOHL (0x65665365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ProvidesDefSeq:1.0
-  15, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65710000),  // name = ProvidesDefSeq
+  15, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65710000),  // name = IR_ProvidesDefSeq
   CORBA::tk_sequence, // typecode kind
   72, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
@@ -4265,12 +2209,12 @@
     56, // encapsulation length
       TAO_ENCAP_BYTE_ORDER, // byte order
       31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDef:1.0
-      12, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44656600),  // name = ProvidesDef
+      12, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44656600),  // name = IR_ProvidesDef
 
     0U,
 
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_ProvidesDefSeq (CORBA::tk_alias, sizeof (_oc_IR_ProvidesDefSeq), (char *) &_oc_IR_ProvidesDefSeq, 0, sizeof (IR::ProvidesDefSeq));
+static CORBA::TypeCode _tc_TAO_tc_IR_ProvidesDefSeq (CORBA::tk_alias, sizeof (_oc_IR_ProvidesDefSeq), (char *) &_oc_IR_ProvidesDefSeq, 0, sizeof (IR_ProvidesDefSeq));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
 TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ProvidesDefSeq, &_tc_TAO_tc_IR_ProvidesDefSeq)
@@ -4278,22 +2222,19 @@
 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   
-#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_USESDEFSEQ_CS_)
-#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_USESDEFSEQ_CS_
-
   // The Base_Sequence functions, please see tao/Sequence.h
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_allocate_buffer (CORBA::ULong length)
+  _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_allocate_buffer (CORBA::ULong length)
   {
-    IR::UsesDef **tmp = 0;
+    IR_UsesDef **tmp = 0;
     tmp = _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::allocbuf (length);
     
     if (this->buffer_ != 0)
     {
-      IR::UsesDef **old = ACE_reinterpret_cast (IR::UsesDef**, this->buffer_);
+      IR_UsesDef **old = ACE_reinterpret_cast (IR_UsesDef**, this->buffer_);
       for (CORBA::ULong i = 0; i < this->length_; ++i)
         if (!this->release_)
-          tmp[i] = IR::UsesDef::_duplicate (old[i]);
+          tmp[i] = IR_UsesDef::_duplicate (old[i]);
         else
           tmp[i] = old[i];
         
@@ -4305,111 +2246,102 @@
   }
   
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_deallocate_buffer (void)
+  _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_deallocate_buffer (void)
   {
     if (this->buffer_ == 0 || this->release_ == 0)
       return;
-    IR::UsesDef **tmp = ACE_reinterpret_cast (IR::UsesDef**, this->buffer_);
+    IR_UsesDef **tmp = ACE_reinterpret_cast (IR_UsesDef**, this->buffer_);
     for (CORBA::ULong i = 0; i < this->length_; ++i)
     {
       CORBA::release (tmp[i]);
-      tmp[i] = IR::UsesDef::_nil ();
+      tmp[i] = IR_UsesDef::_nil ();
     }
     _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::freebuf (tmp);
     this->buffer_ = 0;
   }
   
-  IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::~_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq (void)
+  _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::~_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq (void)
   {
     this->_deallocate_buffer ();
   }
   
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
+  _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
   {
-    IR::UsesDef **tmp = ACE_reinterpret_cast (IR::UsesDef**, this->buffer_);
+    IR_UsesDef **tmp = ACE_reinterpret_cast (IR_UsesDef**, this->buffer_);
     
     for (CORBA::ULong i = nl; i < ol; ++i)
     {
       CORBA::release (tmp[i]);
-      tmp[i] = IR::UsesDef::_nil ();
+      tmp[i] = IR_UsesDef::_nil ();
     }
   }
   void 
-  IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_downcast (
+  _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_downcast (
       void* target,
       CORBA_Object *src,
       CORBA_Environment &ACE_TRY_ENV
     )
   {
-    IR::UsesDef **tmp = ACE_static_cast (IR::UsesDef**, target);
-    *tmp = IR::UsesDef::_narrow (src, ACE_TRY_ENV);
+    IR_UsesDef **tmp = ACE_static_cast (IR_UsesDef**, target);
+    *tmp = IR_UsesDef::_narrow (src, ACE_TRY_ENV);
   }
 
   CORBA_Object*
-  IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_upcast (void *src) const
+  _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_upcast (void *src) const
   {
-    IR::UsesDef **tmp = ACE_static_cast (IR::UsesDef**, src);
+    IR_UsesDef **tmp = ACE_static_cast (IR_UsesDef**, src);
     return *tmp;
   }
   
-#endif /* end #if !defined */
-
-
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 
-#if !defined (_IR_USESDEFSEQ_CS_)
-#define _IR_USESDEFSEQ_CS_
-
 // *************************************************************
-// IR::UsesDefSeq
+// IR_UsesDefSeq
 // *************************************************************
 
-IR::UsesDefSeq::UsesDefSeq (void)
+IR_UsesDefSeq::IR_UsesDefSeq (void)
 {}
-IR::UsesDefSeq::UsesDefSeq (CORBA::ULong max) // uses max size
+IR_UsesDefSeq::IR_UsesDefSeq (CORBA::ULong max) // uses max size
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::UsesDef,IR::UsesDef_var>
+  TAO_Unbounded_Object_Sequence<IR_UsesDef,IR_UsesDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max)
 {}
-IR::UsesDefSeq::UsesDefSeq (CORBA::ULong max, CORBA::ULong length, IR::UsesDef_ptr *buffer, CORBA::Boolean release)
+IR_UsesDefSeq::IR_UsesDefSeq (CORBA::ULong max, CORBA::ULong length, IR_UsesDef_ptr *buffer, CORBA::Boolean release)
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::UsesDef,IR::UsesDef_var>
+  TAO_Unbounded_Object_Sequence<IR_UsesDef,IR_UsesDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max, length, buffer, release)
 {}
-IR::UsesDefSeq::UsesDefSeq (const UsesDefSeq &seq) // copy ctor
+IR_UsesDefSeq::IR_UsesDefSeq (const IR_UsesDefSeq &seq) // copy ctor
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::UsesDef,IR::UsesDef_var>
+  TAO_Unbounded_Object_Sequence<IR_UsesDef,IR_UsesDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (seq)
 {}
-IR::UsesDefSeq::~UsesDefSeq (void) // dtor
+IR_UsesDefSeq::~IR_UsesDefSeq (void) // dtor
 {}
-void IR::UsesDefSeq::_tao_any_destructor (void *x)
+void IR_UsesDefSeq::_tao_any_destructor (void *x)
 {
-  UsesDefSeq *tmp = ACE_static_cast (UsesDefSeq*,x);
+  IR_UsesDefSeq *tmp = ACE_static_cast (IR_UsesDefSeq*,x);
   delete tmp;
 }
 
-
-#endif /* end #if !defined */
-
 static const CORBA::Long _oc_IR_UsesDefSeq[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
   30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x73657344), ACE_NTOHL (0x65665365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/UsesDefSeq:1.0
-  11, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65710000),  // name = UsesDefSeq
+  11, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65710000),  // name = IR_UsesDefSeq
   CORBA::tk_sequence, // typecode kind
   64, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
@@ -4417,12 +2349,12 @@
     48, // encapsulation length
       TAO_ENCAP_BYTE_ORDER, // byte order
       27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x73657344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDef:1.0
-      8, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44656600),  // name = UsesDef
+      8, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44656600),  // name = IR_UsesDef
 
     0U,
 
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_UsesDefSeq (CORBA::tk_alias, sizeof (_oc_IR_UsesDefSeq), (char *) &_oc_IR_UsesDefSeq, 0, sizeof (IR::UsesDefSeq));
+static CORBA::TypeCode _tc_TAO_tc_IR_UsesDefSeq (CORBA::tk_alias, sizeof (_oc_IR_UsesDefSeq), (char *) &_oc_IR_UsesDefSeq, 0, sizeof (IR_UsesDefSeq));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
 TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UsesDefSeq, &_tc_TAO_tc_IR_UsesDefSeq)
@@ -4430,22 +2362,19 @@
 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   
-#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_HOMEDEFSEQ_CS_)
-#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_HOMEDEFSEQ_CS_
-
   // The Base_Sequence functions, please see tao/Sequence.h
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_allocate_buffer (CORBA::ULong length)
+  _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_allocate_buffer (CORBA::ULong length)
   {
-    IR::HomeDef **tmp = 0;
+    IR_HomeDef **tmp = 0;
     tmp = _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::allocbuf (length);
     
     if (this->buffer_ != 0)
     {
-      IR::HomeDef **old = ACE_reinterpret_cast (IR::HomeDef**, this->buffer_);
+      IR_HomeDef **old = ACE_reinterpret_cast (IR_HomeDef**, this->buffer_);
       for (CORBA::ULong i = 0; i < this->length_; ++i)
         if (!this->release_)
-          tmp[i] = IR::HomeDef::_duplicate (old[i]);
+          tmp[i] = IR_HomeDef::_duplicate (old[i]);
         else
           tmp[i] = old[i];
         
@@ -4457,111 +2386,102 @@
   }
   
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_deallocate_buffer (void)
+  _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_deallocate_buffer (void)
   {
     if (this->buffer_ == 0 || this->release_ == 0)
       return;
-    IR::HomeDef **tmp = ACE_reinterpret_cast (IR::HomeDef**, this->buffer_);
+    IR_HomeDef **tmp = ACE_reinterpret_cast (IR_HomeDef**, this->buffer_);
     for (CORBA::ULong i = 0; i < this->length_; ++i)
     {
       CORBA::release (tmp[i]);
-      tmp[i] = IR::HomeDef::_nil ();
+      tmp[i] = IR_HomeDef::_nil ();
     }
     _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::freebuf (tmp);
     this->buffer_ = 0;
   }
   
-  IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::~_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq (void)
+  _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::~_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq (void)
   {
     this->_deallocate_buffer ();
   }
   
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
+  _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
   {
-    IR::HomeDef **tmp = ACE_reinterpret_cast (IR::HomeDef**, this->buffer_);
+    IR_HomeDef **tmp = ACE_reinterpret_cast (IR_HomeDef**, this->buffer_);
     
     for (CORBA::ULong i = nl; i < ol; ++i)
     {
       CORBA::release (tmp[i]);
-      tmp[i] = IR::HomeDef::_nil ();
+      tmp[i] = IR_HomeDef::_nil ();
     }
   }
   void 
-  IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_downcast (
+  _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_downcast (
       void* target,
       CORBA_Object *src,
       CORBA_Environment &ACE_TRY_ENV
     )
   {
-    IR::HomeDef **tmp = ACE_static_cast (IR::HomeDef**, target);
-    *tmp = IR::HomeDef::_narrow (src, ACE_TRY_ENV);
+    IR_HomeDef **tmp = ACE_static_cast (IR_HomeDef**, target);
+    *tmp = IR_HomeDef::_narrow (src, ACE_TRY_ENV);
   }
 
   CORBA_Object*
-  IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_upcast (void *src) const
+  _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_upcast (void *src) const
   {
-    IR::HomeDef **tmp = ACE_static_cast (IR::HomeDef**, src);
+    IR_HomeDef **tmp = ACE_static_cast (IR_HomeDef**, src);
     return *tmp;
   }
   
-#endif /* end #if !defined */
-
-
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 
-#if !defined (_IR_HOMEDEFSEQ_CS_)
-#define _IR_HOMEDEFSEQ_CS_
-
 // *************************************************************
-// IR::HomeDefSeq
+// IR_HomeDefSeq
 // *************************************************************
 
-IR::HomeDefSeq::HomeDefSeq (void)
+IR_HomeDefSeq::IR_HomeDefSeq (void)
 {}
-IR::HomeDefSeq::HomeDefSeq (CORBA::ULong max) // uses max size
+IR_HomeDefSeq::IR_HomeDefSeq (CORBA::ULong max) // uses max size
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::HomeDef,IR::HomeDef_var>
+  TAO_Unbounded_Object_Sequence<IR_HomeDef,IR_HomeDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max)
 {}
-IR::HomeDefSeq::HomeDefSeq (CORBA::ULong max, CORBA::ULong length, IR::HomeDef_ptr *buffer, CORBA::Boolean release)
+IR_HomeDefSeq::IR_HomeDefSeq (CORBA::ULong max, CORBA::ULong length, IR_HomeDef_ptr *buffer, CORBA::Boolean release)
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::HomeDef,IR::HomeDef_var>
+  TAO_Unbounded_Object_Sequence<IR_HomeDef,IR_HomeDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max, length, buffer, release)
 {}
-IR::HomeDefSeq::HomeDefSeq (const HomeDefSeq &seq) // copy ctor
+IR_HomeDefSeq::IR_HomeDefSeq (const IR_HomeDefSeq &seq) // copy ctor
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::HomeDef,IR::HomeDef_var>
+  TAO_Unbounded_Object_Sequence<IR_HomeDef,IR_HomeDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (seq)
 {}
-IR::HomeDefSeq::~HomeDefSeq (void) // dtor
+IR_HomeDefSeq::~IR_HomeDefSeq (void) // dtor
 {}
-void IR::HomeDefSeq::_tao_any_destructor (void *x)
+void IR_HomeDefSeq::_tao_any_destructor (void *x)
 {
-  HomeDefSeq *tmp = ACE_static_cast (HomeDefSeq*,x);
+  IR_HomeDefSeq *tmp = ACE_static_cast (IR_HomeDefSeq*,x);
   delete tmp;
 }
 
-
-#endif /* end #if !defined */
-
 static const CORBA::Long _oc_IR_HomeDefSeq[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
   30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f48), ACE_NTOHL (0x6f6d6544), ACE_NTOHL (0x65665365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/HomeDefSeq:1.0
-  11, ACE_NTOHL (0x486f6d65), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65710000),  // name = HomeDefSeq
+  11, ACE_NTOHL (0x486f6d65), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65710000),  // name = IR_HomeDefSeq
   CORBA::tk_sequence, // typecode kind
   64, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
@@ -4569,12 +2489,12 @@
     48, // encapsulation length
       TAO_ENCAP_BYTE_ORDER, // byte order
       27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f48), ACE_NTOHL (0x6f6d6544), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/HomeDef:1.0
-      8, ACE_NTOHL (0x486f6d65), ACE_NTOHL (0x44656600),  // name = HomeDef
+      8, ACE_NTOHL (0x486f6d65), ACE_NTOHL (0x44656600),  // name = IR_HomeDef
 
     0U,
 
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_HomeDefSeq (CORBA::tk_alias, sizeof (_oc_IR_HomeDefSeq), (char *) &_oc_IR_HomeDefSeq, 0, sizeof (IR::HomeDefSeq));
+static CORBA::TypeCode _tc_TAO_tc_IR_HomeDefSeq (CORBA::tk_alias, sizeof (_oc_IR_HomeDefSeq), (char *) &_oc_IR_HomeDefSeq, 0, sizeof (IR_HomeDefSeq));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
 TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_HomeDefSeq, &_tc_TAO_tc_IR_HomeDefSeq)
@@ -4582,22 +2502,19 @@
 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   
-#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_EMITSDEFSEQ_CS_)
-#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_EMITSDEFSEQ_CS_
-
   // The Base_Sequence functions, please see tao/Sequence.h
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_allocate_buffer (CORBA::ULong length)
+  _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_allocate_buffer (CORBA::ULong length)
   {
-    IR::EmitsDef **tmp = 0;
+    IR_EmitsDef **tmp = 0;
     tmp = _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::allocbuf (length);
     
     if (this->buffer_ != 0)
     {
-      IR::EmitsDef **old = ACE_reinterpret_cast (IR::EmitsDef**, this->buffer_);
+      IR_EmitsDef **old = ACE_reinterpret_cast (IR_EmitsDef**, this->buffer_);
       for (CORBA::ULong i = 0; i < this->length_; ++i)
         if (!this->release_)
-          tmp[i] = IR::EmitsDef::_duplicate (old[i]);
+          tmp[i] = IR_EmitsDef::_duplicate (old[i]);
         else
           tmp[i] = old[i];
         
@@ -4609,111 +2526,102 @@
   }
   
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_deallocate_buffer (void)
+  _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_deallocate_buffer (void)
   {
     if (this->buffer_ == 0 || this->release_ == 0)
       return;
-    IR::EmitsDef **tmp = ACE_reinterpret_cast (IR::EmitsDef**, this->buffer_);
+    IR_EmitsDef **tmp = ACE_reinterpret_cast (IR_EmitsDef**, this->buffer_);
     for (CORBA::ULong i = 0; i < this->length_; ++i)
     {
       CORBA::release (tmp[i]);
-      tmp[i] = IR::EmitsDef::_nil ();
+      tmp[i] = IR_EmitsDef::_nil ();
     }
     _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::freebuf (tmp);
     this->buffer_ = 0;
   }
   
-  IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::~_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq (void)
+  _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::~_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq (void)
   {
     this->_deallocate_buffer ();
   }
   
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
+  _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
   {
-    IR::EmitsDef **tmp = ACE_reinterpret_cast (IR::EmitsDef**, this->buffer_);
+    IR_EmitsDef **tmp = ACE_reinterpret_cast (IR_EmitsDef**, this->buffer_);
     
     for (CORBA::ULong i = nl; i < ol; ++i)
     {
       CORBA::release (tmp[i]);
-      tmp[i] = IR::EmitsDef::_nil ();
+      tmp[i] = IR_EmitsDef::_nil ();
     }
   }
   void 
-  IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_downcast (
+  _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_downcast (
       void* target,
       CORBA_Object *src,
       CORBA_Environment &ACE_TRY_ENV
     )
   {
-    IR::EmitsDef **tmp = ACE_static_cast (IR::EmitsDef**, target);
-    *tmp = IR::EmitsDef::_narrow (src, ACE_TRY_ENV);
+    IR_EmitsDef **tmp = ACE_static_cast (IR_EmitsDef**, target);
+    *tmp = IR_EmitsDef::_narrow (src, ACE_TRY_ENV);
   }
 
   CORBA_Object*
-  IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_upcast (void *src) const
+  _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_upcast (void *src) const
   {
-    IR::EmitsDef **tmp = ACE_static_cast (IR::EmitsDef**, src);
+    IR_EmitsDef **tmp = ACE_static_cast (IR_EmitsDef**, src);
     return *tmp;
   }
   
-#endif /* end #if !defined */
-
-
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 
-#if !defined (_IR_EMITSDEFSEQ_CS_)
-#define _IR_EMITSDEFSEQ_CS_
-
 // *************************************************************
-// IR::EmitsDefSeq
+// IR_EmitsDefSeq
 // *************************************************************
 
-IR::EmitsDefSeq::EmitsDefSeq (void)
+IR_EmitsDefSeq::IR_EmitsDefSeq (void)
 {}
-IR::EmitsDefSeq::EmitsDefSeq (CORBA::ULong max) // uses max size
+IR_EmitsDefSeq::IR_EmitsDefSeq (CORBA::ULong max) // uses max size
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::EmitsDef,IR::EmitsDef_var>
+  TAO_Unbounded_Object_Sequence<IR_EmitsDef,IR_EmitsDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max)
 {}
-IR::EmitsDefSeq::EmitsDefSeq (CORBA::ULong max, CORBA::ULong length, IR::EmitsDef_ptr *buffer, CORBA::Boolean release)
+IR_EmitsDefSeq::IR_EmitsDefSeq (CORBA::ULong max, CORBA::ULong length, IR_EmitsDef_ptr *buffer, CORBA::Boolean release)
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::EmitsDef,IR::EmitsDef_var>
+  TAO_Unbounded_Object_Sequence<IR_EmitsDef,IR_EmitsDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max, length, buffer, release)
 {}
-IR::EmitsDefSeq::EmitsDefSeq (const EmitsDefSeq &seq) // copy ctor
+IR_EmitsDefSeq::IR_EmitsDefSeq (const IR_EmitsDefSeq &seq) // copy ctor
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::EmitsDef,IR::EmitsDef_var>
+  TAO_Unbounded_Object_Sequence<IR_EmitsDef,IR_EmitsDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (seq)
 {}
-IR::EmitsDefSeq::~EmitsDefSeq (void) // dtor
+IR_EmitsDefSeq::~IR_EmitsDefSeq (void) // dtor
 {}
-void IR::EmitsDefSeq::_tao_any_destructor (void *x)
+void IR_EmitsDefSeq::_tao_any_destructor (void *x)
 {
-  EmitsDefSeq *tmp = ACE_static_cast (EmitsDefSeq*,x);
+  IR_EmitsDefSeq *tmp = ACE_static_cast (IR_EmitsDefSeq*,x);
   delete tmp;
 }
 
-
-#endif /* end #if !defined */
-
 static const CORBA::Long _oc_IR_EmitsDefSeq[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
   31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x6d697473), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/EmitsDefSeq:1.0
-  12, ACE_NTOHL (0x456d6974), ACE_NTOHL (0x73446566), ACE_NTOHL (0x53657100),  // name = EmitsDefSeq
+  12, ACE_NTOHL (0x456d6974), ACE_NTOHL (0x73446566), ACE_NTOHL (0x53657100),  // name = IR_EmitsDefSeq
   CORBA::tk_sequence, // typecode kind
   68, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
@@ -4721,12 +2629,12 @@
     52, // encapsulation length
       TAO_ENCAP_BYTE_ORDER, // byte order
       28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x6d697473), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/EmitsDef:1.0
-      9, ACE_NTOHL (0x456d6974), ACE_NTOHL (0x73446566), ACE_NTOHL (0x0),  // name = EmitsDef
+      9, ACE_NTOHL (0x456d6974), ACE_NTOHL (0x73446566), ACE_NTOHL (0x0),  // name = IR_EmitsDef
 
     0U,
 
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_EmitsDefSeq (CORBA::tk_alias, sizeof (_oc_IR_EmitsDefSeq), (char *) &_oc_IR_EmitsDefSeq, 0, sizeof (IR::EmitsDefSeq));
+static CORBA::TypeCode _tc_TAO_tc_IR_EmitsDefSeq (CORBA::tk_alias, sizeof (_oc_IR_EmitsDefSeq), (char *) &_oc_IR_EmitsDefSeq, 0, sizeof (IR_EmitsDefSeq));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
 TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EmitsDefSeq, &_tc_TAO_tc_IR_EmitsDefSeq)
@@ -4734,22 +2642,19 @@
 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   
-#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_PUBLISHESDEFSEQ_CS_)
-#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_PUBLISHESDEFSEQ_CS_
-
   // The Base_Sequence functions, please see tao/Sequence.h
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_allocate_buffer (CORBA::ULong length)
+  _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_allocate_buffer (CORBA::ULong length)
   {
-    IR::PublishesDef **tmp = 0;
+    IR_PublishesDef **tmp = 0;
     tmp = _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::allocbuf (length);
     
     if (this->buffer_ != 0)
     {
-      IR::PublishesDef **old = ACE_reinterpret_cast (IR::PublishesDef**, this->buffer_);
+      IR_PublishesDef **old = ACE_reinterpret_cast (IR_PublishesDef**, this->buffer_);
       for (CORBA::ULong i = 0; i < this->length_; ++i)
         if (!this->release_)
-          tmp[i] = IR::PublishesDef::_duplicate (old[i]);
+          tmp[i] = IR_PublishesDef::_duplicate (old[i]);
         else
           tmp[i] = old[i];
         
@@ -4761,111 +2666,102 @@
   }
   
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_deallocate_buffer (void)
+  _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_deallocate_buffer (void)
   {
     if (this->buffer_ == 0 || this->release_ == 0)
       return;
-    IR::PublishesDef **tmp = ACE_reinterpret_cast (IR::PublishesDef**, this->buffer_);
+    IR_PublishesDef **tmp = ACE_reinterpret_cast (IR_PublishesDef**, this->buffer_);
     for (CORBA::ULong i = 0; i < this->length_; ++i)
     {
       CORBA::release (tmp[i]);
-      tmp[i] = IR::PublishesDef::_nil ();
+      tmp[i] = IR_PublishesDef::_nil ();
     }
     _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::freebuf (tmp);
     this->buffer_ = 0;
   }
   
-  IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::~_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq (void)
+  _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::~_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq (void)
   {
     this->_deallocate_buffer ();
   }
   
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
+  _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
   {
-    IR::PublishesDef **tmp = ACE_reinterpret_cast (IR::PublishesDef**, this->buffer_);
+    IR_PublishesDef **tmp = ACE_reinterpret_cast (IR_PublishesDef**, this->buffer_);
     
     for (CORBA::ULong i = nl; i < ol; ++i)
     {
       CORBA::release (tmp[i]);
-      tmp[i] = IR::PublishesDef::_nil ();
+      tmp[i] = IR_PublishesDef::_nil ();
     }
   }
   void 
-  IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_downcast (
+  _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_downcast (
       void* target,
       CORBA_Object *src,
       CORBA_Environment &ACE_TRY_ENV
     )
   {
-    IR::PublishesDef **tmp = ACE_static_cast (IR::PublishesDef**, target);
-    *tmp = IR::PublishesDef::_narrow (src, ACE_TRY_ENV);
+    IR_PublishesDef **tmp = ACE_static_cast (IR_PublishesDef**, target);
+    *tmp = IR_PublishesDef::_narrow (src, ACE_TRY_ENV);
   }
 
   CORBA_Object*
-  IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_upcast (void *src) const
+  _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_upcast (void *src) const
   {
-    IR::PublishesDef **tmp = ACE_static_cast (IR::PublishesDef**, src);
+    IR_PublishesDef **tmp = ACE_static_cast (IR_PublishesDef**, src);
     return *tmp;
   }
   
-#endif /* end #if !defined */
-
-
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 
-#if !defined (_IR_PUBLISHESDEFSEQ_CS_)
-#define _IR_PUBLISHESDEFSEQ_CS_
-
 // *************************************************************
-// IR::PublishesDefSeq
+// IR_PublishesDefSeq
 // *************************************************************
 
-IR::PublishesDefSeq::PublishesDefSeq (void)
+IR_PublishesDefSeq::IR_PublishesDefSeq (void)
 {}
-IR::PublishesDefSeq::PublishesDefSeq (CORBA::ULong max) // uses max size
+IR_PublishesDefSeq::IR_PublishesDefSeq (CORBA::ULong max) // uses max size
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::PublishesDef,IR::PublishesDef_var>
+  TAO_Unbounded_Object_Sequence<IR_PublishesDef,IR_PublishesDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max)
 {}
-IR::PublishesDefSeq::PublishesDefSeq (CORBA::ULong max, CORBA::ULong length, IR::PublishesDef_ptr *buffer, CORBA::Boolean release)
+IR_PublishesDefSeq::IR_PublishesDefSeq (CORBA::ULong max, CORBA::ULong length, IR_PublishesDef_ptr *buffer, CORBA::Boolean release)
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::PublishesDef,IR::PublishesDef_var>
+  TAO_Unbounded_Object_Sequence<IR_PublishesDef,IR_PublishesDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max, length, buffer, release)
 {}
-IR::PublishesDefSeq::PublishesDefSeq (const PublishesDefSeq &seq) // copy ctor
+IR_PublishesDefSeq::IR_PublishesDefSeq (const IR_PublishesDefSeq &seq) // copy ctor
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::PublishesDef,IR::PublishesDef_var>
+  TAO_Unbounded_Object_Sequence<IR_PublishesDef,IR_PublishesDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (seq)
 {}
-IR::PublishesDefSeq::~PublishesDefSeq (void) // dtor
+IR_PublishesDefSeq::~IR_PublishesDefSeq (void) // dtor
 {}
-void IR::PublishesDefSeq::_tao_any_destructor (void *x)
+void IR_PublishesDefSeq::_tao_any_destructor (void *x)
 {
-  PublishesDefSeq *tmp = ACE_static_cast (PublishesDefSeq*,x);
+  IR_PublishesDefSeq *tmp = ACE_static_cast (IR_PublishesDefSeq*,x);
   delete tmp;
 }
 
-
-#endif /* end #if !defined */
-
 static const CORBA::Long _oc_IR_PublishesDefSeq[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
   35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x75626c69), ACE_NTOHL (0x73686573), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/PublishesDefSeq:1.0
-  16, ACE_NTOHL (0x5075626c), ACE_NTOHL (0x69736865), ACE_NTOHL (0x73446566), ACE_NTOHL (0x53657100),  // name = PublishesDefSeq
+  16, ACE_NTOHL (0x5075626c), ACE_NTOHL (0x69736865), ACE_NTOHL (0x73446566), ACE_NTOHL (0x53657100),  // name = IR_PublishesDefSeq
   CORBA::tk_sequence, // typecode kind
   76, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
@@ -4873,12 +2769,12 @@
     60, // encapsulation length
       TAO_ENCAP_BYTE_ORDER, // byte order
       32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x75626c69), ACE_NTOHL (0x73686573), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/PublishesDef:1.0
-      13, ACE_NTOHL (0x5075626c), ACE_NTOHL (0x69736865), ACE_NTOHL (0x73446566), ACE_NTOHL (0x0),  // name = PublishesDef
+      13, ACE_NTOHL (0x5075626c), ACE_NTOHL (0x69736865), ACE_NTOHL (0x73446566), ACE_NTOHL (0x0),  // name = IR_PublishesDef
 
     0U,
 
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_PublishesDefSeq (CORBA::tk_alias, sizeof (_oc_IR_PublishesDefSeq), (char *) &_oc_IR_PublishesDefSeq, 0, sizeof (IR::PublishesDefSeq));
+static CORBA::TypeCode _tc_TAO_tc_IR_PublishesDefSeq (CORBA::tk_alias, sizeof (_oc_IR_PublishesDefSeq), (char *) &_oc_IR_PublishesDefSeq, 0, sizeof (IR_PublishesDefSeq));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
 TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PublishesDefSeq, &_tc_TAO_tc_IR_PublishesDefSeq)
@@ -4886,22 +2782,19 @@
 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   
-#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_CONSUMESDEFSEQ_CS_)
-#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_CONSUMESDEFSEQ_CS_
-
   // The Base_Sequence functions, please see tao/Sequence.h
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_allocate_buffer (CORBA::ULong length)
+  _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_allocate_buffer (CORBA::ULong length)
   {
-    IR::ConsumesDef **tmp = 0;
+    IR_ConsumesDef **tmp = 0;
     tmp = _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::allocbuf (length);
     
     if (this->buffer_ != 0)
     {
-      IR::ConsumesDef **old = ACE_reinterpret_cast (IR::ConsumesDef**, this->buffer_);
+      IR_ConsumesDef **old = ACE_reinterpret_cast (IR_ConsumesDef**, this->buffer_);
       for (CORBA::ULong i = 0; i < this->length_; ++i)
         if (!this->release_)
-          tmp[i] = IR::ConsumesDef::_duplicate (old[i]);
+          tmp[i] = IR_ConsumesDef::_duplicate (old[i]);
         else
           tmp[i] = old[i];
         
@@ -4913,111 +2806,102 @@
   }
   
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_deallocate_buffer (void)
+  _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_deallocate_buffer (void)
   {
     if (this->buffer_ == 0 || this->release_ == 0)
       return;
-    IR::ConsumesDef **tmp = ACE_reinterpret_cast (IR::ConsumesDef**, this->buffer_);
+    IR_ConsumesDef **tmp = ACE_reinterpret_cast (IR_ConsumesDef**, this->buffer_);
     for (CORBA::ULong i = 0; i < this->length_; ++i)
     {
       CORBA::release (tmp[i]);
-      tmp[i] = IR::ConsumesDef::_nil ();
+      tmp[i] = IR_ConsumesDef::_nil ();
     }
     _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::freebuf (tmp);
     this->buffer_ = 0;
   }
   
-  IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::~_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq (void)
+  _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::~_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq (void)
   {
     this->_deallocate_buffer ();
   }
   
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
+  _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
   {
-    IR::ConsumesDef **tmp = ACE_reinterpret_cast (IR::ConsumesDef**, this->buffer_);
+    IR_ConsumesDef **tmp = ACE_reinterpret_cast (IR_ConsumesDef**, this->buffer_);
     
     for (CORBA::ULong i = nl; i < ol; ++i)
     {
       CORBA::release (tmp[i]);
-      tmp[i] = IR::ConsumesDef::_nil ();
+      tmp[i] = IR_ConsumesDef::_nil ();
     }
   }
   void 
-  IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_downcast (
+  _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_downcast (
       void* target,
       CORBA_Object *src,
       CORBA_Environment &ACE_TRY_ENV
     )
   {
-    IR::ConsumesDef **tmp = ACE_static_cast (IR::ConsumesDef**, target);
-    *tmp = IR::ConsumesDef::_narrow (src, ACE_TRY_ENV);
+    IR_ConsumesDef **tmp = ACE_static_cast (IR_ConsumesDef**, target);
+    *tmp = IR_ConsumesDef::_narrow (src, ACE_TRY_ENV);
   }
 
   CORBA_Object*
-  IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_upcast (void *src) const
+  _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_upcast (void *src) const
   {
-    IR::ConsumesDef **tmp = ACE_static_cast (IR::ConsumesDef**, src);
+    IR_ConsumesDef **tmp = ACE_static_cast (IR_ConsumesDef**, src);
     return *tmp;
   }
   
-#endif /* end #if !defined */
-
-
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 
-#if !defined (_IR_CONSUMESDEFSEQ_CS_)
-#define _IR_CONSUMESDEFSEQ_CS_
-
 // *************************************************************
-// IR::ConsumesDefSeq
+// IR_ConsumesDefSeq
 // *************************************************************
 
-IR::ConsumesDefSeq::ConsumesDefSeq (void)
+IR_ConsumesDefSeq::IR_ConsumesDefSeq (void)
 {}
-IR::ConsumesDefSeq::ConsumesDefSeq (CORBA::ULong max) // uses max size
+IR_ConsumesDefSeq::IR_ConsumesDefSeq (CORBA::ULong max) // uses max size
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::ConsumesDef,IR::ConsumesDef_var>
+  TAO_Unbounded_Object_Sequence<IR_ConsumesDef,IR_ConsumesDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max)
 {}
-IR::ConsumesDefSeq::ConsumesDefSeq (CORBA::ULong max, CORBA::ULong length, IR::ConsumesDef_ptr *buffer, CORBA::Boolean release)
+IR_ConsumesDefSeq::IR_ConsumesDefSeq (CORBA::ULong max, CORBA::ULong length, IR_ConsumesDef_ptr *buffer, CORBA::Boolean release)
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::ConsumesDef,IR::ConsumesDef_var>
+  TAO_Unbounded_Object_Sequence<IR_ConsumesDef,IR_ConsumesDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max, length, buffer, release)
 {}
-IR::ConsumesDefSeq::ConsumesDefSeq (const ConsumesDefSeq &seq) // copy ctor
+IR_ConsumesDefSeq::IR_ConsumesDefSeq (const IR_ConsumesDefSeq &seq) // copy ctor
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::ConsumesDef,IR::ConsumesDef_var>
+  TAO_Unbounded_Object_Sequence<IR_ConsumesDef,IR_ConsumesDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (seq)
 {}
-IR::ConsumesDefSeq::~ConsumesDefSeq (void) // dtor
+IR_ConsumesDefSeq::~IR_ConsumesDefSeq (void) // dtor
 {}
-void IR::ConsumesDefSeq::_tao_any_destructor (void *x)
+void IR_ConsumesDefSeq::_tao_any_destructor (void *x)
 {
-  ConsumesDefSeq *tmp = ACE_static_cast (ConsumesDefSeq*,x);
+  IR_ConsumesDefSeq *tmp = ACE_static_cast (IR_ConsumesDefSeq*,x);
   delete tmp;
 }
 
-
-#endif /* end #if !defined */
-
 static const CORBA::Long _oc_IR_ConsumesDefSeq[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
   34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7375), ACE_NTOHL (0x6d657344), ACE_NTOHL (0x65665365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ConsumesDefSeq:1.0
-  15, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x756d6573), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65710000),  // name = ConsumesDefSeq
+  15, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x756d6573), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65710000),  // name = IR_ConsumesDefSeq
   CORBA::tk_sequence, // typecode kind
   72, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
@@ -5025,12 +2909,12 @@
     56, // encapsulation length
       TAO_ENCAP_BYTE_ORDER, // byte order
       31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7375), ACE_NTOHL (0x6d657344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ConsumesDef:1.0
-      12, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x756d6573), ACE_NTOHL (0x44656600),  // name = ConsumesDef
+      12, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x756d6573), ACE_NTOHL (0x44656600),  // name = IR_ConsumesDef
 
     0U,
 
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_ConsumesDefSeq (CORBA::tk_alias, sizeof (_oc_IR_ConsumesDefSeq), (char *) &_oc_IR_ConsumesDefSeq, 0, sizeof (IR::ConsumesDefSeq));
+static CORBA::TypeCode _tc_TAO_tc_IR_ConsumesDefSeq (CORBA::tk_alias, sizeof (_oc_IR_ConsumesDefSeq), (char *) &_oc_IR_ConsumesDefSeq, 0, sizeof (IR_ConsumesDefSeq));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
 TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ConsumesDefSeq, &_tc_TAO_tc_IR_ConsumesDefSeq)
@@ -5038,22 +2922,19 @@
 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   
-#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_FACTORYDEFSEQ_CS_)
-#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_FACTORYDEFSEQ_CS_
-
   // The Base_Sequence functions, please see tao/Sequence.h
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_allocate_buffer (CORBA::ULong length)
+  _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_allocate_buffer (CORBA::ULong length)
   {
-    IR::FactoryDef **tmp = 0;
+    IR_FactoryDef **tmp = 0;
     tmp = _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::allocbuf (length);
     
     if (this->buffer_ != 0)
     {
-      IR::FactoryDef **old = ACE_reinterpret_cast (IR::FactoryDef**, this->buffer_);
+      IR_FactoryDef **old = ACE_reinterpret_cast (IR_FactoryDef**, this->buffer_);
       for (CORBA::ULong i = 0; i < this->length_; ++i)
         if (!this->release_)
-          tmp[i] = IR::FactoryDef::_duplicate (old[i]);
+          tmp[i] = IR_FactoryDef::_duplicate (old[i]);
         else
           tmp[i] = old[i];
         
@@ -5065,111 +2946,102 @@
   }
   
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_deallocate_buffer (void)
+  _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_deallocate_buffer (void)
   {
     if (this->buffer_ == 0 || this->release_ == 0)
       return;
-    IR::FactoryDef **tmp = ACE_reinterpret_cast (IR::FactoryDef**, this->buffer_);
+    IR_FactoryDef **tmp = ACE_reinterpret_cast (IR_FactoryDef**, this->buffer_);
     for (CORBA::ULong i = 0; i < this->length_; ++i)
     {
       CORBA::release (tmp[i]);
-      tmp[i] = IR::FactoryDef::_nil ();
+      tmp[i] = IR_FactoryDef::_nil ();
     }
     _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::freebuf (tmp);
     this->buffer_ = 0;
   }
   
-  IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::~_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq (void)
+  _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::~_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq (void)
   {
     this->_deallocate_buffer ();
   }
   
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
+  _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
   {
-    IR::FactoryDef **tmp = ACE_reinterpret_cast (IR::FactoryDef**, this->buffer_);
+    IR_FactoryDef **tmp = ACE_reinterpret_cast (IR_FactoryDef**, this->buffer_);
     
     for (CORBA::ULong i = nl; i < ol; ++i)
     {
       CORBA::release (tmp[i]);
-      tmp[i] = IR::FactoryDef::_nil ();
+      tmp[i] = IR_FactoryDef::_nil ();
     }
   }
   void 
-  IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_downcast (
+  _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_downcast (
       void* target,
       CORBA_Object *src,
       CORBA_Environment &ACE_TRY_ENV
     )
   {
-    IR::FactoryDef **tmp = ACE_static_cast (IR::FactoryDef**, target);
-    *tmp = IR::FactoryDef::_narrow (src, ACE_TRY_ENV);
+    IR_FactoryDef **tmp = ACE_static_cast (IR_FactoryDef**, target);
+    *tmp = IR_FactoryDef::_narrow (src, ACE_TRY_ENV);
   }
 
   CORBA_Object*
-  IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_upcast (void *src) const
+  _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_upcast (void *src) const
   {
-    IR::FactoryDef **tmp = ACE_static_cast (IR::FactoryDef**, src);
+    IR_FactoryDef **tmp = ACE_static_cast (IR_FactoryDef**, src);
     return *tmp;
   }
   
-#endif /* end #if !defined */
-
-
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 
-#if !defined (_IR_FACTORYDEFSEQ_CS_)
-#define _IR_FACTORYDEFSEQ_CS_
-
 // *************************************************************
-// IR::FactoryDefSeq
+// IR_FactoryDefSeq
 // *************************************************************
 
-IR::FactoryDefSeq::FactoryDefSeq (void)
+IR_FactoryDefSeq::IR_FactoryDefSeq (void)
 {}
-IR::FactoryDefSeq::FactoryDefSeq (CORBA::ULong max) // uses max size
+IR_FactoryDefSeq::IR_FactoryDefSeq (CORBA::ULong max) // uses max size
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::FactoryDef,IR::FactoryDef_var>
+  TAO_Unbounded_Object_Sequence<IR_FactoryDef,IR_FactoryDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max)
 {}
-IR::FactoryDefSeq::FactoryDefSeq (CORBA::ULong max, CORBA::ULong length, IR::FactoryDef_ptr *buffer, CORBA::Boolean release)
+IR_FactoryDefSeq::IR_FactoryDefSeq (CORBA::ULong max, CORBA::ULong length, IR_FactoryDef_ptr *buffer, CORBA::Boolean release)
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::FactoryDef,IR::FactoryDef_var>
+  TAO_Unbounded_Object_Sequence<IR_FactoryDef,IR_FactoryDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max, length, buffer, release)
 {}
-IR::FactoryDefSeq::FactoryDefSeq (const FactoryDefSeq &seq) // copy ctor
+IR_FactoryDefSeq::IR_FactoryDefSeq (const IR_FactoryDefSeq &seq) // copy ctor
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::FactoryDef,IR::FactoryDef_var>
+  TAO_Unbounded_Object_Sequence<IR_FactoryDef,IR_FactoryDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (seq)
 {}
-IR::FactoryDefSeq::~FactoryDefSeq (void) // dtor
+IR_FactoryDefSeq::~IR_FactoryDefSeq (void) // dtor
 {}
-void IR::FactoryDefSeq::_tao_any_destructor (void *x)
+void IR_FactoryDefSeq::_tao_any_destructor (void *x)
 {
-  FactoryDefSeq *tmp = ACE_static_cast (FactoryDefSeq*,x);
+  IR_FactoryDefSeq *tmp = ACE_static_cast (IR_FactoryDefSeq*,x);
   delete tmp;
 }
 
-
-#endif /* end #if !defined */
-
 static const CORBA::Long _oc_IR_FactoryDefSeq[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
   33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x6163746f), ACE_NTOHL (0x72794465), ACE_NTOHL (0x66536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/FactoryDefSeq:1.0
-  14, ACE_NTOHL (0x46616374), ACE_NTOHL (0x6f727944), ACE_NTOHL (0x65665365), ACE_NTOHL (0x71000000),  // name = FactoryDefSeq
+  14, ACE_NTOHL (0x46616374), ACE_NTOHL (0x6f727944), ACE_NTOHL (0x65665365), ACE_NTOHL (0x71000000),  // name = IR_FactoryDefSeq
   CORBA::tk_sequence, // typecode kind
   72, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
@@ -5177,12 +3049,12 @@
     56, // encapsulation length
       TAO_ENCAP_BYTE_ORDER, // byte order
       30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x6163746f), ACE_NTOHL (0x72794465), ACE_NTOHL (0x663a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/FactoryDef:1.0
-      11, ACE_NTOHL (0x46616374), ACE_NTOHL (0x6f727944), ACE_NTOHL (0x65660000),  // name = FactoryDef
+      11, ACE_NTOHL (0x46616374), ACE_NTOHL (0x6f727944), ACE_NTOHL (0x65660000),  // name = IR_FactoryDef
 
     0U,
 
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_FactoryDefSeq (CORBA::tk_alias, sizeof (_oc_IR_FactoryDefSeq), (char *) &_oc_IR_FactoryDefSeq, 0, sizeof (IR::FactoryDefSeq));
+static CORBA::TypeCode _tc_TAO_tc_IR_FactoryDefSeq (CORBA::tk_alias, sizeof (_oc_IR_FactoryDefSeq), (char *) &_oc_IR_FactoryDefSeq, 0, sizeof (IR_FactoryDefSeq));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
 TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FactoryDefSeq, &_tc_TAO_tc_IR_FactoryDefSeq)
@@ -5190,22 +3062,19 @@
 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   
-#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_FINDERDEFSEQ_CS_)
-#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_FINDERDEFSEQ_CS_
-
   // The Base_Sequence functions, please see tao/Sequence.h
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_allocate_buffer (CORBA::ULong length)
+  _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_allocate_buffer (CORBA::ULong length)
   {
-    IR::FinderDef **tmp = 0;
+    IR_FinderDef **tmp = 0;
     tmp = _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::allocbuf (length);
     
     if (this->buffer_ != 0)
     {
-      IR::FinderDef **old = ACE_reinterpret_cast (IR::FinderDef**, this->buffer_);
+      IR_FinderDef **old = ACE_reinterpret_cast (IR_FinderDef**, this->buffer_);
       for (CORBA::ULong i = 0; i < this->length_; ++i)
         if (!this->release_)
-          tmp[i] = IR::FinderDef::_duplicate (old[i]);
+          tmp[i] = IR_FinderDef::_duplicate (old[i]);
         else
           tmp[i] = old[i];
         
@@ -5217,111 +3086,102 @@
   }
   
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_deallocate_buffer (void)
+  _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_deallocate_buffer (void)
   {
     if (this->buffer_ == 0 || this->release_ == 0)
       return;
-    IR::FinderDef **tmp = ACE_reinterpret_cast (IR::FinderDef**, this->buffer_);
+    IR_FinderDef **tmp = ACE_reinterpret_cast (IR_FinderDef**, this->buffer_);
     for (CORBA::ULong i = 0; i < this->length_; ++i)
     {
       CORBA::release (tmp[i]);
-      tmp[i] = IR::FinderDef::_nil ();
+      tmp[i] = IR_FinderDef::_nil ();
     }
     _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::freebuf (tmp);
     this->buffer_ = 0;
   }
   
-  IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::~_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq (void)
+  _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::~_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq (void)
   {
     this->_deallocate_buffer ();
   }
   
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
+  _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
   {
-    IR::FinderDef **tmp = ACE_reinterpret_cast (IR::FinderDef**, this->buffer_);
+    IR_FinderDef **tmp = ACE_reinterpret_cast (IR_FinderDef**, this->buffer_);
     
     for (CORBA::ULong i = nl; i < ol; ++i)
     {
       CORBA::release (tmp[i]);
-      tmp[i] = IR::FinderDef::_nil ();
+      tmp[i] = IR_FinderDef::_nil ();
     }
   }
   void 
-  IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_downcast (
+  _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_downcast (
       void* target,
       CORBA_Object *src,
       CORBA_Environment &ACE_TRY_ENV
     )
   {
-    IR::FinderDef **tmp = ACE_static_cast (IR::FinderDef**, target);
-    *tmp = IR::FinderDef::_narrow (src, ACE_TRY_ENV);
+    IR_FinderDef **tmp = ACE_static_cast (IR_FinderDef**, target);
+    *tmp = IR_FinderDef::_narrow (src, ACE_TRY_ENV);
   }
 
   CORBA_Object*
-  IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_upcast (void *src) const
+  _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_upcast (void *src) const
   {
-    IR::FinderDef **tmp = ACE_static_cast (IR::FinderDef**, src);
+    IR_FinderDef **tmp = ACE_static_cast (IR_FinderDef**, src);
     return *tmp;
   }
   
-#endif /* end #if !defined */
-
-
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 
-#if !defined (_IR_FINDERDEFSEQ_CS_)
-#define _IR_FINDERDEFSEQ_CS_
-
 // *************************************************************
-// IR::FinderDefSeq
+// IR_FinderDefSeq
 // *************************************************************
 
-IR::FinderDefSeq::FinderDefSeq (void)
+IR_FinderDefSeq::IR_FinderDefSeq (void)
 {}
-IR::FinderDefSeq::FinderDefSeq (CORBA::ULong max) // uses max size
+IR_FinderDefSeq::IR_FinderDefSeq (CORBA::ULong max) // uses max size
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::FinderDef,IR::FinderDef_var>
+  TAO_Unbounded_Object_Sequence<IR_FinderDef,IR_FinderDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max)
 {}
-IR::FinderDefSeq::FinderDefSeq (CORBA::ULong max, CORBA::ULong length, IR::FinderDef_ptr *buffer, CORBA::Boolean release)
+IR_FinderDefSeq::IR_FinderDefSeq (CORBA::ULong max, CORBA::ULong length, IR_FinderDef_ptr *buffer, CORBA::Boolean release)
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::FinderDef,IR::FinderDef_var>
+  TAO_Unbounded_Object_Sequence<IR_FinderDef,IR_FinderDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max, length, buffer, release)
 {}
-IR::FinderDefSeq::FinderDefSeq (const FinderDefSeq &seq) // copy ctor
+IR_FinderDefSeq::IR_FinderDefSeq (const IR_FinderDefSeq &seq) // copy ctor
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::FinderDef,IR::FinderDef_var>
+  TAO_Unbounded_Object_Sequence<IR_FinderDef,IR_FinderDef_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (seq)
 {}
-IR::FinderDefSeq::~FinderDefSeq (void) // dtor
+IR_FinderDefSeq::~IR_FinderDefSeq (void) // dtor
 {}
-void IR::FinderDefSeq::_tao_any_destructor (void *x)
+void IR_FinderDefSeq::_tao_any_destructor (void *x)
 {
-  FinderDefSeq *tmp = ACE_static_cast (FinderDefSeq*,x);
+  IR_FinderDefSeq *tmp = ACE_static_cast (IR_FinderDefSeq*,x);
   delete tmp;
 }
 
-
-#endif /* end #if !defined */
-
 static const CORBA::Long _oc_IR_FinderDefSeq[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
   32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x696e6465), ACE_NTOHL (0x72446566), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/FinderDefSeq:1.0
-  13, ACE_NTOHL (0x46696e64), ACE_NTOHL (0x65724465), ACE_NTOHL (0x66536571), ACE_NTOHL (0x0),  // name = FinderDefSeq
+  13, ACE_NTOHL (0x46696e64), ACE_NTOHL (0x65724465), ACE_NTOHL (0x66536571), ACE_NTOHL (0x0),  // name = IR_FinderDefSeq
   CORBA::tk_sequence, // typecode kind
   72, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
@@ -5329,12 +3189,12 @@
     56, // encapsulation length
       TAO_ENCAP_BYTE_ORDER, // byte order
       29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x696e6465), ACE_NTOHL (0x72446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/FinderDef:1.0
-      10, ACE_NTOHL (0x46696e64), ACE_NTOHL (0x65724465), ACE_NTOHL (0x66000000),  // name = FinderDef
+      10, ACE_NTOHL (0x46696e64), ACE_NTOHL (0x65724465), ACE_NTOHL (0x66000000),  // name = IR_FinderDef
 
     0U,
 
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_FinderDefSeq (CORBA::tk_alias, sizeof (_oc_IR_FinderDefSeq), (char *) &_oc_IR_FinderDefSeq, 0, sizeof (IR::FinderDefSeq));
+static CORBA::TypeCode _tc_TAO_tc_IR_FinderDefSeq (CORBA::tk_alias, sizeof (_oc_IR_FinderDefSeq), (char *) &_oc_IR_FinderDefSeq, 0, sizeof (IR_FinderDefSeq));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
 TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FinderDefSeq, &_tc_TAO_tc_IR_FinderDefSeq)
@@ -5342,22 +3202,19 @@
 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   
-#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_CONTAINEDSEQ_CS_)
-#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_CONTAINEDSEQ_CS_
-
   // The Base_Sequence functions, please see tao/Sequence.h
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_ContainedSeq::_allocate_buffer (CORBA::ULong length)
+  _TAO_Unbounded_Object_Sequence_IR_ContainedSeq::_allocate_buffer (CORBA::ULong length)
   {
-    IR::Contained **tmp = 0;
+    IR_Contained **tmp = 0;
     tmp = _TAO_Unbounded_Object_Sequence_IR_ContainedSeq::allocbuf (length);
     
     if (this->buffer_ != 0)
     {
-      IR::Contained **old = ACE_reinterpret_cast (IR::Contained**, this->buffer_);
+      IR_Contained **old = ACE_reinterpret_cast (IR_Contained**, this->buffer_);
       for (CORBA::ULong i = 0; i < this->length_; ++i)
         if (!this->release_)
-          tmp[i] = IR::Contained::_duplicate (old[i]);
+          tmp[i] = IR_Contained::_duplicate (old[i]);
         else
           tmp[i] = old[i];
         
@@ -5369,111 +3226,102 @@
   }
   
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_ContainedSeq::_deallocate_buffer (void)
+  _TAO_Unbounded_Object_Sequence_IR_ContainedSeq::_deallocate_buffer (void)
   {
     if (this->buffer_ == 0 || this->release_ == 0)
       return;
-    IR::Contained **tmp = ACE_reinterpret_cast (IR::Contained**, this->buffer_);
+    IR_Contained **tmp = ACE_reinterpret_cast (IR_Contained**, this->buffer_);
     for (CORBA::ULong i = 0; i < this->length_; ++i)
     {
       CORBA::release (tmp[i]);
-      tmp[i] = IR::Contained::_nil ();
+      tmp[i] = IR_Contained::_nil ();
     }
     _TAO_Unbounded_Object_Sequence_IR_ContainedSeq::freebuf (tmp);
     this->buffer_ = 0;
   }
   
-  IR::_TAO_Unbounded_Object_Sequence_IR_ContainedSeq::~_TAO_Unbounded_Object_Sequence_IR_ContainedSeq (void)
+  _TAO_Unbounded_Object_Sequence_IR_ContainedSeq::~_TAO_Unbounded_Object_Sequence_IR_ContainedSeq (void)
   {
     this->_deallocate_buffer ();
   }
   
   void
-  IR::_TAO_Unbounded_Object_Sequence_IR_ContainedSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
+  _TAO_Unbounded_Object_Sequence_IR_ContainedSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
   {
-    IR::Contained **tmp = ACE_reinterpret_cast (IR::Contained**, this->buffer_);
+    IR_Contained **tmp = ACE_reinterpret_cast (IR_Contained**, this->buffer_);
     
     for (CORBA::ULong i = nl; i < ol; ++i)
     {
       CORBA::release (tmp[i]);
-      tmp[i] = IR::Contained::_nil ();
+      tmp[i] = IR_Contained::_nil ();
     }
   }
   void 
-  IR::_TAO_Unbounded_Object_Sequence_IR_ContainedSeq::_downcast (
+  _TAO_Unbounded_Object_Sequence_IR_ContainedSeq::_downcast (
       void* target,
       CORBA_Object *src,
       CORBA_Environment &ACE_TRY_ENV
     )
   {
-    IR::Contained **tmp = ACE_static_cast (IR::Contained**, target);
-    *tmp = IR::Contained::_narrow (src, ACE_TRY_ENV);
+    IR_Contained **tmp = ACE_static_cast (IR_Contained**, target);
+    *tmp = IR_Contained::_narrow (src, ACE_TRY_ENV);
   }
 
   CORBA_Object*
-  IR::_TAO_Unbounded_Object_Sequence_IR_ContainedSeq::_upcast (void *src) const
+  _TAO_Unbounded_Object_Sequence_IR_ContainedSeq::_upcast (void *src) const
   {
-    IR::Contained **tmp = ACE_static_cast (IR::Contained**, src);
+    IR_Contained **tmp = ACE_static_cast (IR_Contained**, src);
     return *tmp;
   }
   
-#endif /* end #if !defined */
-
-
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 
-#if !defined (_IR_CONTAINEDSEQ_CS_)
-#define _IR_CONTAINEDSEQ_CS_
-
 // *************************************************************
-// IR::ContainedSeq
+// IR_ContainedSeq
 // *************************************************************
 
-IR::ContainedSeq::ContainedSeq (void)
+IR_ContainedSeq::IR_ContainedSeq (void)
 {}
-IR::ContainedSeq::ContainedSeq (CORBA::ULong max) // uses max size
+IR_ContainedSeq::IR_ContainedSeq (CORBA::ULong max) // uses max size
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_ContainedSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::Contained,IR::Contained_var>
+  TAO_Unbounded_Object_Sequence<IR_Contained,IR_Contained_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max)
 {}
-IR::ContainedSeq::ContainedSeq (CORBA::ULong max, CORBA::ULong length, IR::Contained_ptr *buffer, CORBA::Boolean release)
+IR_ContainedSeq::IR_ContainedSeq (CORBA::ULong max, CORBA::ULong length, IR_Contained_ptr *buffer, CORBA::Boolean release)
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_ContainedSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::Contained,IR::Contained_var>
+  TAO_Unbounded_Object_Sequence<IR_Contained,IR_Contained_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max, length, buffer, release)
 {}
-IR::ContainedSeq::ContainedSeq (const ContainedSeq &seq) // copy ctor
+IR_ContainedSeq::IR_ContainedSeq (const IR_ContainedSeq &seq) // copy ctor
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Object_Sequence_IR_ContainedSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::Contained,IR::Contained_var>
+  TAO_Unbounded_Object_Sequence<IR_Contained,IR_Contained_var>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (seq)
 {}
-IR::ContainedSeq::~ContainedSeq (void) // dtor
+IR_ContainedSeq::~IR_ContainedSeq (void) // dtor
 {}
-void IR::ContainedSeq::_tao_any_destructor (void *x)
+void IR_ContainedSeq::_tao_any_destructor (void *x)
 {
-  ContainedSeq *tmp = ACE_static_cast (ContainedSeq*,x);
+  IR_ContainedSeq *tmp = ACE_static_cast (IR_ContainedSeq*,x);
   delete tmp;
 }
 
-
-#endif /* end #if !defined */
-
 static const CORBA::Long _oc_IR_ContainedSeq[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
   32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7461), ACE_NTOHL (0x696e6564), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ContainedSeq:1.0
-  13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContainedSeq
+  13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = IR_ContainedSeq
   CORBA::tk_sequence, // typecode kind
   72, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
@@ -5481,21 +3329,22 @@
     56, // encapsulation length
       TAO_ENCAP_BYTE_ORDER, // byte order
       29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7461), ACE_NTOHL (0x696e6564), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/Contained:1.0
-      10, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x64000000),  // name = Contained
+      10, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x64000000),  // name = IR_Contained
 
     0U,
 
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_ContainedSeq (CORBA::tk_alias, sizeof (_oc_IR_ContainedSeq), (char *) &_oc_IR_ContainedSeq, 0, sizeof (IR::ContainedSeq));
+static CORBA::TypeCode _tc_TAO_tc_IR_ContainedSeq (CORBA::tk_alias, sizeof (_oc_IR_ContainedSeq), (char *) &_oc_IR_ContainedSeq, 0, sizeof (IR_ContainedSeq));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
 TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ContainedSeq, &_tc_TAO_tc_IR_ContainedSeq)
 TAO_NAMESPACE_END
+
 static const CORBA::Long _oc_IR_StructMember[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
   32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x744d656d), ACE_NTOHL (0x6265723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/StructMember:1.0
-  13, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x0),  // name = StructMember
+  13, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x0),  // name = IR_StructMember
   3, // member count
   5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
   CORBA::tk_alias, // typecode kind for typedefs
@@ -5514,35 +3363,32 @@
   48, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
     27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
-    8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType
+    8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType
 
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_StructMember (CORBA::tk_struct, sizeof (_oc_IR_StructMember), (char *) &_oc_IR_StructMember, 0, sizeof (IR::StructMember));
+static CORBA::TypeCode _tc_TAO_tc_IR_StructMember (CORBA::tk_struct, sizeof (_oc_IR_StructMember), (char *) &_oc_IR_StructMember, 0, sizeof (IR_StructMember));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
 TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_StructMember, &_tc_TAO_tc_IR_StructMember)
 TAO_NAMESPACE_END
-void IR::StructMember::_tao_any_destructor (void *x)
+
+void IR_StructMember::_tao_any_destructor (void *x)
 {
-  StructMember *tmp = ACE_static_cast (StructMember*,x);
+  IR_StructMember *tmp = ACE_static_cast (IR_StructMember*,x);
   delete tmp;
 }
 
-
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   
-#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_STRUCTMEMBERSEQ_CS_)
-#define __TAO_UNBOUNDED_SEQUENCE_IR_STRUCTMEMBERSEQ_CS_
-
   void
-  IR::_TAO_Unbounded_Sequence_IR_StructMemberSeq::_allocate_buffer (CORBA::ULong length)
+  _TAO_Unbounded_Sequence_IR_StructMemberSeq::_allocate_buffer (CORBA::ULong length)
   {
-    IR::StructMember* tmp = 0;
+    IR_StructMember* tmp = 0;
     tmp = _TAO_Unbounded_Sequence_IR_StructMemberSeq::allocbuf (length);
     
     if (this->buffer_ != 0)
     {
-      IR::StructMember *old = ACE_reinterpret_cast (IR::StructMember *,this->buffer_);
+      IR_StructMember *old = ACE_reinterpret_cast (IR_StructMember *,this->buffer_);
       
       for (CORBA::ULong i = 0; i < this->length_; ++i)
         tmp[i] = old[i];
@@ -5555,80 +3401,70 @@
   }
   
   void
-  IR::_TAO_Unbounded_Sequence_IR_StructMemberSeq::_deallocate_buffer (void)
+  _TAO_Unbounded_Sequence_IR_StructMemberSeq::_deallocate_buffer (void)
   {
     if (this->buffer_ == 0 || this->release_ == 0)
       return;
     
-    IR::StructMember *tmp = ACE_reinterpret_cast (IR::StructMember *,this->buffer_);
+    IR_StructMember *tmp = ACE_reinterpret_cast (IR_StructMember *,this->buffer_);
     
     _TAO_Unbounded_Sequence_IR_StructMemberSeq::freebuf (tmp);
     this->buffer_ = 0;
   } 
   
-  IR::_TAO_Unbounded_Sequence_IR_StructMemberSeq::~_TAO_Unbounded_Sequence_IR_StructMemberSeq (void) // Dtor.
+  _TAO_Unbounded_Sequence_IR_StructMemberSeq::~_TAO_Unbounded_Sequence_IR_StructMemberSeq (void) // Dtor.
   {
     this->_deallocate_buffer ();
   }
   
-  
-#endif /* end #if !defined */
-
-
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 
-#if !defined (_IR_STRUCTMEMBERSEQ_CS_)
-#define _IR_STRUCTMEMBERSEQ_CS_
-
 // *************************************************************
-// IR::StructMemberSeq
+// IR_StructMemberSeq
 // *************************************************************
 
-IR::StructMemberSeq::StructMemberSeq (void)
+IR_StructMemberSeq::IR_StructMemberSeq (void)
 {}
-IR::StructMemberSeq::StructMemberSeq (CORBA::ULong max) // uses max size
+IR_StructMemberSeq::IR_StructMemberSeq (CORBA::ULong max) // uses max size
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Sequence_IR_StructMemberSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::StructMember>
+  TAO_Unbounded_Sequence<IR_StructMember>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max)
 {}
-IR::StructMemberSeq::StructMemberSeq (CORBA::ULong max, CORBA::ULong length, IR::StructMember *buffer, CORBA::Boolean release)
+IR_StructMemberSeq::IR_StructMemberSeq (CORBA::ULong max, CORBA::ULong length, IR_StructMember *buffer, CORBA::Boolean release)
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Sequence_IR_StructMemberSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::StructMember>
+  TAO_Unbounded_Sequence<IR_StructMember>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max, length, buffer, release)
 {}
-IR::StructMemberSeq::StructMemberSeq (const StructMemberSeq &seq) // copy ctor
+IR_StructMemberSeq::IR_StructMemberSeq (const IR_StructMemberSeq &seq) // copy ctor
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Sequence_IR_StructMemberSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::StructMember>
+  TAO_Unbounded_Sequence<IR_StructMember>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (seq)
 {}
-IR::StructMemberSeq::~StructMemberSeq (void) // dtor
+IR_StructMemberSeq::~IR_StructMemberSeq (void) // dtor
 {}
-void IR::StructMemberSeq::_tao_any_destructor (void *x)
+void IR_StructMemberSeq::_tao_any_destructor (void *x)
 {
-  StructMemberSeq *tmp = ACE_static_cast (StructMemberSeq*,x);
+  IR_StructMemberSeq *tmp = ACE_static_cast (IR_StructMemberSeq*,x);
   delete tmp;
 }
 
-
-#endif /* end #if !defined */
-
 static const CORBA::Long _oc_IR_StructMemberSeq[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
   35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x744d656d), ACE_NTOHL (0x62657253), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/StructMemberSeq:1.0
-  16, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x53657100),  // name = StructMemberSeq
+  16, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x53657100),  // name = IR_StructMemberSeq
   CORBA::tk_sequence, // typecode kind
   252, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
@@ -5636,7 +3472,7 @@
     236, // encapsulation length
       TAO_ENCAP_BYTE_ORDER, // byte order
       32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x744d656d), ACE_NTOHL (0x6265723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/StructMember:1.0
-      13, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x0),  // name = StructMember
+      13, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x0),  // name = IR_StructMember
       3, // member count
       5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
       CORBA::tk_alias, // typecode kind for typedefs
@@ -5655,29 +3491,30 @@
       48, // encapsulation length
         TAO_ENCAP_BYTE_ORDER, // byte order
         27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
-        8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType
+        8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType
 
 
     0U,
 
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_StructMemberSeq (CORBA::tk_alias, sizeof (_oc_IR_StructMemberSeq), (char *) &_oc_IR_StructMemberSeq, 0, sizeof (IR::StructMemberSeq));
+static CORBA::TypeCode _tc_TAO_tc_IR_StructMemberSeq (CORBA::tk_alias, sizeof (_oc_IR_StructMemberSeq), (char *) &_oc_IR_StructMemberSeq, 0, sizeof (IR_StructMemberSeq));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
 TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_StructMemberSeq, &_tc_TAO_tc_IR_StructMemberSeq)
 TAO_NAMESPACE_END
+
 static const CORBA::Long _oc_IR_Initializer[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
   31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x616c697a), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/Initializer:1.0
-  12, ACE_NTOHL (0x496e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657200),  // name = Initializer
+  12, ACE_NTOHL (0x496e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657200),  // name = IR_Initializer
   2, // member count
   8, ACE_NTOHL (0x6d656d62), ACE_NTOHL (0x65727300),  // name = members
   CORBA::tk_alias, // typecode kind for typedefs
   324, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
     35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x744d656d), ACE_NTOHL (0x62657253), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/StructMemberSeq:1.0
-    16, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x53657100),  // name = StructMemberSeq
+    16, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x53657100),  // name = IR_StructMemberSeq
     CORBA::tk_sequence, // typecode kind
     252, // encapsulation length
       TAO_ENCAP_BYTE_ORDER, // byte order
@@ -5685,7 +3522,7 @@
       236, // encapsulation length
         TAO_ENCAP_BYTE_ORDER, // byte order
         32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x744d656d), ACE_NTOHL (0x6265723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/StructMember:1.0
-        13, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x0),  // name = StructMember
+        13, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x0),  // name = IR_StructMember
         3, // member count
         5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
         CORBA::tk_alias, // typecode kind for typedefs
@@ -5704,7 +3541,7 @@
         48, // encapsulation length
           TAO_ENCAP_BYTE_ORDER, // byte order
           27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
-          8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType
+          8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType
 
 
       0U,
@@ -5720,32 +3557,29 @@
     0U, // string length
 
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_Initializer (CORBA::tk_struct, sizeof (_oc_IR_Initializer), (char *) &_oc_IR_Initializer, 0, sizeof (IR::Initializer));
+static CORBA::TypeCode _tc_TAO_tc_IR_Initializer (CORBA::tk_struct, sizeof (_oc_IR_Initializer), (char *) &_oc_IR_Initializer, 0, sizeof (IR_Initializer));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
 TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Initializer, &_tc_TAO_tc_IR_Initializer)
 TAO_NAMESPACE_END
-void IR::Initializer::_tao_any_destructor (void *x)
+
+void IR_Initializer::_tao_any_destructor (void *x)
 {
-  Initializer *tmp = ACE_static_cast (Initializer*,x);
+  IR_Initializer *tmp = ACE_static_cast (IR_Initializer*,x);
   delete tmp;
 }
 
-
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   
-#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_INITIALIZERSEQ_CS_)
-#define __TAO_UNBOUNDED_SEQUENCE_IR_INITIALIZERSEQ_CS_
-
   void
-  IR::_TAO_Unbounded_Sequence_IR_InitializerSeq::_allocate_buffer (CORBA::ULong length)
+  _TAO_Unbounded_Sequence_IR_InitializerSeq::_allocate_buffer (CORBA::ULong length)
   {
-    IR::Initializer* tmp = 0;
+    IR_Initializer* tmp = 0;
     tmp = _TAO_Unbounded_Sequence_IR_InitializerSeq::allocbuf (length);
     
     if (this->buffer_ != 0)
     {
-      IR::Initializer *old = ACE_reinterpret_cast (IR::Initializer *,this->buffer_);
+      IR_Initializer *old = ACE_reinterpret_cast (IR_Initializer *,this->buffer_);
       
       for (CORBA::ULong i = 0; i < this->length_; ++i)
         tmp[i] = old[i];
@@ -5758,80 +3592,70 @@
   }
   
   void
-  IR::_TAO_Unbounded_Sequence_IR_InitializerSeq::_deallocate_buffer (void)
+  _TAO_Unbounded_Sequence_IR_InitializerSeq::_deallocate_buffer (void)
   {
     if (this->buffer_ == 0 || this->release_ == 0)
       return;
     
-    IR::Initializer *tmp = ACE_reinterpret_cast (IR::Initializer *,this->buffer_);
+    IR_Initializer *tmp = ACE_reinterpret_cast (IR_Initializer *,this->buffer_);
     
     _TAO_Unbounded_Sequence_IR_InitializerSeq::freebuf (tmp);
     this->buffer_ = 0;
   } 
   
-  IR::_TAO_Unbounded_Sequence_IR_InitializerSeq::~_TAO_Unbounded_Sequence_IR_InitializerSeq (void) // Dtor.
+  _TAO_Unbounded_Sequence_IR_InitializerSeq::~_TAO_Unbounded_Sequence_IR_InitializerSeq (void) // Dtor.
   {
     this->_deallocate_buffer ();
   }
   
-  
-#endif /* end #if !defined */
-
-
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 
-#if !defined (_IR_INITIALIZERSEQ_CS_)
-#define _IR_INITIALIZERSEQ_CS_
-
 // *************************************************************
-// IR::InitializerSeq
+// IR_InitializerSeq
 // *************************************************************
 
-IR::InitializerSeq::InitializerSeq (void)
+IR_InitializerSeq::IR_InitializerSeq (void)
 {}
-IR::InitializerSeq::InitializerSeq (CORBA::ULong max) // uses max size
+IR_InitializerSeq::IR_InitializerSeq (CORBA::ULong max) // uses max size
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Sequence_IR_InitializerSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::Initializer>
+  TAO_Unbounded_Sequence<IR_Initializer>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max)
 {}
-IR::InitializerSeq::InitializerSeq (CORBA::ULong max, CORBA::ULong length, IR::Initializer *buffer, CORBA::Boolean release)
+IR_InitializerSeq::IR_InitializerSeq (CORBA::ULong max, CORBA::ULong length, IR_Initializer *buffer, CORBA::Boolean release)
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Sequence_IR_InitializerSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::Initializer>
+  TAO_Unbounded_Sequence<IR_Initializer>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max, length, buffer, release)
 {}
-IR::InitializerSeq::InitializerSeq (const InitializerSeq &seq) // copy ctor
+IR_InitializerSeq::IR_InitializerSeq (const IR_InitializerSeq &seq) // copy ctor
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Sequence_IR_InitializerSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::Initializer>
+  TAO_Unbounded_Sequence<IR_Initializer>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (seq)
 {}
-IR::InitializerSeq::~InitializerSeq (void) // dtor
+IR_InitializerSeq::~IR_InitializerSeq (void) // dtor
 {}
-void IR::InitializerSeq::_tao_any_destructor (void *x)
+void IR_InitializerSeq::_tao_any_destructor (void *x)
 {
-  InitializerSeq *tmp = ACE_static_cast (InitializerSeq*,x);
+  IR_InitializerSeq *tmp = ACE_static_cast (IR_InitializerSeq*,x);
   delete tmp;
 }
 
-
-#endif /* end #if !defined */
-
 static const CORBA::Long _oc_IR_InitializerSeq[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
   34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x616c697a), ACE_NTOHL (0x65725365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/InitializerSeq:1.0
-  15, ACE_NTOHL (0x496e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657253), ACE_NTOHL (0x65710000),  // name = InitializerSeq
+  15, ACE_NTOHL (0x496e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657253), ACE_NTOHL (0x65710000),  // name = IR_InitializerSeq
   CORBA::tk_sequence, // typecode kind
   504, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
@@ -5839,14 +3663,14 @@
     488, // encapsulation length
       TAO_ENCAP_BYTE_ORDER, // byte order
       31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x616c697a), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/Initializer:1.0
-      12, ACE_NTOHL (0x496e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657200),  // name = Initializer
+      12, ACE_NTOHL (0x496e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657200),  // name = IR_Initializer
       2, // member count
       8, ACE_NTOHL (0x6d656d62), ACE_NTOHL (0x65727300),  // name = members
       CORBA::tk_alias, // typecode kind for typedefs
       324, // encapsulation length
         TAO_ENCAP_BYTE_ORDER, // byte order
         35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x744d656d), ACE_NTOHL (0x62657253), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/StructMemberSeq:1.0
-        16, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x53657100),  // name = StructMemberSeq
+        16, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x53657100),  // name = IR_StructMemberSeq
         CORBA::tk_sequence, // typecode kind
         252, // encapsulation length
           TAO_ENCAP_BYTE_ORDER, // byte order
@@ -5854,7 +3678,7 @@
           236, // encapsulation length
             TAO_ENCAP_BYTE_ORDER, // byte order
             32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x744d656d), ACE_NTOHL (0x6265723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/StructMember:1.0
-            13, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x0),  // name = StructMember
+            13, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x0),  // name = IR_StructMember
             3, // member count
             5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
             CORBA::tk_alias, // typecode kind for typedefs
@@ -5873,7 +3697,7 @@
             48, // encapsulation length
               TAO_ENCAP_BYTE_ORDER, // byte order
               27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
-              8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType
+              8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType
 
 
           0U,
@@ -5892,16 +3716,17 @@
     0U,
 
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_InitializerSeq (CORBA::tk_alias, sizeof (_oc_IR_InitializerSeq), (char *) &_oc_IR_InitializerSeq, 0, sizeof (IR::InitializerSeq));
+static CORBA::TypeCode _tc_TAO_tc_IR_InitializerSeq (CORBA::tk_alias, sizeof (_oc_IR_InitializerSeq), (char *) &_oc_IR_InitializerSeq, 0, sizeof (IR_InitializerSeq));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
 TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_InitializerSeq, &_tc_TAO_tc_IR_InitializerSeq)
 TAO_NAMESPACE_END
+
 static const CORBA::Long _oc_IR_UnionMember[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
   31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x6e696f6e), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UnionMember:1.0
-  12, ACE_NTOHL (0x556e696f), ACE_NTOHL (0x6e4d656d), ACE_NTOHL (0x62657200),  // name = UnionMember
+  12, ACE_NTOHL (0x556e696f), ACE_NTOHL (0x6e4d656d), ACE_NTOHL (0x62657200),  // name = IR_UnionMember
   4, // member count
   5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
   CORBA::tk_alias, // typecode kind for typedefs
@@ -5923,35 +3748,32 @@
   48, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
     27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
-    8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType
+    8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType
 
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_UnionMember (CORBA::tk_struct, sizeof (_oc_IR_UnionMember), (char *) &_oc_IR_UnionMember, 0, sizeof (IR::UnionMember));
+static CORBA::TypeCode _tc_TAO_tc_IR_UnionMember (CORBA::tk_struct, sizeof (_oc_IR_UnionMember), (char *) &_oc_IR_UnionMember, 0, sizeof (IR_UnionMember));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
 TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UnionMember, &_tc_TAO_tc_IR_UnionMember)
 TAO_NAMESPACE_END
-void IR::UnionMember::_tao_any_destructor (void *x)
+
+void IR_UnionMember::_tao_any_destructor (void *x)
 {
-  UnionMember *tmp = ACE_static_cast (UnionMember*,x);
+  IR_UnionMember *tmp = ACE_static_cast (IR_UnionMember*,x);
   delete tmp;
 }
 
-
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   
-#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_UNIONMEMBERSEQ_CS_)
-#define __TAO_UNBOUNDED_SEQUENCE_IR_UNIONMEMBERSEQ_CS_
-
   void
-  IR::_TAO_Unbounded_Sequence_IR_UnionMemberSeq::_allocate_buffer (CORBA::ULong length)
+  _TAO_Unbounded_Sequence_IR_UnionMemberSeq::_allocate_buffer (CORBA::ULong length)
   {
-    IR::UnionMember* tmp = 0;
+    IR_UnionMember* tmp = 0;
     tmp = _TAO_Unbounded_Sequence_IR_UnionMemberSeq::allocbuf (length);
     
     if (this->buffer_ != 0)
     {
-      IR::UnionMember *old = ACE_reinterpret_cast (IR::UnionMember *,this->buffer_);
+      IR_UnionMember *old = ACE_reinterpret_cast (IR_UnionMember *,this->buffer_);
       
       for (CORBA::ULong i = 0; i < this->length_; ++i)
         tmp[i] = old[i];
@@ -5964,80 +3786,70 @@
   }
   
   void
-  IR::_TAO_Unbounded_Sequence_IR_UnionMemberSeq::_deallocate_buffer (void)
+  _TAO_Unbounded_Sequence_IR_UnionMemberSeq::_deallocate_buffer (void)
   {
     if (this->buffer_ == 0 || this->release_ == 0)
       return;
     
-    IR::UnionMember *tmp = ACE_reinterpret_cast (IR::UnionMember *,this->buffer_);
+    IR_UnionMember *tmp = ACE_reinterpret_cast (IR_UnionMember *,this->buffer_);
     
     _TAO_Unbounded_Sequence_IR_UnionMemberSeq::freebuf (tmp);
     this->buffer_ = 0;
   } 
   
-  IR::_TAO_Unbounded_Sequence_IR_UnionMemberSeq::~_TAO_Unbounded_Sequence_IR_UnionMemberSeq (void) // Dtor.
+  _TAO_Unbounded_Sequence_IR_UnionMemberSeq::~_TAO_Unbounded_Sequence_IR_UnionMemberSeq (void) // Dtor.
   {
     this->_deallocate_buffer ();
   }
   
-  
-#endif /* end #if !defined */
-
-
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 
-#if !defined (_IR_UNIONMEMBERSEQ_CS_)
-#define _IR_UNIONMEMBERSEQ_CS_
-
 // *************************************************************
-// IR::UnionMemberSeq
+// IR_UnionMemberSeq
 // *************************************************************
 
-IR::UnionMemberSeq::UnionMemberSeq (void)
+IR_UnionMemberSeq::IR_UnionMemberSeq (void)
 {}
-IR::UnionMemberSeq::UnionMemberSeq (CORBA::ULong max) // uses max size
+IR_UnionMemberSeq::IR_UnionMemberSeq (CORBA::ULong max) // uses max size
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Sequence_IR_UnionMemberSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::UnionMember>
+  TAO_Unbounded_Sequence<IR_UnionMember>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max)
 {}
-IR::UnionMemberSeq::UnionMemberSeq (CORBA::ULong max, CORBA::ULong length, IR::UnionMember *buffer, CORBA::Boolean release)
+IR_UnionMemberSeq::IR_UnionMemberSeq (CORBA::ULong max, CORBA::ULong length, IR_UnionMember *buffer, CORBA::Boolean release)
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Sequence_IR_UnionMemberSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::UnionMember>
+  TAO_Unbounded_Sequence<IR_UnionMember>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max, length, buffer, release)
 {}
-IR::UnionMemberSeq::UnionMemberSeq (const UnionMemberSeq &seq) // copy ctor
+IR_UnionMemberSeq::IR_UnionMemberSeq (const IR_UnionMemberSeq &seq) // copy ctor
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Sequence_IR_UnionMemberSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::UnionMember>
+  TAO_Unbounded_Sequence<IR_UnionMember>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (seq)
 {}
-IR::UnionMemberSeq::~UnionMemberSeq (void) // dtor
+IR_UnionMemberSeq::~IR_UnionMemberSeq (void) // dtor
 {}
-void IR::UnionMemberSeq::_tao_any_destructor (void *x)
+void IR_UnionMemberSeq::_tao_any_destructor (void *x)
 {
-  UnionMemberSeq *tmp = ACE_static_cast (UnionMemberSeq*,x);
+  IR_UnionMemberSeq *tmp = ACE_static_cast (IR_UnionMemberSeq*,x);
   delete tmp;
 }
 
-
-#endif /* end #if !defined */
-
 static const CORBA::Long _oc_IR_UnionMemberSeq[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
   34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x6e696f6e), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65725365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/UnionMemberSeq:1.0
-  15, ACE_NTOHL (0x556e696f), ACE_NTOHL (0x6e4d656d), ACE_NTOHL (0x62657253), ACE_NTOHL (0x65710000),  // name = UnionMemberSeq
+  15, ACE_NTOHL (0x556e696f), ACE_NTOHL (0x6e4d656d), ACE_NTOHL (0x62657253), ACE_NTOHL (0x65710000),  // name = IR_UnionMemberSeq
   CORBA::tk_sequence, // typecode kind
   264, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
@@ -6045,7 +3857,7 @@
     248, // encapsulation length
       TAO_ENCAP_BYTE_ORDER, // byte order
       31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x6e696f6e), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UnionMember:1.0
-      12, ACE_NTOHL (0x556e696f), ACE_NTOHL (0x6e4d656d), ACE_NTOHL (0x62657200),  // name = UnionMember
+      12, ACE_NTOHL (0x556e696f), ACE_NTOHL (0x6e4d656d), ACE_NTOHL (0x62657200),  // name = IR_UnionMember
       4, // member count
       5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
       CORBA::tk_alias, // typecode kind for typedefs
@@ -6067,28 +3879,25 @@
       48, // encapsulation length
         TAO_ENCAP_BYTE_ORDER, // byte order
         27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
-        8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType
+        8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType
 
 
     0U,
 
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_UnionMemberSeq (CORBA::tk_alias, sizeof (_oc_IR_UnionMemberSeq), (char *) &_oc_IR_UnionMemberSeq, 0, sizeof (IR::UnionMemberSeq));
+static CORBA::TypeCode _tc_TAO_tc_IR_UnionMemberSeq (CORBA::tk_alias, sizeof (_oc_IR_UnionMemberSeq), (char *) &_oc_IR_UnionMemberSeq, 0, sizeof (IR_UnionMemberSeq));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
 TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UnionMemberSeq, &_tc_TAO_tc_IR_UnionMemberSeq)
 TAO_NAMESPACE_END
 
-#if !defined (_IR_ENUMMEMBERSEQ_CS_)
-#define _IR_ENUMMEMBERSEQ_CS_
-
 // *************************************************************
-// IR::EnumMemberSeq
+// IR_EnumMemberSeq
 // *************************************************************
 
-IR::EnumMemberSeq::EnumMemberSeq (void)
+IR_EnumMemberSeq::IR_EnumMemberSeq (void)
 {}
-IR::EnumMemberSeq::EnumMemberSeq (CORBA::ULong max) // uses max size
+IR_EnumMemberSeq::IR_EnumMemberSeq (CORBA::ULong max) // uses max size
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   TAO_Unbounded_String_Sequence
@@ -6097,7 +3906,7 @@
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max)
 {}
-IR::EnumMemberSeq::EnumMemberSeq (CORBA::ULong max, CORBA::ULong length, char * *buffer, CORBA::Boolean release)
+IR_EnumMemberSeq::IR_EnumMemberSeq (CORBA::ULong max, CORBA::ULong length, char * *buffer, CORBA::Boolean release)
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   TAO_Unbounded_String_Sequence
@@ -6106,7 +3915,7 @@
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max, length, buffer, release)
 {}
-IR::EnumMemberSeq::EnumMemberSeq (const EnumMemberSeq &seq) // copy ctor
+IR_EnumMemberSeq::IR_EnumMemberSeq (const IR_EnumMemberSeq &seq) // copy ctor
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   TAO_Unbounded_String_Sequence
@@ -6115,22 +3924,19 @@
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (seq)
 {}
-IR::EnumMemberSeq::~EnumMemberSeq (void) // dtor
+IR_EnumMemberSeq::~IR_EnumMemberSeq (void) // dtor
 {}
-void IR::EnumMemberSeq::_tao_any_destructor (void *x)
+void IR_EnumMemberSeq::_tao_any_destructor (void *x)
 {
-  EnumMemberSeq *tmp = ACE_static_cast (EnumMemberSeq*,x);
+  IR_EnumMemberSeq *tmp = ACE_static_cast (IR_EnumMemberSeq*,x);
   delete tmp;
 }
 
-
-#endif /* end #if !defined */
-
 static const CORBA::Long _oc_IR_EnumMemberSeq[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
   33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x6e756d4d), ACE_NTOHL (0x656d6265), ACE_NTOHL (0x72536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/EnumMemberSeq:1.0
-  14, ACE_NTOHL (0x456e756d), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65725365), ACE_NTOHL (0x71000000),  // name = EnumMemberSeq
+  14, ACE_NTOHL (0x456e756d), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65725365), ACE_NTOHL (0x71000000),  // name = IR_EnumMemberSeq
   CORBA::tk_sequence, // typecode kind
   80, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
@@ -6145,7 +3951,7 @@
     0U,
 
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_EnumMemberSeq (CORBA::tk_alias, sizeof (_oc_IR_EnumMemberSeq), (char *) &_oc_IR_EnumMemberSeq, 0, sizeof (IR::EnumMemberSeq));
+static CORBA::TypeCode _tc_TAO_tc_IR_EnumMemberSeq (CORBA::tk_alias, sizeof (_oc_IR_EnumMemberSeq), (char *) &_oc_IR_EnumMemberSeq, 0, sizeof (IR_EnumMemberSeq));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
 TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EnumMemberSeq, &_tc_TAO_tc_IR_EnumMemberSeq)
@@ -6155,15 +3961,15 @@
 //                Base & Remote Proxy  Implementation. 
 //
 
-IR::_TAO_Container_Proxy_Impl::_TAO_Container_Proxy_Impl (void)
+_TAO_Container_Proxy_Impl::_TAO_Container_Proxy_Impl (void)
 {}
 
-IR::_TAO_Container_Remote_Proxy_Impl::_TAO_Container_Remote_Proxy_Impl (void)
+_TAO_Container_Remote_Proxy_Impl::_TAO_Container_Remote_Proxy_Impl (void)
 {}
 
 // Remote Implementation of the IDL interface methods
 
-IR::Contained_ptr IR::_TAO_Container_Remote_Proxy_Impl::lookup (
+IR_Contained_ptr _TAO_Container_Remote_Proxy_Impl::lookup (
     CORBA_Object *_collocated_tao_target_,
     const char * search_name,
     CORBA::Environment &ACE_TRY_ENV
@@ -6171,10 +3977,9 @@
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
-{
-  
-  IR::Contained_ptr _tao_retval = IR::Contained::_nil ();
-  IR::Contained_var _tao_safe_retval (_tao_retval);
+{ 
+  IR_Contained_ptr _tao_retval = IR_Contained::_nil ();
+  IR_Contained_var _tao_safe_retval (_tao_retval);
   
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
@@ -6190,172 +3995,77 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Container::TAO_ClientRequestInfo_IR_Container_lookup ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        search_name,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << search_name)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
-              0
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::Contained_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << search_name)
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
       
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
         }
-      
-      break;
-    }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
   return _tao_safe_retval._retn ();
 }
 
-IR::ContainedSeq * IR::_TAO_Container_Remote_Proxy_Impl::contents (
+IR_ContainedSeq * _TAO_Container_Remote_Proxy_Impl::contents (
     CORBA_Object *_collocated_tao_target_,
-    IR::DefinitionKind limit_type,
+    IR_DefinitionKind limit_type,
     CORBA::Boolean exclude_inherited,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
-{
-  
-  IR::ContainedSeq *_tao_retval = 0;
-  
-  
+{ 
+  IR_ContainedSeq *_tao_retval = 0;
+   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
   
-  ACE_NEW_RETURN (_tao_retval, IR::ContainedSeq, _tao_retval);
-  IR::ContainedSeq_var _tao_safe_retval (_tao_retval);
+  ACE_NEW_RETURN (_tao_retval, IR_ContainedSeq, _tao_retval);
+  IR_ContainedSeq_var _tao_safe_retval (_tao_retval);
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
       "contents",
@@ -6364,176 +4074,80 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Container::TAO_ClientRequestInfo_IR_Container_contents ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        limit_type,
-        exclude_inherited,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << limit_type) &&
-              (_tao_out << CORBA::Any::from_boolean (exclude_inherited))
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
-              0
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::ContainedSeq * _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << limit_type) &&
+              (_tao_out << CORBA::Any::from_boolean (exclude_inherited))
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
       
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
         }
-      
-      break;
-    }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
   return _tao_safe_retval._retn ();
 }
 
-IR::ContainedSeq * IR::_TAO_Container_Remote_Proxy_Impl::lookup_name (
+IR_ContainedSeq * _TAO_Container_Remote_Proxy_Impl::lookup_name (
     CORBA_Object *_collocated_tao_target_,
     const char * search_name,
     CORBA::Long levels_to_search,
-    IR::DefinitionKind limit_type,
+    IR_DefinitionKind limit_type,
     CORBA::Boolean exclude_inherited,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
-{
-  
-  IR::ContainedSeq *_tao_retval = 0;
-  
+{ 
+  IR_ContainedSeq *_tao_retval = 0;
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-  
-  ACE_NEW_RETURN (_tao_retval, IR::ContainedSeq, _tao_retval);
-  IR::ContainedSeq_var _tao_safe_retval (_tao_retval);
+  ACE_NEW_RETURN (_tao_retval, IR_ContainedSeq, _tao_retval);
+  IR_ContainedSeq_var _tao_safe_retval (_tao_retval);
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
       "lookup_name",
@@ -6542,160 +4156,66 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Container::TAO_ClientRequestInfo_IR_Container_lookup_name ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        search_name,
-        levels_to_search,
-        limit_type,
-        exclude_inherited,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << search_name) &&
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << search_name) &&
               (_tao_out << levels_to_search) &&
               (_tao_out << limit_type) &&
               (_tao_out << CORBA::Any::from_boolean (exclude_inherited))
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
               0
             );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
                 CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                 0
               );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::ContainedSeq * _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
-IR::Container::DescriptionSeq * IR::_TAO_Container_Remote_Proxy_Impl::describe_contents (
+IR_Container::DescriptionSeq * _TAO_Container_Remote_Proxy_Impl::describe_contents (
     CORBA_Object *_collocated_tao_target_,
-    IR::DefinitionKind limit_type,
+    IR_DefinitionKind limit_type,
     CORBA::Boolean exclude_inherited,
     CORBA::Long max_returned_objs,
     CORBA::Environment &ACE_TRY_ENV
@@ -6704,17 +4224,14 @@
     CORBA::SystemException
   ))
 {
-  
-  IR::Container::DescriptionSeq *_tao_retval = 0;
-  
+  IR_Container::DescriptionSeq *_tao_retval = 0;
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
   
-  ACE_NEW_RETURN (_tao_retval, IR::Container::DescriptionSeq, _tao_retval);
-  IR::Container::DescriptionSeq_var _tao_safe_retval (_tao_retval);
+  ACE_NEW_RETURN (_tao_retval, IR_Container::DescriptionSeq, _tao_retval);
+  IR_Container::DescriptionSeq_var _tao_safe_retval (_tao_retval);
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
       "describe_contents",
@@ -6723,156 +4240,62 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Container::TAO_ClientRequestInfo_IR_Container_describe_contents ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        limit_type,
-        exclude_inherited,
-        max_returned_objs,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << limit_type) &&
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << limit_type) &&
               (_tao_out << CORBA::Any::from_boolean (exclude_inherited)) &&
               (_tao_out << max_returned_objs)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
               0
             );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
                 CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                 0
               );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::Container::DescriptionSeq * _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
+          }
+        break;
+      }
   return _tao_safe_retval._retn ();
 }
 
-IR::ModuleDef_ptr IR::_TAO_Container_Remote_Proxy_Impl::create_module (
+IR_ModuleDef_ptr _TAO_Container_Remote_Proxy_Impl::create_module (
     CORBA_Object *_collocated_tao_target_,
     const char * id,
     const char * name,
@@ -6883,16 +4306,13 @@
     CORBA::SystemException
   ))
 {
-  
-  IR::ModuleDef_ptr _tao_retval = IR::ModuleDef::_nil ();
-  IR::ModuleDef_var _tao_safe_retval (_tao_retval);
-  
+  IR_ModuleDef_ptr _tao_retval = IR_ModuleDef::_nil ();
+  IR_ModuleDef_var _tao_safe_retval (_tao_retval);
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-  
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
       "create_module",
@@ -6901,161 +4321,68 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Container::TAO_ClientRequestInfo_IR_Container_create_module ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        id,
-        name,
-        version,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << id) &&
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << id) &&
               (_tao_out << name) &&
               (_tao_out << version)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
               0
             );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
                 CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                 0
               );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::ModuleDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
-IR::ConstantDef_ptr IR::_TAO_Container_Remote_Proxy_Impl::create_constant (
+IR_ConstantDef_ptr _TAO_Container_Remote_Proxy_Impl::create_constant (
     CORBA_Object *_collocated_tao_target_,
     const char * id,
     const char * name,
     const char * version,
-    IR::IDLType_ptr type,
+    IR_IDLType_ptr type,
     const CORBA::Any & value,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -7063,15 +4390,12 @@
     CORBA::SystemException
   ))
 {
-  
-  IR::ConstantDef_ptr _tao_retval = IR::ConstantDef::_nil ();
-  IR::ConstantDef_var _tao_safe_retval (_tao_retval);
-  
+  IR_ConstantDef_ptr _tao_retval = IR_ConstantDef::_nil ();
+  IR_ConstantDef_var _tao_safe_retval (_tao_retval);
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
   
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
@@ -7081,181 +4405,83 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Container::TAO_ClientRequestInfo_IR_Container_create_constant ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        id,
-        name,
-        version,
-        type,
-        value,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << id) &&
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << id) &&
               (_tao_out << name) &&
               (_tao_out << version) &&
               (_tao_out << type) &&
               (_tao_out << value)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
               0
             );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
                 CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                 0
               );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::ConstantDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
-IR::StructDef_ptr IR::_TAO_Container_Remote_Proxy_Impl::create_struct (
+IR_StructDef_ptr _TAO_Container_Remote_Proxy_Impl::create_struct (
     CORBA_Object *_collocated_tao_target_,
     const char * id,
     const char * name,
     const char * version,
-    const IR::StructMemberSeq & members,
+    const IR_StructMemberSeq & members,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-  IR::StructDef_ptr _tao_retval = IR::StructDef::_nil ();
-  IR::StructDef_var _tao_safe_retval (_tao_retval);
-  
+  IR_StructDef_ptr _tao_retval = IR_StructDef::_nil ();
+  IR_StructDef_var _tao_safe_retval (_tao_retval);
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-  
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
       "create_struct",
@@ -7264,180 +4490,83 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Container::TAO_ClientRequestInfo_IR_Container_create_struct ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        id,
-        name,
-        version,
-        members,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << id) &&
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << id) &&
               (_tao_out << name) &&
               (_tao_out << version) &&
               (_tao_out << members)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
               0
             );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
                 CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                 0
               );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::StructDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
-IR::UnionDef_ptr IR::_TAO_Container_Remote_Proxy_Impl::create_union (
+IR_UnionDef_ptr _TAO_Container_Remote_Proxy_Impl::create_union (
     CORBA_Object *_collocated_tao_target_,
     const char * id,
     const char * name,
     const char * version,
-    IR::IDLType_ptr discriminator_type,
-    const IR::UnionMemberSeq & members,
+    IR_IDLType_ptr discriminator_type,
+    const IR_UnionMemberSeq & members,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-  IR::UnionDef_ptr _tao_retval = IR::UnionDef::_nil ();
-  IR::UnionDef_var _tao_safe_retval (_tao_retval);
-  
+  IR_UnionDef_ptr _tao_retval = IR_UnionDef::_nil ();
+  IR_UnionDef_var _tao_safe_retval (_tao_retval);
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-  
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
       "create_union",
@@ -7446,181 +4575,83 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Container::TAO_ClientRequestInfo_IR_Container_create_union ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        id,
-        name,
-        version,
-        discriminator_type,
-        members,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << id) &&
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << id) &&
               (_tao_out << name) &&
               (_tao_out << version) &&
               (_tao_out << discriminator_type) &&
               (_tao_out << members)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
               0
             );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
                 CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                 0
               );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::UnionDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
-IR::EnumDef_ptr IR::_TAO_Container_Remote_Proxy_Impl::create_enum (
+IR_EnumDef_ptr _TAO_Container_Remote_Proxy_Impl::create_enum (
     CORBA_Object *_collocated_tao_target_,
     const char * id,
     const char * name,
     const char * version,
-    const IR::EnumMemberSeq & members,
+    const IR_EnumMemberSeq & members,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-  IR::EnumDef_ptr _tao_retval = IR::EnumDef::_nil ();
-  IR::EnumDef_var _tao_safe_retval (_tao_retval);
-  
+  IR_EnumDef_ptr _tao_retval = IR_EnumDef::_nil ();
+  IR_EnumDef_var _tao_safe_retval (_tao_retval);
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-  
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
       "create_enum",
@@ -7629,179 +4660,82 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Container::TAO_ClientRequestInfo_IR_Container_create_enum ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        id,
-        name,
-        version,
-        members,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << id) &&
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << id) &&
               (_tao_out << name) &&
               (_tao_out << version) &&
               (_tao_out << members)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
               0
             );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
                 CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                 0
               );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::EnumDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
-IR::AliasDef_ptr IR::_TAO_Container_Remote_Proxy_Impl::create_alias (
+IR_AliasDef_ptr _TAO_Container_Remote_Proxy_Impl::create_alias (
     CORBA_Object *_collocated_tao_target_,
     const char * id,
     const char * name,
     const char * version,
-    IR::IDLType_ptr original_type,
+    IR_IDLType_ptr original_type,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-  IR::AliasDef_ptr _tao_retval = IR::AliasDef::_nil ();
-  IR::AliasDef_var _tao_safe_retval (_tao_retval);
-  
+  IR_AliasDef_ptr _tao_retval = IR_AliasDef::_nil ();
+  IR_AliasDef_var _tao_safe_retval (_tao_retval);
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-  
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
       "create_alias",
@@ -7810,163 +4744,69 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Container::TAO_ClientRequestInfo_IR_Container_create_alias ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        id,
-        name,
-        version,
-        original_type,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << id) &&
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << id) &&
               (_tao_out << name) &&
               (_tao_out << version) &&
               (_tao_out << original_type)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
               0
             );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
                 CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                 0
               );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::AliasDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
-IR::InterfaceDef_ptr IR::_TAO_Container_Remote_Proxy_Impl::create_interface (
+IR_InterfaceDef_ptr _TAO_Container_Remote_Proxy_Impl::create_interface (
     CORBA_Object *_collocated_tao_target_,
     const char * id,
     const char * name,
     const char * version,
-    const IR::InterfaceDefSeq & base_interfaces,
+    const IR_InterfaceDefSeq & base_interfaces,
     CORBA::Boolean is_abstract,
     CORBA::Boolean is_local,
     CORBA::Environment &ACE_TRY_ENV
@@ -7975,16 +4815,14 @@
     CORBA::SystemException
   ))
 {
-  
-  IR::InterfaceDef_ptr _tao_retval = IR::InterfaceDef::_nil ();
-  IR::InterfaceDef_var _tao_safe_retval (_tao_retval);
+  IR_InterfaceDef_ptr _tao_retval = IR_InterfaceDef::_nil ();
+  IR_InterfaceDef_var _tao_safe_retval (_tao_retval);
   
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-  
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
       "create_interface",
@@ -7993,189 +4831,90 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Container::TAO_ClientRequestInfo_IR_Container_create_interface ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        id,
-        name,
-        version,
-        base_interfaces,
-        is_abstract,
-        is_local,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << id) &&
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << id) &&
               (_tao_out << name) &&
               (_tao_out << version) &&
               (_tao_out << base_interfaces) &&
               (_tao_out << CORBA::Any::from_boolean (is_abstract)) &&
               (_tao_out << CORBA::Any::from_boolean (is_local))
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
               0
             );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
                 CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                 0
               );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::InterfaceDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
-IR::ValueDef_ptr IR::_TAO_Container_Remote_Proxy_Impl::create_value (
+IR_ValueDef_ptr _TAO_Container_Remote_Proxy_Impl::create_value (
     CORBA_Object *_collocated_tao_target_,
     const char * id,
     const char * name,
     const char * version,
     CORBA::Boolean is_custom,
     CORBA::Boolean is_abstract,
-    IR::ValueDef_ptr base_value,
+    IR_ValueDef_ptr base_value,
     CORBA::Boolean is_truncatable,
-    const IR::ValueDefSeq & abstract_base_values,
-    const IR::InterfaceDefSeq & supported_interfaces,
-    const IR::InitializerSeq & initializers,
+    const IR_ValueDefSeq & abstract_base_values,
+    const IR_InterfaceDefSeq & supported_interfaces,
+    const IR_InitializerSeq & initializers,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-  IR::ValueDef_ptr _tao_retval = IR::ValueDef::_nil ();
-  IR::ValueDef_var _tao_safe_retval (_tao_retval);
-  
+  IR_ValueDef_ptr _tao_retval = IR_ValueDef::_nil ();
+  IR_ValueDef_var _tao_safe_retval (_tao_retval);
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-  
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
       "create_value",
@@ -8184,62 +4923,22 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Container::TAO_ClientRequestInfo_IR_Container_create_value ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        id,
-        name,
-        version,
-        is_custom,
-        is_abstract,
-        base_value,
-        is_truncatable,
-        abstract_base_values,
-        supported_interfaces,
-        initializers,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << id) &&
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << id) &&
               (_tao_out << name) &&
               (_tao_out << version) &&
               (_tao_out << CORBA::Any::from_boolean (is_custom)) &&
@@ -8249,126 +4948,63 @@
               (_tao_out << abstract_base_values) &&
               (_tao_out << supported_interfaces) &&
               (_tao_out << initializers)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
               0
             );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
                 CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                 0
               );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::ValueDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
-IR::ValueBoxDef_ptr IR::_TAO_Container_Remote_Proxy_Impl::create_value_box (
+IR_ValueBoxDef_ptr _TAO_Container_Remote_Proxy_Impl::create_value_box (
     CORBA_Object *_collocated_tao_target_,
     const char * id,
     const char * name,
     const char * version,
-    IR::IDLType_ptr original_type_def,
+    IR_IDLType_ptr original_type_def,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-  IR::ValueBoxDef_ptr _tao_retval = IR::ValueBoxDef::_nil ();
-  IR::ValueBoxDef_var _tao_safe_retval (_tao_retval);
-  
+  IR_ValueBoxDef_ptr _tao_retval = IR_ValueBoxDef::_nil ();
+  IR_ValueBoxDef_var _tao_safe_retval (_tao_retval);
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-  
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
       "create_value_box",
@@ -8377,179 +5013,82 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Container::TAO_ClientRequestInfo_IR_Container_create_value_box ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        id,
-        name,
-        version,
-        original_type_def,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << id) &&
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << id) &&
               (_tao_out << name) &&
               (_tao_out << version) &&
               (_tao_out << original_type_def)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
               0
             );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
                 CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                 0
               );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::ValueBoxDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
-IR::ExceptionDef_ptr IR::_TAO_Container_Remote_Proxy_Impl::create_exception (
+IR_ExceptionDef_ptr _TAO_Container_Remote_Proxy_Impl::create_exception (
     CORBA_Object *_collocated_tao_target_,
     const char * id,
     const char * name,
     const char * version,
-    const IR::StructMemberSeq & members,
+    const IR_StructMemberSeq & members,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-  IR::ExceptionDef_ptr _tao_retval = IR::ExceptionDef::_nil ();
-  IR::ExceptionDef_var _tao_safe_retval (_tao_retval);
-  
+  IR_ExceptionDef_ptr _tao_retval = IR_ExceptionDef::_nil ();
+  IR_ExceptionDef_var _tao_safe_retval (_tao_retval);
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-  
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
       "create_exception",
@@ -8558,158 +5097,64 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Container::TAO_ClientRequestInfo_IR_Container_create_exception ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        id,
-        name,
-        version,
-        members,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << id) &&
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << id) &&
               (_tao_out << name) &&
               (_tao_out << version) &&
               (_tao_out << members)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
               0
             );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
                 CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                 0
               );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::ExceptionDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
-IR::NativeDef_ptr IR::_TAO_Container_Remote_Proxy_Impl::create_native (
+IR_NativeDef_ptr _TAO_Container_Remote_Proxy_Impl::create_native (
     CORBA_Object *_collocated_tao_target_,
     const char * id,
     const char * name,
@@ -8720,16 +5165,13 @@
     CORBA::SystemException
   ))
 {
-  
-  IR::NativeDef_ptr _tao_retval = IR::NativeDef::_nil ();
-  IR::NativeDef_var _tao_safe_retval (_tao_retval);
-  
+  IR_NativeDef_ptr _tao_retval = IR_NativeDef::_nil ();
+  IR_NativeDef_var _tao_safe_retval (_tao_retval);
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-  
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
       "create_native",
@@ -8738,152 +5180,59 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Container::TAO_ClientRequestInfo_IR_Container_create_native ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        id,
-        name,
-        version,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << id) &&
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << id) &&
               (_tao_out << name) &&
               (_tao_out << version)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
               0
             );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
                 CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                 0
               );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::NativeDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
@@ -8897,32 +5246,32 @@
 //           Remote & Base  Proxy Broker Implementation
 //
 
-IR::_TAO_Container_Proxy_Broker::_TAO_Container_Proxy_Broker (void)
+_TAO_Container_Proxy_Broker::_TAO_Container_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_Container_Proxy_Broker::~_TAO_Container_Proxy_Broker (void)
+_TAO_Container_Proxy_Broker::~_TAO_Container_Proxy_Broker (void)
 {
 }
 
-// Factory Member function Implementation.
-IR::_TAO_Container_Remote_Proxy_Broker *IR::_TAO_Container_Remote_Proxy_Broker::the_TAO_Container_Remote_Proxy_Broker (void)
+// Factory function Implementation.
+_TAO_Container_Remote_Proxy_Broker *the_TAO_Container_Remote_Proxy_Broker (void)
 {
-  static ::IR::_TAO_Container_Remote_Proxy_Broker remote_proxy_broker;
+  static ::_TAO_Container_Remote_Proxy_Broker remote_proxy_broker;
   return &remote_proxy_broker;
 }
 
-IR::_TAO_Container_Remote_Proxy_Broker::_TAO_Container_Remote_Proxy_Broker (void)
+_TAO_Container_Remote_Proxy_Broker::_TAO_Container_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_Container_Remote_Proxy_Broker::~_TAO_Container_Remote_Proxy_Broker (void)
+_TAO_Container_Remote_Proxy_Broker::~_TAO_Container_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_Container_Proxy_Impl&
-IR::_TAO_Container_Remote_Proxy_Broker::select_proxy (
-  ::IR::Container *object,
+_TAO_Container_Proxy_Impl&
+_TAO_Container_Remote_Proxy_Broker::select_proxy (
+  ::IR_Container *object,
   CORBA::Environment &ACE_TRY_ENV
 )
 {
@@ -8938,109 +5287,110 @@
 
 
 // default constructor
-IR::Container::Container (int collocated)
+IR_Container::IR_Container (int collocated)
 {
   this->_tao_setup_collocation (collocated);
 }
 
 // destructor
-IR::Container::~Container (void)
+IR_Container::~IR_Container (void)
 {}
 
 void
-IR::Container::_tao_setup_collocation (int collocated)
+IR_Container::_tao_setup_collocation (int collocated)
 {
   if (collocated)
     this->the_TAO_Container_Proxy_Broker_ =
-      ::IR__TAO_Container_Proxy_Broker_Factory_function_pointer (this);
+      _TAO_Container_Proxy_Broker_Factory_function_pointer (this);
   else
     this->the_TAO_Container_Proxy_Broker_ =
-      ::IR::_TAO_Container_Remote_Proxy_Broker::the_TAO_Container_Remote_Proxy_Broker ();
+      ::the_TAO_Container_Remote_Proxy_Broker ();
+  
+  CORBA_IRObject::_tao_setup_collocation (collocated);
   
-  ACE_NESTED_CLASS (CORBA, IRObject)::_tao_setup_collocation (collocated);
 }
 
-void IR::Container::_tao_any_destructor (void *x)
+void IR_Container::_tao_any_destructor (void *x)
 {
-  Container *tmp = ACE_static_cast (Container*,x);
+  IR_Container *tmp = ACE_static_cast (IR_Container*,x);
   CORBA::release (tmp);
 }
 
-IR::Container_ptr IR::Container::_narrow (
+IR_Container_ptr IR_Container::_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
 {
   if (CORBA::is_nil (obj))
-    return Container::_nil ();
+    return IR_Container::_nil ();
   if (! obj->_is_local ())
     {
       CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/Container:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (Container::_nil ());
+      ACE_CHECK_RETURN (IR_Container::_nil ());
       if (is_a == 0)
-        return Container::_nil ();
+        return IR_Container::_nil ();
     }
-  return Container::_unchecked_narrow (obj, ACE_TRY_ENV);
+  return IR_Container::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::Container_ptr IR::Container::_unchecked_narrow (
+IR_Container_ptr IR_Container::_unchecked_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &
   )
 {
   if (CORBA::is_nil (obj))
-    return Container::_nil ();
+    return IR_Container::_nil ();
   if (! obj->_is_local ())
     {
       TAO_Stub* stub = obj->_stubobj ();
       if (stub)
         stub->_incr_refcnt ();
-      Container_ptr default_proxy = Container::_nil ();
+      IR_Container_ptr default_proxy = IR_Container::_nil ();
 
       if (
           !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
           stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_Container_Proxy_Broker_Factory_function_pointer != 0
+          obj->_is_collocated () &&_TAO_Container_Proxy_Broker_Factory_function_pointer != 0
         )
       {
         ACE_NEW_RETURN (
           default_proxy,
-          ::IR::Container (
+          ::IR_Container (
             stub,
             1,
             obj->_servant ()),
             
-          Container::_nil ());
+          IR_Container::_nil ());
         }
       if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::Container (stub, 0, obj->_servant ()), Container::_nil ());
+        ACE_NEW_RETURN (default_proxy, ::IR_Container (stub, 0, obj->_servant ()), IR_Container::_nil ());
         return default_proxy;
       }
     else 
       return
         ACE_reinterpret_cast
           (
-            Container_ptr,
+            IR_Container_ptr,
               obj->_tao_QueryInterface
                 (
                   ACE_reinterpret_cast
                     (
                       ptr_arith_t,
-                      &Container::_narrow
+                      &IR_Container::_narrow
                     )
                 )
           );
 }
 
-IR::Container_ptr
-IR::Container::_duplicate (Container_ptr obj)
+IR_Container_ptr
+IR_Container::_duplicate (IR_Container_ptr obj)
 {
   if (!CORBA::is_nil (obj))
     obj->_add_ref ();
   return obj;
 }
 
-CORBA::Boolean IR::Container::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+CORBA::Boolean IR_Container::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
   if (
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
@@ -9051,22 +5401,22 @@
     return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
 }
 
-void *IR::Container::_tao_QueryInterface (ptr_arith_t type)
+void *IR_Container::_tao_QueryInterface (ptr_arith_t type)
 {
   void *retv = 0;
   if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Container)::_narrow))
+      &IR_Container::_narrow))
     retv = ACE_reinterpret_cast (void*, this);
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
+      &CORBA_IRObject::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            CORBA::IRObject_ptr,
+            CORBA_IRObject_ptr,
             this
           )
       );
@@ -9079,20 +5429,19 @@
   return retv;
 }
 
-const char* IR::Container::_interface_repository_id (void) const
+const char* IR_Container::_interface_repository_id (void) const
 {
   return "IDL:omg.org/IR/Container:1.0";
 }
 
-IR::Contained_ptr IR::Container::lookup (
+IR_Contained_ptr IR_Container::lookup (
     const char * search_name,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
-{
-  
+{ 
   return this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).lookup (
       this,
       search_name,
@@ -9100,8 +5449,8 @@
     );
 }
 
-IR::ContainedSeq * IR::Container::contents (
-    IR::DefinitionKind limit_type,
+IR_ContainedSeq * IR_Container::contents (
+    IR_DefinitionKind limit_type,
     CORBA::Boolean exclude_inherited,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -9109,7 +5458,6 @@
     CORBA::SystemException
   ))
 {
-  
   return this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).contents (
       this,
       limit_type,
@@ -9118,10 +5466,10 @@
     );
 }
 
-IR::ContainedSeq * IR::Container::lookup_name (
+IR_ContainedSeq * IR_Container::lookup_name (
     const char * search_name,
     CORBA::Long levels_to_search,
-    IR::DefinitionKind limit_type,
+    IR_DefinitionKind limit_type,
     CORBA::Boolean exclude_inherited,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -9129,7 +5477,6 @@
     CORBA::SystemException
   ))
 {
-  
   return this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).lookup_name (
       this,
       search_name,
@@ -9151,7 +5498,7 @@
   56, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
     29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7461), ACE_NTOHL (0x696e6564), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/Contained:1.0
-    10, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x64000000),  // name = Contained
+    10, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x64000000),  // name = IR_Contained
 
   5, ACE_NTOHL (0x6b696e64), ACE_NTOHL (0x0),  // name = kind
   CORBA::tk_enum, // typecode kind
@@ -9199,30 +5546,26 @@
   CORBA::tk_any,
 
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_Container_Description (CORBA::tk_struct, sizeof (_oc_IR_Container_Description), (char *) &_oc_IR_Container_Description, 0, sizeof (IR::Container::Description));
-CORBA::TypeCode_ptr IR::Container::_tc_Description = &_tc_TAO_tc_IR_Container_Description;
+static CORBA::TypeCode _tc_TAO_tc_IR_Container_Description (CORBA::tk_struct, sizeof (_oc_IR_Container_Description), (char *) &_oc_IR_Container_Description, 0, sizeof (IR_Container::Description));
+CORBA::TypeCode_ptr IR_Container::_tc_Description = &_tc_TAO_tc_IR_Container_Description;
 
-void IR::Container::Description::_tao_any_destructor (void *x)
+void IR_Container::Description::_tao_any_destructor (void *x)
 {
   Description *tmp = ACE_static_cast (Description*,x);
   delete tmp;
 }
 
-
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   
-#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_CONTAINER_DESCRIPTIONSEQ_CS_)
-#define __TAO_UNBOUNDED_SEQUENCE_IR_CONTAINER_DESCRIPTIONSEQ_CS_
-
   void
-  IR::Container::_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::_allocate_buffer (CORBA::ULong length)
+  IR_Container::_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::_allocate_buffer (CORBA::ULong length)
   {
-    IR::Container::Description* tmp = 0;
+    IR_Container::Description* tmp = 0;
     tmp = _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::allocbuf (length);
     
     if (this->buffer_ != 0)
     {
-      IR::Container::Description *old = ACE_reinterpret_cast (IR::Container::Description *,this->buffer_);
+      IR_Container::Description *old = ACE_reinterpret_cast (IR_Container::Description *,this->buffer_);
       
       for (CORBA::ULong i = 0; i < this->length_; ++i)
         tmp[i] = old[i];
@@ -9235,75 +5578,66 @@
   }
   
   void
-  IR::Container::_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::_deallocate_buffer (void)
+  IR_Container::_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::_deallocate_buffer (void)
   {
     if (this->buffer_ == 0 || this->release_ == 0)
       return;
     
-    IR::Container::Description *tmp = ACE_reinterpret_cast (IR::Container::Description *,this->buffer_);
+    IR_Container::Description *tmp = ACE_reinterpret_cast (IR_Container::Description *,this->buffer_);
     
     _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::freebuf (tmp);
     this->buffer_ = 0;
   } 
   
-  IR::Container::_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::~_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq (void) // Dtor.
+  IR_Container::_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::~_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq (void) // Dtor.
   {
     this->_deallocate_buffer ();
   }
   
   
-#endif /* end #if !defined */
-
-
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 
-#if !defined (_IR_CONTAINER_DESCRIPTIONSEQ_CS_)
-#define _IR_CONTAINER_DESCRIPTIONSEQ_CS_
-
 // *************************************************************
-// IR::Container::DescriptionSeq
+// IR_Container::DescriptionSeq
 // *************************************************************
 
-IR::Container::DescriptionSeq::DescriptionSeq (void)
+IR_Container::DescriptionSeq::DescriptionSeq (void)
 {}
-IR::Container::DescriptionSeq::DescriptionSeq (CORBA::ULong max) // uses max size
+IR_Container::DescriptionSeq::DescriptionSeq (CORBA::ULong max) // uses max size
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::Container::Description>
+  TAO_Unbounded_Sequence<IR_Container::Description>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max)
 {}
-IR::Container::DescriptionSeq::DescriptionSeq (CORBA::ULong max, CORBA::ULong length, IR::Container::Description *buffer, CORBA::Boolean release)
+IR_Container::DescriptionSeq::DescriptionSeq (CORBA::ULong max, CORBA::ULong length, IR_Container::Description *buffer, CORBA::Boolean release)
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::Container::Description>
+  TAO_Unbounded_Sequence<IR_Container::Description>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max, length, buffer, release)
 {}
-IR::Container::DescriptionSeq::DescriptionSeq (const DescriptionSeq &seq) // copy ctor
+IR_Container::DescriptionSeq::DescriptionSeq (const DescriptionSeq &seq) // copy ctor
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::Container::Description>
+  TAO_Unbounded_Sequence<IR_Container::Description>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (seq)
 {}
-IR::Container::DescriptionSeq::~DescriptionSeq (void) // dtor
+IR_Container::DescriptionSeq::~DescriptionSeq (void) // dtor
 {}
-void IR::Container::DescriptionSeq::_tao_any_destructor (void *x)
+void IR_Container::DescriptionSeq::_tao_any_destructor (void *x)
 {
   DescriptionSeq *tmp = ACE_static_cast (DescriptionSeq*,x);
   delete tmp;
 }
 
-
-#endif /* end #if !defined */
-
 static const CORBA::Long _oc_IR_Container_DescriptionSeq[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
@@ -9323,7 +5657,7 @@
       56, // encapsulation length
         TAO_ENCAP_BYTE_ORDER, // byte order
         29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7461), ACE_NTOHL (0x696e6564), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/Contained:1.0
-        10, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x64000000),  // name = Contained
+        10, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x64000000),  // name = IR_Contained
 
       5, ACE_NTOHL (0x6b696e64), ACE_NTOHL (0x0),  // name = kind
       CORBA::tk_enum, // typecode kind
@@ -9374,11 +5708,11 @@
     0U,
 
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_Container_DescriptionSeq (CORBA::tk_alias, sizeof (_oc_IR_Container_DescriptionSeq), (char *) &_oc_IR_Container_DescriptionSeq, 0, sizeof (IR::Container::DescriptionSeq));
-CORBA::TypeCode_ptr IR::Container::_tc_DescriptionSeq = &_tc_TAO_tc_IR_Container_DescriptionSeq;
+static CORBA::TypeCode _tc_TAO_tc_IR_Container_DescriptionSeq (CORBA::tk_alias, sizeof (_oc_IR_Container_DescriptionSeq), (char *) &_oc_IR_Container_DescriptionSeq, 0, sizeof (IR_Container::DescriptionSeq));
+CORBA::TypeCode_ptr IR_Container::_tc_DescriptionSeq = &_tc_TAO_tc_IR_Container_DescriptionSeq;
 
-IR::Container::DescriptionSeq * IR::Container::describe_contents (
-    IR::DefinitionKind limit_type,
+IR_Container::DescriptionSeq * IR_Container::describe_contents (
+    IR_DefinitionKind limit_type,
     CORBA::Boolean exclude_inherited,
     CORBA::Long max_returned_objs,
     CORBA::Environment &ACE_TRY_ENV
@@ -9387,7 +5721,6 @@
     CORBA::SystemException
   ))
 {
-  
   return this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).describe_contents (
       this,
       limit_type,
@@ -9397,7 +5730,7 @@
     );
 }
 
-IR::ModuleDef_ptr IR::Container::create_module (
+IR_ModuleDef_ptr IR_Container::create_module (
     const char * id,
     const char * name,
     const char * version,
@@ -9407,7 +5740,6 @@
     CORBA::SystemException
   ))
 {
-  
   return this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_module (
       this,
       id,
@@ -9417,11 +5749,11 @@
     );
 }
 
-IR::ConstantDef_ptr IR::Container::create_constant (
+IR_ConstantDef_ptr IR_Container::create_constant (
     const char * id,
     const char * name,
     const char * version,
-    IR::IDLType_ptr type,
+    IR_IDLType_ptr type,
     const CORBA::Any & value,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -9429,7 +5761,6 @@
     CORBA::SystemException
   ))
 {
-  
   return this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_constant (
       this,
       id,
@@ -9441,18 +5772,17 @@
     );
 }
 
-IR::StructDef_ptr IR::Container::create_struct (
+IR_StructDef_ptr IR_Container::create_struct (
     const char * id,
     const char * name,
     const char * version,
-    const IR::StructMemberSeq & members,
+    const IR_StructMemberSeq & members,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
   return this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_struct (
       this,
       id,
@@ -9463,19 +5793,18 @@
     );
 }
 
-IR::UnionDef_ptr IR::Container::create_union (
+IR_UnionDef_ptr IR_Container::create_union (
     const char * id,
     const char * name,
     const char * version,
-    IR::IDLType_ptr discriminator_type,
-    const IR::UnionMemberSeq & members,
+    IR_IDLType_ptr discriminator_type,
+    const IR_UnionMemberSeq & members,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
   return this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_union (
       this,
       id,
@@ -9487,18 +5816,17 @@
     );
 }
 
-IR::EnumDef_ptr IR::Container::create_enum (
+IR_EnumDef_ptr IR_Container::create_enum (
     const char * id,
     const char * name,
     const char * version,
-    const IR::EnumMemberSeq & members,
+    const IR_EnumMemberSeq & members,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
   return this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_enum (
       this,
       id,
@@ -9509,18 +5837,17 @@
     );
 }
 
-IR::AliasDef_ptr IR::Container::create_alias (
+IR_AliasDef_ptr IR_Container::create_alias (
     const char * id,
     const char * name,
     const char * version,
-    IR::IDLType_ptr original_type,
+    IR_IDLType_ptr original_type,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
   return this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_alias (
       this,
       id,
@@ -9531,11 +5858,11 @@
     );
 }
 
-IR::InterfaceDef_ptr IR::Container::create_interface (
+IR_InterfaceDef_ptr IR_Container::create_interface (
     const char * id,
     const char * name,
     const char * version,
-    const IR::InterfaceDefSeq & base_interfaces,
+    const IR_InterfaceDefSeq & base_interfaces,
     CORBA::Boolean is_abstract,
     CORBA::Boolean is_local,
     CORBA::Environment &ACE_TRY_ENV
@@ -9544,7 +5871,6 @@
     CORBA::SystemException
   ))
 {
-  
   return this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_interface (
       this,
       id,
@@ -9557,24 +5883,23 @@
     );
 }
 
-IR::ValueDef_ptr IR::Container::create_value (
+IR_ValueDef_ptr IR_Container::create_value (
     const char * id,
     const char * name,
     const char * version,
     CORBA::Boolean is_custom,
     CORBA::Boolean is_abstract,
-    IR::ValueDef_ptr base_value,
+    IR_ValueDef_ptr base_value,
     CORBA::Boolean is_truncatable,
-    const IR::ValueDefSeq & abstract_base_values,
-    const IR::InterfaceDefSeq & supported_interfaces,
-    const IR::InitializerSeq & initializers,
+    const IR_ValueDefSeq & abstract_base_values,
+    const IR_InterfaceDefSeq & supported_interfaces,
+    const IR_InitializerSeq & initializers,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
   return this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_value (
       this,
       id,
@@ -9591,18 +5916,17 @@
     );
 }
 
-IR::ValueBoxDef_ptr IR::Container::create_value_box (
+IR_ValueBoxDef_ptr IR_Container::create_value_box (
     const char * id,
     const char * name,
     const char * version,
-    IR::IDLType_ptr original_type_def,
+    IR_IDLType_ptr original_type_def,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
   return this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_value_box (
       this,
       id,
@@ -9613,18 +5937,17 @@
     );
 }
 
-IR::ExceptionDef_ptr IR::Container::create_exception (
+IR_ExceptionDef_ptr IR_Container::create_exception (
     const char * id,
     const char * name,
     const char * version,
-    const IR::StructMemberSeq & members,
+    const IR_StructMemberSeq & members,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
   return this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_exception (
       this,
       id,
@@ -9635,7 +5958,7 @@
     );
 }
 
-IR::NativeDef_ptr IR::Container::create_native (
+IR_NativeDef_ptr IR_Container::create_native (
     const char * id,
     const char * name,
     const char * version,
@@ -9645,7 +5968,6 @@
     CORBA::SystemException
   ))
 {
-  
   return this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_native (
       this,
       id,
@@ -9655,1670 +5977,1156 @@
     );
 }
 
+static const CORBA::Long _oc_IR_Container[] =
+{
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7461), ACE_NTOHL (0x696e6572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/Container:1.0
+  10, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x72000000),  // name = IR_Container
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_Container (CORBA::tk_objref, sizeof (_oc_IR_Container), (char *) &_oc_IR_Container, 0, sizeof (IR_Container));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Container, &_tc_TAO_tc_IR_Container)
+TAO_NAMESPACE_END
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-IR::Container::TAO_ClientRequestInfo_IR_Container_lookup::TAO_ClientRequestInfo_IR_Container_lookup (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * search_name,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    search_name_ (search_name)
+///////////////////////////////////////////////////////////////////////
+//                Base & Remote Proxy  Implementation. 
+//
+
+_TAO_IDLType_Proxy_Impl::_TAO_IDLType_Proxy_Impl (void)
 {}
 
-Dynamic::ParameterList *
-IR::Container::TAO_ClientRequestInfo_IR_Container_lookup::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_search_name = parameter_list->length ();
-  parameter_list->length (length_search_name + 1);
-  (*parameter_list)[length_search_name].argument <<= search_name_;
-  (*parameter_list)[length_search_name].mode = Dynamic::PARAM_IN;
+_TAO_IDLType_Remote_Proxy_Impl::_TAO_IDLType_Remote_Proxy_Impl (void)
+{}
+
+// Remote Implementation of the IDL interface methods
+
+CORBA::TypeCode_ptr _TAO_IDLType_Remote_Proxy_Impl::type (
+    CORBA_Object *_collocated_tao_target_,
+        CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{  
+  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
+  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
   
-  return safe_parameter_list._retn ();
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_type",
+      9,
+      0,
+      istub->orb_core ()
+    );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
+
+  return _tao_safe_retval._retn ();
 }
 
-Dynamic::ExceptionList *
-IR::Container::TAO_ClientRequestInfo_IR_Container_lookup::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+
+//
+//            End  Base & Remote  Proxy Implemeentation. 
+///////////////////////////////////////////////////////////////////////
+
+
+///////////////////////////////////////////////////////////////////////
+//           Remote & Base  Proxy Broker Implementation
+//
+
+_TAO_IDLType_Proxy_Broker::_TAO_IDLType_Proxy_Broker (void)
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
 }
 
+_TAO_IDLType_Proxy_Broker::~_TAO_IDLType_Proxy_Broker (void)
+{
+}
 
-CORBA::Any * 
-IR::Container::TAO_ClientRequestInfo_IR_Container_lookup::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+// Factory function Implementation.
+_TAO_IDLType_Remote_Proxy_Broker *the_TAO_IDLType_Remote_Proxy_Broker (void)
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
+  static ::_TAO_IDLType_Remote_Proxy_Broker remote_proxy_broker;
+  return &remote_proxy_broker;
 }
 
-void 
-IR::Container::TAO_ClientRequestInfo_IR_Container_lookup::result (IR::Contained_ptr result)
+_TAO_IDLType_Remote_Proxy_Broker::_TAO_IDLType_Remote_Proxy_Broker (void)
 {
-  // update the result 
-  this->_result = result;
 }
 
-IR::Container::TAO_ClientRequestInfo_IR_Container_contents::TAO_ClientRequestInfo_IR_Container_contents (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    IR::DefinitionKind & limit_type,
-    const CORBA::Boolean & exclude_inherited,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    limit_type_ (limit_type),
-    exclude_inherited_ (exclude_inherited)
-{}
-
-Dynamic::ParameterList *
-IR::Container::TAO_ClientRequestInfo_IR_Container_contents::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+_TAO_IDLType_Remote_Proxy_Broker::~_TAO_IDLType_Remote_Proxy_Broker (void)
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_limit_type = parameter_list->length ();
-  parameter_list->length (length_limit_type + 1);
-  (*parameter_list)[length_limit_type].argument <<=  this->limit_type_;
-  
-  (*parameter_list)[length_limit_type].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_exclude_inherited = parameter_list->length ();
-  parameter_list->length (length_exclude_inherited + 1);
-  (*parameter_list)[length_exclude_inherited].argument <<= CORBA::Any::from_boolean (this->exclude_inherited_);
-  (*parameter_list)[length_exclude_inherited].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
 }
 
-Dynamic::ExceptionList *
-IR::Container::TAO_ClientRequestInfo_IR_Container_contents::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+_TAO_IDLType_Proxy_Impl&
+_TAO_IDLType_Remote_Proxy_Broker::select_proxy (
+  ::IR_IDLType *object,
+  CORBA::Environment &ACE_TRY_ENV
+)
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
+  ACE_UNUSED_ARG (object);
+  ACE_UNUSED_ARG (ACE_TRY_ENV);
+  return remote_proxy_impl_;
 }
 
 
-CORBA::Any * 
-IR::Container::TAO_ClientRequestInfo_IR_Container_contents::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
+//
+//           End Remote & Base Proxy Broker Implementation
+///////////////////////////////////////////////////////////////////////
+
 
-void 
-IR::Container::TAO_ClientRequestInfo_IR_Container_contents::result (IR::ContainedSeq * result)
+// default constructor
+IR_IDLType::IR_IDLType (int collocated)
 {
-  // update the result 
-  this->_result = result;
+  this->_tao_setup_collocation (collocated);
 }
 
-IR::Container::TAO_ClientRequestInfo_IR_Container_lookup_name::TAO_ClientRequestInfo_IR_Container_lookup_name (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * search_name,
-    const CORBA::Long & levels_to_search,
-    IR::DefinitionKind & limit_type,
-    const CORBA::Boolean & exclude_inherited,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    search_name_ (search_name),
-    levels_to_search_ (levels_to_search),
-    limit_type_ (limit_type),
-    exclude_inherited_ (exclude_inherited)
+// destructor
+IR_IDLType::~IR_IDLType (void)
 {}
 
-Dynamic::ParameterList *
-IR::Container::TAO_ClientRequestInfo_IR_Container_lookup_name::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+void
+IR_IDLType::_tao_setup_collocation (int collocated)
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_search_name = parameter_list->length ();
-  parameter_list->length (length_search_name + 1);
-  (*parameter_list)[length_search_name].argument <<= search_name_;
-  (*parameter_list)[length_search_name].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_levels_to_search = parameter_list->length ();
-  parameter_list->length (length_levels_to_search + 1);
-  (*parameter_list)[length_levels_to_search].argument <<= levels_to_search_;
-  (*parameter_list)[length_levels_to_search].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_limit_type = parameter_list->length ();
-  parameter_list->length (length_limit_type + 1);
-  (*parameter_list)[length_limit_type].argument <<=  this->limit_type_;
-  
-  (*parameter_list)[length_limit_type].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_exclude_inherited = parameter_list->length ();
-  parameter_list->length (length_exclude_inherited + 1);
-  (*parameter_list)[length_exclude_inherited].argument <<= CORBA::Any::from_boolean (this->exclude_inherited_);
-  (*parameter_list)[length_exclude_inherited].mode = Dynamic::PARAM_IN;
+  if (collocated)
+    this->the_TAO_IDLType_Proxy_Broker_ =
+      _TAO_IDLType_Proxy_Broker_Factory_function_pointer (this);
+  else
+    this->the_TAO_IDLType_Proxy_Broker_ =
+      ::the_TAO_IDLType_Remote_Proxy_Broker ();
   
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::Container::TAO_ClientRequestInfo_IR_Container_lookup_name::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
+  CORBA_IRObject::_tao_setup_collocation (collocated);
   
-  return exception_list;
 }
 
-
-CORBA::Any * 
-IR::Container::TAO_ClientRequestInfo_IR_Container_lookup_name::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+void IR_IDLType::_tao_any_destructor (void *x)
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
+  IR_IDLType *tmp = ACE_static_cast (IR_IDLType*,x);
+  CORBA::release (tmp);
 }
 
-void 
-IR::Container::TAO_ClientRequestInfo_IR_Container_lookup_name::result (IR::ContainedSeq * result)
+IR_IDLType_ptr IR_IDLType::_narrow (
+    CORBA::Object_ptr obj,
+    CORBA::Environment &ACE_TRY_ENV
+  )
 {
-  // update the result 
-  this->_result = result;
+  if (CORBA::is_nil (obj))
+    return IR_IDLType::_nil ();
+  if (! obj->_is_local ())
+    {
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/IDLType:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (IR_IDLType::_nil ());
+      if (is_a == 0)
+        return IR_IDLType::_nil ();
+    }
+  return IR_IDLType::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::Container::TAO_ClientRequestInfo_IR_Container_describe_contents::TAO_ClientRequestInfo_IR_Container_describe_contents (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    IR::DefinitionKind & limit_type,
-    const CORBA::Boolean & exclude_inherited,
-    const CORBA::Long & max_returned_objs,
-    CORBA::Environment &    
+IR_IDLType_ptr IR_IDLType::_unchecked_narrow (
+    CORBA::Object_ptr obj,
+    CORBA::Environment &
   )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    limit_type_ (limit_type),
-    exclude_inherited_ (exclude_inherited),
-    max_returned_objs_ (max_returned_objs)
-{}
-
-Dynamic::ParameterList *
-IR::Container::TAO_ClientRequestInfo_IR_Container_describe_contents::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_limit_type = parameter_list->length ();
-  parameter_list->length (length_limit_type + 1);
-  (*parameter_list)[length_limit_type].argument <<=  this->limit_type_;
-  
-  (*parameter_list)[length_limit_type].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_exclude_inherited = parameter_list->length ();
-  parameter_list->length (length_exclude_inherited + 1);
-  (*parameter_list)[length_exclude_inherited].argument <<= CORBA::Any::from_boolean (this->exclude_inherited_);
-  (*parameter_list)[length_exclude_inherited].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_max_returned_objs = parameter_list->length ();
-  parameter_list->length (length_max_returned_objs + 1);
-  (*parameter_list)[length_max_returned_objs].argument <<= max_returned_objs_;
-  (*parameter_list)[length_max_returned_objs].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
+  if (CORBA::is_nil (obj))
+    return IR_IDLType::_nil ();
+  if (! obj->_is_local ())
+    {
+      TAO_Stub* stub = obj->_stubobj ();
+      if (stub)
+        stub->_incr_refcnt ();
+      IR_IDLType_ptr default_proxy = IR_IDLType::_nil ();
 
-Dynamic::ExceptionList *
-IR::Container::TAO_ClientRequestInfo_IR_Container_describe_contents::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
+      if (
+          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
+          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
+          obj->_is_collocated () &&_TAO_IDLType_Proxy_Broker_Factory_function_pointer != 0
+        )
+      {
+        ACE_NEW_RETURN (
+          default_proxy,
+          ::IR_IDLType (
+            stub,
+            1,
+            obj->_servant ()),
+            
+          IR_IDLType::_nil ());
+        }
+      if (CORBA::is_nil (default_proxy))
+        ACE_NEW_RETURN (default_proxy, ::IR_IDLType (stub, 0, obj->_servant ()), IR_IDLType::_nil ());
+        return default_proxy;
+      }
+    else 
+      return
+        ACE_reinterpret_cast
+          (
+            IR_IDLType_ptr,
+              obj->_tao_QueryInterface
+                (
+                  ACE_reinterpret_cast
+                    (
+                      ptr_arith_t,
+                      &IR_IDLType::_narrow
+                    )
+                )
+          );
 }
 
-
-CORBA::Any * 
-IR::Container::TAO_ClientRequestInfo_IR_Container_describe_contents::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+IR_IDLType_ptr
+IR_IDLType::_duplicate (IR_IDLType_ptr obj)
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
+  if (!CORBA::is_nil (obj))
+    obj->_add_ref ();
+  return obj;
 }
 
-void 
-IR::Container::TAO_ClientRequestInfo_IR_Container_describe_contents::result (ACE_NESTED_CLASS (IR::Container,DescriptionSeq) * result)
+CORBA::Boolean IR_IDLType::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
-  // update the result 
-  this->_result = result;
+  if (
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
+  return 1; // success using local knowledge
+  else
+    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
 }
 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_module::TAO_ClientRequestInfo_IR_Container_create_module (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * id,
-    const char * name,
-    const char * version,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    id_ (id),
-    name_ (name),
-    version_ (version)
-{}
-
-Dynamic::ParameterList *
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_module::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+void *IR_IDLType::_tao_QueryInterface (ptr_arith_t type)
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_id = parameter_list->length ();
-  parameter_list->length (length_id + 1);
-  (*parameter_list)[length_id].argument <<= id_;
-  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_name = parameter_list->length ();
-  parameter_list->length (length_name + 1);
-  (*parameter_list)[length_name].argument <<= name_;
-  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
+  void *retv = 0;
+  if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_IDLType::_narrow))
+    retv = ACE_reinterpret_cast (void*, this);
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &CORBA_IRObject::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            CORBA_IRObject_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
+    retv = ACE_reinterpret_cast (void *,
+      ACE_static_cast (CORBA::Object_ptr, this));
     
-  CORBA::ULong length_version = parameter_list->length ();
-  parameter_list->length (length_version + 1);
-  (*parameter_list)[length_version].argument <<= version_;
-  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_module::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_module::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
+  if (retv)
+    this->_add_ref ();
+  return retv;
 }
 
-void 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_module::result (IR::ModuleDef_ptr result)
+const char* IR_IDLType::_interface_repository_id (void) const
 {
-  // update the result 
-  this->_result = result;
+  return "IDL:omg.org/IR/IDLType:1.0";
 }
 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_constant::TAO_ClientRequestInfo_IR_Container_create_constant (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::IDLType_ptr type,
-    const CORBA::Any & value,
-    CORBA::Environment &    
+CORBA::TypeCode_ptr IR_IDLType::type (
+            CORBA::Environment &ACE_TRY_ENV
   )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    id_ (id),
-    name_ (name),
-    version_ (version),
-    type_ (type),
-    value_ (value)
-{}
-
-Dynamic::ParameterList *
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_constant::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_id = parameter_list->length ();
-  parameter_list->length (length_id + 1);
-  (*parameter_list)[length_id].argument <<= id_;
-  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_name = parameter_list->length ();
-  parameter_list->length (length_name + 1);
-  (*parameter_list)[length_name].argument <<= name_;
-  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_version = parameter_list->length ();
-  parameter_list->length (length_version + 1);
-  (*parameter_list)[length_version].argument <<= version_;
-  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_type = parameter_list->length ();
-  parameter_list->length (length_type + 1);
-  (*parameter_list)[length_type].argument <<=  this->type_;
   
-  (*parameter_list)[length_type].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_value = parameter_list->length ();
-  parameter_list->length (length_value + 1);
-  (*parameter_list)[length_value].argument <<= value_;
-  (*parameter_list)[length_value].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
+  return this->the_TAO_IDLType_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type (
+      this,
+      ACE_TRY_ENV
+    );
 }
 
-Dynamic::ExceptionList *
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_constant::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+static const CORBA::Long _oc_IR_IDLType[] =
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_constant::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
+  8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_IDLType (CORBA::tk_objref, sizeof (_oc_IR_IDLType), (char *) &_oc_IR_IDLType, 0, sizeof (IR_IDLType));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_IDLType, &_tc_TAO_tc_IR_IDLType)
+TAO_NAMESPACE_END
+static const CORBA::Long _oc_IR_PrimitiveKind[] =
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x72696d69), ACE_NTOHL (0x74697665), ACE_NTOHL (0x4b696e64), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/PrimitiveKind:1.0
+  14, ACE_NTOHL (0x5072696d), ACE_NTOHL (0x69746976), ACE_NTOHL (0x654b696e), ACE_NTOHL (0x64000000),  // name = PrimitiveKind
+  22, // member count
+  8, ACE_NTOHL (0x706b5f6e), ACE_NTOHL (0x756c6c00),  // name = pk_null
+  8, ACE_NTOHL (0x706b5f76), ACE_NTOHL (0x6f696400),  // name = pk_void
+  9, ACE_NTOHL (0x706b5f73), ACE_NTOHL (0x686f7274), ACE_NTOHL (0x0),  // name = pk_short
+  8, ACE_NTOHL (0x706b5f6c), ACE_NTOHL (0x6f6e6700),  // name = pk_long
+  10, ACE_NTOHL (0x706b5f75), ACE_NTOHL (0x73686f72), ACE_NTOHL (0x74000000),  // name = pk_ushort
+  9, ACE_NTOHL (0x706b5f75), ACE_NTOHL (0x6c6f6e67), ACE_NTOHL (0x0),  // name = pk_ulong
+  9, ACE_NTOHL (0x706b5f66), ACE_NTOHL (0x6c6f6174), ACE_NTOHL (0x0),  // name = pk_float
+  10, ACE_NTOHL (0x706b5f64), ACE_NTOHL (0x6f75626c), ACE_NTOHL (0x65000000),  // name = pk_double
+  11, ACE_NTOHL (0x706b5f62), ACE_NTOHL (0x6f6f6c65), ACE_NTOHL (0x616e0000),  // name = pk_boolean
+  8, ACE_NTOHL (0x706b5f63), ACE_NTOHL (0x68617200),  // name = pk_char
+  9, ACE_NTOHL (0x706b5f6f), ACE_NTOHL (0x63746574), ACE_NTOHL (0x0),  // name = pk_octet
+  7, ACE_NTOHL (0x706b5f61), ACE_NTOHL (0x6e790000),  // name = pk_any
+  12, ACE_NTOHL (0x706b5f54), ACE_NTOHL (0x79706543), ACE_NTOHL (0x6f646500),  // name = pk_TypeCode
+  13, ACE_NTOHL (0x706b5f50), ACE_NTOHL (0x72696e63), ACE_NTOHL (0x6970616c), ACE_NTOHL (0x0),  // name = pk_Principal
+  10, ACE_NTOHL (0x706b5f73), ACE_NTOHL (0x7472696e), ACE_NTOHL (0x67000000),  // name = pk_string
+  10, ACE_NTOHL (0x706b5f6f), ACE_NTOHL (0x626a7265), ACE_NTOHL (0x66000000),  // name = pk_objref
+  12, ACE_NTOHL (0x706b5f6c), ACE_NTOHL (0x6f6e676c), ACE_NTOHL (0x6f6e6700),  // name = pk_longlong
+  13, ACE_NTOHL (0x706b5f75), ACE_NTOHL (0x6c6f6e67), ACE_NTOHL (0x6c6f6e67), ACE_NTOHL (0x0),  // name = pk_ulonglong
+  14, ACE_NTOHL (0x706b5f6c), ACE_NTOHL (0x6f6e6764), ACE_NTOHL (0x6f75626c), ACE_NTOHL (0x65000000),  // name = pk_longdouble
+  9, ACE_NTOHL (0x706b5f77), ACE_NTOHL (0x63686172), ACE_NTOHL (0x0),  // name = pk_wchar
+  11, ACE_NTOHL (0x706b5f77), ACE_NTOHL (0x73747269), ACE_NTOHL (0x6e670000),  // name = pk_wstring
+  14, ACE_NTOHL (0x706b5f76), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x5f626173), ACE_NTOHL (0x65000000),  // name = pk_value_base
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_PrimitiveKind (CORBA::tk_enum, sizeof (_oc_IR_PrimitiveKind), (char *) &_oc_IR_PrimitiveKind, 0, sizeof (IR_PrimitiveKind));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PrimitiveKind, &_tc_TAO_tc_IR_PrimitiveKind)
+TAO_NAMESPACE_END
 
-void 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_constant::result (IR::ConstantDef_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
+///////////////////////////////////////////////////////////////////////
+//                Base & Remote Proxy  Implementation. 
+//
 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_struct::TAO_ClientRequestInfo_IR_Container_create_struct (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * id,
-    const char * name,
-    const char * version,
-    const IR::StructMemberSeq & members,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    id_ (id),
-    name_ (name),
-    version_ (version),
-    members_ (members)
+_TAO_Repository_Proxy_Impl::_TAO_Repository_Proxy_Impl (void)
 {}
 
-Dynamic::ParameterList *
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_struct::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_id = parameter_list->length ();
-  parameter_list->length (length_id + 1);
-  (*parameter_list)[length_id].argument <<= id_;
-  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_name = parameter_list->length ();
-  parameter_list->length (length_name + 1);
-  (*parameter_list)[length_name].argument <<= name_;
-  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_version = parameter_list->length ();
-  parameter_list->length (length_version + 1);
-  (*parameter_list)[length_version].argument <<= version_;
-  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_members = parameter_list->length ();
-  parameter_list->length (length_members + 1);
-  (*parameter_list)[length_members].argument <<=  this->members_;
-  
-  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_struct::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
+_TAO_Repository_Remote_Proxy_Impl::_TAO_Repository_Remote_Proxy_Impl (void)
+{}
 
+// Remote Implementation of the IDL interface methods
 
-CORBA::Any * 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_struct::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+IR_Contained_ptr _TAO_Repository_Remote_Proxy_Impl::lookup_id (
+    CORBA_Object *_collocated_tao_target_,
+    const char * search_id,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
+  IR_Contained_ptr _tao_retval = IR_Contained::_nil ();
+  IR_Contained_var _tao_safe_retval (_tao_retval);
   
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_struct::result (IR::StructDef_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_union::TAO_ClientRequestInfo_IR_Container_create_union (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::IDLType_ptr discriminator_type,
-    const IR::UnionMemberSeq & members,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    id_ (id),
-    name_ (name),
-    version_ (version),
-    discriminator_type_ (discriminator_type),
-    members_ (members)
-{}
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "lookup_id",
+      9,
+      1,
+      istub->orb_core ()
+    );
 
-Dynamic::ParameterList *
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_union::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_id = parameter_list->length ();
-  parameter_list->length (length_id + 1);
-  (*parameter_list)[length_id].argument <<= id_;
-  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_name = parameter_list->length ();
-  parameter_list->length (length_name + 1);
-  (*parameter_list)[length_name].argument <<= name_;
-  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_version = parameter_list->length ();
-  parameter_list->length (length_version + 1);
-  (*parameter_list)[length_version].argument <<= version_;
-  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_discriminator_type = parameter_list->length ();
-  parameter_list->length (length_discriminator_type + 1);
-  (*parameter_list)[length_discriminator_type].argument <<=  this->discriminator_type_;
-  
-  (*parameter_list)[length_discriminator_type].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_members = parameter_list->length ();
-  parameter_list->length (length_members + 1);
-  (*parameter_list)[length_members].argument <<=  this->members_;
-  
-  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << search_id)
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-Dynamic::ExceptionList *
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_union::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
+  return _tao_safe_retval._retn ();
 }
 
-
-CORBA::Any * 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_union::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+CORBA::TypeCode_ptr _TAO_Repository_Remote_Proxy_Impl::get_canonical_typecode (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::TypeCode_ptr tc,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
+  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
+  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
   
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-void 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_union::result (IR::UnionDef_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "get_canonical_typecode",
+      22,
+      1,
+      istub->orb_core ()
+    );
 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_enum::TAO_ClientRequestInfo_IR_Container_create_enum (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * id,
-    const char * name,
-    const char * version,
-    const IR::EnumMemberSeq & members,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    id_ (id),
-    name_ (name),
-    version_ (version),
-    members_ (members)
-{}
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << tc)
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-Dynamic::ParameterList *
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_enum::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_id = parameter_list->length ();
-  parameter_list->length (length_id + 1);
-  (*parameter_list)[length_id].argument <<= id_;
-  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_name = parameter_list->length ();
-  parameter_list->length (length_name + 1);
-  (*parameter_list)[length_name].argument <<= name_;
-  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_version = parameter_list->length ();
-  parameter_list->length (length_version + 1);
-  (*parameter_list)[length_version].argument <<= version_;
-  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_members = parameter_list->length ();
-  parameter_list->length (length_members + 1);
-  (*parameter_list)[length_members].argument <<=  this->members_;
-  
-  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
+  return _tao_safe_retval._retn ();
 }
 
-Dynamic::ExceptionList *
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_enum::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+IR_PrimitiveDef_ptr _TAO_Repository_Remote_Proxy_Impl::get_primitive (
+    CORBA_Object *_collocated_tao_target_,
+    IR_PrimitiveKind kind,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
+  IR_PrimitiveDef_ptr _tao_retval = IR_PrimitiveDef::_nil ();
+  IR_PrimitiveDef_var _tao_safe_retval (_tao_retval);
   
-  return exception_list;
-}
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "get_primitive",
+      13,
+      1,
+      istub->orb_core ()
+    );
 
-CORBA::Any * 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_enum::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << kind)
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-void 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_enum::result (IR::EnumDef_ptr result)
-{
-  // update the result 
-  this->_result = result;
+  return _tao_safe_retval._retn ();
 }
 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_alias::TAO_ClientRequestInfo_IR_Container_create_alias (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::IDLType_ptr original_type,
-    CORBA::Environment &    
+IR_StringDef_ptr _TAO_Repository_Remote_Proxy_Impl::create_string (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::ULong bound,
+    CORBA::Environment &ACE_TRY_ENV
   )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    id_ (id),
-    name_ (name),
-    version_ (version),
-    original_type_ (original_type)
-{}
-
-Dynamic::ParameterList *
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_alias::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_id = parameter_list->length ();
-  parameter_list->length (length_id + 1);
-  (*parameter_list)[length_id].argument <<= id_;
-  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_name = parameter_list->length ();
-  parameter_list->length (length_name + 1);
-  (*parameter_list)[length_name].argument <<= name_;
-  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_version = parameter_list->length ();
-  parameter_list->length (length_version + 1);
-  (*parameter_list)[length_version].argument <<= version_;
-  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_original_type = parameter_list->length ();
-  parameter_list->length (length_original_type + 1);
-  (*parameter_list)[length_original_type].argument <<=  this->original_type_;
+  IR_StringDef_ptr _tao_retval = IR_StringDef::_nil ();
+  IR_StringDef_var _tao_safe_retval (_tao_retval);
   
-  (*parameter_list)[length_original_type].mode = Dynamic::PARAM_IN;
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
   
-  return safe_parameter_list._retn ();
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "create_string",
+      13,
+      1,
+      istub->orb_core ()
+    );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << bound)
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
+
+  return _tao_safe_retval._retn ();
 }
 
-Dynamic::ExceptionList *
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_alias::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+IR_WstringDef_ptr _TAO_Repository_Remote_Proxy_Impl::create_wstring (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::ULong bound,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
+  IR_WstringDef_ptr _tao_retval = IR_WstringDef::_nil ();
+  IR_WstringDef_var _tao_safe_retval (_tao_retval);
   
-  return exception_list;
-}
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "create_wstring",
+      14,
+      1,
+      istub->orb_core ()
+    );
 
-CORBA::Any * 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_alias::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << bound)
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-void 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_alias::result (IR::AliasDef_ptr result)
-{
-  // update the result 
-  this->_result = result;
+  return _tao_safe_retval._retn ();
 }
 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_interface::TAO_ClientRequestInfo_IR_Container_create_interface (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * id,
-    const char * name,
-    const char * version,
-    const IR::InterfaceDefSeq & base_interfaces,
-    const CORBA::Boolean & is_abstract,
-    const CORBA::Boolean & is_local,
-    CORBA::Environment &    
+IR_SequenceDef_ptr _TAO_Repository_Remote_Proxy_Impl::create_sequence (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::ULong bound,
+    IR_IDLType_ptr element_type,
+    CORBA::Environment &ACE_TRY_ENV
   )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    id_ (id),
-    name_ (name),
-    version_ (version),
-    base_interfaces_ (base_interfaces),
-    is_abstract_ (is_abstract),
-    is_local_ (is_local)
-{}
-
-Dynamic::ParameterList *
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_interface::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_id = parameter_list->length ();
-  parameter_list->length (length_id + 1);
-  (*parameter_list)[length_id].argument <<= id_;
-  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_name = parameter_list->length ();
-  parameter_list->length (length_name + 1);
-  (*parameter_list)[length_name].argument <<= name_;
-  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_version = parameter_list->length ();
-  parameter_list->length (length_version + 1);
-  (*parameter_list)[length_version].argument <<= version_;
-  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_base_interfaces = parameter_list->length ();
-  parameter_list->length (length_base_interfaces + 1);
-  (*parameter_list)[length_base_interfaces].argument <<=  this->base_interfaces_;
+  IR_SequenceDef_ptr _tao_retval = IR_SequenceDef::_nil ();
+  IR_SequenceDef_var _tao_safe_retval (_tao_retval);
   
-  (*parameter_list)[length_base_interfaces].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_is_abstract = parameter_list->length ();
-  parameter_list->length (length_is_abstract + 1);
-  (*parameter_list)[length_is_abstract].argument <<= CORBA::Any::from_boolean (this->is_abstract_);
-  (*parameter_list)[length_is_abstract].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_is_local = parameter_list->length ();
-  parameter_list->length (length_is_local + 1);
-  (*parameter_list)[length_is_local].argument <<= CORBA::Any::from_boolean (this->is_local_);
-  (*parameter_list)[length_is_local].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_interface::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "create_sequence",
+      15,
+      1,
+      istub->orb_core ()
+    );
 
-CORBA::Any * 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_interface::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << bound) &&
+              (_tao_out << element_type)
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-void 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_interface::result (IR::InterfaceDef_ptr result)
-{
-  // update the result 
-  this->_result = result;
+  return _tao_safe_retval._retn ();
 }
 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_value::TAO_ClientRequestInfo_IR_Container_create_value (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * id,
-    const char * name,
-    const char * version,
-    const CORBA::Boolean & is_custom,
-    const CORBA::Boolean & is_abstract,
-    IR::ValueDef_ptr base_value,
-    const CORBA::Boolean & is_truncatable,
-    const IR::ValueDefSeq & abstract_base_values,
-    const IR::InterfaceDefSeq & supported_interfaces,
-    const IR::InitializerSeq & initializers,
-    CORBA::Environment &    
+IR_ArrayDef_ptr _TAO_Repository_Remote_Proxy_Impl::create_array (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::ULong length,
+    IR_IDLType_ptr element_type,
+    CORBA::Environment &ACE_TRY_ENV
   )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    id_ (id),
-    name_ (name),
-    version_ (version),
-    is_custom_ (is_custom),
-    is_abstract_ (is_abstract),
-    base_value_ (base_value),
-    is_truncatable_ (is_truncatable),
-    abstract_base_values_ (abstract_base_values),
-    supported_interfaces_ (supported_interfaces),
-    initializers_ (initializers)
-{}
-
-Dynamic::ParameterList *
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_value::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_id = parameter_list->length ();
-  parameter_list->length (length_id + 1);
-  (*parameter_list)[length_id].argument <<= id_;
-  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_name = parameter_list->length ();
-  parameter_list->length (length_name + 1);
-  (*parameter_list)[length_name].argument <<= name_;
-  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_version = parameter_list->length ();
-  parameter_list->length (length_version + 1);
-  (*parameter_list)[length_version].argument <<= version_;
-  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_is_custom = parameter_list->length ();
-  parameter_list->length (length_is_custom + 1);
-  (*parameter_list)[length_is_custom].argument <<= CORBA::Any::from_boolean (this->is_custom_);
-  (*parameter_list)[length_is_custom].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_is_abstract = parameter_list->length ();
-  parameter_list->length (length_is_abstract + 1);
-  (*parameter_list)[length_is_abstract].argument <<= CORBA::Any::from_boolean (this->is_abstract_);
-  (*parameter_list)[length_is_abstract].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_base_value = parameter_list->length ();
-  parameter_list->length (length_base_value + 1);
-  (*parameter_list)[length_base_value].argument <<=  this->base_value_;
-  
-  (*parameter_list)[length_base_value].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_is_truncatable = parameter_list->length ();
-  parameter_list->length (length_is_truncatable + 1);
-  (*parameter_list)[length_is_truncatable].argument <<= CORBA::Any::from_boolean (this->is_truncatable_);
-  (*parameter_list)[length_is_truncatable].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_abstract_base_values = parameter_list->length ();
-  parameter_list->length (length_abstract_base_values + 1);
-  (*parameter_list)[length_abstract_base_values].argument <<=  this->abstract_base_values_;
-  
-  (*parameter_list)[length_abstract_base_values].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_supported_interfaces = parameter_list->length ();
-  parameter_list->length (length_supported_interfaces + 1);
-  (*parameter_list)[length_supported_interfaces].argument <<=  this->supported_interfaces_;
-  
-  (*parameter_list)[length_supported_interfaces].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_initializers = parameter_list->length ();
-  parameter_list->length (length_initializers + 1);
-  (*parameter_list)[length_initializers].argument <<=  this->initializers_;
-  
-  (*parameter_list)[length_initializers].mode = Dynamic::PARAM_IN;
+  IR_ArrayDef_ptr _tao_retval = IR_ArrayDef::_nil ();
+  IR_ArrayDef_var _tao_safe_retval (_tao_retval);
   
-  return safe_parameter_list._retn ();
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "create_array",
+      12,
+      1,
+      istub->orb_core ()
+    );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << length) &&
+              (_tao_out << element_type)
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
+
+  return _tao_safe_retval._retn ();
 }
 
-Dynamic::ExceptionList *
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_value::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+IR_FixedDef_ptr _TAO_Repository_Remote_Proxy_Impl::create_fixed (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::UShort digits,
+    CORBA::Short scale,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
+  IR_FixedDef_ptr _tao_retval = IR_FixedDef::_nil ();
+  IR_FixedDef_var _tao_safe_retval (_tao_retval);
   
-  return exception_list;
-}
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "create_fixed",
+      12,
+      1,
+      istub->orb_core ()
+    );
 
-CORBA::Any * 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_value::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << digits) &&
+              (_tao_out << scale)
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-void 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_value::result (IR::ValueDef_ptr result)
-{
-  // update the result 
-  this->_result = result;
+  return _tao_safe_retval._retn ();
 }
 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_value_box::TAO_ClientRequestInfo_IR_Container_create_value_box (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::IDLType_ptr original_type_def,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    id_ (id),
-    name_ (name),
-    version_ (version),
-    original_type_def_ (original_type_def)
-{}
 
-Dynamic::ParameterList *
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_value_box::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_id = parameter_list->length ();
-  parameter_list->length (length_id + 1);
-  (*parameter_list)[length_id].argument <<= id_;
-  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_name = parameter_list->length ();
-  parameter_list->length (length_name + 1);
-  (*parameter_list)[length_name].argument <<= name_;
-  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_version = parameter_list->length ();
-  parameter_list->length (length_version + 1);
-  (*parameter_list)[length_version].argument <<= version_;
-  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_original_type_def = parameter_list->length ();
-  parameter_list->length (length_original_type_def + 1);
-  (*parameter_list)[length_original_type_def].argument <<=  this->original_type_def_;
-  
-  (*parameter_list)[length_original_type_def].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
+//
+//            End  Base & Remote  Proxy Implemeentation. 
+///////////////////////////////////////////////////////////////////////
 
-Dynamic::ExceptionList *
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_value_box::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
 
+///////////////////////////////////////////////////////////////////////
+//           Remote & Base  Proxy Broker Implementation
+//
 
-CORBA::Any * 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_value_box::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+_TAO_Repository_Proxy_Broker::_TAO_Repository_Proxy_Broker (void)
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
 }
 
-void 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_value_box::result (IR::ValueBoxDef_ptr result)
+_TAO_Repository_Proxy_Broker::~_TAO_Repository_Proxy_Broker (void)
 {
-  // update the result 
-  this->_result = result;
 }
 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_exception::TAO_ClientRequestInfo_IR_Container_create_exception (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * id,
-    const char * name,
-    const char * version,
-    const IR::StructMemberSeq & members,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    id_ (id),
-    name_ (name),
-    version_ (version),
-    members_ (members)
-{}
-
-Dynamic::ParameterList *
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_exception::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+// Factory function Implementation.
+_TAO_Repository_Remote_Proxy_Broker *the_TAO_Repository_Remote_Proxy_Broker (void)
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_id = parameter_list->length ();
-  parameter_list->length (length_id + 1);
-  (*parameter_list)[length_id].argument <<= id_;
-  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_name = parameter_list->length ();
-  parameter_list->length (length_name + 1);
-  (*parameter_list)[length_name].argument <<= name_;
-  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_version = parameter_list->length ();
-  parameter_list->length (length_version + 1);
-  (*parameter_list)[length_version].argument <<= version_;
-  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_members = parameter_list->length ();
-  parameter_list->length (length_members + 1);
-  (*parameter_list)[length_members].argument <<=  this->members_;
-  
-  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
+  static ::_TAO_Repository_Remote_Proxy_Broker remote_proxy_broker;
+  return &remote_proxy_broker;
 }
 
-Dynamic::ExceptionList *
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_exception::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+_TAO_Repository_Remote_Proxy_Broker::_TAO_Repository_Remote_Proxy_Broker (void)
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
 }
 
-
-CORBA::Any * 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_exception::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+_TAO_Repository_Remote_Proxy_Broker::~_TAO_Repository_Remote_Proxy_Broker (void)
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
 }
 
-void 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_exception::result (IR::ExceptionDef_ptr result)
+_TAO_Repository_Proxy_Impl&
+_TAO_Repository_Remote_Proxy_Broker::select_proxy (
+  ::IR_Repository *object,
+  CORBA::Environment &ACE_TRY_ENV
+)
 {
-  // update the result 
-  this->_result = result;
+  ACE_UNUSED_ARG (object);
+  ACE_UNUSED_ARG (ACE_TRY_ENV);
+  return remote_proxy_impl_;
 }
 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_native::TAO_ClientRequestInfo_IR_Container_create_native (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * id,
-    const char * name,
-    const char * version,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    id_ (id),
-    name_ (name),
-    version_ (version)
-{}
 
-Dynamic::ParameterList *
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_native::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_id = parameter_list->length ();
-  parameter_list->length (length_id + 1);
-  (*parameter_list)[length_id].argument <<= id_;
-  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_name = parameter_list->length ();
-  parameter_list->length (length_name + 1);
-  (*parameter_list)[length_name].argument <<= name_;
-  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_version = parameter_list->length ();
-  parameter_list->length (length_version + 1);
-  (*parameter_list)[length_version].argument <<= version_;
-  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
+//
+//           End Remote & Base Proxy Broker Implementation
+///////////////////////////////////////////////////////////////////////
 
-Dynamic::ExceptionList *
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_native::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+
+// default constructor
+IR_Repository::IR_Repository (int collocated)
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
+  this->_tao_setup_collocation (collocated);
 }
 
+// destructor
+IR_Repository::~IR_Repository (void)
+{}
 
-CORBA::Any * 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_native::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+void
+IR_Repository::_tao_setup_collocation (int collocated)
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
+  if (collocated)
+    this->the_TAO_Repository_Proxy_Broker_ =
+      _TAO_Repository_Proxy_Broker_Factory_function_pointer (this);
+  else
+    this->the_TAO_Repository_Proxy_Broker_ =
+      ::the_TAO_Repository_Remote_Proxy_Broker ();
   
-  CORBA::Any_var safe_result_any = result_any;
+  IR_Container::_tao_setup_collocation (collocated);
   
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
 }
 
-void 
-IR::Container::TAO_ClientRequestInfo_IR_Container_create_native::result (IR::NativeDef_ptr result)
+void IR_Repository::_tao_any_destructor (void *x)
 {
-  // update the result 
-  this->_result = result;
+  IR_Repository *tmp = ACE_static_cast (IR_Repository*,x);
+  CORBA::release (tmp);
 }
 
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_Container[] =
+IR_Repository_ptr IR_Repository::_narrow (
+    CORBA::Object_ptr obj,
+    CORBA::Environment &ACE_TRY_ENV
+  )
 {
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7461), ACE_NTOHL (0x696e6572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/Container:1.0
-  10, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x72000000),  // name = Container
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_Container (CORBA::tk_objref, sizeof (_oc_IR_Container), (char *) &_oc_IR_Container, 0, sizeof (IR::Container));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Container, &_tc_TAO_tc_IR_Container)
-TAO_NAMESPACE_END
-
-///////////////////////////////////////////////////////////////////////
-//                Base & Remote Proxy  Implementation. 
-//
-
-IR::_TAO_IDLType_Proxy_Impl::_TAO_IDLType_Proxy_Impl (void)
-{}
-
-IR::_TAO_IDLType_Remote_Proxy_Impl::_TAO_IDLType_Remote_Proxy_Impl (void)
-{}
-
-// Remote Implementation of the IDL interface methods
+  if (CORBA::is_nil (obj))
+    return IR_Repository::_nil ();
+  if (! obj->_is_local ())
+    {
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/Repository:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (IR_Repository::_nil ());
+      if (is_a == 0)
+        return IR_Repository::_nil ();
+    }
+  return IR_Repository::_unchecked_narrow (obj, ACE_TRY_ENV);
+}
 
-CORBA::TypeCode_ptr IR::_TAO_IDLType_Remote_Proxy_Impl::type (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
-  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_type",
-      9,
-      0,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::IDLType::TAO_ClientRequestInfo_IR_IDLType_type_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              CORBA::TypeCode_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
-}
-
-
-//
-//            End  Base & Remote  Proxy Implemeentation. 
-///////////////////////////////////////////////////////////////////////
-
-
-///////////////////////////////////////////////////////////////////////
-//           Remote & Base  Proxy Broker Implementation
-//
-
-IR::_TAO_IDLType_Proxy_Broker::_TAO_IDLType_Proxy_Broker (void)
-{
-}
-
-IR::_TAO_IDLType_Proxy_Broker::~_TAO_IDLType_Proxy_Broker (void)
-{
-}
-
-// Factory Member function Implementation.
-IR::_TAO_IDLType_Remote_Proxy_Broker *IR::_TAO_IDLType_Remote_Proxy_Broker::the_TAO_IDLType_Remote_Proxy_Broker (void)
-{
-  static ::IR::_TAO_IDLType_Remote_Proxy_Broker remote_proxy_broker;
-  return &remote_proxy_broker;
-}
-
-IR::_TAO_IDLType_Remote_Proxy_Broker::_TAO_IDLType_Remote_Proxy_Broker (void)
-{
-}
-
-IR::_TAO_IDLType_Remote_Proxy_Broker::~_TAO_IDLType_Remote_Proxy_Broker (void)
-{
-}
-
-IR::_TAO_IDLType_Proxy_Impl&
-IR::_TAO_IDLType_Remote_Proxy_Broker::select_proxy (
-  ::IR::IDLType *object,
-  CORBA::Environment &ACE_TRY_ENV
-)
-{
-  ACE_UNUSED_ARG (object);
-  ACE_UNUSED_ARG (ACE_TRY_ENV);
-  return remote_proxy_impl_;
-}
-
-
-//
-//           End Remote & Base Proxy Broker Implementation
-///////////////////////////////////////////////////////////////////////
-
-
-// default constructor
-IR::IDLType::IDLType (int collocated)
-{
-  this->_tao_setup_collocation (collocated);
-}
-
-// destructor
-IR::IDLType::~IDLType (void)
-{}
-
-void
-IR::IDLType::_tao_setup_collocation (int collocated)
-{
-  if (collocated)
-    this->the_TAO_IDLType_Proxy_Broker_ =
-      ::IR__TAO_IDLType_Proxy_Broker_Factory_function_pointer (this);
-  else
-    this->the_TAO_IDLType_Proxy_Broker_ =
-      ::IR::_TAO_IDLType_Remote_Proxy_Broker::the_TAO_IDLType_Remote_Proxy_Broker ();
-  
-  ACE_NESTED_CLASS (CORBA, IRObject)::_tao_setup_collocation (collocated);
-}
-
-void IR::IDLType::_tao_any_destructor (void *x)
-{
-  IDLType *tmp = ACE_static_cast (IDLType*,x);
-  CORBA::release (tmp);
-}
-
-IR::IDLType_ptr IR::IDLType::_narrow (
-    CORBA::Object_ptr obj,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-{
-  if (CORBA::is_nil (obj))
-    return IDLType::_nil ();
-  if (! obj->_is_local ())
-    {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/IDLType:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (IDLType::_nil ());
-      if (is_a == 0)
-        return IDLType::_nil ();
-    }
-  return IDLType::_unchecked_narrow (obj, ACE_TRY_ENV);
-}
-
-IR::IDLType_ptr IR::IDLType::_unchecked_narrow (
-    CORBA::Object_ptr obj,
-    CORBA::Environment &
+IR_Repository_ptr IR_Repository::_unchecked_narrow (
+    CORBA::Object_ptr obj,
+    CORBA::Environment &
   )
 {
   if (CORBA::is_nil (obj))
-    return IDLType::_nil ();
+    return IR_Repository::_nil ();
   if (! obj->_is_local ())
     {
       TAO_Stub* stub = obj->_stubobj ();
       if (stub)
         stub->_incr_refcnt ();
-      IDLType_ptr default_proxy = IDLType::_nil ();
+      IR_Repository_ptr default_proxy = IR_Repository::_nil ();
 
       if (
           !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
           stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_IDLType_Proxy_Broker_Factory_function_pointer != 0
+          obj->_is_collocated () &&_TAO_Repository_Proxy_Broker_Factory_function_pointer != 0
         )
       {
         ACE_NEW_RETURN (
           default_proxy,
-          ::IR::IDLType (
+          ::IR_Repository (
             stub,
             1,
             obj->_servant ()),
             
-          IDLType::_nil ());
+          IR_Repository::_nil ());
         }
       if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::IDLType (stub, 0, obj->_servant ()), IDLType::_nil ());
+        ACE_NEW_RETURN (default_proxy, ::IR_Repository (stub, 0, obj->_servant ()), IR_Repository::_nil ());
         return default_proxy;
       }
     else 
       return
         ACE_reinterpret_cast
           (
-            IDLType_ptr,
+            IR_Repository_ptr,
               obj->_tao_QueryInterface
                 (
                   ACE_reinterpret_cast
                     (
                       ptr_arith_t,
-                      &IDLType::_narrow
+                      &IR_Repository::_narrow
                     )
                 )
           );
 }
 
-IR::IDLType_ptr
-IR::IDLType::_duplicate (IDLType_ptr obj)
+IR_Repository_ptr
+IR_Repository::_duplicate (IR_Repository_ptr obj)
 {
   if (!CORBA::is_nil (obj))
     obj->_add_ref ();
   return obj;
 }
 
-CORBA::Boolean IR::IDLType::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+CORBA::Boolean IR_Repository::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
   if (
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Repository:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
   return 1; // success using local knowledge
@@ -11326,22 +7134,34 @@
     return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
 }
 
-void *IR::IDLType::_tao_QueryInterface (ptr_arith_t type)
+void *IR_Repository::_tao_QueryInterface (ptr_arith_t type)
 {
   void *retv = 0;
   if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, IDLType)::_narrow))
+      &IR_Repository::_narrow))
     retv = ACE_reinterpret_cast (void*, this);
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
+      &IR_Container::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            IR_Container_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &CORBA_IRObject::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            CORBA::IRObject_ptr,
+            CORBA_IRObject_ptr,
             this
           )
       );
@@ -11354,1570 +7174,378 @@
   return retv;
 }
 
-const char* IR::IDLType::_interface_repository_id (void) const
+const char* IR_Repository::_interface_repository_id (void) const
 {
-  return "IDL:omg.org/IR/IDLType:1.0";
+  return "IDL:omg.org/IR/Repository:1.0";
 }
 
-CORBA::TypeCode_ptr IR::IDLType::type (
+IR_Contained_ptr IR_Repository::lookup_id (
+   const char * search_id,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-  return this->the_TAO_IDLType_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type (
+  return this->the_TAO_Repository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).lookup_id (
       this,
+      search_id,
       ACE_TRY_ENV
     );
 }
 
+CORBA::TypeCode_ptr IR_Repository::get_canonical_typecode (
+    CORBA::TypeCode_ptr tc,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  return this->the_TAO_Repository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).get_canonical_typecode (
+      this,
+      tc,
+      ACE_TRY_ENV
+    );
+}
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-IR::IDLType::TAO_ClientRequestInfo_IR_IDLType_type_get::TAO_ClientRequestInfo_IR_IDLType_type_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
+IR_PrimitiveDef_ptr IR_Repository::get_primitive (
+    IR_PrimitiveKind kind,
+    CORBA::Environment &ACE_TRY_ENV
   )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  return this->the_TAO_Repository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).get_primitive (
+      this,
+      kind,
+      ACE_TRY_ENV
+    );
+}
 
-Dynamic::ParameterList *
-IR::IDLType::TAO_ClientRequestInfo_IR_IDLType_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+IR_StringDef_ptr IR_Repository::create_string (
+    CORBA::ULong bound,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
+  return this->the_TAO_Repository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_string (
+      this,
+      bound,
+      ACE_TRY_ENV
+    );
 }
 
-Dynamic::ExceptionList *
-IR::IDLType::TAO_ClientRequestInfo_IR_IDLType_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+IR_WstringDef_ptr IR_Repository::create_wstring (
+    CORBA::ULong bound,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
+  return this->the_TAO_Repository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_wstring (
+      this,
+      bound,
+      ACE_TRY_ENV
+    );
 }
 
+IR_SequenceDef_ptr IR_Repository::create_sequence (
+    CORBA::ULong bound,
+    IR_IDLType_ptr element_type,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  return this->the_TAO_Repository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_sequence (
+      this,
+      bound,
+      element_type,
+      ACE_TRY_ENV
+    );
+}
 
-CORBA::Any * 
-IR::IDLType::TAO_ClientRequestInfo_IR_IDLType_type_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+IR_ArrayDef_ptr IR_Repository::create_array (
+    CORBA::ULong length,
+    IR_IDLType_ptr element_type,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
+  return this->the_TAO_Repository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_array (
+      this,
+      length,
+      element_type,
+      ACE_TRY_ENV
+    );
 }
 
-void 
-IR::IDLType::TAO_ClientRequestInfo_IR_IDLType_type_get::result (CORBA::TypeCode_ptr result)
+IR_FixedDef_ptr IR_Repository::create_fixed (
+    CORBA::UShort digits,
+    CORBA::Short scale,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // update the result 
-  this->_result = result;
+  return this->the_TAO_Repository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_fixed (
+      this,
+      digits,
+      scale,
+      ACE_TRY_ENV
+    );
 }
 
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_IDLType[] =
+static const CORBA::Long _oc_IR_Repository[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
-  27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
-  8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType
+  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x793a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Repository:1.0
+  11, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72790000),  // name = IR_Repository
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_IDLType (CORBA::tk_objref, sizeof (_oc_IR_IDLType), (char *) &_oc_IR_IDLType, 0, sizeof (IR::IDLType));
+static CORBA::TypeCode _tc_TAO_tc_IR_Repository (CORBA::tk_objref, sizeof (_oc_IR_Repository), (char *) &_oc_IR_Repository, 0, sizeof (IR_Repository));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_IDLType, &_tc_TAO_tc_IR_IDLType)
-TAO_NAMESPACE_END
-static const CORBA::Long _oc_IR_PrimitiveKind[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x72696d69), ACE_NTOHL (0x74697665), ACE_NTOHL (0x4b696e64), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/PrimitiveKind:1.0
-  14, ACE_NTOHL (0x5072696d), ACE_NTOHL (0x69746976), ACE_NTOHL (0x654b696e), ACE_NTOHL (0x64000000),  // name = PrimitiveKind
-  22, // member count
-  8, ACE_NTOHL (0x706b5f6e), ACE_NTOHL (0x756c6c00),  // name = pk_null
-  8, ACE_NTOHL (0x706b5f76), ACE_NTOHL (0x6f696400),  // name = pk_void
-  9, ACE_NTOHL (0x706b5f73), ACE_NTOHL (0x686f7274), ACE_NTOHL (0x0),  // name = pk_short
-  8, ACE_NTOHL (0x706b5f6c), ACE_NTOHL (0x6f6e6700),  // name = pk_long
-  10, ACE_NTOHL (0x706b5f75), ACE_NTOHL (0x73686f72), ACE_NTOHL (0x74000000),  // name = pk_ushort
-  9, ACE_NTOHL (0x706b5f75), ACE_NTOHL (0x6c6f6e67), ACE_NTOHL (0x0),  // name = pk_ulong
-  9, ACE_NTOHL (0x706b5f66), ACE_NTOHL (0x6c6f6174), ACE_NTOHL (0x0),  // name = pk_float
-  10, ACE_NTOHL (0x706b5f64), ACE_NTOHL (0x6f75626c), ACE_NTOHL (0x65000000),  // name = pk_double
-  11, ACE_NTOHL (0x706b5f62), ACE_NTOHL (0x6f6f6c65), ACE_NTOHL (0x616e0000),  // name = pk_boolean
-  8, ACE_NTOHL (0x706b5f63), ACE_NTOHL (0x68617200),  // name = pk_char
-  9, ACE_NTOHL (0x706b5f6f), ACE_NTOHL (0x63746574), ACE_NTOHL (0x0),  // name = pk_octet
-  7, ACE_NTOHL (0x706b5f61), ACE_NTOHL (0x6e790000),  // name = pk_any
-  12, ACE_NTOHL (0x706b5f54), ACE_NTOHL (0x79706543), ACE_NTOHL (0x6f646500),  // name = pk_TypeCode
-  13, ACE_NTOHL (0x706b5f50), ACE_NTOHL (0x72696e63), ACE_NTOHL (0x6970616c), ACE_NTOHL (0x0),  // name = pk_Principal
-  10, ACE_NTOHL (0x706b5f73), ACE_NTOHL (0x7472696e), ACE_NTOHL (0x67000000),  // name = pk_string
-  10, ACE_NTOHL (0x706b5f6f), ACE_NTOHL (0x626a7265), ACE_NTOHL (0x66000000),  // name = pk_objref
-  12, ACE_NTOHL (0x706b5f6c), ACE_NTOHL (0x6f6e676c), ACE_NTOHL (0x6f6e6700),  // name = pk_longlong
-  13, ACE_NTOHL (0x706b5f75), ACE_NTOHL (0x6c6f6e67), ACE_NTOHL (0x6c6f6e67), ACE_NTOHL (0x0),  // name = pk_ulonglong
-  14, ACE_NTOHL (0x706b5f6c), ACE_NTOHL (0x6f6e6764), ACE_NTOHL (0x6f75626c), ACE_NTOHL (0x65000000),  // name = pk_longdouble
-  9, ACE_NTOHL (0x706b5f77), ACE_NTOHL (0x63686172), ACE_NTOHL (0x0),  // name = pk_wchar
-  11, ACE_NTOHL (0x706b5f77), ACE_NTOHL (0x73747269), ACE_NTOHL (0x6e670000),  // name = pk_wstring
-  14, ACE_NTOHL (0x706b5f76), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x5f626173), ACE_NTOHL (0x65000000),  // name = pk_value_base
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_PrimitiveKind (CORBA::tk_enum, sizeof (_oc_IR_PrimitiveKind), (char *) &_oc_IR_PrimitiveKind, 0, sizeof (IR::PrimitiveKind));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PrimitiveKind, &_tc_TAO_tc_IR_PrimitiveKind)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Repository, &_tc_TAO_tc_IR_Repository)
 TAO_NAMESPACE_END
 
 ///////////////////////////////////////////////////////////////////////
 //                Base & Remote Proxy  Implementation. 
 //
 
-IR::_TAO_Repository_Proxy_Impl::_TAO_Repository_Proxy_Impl (void)
+_TAO_ComponentRepository_Proxy_Impl::_TAO_ComponentRepository_Proxy_Impl (void)
 {}
 
-IR::_TAO_Repository_Remote_Proxy_Impl::_TAO_Repository_Remote_Proxy_Impl (void)
+_TAO_ComponentRepository_Remote_Proxy_Impl::_TAO_ComponentRepository_Remote_Proxy_Impl (void)
 {}
 
 // Remote Implementation of the IDL interface methods
 
-IR::Contained_ptr IR::_TAO_Repository_Remote_Proxy_Impl::lookup_id (
+IR_ComponentDef_ptr _TAO_ComponentRepository_Remote_Proxy_Impl::create_component (
     CORBA_Object *_collocated_tao_target_,
-    const char * search_id,
+    const char * id,
+    const char * name,
+    const char * version,
+    IR_ComponentDef_ptr base_component,
+    const IR_InterfaceDefSeq & supports_interfaces,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-  IR::Contained_ptr _tao_retval = IR::Contained::_nil ();
-  IR::Contained_var _tao_safe_retval (_tao_retval);
-  
+  IR_ComponentDef_ptr _tao_retval = IR_ComponentDef::_nil ();
+  IR_ComponentDef_var _tao_safe_retval (_tao_retval);
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
   
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "lookup_id",
-      9,
+      "create_component",
+      16,
       1,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << id) &&
+              (_tao_out << name) &&
+              (_tao_out << version) &&
+              (_tao_out << base_component) &&
+              (_tao_out << supports_interfaces)
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
       
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Repository::TAO_ClientRequestInfo_IR_Repository_lookup_id ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        search_id,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << search_id)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
               0
             );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
                 CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                 0
               );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::Contained_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
-CORBA::TypeCode_ptr IR::_TAO_Repository_Remote_Proxy_Impl::get_canonical_typecode (
+IR_HomeDef_ptr _TAO_ComponentRepository_Remote_Proxy_Impl::create_home (
     CORBA_Object *_collocated_tao_target_,
-    CORBA::TypeCode_ptr tc,
+    const char * id,
+    const char * name,
+    const char * version,
+    IR_HomeDef_ptr base_home,
+    IR_ComponentDef_ptr managed_component,
+    IR_ValueDef_ptr primary_key,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
-  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
-  
+  IR_HomeDef_ptr _tao_retval = IR_HomeDef::_nil ();
+  IR_HomeDef_var _tao_safe_retval (_tao_retval);
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-  
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "get_canonical_typecode",
-      22,
+      "create_home",
+      11,
       1,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << id) &&
+              (_tao_out << name) &&
+              (_tao_out << version) &&
+              (_tao_out << base_home) &&
+              (_tao_out << managed_component) &&
+              (_tao_out << primary_key)
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
       
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Repository::TAO_ClientRequestInfo_IR_Repository_get_canonical_typecode ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        tc,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << tc)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
               0
             );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
                 CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                 0
               );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              CORBA::TypeCode_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
-IR::PrimitiveDef_ptr IR::_TAO_Repository_Remote_Proxy_Impl::get_primitive (
-    CORBA_Object *_collocated_tao_target_,
-    IR::PrimitiveKind kind,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  IR::PrimitiveDef_ptr _tao_retval = IR::PrimitiveDef::_nil ();
-  IR::PrimitiveDef_var _tao_safe_retval (_tao_retval);
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "get_primitive",
-      13,
-      1,
-      istub->orb_core ()
-    );
+//
+//            End  Base & Remote  Proxy Implemeentation. 
+///////////////////////////////////////////////////////////////////////
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Repository::TAO_ClientRequestInfo_IR_Repository_get_primitive ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        kind,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << kind)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
-              0
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::PrimitiveDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
+///////////////////////////////////////////////////////////////////////
+//           Remote & Base  Proxy Broker Implementation
+//
+
+_TAO_ComponentRepository_Proxy_Broker::_TAO_ComponentRepository_Proxy_Broker (void)
+{
 }
 
-IR::StringDef_ptr IR::_TAO_Repository_Remote_Proxy_Impl::create_string (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::ULong bound,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
+_TAO_ComponentRepository_Proxy_Broker::~_TAO_ComponentRepository_Proxy_Broker (void)
 {
-  
-  IR::StringDef_ptr _tao_retval = IR::StringDef::_nil ();
-  IR::StringDef_var _tao_safe_retval (_tao_retval);
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+}
 
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "create_string",
-      13,
-      1,
-      istub->orb_core ()
-    );
+// Factory function Implementation.
+_TAO_ComponentRepository_Remote_Proxy_Broker *the_TAO_ComponentRepository_Remote_Proxy_Broker (void)
+{
+  static ::_TAO_ComponentRepository_Remote_Proxy_Broker remote_proxy_broker;
+  return &remote_proxy_broker;
+}
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Repository::TAO_ClientRequestInfo_IR_Repository_create_string ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        bound,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << bound)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
-              0
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::StringDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+_TAO_ComponentRepository_Remote_Proxy_Broker::_TAO_ComponentRepository_Remote_Proxy_Broker (void)
+{
+}
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
+_TAO_ComponentRepository_Remote_Proxy_Broker::~_TAO_ComponentRepository_Remote_Proxy_Broker (void)
+{
 }
 
-IR::WstringDef_ptr IR::_TAO_Repository_Remote_Proxy_Impl::create_wstring (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::ULong bound,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
+_TAO_ComponentRepository_Proxy_Impl&
+_TAO_ComponentRepository_Remote_Proxy_Broker::select_proxy (
+  ::IR_ComponentRepository *object,
+  CORBA::Environment &ACE_TRY_ENV
+)
 {
-  
-  IR::WstringDef_ptr _tao_retval = IR::WstringDef::_nil ();
-  IR::WstringDef_var _tao_safe_retval (_tao_retval);
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "create_wstring",
-      14,
-      1,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Repository::TAO_ClientRequestInfo_IR_Repository_create_wstring ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        bound,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << bound)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
-              0
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::WstringDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
-}
-
-IR::SequenceDef_ptr IR::_TAO_Repository_Remote_Proxy_Impl::create_sequence (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::ULong bound,
-    IR::IDLType_ptr element_type,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  IR::SequenceDef_ptr _tao_retval = IR::SequenceDef::_nil ();
-  IR::SequenceDef_var _tao_safe_retval (_tao_retval);
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "create_sequence",
-      15,
-      1,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Repository::TAO_ClientRequestInfo_IR_Repository_create_sequence ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        bound,
-        element_type,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << bound) &&
-              (_tao_out << element_type)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
-              0
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::SequenceDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
-}
-
-IR::ArrayDef_ptr IR::_TAO_Repository_Remote_Proxy_Impl::create_array (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::ULong length,
-    IR::IDLType_ptr element_type,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  IR::ArrayDef_ptr _tao_retval = IR::ArrayDef::_nil ();
-  IR::ArrayDef_var _tao_safe_retval (_tao_retval);
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "create_array",
-      12,
-      1,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Repository::TAO_ClientRequestInfo_IR_Repository_create_array ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        length,
-        element_type,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << length) &&
-              (_tao_out << element_type)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
-              0
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::ArrayDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
-}
-
-IR::FixedDef_ptr IR::_TAO_Repository_Remote_Proxy_Impl::create_fixed (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::UShort digits,
-    CORBA::Short scale,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  IR::FixedDef_ptr _tao_retval = IR::FixedDef::_nil ();
-  IR::FixedDef_var _tao_safe_retval (_tao_retval);
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "create_fixed",
-      12,
-      1,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::Repository::TAO_ClientRequestInfo_IR_Repository_create_fixed ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        digits,
-        scale,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << digits) &&
-              (_tao_out << scale)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
-              0
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::FixedDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
-}
-
-
-//
-//            End  Base & Remote  Proxy Implemeentation. 
-///////////////////////////////////////////////////////////////////////
-
-
-///////////////////////////////////////////////////////////////////////
-//           Remote & Base  Proxy Broker Implementation
-//
-
-IR::_TAO_Repository_Proxy_Broker::_TAO_Repository_Proxy_Broker (void)
-{
-}
-
-IR::_TAO_Repository_Proxy_Broker::~_TAO_Repository_Proxy_Broker (void)
-{
-}
-
-// Factory Member function Implementation.
-IR::_TAO_Repository_Remote_Proxy_Broker *IR::_TAO_Repository_Remote_Proxy_Broker::the_TAO_Repository_Remote_Proxy_Broker (void)
-{
-  static ::IR::_TAO_Repository_Remote_Proxy_Broker remote_proxy_broker;
-  return &remote_proxy_broker;
-}
-
-IR::_TAO_Repository_Remote_Proxy_Broker::_TAO_Repository_Remote_Proxy_Broker (void)
-{
-}
-
-IR::_TAO_Repository_Remote_Proxy_Broker::~_TAO_Repository_Remote_Proxy_Broker (void)
-{
-}
-
-IR::_TAO_Repository_Proxy_Impl&
-IR::_TAO_Repository_Remote_Proxy_Broker::select_proxy (
-  ::IR::Repository *object,
-  CORBA::Environment &ACE_TRY_ENV
-)
-{
-  ACE_UNUSED_ARG (object);
-  ACE_UNUSED_ARG (ACE_TRY_ENV);
-  return remote_proxy_impl_;
-}
+  ACE_UNUSED_ARG (object);
+  ACE_UNUSED_ARG (ACE_TRY_ENV);
+  return remote_proxy_impl_;
+}
 
 
 //
@@ -12926,111 +7554,113 @@
 
 
 // default constructor
-IR::Repository::Repository (int collocated)
+IR_ComponentRepository::IR_ComponentRepository (int collocated)
 {
   this->_tao_setup_collocation (collocated);
 }
 
 // destructor
-IR::Repository::~Repository (void)
+IR_ComponentRepository::~IR_ComponentRepository (void)
 {}
 
 void
-IR::Repository::_tao_setup_collocation (int collocated)
+IR_ComponentRepository::_tao_setup_collocation (int collocated)
 {
   if (collocated)
-    this->the_TAO_Repository_Proxy_Broker_ =
-      ::IR__TAO_Repository_Proxy_Broker_Factory_function_pointer (this);
+    this->the_TAO_ComponentRepository_Proxy_Broker_ =
+      _TAO_ComponentRepository_Proxy_Broker_Factory_function_pointer (this);
   else
-    this->the_TAO_Repository_Proxy_Broker_ =
-      ::IR::_TAO_Repository_Remote_Proxy_Broker::the_TAO_Repository_Remote_Proxy_Broker ();
+    this->the_TAO_ComponentRepository_Proxy_Broker_ =
+      ::the_TAO_ComponentRepository_Remote_Proxy_Broker ();
+  
+  IR_Repository::_tao_setup_collocation (collocated);
   
-  ACE_NESTED_CLASS (IR, Container)::_tao_setup_collocation (collocated);
 }
 
-void IR::Repository::_tao_any_destructor (void *x)
+void IR_ComponentRepository::_tao_any_destructor (void *x)
 {
-  Repository *tmp = ACE_static_cast (Repository*,x);
+  IR_ComponentRepository *tmp = ACE_static_cast (IR_ComponentRepository*,x);
   CORBA::release (tmp);
 }
 
-IR::Repository_ptr IR::Repository::_narrow (
+IR_ComponentRepository_ptr IR_ComponentRepository::_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
 {
   if (CORBA::is_nil (obj))
-    return Repository::_nil ();
+    return IR_ComponentRepository::_nil ();
   if (! obj->_is_local ())
     {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/Repository:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (Repository::_nil ());
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ComponentRepository:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (IR_ComponentRepository::_nil ());
       if (is_a == 0)
-        return Repository::_nil ();
+        return IR_ComponentRepository::_nil ();
     }
-  return Repository::_unchecked_narrow (obj, ACE_TRY_ENV);
+  return IR_ComponentRepository::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::Repository_ptr IR::Repository::_unchecked_narrow (
+IR_ComponentRepository_ptr IR_ComponentRepository::_unchecked_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &
   )
 {
   if (CORBA::is_nil (obj))
-    return Repository::_nil ();
+    return IR_ComponentRepository::_nil ();
   if (! obj->_is_local ())
     {
       TAO_Stub* stub = obj->_stubobj ();
       if (stub)
         stub->_incr_refcnt ();
-      Repository_ptr default_proxy = Repository::_nil ();
+      IR_ComponentRepository_ptr default_proxy = IR_ComponentRepository::_nil ();
 
       if (
           !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
           stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_Repository_Proxy_Broker_Factory_function_pointer != 0
+          obj->_is_collocated () &&_TAO_ComponentRepository_Proxy_Broker_Factory_function_pointer != 0
         )
       {
         ACE_NEW_RETURN (
           default_proxy,
-          ::IR::Repository (
+          ::IR_ComponentRepository (
             stub,
             1,
             obj->_servant ()),
             
-          Repository::_nil ());
+          IR_ComponentRepository::_nil ());
         }
       if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::Repository (stub, 0, obj->_servant ()), Repository::_nil ());
+        ACE_NEW_RETURN (default_proxy, ::IR_ComponentRepository (stub, 0, obj->_servant ()), IR_ComponentRepository::_nil ());
         return default_proxy;
       }
     else 
       return
         ACE_reinterpret_cast
           (
-            Repository_ptr,
+            IR_ComponentRepository_ptr,
               obj->_tao_QueryInterface
                 (
                   ACE_reinterpret_cast
                     (
                       ptr_arith_t,
-                      &Repository::_narrow
+                      &IR_ComponentRepository::_narrow
                     )
                 )
           );
 }
 
-IR::Repository_ptr
-IR::Repository::_duplicate (Repository_ptr obj)
+IR_ComponentRepository_ptr
+IR_ComponentRepository::_duplicate (IR_ComponentRepository_ptr obj)
 {
   if (!CORBA::is_nil (obj))
     obj->_add_ref ();
   return obj;
 }
 
-CORBA::Boolean IR::Repository::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+CORBA::Boolean IR_ComponentRepository::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
   if (
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ComponentRepository:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Repository:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
@@ -13040,38 +7670,50 @@
     return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
 }
 
-void *IR::Repository::_tao_QueryInterface (ptr_arith_t type)
+void *IR_ComponentRepository::_tao_QueryInterface (ptr_arith_t type)
 {
   void *retv = 0;
   if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Repository)::_narrow))
+      &IR_ComponentRepository::_narrow))
     retv = ACE_reinterpret_cast (void*, this);
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Container)::_narrow))
+      &IR_Repository::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::Container_ptr,
+            IR_Repository_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
+      &IR_Container::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            CORBA::IRObject_ptr,
+            IR_Container_ptr,
             this
           )
       );
-  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &CORBA_IRObject::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            CORBA_IRObject_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
     retv = ACE_reinterpret_cast (void *,
       ACE_static_cast (CORBA::Object_ptr, this));
     
@@ -13080,1088 +7722,717 @@
   return retv;
 }
 
-const char* IR::Repository::_interface_repository_id (void) const
+const char* IR_ComponentRepository::_interface_repository_id (void) const
 {
-  return "IDL:omg.org/IR/Repository:1.0";
+  return "IDL:omg.org/IR/ComponentRepository:1.0";
 }
 
-IR::Contained_ptr IR::Repository::lookup_id (
-    const char * search_id,
+IR_ComponentDef_ptr IR_ComponentRepository::create_component (
+    const char * id,
+    const char * name,
+    const char * version,
+    IR_ComponentDef_ptr base_component,
+    const IR_InterfaceDefSeq & supports_interfaces,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-  return this->the_TAO_Repository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).lookup_id (
+  return this->the_TAO_ComponentRepository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_component (
       this,
-      search_id,
+      id,
+      name,
+      version,
+      base_component,
+      supports_interfaces,
       ACE_TRY_ENV
     );
 }
 
-CORBA::TypeCode_ptr IR::Repository::get_canonical_typecode (
-    CORBA::TypeCode_ptr tc,
+IR_HomeDef_ptr IR_ComponentRepository::create_home (
+    const char * id,
+    const char * name,
+    const char * version,
+    IR_HomeDef_ptr base_home,
+    IR_ComponentDef_ptr managed_component,
+    IR_ValueDef_ptr primary_key,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
-{
-  
-  return this->the_TAO_Repository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).get_canonical_typecode (
+{ 
+  return this->the_TAO_ComponentRepository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_home (
       this,
-      tc,
+      id,
+      name,
+      version,
+      base_home,
+      managed_component,
+      primary_key,
       ACE_TRY_ENV
     );
 }
 
-IR::PrimitiveDef_ptr IR::Repository::get_primitive (
-    IR::PrimitiveKind kind,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
+static const CORBA::Long _oc_IR_ComponentRepository[] =
 {
-  
-  return this->the_TAO_Repository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).get_primitive (
-      this,
-      kind,
-      ACE_TRY_ENV
-    );
-}
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  39, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6d706f), ACE_NTOHL (0x6e656e74), ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72793a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ComponentRepository:1.0
+  20, ACE_NTOHL (0x436f6d70), ACE_NTOHL (0x6f6e656e), ACE_NTOHL (0x74526570), ACE_NTOHL (0x6f736974), ACE_NTOHL (0x6f727900),  // name = IR_ComponentRepository
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_ComponentRepository (CORBA::tk_objref, sizeof (_oc_IR_ComponentRepository), (char *) &_oc_IR_ComponentRepository, 0, sizeof (IR_ComponentRepository));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ComponentRepository, &_tc_TAO_tc_IR_ComponentRepository)
+TAO_NAMESPACE_END
 
-IR::StringDef_ptr IR::Repository::create_string (
-    CORBA::ULong bound,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_Repository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_string (
-      this,
-      bound,
-      ACE_TRY_ENV
-    );
-}
+///////////////////////////////////////////////////////////////////////
+//                Base & Remote Proxy  Implementation. 
+//
 
-IR::WstringDef_ptr IR::Repository::create_wstring (
-    CORBA::ULong bound,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_Repository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_wstring (
-      this,
-      bound,
-      ACE_TRY_ENV
-    );
-}
+_TAO_ModuleDef_Proxy_Impl::_TAO_ModuleDef_Proxy_Impl (void)
+{}
 
-IR::SequenceDef_ptr IR::Repository::create_sequence (
-    CORBA::ULong bound,
-    IR::IDLType_ptr element_type,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_Repository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_sequence (
-      this,
-      bound,
-      element_type,
-      ACE_TRY_ENV
-    );
-}
+_TAO_ModuleDef_Remote_Proxy_Impl::_TAO_ModuleDef_Remote_Proxy_Impl (void)
+{}
 
-IR::ArrayDef_ptr IR::Repository::create_array (
-    CORBA::ULong length,
-    IR::IDLType_ptr element_type,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_Repository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_array (
-      this,
-      length,
-      element_type,
-      ACE_TRY_ENV
-    );
-}
+// Remote Implementation of the IDL interface methods
 
-IR::FixedDef_ptr IR::Repository::create_fixed (
-    CORBA::UShort digits,
-    CORBA::Short scale,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_Repository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_fixed (
-      this,
-      digits,
-      scale,
-      ACE_TRY_ENV
-    );
-}
+
+//
+//            End  Base & Remote  Proxy Implemeentation. 
+///////////////////////////////////////////////////////////////////////
 
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_lookup_id::TAO_ClientRequestInfo_IR_Repository_lookup_id (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * search_id,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    search_id_ (search_id)
-{}
+///////////////////////////////////////////////////////////////////////
+//           Remote & Base  Proxy Broker Implementation
+//
 
-Dynamic::ParameterList *
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_lookup_id::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+_TAO_ModuleDef_Proxy_Broker::_TAO_ModuleDef_Proxy_Broker (void)
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_search_id = parameter_list->length ();
-  parameter_list->length (length_search_id + 1);
-  (*parameter_list)[length_search_id].argument <<= search_id_;
-  (*parameter_list)[length_search_id].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
 }
 
-Dynamic::ExceptionList *
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_lookup_id::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+_TAO_ModuleDef_Proxy_Broker::~_TAO_ModuleDef_Proxy_Broker (void)
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
 }
 
-
-CORBA::Any * 
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_lookup_id::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+// Factory function Implementation.
+_TAO_ModuleDef_Remote_Proxy_Broker *the_TAO_ModuleDef_Remote_Proxy_Broker (void)
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
+  static ::_TAO_ModuleDef_Remote_Proxy_Broker remote_proxy_broker;
+  return &remote_proxy_broker;
 }
 
-void 
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_lookup_id::result (IR::Contained_ptr result)
+_TAO_ModuleDef_Remote_Proxy_Broker::_TAO_ModuleDef_Remote_Proxy_Broker (void)
 {
-  // update the result 
-  this->_result = result;
 }
 
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_get_canonical_typecode::TAO_ClientRequestInfo_IR_Repository_get_canonical_typecode (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::TypeCode_ptr tc,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    tc_ (tc)
-{}
-
-Dynamic::ParameterList *
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_get_canonical_typecode::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+_TAO_ModuleDef_Remote_Proxy_Broker::~_TAO_ModuleDef_Remote_Proxy_Broker (void)
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_tc = parameter_list->length ();
-  parameter_list->length (length_tc + 1);
-  (*parameter_list)[length_tc].argument <<= tc_;
-  (*parameter_list)[length_tc].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
 }
 
-Dynamic::ExceptionList *
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_get_canonical_typecode::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+_TAO_ModuleDef_Proxy_Impl&
+_TAO_ModuleDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_ModuleDef *object,
+  CORBA::Environment &ACE_TRY_ENV
+)
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
+  ACE_UNUSED_ARG (object);
+  ACE_UNUSED_ARG (ACE_TRY_ENV);
+  return remote_proxy_impl_;
 }
 
 
-CORBA::Any * 
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_get_canonical_typecode::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
+//
+//           End Remote & Base Proxy Broker Implementation
+///////////////////////////////////////////////////////////////////////
+
 
-void 
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_get_canonical_typecode::result (CORBA::TypeCode_ptr result)
+// default constructor
+IR_ModuleDef::IR_ModuleDef (int collocated)
 {
-  // update the result 
-  this->_result = result;
+  this->_tao_setup_collocation (collocated);
 }
 
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_get_primitive::TAO_ClientRequestInfo_IR_Repository_get_primitive (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    IR::PrimitiveKind & kind,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    kind_ (kind)
+// destructor
+IR_ModuleDef::~IR_ModuleDef (void)
 {}
 
-Dynamic::ParameterList *
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_get_primitive::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+void
+IR_ModuleDef::_tao_setup_collocation (int collocated)
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_kind = parameter_list->length ();
-  parameter_list->length (length_kind + 1);
-  (*parameter_list)[length_kind].argument <<=  this->kind_;
-  
-  (*parameter_list)[length_kind].mode = Dynamic::PARAM_IN;
+  if (collocated)
+    this->the_TAO_ModuleDef_Proxy_Broker_ =
+      _TAO_ModuleDef_Proxy_Broker_Factory_function_pointer (this);
+  else
+    this->the_TAO_ModuleDef_Proxy_Broker_ =
+      ::the_TAO_ModuleDef_Remote_Proxy_Broker ();
   
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_get_primitive::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
+  IR_Container::_tao_setup_collocation (collocated);
+  IR_Contained::_tao_setup_collocation (collocated);
   
-  return exception_list;
 }
 
-
-CORBA::Any * 
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_get_primitive::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+void IR_ModuleDef::_tao_any_destructor (void *x)
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
+  IR_ModuleDef *tmp = ACE_static_cast (IR_ModuleDef*,x);
+  CORBA::release (tmp);
 }
 
-void 
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_get_primitive::result (IR::PrimitiveDef_ptr result)
+IR_ModuleDef_ptr IR_ModuleDef::_narrow (
+    CORBA::Object_ptr obj,
+    CORBA::Environment &ACE_TRY_ENV
+  )
 {
-  // update the result 
-  this->_result = result;
+  if (CORBA::is_nil (obj))
+    return IR_ModuleDef::_nil ();
+  if (! obj->_is_local ())
+    {
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ModuleDef:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (IR_ModuleDef::_nil ());
+      if (is_a == 0)
+        return IR_ModuleDef::_nil ();
+    }
+  return IR_ModuleDef::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_create_string::TAO_ClientRequestInfo_IR_Repository_create_string (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const CORBA::ULong & bound,
-    CORBA::Environment &    
+IR_ModuleDef_ptr IR_ModuleDef::_unchecked_narrow (
+    CORBA::Object_ptr obj,
+    CORBA::Environment &
   )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    bound_ (bound)
-{}
-
-Dynamic::ParameterList *
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_create_string::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_bound = parameter_list->length ();
-  parameter_list->length (length_bound + 1);
-  (*parameter_list)[length_bound].argument <<= bound_;
-  (*parameter_list)[length_bound].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
+  if (CORBA::is_nil (obj))
+    return IR_ModuleDef::_nil ();
+  if (! obj->_is_local ())
+    {
+      TAO_Stub* stub = obj->_stubobj ();
+      if (stub)
+        stub->_incr_refcnt ();
+      IR_ModuleDef_ptr default_proxy = IR_ModuleDef::_nil ();
+
+      if (
+          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
+          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
+          obj->_is_collocated () &&_TAO_ModuleDef_Proxy_Broker_Factory_function_pointer != 0
+        )
+      {
+        ACE_NEW_RETURN (
+          default_proxy,
+          ::IR_ModuleDef (
+            stub,
+            1,
+            obj->_servant ()),
+            
+          IR_ModuleDef::_nil ());
+        }
+      if (CORBA::is_nil (default_proxy))
+        ACE_NEW_RETURN (default_proxy, ::IR_ModuleDef (stub, 0, obj->_servant ()), IR_ModuleDef::_nil ());
+        return default_proxy;
+      }
+    else 
+      return
+        ACE_reinterpret_cast
+          (
+            IR_ModuleDef_ptr,
+              obj->_tao_QueryInterface
+                (
+                  ACE_reinterpret_cast
+                    (
+                      ptr_arith_t,
+                      &IR_ModuleDef::_narrow
+                    )
+                )
+          );
 }
 
-Dynamic::ExceptionList *
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_create_string::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+IR_ModuleDef_ptr
+IR_ModuleDef::_duplicate (IR_ModuleDef_ptr obj)
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
+  if (!CORBA::is_nil (obj))
+    obj->_add_ref ();
+  return obj;
 }
 
-
-CORBA::Any * 
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_create_string::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+CORBA::Boolean IR_ModuleDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_create_string::result (IR::StringDef_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_create_wstring::TAO_ClientRequestInfo_IR_Repository_create_wstring (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const CORBA::ULong & bound,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    bound_ (bound)
-{}
-
-Dynamic::ParameterList *
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_create_wstring::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_bound = parameter_list->length ();
-  parameter_list->length (length_bound + 1);
-  (*parameter_list)[length_bound].argument <<= bound_;
-  (*parameter_list)[length_bound].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_create_wstring::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_create_wstring::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_create_wstring::result (IR::WstringDef_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_create_sequence::TAO_ClientRequestInfo_IR_Repository_create_sequence (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const CORBA::ULong & bound,
-    IR::IDLType_ptr element_type,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    bound_ (bound),
-    element_type_ (element_type)
-{}
-
-Dynamic::ParameterList *
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_create_sequence::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_bound = parameter_list->length ();
-  parameter_list->length (length_bound + 1);
-  (*parameter_list)[length_bound].argument <<= bound_;
-  (*parameter_list)[length_bound].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_element_type = parameter_list->length ();
-  parameter_list->length (length_element_type + 1);
-  (*parameter_list)[length_element_type].argument <<=  this->element_type_;
-  
-  (*parameter_list)[length_element_type].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_create_sequence::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_create_sequence::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_create_sequence::result (IR::SequenceDef_ptr result)
-{
-  // update the result 
-  this->_result = result;
+  if (
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ModuleDef:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
+  return 1; // success using local knowledge
+  else
+    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
 }
 
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_create_array::TAO_ClientRequestInfo_IR_Repository_create_array (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const CORBA::ULong & length,
-    IR::IDLType_ptr element_type,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    length_ (length),
-    element_type_ (element_type)
-{}
-
-Dynamic::ParameterList *
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_create_array::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+void *IR_ModuleDef::_tao_QueryInterface (ptr_arith_t type)
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_length = parameter_list->length ();
-  parameter_list->length (length_length + 1);
-  (*parameter_list)[length_length].argument <<= length_;
-  (*parameter_list)[length_length].mode = Dynamic::PARAM_IN;
+  void *retv = 0;
+  if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_ModuleDef::_narrow))
+    retv = ACE_reinterpret_cast (void*, this);
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_Container::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            IR_Container_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_Contained::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            IR_Contained_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &CORBA_IRObject::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            CORBA_IRObject_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
+    retv = ACE_reinterpret_cast (void *,
+      ACE_static_cast (CORBA::Object_ptr, this));
     
-  CORBA::ULong length_element_type = parameter_list->length ();
-  parameter_list->length (length_element_type + 1);
-  (*parameter_list)[length_element_type].argument <<=  this->element_type_;
-  
-  (*parameter_list)[length_element_type].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_create_array::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_create_array::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
+  if (retv)
+    this->_add_ref ();
+  return retv;
 }
 
-void 
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_create_array::result (IR::ArrayDef_ptr result)
+const char* IR_ModuleDef::_interface_repository_id (void) const
 {
-  // update the result 
-  this->_result = result;
+  return "IDL:omg.org/IR/ModuleDef:1.0";
 }
 
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_create_fixed::TAO_ClientRequestInfo_IR_Repository_create_fixed (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const CORBA::UShort & digits,
-    const CORBA::Short & scale,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    digits_ (digits),
-    scale_ (scale)
-{}
-
-Dynamic::ParameterList *
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_create_fixed::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+static const CORBA::Long _oc_IR_ModuleDef[] =
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_digits = parameter_list->length ();
-  parameter_list->length (length_digits + 1);
-  (*parameter_list)[length_digits].argument <<= digits_;
-  (*parameter_list)[length_digits].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_scale = parameter_list->length ();
-  parameter_list->length (length_scale + 1);
-  (*parameter_list)[length_scale].argument <<= scale_;
-  (*parameter_list)[length_scale].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4d), ACE_NTOHL (0x6f64756c), ACE_NTOHL (0x65446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ModuleDef:1.0
+  10, ACE_NTOHL (0x4d6f6475), ACE_NTOHL (0x6c654465), ACE_NTOHL (0x66000000),  // name = IR_ModuleDef
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_ModuleDef (CORBA::tk_objref, sizeof (_oc_IR_ModuleDef), (char *) &_oc_IR_ModuleDef, 0, sizeof (IR_ModuleDef));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ModuleDef, &_tc_TAO_tc_IR_ModuleDef)
+TAO_NAMESPACE_END
 
-Dynamic::ExceptionList *
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_create_fixed::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+static const CORBA::Long _oc_IR_ModuleDescription[] =
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4d), ACE_NTOHL (0x6f64756c), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ModuleDescription:1.0
+  18, ACE_NTOHL (0x4d6f6475), ACE_NTOHL (0x6c654465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e000000),  // name = ModuleDescription
+  4, // member count
+  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+  CORBA::tk_alias, // typecode kind for typedefs
+  64, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+    CORBA::tk_string, 
+    0U, // string length
 
+  3, ACE_NTOHL (0x69640000),  // name = id
+  CORBA::tk_alias, // typecode kind for typedefs
+  68, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+    CORBA::tk_string, 
+    0U, // string length
 
-CORBA::Any * 
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_create_fixed::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
+  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
+  CORBA::tk_alias, // typecode kind for typedefs
+  68, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+    CORBA::tk_string, 
+    0U, // string length
 
-void 
-IR::Repository::TAO_ClientRequestInfo_IR_Repository_create_fixed::result (IR::FixedDef_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
+  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
+  CORBA::tk_alias, // typecode kind for typedefs
+  64, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
+    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
+    CORBA::tk_string, 
+    0U, // string length
 
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_Repository[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x793a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Repository:1.0
-  11, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72790000),  // name = Repository
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_Repository (CORBA::tk_objref, sizeof (_oc_IR_Repository), (char *) &_oc_IR_Repository, 0, sizeof (IR::Repository));
+static CORBA::TypeCode _tc_TAO_tc_IR_ModuleDescription (CORBA::tk_struct, sizeof (_oc_IR_ModuleDescription), (char *) &_oc_IR_ModuleDescription, 0, sizeof (IR_ModuleDescription));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Repository, &_tc_TAO_tc_IR_Repository)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ModuleDescription, &_tc_TAO_tc_IR_ModuleDescription)
 TAO_NAMESPACE_END
 
+void IR_ModuleDescription::_tao_any_destructor (void *x)
+{
+  IR_ModuleDescription *tmp = ACE_static_cast (IR_ModuleDescription*,x);
+  delete tmp;
+}
+
 ///////////////////////////////////////////////////////////////////////
 //                Base & Remote Proxy  Implementation. 
 //
 
-IR::_TAO_ComponentRepository_Proxy_Impl::_TAO_ComponentRepository_Proxy_Impl (void)
+_TAO_ConstantDef_Proxy_Impl::_TAO_ConstantDef_Proxy_Impl (void)
 {}
 
-IR::_TAO_ComponentRepository_Remote_Proxy_Impl::_TAO_ComponentRepository_Remote_Proxy_Impl (void)
+_TAO_ConstantDef_Remote_Proxy_Impl::_TAO_ConstantDef_Remote_Proxy_Impl (void)
 {}
 
 // Remote Implementation of the IDL interface methods
 
-IR::ComponentDef_ptr IR::_TAO_ComponentRepository_Remote_Proxy_Impl::create_component (
+CORBA::TypeCode_ptr _TAO_ConstantDef_Remote_Proxy_Impl::type (
     CORBA_Object *_collocated_tao_target_,
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::ComponentDef_ptr base_component,
-    const IR::InterfaceDefSeq & supports_interfaces,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-  IR::ComponentDef_ptr _tao_retval = IR::ComponentDef::_nil ();
-  IR::ComponentDef_var _tao_safe_retval (_tao_retval);
-  
+  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
+  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-  
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "create_component",
-      16,
-      1,
+      "_get_type",
+      9,
+      0,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ComponentRepository::TAO_ClientRequestInfo_IR_ComponentRepository_create_component ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        id,
-        name,
-        version,
-        base_component,
-        supports_interfaces,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << id) &&
-              (_tao_out << name) &&
-              (_tao_out << version) &&
-              (_tao_out << base_component) &&
-              (_tao_out << supports_interfaces)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
               0
             );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
                 CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                 0
               );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::ComponentDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
-IR::HomeDef_ptr IR::_TAO_ComponentRepository_Remote_Proxy_Impl::create_home (
+IR_IDLType_ptr _TAO_ConstantDef_Remote_Proxy_Impl::type_def (
     CORBA_Object *_collocated_tao_target_,
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::HomeDef_ptr base_home,
-    IR::ComponentDef_ptr managed_component,
-    IR::ValueDef_ptr primary_key,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-  IR::HomeDef_ptr _tao_retval = IR::HomeDef::_nil ();
-  IR::HomeDef_var _tao_safe_retval (_tao_retval);
-  
+  IR_IDLType_ptr _tao_retval = IR_IDLType::_nil ();
+  IR_IDLType_var _tao_safe_retval (_tao_retval);
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-  
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "create_home",
-      11,
-      1,
+      "_get_type_def",
+      13,
+      0,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ComponentRepository::TAO_ClientRequestInfo_IR_ComponentRepository_create_home ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        id,
-        name,
-        version,
-        base_home,
-        managed_component,
-        primary_key,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << id) &&
-              (_tao_out << name) &&
-              (_tao_out << version) &&
-              (_tao_out << base_home) &&
-              (_tao_out << managed_component) &&
-              (_tao_out << primary_key)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
               0
             );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
                 CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                 0
               );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::HomeDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
+          }
+        break;
+      }
+
+  return _tao_safe_retval._retn ();
+}
+
+void _TAO_ConstantDef_Remote_Proxy_Impl::type_def (
+    CORBA_Object *_collocated_tao_target_,
+    IR_IDLType_ptr type_def,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW (CORBA::INTERNAL ());
+
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_set_type_def",
+      13,
+      1,
+      istub->orb_core ()
+    );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
           );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << type_def)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
+        }
+        
+        break;
+      }
+
+}
+
+CORBA::Any * _TAO_ConstantDef_Remote_Proxy_Impl::value (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  CORBA::Any *_tao_retval = 0;
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+
+  ACE_NEW_RETURN (_tao_retval, CORBA::Any, _tao_retval);
+  CORBA::Any_var _tao_safe_retval (_tao_retval);
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_value",
+      10,
+      0,
+      istub->orb_core ()
+    );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
+
+  return _tao_safe_retval._retn ();
+}
+
+void _TAO_ConstantDef_Remote_Proxy_Impl::value (
+    CORBA_Object *_collocated_tao_target_,
+    const CORBA::Any & value,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW (CORBA::INTERNAL ());
+
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_set_value",
+      10,
+      1,
+      istub->orb_core ()
+    );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        ACE_CHECK;
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << value)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
+          );
       
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
         }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
+        
+        break;
+      }
 }
 
-
 //
 //            End  Base & Remote  Proxy Implemeentation. 
 ///////////////////////////////////////////////////////////////////////
@@ -14171,32 +8442,32 @@
 //           Remote & Base  Proxy Broker Implementation
 //
 
-IR::_TAO_ComponentRepository_Proxy_Broker::_TAO_ComponentRepository_Proxy_Broker (void)
+_TAO_ConstantDef_Proxy_Broker::_TAO_ConstantDef_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_ComponentRepository_Proxy_Broker::~_TAO_ComponentRepository_Proxy_Broker (void)
+_TAO_ConstantDef_Proxy_Broker::~_TAO_ConstantDef_Proxy_Broker (void)
 {
 }
 
-// Factory Member function Implementation.
-IR::_TAO_ComponentRepository_Remote_Proxy_Broker *IR::_TAO_ComponentRepository_Remote_Proxy_Broker::the_TAO_ComponentRepository_Remote_Proxy_Broker (void)
+// Factory function Implementation.
+_TAO_ConstantDef_Remote_Proxy_Broker *the_TAO_ConstantDef_Remote_Proxy_Broker (void)
 {
-  static ::IR::_TAO_ComponentRepository_Remote_Proxy_Broker remote_proxy_broker;
+  static ::_TAO_ConstantDef_Remote_Proxy_Broker remote_proxy_broker;
   return &remote_proxy_broker;
 }
 
-IR::_TAO_ComponentRepository_Remote_Proxy_Broker::_TAO_ComponentRepository_Remote_Proxy_Broker (void)
+_TAO_ConstantDef_Remote_Proxy_Broker::_TAO_ConstantDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_ComponentRepository_Remote_Proxy_Broker::~_TAO_ComponentRepository_Remote_Proxy_Broker (void)
+_TAO_ConstantDef_Remote_Proxy_Broker::~_TAO_ConstantDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_ComponentRepository_Proxy_Impl&
-IR::_TAO_ComponentRepository_Remote_Proxy_Broker::select_proxy (
-  ::IR::ComponentRepository *object,
+_TAO_ConstantDef_Proxy_Impl&
+_TAO_ConstantDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_ConstantDef *object,
   CORBA::Environment &ACE_TRY_ENV
 )
 {
@@ -14212,114 +8483,114 @@
 
 
 // default constructor
-IR::ComponentRepository::ComponentRepository (int collocated)
+IR_ConstantDef::IR_ConstantDef (int collocated)
 {
   this->_tao_setup_collocation (collocated);
 }
 
 // destructor
-IR::ComponentRepository::~ComponentRepository (void)
+IR_ConstantDef::~IR_ConstantDef (void)
 {}
 
 void
-IR::ComponentRepository::_tao_setup_collocation (int collocated)
+IR_ConstantDef::_tao_setup_collocation (int collocated)
 {
   if (collocated)
-    this->the_TAO_ComponentRepository_Proxy_Broker_ =
-      ::IR__TAO_ComponentRepository_Proxy_Broker_Factory_function_pointer (this);
+    this->the_TAO_ConstantDef_Proxy_Broker_ =
+      _TAO_ConstantDef_Proxy_Broker_Factory_function_pointer (this);
   else
-    this->the_TAO_ComponentRepository_Proxy_Broker_ =
-      ::IR::_TAO_ComponentRepository_Remote_Proxy_Broker::the_TAO_ComponentRepository_Remote_Proxy_Broker ();
+    this->the_TAO_ConstantDef_Proxy_Broker_ =
+      ::the_TAO_ConstantDef_Remote_Proxy_Broker ();
+  
+  IR_Contained::_tao_setup_collocation (collocated);
   
-  ACE_NESTED_CLASS (IR, Repository)::_tao_setup_collocation (collocated);
 }
 
-void IR::ComponentRepository::_tao_any_destructor (void *x)
+void IR_ConstantDef::_tao_any_destructor (void *x)
 {
-  ComponentRepository *tmp = ACE_static_cast (ComponentRepository*,x);
+  IR_ConstantDef *tmp = ACE_static_cast (IR_ConstantDef*,x);
   CORBA::release (tmp);
 }
 
-IR::ComponentRepository_ptr IR::ComponentRepository::_narrow (
+IR_ConstantDef_ptr IR_ConstantDef::_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
 {
   if (CORBA::is_nil (obj))
-    return ComponentRepository::_nil ();
+    return IR_ConstantDef::_nil ();
   if (! obj->_is_local ())
     {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ComponentRepository:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (ComponentRepository::_nil ());
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ConstantDef:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (IR_ConstantDef::_nil ());
       if (is_a == 0)
-        return ComponentRepository::_nil ();
+        return IR_ConstantDef::_nil ();
     }
-  return ComponentRepository::_unchecked_narrow (obj, ACE_TRY_ENV);
+  return IR_ConstantDef::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::ComponentRepository_ptr IR::ComponentRepository::_unchecked_narrow (
+IR_ConstantDef_ptr IR_ConstantDef::_unchecked_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &
   )
 {
   if (CORBA::is_nil (obj))
-    return ComponentRepository::_nil ();
+    return IR_ConstantDef::_nil ();
   if (! obj->_is_local ())
     {
       TAO_Stub* stub = obj->_stubobj ();
       if (stub)
         stub->_incr_refcnt ();
-      ComponentRepository_ptr default_proxy = ComponentRepository::_nil ();
+      IR_ConstantDef_ptr default_proxy = IR_ConstantDef::_nil ();
 
       if (
           !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
           stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_ComponentRepository_Proxy_Broker_Factory_function_pointer != 0
+          obj->_is_collocated () &&_TAO_ConstantDef_Proxy_Broker_Factory_function_pointer != 0
         )
       {
         ACE_NEW_RETURN (
           default_proxy,
-          ::IR::ComponentRepository (
+          ::IR_ConstantDef (
             stub,
             1,
             obj->_servant ()),
             
-          ComponentRepository::_nil ());
+          IR_ConstantDef::_nil ());
         }
       if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::ComponentRepository (stub, 0, obj->_servant ()), ComponentRepository::_nil ());
+        ACE_NEW_RETURN (default_proxy, ::IR_ConstantDef (stub, 0, obj->_servant ()), IR_ConstantDef::_nil ());
         return default_proxy;
       }
     else 
       return
         ACE_reinterpret_cast
           (
-            ComponentRepository_ptr,
+            IR_ConstantDef_ptr,
               obj->_tao_QueryInterface
                 (
                   ACE_reinterpret_cast
                     (
                       ptr_arith_t,
-                      &ComponentRepository::_narrow
+                      &IR_ConstantDef::_narrow
                     )
                 )
           );
 }
 
-IR::ComponentRepository_ptr
-IR::ComponentRepository::_duplicate (ComponentRepository_ptr obj)
+IR_ConstantDef_ptr
+IR_ConstantDef::_duplicate (IR_ConstantDef_ptr obj)
 {
   if (!CORBA::is_nil (obj))
     obj->_add_ref ();
   return obj;
 }
 
-CORBA::Boolean IR::ComponentRepository::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+CORBA::Boolean IR_ConstantDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
   if (
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ComponentRepository:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Repository:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ConstantDef:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
   return 1; // success using local knowledge
@@ -14327,46 +8598,34 @@
     return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
 }
 
-void *IR::ComponentRepository::_tao_QueryInterface (ptr_arith_t type)
+void *IR_ConstantDef::_tao_QueryInterface (ptr_arith_t type)
 {
   void *retv = 0;
   if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, ComponentRepository)::_narrow))
+      &IR_ConstantDef::_narrow))
     retv = ACE_reinterpret_cast (void*, this);
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Repository)::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            IR::Repository_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Container)::_narrow))
+      &IR_Contained::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::Container_ptr,
+            IR_Contained_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
+      &CORBA_IRObject::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            CORBA::IRObject_ptr,
+            CORBA_IRObject_ptr,
             this
           )
       );
@@ -14379,282 +8638,162 @@
   return retv;
 }
 
-const char* IR::ComponentRepository::_interface_repository_id (void) const
+const char* IR_ConstantDef::_interface_repository_id (void) const
 {
-  return "IDL:omg.org/IR/ComponentRepository:1.0";
+  return "IDL:omg.org/IR/ConstantDef:1.0";
 }
 
-IR::ComponentDef_ptr IR::ComponentRepository::create_component (
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::ComponentDef_ptr base_component,
-    const IR::InterfaceDefSeq & supports_interfaces,
+CORBA::TypeCode_ptr IR_ConstantDef::type (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
-{
-  
-  return this->the_TAO_ComponentRepository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_component (
+{ 
+  return this->the_TAO_ConstantDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type (
       this,
-      id,
-      name,
-      version,
-      base_component,
-      supports_interfaces,
       ACE_TRY_ENV
     );
 }
 
-IR::HomeDef_ptr IR::ComponentRepository::create_home (
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::HomeDef_ptr base_home,
-    IR::ComponentDef_ptr managed_component,
-    IR::ValueDef_ptr primary_key,
+IR_IDLType_ptr IR_ConstantDef::type_def (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-  return this->the_TAO_ComponentRepository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_home (
+  return this->the_TAO_ConstantDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type_def (
       this,
-      id,
-      name,
-      version,
-      base_home,
-      managed_component,
-      primary_key,
       ACE_TRY_ENV
     );
 }
 
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-IR::ComponentRepository::TAO_ClientRequestInfo_IR_ComponentRepository_create_component::TAO_ClientRequestInfo_IR_ComponentRepository_create_component (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::ComponentDef_ptr base_component,
-    const IR::InterfaceDefSeq & supports_interfaces,
-    CORBA::Environment &    
+void IR_ConstantDef::type_def (
+    IR_IDLType_ptr type_def,
+    CORBA::Environment &ACE_TRY_ENV
   )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    id_ (id),
-    name_ (name),
-    version_ (version),
-    base_component_ (base_component),
-    supports_interfaces_ (supports_interfaces)
-{}
-
-Dynamic::ParameterList *
-IR::ComponentRepository::TAO_ClientRequestInfo_IR_ComponentRepository_create_component::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_id = parameter_list->length ();
-  parameter_list->length (length_id + 1);
-  (*parameter_list)[length_id].argument <<= id_;
-  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_name = parameter_list->length ();
-  parameter_list->length (length_name + 1);
-  (*parameter_list)[length_name].argument <<= name_;
-  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_version = parameter_list->length ();
-  parameter_list->length (length_version + 1);
-  (*parameter_list)[length_version].argument <<= version_;
-  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_base_component = parameter_list->length ();
-  parameter_list->length (length_base_component + 1);
-  (*parameter_list)[length_base_component].argument <<=  this->base_component_;
-  
-  (*parameter_list)[length_base_component].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_supports_interfaces = parameter_list->length ();
-  parameter_list->length (length_supports_interfaces + 1);
-  (*parameter_list)[length_supports_interfaces].argument <<=  this->supports_interfaces_;
-  
-  (*parameter_list)[length_supports_interfaces].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
+  this->the_TAO_ConstantDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type_def (
+      this,
+      type_def,
+      ACE_TRY_ENV
+    );
 }
 
-Dynamic::ExceptionList *
-IR::ComponentRepository::TAO_ClientRequestInfo_IR_ComponentRepository_create_component::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+CORBA::Any * IR_ConstantDef::value (
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
+  return this->the_TAO_ConstantDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).value (
+      this,
+      ACE_TRY_ENV
+    );
 }
 
-
-CORBA::Any * 
-IR::ComponentRepository::TAO_ClientRequestInfo_IR_ComponentRepository_create_component::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+void IR_ConstantDef::value (
+    const CORBA::Any & value,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
+  this->the_TAO_ConstantDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).value (
+      this,
+      value,
+      ACE_TRY_ENV
+    );
 }
 
-void 
-IR::ComponentRepository::TAO_ClientRequestInfo_IR_ComponentRepository_create_component::result (IR::ComponentDef_ptr result)
+static const CORBA::Long _oc_IR_ConstantDef[] =
 {
-  // update the result 
-  this->_result = result;
-}
-
-IR::ComponentRepository::TAO_ClientRequestInfo_IR_ComponentRepository_create_home::TAO_ClientRequestInfo_IR_ComponentRepository_create_home (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::HomeDef_ptr base_home,
-    IR::ComponentDef_ptr managed_component,
-    IR::ValueDef_ptr primary_key,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    id_ (id),
-    name_ (name),
-    version_ (version),
-    base_home_ (base_home),
-    managed_component_ (managed_component),
-    primary_key_ (primary_key)
-{}
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7374), ACE_NTOHL (0x616e7444), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ConstantDef:1.0
+  12, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x74616e74), ACE_NTOHL (0x44656600),  // name = IR_ConstantDef
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_ConstantDef (CORBA::tk_objref, sizeof (_oc_IR_ConstantDef), (char *) &_oc_IR_ConstantDef, 0, sizeof (IR_ConstantDef));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ConstantDef, &_tc_TAO_tc_IR_ConstantDef)
+TAO_NAMESPACE_END
 
-Dynamic::ParameterList *
-IR::ComponentRepository::TAO_ClientRequestInfo_IR_ComponentRepository_create_home::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+static const CORBA::Long _oc_IR_ConstantDescription[] =
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_id = parameter_list->length ();
-  parameter_list->length (length_id + 1);
-  (*parameter_list)[length_id].argument <<= id_;
-  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_name = parameter_list->length ();
-  parameter_list->length (length_name + 1);
-  (*parameter_list)[length_name].argument <<= name_;
-  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_version = parameter_list->length ();
-  parameter_list->length (length_version + 1);
-  (*parameter_list)[length_version].argument <<= version_;
-  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_base_home = parameter_list->length ();
-  parameter_list->length (length_base_home + 1);
-  (*parameter_list)[length_base_home].argument <<=  this->base_home_;
-  
-  (*parameter_list)[length_base_home].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_managed_component = parameter_list->length ();
-  parameter_list->length (length_managed_component + 1);
-  (*parameter_list)[length_managed_component].argument <<=  this->managed_component_;
-  
-  (*parameter_list)[length_managed_component].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_primary_key = parameter_list->length ();
-  parameter_list->length (length_primary_key + 1);
-  (*parameter_list)[length_primary_key].argument <<=  this->primary_key_;
-  
-  (*parameter_list)[length_primary_key].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  39, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7374), ACE_NTOHL (0x616e7444), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ConstantDescription:1.0
+  20, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x74616e74), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = ConstantDescription
+  6, // member count
+  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+  CORBA::tk_alias, // typecode kind for typedefs
+  64, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+    CORBA::tk_string, 
+    0U, // string length
 
-Dynamic::ExceptionList *
-IR::ComponentRepository::TAO_ClientRequestInfo_IR_ComponentRepository_create_home::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
+  3, ACE_NTOHL (0x69640000),  // name = id
+  CORBA::tk_alias, // typecode kind for typedefs
+  68, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+    CORBA::tk_string, 
+    0U, // string length
+
+  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
+  CORBA::tk_alias, // typecode kind for typedefs
+  68, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+    CORBA::tk_string, 
+    0U, // string length
 
+  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
+  CORBA::tk_alias, // typecode kind for typedefs
+  64, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
+    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
+    CORBA::tk_string, 
+    0U, // string length
 
-CORBA::Any * 
-IR::ComponentRepository::TAO_ClientRequestInfo_IR_ComponentRepository_create_home::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
+  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+  CORBA::tk_TypeCode,
 
-void 
-IR::ComponentRepository::TAO_ClientRequestInfo_IR_ComponentRepository_create_home::result (IR::HomeDef_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
+  6, ACE_NTOHL (0x76616c75), ACE_NTOHL (0x65000000),  // name = value
+  CORBA::tk_any,
 
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_ComponentRepository[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  39, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6d706f), ACE_NTOHL (0x6e656e74), ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72793a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ComponentRepository:1.0
-  20, ACE_NTOHL (0x436f6d70), ACE_NTOHL (0x6f6e656e), ACE_NTOHL (0x74526570), ACE_NTOHL (0x6f736974), ACE_NTOHL (0x6f727900),  // name = ComponentRepository
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_ComponentRepository (CORBA::tk_objref, sizeof (_oc_IR_ComponentRepository), (char *) &_oc_IR_ComponentRepository, 0, sizeof (IR::ComponentRepository));
+static CORBA::TypeCode _tc_TAO_tc_IR_ConstantDescription (CORBA::tk_struct, sizeof (_oc_IR_ConstantDescription), (char *) &_oc_IR_ConstantDescription, 0, sizeof (IR_ConstantDescription));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ComponentRepository, &_tc_TAO_tc_IR_ComponentRepository)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ConstantDescription, &_tc_TAO_tc_IR_ConstantDescription)
 TAO_NAMESPACE_END
 
+void IR_ConstantDescription::_tao_any_destructor (void *x)
+{
+  IR_ConstantDescription *tmp = ACE_static_cast (IR_ConstantDescription*,x);
+  delete tmp;
+}
+
+
 ///////////////////////////////////////////////////////////////////////
 //                Base & Remote Proxy  Implementation. 
 //
 
-IR::_TAO_ModuleDef_Proxy_Impl::_TAO_ModuleDef_Proxy_Impl (void)
+_TAO_TypedefDef_Proxy_Impl::_TAO_TypedefDef_Proxy_Impl (void)
 {}
 
-IR::_TAO_ModuleDef_Remote_Proxy_Impl::_TAO_ModuleDef_Remote_Proxy_Impl (void)
+_TAO_TypedefDef_Remote_Proxy_Impl::_TAO_TypedefDef_Remote_Proxy_Impl (void)
 {}
 
 // Remote Implementation of the IDL interface methods
@@ -14669,32 +8808,32 @@
 //           Remote & Base  Proxy Broker Implementation
 //
 
-IR::_TAO_ModuleDef_Proxy_Broker::_TAO_ModuleDef_Proxy_Broker (void)
+_TAO_TypedefDef_Proxy_Broker::_TAO_TypedefDef_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_ModuleDef_Proxy_Broker::~_TAO_ModuleDef_Proxy_Broker (void)
+_TAO_TypedefDef_Proxy_Broker::~_TAO_TypedefDef_Proxy_Broker (void)
 {
 }
 
-// Factory Member function Implementation.
-IR::_TAO_ModuleDef_Remote_Proxy_Broker *IR::_TAO_ModuleDef_Remote_Proxy_Broker::the_TAO_ModuleDef_Remote_Proxy_Broker (void)
+// Factory function Implementation.
+_TAO_TypedefDef_Remote_Proxy_Broker *the_TAO_TypedefDef_Remote_Proxy_Broker (void)
 {
-  static ::IR::_TAO_ModuleDef_Remote_Proxy_Broker remote_proxy_broker;
+  static ::_TAO_TypedefDef_Remote_Proxy_Broker remote_proxy_broker;
   return &remote_proxy_broker;
 }
 
-IR::_TAO_ModuleDef_Remote_Proxy_Broker::_TAO_ModuleDef_Remote_Proxy_Broker (void)
+_TAO_TypedefDef_Remote_Proxy_Broker::_TAO_TypedefDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_ModuleDef_Remote_Proxy_Broker::~_TAO_ModuleDef_Remote_Proxy_Broker (void)
+_TAO_TypedefDef_Remote_Proxy_Broker::~_TAO_TypedefDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_ModuleDef_Proxy_Impl&
-IR::_TAO_ModuleDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::ModuleDef *object,
+_TAO_TypedefDef_Proxy_Impl&
+_TAO_TypedefDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_TypedefDef *object,
   CORBA::Environment &ACE_TRY_ENV
 )
 {
@@ -14710,115 +8849,116 @@
 
 
 // default constructor
-IR::ModuleDef::ModuleDef (int collocated)
+IR_TypedefDef::IR_TypedefDef (int collocated)
 {
   this->_tao_setup_collocation (collocated);
 }
 
 // destructor
-IR::ModuleDef::~ModuleDef (void)
+IR_TypedefDef::~IR_TypedefDef (void)
 {}
 
 void
-IR::ModuleDef::_tao_setup_collocation (int collocated)
+IR_TypedefDef::_tao_setup_collocation (int collocated)
 {
   if (collocated)
-    this->the_TAO_ModuleDef_Proxy_Broker_ =
-      ::IR__TAO_ModuleDef_Proxy_Broker_Factory_function_pointer (this);
+    this->the_TAO_TypedefDef_Proxy_Broker_ =
+      _TAO_TypedefDef_Proxy_Broker_Factory_function_pointer (this);
   else
-    this->the_TAO_ModuleDef_Proxy_Broker_ =
-      ::IR::_TAO_ModuleDef_Remote_Proxy_Broker::the_TAO_ModuleDef_Remote_Proxy_Broker ();
+    this->the_TAO_TypedefDef_Proxy_Broker_ =
+      ::the_TAO_TypedefDef_Remote_Proxy_Broker ();
+  
+  IR_Contained::_tao_setup_collocation (collocated);
+  IR_IDLType::_tao_setup_collocation (collocated);
   
-  ACE_NESTED_CLASS (IR, Container)::_tao_setup_collocation (collocated);
-  ACE_NESTED_CLASS (IR, Contained)::_tao_setup_collocation (collocated);
 }
 
-void IR::ModuleDef::_tao_any_destructor (void *x)
+void IR_TypedefDef::_tao_any_destructor (void *x)
 {
-  ModuleDef *tmp = ACE_static_cast (ModuleDef*,x);
+  IR_TypedefDef *tmp = ACE_static_cast (IR_TypedefDef*,x);
   CORBA::release (tmp);
 }
 
-IR::ModuleDef_ptr IR::ModuleDef::_narrow (
+IR_TypedefDef_ptr IR_TypedefDef::_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
 {
   if (CORBA::is_nil (obj))
-    return ModuleDef::_nil ();
+    return IR_TypedefDef::_nil ();
   if (! obj->_is_local ())
     {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ModuleDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (ModuleDef::_nil ());
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/TypedefDef:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (IR_TypedefDef::_nil ());
       if (is_a == 0)
-        return ModuleDef::_nil ();
+        return IR_TypedefDef::_nil ();
     }
-  return ModuleDef::_unchecked_narrow (obj, ACE_TRY_ENV);
+  return IR_TypedefDef::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::ModuleDef_ptr IR::ModuleDef::_unchecked_narrow (
+IR_TypedefDef_ptr IR_TypedefDef::_unchecked_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &
   )
 {
   if (CORBA::is_nil (obj))
-    return ModuleDef::_nil ();
+    return IR_TypedefDef::_nil ();
   if (! obj->_is_local ())
     {
       TAO_Stub* stub = obj->_stubobj ();
       if (stub)
         stub->_incr_refcnt ();
-      ModuleDef_ptr default_proxy = ModuleDef::_nil ();
+      IR_TypedefDef_ptr default_proxy = IR_TypedefDef::_nil ();
 
       if (
           !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
           stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_ModuleDef_Proxy_Broker_Factory_function_pointer != 0
+          obj->_is_collocated () &&_TAO_TypedefDef_Proxy_Broker_Factory_function_pointer != 0
         )
       {
         ACE_NEW_RETURN (
           default_proxy,
-          ::IR::ModuleDef (
+          ::IR_TypedefDef (
             stub,
             1,
             obj->_servant ()),
             
-          ModuleDef::_nil ());
+          IR_TypedefDef::_nil ());
         }
       if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::ModuleDef (stub, 0, obj->_servant ()), ModuleDef::_nil ());
+        ACE_NEW_RETURN (default_proxy, ::IR_TypedefDef (stub, 0, obj->_servant ()), IR_TypedefDef::_nil ());
         return default_proxy;
       }
     else 
       return
         ACE_reinterpret_cast
           (
-            ModuleDef_ptr,
+            IR_TypedefDef_ptr,
               obj->_tao_QueryInterface
                 (
                   ACE_reinterpret_cast
                     (
                       ptr_arith_t,
-                      &ModuleDef::_narrow
+                      &IR_TypedefDef::_narrow
                     )
                 )
           );
 }
 
-IR::ModuleDef_ptr
-IR::ModuleDef::_duplicate (ModuleDef_ptr obj)
+IR_TypedefDef_ptr
+IR_TypedefDef::_duplicate (IR_TypedefDef_ptr obj)
 {
   if (!CORBA::is_nil (obj))
     obj->_add_ref ();
   return obj;
 }
 
-CORBA::Boolean IR::ModuleDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+CORBA::Boolean IR_TypedefDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
   if (
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ModuleDef:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
   return 1; // success using local knowledge
@@ -14826,46 +8966,46 @@
     return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
 }
 
-void *IR::ModuleDef::_tao_QueryInterface (ptr_arith_t type)
+void *IR_TypedefDef::_tao_QueryInterface (ptr_arith_t type)
 {
   void *retv = 0;
   if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, ModuleDef)::_narrow))
+      &IR_TypedefDef::_narrow))
     retv = ACE_reinterpret_cast (void*, this);
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Container)::_narrow))
+      &IR_Contained::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::Container_ptr,
+            IR_Contained_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Contained)::_narrow))
+      &IR_IDLType::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::Contained_ptr,
+            IR_IDLType_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
+      &CORBA_IRObject::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            CORBA::IRObject_ptr,
+            CORBA_IRObject_ptr,
             this
           )
       );
@@ -14878,31 +9018,29 @@
   return retv;
 }
 
-const char* IR::ModuleDef::_interface_repository_id (void) const
+const char* IR_TypedefDef::_interface_repository_id (void) const
 {
-  return "IDL:omg.org/IR/ModuleDef:1.0";
+  return "IDL:omg.org/IR/TypedefDef:1.0";
 }
 
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_ModuleDef[] =
+static const CORBA::Long _oc_IR_TypedefDef[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
-  29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4d), ACE_NTOHL (0x6f64756c), ACE_NTOHL (0x65446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ModuleDef:1.0
-  10, ACE_NTOHL (0x4d6f6475), ACE_NTOHL (0x6c654465), ACE_NTOHL (0x66000000),  // name = ModuleDef
+  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f54), ACE_NTOHL (0x79706564), ACE_NTOHL (0x65664465), ACE_NTOHL (0x663a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/TypedefDef:1.0
+  11, ACE_NTOHL (0x54797065), ACE_NTOHL (0x64656644), ACE_NTOHL (0x65660000),  // name = IR_TypedefDef
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_ModuleDef (CORBA::tk_objref, sizeof (_oc_IR_ModuleDef), (char *) &_oc_IR_ModuleDef, 0, sizeof (IR::ModuleDef));
+static CORBA::TypeCode _tc_TAO_tc_IR_TypedefDef (CORBA::tk_objref, sizeof (_oc_IR_TypedefDef), (char *) &_oc_IR_TypedefDef, 0, sizeof (IR_TypedefDef));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ModuleDef, &_tc_TAO_tc_IR_ModuleDef)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_TypedefDef, &_tc_TAO_tc_IR_TypedefDef)
 TAO_NAMESPACE_END
-static const CORBA::Long _oc_IR_ModuleDescription[] =
+
+static const CORBA::Long _oc_IR_TypeDescription[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
-  37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4d), ACE_NTOHL (0x6f64756c), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ModuleDescription:1.0
-  18, ACE_NTOHL (0x4d6f6475), ACE_NTOHL (0x6c654465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e000000),  // name = ModuleDescription
-  4, // member count
+  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f54), ACE_NTOHL (0x79706544), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/TypeDescription:1.0
+  16, ACE_NTOHL (0x54797065), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = TypeDescription
+  5, // member count
   5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
   CORBA::tk_alias, // typecode kind for typedefs
   64, // encapsulation length
@@ -14939,32 +9077,35 @@
     CORBA::tk_string, 
     0U, // string length
 
+  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+  CORBA::tk_TypeCode,
+
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_ModuleDescription (CORBA::tk_struct, sizeof (_oc_IR_ModuleDescription), (char *) &_oc_IR_ModuleDescription, 0, sizeof (IR::ModuleDescription));
+static CORBA::TypeCode _tc_TAO_tc_IR_TypeDescription (CORBA::tk_struct, sizeof (_oc_IR_TypeDescription), (char *) &_oc_IR_TypeDescription, 0, sizeof (IR_TypeDescription));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ModuleDescription, &_tc_TAO_tc_IR_ModuleDescription)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_TypeDescription, &_tc_TAO_tc_IR_TypeDescription)
 TAO_NAMESPACE_END
-void IR::ModuleDescription::_tao_any_destructor (void *x)
+
+void IR_TypeDescription::_tao_any_destructor (void *x)
 {
-  ModuleDescription *tmp = ACE_static_cast (ModuleDescription*,x);
+  IR_TypeDescription *tmp = ACE_static_cast (IR_TypeDescription*,x);
   delete tmp;
 }
 
-
 ///////////////////////////////////////////////////////////////////////
 //                Base & Remote Proxy  Implementation. 
 //
 
-IR::_TAO_ConstantDef_Proxy_Impl::_TAO_ConstantDef_Proxy_Impl (void)
+_TAO_StructDef_Proxy_Impl::_TAO_StructDef_Proxy_Impl (void)
 {}
 
-IR::_TAO_ConstantDef_Remote_Proxy_Impl::_TAO_ConstantDef_Remote_Proxy_Impl (void)
+_TAO_StructDef_Remote_Proxy_Impl::_TAO_StructDef_Remote_Proxy_Impl (void)
 {}
 
 // Remote Implementation of the IDL interface methods
 
-CORBA::TypeCode_ptr IR::_TAO_ConstantDef_Remote_Proxy_Impl::type (
+IR_StructMemberSeq * _TAO_StructDef_Remote_Proxy_Impl::members (
     CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -14972,819 +9113,165 @@
     CORBA::SystemException
   ))
 {
-  
-  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
-  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
-  
+  IR_StructMemberSeq *_tao_retval = 0;
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-  
+  ACE_NEW_RETURN (_tao_retval, IR_StructMemberSeq, _tao_retval);
+  IR_StructMemberSeq_var _tao_safe_retval (_tao_retval);
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_get_type",
-      9,
+      "_get_members",
+      12,
       0,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              CORBA::TypeCode_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
         }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
-IR::IDLType_ptr IR::_TAO_ConstantDef_Remote_Proxy_Impl::type_def (
+void _TAO_StructDef_Remote_Proxy_Impl::members (
     CORBA_Object *_collocated_tao_target_,
+    const IR_StructMemberSeq & members,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-  IR::IDLType_ptr _tao_retval = IR::IDLType::_nil ();
-  IR::IDLType_var _tao_safe_retval (_tao_retval);
-  
-  
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+    ACE_THROW (CORBA::INTERNAL ());
 
   
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_get_type_def",
-      13,
-      0,
+      "_set_members",
+      12,
+      1,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_def_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::IDLType_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << members)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
       
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
         }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
+        
+        break;
+      }
 }
 
-void IR::_TAO_ConstantDef_Remote_Proxy_Impl::type_def (
-    CORBA_Object *_collocated_tao_target_,
-    IR::IDLType_ptr type_def,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
 
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW (CORBA::INTERNAL ());
+//
+//            End  Base & Remote  Proxy Implemeentation. 
+///////////////////////////////////////////////////////////////////////
 
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_set_type_def",
-      13,
-      1,
-      istub->orb_core ()
-    );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_def_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        type_def,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << type_def)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+///////////////////////////////////////////////////////////////////////
+//           Remote & Base  Proxy Broker Implementation
+//
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  
+_TAO_StructDef_Proxy_Broker::_TAO_StructDef_Proxy_Broker (void)
+{
 }
 
-CORBA::Any * IR::_TAO_ConstantDef_Remote_Proxy_Impl::value (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
+_TAO_StructDef_Proxy_Broker::~_TAO_StructDef_Proxy_Broker (void)
 {
-  
-  CORBA::Any *_tao_retval = 0;
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+}
 
-  
-  ACE_NEW_RETURN (_tao_retval, CORBA::Any, _tao_retval);
-  CORBA::Any_var _tao_safe_retval (_tao_retval);
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_value",
-      10,
-      0,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_value_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              CORBA::Any * _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
-}
-
-void IR::_TAO_ConstantDef_Remote_Proxy_Impl::value (
-    CORBA_Object *_collocated_tao_target_,
-    const CORBA::Any & value,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW (CORBA::INTERNAL ());
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_set_value",
-      10,
-      1,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_value_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        value,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << value)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  
-}
-
-
-//
-//            End  Base & Remote  Proxy Implemeentation. 
-///////////////////////////////////////////////////////////////////////
-
-
-///////////////////////////////////////////////////////////////////////
-//           Remote & Base  Proxy Broker Implementation
-//
-
-IR::_TAO_ConstantDef_Proxy_Broker::_TAO_ConstantDef_Proxy_Broker (void)
-{
-}
-
-IR::_TAO_ConstantDef_Proxy_Broker::~_TAO_ConstantDef_Proxy_Broker (void)
-{
-}
-
-// Factory Member function Implementation.
-IR::_TAO_ConstantDef_Remote_Proxy_Broker *IR::_TAO_ConstantDef_Remote_Proxy_Broker::the_TAO_ConstantDef_Remote_Proxy_Broker (void)
+// Factory function Implementation.
+_TAO_StructDef_Remote_Proxy_Broker *the_TAO_StructDef_Remote_Proxy_Broker (void)
 {
-  static ::IR::_TAO_ConstantDef_Remote_Proxy_Broker remote_proxy_broker;
+  static ::_TAO_StructDef_Remote_Proxy_Broker remote_proxy_broker;
   return &remote_proxy_broker;
 }
 
-IR::_TAO_ConstantDef_Remote_Proxy_Broker::_TAO_ConstantDef_Remote_Proxy_Broker (void)
+_TAO_StructDef_Remote_Proxy_Broker::_TAO_StructDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_ConstantDef_Remote_Proxy_Broker::~_TAO_ConstantDef_Remote_Proxy_Broker (void)
+_TAO_StructDef_Remote_Proxy_Broker::~_TAO_StructDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_ConstantDef_Proxy_Impl&
-IR::_TAO_ConstantDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::ConstantDef *object,
+_TAO_StructDef_Proxy_Impl&
+_TAO_StructDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_StructDef *object,
   CORBA::Environment &ACE_TRY_ENV
 )
 {
@@ -15800,113 +9287,118 @@
 
 
 // default constructor
-IR::ConstantDef::ConstantDef (int collocated)
+IR_StructDef::IR_StructDef (int collocated)
 {
   this->_tao_setup_collocation (collocated);
 }
 
 // destructor
-IR::ConstantDef::~ConstantDef (void)
+IR_StructDef::~IR_StructDef (void)
 {}
 
 void
-IR::ConstantDef::_tao_setup_collocation (int collocated)
+IR_StructDef::_tao_setup_collocation (int collocated)
 {
   if (collocated)
-    this->the_TAO_ConstantDef_Proxy_Broker_ =
-      ::IR__TAO_ConstantDef_Proxy_Broker_Factory_function_pointer (this);
+    this->the_TAO_StructDef_Proxy_Broker_ =
+      _TAO_StructDef_Proxy_Broker_Factory_function_pointer (this);
   else
-    this->the_TAO_ConstantDef_Proxy_Broker_ =
-      ::IR::_TAO_ConstantDef_Remote_Proxy_Broker::the_TAO_ConstantDef_Remote_Proxy_Broker ();
+    this->the_TAO_StructDef_Proxy_Broker_ =
+      ::the_TAO_StructDef_Remote_Proxy_Broker ();
+  
+  IR_TypedefDef::_tao_setup_collocation (collocated);
+  IR_Container::_tao_setup_collocation (collocated);
   
-  ACE_NESTED_CLASS (IR, Contained)::_tao_setup_collocation (collocated);
 }
 
-void IR::ConstantDef::_tao_any_destructor (void *x)
+void IR_StructDef::_tao_any_destructor (void *x)
 {
-  ConstantDef *tmp = ACE_static_cast (ConstantDef*,x);
+  IR_StructDef *tmp = ACE_static_cast (IR_StructDef*,x);
   CORBA::release (tmp);
 }
 
-IR::ConstantDef_ptr IR::ConstantDef::_narrow (
+IR_StructDef_ptr IR_StructDef::_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
 {
   if (CORBA::is_nil (obj))
-    return ConstantDef::_nil ();
+    return IR_StructDef::_nil ();
   if (! obj->_is_local ())
     {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ConstantDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (ConstantDef::_nil ());
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/StructDef:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (IR_StructDef::_nil ());
       if (is_a == 0)
-        return ConstantDef::_nil ();
+        return IR_StructDef::_nil ();
     }
-  return ConstantDef::_unchecked_narrow (obj, ACE_TRY_ENV);
+  return IR_StructDef::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::ConstantDef_ptr IR::ConstantDef::_unchecked_narrow (
+IR_StructDef_ptr IR_StructDef::_unchecked_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &
   )
 {
   if (CORBA::is_nil (obj))
-    return ConstantDef::_nil ();
+    return IR_StructDef::_nil ();
   if (! obj->_is_local ())
     {
       TAO_Stub* stub = obj->_stubobj ();
       if (stub)
         stub->_incr_refcnt ();
-      ConstantDef_ptr default_proxy = ConstantDef::_nil ();
+      IR_StructDef_ptr default_proxy = IR_StructDef::_nil ();
 
       if (
           !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
           stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_ConstantDef_Proxy_Broker_Factory_function_pointer != 0
+          obj->_is_collocated () &&_TAO_StructDef_Proxy_Broker_Factory_function_pointer != 0
         )
       {
         ACE_NEW_RETURN (
           default_proxy,
-          ::IR::ConstantDef (
+          ::IR_StructDef (
             stub,
             1,
             obj->_servant ()),
             
-          ConstantDef::_nil ());
+          IR_StructDef::_nil ());
         }
       if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::ConstantDef (stub, 0, obj->_servant ()), ConstantDef::_nil ());
+        ACE_NEW_RETURN (default_proxy, ::IR_StructDef (stub, 0, obj->_servant ()), IR_StructDef::_nil ());
         return default_proxy;
       }
     else 
       return
         ACE_reinterpret_cast
           (
-            ConstantDef_ptr,
+            IR_StructDef_ptr,
               obj->_tao_QueryInterface
                 (
                   ACE_reinterpret_cast
                     (
                       ptr_arith_t,
-                      &ConstantDef::_narrow
+                      &IR_StructDef::_narrow
                     )
                 )
           );
 }
 
-IR::ConstantDef_ptr
-IR::ConstantDef::_duplicate (ConstantDef_ptr obj)
+IR_StructDef_ptr
+IR_StructDef::_duplicate (IR_StructDef_ptr obj)
 {
   if (!CORBA::is_nil (obj))
     obj->_add_ref ();
   return obj;
 }
 
-CORBA::Boolean IR::ConstantDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+CORBA::Boolean IR_StructDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
   if (
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ConstantDef:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/StructDef:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
   return 1; // success using local knowledge
@@ -15914,34 +9406,70 @@
     return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
 }
 
-void *IR::ConstantDef::_tao_QueryInterface (ptr_arith_t type)
+void *IR_StructDef::_tao_QueryInterface (ptr_arith_t type)
 {
   void *retv = 0;
   if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, ConstantDef)::_narrow))
+      &IR_StructDef::_narrow))
     retv = ACE_reinterpret_cast (void*, this);
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Contained)::_narrow))
+      &IR_TypedefDef::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            IR_TypedefDef_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_Container::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            IR_Container_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_Contained::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            IR_Contained_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_IDLType::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::Contained_ptr,
+            IR_IDLType_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
+      &CORBA_IRObject::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            CORBA::IRObject_ptr,
+            CORBA_IRObject_ptr,
             this
           )
       );
@@ -15954,452 +9482,392 @@
   return retv;
 }
 
-const char* IR::ConstantDef::_interface_repository_id (void) const
+const char* IR_StructDef::_interface_repository_id (void) const
 {
-  return "IDL:omg.org/IR/ConstantDef:1.0";
+  return "IDL:omg.org/IR/StructDef:1.0";
 }
 
-CORBA::TypeCode_ptr IR::ConstantDef::type (
+IR_StructMemberSeq * IR_StructDef::members (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-  return this->the_TAO_ConstantDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type (
+  return this->the_TAO_StructDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).members (
       this,
       ACE_TRY_ENV
     );
 }
 
-IR::IDLType_ptr IR::ConstantDef::type_def (
+void IR_StructDef::members (
+    const IR_StructMemberSeq & members,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-  return this->the_TAO_ConstantDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type_def (
+  this->the_TAO_StructDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).members (
       this,
+      members,
       ACE_TRY_ENV
     );
 }
 
-void IR::ConstantDef::type_def (
-    IR::IDLType_ptr type_def,
+static const CORBA::Long _oc_IR_StructDef[] =
+{
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x74446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/StructDef:1.0
+  10, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744465), ACE_NTOHL (0x66000000),  // name = IR_StructDef
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_StructDef (CORBA::tk_objref, sizeof (_oc_IR_StructDef), (char *) &_oc_IR_StructDef, 0, sizeof (IR_StructDef));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_StructDef, &_tc_TAO_tc_IR_StructDef)
+TAO_NAMESPACE_END
+
+///////////////////////////////////////////////////////////////////////
+//                Base & Remote Proxy  Implementation. 
+//
+
+_TAO_UnionDef_Proxy_Impl::_TAO_UnionDef_Proxy_Impl (void)
+{}
+
+_TAO_UnionDef_Remote_Proxy_Impl::_TAO_UnionDef_Remote_Proxy_Impl (void)
+{}
+
+// Remote Implementation of the IDL interface methods
+
+CORBA::TypeCode_ptr _TAO_UnionDef_Remote_Proxy_Impl::discriminator_type (
+    CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
+  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
+  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
   
-  this->the_TAO_ConstantDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type_def (
-      this,
-      type_def,
-      ACE_TRY_ENV
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_discriminator_type",
+      23,
+      0,
+      istub->orb_core ()
     );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
+
+  return _tao_safe_retval._retn ();
 }
 
-CORBA::Any * IR::ConstantDef::value (
+IR_IDLType_ptr _TAO_UnionDef_Remote_Proxy_Impl::discriminator_type_def (
+    CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-  return this->the_TAO_ConstantDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).value (
-      this,
-      ACE_TRY_ENV
+  IR_IDLType_ptr _tao_retval = IR_IDLType::_nil ();
+  IR_IDLType_var _tao_safe_retval (_tao_retval);
+ 
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_discriminator_type_def",
+      27,
+      0,
+      istub->orb_core ()
     );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
+
+  return _tao_safe_retval._retn ();
 }
 
-void IR::ConstantDef::value (
-    const CORBA::Any & value,
+void _TAO_UnionDef_Remote_Proxy_Impl::discriminator_type_def (
+    CORBA_Object *_collocated_tao_target_,
+    IR_IDLType_ptr discriminator_type_def,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW (CORBA::INTERNAL ());
+
   
-  this->the_TAO_ConstantDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).value (
-      this,
-      value,
-      ACE_TRY_ENV
-    );
-}
-
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-IR::ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_get::TAO_ClientRequestInfo_IR_ConstantDef_type_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_get::result (CORBA::TypeCode_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_def_get::TAO_ClientRequestInfo_IR_ConstantDef_type_def_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_def_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_def_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_def_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_def_get::result (IR::IDLType_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_def_set::TAO_ClientRequestInfo_IR_ConstantDef_type_def_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    IR::IDLType_ptr type_def,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    type_def_ (type_def)
-{}
-
-Dynamic::ParameterList *
-IR::ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_def_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_type_def = parameter_list->length ();
-  parameter_list->length (length_type_def + 1);
-  (*parameter_list)[length_type_def].argument <<=  this->type_def_;
-  
-  (*parameter_list)[length_type_def].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_def_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_set_discriminator_type_def",
+      27,
+      1,
+      istub->orb_core ()
+    );
 
-CORBA::Any * 
-IR::ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_def_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << discriminator_type_def)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
+        }
+        
+        break;
+      }
 }
 
-IR::ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_value_get::TAO_ClientRequestInfo_IR_ConstantDef_value_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
+IR_UnionMemberSeq * _TAO_UnionDef_Remote_Proxy_Impl::members (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::Environment &ACE_TRY_ENV
   )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_value_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_value_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
+  IR_UnionMemberSeq *_tao_retval = 0;
   
-  return exception_list;
-}
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
+  ACE_NEW_RETURN (_tao_retval, IR_UnionMemberSeq, _tao_retval);
+  IR_UnionMemberSeq_var _tao_safe_retval (_tao_retval);
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_members",
+      12,
+      0,
+      istub->orb_core ()
+    );
 
-CORBA::Any * 
-IR::ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_value_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-void 
-IR::ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_value_get::result (CORBA::Any * result)
-{
-  // update the result 
-  this->_result = result;
+  return _tao_safe_retval._retn ();
 }
 
-IR::ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_value_set::TAO_ClientRequestInfo_IR_ConstantDef_value_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const CORBA::Any & value,
-    CORBA::Environment &    
+void _TAO_UnionDef_Remote_Proxy_Impl::members (
+    CORBA_Object *_collocated_tao_target_,
+    const IR_UnionMemberSeq & members,
+    CORBA::Environment &ACE_TRY_ENV
   )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    value_ (value)
-{}
-
-Dynamic::ParameterList *
-IR::ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_value_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_value = parameter_list->length ();
-  parameter_list->length (length_value + 1);
-  (*parameter_list)[length_value].argument <<= value_;
-  (*parameter_list)[length_value].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_value_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW (CORBA::INTERNAL ());
 
-CORBA::Any * 
-IR::ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_value_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
   
-  return result_any;
-}
-
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_ConstantDef[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7374), ACE_NTOHL (0x616e7444), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ConstantDef:1.0
-  12, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x74616e74), ACE_NTOHL (0x44656600),  // name = ConstantDef
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_ConstantDef (CORBA::tk_objref, sizeof (_oc_IR_ConstantDef), (char *) &_oc_IR_ConstantDef, 0, sizeof (IR::ConstantDef));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ConstantDef, &_tc_TAO_tc_IR_ConstantDef)
-TAO_NAMESPACE_END
-static const CORBA::Long _oc_IR_ConstantDescription[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  39, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7374), ACE_NTOHL (0x616e7444), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ConstantDescription:1.0
-  20, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x74616e74), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = ConstantDescription
-  6, // member count
-  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-  CORBA::tk_alias, // typecode kind for typedefs
-  64, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-    CORBA::tk_string, 
-    0U, // string length
-
-  3, ACE_NTOHL (0x69640000),  // name = id
-  CORBA::tk_alias, // typecode kind for typedefs
-  68, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-    CORBA::tk_string, 
-    0U, // string length
-
-  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
-  CORBA::tk_alias, // typecode kind for typedefs
-  68, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-    CORBA::tk_string, 
-    0U, // string length
-
-  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
-  CORBA::tk_alias, // typecode kind for typedefs
-  64, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
-    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
-    CORBA::tk_string, 
-    0U, // string length
-
-  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
-  CORBA::tk_TypeCode,
-
-  6, ACE_NTOHL (0x76616c75), ACE_NTOHL (0x65000000),  // name = value
-  CORBA::tk_any,
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_set_members",
+      12,
+      1,
+      istub->orb_core ()
+    );
 
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_ConstantDescription (CORBA::tk_struct, sizeof (_oc_IR_ConstantDescription), (char *) &_oc_IR_ConstantDescription, 0, sizeof (IR::ConstantDescription));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ConstantDescription, &_tc_TAO_tc_IR_ConstantDescription)
-TAO_NAMESPACE_END
-void IR::ConstantDescription::_tao_any_destructor (void *x)
-{
-  ConstantDescription *tmp = ACE_static_cast (ConstantDescription*,x);
-  delete tmp;
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << members)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
+        }
+        
+        break;
+      }
 }
 
 
-///////////////////////////////////////////////////////////////////////
-//                Base & Remote Proxy  Implementation. 
-//
-
-IR::_TAO_TypedefDef_Proxy_Impl::_TAO_TypedefDef_Proxy_Impl (void)
-{}
-
-IR::_TAO_TypedefDef_Remote_Proxy_Impl::_TAO_TypedefDef_Remote_Proxy_Impl (void)
-{}
-
-// Remote Implementation of the IDL interface methods
-
-
 //
 //            End  Base & Remote  Proxy Implemeentation. 
 ///////////////////////////////////////////////////////////////////////
@@ -16409,32 +9877,32 @@
 //           Remote & Base  Proxy Broker Implementation
 //
 
-IR::_TAO_TypedefDef_Proxy_Broker::_TAO_TypedefDef_Proxy_Broker (void)
+_TAO_UnionDef_Proxy_Broker::_TAO_UnionDef_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_TypedefDef_Proxy_Broker::~_TAO_TypedefDef_Proxy_Broker (void)
+_TAO_UnionDef_Proxy_Broker::~_TAO_UnionDef_Proxy_Broker (void)
 {
 }
 
-// Factory Member function Implementation.
-IR::_TAO_TypedefDef_Remote_Proxy_Broker *IR::_TAO_TypedefDef_Remote_Proxy_Broker::the_TAO_TypedefDef_Remote_Proxy_Broker (void)
+// Factory function Implementation.
+_TAO_UnionDef_Remote_Proxy_Broker *the_TAO_UnionDef_Remote_Proxy_Broker (void)
 {
-  static ::IR::_TAO_TypedefDef_Remote_Proxy_Broker remote_proxy_broker;
+  static ::_TAO_UnionDef_Remote_Proxy_Broker remote_proxy_broker;
   return &remote_proxy_broker;
 }
 
-IR::_TAO_TypedefDef_Remote_Proxy_Broker::_TAO_TypedefDef_Remote_Proxy_Broker (void)
+_TAO_UnionDef_Remote_Proxy_Broker::_TAO_UnionDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_TypedefDef_Remote_Proxy_Broker::~_TAO_TypedefDef_Remote_Proxy_Broker (void)
+_TAO_UnionDef_Remote_Proxy_Broker::~_TAO_UnionDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_TypedefDef_Proxy_Impl&
-IR::_TAO_TypedefDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::TypedefDef *object,
+_TAO_UnionDef_Proxy_Impl&
+_TAO_UnionDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_UnionDef *object,
   CORBA::Environment &ACE_TRY_ENV
 )
 {
@@ -16450,113 +9918,115 @@
 
 
 // default constructor
-IR::TypedefDef::TypedefDef (int collocated)
+IR_UnionDef::IR_UnionDef (int collocated)
 {
   this->_tao_setup_collocation (collocated);
 }
 
 // destructor
-IR::TypedefDef::~TypedefDef (void)
+IR_UnionDef::~IR_UnionDef (void)
 {}
 
 void
-IR::TypedefDef::_tao_setup_collocation (int collocated)
+IR_UnionDef::_tao_setup_collocation (int collocated)
 {
   if (collocated)
-    this->the_TAO_TypedefDef_Proxy_Broker_ =
-      ::IR__TAO_TypedefDef_Proxy_Broker_Factory_function_pointer (this);
+    this->the_TAO_UnionDef_Proxy_Broker_ =
+      _TAO_UnionDef_Proxy_Broker_Factory_function_pointer (this);
   else
-    this->the_TAO_TypedefDef_Proxy_Broker_ =
-      ::IR::_TAO_TypedefDef_Remote_Proxy_Broker::the_TAO_TypedefDef_Remote_Proxy_Broker ();
+    this->the_TAO_UnionDef_Proxy_Broker_ =
+      ::the_TAO_UnionDef_Remote_Proxy_Broker ();
   
-  ACE_NESTED_CLASS (IR, Contained)::_tao_setup_collocation (collocated);
-  ACE_NESTED_CLASS (IR, IDLType)::_tao_setup_collocation (collocated);
+  IR_TypedefDef::_tao_setup_collocation (collocated);
+  IR_Container::_tao_setup_collocation (collocated);
 }
 
-void IR::TypedefDef::_tao_any_destructor (void *x)
+void IR_UnionDef::_tao_any_destructor (void *x)
 {
-  TypedefDef *tmp = ACE_static_cast (TypedefDef*,x);
+  IR_UnionDef *tmp = ACE_static_cast (IR_UnionDef*,x);
   CORBA::release (tmp);
 }
 
-IR::TypedefDef_ptr IR::TypedefDef::_narrow (
+IR_UnionDef_ptr IR_UnionDef::_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
 {
   if (CORBA::is_nil (obj))
-    return TypedefDef::_nil ();
+    return IR_UnionDef::_nil ();
   if (! obj->_is_local ())
     {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/TypedefDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (TypedefDef::_nil ());
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/UnionDef:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (IR_UnionDef::_nil ());
       if (is_a == 0)
-        return TypedefDef::_nil ();
+        return IR_UnionDef::_nil ();
     }
-  return TypedefDef::_unchecked_narrow (obj, ACE_TRY_ENV);
+  return IR_UnionDef::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::TypedefDef_ptr IR::TypedefDef::_unchecked_narrow (
+IR_UnionDef_ptr IR_UnionDef::_unchecked_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &
   )
 {
   if (CORBA::is_nil (obj))
-    return TypedefDef::_nil ();
+    return IR_UnionDef::_nil ();
   if (! obj->_is_local ())
     {
       TAO_Stub* stub = obj->_stubobj ();
       if (stub)
         stub->_incr_refcnt ();
-      TypedefDef_ptr default_proxy = TypedefDef::_nil ();
+      IR_UnionDef_ptr default_proxy = IR_UnionDef::_nil ();
 
       if (
           !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
           stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_TypedefDef_Proxy_Broker_Factory_function_pointer != 0
+          obj->_is_collocated () &&_TAO_UnionDef_Proxy_Broker_Factory_function_pointer != 0
         )
       {
         ACE_NEW_RETURN (
           default_proxy,
-          ::IR::TypedefDef (
+          ::IR_UnionDef (
             stub,
             1,
             obj->_servant ()),
             
-          TypedefDef::_nil ());
+          IR_UnionDef::_nil ());
         }
       if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::TypedefDef (stub, 0, obj->_servant ()), TypedefDef::_nil ());
+        ACE_NEW_RETURN (default_proxy, ::IR_UnionDef (stub, 0, obj->_servant ()), IR_UnionDef::_nil ());
         return default_proxy;
       }
     else 
       return
         ACE_reinterpret_cast
           (
-            TypedefDef_ptr,
+            IR_UnionDef_ptr,
               obj->_tao_QueryInterface
                 (
                   ACE_reinterpret_cast
                     (
                       ptr_arith_t,
-                      &TypedefDef::_narrow
+                      &IR_UnionDef::_narrow
                     )
                 )
           );
 }
 
-IR::TypedefDef_ptr
-IR::TypedefDef::_duplicate (TypedefDef_ptr obj)
+IR_UnionDef_ptr
+IR_UnionDef::_duplicate (IR_UnionDef_ptr obj)
 {
   if (!CORBA::is_nil (obj))
     obj->_add_ref ();
   return obj;
 }
 
-CORBA::Boolean IR::TypedefDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+CORBA::Boolean IR_UnionDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
   if (
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/UnionDef:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
@@ -16566,148 +10036,181 @@
     return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
 }
 
-void *IR::TypedefDef::_tao_QueryInterface (ptr_arith_t type)
+void *IR_UnionDef::_tao_QueryInterface (ptr_arith_t type)
 {
   void *retv = 0;
   if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, TypedefDef)::_narrow))
+      &IR_UnionDef::_narrow))
     retv = ACE_reinterpret_cast (void*, this);
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Contained)::_narrow))
+      &IR_TypedefDef::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::Contained_ptr,
+            IR_TypedefDef_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, IDLType)::_narrow))
+      &IR_Container::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::IDLType_ptr,
+            IR_Container_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
+      &IR_Contained::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            CORBA::IRObject_ptr,
+            IR_Contained_ptr,
             this
           )
       );
-  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
-    retv = ACE_reinterpret_cast (void *,
-      ACE_static_cast (CORBA::Object_ptr, this));
-    
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_IDLType::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            IR_IDLType_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &CORBA_IRObject::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            CORBA_IRObject_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
+    retv = ACE_reinterpret_cast (void *,
+      ACE_static_cast (CORBA::Object_ptr, this));
+    
   if (retv)
     this->_add_ref ();
   return retv;
 }
 
-const char* IR::TypedefDef::_interface_repository_id (void) const
+const char* IR_UnionDef::_interface_repository_id (void) const
 {
-  return "IDL:omg.org/IR/TypedefDef:1.0";
+  return "IDL:omg.org/IR/UnionDef:1.0";
 }
 
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_TypedefDef[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f54), ACE_NTOHL (0x79706564), ACE_NTOHL (0x65664465), ACE_NTOHL (0x663a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/TypedefDef:1.0
-  11, ACE_NTOHL (0x54797065), ACE_NTOHL (0x64656644), ACE_NTOHL (0x65660000),  // name = TypedefDef
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_TypedefDef (CORBA::tk_objref, sizeof (_oc_IR_TypedefDef), (char *) &_oc_IR_TypedefDef, 0, sizeof (IR::TypedefDef));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_TypedefDef, &_tc_TAO_tc_IR_TypedefDef)
-TAO_NAMESPACE_END
-static const CORBA::Long _oc_IR_TypeDescription[] =
+CORBA::TypeCode_ptr IR_UnionDef::discriminator_type (
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f54), ACE_NTOHL (0x79706544), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/TypeDescription:1.0
-  16, ACE_NTOHL (0x54797065), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = TypeDescription
-  5, // member count
-  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-  CORBA::tk_alias, // typecode kind for typedefs
-  64, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-    CORBA::tk_string, 
-    0U, // string length
+  return this->the_TAO_UnionDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).discriminator_type (
+      this,
+      ACE_TRY_ENV
+    );
+}
 
-  3, ACE_NTOHL (0x69640000),  // name = id
-  CORBA::tk_alias, // typecode kind for typedefs
-  68, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-    CORBA::tk_string, 
-    0U, // string length
+IR_IDLType_ptr IR_UnionDef::discriminator_type_def (
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  return this->the_TAO_UnionDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).discriminator_type_def (
+      this,
+      ACE_TRY_ENV
+    );
+}
 
-  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
-  CORBA::tk_alias, // typecode kind for typedefs
-  68, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-    CORBA::tk_string, 
-    0U, // string length
+void IR_UnionDef::discriminator_type_def (
+    IR_IDLType_ptr discriminator_type_def,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  this->the_TAO_UnionDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).discriminator_type_def (
+      this,
+      discriminator_type_def,
+      ACE_TRY_ENV
+    );
+}
 
-  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
-  CORBA::tk_alias, // typecode kind for typedefs
-  64, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
-    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
-    CORBA::tk_string, 
-    0U, // string length
+IR_UnionMemberSeq * IR_UnionDef::members (
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  return this->the_TAO_UnionDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).members (
+      this,
+      ACE_TRY_ENV
+    );
+}
 
-  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
-  CORBA::tk_TypeCode,
+void IR_UnionDef::members (
+    const IR_UnionMemberSeq & members,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  this->the_TAO_UnionDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).members (
+      this,
+      members,
+      ACE_TRY_ENV
+    );
+}
 
+static const CORBA::Long _oc_IR_UnionDef[] =
+{
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x6e696f6e), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/UnionDef:1.0
+  9, ACE_NTOHL (0x556e696f), ACE_NTOHL (0x6e446566), ACE_NTOHL (0x0),  // name = IR_UnionDef
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_TypeDescription (CORBA::tk_struct, sizeof (_oc_IR_TypeDescription), (char *) &_oc_IR_TypeDescription, 0, sizeof (IR::TypeDescription));
+static CORBA::TypeCode _tc_TAO_tc_IR_UnionDef (CORBA::tk_objref, sizeof (_oc_IR_UnionDef), (char *) &_oc_IR_UnionDef, 0, sizeof (IR_UnionDef));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_TypeDescription, &_tc_TAO_tc_IR_TypeDescription)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UnionDef, &_tc_TAO_tc_IR_UnionDef)
 TAO_NAMESPACE_END
-void IR::TypeDescription::_tao_any_destructor (void *x)
-{
-  TypeDescription *tmp = ACE_static_cast (TypeDescription*,x);
-  delete tmp;
-}
-
 
 ///////////////////////////////////////////////////////////////////////
 //                Base & Remote Proxy  Implementation. 
 //
 
-IR::_TAO_StructDef_Proxy_Impl::_TAO_StructDef_Proxy_Impl (void)
+_TAO_EnumDef_Proxy_Impl::_TAO_EnumDef_Proxy_Impl (void)
 {}
 
-IR::_TAO_StructDef_Remote_Proxy_Impl::_TAO_StructDef_Remote_Proxy_Impl (void)
+_TAO_EnumDef_Remote_Proxy_Impl::_TAO_EnumDef_Remote_Proxy_Impl (void)
 {}
 
 // Remote Implementation of the IDL interface methods
 
-IR::StructMemberSeq * IR::_TAO_StructDef_Remote_Proxy_Impl::members (
+IR_EnumMemberSeq * _TAO_EnumDef_Remote_Proxy_Impl::members (
     CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -16715,17 +10218,14 @@
     CORBA::SystemException
   ))
 {
-  
-  IR::StructMemberSeq *_tao_retval = 0;
-  
+  IR_EnumMemberSeq *_tao_retval = 0;
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-  
-  ACE_NEW_RETURN (_tao_retval, IR::StructMemberSeq, _tao_retval);
-  IR::StructMemberSeq_var _tao_safe_retval (_tao_retval);
+  ACE_NEW_RETURN (_tao_retval, IR_EnumMemberSeq, _tao_retval);
+  IR_EnumMemberSeq_var _tao_safe_retval (_tao_retval);
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
       "_get_members",
@@ -16734,158 +10234,63 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::StructDef::TAO_ClientRequestInfo_IR_StructDef_members_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::StructMemberSeq * _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
         }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
-void IR::_TAO_StructDef_Remote_Proxy_Impl::members (
+void _TAO_EnumDef_Remote_Proxy_Impl::members (
     CORBA_Object *_collocated_tao_target_,
-    const IR::StructMemberSeq & members,
+    const IR_EnumMemberSeq & members,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-
-  
-  
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW (CORBA::INTERNAL ());
 
-  
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
       "_set_members",
@@ -16894,130 +10299,45 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::StructDef::TAO_ClientRequestInfo_IR_StructDef_members_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        members,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << members)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << members)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
       
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
         }
-      
-      break;
-    }
-  
+        
+        break;
+      }
 }
 
 
@@ -17030,32 +10350,32 @@
 //           Remote & Base  Proxy Broker Implementation
 //
 
-IR::_TAO_StructDef_Proxy_Broker::_TAO_StructDef_Proxy_Broker (void)
+_TAO_EnumDef_Proxy_Broker::_TAO_EnumDef_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_StructDef_Proxy_Broker::~_TAO_StructDef_Proxy_Broker (void)
+_TAO_EnumDef_Proxy_Broker::~_TAO_EnumDef_Proxy_Broker (void)
 {
 }
 
-// Factory Member function Implementation.
-IR::_TAO_StructDef_Remote_Proxy_Broker *IR::_TAO_StructDef_Remote_Proxy_Broker::the_TAO_StructDef_Remote_Proxy_Broker (void)
+// Factory function Implementation.
+_TAO_EnumDef_Remote_Proxy_Broker *the_TAO_EnumDef_Remote_Proxy_Broker (void)
 {
-  static ::IR::_TAO_StructDef_Remote_Proxy_Broker remote_proxy_broker;
+  static ::_TAO_EnumDef_Remote_Proxy_Broker remote_proxy_broker;
   return &remote_proxy_broker;
 }
 
-IR::_TAO_StructDef_Remote_Proxy_Broker::_TAO_StructDef_Remote_Proxy_Broker (void)
+_TAO_EnumDef_Remote_Proxy_Broker::_TAO_EnumDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_StructDef_Remote_Proxy_Broker::~_TAO_StructDef_Remote_Proxy_Broker (void)
+_TAO_EnumDef_Remote_Proxy_Broker::~_TAO_EnumDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_StructDef_Proxy_Impl&
-IR::_TAO_StructDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::StructDef *object,
+_TAO_EnumDef_Proxy_Impl&
+_TAO_EnumDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_EnumDef *object,
   CORBA::Environment &ACE_TRY_ENV
 )
 {
@@ -17071,115 +10391,114 @@
 
 
 // default constructor
-IR::StructDef::StructDef (int collocated)
+IR_EnumDef::IR_EnumDef (int collocated)
 {
   this->_tao_setup_collocation (collocated);
 }
 
 // destructor
-IR::StructDef::~StructDef (void)
+IR_EnumDef::~IR_EnumDef (void)
 {}
 
 void
-IR::StructDef::_tao_setup_collocation (int collocated)
+IR_EnumDef::_tao_setup_collocation (int collocated)
 {
   if (collocated)
-    this->the_TAO_StructDef_Proxy_Broker_ =
-      ::IR__TAO_StructDef_Proxy_Broker_Factory_function_pointer (this);
+    this->the_TAO_EnumDef_Proxy_Broker_ =
+      _TAO_EnumDef_Proxy_Broker_Factory_function_pointer (this);
   else
-    this->the_TAO_StructDef_Proxy_Broker_ =
-      ::IR::_TAO_StructDef_Remote_Proxy_Broker::the_TAO_StructDef_Remote_Proxy_Broker ();
+    this->the_TAO_EnumDef_Proxy_Broker_ =
+      ::the_TAO_EnumDef_Remote_Proxy_Broker ();
+  
+  IR_TypedefDef::_tao_setup_collocation (collocated);
   
-  ACE_NESTED_CLASS (IR, TypedefDef)::_tao_setup_collocation (collocated);
-  ACE_NESTED_CLASS (IR, Container)::_tao_setup_collocation (collocated);
 }
 
-void IR::StructDef::_tao_any_destructor (void *x)
+void IR_EnumDef::_tao_any_destructor (void *x)
 {
-  StructDef *tmp = ACE_static_cast (StructDef*,x);
+  IR_EnumDef *tmp = ACE_static_cast (IR_EnumDef*,x);
   CORBA::release (tmp);
 }
 
-IR::StructDef_ptr IR::StructDef::_narrow (
+IR_EnumDef_ptr IR_EnumDef::_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
 {
   if (CORBA::is_nil (obj))
-    return StructDef::_nil ();
+    return IR_EnumDef::_nil ();
   if (! obj->_is_local ())
     {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/StructDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (StructDef::_nil ());
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/EnumDef:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (IR_EnumDef::_nil ());
       if (is_a == 0)
-        return StructDef::_nil ();
+        return IR_EnumDef::_nil ();
     }
-  return StructDef::_unchecked_narrow (obj, ACE_TRY_ENV);
+  return IR_EnumDef::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::StructDef_ptr IR::StructDef::_unchecked_narrow (
+IR_EnumDef_ptr IR_EnumDef::_unchecked_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &
   )
 {
   if (CORBA::is_nil (obj))
-    return StructDef::_nil ();
+    return IR_EnumDef::_nil ();
   if (! obj->_is_local ())
     {
       TAO_Stub* stub = obj->_stubobj ();
       if (stub)
         stub->_incr_refcnt ();
-      StructDef_ptr default_proxy = StructDef::_nil ();
+      IR_EnumDef_ptr default_proxy = IR_EnumDef::_nil ();
 
       if (
           !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
           stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_StructDef_Proxy_Broker_Factory_function_pointer != 0
+          obj->_is_collocated () &&_TAO_EnumDef_Proxy_Broker_Factory_function_pointer != 0
         )
       {
         ACE_NEW_RETURN (
           default_proxy,
-          ::IR::StructDef (
+          ::IR_EnumDef (
             stub,
             1,
             obj->_servant ()),
             
-          StructDef::_nil ());
+          IR_EnumDef::_nil ());
         }
       if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::StructDef (stub, 0, obj->_servant ()), StructDef::_nil ());
+        ACE_NEW_RETURN (default_proxy, ::IR_EnumDef (stub, 0, obj->_servant ()), IR_EnumDef::_nil ());
         return default_proxy;
       }
     else 
       return
         ACE_reinterpret_cast
           (
-            StructDef_ptr,
+            IR_EnumDef_ptr,
               obj->_tao_QueryInterface
                 (
                   ACE_reinterpret_cast
                     (
                       ptr_arith_t,
-                      &StructDef::_narrow
+                      &IR_EnumDef::_narrow
                     )
                 )
           );
 }
 
-IR::StructDef_ptr
-IR::StructDef::_duplicate (StructDef_ptr obj)
+IR_EnumDef_ptr
+IR_EnumDef::_duplicate (IR_EnumDef_ptr obj)
 {
   if (!CORBA::is_nil (obj))
     obj->_add_ref ();
   return obj;
 }
 
-CORBA::Boolean IR::StructDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+CORBA::Boolean IR_EnumDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
   if (
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/StructDef:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EnumDef:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
@@ -17189,70 +10508,58 @@
     return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
 }
 
-void *IR::StructDef::_tao_QueryInterface (ptr_arith_t type)
+void *IR_EnumDef::_tao_QueryInterface (ptr_arith_t type)
 {
   void *retv = 0;
   if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, StructDef)::_narrow))
+      &IR_EnumDef::_narrow))
     retv = ACE_reinterpret_cast (void*, this);
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, TypedefDef)::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            IR::TypedefDef_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Container)::_narrow))
+      &IR_TypedefDef::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::Container_ptr,
+            IR_TypedefDef_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Contained)::_narrow))
+      &IR_Contained::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::Contained_ptr,
+            IR_Contained_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, IDLType)::_narrow))
+      &IR_IDLType::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::IDLType_ptr,
+            IR_IDLType_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
+      &CORBA_IRObject::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            CORBA::IRObject_ptr,
+            CORBA_IRObject_ptr,
             this
           )
       );
@@ -17265,181 +10572,64 @@
   return retv;
 }
 
-const char* IR::StructDef::_interface_repository_id (void) const
+const char* IR_EnumDef::_interface_repository_id (void) const
 {
-  return "IDL:omg.org/IR/StructDef:1.0";
+  return "IDL:omg.org/IR/EnumDef:1.0";
 }
 
-IR::StructMemberSeq * IR::StructDef::members (
+IR_EnumMemberSeq * IR_EnumDef::members (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-  return this->the_TAO_StructDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).members (
+  return this->the_TAO_EnumDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).members (
       this,
       ACE_TRY_ENV
     );
 }
 
-void IR::StructDef::members (
-    const IR::StructMemberSeq & members,
+void IR_EnumDef::members (
+    const IR_EnumMemberSeq & members,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-  this->the_TAO_StructDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).members (
+  this->the_TAO_EnumDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).members (
       this,
       members,
       ACE_TRY_ENV
     );
 }
 
+static const CORBA::Long _oc_IR_EnumDef[] =
+{
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x6e756d44), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/EnumDef:1.0
+  8, ACE_NTOHL (0x456e756d), ACE_NTOHL (0x44656600),  // name = IR_EnumDef
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_EnumDef (CORBA::tk_objref, sizeof (_oc_IR_EnumDef), (char *) &_oc_IR_EnumDef, 0, sizeof (IR_EnumDef));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EnumDef, &_tc_TAO_tc_IR_EnumDef)
+TAO_NAMESPACE_END
+
+///////////////////////////////////////////////////////////////////////
+//                Base & Remote Proxy  Implementation. 
+//
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-IR::StructDef::TAO_ClientRequestInfo_IR_StructDef_members_get::TAO_ClientRequestInfo_IR_StructDef_members_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
+_TAO_AliasDef_Proxy_Impl::_TAO_AliasDef_Proxy_Impl (void)
 {}
 
-Dynamic::ParameterList *
-IR::StructDef::TAO_ClientRequestInfo_IR_StructDef_members_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::StructDef::TAO_ClientRequestInfo_IR_StructDef_members_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::StructDef::TAO_ClientRequestInfo_IR_StructDef_members_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::StructDef::TAO_ClientRequestInfo_IR_StructDef_members_get::result (IR::StructMemberSeq * result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::StructDef::TAO_ClientRequestInfo_IR_StructDef_members_set::TAO_ClientRequestInfo_IR_StructDef_members_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const IR::StructMemberSeq & members,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    members_ (members)
-{}
-
-Dynamic::ParameterList *
-IR::StructDef::TAO_ClientRequestInfo_IR_StructDef_members_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_members = parameter_list->length ();
-  parameter_list->length (length_members + 1);
-  (*parameter_list)[length_members].argument <<=  this->members_;
-  
-  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::StructDef::TAO_ClientRequestInfo_IR_StructDef_members_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::StructDef::TAO_ClientRequestInfo_IR_StructDef_members_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
-}
-
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_StructDef[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x74446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/StructDef:1.0
-  10, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744465), ACE_NTOHL (0x66000000),  // name = StructDef
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_StructDef (CORBA::tk_objref, sizeof (_oc_IR_StructDef), (char *) &_oc_IR_StructDef, 0, sizeof (IR::StructDef));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_StructDef, &_tc_TAO_tc_IR_StructDef)
-TAO_NAMESPACE_END
-
-///////////////////////////////////////////////////////////////////////
-//                Base & Remote Proxy  Implementation. 
-//
-
-IR::_TAO_UnionDef_Proxy_Impl::_TAO_UnionDef_Proxy_Impl (void)
-{}
-
-IR::_TAO_UnionDef_Remote_Proxy_Impl::_TAO_UnionDef_Remote_Proxy_Impl (void)
-{}
+_TAO_AliasDef_Remote_Proxy_Impl::_TAO_AliasDef_Remote_Proxy_Impl (void)
+{}
 
 // Remote Implementation of the IDL interface methods
 
-CORBA::TypeCode_ptr IR::_TAO_UnionDef_Remote_Proxy_Impl::discriminator_type (
+IR_IDLType_ptr _TAO_AliasDef_Remote_Proxy_Impl::original_type_def (
     CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -17447,826 +10637,170 @@
     CORBA::SystemException
   ))
 {
-  
-  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
-  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
-  
+  IR_IDLType_ptr _tao_retval = IR_IDLType::_nil ();
+  IR_IDLType_var _tao_safe_retval (_tao_retval);
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-  
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_get_discriminator_type",
-      23,
+      "_get_original_type_def",
+      22,
       0,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              CORBA::TypeCode_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
         }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
-IR::IDLType_ptr IR::_TAO_UnionDef_Remote_Proxy_Impl::discriminator_type_def (
+void _TAO_AliasDef_Remote_Proxy_Impl::original_type_def (
     CORBA_Object *_collocated_tao_target_,
+    IR_IDLType_ptr original_type_def,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-  IR::IDLType_ptr _tao_retval = IR::IDLType::_nil ();
-  IR::IDLType_var _tao_safe_retval (_tao_retval);
-  
-  
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+    ACE_THROW (CORBA::INTERNAL ());
 
-  
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_get_discriminator_type_def",
-      27,
-      0,
+      "_set_original_type_def",
+      22,
+      1,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_def_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::IDLType_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << original_type_def)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
       
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
         }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
+        
+        break;
+      }
 }
 
-void IR::_TAO_UnionDef_Remote_Proxy_Impl::discriminator_type_def (
-    CORBA_Object *_collocated_tao_target_,
-    IR::IDLType_ptr discriminator_type_def,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
 
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW (CORBA::INTERNAL ());
+//
+//            End  Base & Remote  Proxy Implemeentation. 
+///////////////////////////////////////////////////////////////////////
 
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_set_discriminator_type_def",
-      27,
-      1,
-      istub->orb_core ()
-    );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_def_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        discriminator_type_def,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << discriminator_type_def)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+///////////////////////////////////////////////////////////////////////
+//           Remote & Base  Proxy Broker Implementation
+//
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  
+_TAO_AliasDef_Proxy_Broker::_TAO_AliasDef_Proxy_Broker (void)
+{
 }
 
-IR::UnionMemberSeq * IR::_TAO_UnionDef_Remote_Proxy_Impl::members (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
+_TAO_AliasDef_Proxy_Broker::~_TAO_AliasDef_Proxy_Broker (void)
 {
-  
-  IR::UnionMemberSeq *_tao_retval = 0;
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+}
 
-  
-  ACE_NEW_RETURN (_tao_retval, IR::UnionMemberSeq, _tao_retval);
-  IR::UnionMemberSeq_var _tao_safe_retval (_tao_retval);
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_members",
-      12,
-      0,
-      istub->orb_core ()
-    );
+// Factory function Implementation.
+_TAO_AliasDef_Remote_Proxy_Broker *the_TAO_AliasDef_Remote_Proxy_Broker (void)
+{
+  static ::_TAO_AliasDef_Remote_Proxy_Broker remote_proxy_broker;
+  return &remote_proxy_broker;
+}
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::UnionDef::TAO_ClientRequestInfo_IR_UnionDef_members_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::UnionMemberSeq * _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+_TAO_AliasDef_Remote_Proxy_Broker::_TAO_AliasDef_Remote_Proxy_Broker (void)
+{
+}
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
+_TAO_AliasDef_Remote_Proxy_Broker::~_TAO_AliasDef_Remote_Proxy_Broker (void)
+{
 }
 
-void IR::_TAO_UnionDef_Remote_Proxy_Impl::members (
-    CORBA_Object *_collocated_tao_target_,
-    const IR::UnionMemberSeq & members,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
+_TAO_AliasDef_Proxy_Impl&
+_TAO_AliasDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_AliasDef *object,
+  CORBA::Environment &ACE_TRY_ENV
+)
 {
-  
-
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW (CORBA::INTERNAL ());
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_set_members",
-      12,
-      1,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::UnionDef::TAO_ClientRequestInfo_IR_UnionDef_members_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        members,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << members)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  
-}
-
-
-//
-//            End  Base & Remote  Proxy Implemeentation. 
-///////////////////////////////////////////////////////////////////////
-
-
-///////////////////////////////////////////////////////////////////////
-//           Remote & Base  Proxy Broker Implementation
-//
-
-IR::_TAO_UnionDef_Proxy_Broker::_TAO_UnionDef_Proxy_Broker (void)
-{
-}
-
-IR::_TAO_UnionDef_Proxy_Broker::~_TAO_UnionDef_Proxy_Broker (void)
-{
-}
-
-// Factory Member function Implementation.
-IR::_TAO_UnionDef_Remote_Proxy_Broker *IR::_TAO_UnionDef_Remote_Proxy_Broker::the_TAO_UnionDef_Remote_Proxy_Broker (void)
-{
-  static ::IR::_TAO_UnionDef_Remote_Proxy_Broker remote_proxy_broker;
-  return &remote_proxy_broker;
-}
-
-IR::_TAO_UnionDef_Remote_Proxy_Broker::_TAO_UnionDef_Remote_Proxy_Broker (void)
-{
-}
-
-IR::_TAO_UnionDef_Remote_Proxy_Broker::~_TAO_UnionDef_Remote_Proxy_Broker (void)
-{
-}
-
-IR::_TAO_UnionDef_Proxy_Impl&
-IR::_TAO_UnionDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::UnionDef *object,
-  CORBA::Environment &ACE_TRY_ENV
-)
-{
-  ACE_UNUSED_ARG (object);
-  ACE_UNUSED_ARG (ACE_TRY_ENV);
-  return remote_proxy_impl_;
-}
+  ACE_UNUSED_ARG (object);
+  ACE_UNUSED_ARG (ACE_TRY_ENV);
+  return remote_proxy_impl_;
+}
 
 
 //
@@ -18275,115 +10809,114 @@
 
 
 // default constructor
-IR::UnionDef::UnionDef (int collocated)
+IR_AliasDef::IR_AliasDef (int collocated)
 {
   this->_tao_setup_collocation (collocated);
 }
 
 // destructor
-IR::UnionDef::~UnionDef (void)
+IR_AliasDef::~IR_AliasDef (void)
 {}
 
 void
-IR::UnionDef::_tao_setup_collocation (int collocated)
+IR_AliasDef::_tao_setup_collocation (int collocated)
 {
   if (collocated)
-    this->the_TAO_UnionDef_Proxy_Broker_ =
-      ::IR__TAO_UnionDef_Proxy_Broker_Factory_function_pointer (this);
+    this->the_TAO_AliasDef_Proxy_Broker_ =
+      _TAO_AliasDef_Proxy_Broker_Factory_function_pointer (this);
   else
-    this->the_TAO_UnionDef_Proxy_Broker_ =
-      ::IR::_TAO_UnionDef_Remote_Proxy_Broker::the_TAO_UnionDef_Remote_Proxy_Broker ();
+    this->the_TAO_AliasDef_Proxy_Broker_ =
+      ::the_TAO_AliasDef_Remote_Proxy_Broker ();
+  
+  IR_TypedefDef::_tao_setup_collocation (collocated);
   
-  ACE_NESTED_CLASS (IR, TypedefDef)::_tao_setup_collocation (collocated);
-  ACE_NESTED_CLASS (IR, Container)::_tao_setup_collocation (collocated);
 }
 
-void IR::UnionDef::_tao_any_destructor (void *x)
+void IR_AliasDef::_tao_any_destructor (void *x)
 {
-  UnionDef *tmp = ACE_static_cast (UnionDef*,x);
+  IR_AliasDef *tmp = ACE_static_cast (IR_AliasDef*,x);
   CORBA::release (tmp);
 }
 
-IR::UnionDef_ptr IR::UnionDef::_narrow (
+IR_AliasDef_ptr IR_AliasDef::_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
 {
   if (CORBA::is_nil (obj))
-    return UnionDef::_nil ();
+    return IR_AliasDef::_nil ();
   if (! obj->_is_local ())
     {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/UnionDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (UnionDef::_nil ());
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/AliasDef:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (IR_AliasDef::_nil ());
       if (is_a == 0)
-        return UnionDef::_nil ();
+        return IR_AliasDef::_nil ();
     }
-  return UnionDef::_unchecked_narrow (obj, ACE_TRY_ENV);
+  return IR_AliasDef::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::UnionDef_ptr IR::UnionDef::_unchecked_narrow (
+IR_AliasDef_ptr IR_AliasDef::_unchecked_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &
   )
 {
   if (CORBA::is_nil (obj))
-    return UnionDef::_nil ();
+    return IR_AliasDef::_nil ();
   if (! obj->_is_local ())
     {
       TAO_Stub* stub = obj->_stubobj ();
       if (stub)
         stub->_incr_refcnt ();
-      UnionDef_ptr default_proxy = UnionDef::_nil ();
+      IR_AliasDef_ptr default_proxy = IR_AliasDef::_nil ();
 
       if (
           !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
           stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_UnionDef_Proxy_Broker_Factory_function_pointer != 0
+          obj->_is_collocated () &&_TAO_AliasDef_Proxy_Broker_Factory_function_pointer != 0
         )
       {
         ACE_NEW_RETURN (
           default_proxy,
-          ::IR::UnionDef (
+          ::IR_AliasDef (
             stub,
             1,
             obj->_servant ()),
             
-          UnionDef::_nil ());
+          IR_AliasDef::_nil ());
         }
       if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::UnionDef (stub, 0, obj->_servant ()), UnionDef::_nil ());
+        ACE_NEW_RETURN (default_proxy, ::IR_AliasDef (stub, 0, obj->_servant ()), IR_AliasDef::_nil ());
         return default_proxy;
       }
     else 
       return
         ACE_reinterpret_cast
           (
-            UnionDef_ptr,
+            IR_AliasDef_ptr,
               obj->_tao_QueryInterface
                 (
                   ACE_reinterpret_cast
                     (
                       ptr_arith_t,
-                      &UnionDef::_narrow
+                      &IR_AliasDef::_narrow
                     )
                 )
           );
 }
 
-IR::UnionDef_ptr
-IR::UnionDef::_duplicate (UnionDef_ptr obj)
+IR_AliasDef_ptr
+IR_AliasDef::_duplicate (IR_AliasDef_ptr obj)
 {
   if (!CORBA::is_nil (obj))
     obj->_add_ref ();
   return obj;
 }
 
-CORBA::Boolean IR::UnionDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+CORBA::Boolean IR_AliasDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
   if (
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/UnionDef:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/AliasDef:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
@@ -18393,70 +10926,58 @@
     return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
 }
 
-void *IR::UnionDef::_tao_QueryInterface (ptr_arith_t type)
+void *IR_AliasDef::_tao_QueryInterface (ptr_arith_t type)
 {
   void *retv = 0;
   if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, UnionDef)::_narrow))
+      &IR_AliasDef::_narrow))
     retv = ACE_reinterpret_cast (void*, this);
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, TypedefDef)::_narrow))
+      &IR_TypedefDef::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::TypedefDef_ptr,
+            IR_TypedefDef_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Container)::_narrow))
+      &IR_Contained::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::Container_ptr,
+            IR_Contained_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Contained)::_narrow))
+      &IR_IDLType::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::Contained_ptr,
+            IR_IDLType_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, IDLType)::_narrow))
+      &CORBA_IRObject::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::IDLType_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            CORBA::IRObject_ptr,
+            CORBA_IRObject_ptr,
             this
           )
       );
@@ -18469,393 +10990,325 @@
   return retv;
 }
 
-const char* IR::UnionDef::_interface_repository_id (void) const
-{
-  return "IDL:omg.org/IR/UnionDef:1.0";
-}
-
-CORBA::TypeCode_ptr IR::UnionDef::discriminator_type (
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_UnionDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).discriminator_type (
-      this,
-      ACE_TRY_ENV
-    );
-}
-
-IR::IDLType_ptr IR::UnionDef::discriminator_type_def (
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
+const char* IR_AliasDef::_interface_repository_id (void) const
 {
-  
-  return this->the_TAO_UnionDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).discriminator_type_def (
-      this,
-      ACE_TRY_ENV
-    );
+  return "IDL:omg.org/IR/AliasDef:1.0";
 }
 
-void IR::UnionDef::discriminator_type_def (
-    IR::IDLType_ptr discriminator_type_def,
+IR_IDLType_ptr IR_AliasDef::original_type_def (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-  this->the_TAO_UnionDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).discriminator_type_def (
+  return this->the_TAO_AliasDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).original_type_def (
       this,
-      discriminator_type_def,
       ACE_TRY_ENV
     );
 }
 
-IR::UnionMemberSeq * IR::UnionDef::members (
+void IR_AliasDef::original_type_def (
+    IR_IDLType_ptr original_type_def,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-  return this->the_TAO_UnionDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).members (
+  this->the_TAO_AliasDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).original_type_def (
       this,
+      original_type_def,
       ACE_TRY_ENV
     );
 }
 
-void IR::UnionDef::members (
-    const IR::UnionMemberSeq & members,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
+static const CORBA::Long _oc_IR_AliasDef[] =
 {
-  
-  this->the_TAO_UnionDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).members (
-      this,
-      members,
-      ACE_TRY_ENV
-    );
-}
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x6c696173), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/AliasDef:1.0
+  9, ACE_NTOHL (0x416c6961), ACE_NTOHL (0x73446566), ACE_NTOHL (0x0),  // name = IR_AliasDef
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_AliasDef (CORBA::tk_objref, sizeof (_oc_IR_AliasDef), (char *) &_oc_IR_AliasDef, 0, sizeof (IR_AliasDef));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AliasDef, &_tc_TAO_tc_IR_AliasDef)
+TAO_NAMESPACE_END
 
+///////////////////////////////////////////////////////////////////////
+//                Base & Remote Proxy  Implementation. 
+//
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-IR::UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_get::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
+_TAO_NativeDef_Proxy_Impl::_TAO_NativeDef_Proxy_Impl (void)
 {}
 
-Dynamic::ParameterList *
-IR::UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
+_TAO_NativeDef_Remote_Proxy_Impl::_TAO_NativeDef_Remote_Proxy_Impl (void)
+{}
 
-void 
-IR::UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_get::result (CORBA::TypeCode_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
+// Remote Implementation of the IDL interface methods
 
-IR::UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_def_get::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_def_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
 
-Dynamic::ParameterList *
-IR::UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_def_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
+//
+//            End  Base & Remote  Proxy Implemeentation. 
+///////////////////////////////////////////////////////////////////////
 
-Dynamic::ExceptionList *
-IR::UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_def_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
 
+///////////////////////////////////////////////////////////////////////
+//           Remote & Base  Proxy Broker Implementation
+//
 
-CORBA::Any * 
-IR::UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_def_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+_TAO_NativeDef_Proxy_Broker::_TAO_NativeDef_Proxy_Broker (void)
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
 }
 
-void 
-IR::UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_def_get::result (IR::IDLType_ptr result)
+_TAO_NativeDef_Proxy_Broker::~_TAO_NativeDef_Proxy_Broker (void)
 {
-  // update the result 
-  this->_result = result;
 }
 
-IR::UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_def_set::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_def_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    IR::IDLType_ptr discriminator_type_def,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    discriminator_type_def_ (discriminator_type_def)
-{}
-
-Dynamic::ParameterList *
-IR::UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_def_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+// Factory function Implementation.
+_TAO_NativeDef_Remote_Proxy_Broker *the_TAO_NativeDef_Remote_Proxy_Broker (void)
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_discriminator_type_def = parameter_list->length ();
-  parameter_list->length (length_discriminator_type_def + 1);
-  (*parameter_list)[length_discriminator_type_def].argument <<=  this->discriminator_type_def_;
-  
-  (*parameter_list)[length_discriminator_type_def].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
+  static ::_TAO_NativeDef_Remote_Proxy_Broker remote_proxy_broker;
+  return &remote_proxy_broker;
 }
 
-Dynamic::ExceptionList *
-IR::UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_def_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+_TAO_NativeDef_Remote_Proxy_Broker::_TAO_NativeDef_Remote_Proxy_Broker (void)
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
 }
 
-
-CORBA::Any * 
-IR::UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_def_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+_TAO_NativeDef_Remote_Proxy_Broker::~_TAO_NativeDef_Remote_Proxy_Broker (void)
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
 }
 
-IR::UnionDef::TAO_ClientRequestInfo_IR_UnionDef_members_get::TAO_ClientRequestInfo_IR_UnionDef_members_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::UnionDef::TAO_ClientRequestInfo_IR_UnionDef_members_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+_TAO_NativeDef_Proxy_Impl&
+_TAO_NativeDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_NativeDef *object,
+  CORBA::Environment &ACE_TRY_ENV
+)
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
+  ACE_UNUSED_ARG (object);
+  ACE_UNUSED_ARG (ACE_TRY_ENV);
+  return remote_proxy_impl_;
 }
 
-Dynamic::ExceptionList *
-IR::UnionDef::TAO_ClientRequestInfo_IR_UnionDef_members_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
 
+//
+//           End Remote & Base Proxy Broker Implementation
+///////////////////////////////////////////////////////////////////////
 
-CORBA::Any * 
-IR::UnionDef::TAO_ClientRequestInfo_IR_UnionDef_members_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
 
-void 
-IR::UnionDef::TAO_ClientRequestInfo_IR_UnionDef_members_get::result (IR::UnionMemberSeq * result)
+// default constructor
+IR_NativeDef::IR_NativeDef (int collocated)
 {
-  // update the result 
-  this->_result = result;
+  this->_tao_setup_collocation (collocated);
 }
 
-IR::UnionDef::TAO_ClientRequestInfo_IR_UnionDef_members_set::TAO_ClientRequestInfo_IR_UnionDef_members_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const IR::UnionMemberSeq & members,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    members_ (members)
+// destructor
+IR_NativeDef::~IR_NativeDef (void)
 {}
 
-Dynamic::ParameterList *
-IR::UnionDef::TAO_ClientRequestInfo_IR_UnionDef_members_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+void
+IR_NativeDef::_tao_setup_collocation (int collocated)
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_members = parameter_list->length ();
-  parameter_list->length (length_members + 1);
-  (*parameter_list)[length_members].argument <<=  this->members_;
+  if (collocated)
+    this->the_TAO_NativeDef_Proxy_Broker_ =
+      _TAO_NativeDef_Proxy_Broker_Factory_function_pointer (this);
+  else
+    this->the_TAO_NativeDef_Proxy_Broker_ =
+      ::the_TAO_NativeDef_Remote_Proxy_Broker ();
   
-  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;
+  IR_TypedefDef::_tao_setup_collocation (collocated);
   
-  return safe_parameter_list._retn ();
 }
 
-Dynamic::ExceptionList *
-IR::UnionDef::TAO_ClientRequestInfo_IR_UnionDef_members_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+void IR_NativeDef::_tao_any_destructor (void *x)
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
+  IR_NativeDef *tmp = ACE_static_cast (IR_NativeDef*,x);
+  CORBA::release (tmp);
 }
 
-
-CORBA::Any * 
-IR::UnionDef::TAO_ClientRequestInfo_IR_UnionDef_members_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+IR_NativeDef_ptr IR_NativeDef::_narrow (
+    CORBA::Object_ptr obj,
+    CORBA::Environment &ACE_TRY_ENV
+  )
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
+  if (CORBA::is_nil (obj))
+    return IR_NativeDef::_nil ();
+  if (! obj->_is_local ())
+    {
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/NativeDef:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (IR_NativeDef::_nil ());
+      if (is_a == 0)
+        return IR_NativeDef::_nil ();
+    }
+  return IR_NativeDef::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_UnionDef[] =
+IR_NativeDef_ptr IR_NativeDef::_unchecked_narrow (
+    CORBA::Object_ptr obj,
+    CORBA::Environment &
+  )
 {
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x6e696f6e), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/UnionDef:1.0
-  9, ACE_NTOHL (0x556e696f), ACE_NTOHL (0x6e446566), ACE_NTOHL (0x0),  // name = UnionDef
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_UnionDef (CORBA::tk_objref, sizeof (_oc_IR_UnionDef), (char *) &_oc_IR_UnionDef, 0, sizeof (IR::UnionDef));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UnionDef, &_tc_TAO_tc_IR_UnionDef)
-TAO_NAMESPACE_END
+  if (CORBA::is_nil (obj))
+    return IR_NativeDef::_nil ();
+  if (! obj->_is_local ())
+    {
+      TAO_Stub* stub = obj->_stubobj ();
+      if (stub)
+        stub->_incr_refcnt ();
+      IR_NativeDef_ptr default_proxy = IR_NativeDef::_nil ();
 
-///////////////////////////////////////////////////////////////////////
-//                Base & Remote Proxy  Implementation. 
+      if (
+          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
+          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
+          obj->_is_collocated () &&_TAO_NativeDef_Proxy_Broker_Factory_function_pointer != 0
+        )
+      {
+        ACE_NEW_RETURN (
+          default_proxy,
+          ::IR_NativeDef (
+            stub,
+            1,
+            obj->_servant ()),
+            
+          IR_NativeDef::_nil ());
+        }
+      if (CORBA::is_nil (default_proxy))
+        ACE_NEW_RETURN (default_proxy, ::IR_NativeDef (stub, 0, obj->_servant ()), IR_NativeDef::_nil ());
+        return default_proxy;
+      }
+    else 
+      return
+        ACE_reinterpret_cast
+          (
+            IR_NativeDef_ptr,
+              obj->_tao_QueryInterface
+                (
+                  ACE_reinterpret_cast
+                    (
+                      ptr_arith_t,
+                      &IR_NativeDef::_narrow
+                    )
+                )
+          );
+}
+
+IR_NativeDef_ptr
+IR_NativeDef::_duplicate (IR_NativeDef_ptr obj)
+{
+  if (!CORBA::is_nil (obj))
+    obj->_add_ref ();
+  return obj;
+}
+
+CORBA::Boolean IR_NativeDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+{
+  if (
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/NativeDef:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
+  return 1; // success using local knowledge
+  else
+    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
+}
+
+void *IR_NativeDef::_tao_QueryInterface (ptr_arith_t type)
+{
+  void *retv = 0;
+  if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_NativeDef::_narrow))
+    retv = ACE_reinterpret_cast (void*, this);
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_TypedefDef::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            IR_TypedefDef_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_Contained::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            IR_Contained_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_IDLType::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            IR_IDLType_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &CORBA_IRObject::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            CORBA_IRObject_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
+    retv = ACE_reinterpret_cast (void *,
+      ACE_static_cast (CORBA::Object_ptr, this));
+    
+  if (retv)
+    this->_add_ref ();
+  return retv;
+}
+
+const char* IR_NativeDef::_interface_repository_id (void) const
+{
+  return "IDL:omg.org/IR/NativeDef:1.0";
+}
+
+static const CORBA::Long _oc_IR_NativeDef[] =
+{
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4e), ACE_NTOHL (0x61746976), ACE_NTOHL (0x65446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/NativeDef:1.0
+  10, ACE_NTOHL (0x4e617469), ACE_NTOHL (0x76654465), ACE_NTOHL (0x66000000),  // name = IR_NativeDef
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_NativeDef (CORBA::tk_objref, sizeof (_oc_IR_NativeDef), (char *) &_oc_IR_NativeDef, 0, sizeof (IR_NativeDef));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_NativeDef, &_tc_TAO_tc_IR_NativeDef)
+TAO_NAMESPACE_END
+
+///////////////////////////////////////////////////////////////////////
+//                Base & Remote Proxy  Implementation. 
 //
 
-IR::_TAO_EnumDef_Proxy_Impl::_TAO_EnumDef_Proxy_Impl (void)
+_TAO_PrimitiveDef_Proxy_Impl::_TAO_PrimitiveDef_Proxy_Impl (void)
 {}
 
-IR::_TAO_EnumDef_Remote_Proxy_Impl::_TAO_EnumDef_Remote_Proxy_Impl (void)
+_TAO_PrimitiveDef_Remote_Proxy_Impl::_TAO_PrimitiveDef_Remote_Proxy_Impl (void)
 {}
 
 // Remote Implementation of the IDL interface methods
 
-IR::EnumMemberSeq * IR::_TAO_EnumDef_Remote_Proxy_Impl::members (
+IR_PrimitiveKind _TAO_PrimitiveDef_Remote_Proxy_Impl::kind (
     CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -18863,309 +11316,62 @@
     CORBA::SystemException
   ))
 {
-  
-  IR::EnumMemberSeq *_tao_retval = 0;
-  
+  IR_PrimitiveKind _tao_retval = (IR_PrimitiveKind)0;
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
 
-  
-  ACE_NEW_RETURN (_tao_retval, IR::EnumMemberSeq, _tao_retval);
-  IR::EnumMemberSeq_var _tao_safe_retval (_tao_retval);
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_get_members",
-      12,
+      "_get_kind",
+      9,
       0,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::EnumDef::TAO_ClientRequestInfo_IR_EnumDef_members_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::EnumMemberSeq * _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        ACE_CHECK_RETURN  (_tao_retval);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
-}
-
-void IR::_TAO_EnumDef_Remote_Proxy_Impl::members (
-    CORBA_Object *_collocated_tao_target_,
-    const IR::EnumMemberSeq & members,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW (CORBA::INTERNAL ());
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_set_members",
-      12,
-      1,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::EnumDef::TAO_ClientRequestInfo_IR_EnumDef_members_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        members,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << members)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              _tao_retval
             );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
         }
-      ACE_ENDTRY;
-      ACE_CHECK;
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_retval)
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                _tao_retval
+              );
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  
+  return _tao_retval;
 }
 
 
@@ -19178,32 +11384,32 @@
 //           Remote & Base  Proxy Broker Implementation
 //
 
-IR::_TAO_EnumDef_Proxy_Broker::_TAO_EnumDef_Proxy_Broker (void)
+_TAO_PrimitiveDef_Proxy_Broker::_TAO_PrimitiveDef_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_EnumDef_Proxy_Broker::~_TAO_EnumDef_Proxy_Broker (void)
+_TAO_PrimitiveDef_Proxy_Broker::~_TAO_PrimitiveDef_Proxy_Broker (void)
 {
 }
 
-// Factory Member function Implementation.
-IR::_TAO_EnumDef_Remote_Proxy_Broker *IR::_TAO_EnumDef_Remote_Proxy_Broker::the_TAO_EnumDef_Remote_Proxy_Broker (void)
+// Factory function Implementation.
+_TAO_PrimitiveDef_Remote_Proxy_Broker *the_TAO_PrimitiveDef_Remote_Proxy_Broker (void)
 {
-  static ::IR::_TAO_EnumDef_Remote_Proxy_Broker remote_proxy_broker;
+  static ::_TAO_PrimitiveDef_Remote_Proxy_Broker remote_proxy_broker;
   return &remote_proxy_broker;
 }
 
-IR::_TAO_EnumDef_Remote_Proxy_Broker::_TAO_EnumDef_Remote_Proxy_Broker (void)
+_TAO_PrimitiveDef_Remote_Proxy_Broker::_TAO_PrimitiveDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_EnumDef_Remote_Proxy_Broker::~_TAO_EnumDef_Remote_Proxy_Broker (void)
+_TAO_PrimitiveDef_Remote_Proxy_Broker::~_TAO_PrimitiveDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_EnumDef_Proxy_Impl&
-IR::_TAO_EnumDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::EnumDef *object,
+_TAO_PrimitiveDef_Proxy_Impl&
+_TAO_PrimitiveDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_PrimitiveDef *object,
   CORBA::Environment &ACE_TRY_ENV
 )
 {
@@ -19219,114 +11425,113 @@
 
 
 // default constructor
-IR::EnumDef::EnumDef (int collocated)
+IR_PrimitiveDef::IR_PrimitiveDef (int collocated)
 {
   this->_tao_setup_collocation (collocated);
 }
 
 // destructor
-IR::EnumDef::~EnumDef (void)
+IR_PrimitiveDef::~IR_PrimitiveDef (void)
 {}
 
 void
-IR::EnumDef::_tao_setup_collocation (int collocated)
+IR_PrimitiveDef::_tao_setup_collocation (int collocated)
 {
   if (collocated)
-    this->the_TAO_EnumDef_Proxy_Broker_ =
-      ::IR__TAO_EnumDef_Proxy_Broker_Factory_function_pointer (this);
+    this->the_TAO_PrimitiveDef_Proxy_Broker_ =
+      _TAO_PrimitiveDef_Proxy_Broker_Factory_function_pointer (this);
   else
-    this->the_TAO_EnumDef_Proxy_Broker_ =
-      ::IR::_TAO_EnumDef_Remote_Proxy_Broker::the_TAO_EnumDef_Remote_Proxy_Broker ();
+    this->the_TAO_PrimitiveDef_Proxy_Broker_ =
+      ::the_TAO_PrimitiveDef_Remote_Proxy_Broker ();
+  
+  IR_IDLType::_tao_setup_collocation (collocated);
   
-  ACE_NESTED_CLASS (IR, TypedefDef)::_tao_setup_collocation (collocated);
 }
 
-void IR::EnumDef::_tao_any_destructor (void *x)
+void IR_PrimitiveDef::_tao_any_destructor (void *x)
 {
-  EnumDef *tmp = ACE_static_cast (EnumDef*,x);
+  IR_PrimitiveDef *tmp = ACE_static_cast (IR_PrimitiveDef*,x);
   CORBA::release (tmp);
 }
 
-IR::EnumDef_ptr IR::EnumDef::_narrow (
+IR_PrimitiveDef_ptr IR_PrimitiveDef::_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
 {
   if (CORBA::is_nil (obj))
-    return EnumDef::_nil ();
+    return IR_PrimitiveDef::_nil ();
   if (! obj->_is_local ())
     {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/EnumDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (EnumDef::_nil ());
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/PrimitiveDef:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (IR_PrimitiveDef::_nil ());
       if (is_a == 0)
-        return EnumDef::_nil ();
+        return IR_PrimitiveDef::_nil ();
     }
-  return EnumDef::_unchecked_narrow (obj, ACE_TRY_ENV);
+  return IR_PrimitiveDef::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::EnumDef_ptr IR::EnumDef::_unchecked_narrow (
+IR_PrimitiveDef_ptr IR_PrimitiveDef::_unchecked_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &
   )
 {
   if (CORBA::is_nil (obj))
-    return EnumDef::_nil ();
+    return IR_PrimitiveDef::_nil ();
   if (! obj->_is_local ())
     {
       TAO_Stub* stub = obj->_stubobj ();
       if (stub)
         stub->_incr_refcnt ();
-      EnumDef_ptr default_proxy = EnumDef::_nil ();
+      IR_PrimitiveDef_ptr default_proxy = IR_PrimitiveDef::_nil ();
 
       if (
           !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
           stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_EnumDef_Proxy_Broker_Factory_function_pointer != 0
+          obj->_is_collocated () &&_TAO_PrimitiveDef_Proxy_Broker_Factory_function_pointer != 0
         )
       {
         ACE_NEW_RETURN (
           default_proxy,
-          ::IR::EnumDef (
+          ::IR_PrimitiveDef (
             stub,
             1,
             obj->_servant ()),
             
-          EnumDef::_nil ());
+          IR_PrimitiveDef::_nil ());
         }
       if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::EnumDef (stub, 0, obj->_servant ()), EnumDef::_nil ());
+        ACE_NEW_RETURN (default_proxy, ::IR_PrimitiveDef (stub, 0, obj->_servant ()), IR_PrimitiveDef::_nil ());
         return default_proxy;
       }
     else 
       return
         ACE_reinterpret_cast
           (
-            EnumDef_ptr,
+            IR_PrimitiveDef_ptr,
               obj->_tao_QueryInterface
                 (
                   ACE_reinterpret_cast
                     (
                       ptr_arith_t,
-                      &EnumDef::_narrow
+                      &IR_PrimitiveDef::_narrow
                     )
                 )
           );
 }
 
-IR::EnumDef_ptr
-IR::EnumDef::_duplicate (EnumDef_ptr obj)
+IR_PrimitiveDef_ptr
+IR_PrimitiveDef::_duplicate (IR_PrimitiveDef_ptr obj)
 {
   if (!CORBA::is_nil (obj))
     obj->_add_ref ();
   return obj;
 }
 
-CORBA::Boolean IR::EnumDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+CORBA::Boolean IR_PrimitiveDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
   if (
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EnumDef:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/PrimitiveDef:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
@@ -19335,58 +11540,34 @@
     return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
 }
 
-void *IR::EnumDef::_tao_QueryInterface (ptr_arith_t type)
+void *IR_PrimitiveDef::_tao_QueryInterface (ptr_arith_t type)
 {
   void *retv = 0;
   if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, EnumDef)::_narrow))
+      &IR_PrimitiveDef::_narrow))
     retv = ACE_reinterpret_cast (void*, this);
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, TypedefDef)::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            IR::TypedefDef_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Contained)::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            IR::Contained_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, IDLType)::_narrow))
+      &IR_IDLType::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::IDLType_ptr,
+            IR_IDLType_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
+      &CORBA_IRObject::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            CORBA::IRObject_ptr,
+            CORBA_IRObject_ptr,
             this
           )
       );
@@ -19399,181 +11580,49 @@
   return retv;
 }
 
-const char* IR::EnumDef::_interface_repository_id (void) const
+const char* IR_PrimitiveDef::_interface_repository_id (void) const
 {
-  return "IDL:omg.org/IR/EnumDef:1.0";
+  return "IDL:omg.org/IR/PrimitiveDef:1.0";
 }
 
-IR::EnumMemberSeq * IR::EnumDef::members (
+IR_PrimitiveKind IR_PrimitiveDef::kind (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-  return this->the_TAO_EnumDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).members (
+  return this->the_TAO_PrimitiveDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).kind (
       this,
       ACE_TRY_ENV
     );
 }
 
-void IR::EnumDef::members (
-    const IR::EnumMemberSeq & members,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  this->the_TAO_EnumDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).members (
-      this,
-      members,
-      ACE_TRY_ENV
-    );
-}
-
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-IR::EnumDef::TAO_ClientRequestInfo_IR_EnumDef_members_get::TAO_ClientRequestInfo_IR_EnumDef_members_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::EnumDef::TAO_ClientRequestInfo_IR_EnumDef_members_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::EnumDef::TAO_ClientRequestInfo_IR_EnumDef_members_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::EnumDef::TAO_ClientRequestInfo_IR_EnumDef_members_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::EnumDef::TAO_ClientRequestInfo_IR_EnumDef_members_get::result (IR::EnumMemberSeq * result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::EnumDef::TAO_ClientRequestInfo_IR_EnumDef_members_set::TAO_ClientRequestInfo_IR_EnumDef_members_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const IR::EnumMemberSeq & members,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    members_ (members)
-{}
-
-Dynamic::ParameterList *
-IR::EnumDef::TAO_ClientRequestInfo_IR_EnumDef_members_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_members = parameter_list->length ();
-  parameter_list->length (length_members + 1);
-  (*parameter_list)[length_members].argument <<=  this->members_;
-  
-  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::EnumDef::TAO_ClientRequestInfo_IR_EnumDef_members_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::EnumDef::TAO_ClientRequestInfo_IR_EnumDef_members_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
-}
-
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_EnumDef[] =
+static const CORBA::Long _oc_IR_PrimitiveDef[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
-  27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x6e756d44), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/EnumDef:1.0
-  8, ACE_NTOHL (0x456e756d), ACE_NTOHL (0x44656600),  // name = EnumDef
+  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x72696d69), ACE_NTOHL (0x74697665), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/PrimitiveDef:1.0
+  13, ACE_NTOHL (0x5072696d), ACE_NTOHL (0x69746976), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = IR_PrimitiveDef
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_EnumDef (CORBA::tk_objref, sizeof (_oc_IR_EnumDef), (char *) &_oc_IR_EnumDef, 0, sizeof (IR::EnumDef));
+static CORBA::TypeCode _tc_TAO_tc_IR_PrimitiveDef (CORBA::tk_objref, sizeof (_oc_IR_PrimitiveDef), (char *) &_oc_IR_PrimitiveDef, 0, sizeof (IR_PrimitiveDef));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EnumDef, &_tc_TAO_tc_IR_EnumDef)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PrimitiveDef, &_tc_TAO_tc_IR_PrimitiveDef)
 TAO_NAMESPACE_END
 
 ///////////////////////////////////////////////////////////////////////
 //                Base & Remote Proxy  Implementation. 
 //
 
-IR::_TAO_AliasDef_Proxy_Impl::_TAO_AliasDef_Proxy_Impl (void)
+_TAO_StringDef_Proxy_Impl::_TAO_StringDef_Proxy_Impl (void)
 {}
 
-IR::_TAO_AliasDef_Remote_Proxy_Impl::_TAO_AliasDef_Remote_Proxy_Impl (void)
+_TAO_StringDef_Remote_Proxy_Impl::_TAO_StringDef_Remote_Proxy_Impl (void)
 {}
 
 // Remote Implementation of the IDL interface methods
 
-IR::IDLType_ptr IR::_TAO_AliasDef_Remote_Proxy_Impl::original_type_def (
+CORBA::ULong _TAO_StringDef_Remote_Proxy_Impl::bound (
     CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -19581,308 +11630,124 @@
     CORBA::SystemException
   ))
 {
-  
-  IR::IDLType_ptr _tao_retval = IR::IDLType::_nil ();
-  IR::IDLType_var _tao_safe_retval (_tao_retval);
-  
+  CORBA::ULong _tao_retval = 0;
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
 
-  
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_get_original_type_def",
-      22,
+      "_get_bound",
+      10,
       0,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::AliasDef::TAO_ClientRequestInfo_IR_AliasDef_original_type_def_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::IDLType_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
+        ACE_CHECK_RETURN  (_tao_retval);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              _tao_retval
+            );
         }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_retval)
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                _tao_retval
+              );
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
+  return _tao_retval;
 }
 
-void IR::_TAO_AliasDef_Remote_Proxy_Impl::original_type_def (
+void _TAO_StringDef_Remote_Proxy_Impl::bound (
     CORBA_Object *_collocated_tao_target_,
-    IR::IDLType_ptr original_type_def,
+    CORBA::ULong bound,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-
-  
-  
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW (CORBA::INTERNAL ());
 
-  
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_set_original_type_def",
-      22,
+      "_set_bound",
+      10,
       1,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::AliasDef::TAO_ClientRequestInfo_IR_AliasDef_original_type_def_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        original_type_def,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << original_type_def)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << bound)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
       
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
         }
-      
-      break;
-    }
-  
+        
+        break;
+      }
 }
 
 
@@ -19895,32 +11760,32 @@
 //           Remote & Base  Proxy Broker Implementation
 //
 
-IR::_TAO_AliasDef_Proxy_Broker::_TAO_AliasDef_Proxy_Broker (void)
+_TAO_StringDef_Proxy_Broker::_TAO_StringDef_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_AliasDef_Proxy_Broker::~_TAO_AliasDef_Proxy_Broker (void)
+_TAO_StringDef_Proxy_Broker::~_TAO_StringDef_Proxy_Broker (void)
 {
 }
 
-// Factory Member function Implementation.
-IR::_TAO_AliasDef_Remote_Proxy_Broker *IR::_TAO_AliasDef_Remote_Proxy_Broker::the_TAO_AliasDef_Remote_Proxy_Broker (void)
+// Factory function Implementation.
+_TAO_StringDef_Remote_Proxy_Broker *the_TAO_StringDef_Remote_Proxy_Broker (void)
 {
-  static ::IR::_TAO_AliasDef_Remote_Proxy_Broker remote_proxy_broker;
+  static ::_TAO_StringDef_Remote_Proxy_Broker remote_proxy_broker;
   return &remote_proxy_broker;
 }
 
-IR::_TAO_AliasDef_Remote_Proxy_Broker::_TAO_AliasDef_Remote_Proxy_Broker (void)
+_TAO_StringDef_Remote_Proxy_Broker::_TAO_StringDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_AliasDef_Remote_Proxy_Broker::~_TAO_AliasDef_Remote_Proxy_Broker (void)
+_TAO_StringDef_Remote_Proxy_Broker::~_TAO_StringDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_AliasDef_Proxy_Impl&
-IR::_TAO_AliasDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::AliasDef *object,
+_TAO_StringDef_Proxy_Impl&
+_TAO_StringDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_StringDef *object,
   CORBA::Environment &ACE_TRY_ENV
 )
 {
@@ -19936,114 +11801,113 @@
 
 
 // default constructor
-IR::AliasDef::AliasDef (int collocated)
+IR_StringDef::IR_StringDef (int collocated)
 {
   this->_tao_setup_collocation (collocated);
 }
 
 // destructor
-IR::AliasDef::~AliasDef (void)
+IR_StringDef::~IR_StringDef (void)
 {}
 
 void
-IR::AliasDef::_tao_setup_collocation (int collocated)
+IR_StringDef::_tao_setup_collocation (int collocated)
 {
   if (collocated)
-    this->the_TAO_AliasDef_Proxy_Broker_ =
-      ::IR__TAO_AliasDef_Proxy_Broker_Factory_function_pointer (this);
+    this->the_TAO_StringDef_Proxy_Broker_ =
+      _TAO_StringDef_Proxy_Broker_Factory_function_pointer (this);
   else
-    this->the_TAO_AliasDef_Proxy_Broker_ =
-      ::IR::_TAO_AliasDef_Remote_Proxy_Broker::the_TAO_AliasDef_Remote_Proxy_Broker ();
+    this->the_TAO_StringDef_Proxy_Broker_ =
+      ::the_TAO_StringDef_Remote_Proxy_Broker ();
+  
+  IR_IDLType::_tao_setup_collocation (collocated);
   
-  ACE_NESTED_CLASS (IR, TypedefDef)::_tao_setup_collocation (collocated);
 }
 
-void IR::AliasDef::_tao_any_destructor (void *x)
+void IR_StringDef::_tao_any_destructor (void *x)
 {
-  AliasDef *tmp = ACE_static_cast (AliasDef*,x);
+  IR_StringDef *tmp = ACE_static_cast (IR_StringDef*,x);
   CORBA::release (tmp);
 }
 
-IR::AliasDef_ptr IR::AliasDef::_narrow (
+IR_StringDef_ptr IR_StringDef::_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
 {
   if (CORBA::is_nil (obj))
-    return AliasDef::_nil ();
+    return IR_StringDef::_nil ();
   if (! obj->_is_local ())
     {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/AliasDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (AliasDef::_nil ());
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/StringDef:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (IR_StringDef::_nil ());
       if (is_a == 0)
-        return AliasDef::_nil ();
+        return IR_StringDef::_nil ();
     }
-  return AliasDef::_unchecked_narrow (obj, ACE_TRY_ENV);
+  return IR_StringDef::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::AliasDef_ptr IR::AliasDef::_unchecked_narrow (
+IR_StringDef_ptr IR_StringDef::_unchecked_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &
   )
 {
   if (CORBA::is_nil (obj))
-    return AliasDef::_nil ();
+    return IR_StringDef::_nil ();
   if (! obj->_is_local ())
     {
       TAO_Stub* stub = obj->_stubobj ();
       if (stub)
         stub->_incr_refcnt ();
-      AliasDef_ptr default_proxy = AliasDef::_nil ();
+      IR_StringDef_ptr default_proxy = IR_StringDef::_nil ();
 
       if (
           !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
           stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_AliasDef_Proxy_Broker_Factory_function_pointer != 0
+          obj->_is_collocated () &&_TAO_StringDef_Proxy_Broker_Factory_function_pointer != 0
         )
       {
         ACE_NEW_RETURN (
           default_proxy,
-          ::IR::AliasDef (
+          ::IR_StringDef (
             stub,
             1,
             obj->_servant ()),
             
-          AliasDef::_nil ());
+          IR_StringDef::_nil ());
         }
       if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::AliasDef (stub, 0, obj->_servant ()), AliasDef::_nil ());
+        ACE_NEW_RETURN (default_proxy, ::IR_StringDef (stub, 0, obj->_servant ()), IR_StringDef::_nil ());
         return default_proxy;
       }
     else 
       return
         ACE_reinterpret_cast
           (
-            AliasDef_ptr,
+            IR_StringDef_ptr,
               obj->_tao_QueryInterface
                 (
                   ACE_reinterpret_cast
                     (
                       ptr_arith_t,
-                      &AliasDef::_narrow
+                      &IR_StringDef::_narrow
                     )
                 )
           );
 }
 
-IR::AliasDef_ptr
-IR::AliasDef::_duplicate (AliasDef_ptr obj)
+IR_StringDef_ptr
+IR_StringDef::_duplicate (IR_StringDef_ptr obj)
 {
   if (!CORBA::is_nil (obj))
     obj->_add_ref ();
   return obj;
 }
 
-CORBA::Boolean IR::AliasDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+CORBA::Boolean IR_StringDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
   if (
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/AliasDef:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/StringDef:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
@@ -20052,58 +11916,34 @@
     return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
 }
 
-void *IR::AliasDef::_tao_QueryInterface (ptr_arith_t type)
+void *IR_StringDef::_tao_QueryInterface (ptr_arith_t type)
 {
   void *retv = 0;
   if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, AliasDef)::_narrow))
+      &IR_StringDef::_narrow))
     retv = ACE_reinterpret_cast (void*, this);
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, TypedefDef)::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            IR::TypedefDef_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Contained)::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            IR::Contained_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, IDLType)::_narrow))
+      &IR_IDLType::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::IDLType_ptr,
+            IR_IDLType_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
+      &CORBA_IRObject::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            CORBA::IRObject_ptr,
+            CORBA_IRObject_ptr,
             this
           )
       );
@@ -20116,216 +11956,227 @@
   return retv;
 }
 
-const char* IR::AliasDef::_interface_repository_id (void) const
+const char* IR_StringDef::_interface_repository_id (void) const
 {
-  return "IDL:omg.org/IR/AliasDef:1.0";
+  return "IDL:omg.org/IR/StringDef:1.0";
 }
 
-IR::IDLType_ptr IR::AliasDef::original_type_def (
+CORBA::ULong IR_StringDef::bound (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-  return this->the_TAO_AliasDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).original_type_def (
+  return this->the_TAO_StringDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).bound (
       this,
       ACE_TRY_ENV
     );
 }
 
-void IR::AliasDef::original_type_def (
-    IR::IDLType_ptr original_type_def,
+void IR_StringDef::bound (
+    CORBA::ULong bound,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-  this->the_TAO_AliasDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).original_type_def (
+  this->the_TAO_StringDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).bound (
       this,
-      original_type_def,
+      bound,
       ACE_TRY_ENV
     );
 }
 
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-IR::AliasDef::TAO_ClientRequestInfo_IR_AliasDef_original_type_def_get::TAO_ClientRequestInfo_IR_AliasDef_original_type_def_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::AliasDef::TAO_ClientRequestInfo_IR_AliasDef_original_type_def_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::AliasDef::TAO_ClientRequestInfo_IR_AliasDef_original_type_def_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::AliasDef::TAO_ClientRequestInfo_IR_AliasDef_original_type_def_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::AliasDef::TAO_ClientRequestInfo_IR_AliasDef_original_type_def_get::result (IR::IDLType_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::AliasDef::TAO_ClientRequestInfo_IR_AliasDef_original_type_def_set::TAO_ClientRequestInfo_IR_AliasDef_original_type_def_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    IR::IDLType_ptr original_type_def,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    original_type_def_ (original_type_def)
-{}
-
-Dynamic::ParameterList *
-IR::AliasDef::TAO_ClientRequestInfo_IR_AliasDef_original_type_def_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_original_type_def = parameter_list->length ();
-  parameter_list->length (length_original_type_def + 1);
-  (*parameter_list)[length_original_type_def].argument <<=  this->original_type_def_;
-  
-  (*parameter_list)[length_original_type_def].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::AliasDef::TAO_ClientRequestInfo_IR_AliasDef_original_type_def_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::AliasDef::TAO_ClientRequestInfo_IR_AliasDef_original_type_def_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
-}
-
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_AliasDef[] =
+static const CORBA::Long _oc_IR_StringDef[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
-  28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x6c696173), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/AliasDef:1.0
-  9, ACE_NTOHL (0x416c6961), ACE_NTOHL (0x73446566), ACE_NTOHL (0x0),  // name = AliasDef
+  29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x7472696e), ACE_NTOHL (0x67446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/StringDef:1.0
+  10, ACE_NTOHL (0x53747269), ACE_NTOHL (0x6e674465), ACE_NTOHL (0x66000000),  // name = IR_StringDef
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_AliasDef (CORBA::tk_objref, sizeof (_oc_IR_AliasDef), (char *) &_oc_IR_AliasDef, 0, sizeof (IR::AliasDef));
+static CORBA::TypeCode _tc_TAO_tc_IR_StringDef (CORBA::tk_objref, sizeof (_oc_IR_StringDef), (char *) &_oc_IR_StringDef, 0, sizeof (IR_StringDef));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AliasDef, &_tc_TAO_tc_IR_AliasDef)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_StringDef, &_tc_TAO_tc_IR_StringDef)
 TAO_NAMESPACE_END
 
 ///////////////////////////////////////////////////////////////////////
 //                Base & Remote Proxy  Implementation. 
 //
 
-IR::_TAO_NativeDef_Proxy_Impl::_TAO_NativeDef_Proxy_Impl (void)
+_TAO_WstringDef_Proxy_Impl::_TAO_WstringDef_Proxy_Impl (void)
 {}
 
-IR::_TAO_NativeDef_Remote_Proxy_Impl::_TAO_NativeDef_Remote_Proxy_Impl (void)
+_TAO_WstringDef_Remote_Proxy_Impl::_TAO_WstringDef_Remote_Proxy_Impl (void)
 {}
 
 // Remote Implementation of the IDL interface methods
 
-
-//
-//            End  Base & Remote  Proxy Implemeentation. 
-///////////////////////////////////////////////////////////////////////
-
-
-///////////////////////////////////////////////////////////////////////
-//           Remote & Base  Proxy Broker Implementation
-//
-
-IR::_TAO_NativeDef_Proxy_Broker::_TAO_NativeDef_Proxy_Broker (void)
+CORBA::ULong _TAO_WstringDef_Remote_Proxy_Impl::bound (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-}
+  CORBA::ULong _tao_retval = 0;
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
 
-IR::_TAO_NativeDef_Proxy_Broker::~_TAO_NativeDef_Proxy_Broker (void)
-{
-}
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_bound",
+      10,
+      0,
+      istub->orb_core ()
+    );
 
-// Factory Member function Implementation.
-IR::_TAO_NativeDef_Remote_Proxy_Broker *IR::_TAO_NativeDef_Remote_Proxy_Broker::the_TAO_NativeDef_Remote_Proxy_Broker (void)
-{
-  static ::IR::_TAO_NativeDef_Remote_Proxy_Broker remote_proxy_broker;
-  return &remote_proxy_broker;
-}
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN  (_tao_retval);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              _tao_retval
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_retval)
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                _tao_retval
+              );
+          }
+        break;
+      }
+
+  return _tao_retval;
+}
+
+void _TAO_WstringDef_Remote_Proxy_Impl::bound (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::ULong bound,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW (CORBA::INTERNAL ());
+
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_set_bound",
+      10,
+      1,
+      istub->orb_core ()
+    );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << bound)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
+        }
+        
+        break;
+      }
+}
+
+
+//
+//            End  Base & Remote  Proxy Implemeentation. 
+///////////////////////////////////////////////////////////////////////
+
+
+///////////////////////////////////////////////////////////////////////
+//           Remote & Base  Proxy Broker Implementation
+//
+
+_TAO_WstringDef_Proxy_Broker::_TAO_WstringDef_Proxy_Broker (void)
+{
+}
+
+_TAO_WstringDef_Proxy_Broker::~_TAO_WstringDef_Proxy_Broker (void)
+{
+}
 
-IR::_TAO_NativeDef_Remote_Proxy_Broker::_TAO_NativeDef_Remote_Proxy_Broker (void)
+// Factory function Implementation.
+_TAO_WstringDef_Remote_Proxy_Broker *the_TAO_WstringDef_Remote_Proxy_Broker (void)
+{
+  static ::_TAO_WstringDef_Remote_Proxy_Broker remote_proxy_broker;
+  return &remote_proxy_broker;
+}
+
+_TAO_WstringDef_Remote_Proxy_Broker::_TAO_WstringDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_NativeDef_Remote_Proxy_Broker::~_TAO_NativeDef_Remote_Proxy_Broker (void)
+_TAO_WstringDef_Remote_Proxy_Broker::~_TAO_WstringDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_NativeDef_Proxy_Impl&
-IR::_TAO_NativeDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::NativeDef *object,
+_TAO_WstringDef_Proxy_Impl&
+_TAO_WstringDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_WstringDef *object,
   CORBA::Environment &ACE_TRY_ENV
 )
 {
@@ -20341,114 +12192,113 @@
 
 
 // default constructor
-IR::NativeDef::NativeDef (int collocated)
+IR_WstringDef::IR_WstringDef (int collocated)
 {
   this->_tao_setup_collocation (collocated);
 }
 
 // destructor
-IR::NativeDef::~NativeDef (void)
+IR_WstringDef::~IR_WstringDef (void)
 {}
 
 void
-IR::NativeDef::_tao_setup_collocation (int collocated)
+IR_WstringDef::_tao_setup_collocation (int collocated)
 {
   if (collocated)
-    this->the_TAO_NativeDef_Proxy_Broker_ =
-      ::IR__TAO_NativeDef_Proxy_Broker_Factory_function_pointer (this);
+    this->the_TAO_WstringDef_Proxy_Broker_ =
+      _TAO_WstringDef_Proxy_Broker_Factory_function_pointer (this);
   else
-    this->the_TAO_NativeDef_Proxy_Broker_ =
-      ::IR::_TAO_NativeDef_Remote_Proxy_Broker::the_TAO_NativeDef_Remote_Proxy_Broker ();
+    this->the_TAO_WstringDef_Proxy_Broker_ =
+      ::the_TAO_WstringDef_Remote_Proxy_Broker ();
+  
+  IR_IDLType::_tao_setup_collocation (collocated);
   
-  ACE_NESTED_CLASS (IR, TypedefDef)::_tao_setup_collocation (collocated);
 }
 
-void IR::NativeDef::_tao_any_destructor (void *x)
+void IR_WstringDef::_tao_any_destructor (void *x)
 {
-  NativeDef *tmp = ACE_static_cast (NativeDef*,x);
+  IR_WstringDef *tmp = ACE_static_cast (IR_WstringDef*,x);
   CORBA::release (tmp);
 }
 
-IR::NativeDef_ptr IR::NativeDef::_narrow (
+IR_WstringDef_ptr IR_WstringDef::_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
 {
   if (CORBA::is_nil (obj))
-    return NativeDef::_nil ();
+    return IR_WstringDef::_nil ();
   if (! obj->_is_local ())
     {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/NativeDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (NativeDef::_nil ());
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/WstringDef:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (IR_WstringDef::_nil ());
       if (is_a == 0)
-        return NativeDef::_nil ();
+        return IR_WstringDef::_nil ();
     }
-  return NativeDef::_unchecked_narrow (obj, ACE_TRY_ENV);
+  return IR_WstringDef::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::NativeDef_ptr IR::NativeDef::_unchecked_narrow (
+IR_WstringDef_ptr IR_WstringDef::_unchecked_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &
   )
 {
   if (CORBA::is_nil (obj))
-    return NativeDef::_nil ();
+    return IR_WstringDef::_nil ();
   if (! obj->_is_local ())
     {
       TAO_Stub* stub = obj->_stubobj ();
       if (stub)
         stub->_incr_refcnt ();
-      NativeDef_ptr default_proxy = NativeDef::_nil ();
+      IR_WstringDef_ptr default_proxy = IR_WstringDef::_nil ();
 
       if (
           !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
           stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_NativeDef_Proxy_Broker_Factory_function_pointer != 0
+          obj->_is_collocated () &&_TAO_WstringDef_Proxy_Broker_Factory_function_pointer != 0
         )
       {
         ACE_NEW_RETURN (
           default_proxy,
-          ::IR::NativeDef (
+          ::IR_WstringDef (
             stub,
             1,
             obj->_servant ()),
             
-          NativeDef::_nil ());
+          IR_WstringDef::_nil ());
         }
       if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::NativeDef (stub, 0, obj->_servant ()), NativeDef::_nil ());
+        ACE_NEW_RETURN (default_proxy, ::IR_WstringDef (stub, 0, obj->_servant ()), IR_WstringDef::_nil ());
         return default_proxy;
       }
     else 
       return
         ACE_reinterpret_cast
           (
-            NativeDef_ptr,
+            IR_WstringDef_ptr,
               obj->_tao_QueryInterface
                 (
                   ACE_reinterpret_cast
                     (
                       ptr_arith_t,
-                      &NativeDef::_narrow
+                      &IR_WstringDef::_narrow
                     )
                 )
           );
 }
 
-IR::NativeDef_ptr
-IR::NativeDef::_duplicate (NativeDef_ptr obj)
+IR_WstringDef_ptr
+IR_WstringDef::_duplicate (IR_WstringDef_ptr obj)
 {
   if (!CORBA::is_nil (obj))
     obj->_add_ref ();
   return obj;
 }
 
-CORBA::Boolean IR::NativeDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+CORBA::Boolean IR_WstringDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
   if (
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/NativeDef:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/WstringDef:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
@@ -20457,58 +12307,34 @@
     return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
 }
 
-void *IR::NativeDef::_tao_QueryInterface (ptr_arith_t type)
+void *IR_WstringDef::_tao_QueryInterface (ptr_arith_t type)
 {
   void *retv = 0;
   if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, NativeDef)::_narrow))
+      &IR_WstringDef::_narrow))
     retv = ACE_reinterpret_cast (void*, this);
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, TypedefDef)::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            IR::TypedefDef_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Contained)::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            IR::Contained_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, IDLType)::_narrow))
+      &IR_IDLType::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::IDLType_ptr,
+            IR_IDLType_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
+      &CORBA_IRObject::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            CORBA::IRObject_ptr,
+            CORBA_IRObject_ptr,
             this
           )
       );
@@ -20521,39 +12347,66 @@
   return retv;
 }
 
-const char* IR::NativeDef::_interface_repository_id (void) const
+const char* IR_WstringDef::_interface_repository_id (void) const
 {
-  return "IDL:omg.org/IR/NativeDef:1.0";
+  return "IDL:omg.org/IR/WstringDef:1.0";
 }
 
+CORBA::ULong IR_WstringDef::bound (
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  return this->the_TAO_WstringDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).bound (
+      this,
+      ACE_TRY_ENV
+    );
+}
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_NativeDef[] =
+void IR_WstringDef::bound (
+    CORBA::ULong bound,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  this->the_TAO_WstringDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).bound (
+      this,
+      bound,
+      ACE_TRY_ENV
+    );
+}
+
+static const CORBA::Long _oc_IR_WstringDef[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
-  29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4e), ACE_NTOHL (0x61746976), ACE_NTOHL (0x65446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/NativeDef:1.0
-  10, ACE_NTOHL (0x4e617469), ACE_NTOHL (0x76654465), ACE_NTOHL (0x66000000),  // name = NativeDef
+  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f57), ACE_NTOHL (0x73747269), ACE_NTOHL (0x6e674465), ACE_NTOHL (0x663a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/WstringDef:1.0
+  11, ACE_NTOHL (0x57737472), ACE_NTOHL (0x696e6744), ACE_NTOHL (0x65660000),  // name = IR_WstringDef
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_NativeDef (CORBA::tk_objref, sizeof (_oc_IR_NativeDef), (char *) &_oc_IR_NativeDef, 0, sizeof (IR::NativeDef));
+static CORBA::TypeCode _tc_TAO_tc_IR_WstringDef (CORBA::tk_objref, sizeof (_oc_IR_WstringDef), (char *) &_oc_IR_WstringDef, 0, sizeof (IR_WstringDef));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_NativeDef, &_tc_TAO_tc_IR_NativeDef)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_WstringDef, &_tc_TAO_tc_IR_WstringDef)
 TAO_NAMESPACE_END
 
 ///////////////////////////////////////////////////////////////////////
 //                Base & Remote Proxy  Implementation. 
 //
 
-IR::_TAO_PrimitiveDef_Proxy_Impl::_TAO_PrimitiveDef_Proxy_Impl (void)
+_TAO_FixedDef_Proxy_Impl::_TAO_FixedDef_Proxy_Impl (void)
 {}
 
-IR::_TAO_PrimitiveDef_Remote_Proxy_Impl::_TAO_PrimitiveDef_Remote_Proxy_Impl (void)
+_TAO_FixedDef_Remote_Proxy_Impl::_TAO_FixedDef_Remote_Proxy_Impl (void)
 {}
 
 // Remote Implementation of the IDL interface methods
 
-IR::PrimitiveKind IR::_TAO_PrimitiveDef_Remote_Proxy_Impl::kind (
+CORBA::UShort _TAO_FixedDef_Remote_Proxy_Impl::digits (
     CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -20562,7 +12415,7 @@
   ))
 {
   
-  IR::PrimitiveKind _tao_retval = (IR::PrimitiveKind)0;
+  CORBA::UShort _tao_retval = 0;
   
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
@@ -20572,183 +12425,287 @@
   
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_get_kind",
-      9,
+      "_get_digits",
+      11,
       0,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::PrimitiveDef::TAO_ClientRequestInfo_IR_PrimitiveDef_kind_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_retval)
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::PrimitiveKind  _tao_retval_info = _tao_retval;
-               ri.result (_tao_retval_info);
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
+        ACE_CHECK_RETURN  (_tao_retval);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              _tao_retval
+            );
         }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_retval)
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                _tao_retval
+              );
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_retval;
 }
 
-
-//
-//            End  Base & Remote  Proxy Implemeentation. 
-///////////////////////////////////////////////////////////////////////
-
-
-///////////////////////////////////////////////////////////////////////
-//           Remote & Base  Proxy Broker Implementation
-//
-
-IR::_TAO_PrimitiveDef_Proxy_Broker::_TAO_PrimitiveDef_Proxy_Broker (void)
+void _TAO_FixedDef_Remote_Proxy_Impl::digits (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::UShort digits,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-}
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW (CORBA::INTERNAL ());
 
-IR::_TAO_PrimitiveDef_Proxy_Broker::~_TAO_PrimitiveDef_Proxy_Broker (void)
-{
-}
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_set_digits",
+      11,
+      1,
+      istub->orb_core ()
+    );
 
-// Factory Member function Implementation.
-IR::_TAO_PrimitiveDef_Remote_Proxy_Broker *IR::_TAO_PrimitiveDef_Remote_Proxy_Broker::the_TAO_PrimitiveDef_Remote_Proxy_Broker (void)
-{
-  static ::IR::_TAO_PrimitiveDef_Remote_Proxy_Broker remote_proxy_broker;
-  return &remote_proxy_broker;
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << digits)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
+        }
+        
+        break;
+      }
 }
 
-IR::_TAO_PrimitiveDef_Remote_Proxy_Broker::_TAO_PrimitiveDef_Remote_Proxy_Broker (void)
+CORBA::Short _TAO_FixedDef_Remote_Proxy_Impl::scale (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-}
+  
+  CORBA::Short _tao_retval = 0;
+  
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
 
-IR::_TAO_PrimitiveDef_Remote_Proxy_Broker::~_TAO_PrimitiveDef_Remote_Proxy_Broker (void)
-{
-}
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_scale",
+      10,
+      0,
+      istub->orb_core ()
+    );
 
-IR::_TAO_PrimitiveDef_Proxy_Impl&
-IR::_TAO_PrimitiveDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::PrimitiveDef *object,
-  CORBA::Environment &ACE_TRY_ENV
-)
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN  (_tao_retval);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              _tao_retval
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_retval)
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                _tao_retval
+              );
+          }
+        break;
+      }
+
+  return _tao_retval;
+}
+
+void _TAO_FixedDef_Remote_Proxy_Impl::scale (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::Short scale,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW (CORBA::INTERNAL ());
+
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_set_scale",
+      10,
+      1,
+      istub->orb_core ()
+    );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << scale)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
+        }
+        
+        break;
+      }
+}
+
+
+//
+//            End  Base & Remote  Proxy Implemeentation. 
+///////////////////////////////////////////////////////////////////////
+
+
+///////////////////////////////////////////////////////////////////////
+//           Remote & Base  Proxy Broker Implementation
+//
+
+_TAO_FixedDef_Proxy_Broker::_TAO_FixedDef_Proxy_Broker (void)
+{
+}
+
+_TAO_FixedDef_Proxy_Broker::~_TAO_FixedDef_Proxy_Broker (void)
+{
+}
+
+// Factory function Implementation.
+_TAO_FixedDef_Remote_Proxy_Broker *the_TAO_FixedDef_Remote_Proxy_Broker (void)
+{
+  static ::_TAO_FixedDef_Remote_Proxy_Broker remote_proxy_broker;
+  return &remote_proxy_broker;
+}
+
+_TAO_FixedDef_Remote_Proxy_Broker::_TAO_FixedDef_Remote_Proxy_Broker (void)
+{
+}
+
+_TAO_FixedDef_Remote_Proxy_Broker::~_TAO_FixedDef_Remote_Proxy_Broker (void)
+{
+}
+
+_TAO_FixedDef_Proxy_Impl&
+_TAO_FixedDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_FixedDef *object,
+  CORBA::Environment &ACE_TRY_ENV
+)
 {
   ACE_UNUSED_ARG (object);
   ACE_UNUSED_ARG (ACE_TRY_ENV);
@@ -20762,112 +12719,113 @@
 
 
 // default constructor
-IR::PrimitiveDef::PrimitiveDef (int collocated)
+IR_FixedDef::IR_FixedDef (int collocated)
 {
   this->_tao_setup_collocation (collocated);
 }
 
 // destructor
-IR::PrimitiveDef::~PrimitiveDef (void)
+IR_FixedDef::~IR_FixedDef (void)
 {}
 
 void
-IR::PrimitiveDef::_tao_setup_collocation (int collocated)
+IR_FixedDef::_tao_setup_collocation (int collocated)
 {
   if (collocated)
-    this->the_TAO_PrimitiveDef_Proxy_Broker_ =
-      ::IR__TAO_PrimitiveDef_Proxy_Broker_Factory_function_pointer (this);
+    this->the_TAO_FixedDef_Proxy_Broker_ =
+      _TAO_FixedDef_Proxy_Broker_Factory_function_pointer (this);
   else
-    this->the_TAO_PrimitiveDef_Proxy_Broker_ =
-      ::IR::_TAO_PrimitiveDef_Remote_Proxy_Broker::the_TAO_PrimitiveDef_Remote_Proxy_Broker ();
+    this->the_TAO_FixedDef_Proxy_Broker_ =
+      ::the_TAO_FixedDef_Remote_Proxy_Broker ();
+  
+  IR_IDLType::_tao_setup_collocation (collocated);
   
-  ACE_NESTED_CLASS (IR, IDLType)::_tao_setup_collocation (collocated);
 }
 
-void IR::PrimitiveDef::_tao_any_destructor (void *x)
+void IR_FixedDef::_tao_any_destructor (void *x)
 {
-  PrimitiveDef *tmp = ACE_static_cast (PrimitiveDef*,x);
+  IR_FixedDef *tmp = ACE_static_cast (IR_FixedDef*,x);
   CORBA::release (tmp);
 }
 
-IR::PrimitiveDef_ptr IR::PrimitiveDef::_narrow (
+IR_FixedDef_ptr IR_FixedDef::_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
 {
   if (CORBA::is_nil (obj))
-    return PrimitiveDef::_nil ();
+    return IR_FixedDef::_nil ();
   if (! obj->_is_local ())
     {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/PrimitiveDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (PrimitiveDef::_nil ());
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/FixedDef:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (IR_FixedDef::_nil ());
       if (is_a == 0)
-        return PrimitiveDef::_nil ();
+        return IR_FixedDef::_nil ();
     }
-  return PrimitiveDef::_unchecked_narrow (obj, ACE_TRY_ENV);
+  return IR_FixedDef::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::PrimitiveDef_ptr IR::PrimitiveDef::_unchecked_narrow (
+IR_FixedDef_ptr IR_FixedDef::_unchecked_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &
   )
 {
   if (CORBA::is_nil (obj))
-    return PrimitiveDef::_nil ();
+    return IR_FixedDef::_nil ();
   if (! obj->_is_local ())
     {
       TAO_Stub* stub = obj->_stubobj ();
       if (stub)
         stub->_incr_refcnt ();
-      PrimitiveDef_ptr default_proxy = PrimitiveDef::_nil ();
+      IR_FixedDef_ptr default_proxy = IR_FixedDef::_nil ();
 
       if (
           !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
           stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_PrimitiveDef_Proxy_Broker_Factory_function_pointer != 0
+          obj->_is_collocated () &&_TAO_FixedDef_Proxy_Broker_Factory_function_pointer != 0
         )
       {
         ACE_NEW_RETURN (
           default_proxy,
-          ::IR::PrimitiveDef (
+          ::IR_FixedDef (
             stub,
             1,
             obj->_servant ()),
             
-          PrimitiveDef::_nil ());
+          IR_FixedDef::_nil ());
         }
       if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::PrimitiveDef (stub, 0, obj->_servant ()), PrimitiveDef::_nil ());
+        ACE_NEW_RETURN (default_proxy, ::IR_FixedDef (stub, 0, obj->_servant ()), IR_FixedDef::_nil ());
         return default_proxy;
       }
     else 
       return
         ACE_reinterpret_cast
           (
-            PrimitiveDef_ptr,
+            IR_FixedDef_ptr,
               obj->_tao_QueryInterface
                 (
                   ACE_reinterpret_cast
                     (
                       ptr_arith_t,
-                      &PrimitiveDef::_narrow
+                      &IR_FixedDef::_narrow
                     )
                 )
           );
 }
 
-IR::PrimitiveDef_ptr
-IR::PrimitiveDef::_duplicate (PrimitiveDef_ptr obj)
+IR_FixedDef_ptr
+IR_FixedDef::_duplicate (IR_FixedDef_ptr obj)
 {
   if (!CORBA::is_nil (obj))
     obj->_add_ref ();
   return obj;
 }
 
-CORBA::Boolean IR::PrimitiveDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+CORBA::Boolean IR_FixedDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
   if (
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/PrimitiveDef:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/FixedDef:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
@@ -20876,34 +12834,34 @@
     return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
 }
 
-void *IR::PrimitiveDef::_tao_QueryInterface (ptr_arith_t type)
+void *IR_FixedDef::_tao_QueryInterface (ptr_arith_t type)
 {
   void *retv = 0;
   if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, PrimitiveDef)::_narrow))
+      &IR_FixedDef::_narrow))
     retv = ACE_reinterpret_cast (void*, this);
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, IDLType)::_narrow))
+      &IR_IDLType::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::IDLType_ptr,
+            IR_IDLType_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
+      &CORBA_IRObject::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            CORBA::IRObject_ptr,
+            CORBA_IRObject_ptr,
             this
           )
       );
@@ -20916,12 +12874,12 @@
   return retv;
 }
 
-const char* IR::PrimitiveDef::_interface_repository_id (void) const
+const char* IR_FixedDef::_interface_repository_id (void) const
 {
-  return "IDL:omg.org/IR/PrimitiveDef:1.0";
+  return "IDL:omg.org/IR/FixedDef:1.0";
 }
 
-IR::PrimitiveKind IR::PrimitiveDef::kind (
+CORBA::UShort IR_FixedDef::digits (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -20929,96 +12887,83 @@
   ))
 {
   
-  return this->the_TAO_PrimitiveDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).kind (
+  return this->the_TAO_FixedDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).digits (
       this,
       ACE_TRY_ENV
     );
 }
 
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-IR::PrimitiveDef::TAO_ClientRequestInfo_IR_PrimitiveDef_kind_get::TAO_ClientRequestInfo_IR_PrimitiveDef_kind_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
+void IR_FixedDef::digits (
+    CORBA::UShort digits,
+    CORBA::Environment &ACE_TRY_ENV
   )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::PrimitiveDef::TAO_ClientRequestInfo_IR_PrimitiveDef_kind_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
   
-  return parameter_list;
+  this->the_TAO_FixedDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).digits (
+      this,
+      digits,
+      ACE_TRY_ENV
+    );
 }
 
-Dynamic::ExceptionList *
-IR::PrimitiveDef::TAO_ClientRequestInfo_IR_PrimitiveDef_kind_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+CORBA::Short IR_FixedDef::scale (
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
   
-  return exception_list;
+  return this->the_TAO_FixedDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).scale (
+      this,
+      ACE_TRY_ENV
+    );
 }
 
-
-CORBA::Any * 
-IR::PrimitiveDef::TAO_ClientRequestInfo_IR_PrimitiveDef_kind_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+void IR_FixedDef::scale (
+    CORBA::Short scale,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
   
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::PrimitiveDef::TAO_ClientRequestInfo_IR_PrimitiveDef_kind_get::result (IR::PrimitiveKind result)
-{
-  // update the result 
-  this->_result = result;
+  this->the_TAO_FixedDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).scale (
+      this,
+      scale,
+      ACE_TRY_ENV
+    );
 }
 
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_PrimitiveDef[] =
+static const CORBA::Long _oc_IR_FixedDef[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
-  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x72696d69), ACE_NTOHL (0x74697665), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/PrimitiveDef:1.0
-  13, ACE_NTOHL (0x5072696d), ACE_NTOHL (0x69746976), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = PrimitiveDef
+  28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x69786564), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/FixedDef:1.0
+  9, ACE_NTOHL (0x46697865), ACE_NTOHL (0x64446566), ACE_NTOHL (0x0),  // name = IR_FixedDef
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_PrimitiveDef (CORBA::tk_objref, sizeof (_oc_IR_PrimitiveDef), (char *) &_oc_IR_PrimitiveDef, 0, sizeof (IR::PrimitiveDef));
+static CORBA::TypeCode _tc_TAO_tc_IR_FixedDef (CORBA::tk_objref, sizeof (_oc_IR_FixedDef), (char *) &_oc_IR_FixedDef, 0, sizeof (IR_FixedDef));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PrimitiveDef, &_tc_TAO_tc_IR_PrimitiveDef)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FixedDef, &_tc_TAO_tc_IR_FixedDef)
 TAO_NAMESPACE_END
 
 ///////////////////////////////////////////////////////////////////////
 //                Base & Remote Proxy  Implementation. 
 //
 
-IR::_TAO_StringDef_Proxy_Impl::_TAO_StringDef_Proxy_Impl (void)
+_TAO_SequenceDef_Proxy_Impl::_TAO_SequenceDef_Proxy_Impl (void)
 {}
 
-IR::_TAO_StringDef_Remote_Proxy_Impl::_TAO_StringDef_Remote_Proxy_Impl (void)
+_TAO_SequenceDef_Remote_Proxy_Impl::_TAO_SequenceDef_Remote_Proxy_Impl (void)
 {}
 
 // Remote Implementation of the IDL interface methods
 
-CORBA::ULong IR::_TAO_StringDef_Remote_Proxy_Impl::bound (
+CORBA::ULong _TAO_SequenceDef_Remote_Proxy_Impl::bound (
     CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -21043,140 +12988,51 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::StringDef::TAO_ClientRequestInfo_IR_StringDef_bound_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_retval)
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              CORBA::ULong  _tao_retval_info = _tao_retval;
-               ri.result (_tao_retval_info);
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
+        ACE_CHECK_RETURN  (_tao_retval);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              _tao_retval
+            );
         }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_retval)
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                _tao_retval
+              );
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_retval;
 }
 
-void IR::_TAO_StringDef_Remote_Proxy_Impl::bound (
+void _TAO_SequenceDef_Remote_Proxy_Impl::bound (
     CORBA_Object *_collocated_tao_target_,
     CORBA::ULong bound,
     CORBA::Environment &ACE_TRY_ENV
@@ -21185,15 +13041,10 @@
     CORBA::SystemException
   ))
 {
-  
-
-  
-  
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW (CORBA::INTERNAL ());
 
-  
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
       "_set_bound",
@@ -21202,168 +13053,285 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::StringDef::TAO_ClientRequestInfo_IR_StringDef_bound_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        bound,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << bound)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << bound)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
       
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
         }
-      
-      break;
-    }
-  
-}
-
-
-//
-//            End  Base & Remote  Proxy Implemeentation. 
-///////////////////////////////////////////////////////////////////////
-
-
-///////////////////////////////////////////////////////////////////////
-//           Remote & Base  Proxy Broker Implementation
-//
-
-IR::_TAO_StringDef_Proxy_Broker::_TAO_StringDef_Proxy_Broker (void)
-{
-}
-
-IR::_TAO_StringDef_Proxy_Broker::~_TAO_StringDef_Proxy_Broker (void)
-{
+        
+        break;
+      }
 }
 
-// Factory Member function Implementation.
-IR::_TAO_StringDef_Remote_Proxy_Broker *IR::_TAO_StringDef_Remote_Proxy_Broker::the_TAO_StringDef_Remote_Proxy_Broker (void)
+CORBA::TypeCode_ptr _TAO_SequenceDef_Remote_Proxy_Impl::element_type (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  static ::IR::_TAO_StringDef_Remote_Proxy_Broker remote_proxy_broker;
-  return &remote_proxy_broker;
-}
+  
+  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
+  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
+  
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-IR::_TAO_StringDef_Remote_Proxy_Broker::_TAO_StringDef_Remote_Proxy_Broker (void)
-{
-}
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_element_type",
+      17,
+      0,
+      istub->orb_core ()
+    );
 
-IR::_TAO_StringDef_Remote_Proxy_Broker::~_TAO_StringDef_Remote_Proxy_Broker (void)
-{
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
+
+  return _tao_safe_retval._retn ();
+}
+
+IR_IDLType_ptr _TAO_SequenceDef_Remote_Proxy_Impl::element_type_def (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  IR_IDLType_ptr _tao_retval = IR_IDLType::_nil ();
+  IR_IDLType_var _tao_safe_retval (_tao_retval);
+  
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_element_type_def",
+      21,
+      0,
+      istub->orb_core ()
+    );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
+
+  return _tao_safe_retval._retn ();
+}
+
+void _TAO_SequenceDef_Remote_Proxy_Impl::element_type_def (
+    CORBA_Object *_collocated_tao_target_,
+    IR_IDLType_ptr element_type_def,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW (CORBA::INTERNAL ());
+
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_set_element_type_def",
+      21,
+      1,
+      istub->orb_core ()
+    );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << element_type_def)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
+        }
+        
+        break;
+      }
+}
+
+
+//
+//            End  Base & Remote  Proxy Implemeentation. 
+///////////////////////////////////////////////////////////////////////
+
+
+///////////////////////////////////////////////////////////////////////
+//           Remote & Base  Proxy Broker Implementation
+//
+
+_TAO_SequenceDef_Proxy_Broker::_TAO_SequenceDef_Proxy_Broker (void)
+{
+}
+
+_TAO_SequenceDef_Proxy_Broker::~_TAO_SequenceDef_Proxy_Broker (void)
+{
+}
+
+// Factory function Implementation.
+_TAO_SequenceDef_Remote_Proxy_Broker *the_TAO_SequenceDef_Remote_Proxy_Broker (void)
+{
+  static ::_TAO_SequenceDef_Remote_Proxy_Broker remote_proxy_broker;
+  return &remote_proxy_broker;
+}
+
+_TAO_SequenceDef_Remote_Proxy_Broker::_TAO_SequenceDef_Remote_Proxy_Broker (void)
+{
 }
 
-IR::_TAO_StringDef_Proxy_Impl&
-IR::_TAO_StringDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::StringDef *object,
+_TAO_SequenceDef_Remote_Proxy_Broker::~_TAO_SequenceDef_Remote_Proxy_Broker (void)
+{
+}
+
+_TAO_SequenceDef_Proxy_Impl&
+_TAO_SequenceDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_SequenceDef *object,
   CORBA::Environment &ACE_TRY_ENV
 )
 {
@@ -21379,112 +13347,113 @@
 
 
 // default constructor
-IR::StringDef::StringDef (int collocated)
+IR_SequenceDef::IR_SequenceDef (int collocated)
 {
   this->_tao_setup_collocation (collocated);
 }
 
 // destructor
-IR::StringDef::~StringDef (void)
+IR_SequenceDef::~IR_SequenceDef (void)
 {}
 
 void
-IR::StringDef::_tao_setup_collocation (int collocated)
+IR_SequenceDef::_tao_setup_collocation (int collocated)
 {
   if (collocated)
-    this->the_TAO_StringDef_Proxy_Broker_ =
-      ::IR__TAO_StringDef_Proxy_Broker_Factory_function_pointer (this);
+    this->the_TAO_SequenceDef_Proxy_Broker_ =
+      _TAO_SequenceDef_Proxy_Broker_Factory_function_pointer (this);
   else
-    this->the_TAO_StringDef_Proxy_Broker_ =
-      ::IR::_TAO_StringDef_Remote_Proxy_Broker::the_TAO_StringDef_Remote_Proxy_Broker ();
+    this->the_TAO_SequenceDef_Proxy_Broker_ =
+      ::the_TAO_SequenceDef_Remote_Proxy_Broker ();
+  
+  IR_IDLType::_tao_setup_collocation (collocated);
   
-  ACE_NESTED_CLASS (IR, IDLType)::_tao_setup_collocation (collocated);
 }
 
-void IR::StringDef::_tao_any_destructor (void *x)
+void IR_SequenceDef::_tao_any_destructor (void *x)
 {
-  StringDef *tmp = ACE_static_cast (StringDef*,x);
+  IR_SequenceDef *tmp = ACE_static_cast (IR_SequenceDef*,x);
   CORBA::release (tmp);
 }
 
-IR::StringDef_ptr IR::StringDef::_narrow (
+IR_SequenceDef_ptr IR_SequenceDef::_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
 {
   if (CORBA::is_nil (obj))
-    return StringDef::_nil ();
+    return IR_SequenceDef::_nil ();
   if (! obj->_is_local ())
     {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/StringDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (StringDef::_nil ());
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/SequenceDef:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (IR_SequenceDef::_nil ());
       if (is_a == 0)
-        return StringDef::_nil ();
+        return IR_SequenceDef::_nil ();
     }
-  return StringDef::_unchecked_narrow (obj, ACE_TRY_ENV);
+  return IR_SequenceDef::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::StringDef_ptr IR::StringDef::_unchecked_narrow (
+IR_SequenceDef_ptr IR_SequenceDef::_unchecked_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &
   )
 {
   if (CORBA::is_nil (obj))
-    return StringDef::_nil ();
+    return IR_SequenceDef::_nil ();
   if (! obj->_is_local ())
     {
       TAO_Stub* stub = obj->_stubobj ();
       if (stub)
         stub->_incr_refcnt ();
-      StringDef_ptr default_proxy = StringDef::_nil ();
+      IR_SequenceDef_ptr default_proxy = IR_SequenceDef::_nil ();
 
       if (
           !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
           stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_StringDef_Proxy_Broker_Factory_function_pointer != 0
+          obj->_is_collocated () &&_TAO_SequenceDef_Proxy_Broker_Factory_function_pointer != 0
         )
       {
         ACE_NEW_RETURN (
           default_proxy,
-          ::IR::StringDef (
+          ::IR_SequenceDef (
             stub,
             1,
             obj->_servant ()),
             
-          StringDef::_nil ());
+          IR_SequenceDef::_nil ());
         }
       if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::StringDef (stub, 0, obj->_servant ()), StringDef::_nil ());
+        ACE_NEW_RETURN (default_proxy, ::IR_SequenceDef (stub, 0, obj->_servant ()), IR_SequenceDef::_nil ());
         return default_proxy;
       }
     else 
       return
         ACE_reinterpret_cast
           (
-            StringDef_ptr,
+            IR_SequenceDef_ptr,
               obj->_tao_QueryInterface
                 (
                   ACE_reinterpret_cast
                     (
                       ptr_arith_t,
-                      &StringDef::_narrow
+                      &IR_SequenceDef::_narrow
                     )
                 )
           );
 }
 
-IR::StringDef_ptr
-IR::StringDef::_duplicate (StringDef_ptr obj)
+IR_SequenceDef_ptr
+IR_SequenceDef::_duplicate (IR_SequenceDef_ptr obj)
 {
   if (!CORBA::is_nil (obj))
     obj->_add_ref ();
   return obj;
 }
 
-CORBA::Boolean IR::StringDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+CORBA::Boolean IR_SequenceDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
   if (
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/StringDef:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/SequenceDef:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
@@ -21493,34 +13462,34 @@
     return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
 }
 
-void *IR::StringDef::_tao_QueryInterface (ptr_arith_t type)
+void *IR_SequenceDef::_tao_QueryInterface (ptr_arith_t type)
 {
   void *retv = 0;
   if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, StringDef)::_narrow))
+      &IR_SequenceDef::_narrow))
     retv = ACE_reinterpret_cast (void*, this);
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, IDLType)::_narrow))
+      &IR_IDLType::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::IDLType_ptr,
+            IR_IDLType_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
+      &CORBA_IRObject::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            CORBA::IRObject_ptr,
+            CORBA_IRObject_ptr,
             this
           )
       );
@@ -21533,12 +13502,12 @@
   return retv;
 }
 
-const char* IR::StringDef::_interface_repository_id (void) const
+const char* IR_SequenceDef::_interface_repository_id (void) const
 {
-  return "IDL:omg.org/IR/StringDef:1.0";
+  return "IDL:omg.org/IR/SequenceDef:1.0";
 }
 
-CORBA::ULong IR::StringDef::bound (
+CORBA::ULong IR_SequenceDef::bound (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -21546,13 +13515,13 @@
   ))
 {
   
-  return this->the_TAO_StringDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).bound (
+  return this->the_TAO_SequenceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).bound (
       this,
       ACE_TRY_ENV
     );
 }
 
-void IR::StringDef::bound (
+void IR_SequenceDef::bound (
     CORBA::ULong bound,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -21561,152 +13530,82 @@
   ))
 {
   
-  this->the_TAO_StringDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).bound (
+  this->the_TAO_SequenceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).bound (
       this,
       bound,
       ACE_TRY_ENV
     );
 }
 
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-IR::StringDef::TAO_ClientRequestInfo_IR_StringDef_bound_get::TAO_ClientRequestInfo_IR_StringDef_bound_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
+CORBA::TypeCode_ptr IR_SequenceDef::element_type (
+    CORBA::Environment &ACE_TRY_ENV
   )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::StringDef::TAO_ClientRequestInfo_IR_StringDef_bound_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::StringDef::TAO_ClientRequestInfo_IR_StringDef_bound_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::StringDef::TAO_ClientRequestInfo_IR_StringDef_bound_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
   
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::StringDef::TAO_ClientRequestInfo_IR_StringDef_bound_get::result (CORBA::ULong result)
-{
-  // update the result 
-  this->_result = result;
+  return this->the_TAO_SequenceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).element_type (
+      this,
+      ACE_TRY_ENV
+    );
 }
 
-IR::StringDef::TAO_ClientRequestInfo_IR_StringDef_bound_set::TAO_ClientRequestInfo_IR_StringDef_bound_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const CORBA::ULong & bound,
-    CORBA::Environment &    
+IR_IDLType_ptr IR_SequenceDef::element_type_def (
+    CORBA::Environment &ACE_TRY_ENV
   )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    bound_ (bound)
-{}
-
-Dynamic::ParameterList *
-IR::StringDef::TAO_ClientRequestInfo_IR_StringDef_bound_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_bound = parameter_list->length ();
-  parameter_list->length (length_bound + 1);
-  (*parameter_list)[length_bound].argument <<= bound_;
-  (*parameter_list)[length_bound].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::StringDef::TAO_ClientRequestInfo_IR_StringDef_bound_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
   
-  return exception_list;
+  return this->the_TAO_SequenceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).element_type_def (
+      this,
+      ACE_TRY_ENV
+    );
 }
 
-
-CORBA::Any * 
-IR::StringDef::TAO_ClientRequestInfo_IR_StringDef_bound_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+void IR_SequenceDef::element_type_def (
+    IR_IDLType_ptr element_type_def,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
   
-  return result_any;
+  this->the_TAO_SequenceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).element_type_def (
+      this,
+      element_type_def,
+      ACE_TRY_ENV
+    );
 }
 
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_StringDef[] =
+static const CORBA::Long _oc_IR_SequenceDef[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
-  29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x7472696e), ACE_NTOHL (0x67446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/StringDef:1.0
-  10, ACE_NTOHL (0x53747269), ACE_NTOHL (0x6e674465), ACE_NTOHL (0x66000000),  // name = StringDef
+  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x65717565), ACE_NTOHL (0x6e636544), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/SequenceDef:1.0
+  12, ACE_NTOHL (0x53657175), ACE_NTOHL (0x656e6365), ACE_NTOHL (0x44656600),  // name = IR_SequenceDef
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_StringDef (CORBA::tk_objref, sizeof (_oc_IR_StringDef), (char *) &_oc_IR_StringDef, 0, sizeof (IR::StringDef));
+static CORBA::TypeCode _tc_TAO_tc_IR_SequenceDef (CORBA::tk_objref, sizeof (_oc_IR_SequenceDef), (char *) &_oc_IR_SequenceDef, 0, sizeof (IR_SequenceDef));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_StringDef, &_tc_TAO_tc_IR_StringDef)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_SequenceDef, &_tc_TAO_tc_IR_SequenceDef)
 TAO_NAMESPACE_END
 
 ///////////////////////////////////////////////////////////////////////
 //                Base & Remote Proxy  Implementation. 
 //
 
-IR::_TAO_WstringDef_Proxy_Impl::_TAO_WstringDef_Proxy_Impl (void)
+_TAO_ArrayDef_Proxy_Impl::_TAO_ArrayDef_Proxy_Impl (void)
 {}
 
-IR::_TAO_WstringDef_Remote_Proxy_Impl::_TAO_WstringDef_Remote_Proxy_Impl (void)
+_TAO_ArrayDef_Remote_Proxy_Impl::_TAO_ArrayDef_Remote_Proxy_Impl (void)
 {}
 
 // Remote Implementation of the IDL interface methods
 
-CORBA::ULong IR::_TAO_WstringDef_Remote_Proxy_Impl::bound (
+CORBA::ULong _TAO_ArrayDef_Remote_Proxy_Impl::length (
     CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -21725,295 +13624,318 @@
   
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_get_bound",
-      10,
+      "_get_length",
+      11,
       0,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::WstringDef::TAO_ClientRequestInfo_IR_WstringDef_bound_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_retval)
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              CORBA::ULong  _tao_retval_info = _tao_retval;
-               ri.result (_tao_retval_info);
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
+        ACE_CHECK_RETURN  (_tao_retval);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              _tao_retval
+            );
         }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_retval)
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                _tao_retval
+              );
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_retval;
 }
 
-void IR::_TAO_WstringDef_Remote_Proxy_Impl::bound (
+void _TAO_ArrayDef_Remote_Proxy_Impl::length (
     CORBA_Object *_collocated_tao_target_,
-    CORBA::ULong bound,
+    CORBA::ULong length,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-
-  
-  
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW (CORBA::INTERNAL ());
 
-  
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_set_bound",
-      10,
+      "_set_length",
+      11,
       1,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::WstringDef::TAO_ClientRequestInfo_IR_WstringDef_bound_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        bound,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << bound)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << length)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
+        }
+        
+        break;
+      }
+}
+
+CORBA::TypeCode_ptr _TAO_ArrayDef_Remote_Proxy_Impl::element_type (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
+  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
+  
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_element_type",
+      17,
+      0,
+      istub->orb_core ()
+    );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
         }
-      ACE_ENDTRY;
-      ACE_CHECK;
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
+
+  return _tao_safe_retval._retn ();
+}
+
+IR_IDLType_ptr _TAO_ArrayDef_Remote_Proxy_Impl::element_type_def (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  IR_IDLType_ptr _tao_retval = IR_IDLType::_nil ();
+  IR_IDLType_var _tao_safe_retval (_tao_retval);
+  
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_element_type_def",
+      21,
+      0,
+      istub->orb_core ()
+    );
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
         }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
+
+  return _tao_safe_retval._retn ();
+}
+
+void _TAO_ArrayDef_Remote_Proxy_Impl::element_type_def (
+    CORBA_Object *_collocated_tao_target_,
+    IR_IDLType_ptr element_type_def,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW (CORBA::INTERNAL ());
+
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_set_element_type_def",
+      21,
+      1,
+      istub->orb_core ()
+    );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << element_type_def)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
+          );
       
-      break;
-    }
-  
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
+        }
+        
+        break;
+      }
 }
 
 
@@ -22026,32 +13948,32 @@
 //           Remote & Base  Proxy Broker Implementation
 //
 
-IR::_TAO_WstringDef_Proxy_Broker::_TAO_WstringDef_Proxy_Broker (void)
+_TAO_ArrayDef_Proxy_Broker::_TAO_ArrayDef_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_WstringDef_Proxy_Broker::~_TAO_WstringDef_Proxy_Broker (void)
+_TAO_ArrayDef_Proxy_Broker::~_TAO_ArrayDef_Proxy_Broker (void)
 {
 }
 
-// Factory Member function Implementation.
-IR::_TAO_WstringDef_Remote_Proxy_Broker *IR::_TAO_WstringDef_Remote_Proxy_Broker::the_TAO_WstringDef_Remote_Proxy_Broker (void)
+// Factory function Implementation.
+_TAO_ArrayDef_Remote_Proxy_Broker *the_TAO_ArrayDef_Remote_Proxy_Broker (void)
 {
-  static ::IR::_TAO_WstringDef_Remote_Proxy_Broker remote_proxy_broker;
+  static ::_TAO_ArrayDef_Remote_Proxy_Broker remote_proxy_broker;
   return &remote_proxy_broker;
 }
 
-IR::_TAO_WstringDef_Remote_Proxy_Broker::_TAO_WstringDef_Remote_Proxy_Broker (void)
+_TAO_ArrayDef_Remote_Proxy_Broker::_TAO_ArrayDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_WstringDef_Remote_Proxy_Broker::~_TAO_WstringDef_Remote_Proxy_Broker (void)
+_TAO_ArrayDef_Remote_Proxy_Broker::~_TAO_ArrayDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_WstringDef_Proxy_Impl&
-IR::_TAO_WstringDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::WstringDef *object,
+_TAO_ArrayDef_Proxy_Impl&
+_TAO_ArrayDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_ArrayDef *object,
   CORBA::Environment &ACE_TRY_ENV
 )
 {
@@ -22067,112 +13989,113 @@
 
 
 // default constructor
-IR::WstringDef::WstringDef (int collocated)
+IR_ArrayDef::IR_ArrayDef (int collocated)
 {
   this->_tao_setup_collocation (collocated);
 }
 
 // destructor
-IR::WstringDef::~WstringDef (void)
+IR_ArrayDef::~IR_ArrayDef (void)
 {}
 
 void
-IR::WstringDef::_tao_setup_collocation (int collocated)
+IR_ArrayDef::_tao_setup_collocation (int collocated)
 {
   if (collocated)
-    this->the_TAO_WstringDef_Proxy_Broker_ =
-      ::IR__TAO_WstringDef_Proxy_Broker_Factory_function_pointer (this);
+    this->the_TAO_ArrayDef_Proxy_Broker_ =
+      _TAO_ArrayDef_Proxy_Broker_Factory_function_pointer (this);
   else
-    this->the_TAO_WstringDef_Proxy_Broker_ =
-      ::IR::_TAO_WstringDef_Remote_Proxy_Broker::the_TAO_WstringDef_Remote_Proxy_Broker ();
+    this->the_TAO_ArrayDef_Proxy_Broker_ =
+      ::the_TAO_ArrayDef_Remote_Proxy_Broker ();
+  
+  IR_IDLType::_tao_setup_collocation (collocated);
   
-  ACE_NESTED_CLASS (IR, IDLType)::_tao_setup_collocation (collocated);
 }
 
-void IR::WstringDef::_tao_any_destructor (void *x)
+void IR_ArrayDef::_tao_any_destructor (void *x)
 {
-  WstringDef *tmp = ACE_static_cast (WstringDef*,x);
+  IR_ArrayDef *tmp = ACE_static_cast (IR_ArrayDef*,x);
   CORBA::release (tmp);
 }
 
-IR::WstringDef_ptr IR::WstringDef::_narrow (
+IR_ArrayDef_ptr IR_ArrayDef::_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
 {
   if (CORBA::is_nil (obj))
-    return WstringDef::_nil ();
+    return IR_ArrayDef::_nil ();
   if (! obj->_is_local ())
     {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/WstringDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (WstringDef::_nil ());
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ArrayDef:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (IR_ArrayDef::_nil ());
       if (is_a == 0)
-        return WstringDef::_nil ();
+        return IR_ArrayDef::_nil ();
     }
-  return WstringDef::_unchecked_narrow (obj, ACE_TRY_ENV);
+  return IR_ArrayDef::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::WstringDef_ptr IR::WstringDef::_unchecked_narrow (
+IR_ArrayDef_ptr IR_ArrayDef::_unchecked_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &
   )
 {
   if (CORBA::is_nil (obj))
-    return WstringDef::_nil ();
+    return IR_ArrayDef::_nil ();
   if (! obj->_is_local ())
     {
       TAO_Stub* stub = obj->_stubobj ();
       if (stub)
         stub->_incr_refcnt ();
-      WstringDef_ptr default_proxy = WstringDef::_nil ();
+      IR_ArrayDef_ptr default_proxy = IR_ArrayDef::_nil ();
 
       if (
           !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
           stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_WstringDef_Proxy_Broker_Factory_function_pointer != 0
+          obj->_is_collocated () &&_TAO_ArrayDef_Proxy_Broker_Factory_function_pointer != 0
         )
       {
         ACE_NEW_RETURN (
           default_proxy,
-          ::IR::WstringDef (
+          ::IR_ArrayDef (
             stub,
             1,
             obj->_servant ()),
             
-          WstringDef::_nil ());
+          IR_ArrayDef::_nil ());
         }
       if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::WstringDef (stub, 0, obj->_servant ()), WstringDef::_nil ());
+        ACE_NEW_RETURN (default_proxy, ::IR_ArrayDef (stub, 0, obj->_servant ()), IR_ArrayDef::_nil ());
         return default_proxy;
       }
     else 
       return
         ACE_reinterpret_cast
           (
-            WstringDef_ptr,
+            IR_ArrayDef_ptr,
               obj->_tao_QueryInterface
                 (
                   ACE_reinterpret_cast
                     (
                       ptr_arith_t,
-                      &WstringDef::_narrow
+                      &IR_ArrayDef::_narrow
                     )
                 )
           );
 }
 
-IR::WstringDef_ptr
-IR::WstringDef::_duplicate (WstringDef_ptr obj)
+IR_ArrayDef_ptr
+IR_ArrayDef::_duplicate (IR_ArrayDef_ptr obj)
 {
   if (!CORBA::is_nil (obj))
     obj->_add_ref ();
   return obj;
 }
 
-CORBA::Boolean IR::WstringDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+CORBA::Boolean IR_ArrayDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
   if (
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/WstringDef:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ArrayDef:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
@@ -22181,34 +14104,34 @@
     return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
 }
 
-void *IR::WstringDef::_tao_QueryInterface (ptr_arith_t type)
+void *IR_ArrayDef::_tao_QueryInterface (ptr_arith_t type)
 {
   void *retv = 0;
   if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, WstringDef)::_narrow))
+      &IR_ArrayDef::_narrow))
     retv = ACE_reinterpret_cast (void*, this);
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, IDLType)::_narrow))
+      &IR_IDLType::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::IDLType_ptr,
+            IR_IDLType_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
+      &CORBA_IRObject::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            CORBA::IRObject_ptr,
+            CORBA_IRObject_ptr,
             this
           )
       );
@@ -22221,12 +14144,12 @@
   return retv;
 }
 
-const char* IR::WstringDef::_interface_repository_id (void) const
+const char* IR_ArrayDef::_interface_repository_id (void) const
 {
-  return "IDL:omg.org/IR/WstringDef:1.0";
+  return "IDL:omg.org/IR/ArrayDef:1.0";
 }
 
-CORBA::ULong IR::WstringDef::bound (
+CORBA::ULong IR_ArrayDef::length (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -22234,14 +14157,14 @@
   ))
 {
   
-  return this->the_TAO_WstringDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).bound (
+  return this->the_TAO_ArrayDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).length (
       this,
       ACE_TRY_ENV
     );
 }
 
-void IR::WstringDef::bound (
-    CORBA::ULong bound,
+void IR_ArrayDef::length (
+    CORBA::ULong length,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -22249,152 +14172,82 @@
   ))
 {
   
-  this->the_TAO_WstringDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).bound (
+  this->the_TAO_ArrayDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).length (
       this,
-      bound,
+      length,
       ACE_TRY_ENV
     );
 }
 
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-IR::WstringDef::TAO_ClientRequestInfo_IR_WstringDef_bound_get::TAO_ClientRequestInfo_IR_WstringDef_bound_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
+CORBA::TypeCode_ptr IR_ArrayDef::element_type (
+    CORBA::Environment &ACE_TRY_ENV
   )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::WstringDef::TAO_ClientRequestInfo_IR_WstringDef_bound_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::WstringDef::TAO_ClientRequestInfo_IR_WstringDef_bound_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::WstringDef::TAO_ClientRequestInfo_IR_WstringDef_bound_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
   
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::WstringDef::TAO_ClientRequestInfo_IR_WstringDef_bound_get::result (CORBA::ULong result)
-{
-  // update the result 
-  this->_result = result;
+  return this->the_TAO_ArrayDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).element_type (
+      this,
+      ACE_TRY_ENV
+    );
 }
 
-IR::WstringDef::TAO_ClientRequestInfo_IR_WstringDef_bound_set::TAO_ClientRequestInfo_IR_WstringDef_bound_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const CORBA::ULong & bound,
-    CORBA::Environment &    
+IR_IDLType_ptr IR_ArrayDef::element_type_def (
+    CORBA::Environment &ACE_TRY_ENV
   )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    bound_ (bound)
-{}
-
-Dynamic::ParameterList *
-IR::WstringDef::TAO_ClientRequestInfo_IR_WstringDef_bound_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_bound = parameter_list->length ();
-  parameter_list->length (length_bound + 1);
-  (*parameter_list)[length_bound].argument <<= bound_;
-  (*parameter_list)[length_bound].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::WstringDef::TAO_ClientRequestInfo_IR_WstringDef_bound_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
   
-  return exception_list;
+  return this->the_TAO_ArrayDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).element_type_def (
+      this,
+      ACE_TRY_ENV
+    );
 }
 
-
-CORBA::Any * 
-IR::WstringDef::TAO_ClientRequestInfo_IR_WstringDef_bound_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+void IR_ArrayDef::element_type_def (
+    IR_IDLType_ptr element_type_def,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
   
-  return result_any;
+  this->the_TAO_ArrayDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).element_type_def (
+      this,
+      element_type_def,
+      ACE_TRY_ENV
+    );
 }
 
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_WstringDef[] =
+static const CORBA::Long _oc_IR_ArrayDef[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
-  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f57), ACE_NTOHL (0x73747269), ACE_NTOHL (0x6e674465), ACE_NTOHL (0x663a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/WstringDef:1.0
-  11, ACE_NTOHL (0x57737472), ACE_NTOHL (0x696e6744), ACE_NTOHL (0x65660000),  // name = WstringDef
+  28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x72726179), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ArrayDef:1.0
+  9, ACE_NTOHL (0x41727261), ACE_NTOHL (0x79446566), ACE_NTOHL (0x0),  // name = IR_ArrayDef
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_WstringDef (CORBA::tk_objref, sizeof (_oc_IR_WstringDef), (char *) &_oc_IR_WstringDef, 0, sizeof (IR::WstringDef));
+static CORBA::TypeCode _tc_TAO_tc_IR_ArrayDef (CORBA::tk_objref, sizeof (_oc_IR_ArrayDef), (char *) &_oc_IR_ArrayDef, 0, sizeof (IR_ArrayDef));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_WstringDef, &_tc_TAO_tc_IR_WstringDef)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ArrayDef, &_tc_TAO_tc_IR_ArrayDef)
 TAO_NAMESPACE_END
 
 ///////////////////////////////////////////////////////////////////////
 //                Base & Remote Proxy  Implementation. 
 //
 
-IR::_TAO_FixedDef_Proxy_Impl::_TAO_FixedDef_Proxy_Impl (void)
+_TAO_ExceptionDef_Proxy_Impl::_TAO_ExceptionDef_Proxy_Impl (void)
 {}
 
-IR::_TAO_FixedDef_Remote_Proxy_Impl::_TAO_FixedDef_Remote_Proxy_Impl (void)
+_TAO_ExceptionDef_Remote_Proxy_Impl::_TAO_ExceptionDef_Remote_Proxy_Impl (void)
 {}
 
 // Remote Implementation of the IDL interface methods
 
-CORBA::UShort IR::_TAO_FixedDef_Remote_Proxy_Impl::digits (
+CORBA::TypeCode_ptr _TAO_ExceptionDef_Remote_Proxy_Impl::type (
     CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -22403,158 +14256,69 @@
   ))
 {
   
-  CORBA::UShort _tao_retval = 0;
+  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
+  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
   
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
   
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_get_digits",
-      11,
+      "_get_type",
+      9,
       0,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::FixedDef::TAO_ClientRequestInfo_IR_FixedDef_digits_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_retval)
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              CORBA::UShort  _tao_retval_info = _tao_retval;
-               ri.result (_tao_retval_info);
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
         }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_retval;
+  return _tao_safe_retval._retn ();
 }
 
-void IR::_TAO_FixedDef_Remote_Proxy_Impl::digits (
+IR_StructMemberSeq * _TAO_ExceptionDef_Remote_Proxy_Impl::members (
     CORBA_Object *_collocated_tao_target_,
-    CORBA::UShort digits,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -22562,456 +14326,128 @@
   ))
 {
   
-
+  IR_StructMemberSeq *_tao_retval = 0;
   
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
-    ACE_THROW (CORBA::INTERNAL ());
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
   
+  ACE_NEW_RETURN (_tao_retval, IR_StructMemberSeq, _tao_retval);
+  IR_StructMemberSeq_var _tao_safe_retval (_tao_retval);
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_set_digits",
-      11,
-      1,
+      "_get_members",
+      12,
+      0,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::FixedDef::TAO_ClientRequestInfo_IR_FixedDef_digits_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        digits,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << digits)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
         }
-      
-      break;
-    }
-  
-}
-
-CORBA::Short IR::_TAO_FixedDef_Remote_Proxy_Impl::scale (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  CORBA::Short _tao_retval = 0;
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_scale",
-      10,
-      0,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::FixedDef::TAO_ClientRequestInfo_IR_FixedDef_scale_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_retval)
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
                 CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
+                0
               );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              CORBA::Short  _tao_retval_info = _tao_retval;
-               ri.result (_tao_retval_info);
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_retval;
+  return _tao_safe_retval._retn ();
 }
 
-void IR::_TAO_FixedDef_Remote_Proxy_Impl::scale (
+void _TAO_ExceptionDef_Remote_Proxy_Impl::members (
     CORBA_Object *_collocated_tao_target_,
-    CORBA::Short scale,
+    const IR_StructMemberSeq & members,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-
-  
-  
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW (CORBA::INTERNAL ());
 
-  
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_set_scale",
-      10,
+      "_set_members",
+      12,
       1,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::FixedDef::TAO_ClientRequestInfo_IR_FixedDef_scale_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        scale,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << scale)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << members)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
       
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
         }
-      
-      break;
-    }
-  
+        
+        break;
+      }
 }
 
 
@@ -23024,32 +14460,32 @@
 //           Remote & Base  Proxy Broker Implementation
 //
 
-IR::_TAO_FixedDef_Proxy_Broker::_TAO_FixedDef_Proxy_Broker (void)
+_TAO_ExceptionDef_Proxy_Broker::_TAO_ExceptionDef_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_FixedDef_Proxy_Broker::~_TAO_FixedDef_Proxy_Broker (void)
+_TAO_ExceptionDef_Proxy_Broker::~_TAO_ExceptionDef_Proxy_Broker (void)
 {
 }
 
-// Factory Member function Implementation.
-IR::_TAO_FixedDef_Remote_Proxy_Broker *IR::_TAO_FixedDef_Remote_Proxy_Broker::the_TAO_FixedDef_Remote_Proxy_Broker (void)
+// Factory function Implementation.
+_TAO_ExceptionDef_Remote_Proxy_Broker *the_TAO_ExceptionDef_Remote_Proxy_Broker (void)
 {
-  static ::IR::_TAO_FixedDef_Remote_Proxy_Broker remote_proxy_broker;
+  static ::_TAO_ExceptionDef_Remote_Proxy_Broker remote_proxy_broker;
   return &remote_proxy_broker;
 }
 
-IR::_TAO_FixedDef_Remote_Proxy_Broker::_TAO_FixedDef_Remote_Proxy_Broker (void)
+_TAO_ExceptionDef_Remote_Proxy_Broker::_TAO_ExceptionDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_FixedDef_Remote_Proxy_Broker::~_TAO_FixedDef_Remote_Proxy_Broker (void)
+_TAO_ExceptionDef_Remote_Proxy_Broker::~_TAO_ExceptionDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_FixedDef_Proxy_Impl&
-IR::_TAO_FixedDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::FixedDef *object,
+_TAO_ExceptionDef_Proxy_Impl&
+_TAO_ExceptionDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_ExceptionDef *object,
   CORBA::Environment &ACE_TRY_ENV
 )
 {
@@ -23065,113 +14501,116 @@
 
 
 // default constructor
-IR::FixedDef::FixedDef (int collocated)
+IR_ExceptionDef::IR_ExceptionDef (int collocated)
 {
   this->_tao_setup_collocation (collocated);
 }
 
 // destructor
-IR::FixedDef::~FixedDef (void)
+IR_ExceptionDef::~IR_ExceptionDef (void)
 {}
 
 void
-IR::FixedDef::_tao_setup_collocation (int collocated)
+IR_ExceptionDef::_tao_setup_collocation (int collocated)
 {
   if (collocated)
-    this->the_TAO_FixedDef_Proxy_Broker_ =
-      ::IR__TAO_FixedDef_Proxy_Broker_Factory_function_pointer (this);
+    this->the_TAO_ExceptionDef_Proxy_Broker_ =
+      _TAO_ExceptionDef_Proxy_Broker_Factory_function_pointer (this);
   else
-    this->the_TAO_FixedDef_Proxy_Broker_ =
-      ::IR::_TAO_FixedDef_Remote_Proxy_Broker::the_TAO_FixedDef_Remote_Proxy_Broker ();
+    this->the_TAO_ExceptionDef_Proxy_Broker_ =
+      ::the_TAO_ExceptionDef_Remote_Proxy_Broker ();
+  
+  IR_Contained::_tao_setup_collocation (collocated);
+  IR_Container::_tao_setup_collocation (collocated);
   
-  ACE_NESTED_CLASS (IR, IDLType)::_tao_setup_collocation (collocated);
 }
 
-void IR::FixedDef::_tao_any_destructor (void *x)
+void IR_ExceptionDef::_tao_any_destructor (void *x)
 {
-  FixedDef *tmp = ACE_static_cast (FixedDef*,x);
+  IR_ExceptionDef *tmp = ACE_static_cast (IR_ExceptionDef*,x);
   CORBA::release (tmp);
 }
 
-IR::FixedDef_ptr IR::FixedDef::_narrow (
+IR_ExceptionDef_ptr IR_ExceptionDef::_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
 {
   if (CORBA::is_nil (obj))
-    return FixedDef::_nil ();
+    return IR_ExceptionDef::_nil ();
   if (! obj->_is_local ())
     {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/FixedDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (FixedDef::_nil ());
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ExceptionDef:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (IR_ExceptionDef::_nil ());
       if (is_a == 0)
-        return FixedDef::_nil ();
+        return IR_ExceptionDef::_nil ();
     }
-  return FixedDef::_unchecked_narrow (obj, ACE_TRY_ENV);
+  return IR_ExceptionDef::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::FixedDef_ptr IR::FixedDef::_unchecked_narrow (
+IR_ExceptionDef_ptr IR_ExceptionDef::_unchecked_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &
   )
 {
   if (CORBA::is_nil (obj))
-    return FixedDef::_nil ();
+    return IR_ExceptionDef::_nil ();
   if (! obj->_is_local ())
     {
       TAO_Stub* stub = obj->_stubobj ();
       if (stub)
         stub->_incr_refcnt ();
-      FixedDef_ptr default_proxy = FixedDef::_nil ();
+      IR_ExceptionDef_ptr default_proxy = IR_ExceptionDef::_nil ();
 
       if (
           !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
           stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_FixedDef_Proxy_Broker_Factory_function_pointer != 0
+          obj->_is_collocated () &&_TAO_ExceptionDef_Proxy_Broker_Factory_function_pointer != 0
         )
       {
         ACE_NEW_RETURN (
           default_proxy,
-          ::IR::FixedDef (
+          ::IR_ExceptionDef (
             stub,
             1,
             obj->_servant ()),
             
-          FixedDef::_nil ());
+          IR_ExceptionDef::_nil ());
         }
       if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::FixedDef (stub, 0, obj->_servant ()), FixedDef::_nil ());
+        ACE_NEW_RETURN (default_proxy, ::IR_ExceptionDef (stub, 0, obj->_servant ()), IR_ExceptionDef::_nil ());
         return default_proxy;
       }
     else 
       return
         ACE_reinterpret_cast
           (
-            FixedDef_ptr,
+            IR_ExceptionDef_ptr,
               obj->_tao_QueryInterface
                 (
                   ACE_reinterpret_cast
                     (
                       ptr_arith_t,
-                      &FixedDef::_narrow
+                      &IR_ExceptionDef::_narrow
                     )
                 )
           );
 }
 
-IR::FixedDef_ptr
-IR::FixedDef::_duplicate (FixedDef_ptr obj)
+IR_ExceptionDef_ptr
+IR_ExceptionDef::_duplicate (IR_ExceptionDef_ptr obj)
 {
   if (!CORBA::is_nil (obj))
     obj->_add_ref ();
   return obj;
 }
 
-CORBA::Boolean IR::FixedDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+CORBA::Boolean IR_ExceptionDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
   if (
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/FixedDef:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ExceptionDef:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
   return 1; // success using local knowledge
@@ -23179,34 +14618,46 @@
     return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
 }
 
-void *IR::FixedDef::_tao_QueryInterface (ptr_arith_t type)
+void *IR_ExceptionDef::_tao_QueryInterface (ptr_arith_t type)
 {
   void *retv = 0;
   if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, FixedDef)::_narrow))
+      &IR_ExceptionDef::_narrow))
     retv = ACE_reinterpret_cast (void*, this);
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, IDLType)::_narrow))
+      &IR_Contained::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            IR_Contained_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_Container::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::IDLType_ptr,
+            IR_Container_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
+      &CORBA_IRObject::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            CORBA::IRObject_ptr,
+            CORBA_IRObject_ptr,
             this
           )
       );
@@ -23219,12 +14670,12 @@
   return retv;
 }
 
-const char* IR::FixedDef::_interface_repository_id (void) const
+const char* IR_ExceptionDef::_interface_repository_id (void) const
 {
-  return "IDL:omg.org/IR/FixedDef:1.0";
+  return "IDL:omg.org/IR/ExceptionDef:1.0";
 }
 
-CORBA::UShort IR::FixedDef::digits (
+CORBA::TypeCode_ptr IR_ExceptionDef::type (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -23232,14 +14683,13 @@
   ))
 {
   
-  return this->the_TAO_FixedDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).digits (
+  return this->the_TAO_ExceptionDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type (
       this,
       ACE_TRY_ENV
     );
 }
 
-void IR::FixedDef::digits (
-    CORBA::UShort digits,
+IR_StructMemberSeq * IR_ExceptionDef::members (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -23247,14 +14697,14 @@
   ))
 {
   
-  this->the_TAO_FixedDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).digits (
+  return this->the_TAO_ExceptionDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).members (
       this,
-      digits,
       ACE_TRY_ENV
     );
 }
 
-CORBA::Short IR::FixedDef::scale (
+void IR_ExceptionDef::members (
+    const IR_StructMemberSeq & members,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -23262,278 +14712,396 @@
   ))
 {
   
-  return this->the_TAO_FixedDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).scale (
+  this->the_TAO_ExceptionDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).members (
       this,
+      members,
       ACE_TRY_ENV
     );
 }
 
-void IR::FixedDef::scale (
-    CORBA::Short scale,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
+static const CORBA::Long _oc_IR_ExceptionDef[] =
 {
-  
-  this->the_TAO_FixedDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).scale (
-      this,
-      scale,
-      ACE_TRY_ENV
-    );
-}
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDef:1.0
+  13, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446566), ACE_NTOHL (0x0),  // name = IR_ExceptionDef
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_ExceptionDef (CORBA::tk_objref, sizeof (_oc_IR_ExceptionDef), (char *) &_oc_IR_ExceptionDef, 0, sizeof (IR_ExceptionDef));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ExceptionDef, &_tc_TAO_tc_IR_ExceptionDef)
+TAO_NAMESPACE_END
 
+static const CORBA::Long _oc_IR_ExceptionDescription[] =
+{
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
+  21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
+  5, // member count
+  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+  CORBA::tk_alias, // typecode kind for typedefs
+  64, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+    CORBA::tk_string, 
+    0U, // string length
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-IR::FixedDef::TAO_ClientRequestInfo_IR_FixedDef_digits_get::TAO_ClientRequestInfo_IR_FixedDef_digits_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
+  3, ACE_NTOHL (0x69640000),  // name = id
+  CORBA::tk_alias, // typecode kind for typedefs
+  68, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+    CORBA::tk_string, 
+    0U, // string length
 
-Dynamic::ParameterList *
-IR::FixedDef::TAO_ClientRequestInfo_IR_FixedDef_digits_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
+  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
+  CORBA::tk_alias, // typecode kind for typedefs
+  68, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+    CORBA::tk_string, 
+    0U, // string length
 
-Dynamic::ExceptionList *
-IR::FixedDef::TAO_ClientRequestInfo_IR_FixedDef_digits_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
+  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
+  CORBA::tk_alias, // typecode kind for typedefs
+  64, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
+    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
+    CORBA::tk_string, 
+    0U, // string length
 
+  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+  CORBA::tk_TypeCode,
 
-CORBA::Any * 
-IR::FixedDef::TAO_ClientRequestInfo_IR_FixedDef_digits_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_ExceptionDescription (CORBA::tk_struct, sizeof (_oc_IR_ExceptionDescription), (char *) &_oc_IR_ExceptionDescription, 0, sizeof (IR_ExceptionDescription));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ExceptionDescription, &_tc_TAO_tc_IR_ExceptionDescription)
+TAO_NAMESPACE_END
 
-void 
-IR::FixedDef::TAO_ClientRequestInfo_IR_FixedDef_digits_get::result (CORBA::UShort result)
+void IR_ExceptionDescription::_tao_any_destructor (void *x)
 {
-  // update the result 
-  this->_result = result;
+  IR_ExceptionDescription *tmp = ACE_static_cast (IR_ExceptionDescription*,x);
+  delete tmp;
 }
 
-IR::FixedDef::TAO_ClientRequestInfo_IR_FixedDef_digits_set::TAO_ClientRequestInfo_IR_FixedDef_digits_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const CORBA::UShort & digits,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    digits_ (digits)
-{}
-
-Dynamic::ParameterList *
-IR::FixedDef::TAO_ClientRequestInfo_IR_FixedDef_digits_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
+  // The Base_Sequence functions, please see tao/Sequence.h
+  void
+  _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::_allocate_buffer (CORBA::ULong length)
+  {
+    IR_ExceptionDef **tmp = 0;
+    tmp = _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::allocbuf (length);
     
-  CORBA::ULong length_digits = parameter_list->length ();
-  parameter_list->length (length_digits + 1);
-  (*parameter_list)[length_digits].argument <<= digits_;
-  (*parameter_list)[length_digits].mode = Dynamic::PARAM_IN;
+    if (this->buffer_ != 0)
+    {
+      IR_ExceptionDef **old = ACE_reinterpret_cast (IR_ExceptionDef**, this->buffer_);
+      for (CORBA::ULong i = 0; i < this->length_; ++i)
+        if (!this->release_)
+          tmp[i] = IR_ExceptionDef::_duplicate (old[i]);
+        else
+          tmp[i] = old[i];
+        
+      if (this->release_)
+        delete[] old;
+      
+    }
+    this->buffer_ = tmp;
+  }
   
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::FixedDef::TAO_ClientRequestInfo_IR_FixedDef_digits_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
+  void
+  _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::_deallocate_buffer (void)
+  {
+    if (this->buffer_ == 0 || this->release_ == 0)
+      return;
+    IR_ExceptionDef **tmp = ACE_reinterpret_cast (IR_ExceptionDef**, this->buffer_);
+    for (CORBA::ULong i = 0; i < this->length_; ++i)
+    {
+      CORBA::release (tmp[i]);
+      tmp[i] = IR_ExceptionDef::_nil ();
+    }
+    _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::freebuf (tmp);
+    this->buffer_ = 0;
+  }
   
-  return exception_list;
-}
-
+  _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::~_TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq (void)
+  {
+    this->_deallocate_buffer ();
+  }
+  
+  void
+  _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
+  {
+    IR_ExceptionDef **tmp = ACE_reinterpret_cast (IR_ExceptionDef**, this->buffer_);
+    
+    for (CORBA::ULong i = nl; i < ol; ++i)
+    {
+      CORBA::release (tmp[i]);
+      tmp[i] = IR_ExceptionDef::_nil ();
+    }
+  }
+  void 
+  _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::_downcast (
+      void* target,
+      CORBA_Object *src,
+      CORBA_Environment &ACE_TRY_ENV
+    )
+  {
+    IR_ExceptionDef **tmp = ACE_static_cast (IR_ExceptionDef**, target);
+    *tmp = IR_ExceptionDef::_narrow (src, ACE_TRY_ENV);
+  }
 
-CORBA::Any * 
-IR::FixedDef::TAO_ClientRequestInfo_IR_FixedDef_digits_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
+  CORBA_Object*
+  _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::_upcast (void *src) const
+  {
+    IR_ExceptionDef **tmp = ACE_static_cast (IR_ExceptionDef**, src);
+    return *tmp;
+  }
   
-  return result_any;
-}
+#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 
-IR::FixedDef::TAO_ClientRequestInfo_IR_FixedDef_scale_get::TAO_ClientRequestInfo_IR_FixedDef_scale_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
+// *************************************************************
+// IR_ExceptionDefSeq
+// *************************************************************
 
-Dynamic::ParameterList *
-IR::FixedDef::TAO_ClientRequestInfo_IR_FixedDef_scale_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+IR_ExceptionDefSeq::IR_ExceptionDefSeq (void)
+{}
+IR_ExceptionDefSeq::IR_ExceptionDefSeq (CORBA::ULong max) // uses max size
+  : 
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
+  _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq
+#else /* TAO_USE_SEQUENCE_TEMPLATES */
+  TAO_Unbounded_Object_Sequence<IR_ExceptionDef,IR_ExceptionDef_var>
+#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
+ (max)
+{}
+IR_ExceptionDefSeq::IR_ExceptionDefSeq (CORBA::ULong max, CORBA::ULong length, IR_ExceptionDef_ptr *buffer, CORBA::Boolean release)
+  : 
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
+  _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq
+#else /* TAO_USE_SEQUENCE_TEMPLATES */
+  TAO_Unbounded_Object_Sequence<IR_ExceptionDef,IR_ExceptionDef_var>
+#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
+ (max, length, buffer, release)
+{}
+IR_ExceptionDefSeq::IR_ExceptionDefSeq (const IR_ExceptionDefSeq &seq) // copy ctor
+  : 
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
+  _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq
+#else /* TAO_USE_SEQUENCE_TEMPLATES */
+  TAO_Unbounded_Object_Sequence<IR_ExceptionDef,IR_ExceptionDef_var>
+#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
+ (seq)
+{}
+IR_ExceptionDefSeq::~IR_ExceptionDefSeq (void) // dtor
+{}
+void IR_ExceptionDefSeq::_tao_any_destructor (void *x)
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
+  IR_ExceptionDefSeq *tmp = ACE_static_cast (IR_ExceptionDefSeq*,x);
+  delete tmp;
 }
 
-Dynamic::ExceptionList *
-IR::FixedDef::TAO_ClientRequestInfo_IR_FixedDef_scale_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+static const CORBA::Long _oc_IR_ExceptionDefSeq[] =
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ExceptionDefSeq:1.0
+  16, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446566), ACE_NTOHL (0x53657100),  // name = ExceptionDefSeq
+  CORBA::tk_sequence, // typecode kind
+  76, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    CORBA::tk_objref, // typecode kind
+    60, // encapsulation length
+      TAO_ENCAP_BYTE_ORDER, // byte order
+      32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDef:1.0
+      13, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446566), ACE_NTOHL (0x0),  // name = IR_ExceptionDef
 
+    0U,
 
-CORBA::Any * 
-IR::FixedDef::TAO_ClientRequestInfo_IR_FixedDef_scale_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_ExceptionDefSeq (CORBA::tk_alias, sizeof (_oc_IR_ExceptionDefSeq), (char *) &_oc_IR_ExceptionDefSeq, 0, sizeof (IR_ExceptionDefSeq));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ExceptionDefSeq, &_tc_TAO_tc_IR_ExceptionDefSeq)
+TAO_NAMESPACE_END
+
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   
-  CORBA::Any_var safe_result_any = result_any;
+  void
+  _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::_allocate_buffer (CORBA::ULong length)
+  {
+    IR_ExceptionDescription* tmp = 0;
+    tmp = _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::allocbuf (length);
+    
+    if (this->buffer_ != 0)
+    {
+      IR_ExceptionDescription *old = ACE_reinterpret_cast (IR_ExceptionDescription *,this->buffer_);
+      
+      for (CORBA::ULong i = 0; i < this->length_; ++i)
+        tmp[i] = old[i];
+      
+      if (this->release_)
+        _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::freebuf (old);
+      
+    }
+    this->buffer_ = tmp;
+  }
   
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
+  void
+  _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::_deallocate_buffer (void)
+  {
+    if (this->buffer_ == 0 || this->release_ == 0)
+      return;
+    
+    IR_ExceptionDescription *tmp = ACE_reinterpret_cast (IR_ExceptionDescription *,this->buffer_);
+    
+    _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::freebuf (tmp);
+    this->buffer_ = 0;
+  } 
+  
+  _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::~_TAO_Unbounded_Sequence_IR_ExcDescriptionSeq (void) // Dtor.
+  {
+    this->_deallocate_buffer ();
+  }
+  
+#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 
-void 
-IR::FixedDef::TAO_ClientRequestInfo_IR_FixedDef_scale_get::result (CORBA::Short result)
-{
-  // update the result 
-  this->_result = result;
-}
+// *************************************************************
+// IR_ExcDescriptionSeq
+// *************************************************************
 
-IR::FixedDef::TAO_ClientRequestInfo_IR_FixedDef_scale_set::TAO_ClientRequestInfo_IR_FixedDef_scale_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const CORBA::Short & scale,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    scale_ (scale)
+IR_ExcDescriptionSeq::IR_ExcDescriptionSeq (void)
 {}
-
-Dynamic::ParameterList *
-IR::FixedDef::TAO_ClientRequestInfo_IR_FixedDef_scale_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+IR_ExcDescriptionSeq::IR_ExcDescriptionSeq (CORBA::ULong max) // uses max size
+  : 
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
+  _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq
+#else /* TAO_USE_SEQUENCE_TEMPLATES */
+  TAO_Unbounded_Sequence<IR_ExceptionDescription>
+#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
+ (max)
+{}
+IR_ExcDescriptionSeq::IR_ExcDescriptionSeq (CORBA::ULong max, CORBA::ULong length, IR_ExceptionDescription *buffer, CORBA::Boolean release)
+  : 
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
+  _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq
+#else /* TAO_USE_SEQUENCE_TEMPLATES */
+  TAO_Unbounded_Sequence<IR_ExceptionDescription>
+#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
+ (max, length, buffer, release)
+{}
+IR_ExcDescriptionSeq::IR_ExcDescriptionSeq (const IR_ExcDescriptionSeq &seq) // copy ctor
+  : 
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
+  _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq
+#else /* TAO_USE_SEQUENCE_TEMPLATES */
+  TAO_Unbounded_Sequence<IR_ExceptionDescription>
+#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
+ (seq)
+{}
+IR_ExcDescriptionSeq::~IR_ExcDescriptionSeq (void) // dtor
+{}
+void IR_ExcDescriptionSeq::_tao_any_destructor (void *x)
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_scale = parameter_list->length ();
-  parameter_list->length (length_scale + 1);
-  (*parameter_list)[length_scale].argument <<= scale_;
-  (*parameter_list)[length_scale].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
+  IR_ExcDescriptionSeq *tmp = ACE_static_cast (IR_ExcDescriptionSeq*,x);
+  delete tmp;
 }
 
-Dynamic::ExceptionList *
-IR::FixedDef::TAO_ClientRequestInfo_IR_FixedDef_scale_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+static const CORBA::Long _oc_IR_ExcDescriptionSeq[] =
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
+  18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
+  CORBA::tk_sequence, // typecode kind
+  456, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    CORBA::tk_struct, // typecode kind
+    440, // encapsulation length
+      TAO_ENCAP_BYTE_ORDER, // byte order
+      40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
+      21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
+      5, // member count
+      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+      CORBA::tk_alias, // typecode kind for typedefs
+      64, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+        CORBA::tk_string, 
+        0U, // string length
 
+      3, ACE_NTOHL (0x69640000),  // name = id
+      CORBA::tk_alias, // typecode kind for typedefs
+      68, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+        CORBA::tk_string, 
+        0U, // string length
 
-CORBA::Any * 
-IR::FixedDef::TAO_ClientRequestInfo_IR_FixedDef_scale_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
-}
+      11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
+      CORBA::tk_alias, // typecode kind for typedefs
+      68, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+        CORBA::tk_string, 
+        0U, // string length
 
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_FixedDef[] =
+      8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
+      CORBA::tk_alias, // typecode kind for typedefs
+      64, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
+        12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
+        CORBA::tk_string, 
+        0U, // string length
+
+      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+      CORBA::tk_TypeCode,
+
+
+    0U,
+
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_ExcDescriptionSeq (CORBA::tk_alias, sizeof (_oc_IR_ExcDescriptionSeq), (char *) &_oc_IR_ExcDescriptionSeq, 0, sizeof (IR_ExcDescriptionSeq));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ExcDescriptionSeq, &_tc_TAO_tc_IR_ExcDescriptionSeq)
+TAO_NAMESPACE_END
+
+static const CORBA::Long _oc_IR_AttributeMode[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
-  28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x69786564), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/FixedDef:1.0
-  9, ACE_NTOHL (0x46697865), ACE_NTOHL (0x64446566), ACE_NTOHL (0x0),  // name = FixedDef
+  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/AttributeMode:1.0
+  14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
+  2, // member count
+  12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
+  14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_FixedDef (CORBA::tk_objref, sizeof (_oc_IR_FixedDef), (char *) &_oc_IR_FixedDef, 0, sizeof (IR::FixedDef));
+static CORBA::TypeCode _tc_TAO_tc_IR_AttributeMode (CORBA::tk_enum, sizeof (_oc_IR_AttributeMode), (char *) &_oc_IR_AttributeMode, 0, sizeof (IR_AttributeMode));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FixedDef, &_tc_TAO_tc_IR_FixedDef)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AttributeMode, &_tc_TAO_tc_IR_AttributeMode)
 TAO_NAMESPACE_END
 
 ///////////////////////////////////////////////////////////////////////
 //                Base & Remote Proxy  Implementation. 
 //
 
-IR::_TAO_SequenceDef_Proxy_Impl::_TAO_SequenceDef_Proxy_Impl (void)
+_TAO_AttributeDef_Proxy_Impl::_TAO_AttributeDef_Proxy_Impl (void)
 {}
 
-IR::_TAO_SequenceDef_Remote_Proxy_Impl::_TAO_SequenceDef_Remote_Proxy_Impl (void)
+_TAO_AttributeDef_Remote_Proxy_Impl::_TAO_AttributeDef_Remote_Proxy_Impl (void)
 {}
 
 // Remote Implementation of the IDL interface methods
 
-CORBA::ULong IR::_TAO_SequenceDef_Remote_Proxy_Impl::bound (
+CORBA::TypeCode_ptr _TAO_AttributeDef_Remote_Proxy_Impl::type (
     CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -23542,158 +15110,69 @@
   ))
 {
   
-  CORBA::ULong _tao_retval = 0;
+  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
+  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
   
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
   
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_get_bound",
-      10,
-      0,
+      "_get_type",
+      9,
+      0,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_bound_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_retval)
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              CORBA::ULong  _tao_retval_info = _tao_retval;
-               ri.result (_tao_retval_info);
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
         }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_retval;
+  return _tao_safe_retval._retn ();
 }
 
-void IR::_TAO_SequenceDef_Remote_Proxy_Impl::bound (
+IR_IDLType_ptr _TAO_AttributeDef_Remote_Proxy_Impl::type_def (
     CORBA_Object *_collocated_tao_target_,
-    CORBA::ULong bound,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -23701,309 +15180,130 @@
   ))
 {
   
-
+  IR_IDLType_ptr _tao_retval = IR_IDLType::_nil ();
+  IR_IDLType_var _tao_safe_retval (_tao_retval);
   
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
-    ACE_THROW (CORBA::INTERNAL ());
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
   
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_set_bound",
-      10,
-      1,
+      "_get_type_def",
+      13,
+      0,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_bound_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        bound,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << bound)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
         }
-      ACE_ENDTRY;
-      ACE_CHECK;
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  
+  return _tao_safe_retval._retn ();
 }
 
-CORBA::TypeCode_ptr IR::_TAO_SequenceDef_Remote_Proxy_Impl::element_type (
+void _TAO_AttributeDef_Remote_Proxy_Impl::type_def (
     CORBA_Object *_collocated_tao_target_,
+    IR_IDLType_ptr type_def,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
-  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
-  
-  
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+    ACE_THROW (CORBA::INTERNAL ());
 
-  
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_get_element_type",
-      17,
-      0,
+      "_set_type_def",
+      13,
+      1,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              CORBA::TypeCode_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << type_def)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
       
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
         }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
+        
+        break;
+      }
 }
 
-IR::IDLType_ptr IR::_TAO_SequenceDef_Remote_Proxy_Impl::element_type_def (
+IR_AttributeMode _TAO_AttributeDef_Remote_Proxy_Impl::mode (
     CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -24012,307 +15312,126 @@
   ))
 {
   
-  IR::IDLType_ptr _tao_retval = IR::IDLType::_nil ();
-  IR::IDLType_var _tao_safe_retval (_tao_retval);
+  IR_AttributeMode _tao_retval = (IR_AttributeMode)0;
   
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
 
   
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_get_element_type_def",
-      21,
+      "_get_mode",
+      9,
       0,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_def_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::IDLType_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
+        ACE_CHECK_RETURN  (_tao_retval);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              _tao_retval
+            );
         }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_retval)
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                _tao_retval
+              );
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
+  return _tao_retval;
 }
 
-void IR::_TAO_SequenceDef_Remote_Proxy_Impl::element_type_def (
+void _TAO_AttributeDef_Remote_Proxy_Impl::mode (
     CORBA_Object *_collocated_tao_target_,
-    IR::IDLType_ptr element_type_def,
+    IR_AttributeMode mode,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-
-  
-  
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW (CORBA::INTERNAL ());
 
-  
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_set_element_type_def",
-      21,
+      "_set_mode",
+      9,
       1,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_def_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        element_type_def,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << element_type_def)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << mode)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
       
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
         }
-      
-      break;
-    }
-  
+        
+        break;
+      }
 }
 
 
@@ -24325,32 +15444,32 @@
 //           Remote & Base  Proxy Broker Implementation
 //
 
-IR::_TAO_SequenceDef_Proxy_Broker::_TAO_SequenceDef_Proxy_Broker (void)
+_TAO_AttributeDef_Proxy_Broker::_TAO_AttributeDef_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_SequenceDef_Proxy_Broker::~_TAO_SequenceDef_Proxy_Broker (void)
+_TAO_AttributeDef_Proxy_Broker::~_TAO_AttributeDef_Proxy_Broker (void)
 {
 }
 
-// Factory Member function Implementation.
-IR::_TAO_SequenceDef_Remote_Proxy_Broker *IR::_TAO_SequenceDef_Remote_Proxy_Broker::the_TAO_SequenceDef_Remote_Proxy_Broker (void)
+// Factory function Implementation.
+_TAO_AttributeDef_Remote_Proxy_Broker *the_TAO_AttributeDef_Remote_Proxy_Broker (void)
 {
-  static ::IR::_TAO_SequenceDef_Remote_Proxy_Broker remote_proxy_broker;
+  static ::_TAO_AttributeDef_Remote_Proxy_Broker remote_proxy_broker;
   return &remote_proxy_broker;
 }
 
-IR::_TAO_SequenceDef_Remote_Proxy_Broker::_TAO_SequenceDef_Remote_Proxy_Broker (void)
+_TAO_AttributeDef_Remote_Proxy_Broker::_TAO_AttributeDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_SequenceDef_Remote_Proxy_Broker::~_TAO_SequenceDef_Remote_Proxy_Broker (void)
+_TAO_AttributeDef_Remote_Proxy_Broker::~_TAO_AttributeDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_SequenceDef_Proxy_Impl&
-IR::_TAO_SequenceDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::SequenceDef *object,
+_TAO_AttributeDef_Proxy_Impl&
+_TAO_AttributeDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_AttributeDef *object,
   CORBA::Environment &ACE_TRY_ENV
 )
 {
@@ -24366,113 +15485,114 @@
 
 
 // default constructor
-IR::SequenceDef::SequenceDef (int collocated)
+IR_AttributeDef::IR_AttributeDef (int collocated)
 {
   this->_tao_setup_collocation (collocated);
 }
 
 // destructor
-IR::SequenceDef::~SequenceDef (void)
+IR_AttributeDef::~IR_AttributeDef (void)
 {}
 
 void
-IR::SequenceDef::_tao_setup_collocation (int collocated)
+IR_AttributeDef::_tao_setup_collocation (int collocated)
 {
   if (collocated)
-    this->the_TAO_SequenceDef_Proxy_Broker_ =
-      ::IR__TAO_SequenceDef_Proxy_Broker_Factory_function_pointer (this);
+    this->the_TAO_AttributeDef_Proxy_Broker_ =
+      _TAO_AttributeDef_Proxy_Broker_Factory_function_pointer (this);
   else
-    this->the_TAO_SequenceDef_Proxy_Broker_ =
-      ::IR::_TAO_SequenceDef_Remote_Proxy_Broker::the_TAO_SequenceDef_Remote_Proxy_Broker ();
+    this->the_TAO_AttributeDef_Proxy_Broker_ =
+      ::the_TAO_AttributeDef_Remote_Proxy_Broker ();
+  
+  IR_Contained::_tao_setup_collocation (collocated);
   
-  ACE_NESTED_CLASS (IR, IDLType)::_tao_setup_collocation (collocated);
 }
 
-void IR::SequenceDef::_tao_any_destructor (void *x)
+void IR_AttributeDef::_tao_any_destructor (void *x)
 {
-  SequenceDef *tmp = ACE_static_cast (SequenceDef*,x);
+  IR_AttributeDef *tmp = ACE_static_cast (IR_AttributeDef*,x);
   CORBA::release (tmp);
 }
 
-IR::SequenceDef_ptr IR::SequenceDef::_narrow (
+IR_AttributeDef_ptr IR_AttributeDef::_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
 {
   if (CORBA::is_nil (obj))
-    return SequenceDef::_nil ();
+    return IR_AttributeDef::_nil ();
   if (! obj->_is_local ())
     {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/SequenceDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (SequenceDef::_nil ());
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/AttributeDef:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (IR_AttributeDef::_nil ());
       if (is_a == 0)
-        return SequenceDef::_nil ();
+        return IR_AttributeDef::_nil ();
     }
-  return SequenceDef::_unchecked_narrow (obj, ACE_TRY_ENV);
+  return IR_AttributeDef::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::SequenceDef_ptr IR::SequenceDef::_unchecked_narrow (
+IR_AttributeDef_ptr IR_AttributeDef::_unchecked_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &
   )
 {
   if (CORBA::is_nil (obj))
-    return SequenceDef::_nil ();
+    return IR_AttributeDef::_nil ();
   if (! obj->_is_local ())
     {
       TAO_Stub* stub = obj->_stubobj ();
       if (stub)
         stub->_incr_refcnt ();
-      SequenceDef_ptr default_proxy = SequenceDef::_nil ();
+      IR_AttributeDef_ptr default_proxy = IR_AttributeDef::_nil ();
 
       if (
           !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
           stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_SequenceDef_Proxy_Broker_Factory_function_pointer != 0
+          obj->_is_collocated () &&_TAO_AttributeDef_Proxy_Broker_Factory_function_pointer != 0
         )
       {
         ACE_NEW_RETURN (
           default_proxy,
-          ::IR::SequenceDef (
+          ::IR_AttributeDef (
             stub,
             1,
             obj->_servant ()),
             
-          SequenceDef::_nil ());
+          IR_AttributeDef::_nil ());
         }
       if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::SequenceDef (stub, 0, obj->_servant ()), SequenceDef::_nil ());
+        ACE_NEW_RETURN (default_proxy, ::IR_AttributeDef (stub, 0, obj->_servant ()), IR_AttributeDef::_nil ());
         return default_proxy;
       }
     else 
       return
         ACE_reinterpret_cast
           (
-            SequenceDef_ptr,
+            IR_AttributeDef_ptr,
               obj->_tao_QueryInterface
                 (
                   ACE_reinterpret_cast
                     (
                       ptr_arith_t,
-                      &SequenceDef::_narrow
+                      &IR_AttributeDef::_narrow
                     )
                 )
           );
 }
 
-IR::SequenceDef_ptr
-IR::SequenceDef::_duplicate (SequenceDef_ptr obj)
+IR_AttributeDef_ptr
+IR_AttributeDef::_duplicate (IR_AttributeDef_ptr obj)
 {
   if (!CORBA::is_nil (obj))
     obj->_add_ref ();
   return obj;
 }
 
-CORBA::Boolean IR::SequenceDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+CORBA::Boolean IR_AttributeDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
   if (
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/SequenceDef:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/AttributeDef:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
   return 1; // success using local knowledge
@@ -24480,34 +15600,34 @@
     return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
 }
 
-void *IR::SequenceDef::_tao_QueryInterface (ptr_arith_t type)
+void *IR_AttributeDef::_tao_QueryInterface (ptr_arith_t type)
 {
   void *retv = 0;
   if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, SequenceDef)::_narrow))
+      &IR_AttributeDef::_narrow))
     retv = ACE_reinterpret_cast (void*, this);
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, IDLType)::_narrow))
+      &IR_Contained::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::IDLType_ptr,
+            IR_Contained_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
+      &CORBA_IRObject::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            CORBA::IRObject_ptr,
+            CORBA_IRObject_ptr,
             this
           )
       );
@@ -24520,12 +15640,12 @@
   return retv;
 }
 
-const char* IR::SequenceDef::_interface_repository_id (void) const
+const char* IR_AttributeDef::_interface_repository_id (void) const
 {
-  return "IDL:omg.org/IR/SequenceDef:1.0";
+  return "IDL:omg.org/IR/AttributeDef:1.0";
 }
 
-CORBA::ULong IR::SequenceDef::bound (
+CORBA::TypeCode_ptr IR_AttributeDef::type (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -24533,14 +15653,13 @@
   ))
 {
   
-  return this->the_TAO_SequenceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).bound (
+  return this->the_TAO_AttributeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type (
       this,
       ACE_TRY_ENV
     );
 }
 
-void IR::SequenceDef::bound (
-    CORBA::ULong bound,
+IR_IDLType_ptr IR_AttributeDef::type_def (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -24548,14 +15667,14 @@
   ))
 {
   
-  this->the_TAO_SequenceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).bound (
+  return this->the_TAO_AttributeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type_def (
       this,
-      bound,
       ACE_TRY_ENV
     );
 }
 
-CORBA::TypeCode_ptr IR::SequenceDef::element_type (
+void IR_AttributeDef::type_def (
+    IR_IDLType_ptr type_def,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -24563,13 +15682,14 @@
   ))
 {
   
-  return this->the_TAO_SequenceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).element_type (
+  this->the_TAO_AttributeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type_def (
       this,
+      type_def,
       ACE_TRY_ENV
     );
 }
 
-IR::IDLType_ptr IR::SequenceDef::element_type_def (
+IR_AttributeMode IR_AttributeDef::mode (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -24577,14 +15697,14 @@
   ))
 {
   
-  return this->the_TAO_SequenceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).element_type_def (
+  return this->the_TAO_AttributeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).mode (
       this,
       ACE_TRY_ENV
     );
 }
 
-void IR::SequenceDef::element_type_def (
-    IR::IDLType_ptr element_type_def,
+void IR_AttributeDef::mode (
+    IR_AttributeMode mode,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -24592,952 +15712,602 @@
   ))
 {
   
-  this->the_TAO_SequenceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).element_type_def (
+  this->the_TAO_AttributeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).mode (
       this,
-      element_type_def,
+      mode,
       ACE_TRY_ENV
     );
 }
 
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-IR::SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_bound_get::TAO_ClientRequestInfo_IR_SequenceDef_bound_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_bound_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_bound_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+static const CORBA::Long _oc_IR_AttributeDef[] =
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/AttributeDef:1.0
+  13, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = IR_AttributeDef
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_AttributeDef (CORBA::tk_objref, sizeof (_oc_IR_AttributeDef), (char *) &_oc_IR_AttributeDef, 0, sizeof (IR_AttributeDef));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AttributeDef, &_tc_TAO_tc_IR_AttributeDef)
+TAO_NAMESPACE_END
 
-CORBA::Any * 
-IR::SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_bound_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+static const CORBA::Long _oc_IR_AttributeDescription[] =
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/AttributeDescription:1.0
+  21, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = AttributeDescription
+  8, // member count
+  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+  CORBA::tk_alias, // typecode kind for typedefs
+  64, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+    CORBA::tk_string, 
+    0U, // string length
 
-void 
-IR::SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_bound_get::result (CORBA::ULong result)
-{
-  // update the result 
-  this->_result = result;
-}
+  3, ACE_NTOHL (0x69640000),  // name = id
+  CORBA::tk_alias, // typecode kind for typedefs
+  68, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+    CORBA::tk_string, 
+    0U, // string length
 
-IR::SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_bound_set::TAO_ClientRequestInfo_IR_SequenceDef_bound_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const CORBA::ULong & bound,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    bound_ (bound)
-{}
+  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
+  CORBA::tk_alias, // typecode kind for typedefs
+  68, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+    CORBA::tk_string, 
+    0U, // string length
 
-Dynamic::ParameterList *
-IR::SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_bound_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_bound = parameter_list->length ();
-  parameter_list->length (length_bound + 1);
-  (*parameter_list)[length_bound].argument <<= bound_;
-  (*parameter_list)[length_bound].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
+  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
+  CORBA::tk_alias, // typecode kind for typedefs
+  64, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
+    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
+    CORBA::tk_string, 
+    0U, // string length
 
-Dynamic::ExceptionList *
-IR::SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_bound_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
+  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+  CORBA::tk_TypeCode,
 
+  5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
+  CORBA::tk_enum, // typecode kind
+  104, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/AttributeMode:1.0
+    14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
+    2, // member count
+    12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
+    14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY
 
-CORBA::Any * 
-IR::SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_bound_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
-}
+  15, ACE_NTOHL (0x6765745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = get_exceptions
+  CORBA::tk_alias, // typecode kind for typedefs
+  536, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
+    18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
+    CORBA::tk_sequence, // typecode kind
+    456, // encapsulation length
+      TAO_ENCAP_BYTE_ORDER, // byte order
+      CORBA::tk_struct, // typecode kind
+      440, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
+        21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
+        5, // member count
+        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+        CORBA::tk_alias, // typecode kind for typedefs
+        64, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+          CORBA::tk_string, 
+          0U, // string length
 
-IR::SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_get::TAO_ClientRequestInfo_IR_SequenceDef_element_type_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
+        3, ACE_NTOHL (0x69640000),  // name = id
+        CORBA::tk_alias, // typecode kind for typedefs
+        68, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+          CORBA::tk_string, 
+          0U, // string length
 
-Dynamic::ParameterList *
-IR::SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
+        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
+        CORBA::tk_alias, // typecode kind for typedefs
+        68, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+          CORBA::tk_string, 
+          0U, // string length
 
-Dynamic::ExceptionList *
-IR::SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
+        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
+        CORBA::tk_alias, // typecode kind for typedefs
+        64, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
+          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
+          CORBA::tk_string, 
+          0U, // string length
 
+        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+        CORBA::tk_TypeCode,
 
-CORBA::Any * 
-IR::SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
 
-void 
-IR::SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_get::result (CORBA::TypeCode_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
+      0U,
 
-IR::SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_def_get::TAO_ClientRequestInfo_IR_SequenceDef_element_type_def_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
 
-Dynamic::ParameterList *
-IR::SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_def_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
+  15, ACE_NTOHL (0x7075745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = put_exceptions
+  CORBA::tk_alias, // typecode kind for typedefs
+  536, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
+    18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
+    CORBA::tk_sequence, // typecode kind
+    456, // encapsulation length
+      TAO_ENCAP_BYTE_ORDER, // byte order
+      CORBA::tk_struct, // typecode kind
+      440, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
+        21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
+        5, // member count
+        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+        CORBA::tk_alias, // typecode kind for typedefs
+        64, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+          CORBA::tk_string, 
+          0U, // string length
 
-Dynamic::ExceptionList *
-IR::SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_def_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
+        3, ACE_NTOHL (0x69640000),  // name = id
+        CORBA::tk_alias, // typecode kind for typedefs
+        68, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+          CORBA::tk_string, 
+          0U, // string length
 
+        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
+        CORBA::tk_alias, // typecode kind for typedefs
+        68, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+          CORBA::tk_string, 
+          0U, // string length
 
-CORBA::Any * 
-IR::SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_def_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
+        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
+        CORBA::tk_alias, // typecode kind for typedefs
+        64, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
+          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
+          CORBA::tk_string, 
+          0U, // string length
 
-void 
-IR::SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_def_get::result (IR::IDLType_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
+        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+        CORBA::tk_TypeCode,
 
-IR::SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_def_set::TAO_ClientRequestInfo_IR_SequenceDef_element_type_def_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    IR::IDLType_ptr element_type_def,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    element_type_def_ (element_type_def)
-{}
 
-Dynamic::ParameterList *
-IR::SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_def_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_element_type_def = parameter_list->length ();
-  parameter_list->length (length_element_type_def + 1);
-  (*parameter_list)[length_element_type_def].argument <<=  this->element_type_def_;
-  
-  (*parameter_list)[length_element_type_def].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
+      0U,
 
-Dynamic::ExceptionList *
-IR::SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_def_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
 
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_AttributeDescription (CORBA::tk_struct, sizeof (_oc_IR_AttributeDescription), (char *) &_oc_IR_AttributeDescription, 0, sizeof (IR_AttributeDescription));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AttributeDescription, &_tc_TAO_tc_IR_AttributeDescription)
+TAO_NAMESPACE_END
 
-CORBA::Any * 
-IR::SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_def_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+void IR_AttributeDescription::_tao_any_destructor (void *x)
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
+  IR_AttributeDescription *tmp = ACE_static_cast (IR_AttributeDescription*,x);
+  delete tmp;
 }
 
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_SequenceDef[] =
+static const CORBA::Long _oc_IR_OperationMode[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
-  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x65717565), ACE_NTOHL (0x6e636544), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/SequenceDef:1.0
-  12, ACE_NTOHL (0x53657175), ACE_NTOHL (0x656e6365), ACE_NTOHL (0x44656600),  // name = SequenceDef
+  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/OperationMode:1.0
+  14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
+  2, // member count
+  10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
+  10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_SequenceDef (CORBA::tk_objref, sizeof (_oc_IR_SequenceDef), (char *) &_oc_IR_SequenceDef, 0, sizeof (IR::SequenceDef));
+static CORBA::TypeCode _tc_TAO_tc_IR_OperationMode (CORBA::tk_enum, sizeof (_oc_IR_OperationMode), (char *) &_oc_IR_OperationMode, 0, sizeof (IR_OperationMode));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_SequenceDef, &_tc_TAO_tc_IR_SequenceDef)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_OperationMode, &_tc_TAO_tc_IR_OperationMode)
 TAO_NAMESPACE_END
 
-///////////////////////////////////////////////////////////////////////
-//                Base & Remote Proxy  Implementation. 
-//
-
-IR::_TAO_ArrayDef_Proxy_Impl::_TAO_ArrayDef_Proxy_Impl (void)
-{}
+static const CORBA::Long _oc_IR_ParameterMode[] =
+{
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParameterMode:1.0
+  14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
+  3, // member count
+  9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
+  10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
+  12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_ParameterMode (CORBA::tk_enum, sizeof (_oc_IR_ParameterMode), (char *) &_oc_IR_ParameterMode, 0, sizeof (IR_ParameterMode));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ParameterMode, &_tc_TAO_tc_IR_ParameterMode)
+TAO_NAMESPACE_END
 
-IR::_TAO_ArrayDef_Remote_Proxy_Impl::_TAO_ArrayDef_Remote_Proxy_Impl (void)
-{}
+static const CORBA::Long _oc_IR_ParameterDescription[] =
+{
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ParameterDescription:1.0
+  21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
+  4, // member count
+  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+  CORBA::tk_alias, // typecode kind for typedefs
+  64, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+    CORBA::tk_string, 
+    0U, // string length
 
-// Remote Implementation of the IDL interface methods
+  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+  CORBA::tk_TypeCode,
 
-CORBA::ULong IR::_TAO_ArrayDef_Remote_Proxy_Impl::length (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  CORBA::ULong _tao_retval = 0;
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_length",
-      11,
-      0,
-      istub->orb_core ()
-    );
+  9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
+  CORBA::tk_objref, // typecode kind
+  48, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
+    8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_length_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_retval)
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              CORBA::ULong  _tao_retval_info = _tao_retval;
-               ri.result (_tao_retval_info);
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+  5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
+  CORBA::tk_enum, // typecode kind
+  116, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParameterMode:1.0
+    14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
+    3, // member count
+    9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
+    10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
+    12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_retval;
-}
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_ParameterDescription (CORBA::tk_struct, sizeof (_oc_IR_ParameterDescription), (char *) &_oc_IR_ParameterDescription, 0, sizeof (IR_ParameterDescription));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ParameterDescription, &_tc_TAO_tc_IR_ParameterDescription)
+TAO_NAMESPACE_END
 
-void IR::_TAO_ArrayDef_Remote_Proxy_Impl::length (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::ULong length,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
+void IR_ParameterDescription::_tao_any_destructor (void *x)
 {
-  
-
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW (CORBA::INTERNAL ());
+  IR_ParameterDescription *tmp = ACE_static_cast (IR_ParameterDescription*,x);
+  delete tmp;
+}
 
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_set_length",
-      11,
-      1,
-      istub->orb_core ()
-    );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   
-  for (;;)
+  void
+  _TAO_Unbounded_Sequence_IR_ParDescriptionSeq::_allocate_buffer (CORBA::ULong length)
+  {
+    IR_ParameterDescription* tmp = 0;
+    tmp = _TAO_Unbounded_Sequence_IR_ParDescriptionSeq::allocbuf (length);
+    
+    if (this->buffer_ != 0)
     {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
+      IR_ParameterDescription *old = ACE_reinterpret_cast (IR_ParameterDescription *,this->buffer_);
       
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_length_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        length,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << length)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
+      for (CORBA::ULong i = 0; i < this->length_; ++i)
+        tmp[i] = old[i];
       
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
+      if (this->release_)
+        _TAO_Unbounded_Sequence_IR_ParDescriptionSeq::freebuf (old);
       
-      break;
     }
+    this->buffer_ = tmp;
+  }
   
-}
-
-CORBA::TypeCode_ptr IR::_TAO_ArrayDef_Remote_Proxy_Impl::element_type (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
-  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
-  
+  void
+  _TAO_Unbounded_Sequence_IR_ParDescriptionSeq::_deallocate_buffer (void)
+  {
+    if (this->buffer_ == 0 || this->release_ == 0)
+      return;
+    
+    IR_ParameterDescription *tmp = ACE_reinterpret_cast (IR_ParameterDescription *,this->buffer_);
+    
+    _TAO_Unbounded_Sequence_IR_ParDescriptionSeq::freebuf (tmp);
+    this->buffer_ = 0;
+  } 
   
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
+  _TAO_Unbounded_Sequence_IR_ParDescriptionSeq::~_TAO_Unbounded_Sequence_IR_ParDescriptionSeq (void) // Dtor.
+  {
+    this->_deallocate_buffer ();
+  }
   
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_element_type",
-      17,
-      0,
-      istub->orb_core ()
-    );
+#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              CORBA::TypeCode_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+// *************************************************************
+// IR_ParDescriptionSeq
+// *************************************************************
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
+IR_ParDescriptionSeq::IR_ParDescriptionSeq (void)
+{}
+IR_ParDescriptionSeq::IR_ParDescriptionSeq (CORBA::ULong max) // uses max size
+  : 
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
+  _TAO_Unbounded_Sequence_IR_ParDescriptionSeq
+#else /* TAO_USE_SEQUENCE_TEMPLATES */
+  TAO_Unbounded_Sequence<IR_ParameterDescription>
+#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
+ (max)
+{}
+IR_ParDescriptionSeq::IR_ParDescriptionSeq (CORBA::ULong max, CORBA::ULong length, IR_ParameterDescription *buffer, CORBA::Boolean release)
+  : 
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
+  _TAO_Unbounded_Sequence_IR_ParDescriptionSeq
+#else /* TAO_USE_SEQUENCE_TEMPLATES */
+  TAO_Unbounded_Sequence<IR_ParameterDescription>
+#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
+ (max, length, buffer, release)
+{}
+IR_ParDescriptionSeq::IR_ParDescriptionSeq (const IR_ParDescriptionSeq &seq) // copy ctor
+  : 
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
+  _TAO_Unbounded_Sequence_IR_ParDescriptionSeq
+#else /* TAO_USE_SEQUENCE_TEMPLATES */
+  TAO_Unbounded_Sequence<IR_ParameterDescription>
+#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
+ (seq)
+{}
+IR_ParDescriptionSeq::~IR_ParDescriptionSeq (void) // dtor
+{}
+void IR_ParDescriptionSeq::_tao_any_destructor (void *x)
+{
+  IR_ParDescriptionSeq *tmp = ACE_static_cast (IR_ParDescriptionSeq*,x);
+  delete tmp;
 }
 
-IR::IDLType_ptr IR::_TAO_ArrayDef_Remote_Proxy_Impl::element_type_def (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
+static const CORBA::Long _oc_IR_ParDescriptionSeq[] =
 {
-  
-  IR::IDLType_ptr _tao_retval = IR::IDLType::_nil ();
-  IR::IDLType_var _tao_safe_retval (_tao_retval);
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x61724465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParDescriptionSeq:1.0
+  18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
+  CORBA::tk_sequence, // typecode kind
+  404, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    CORBA::tk_struct, // typecode kind
+    388, // encapsulation length
+      TAO_ENCAP_BYTE_ORDER, // byte order
+      40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ParameterDescription:1.0
+      21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
+      4, // member count
+      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+      CORBA::tk_alias, // typecode kind for typedefs
+      64, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+        CORBA::tk_string, 
+        0U, // string length
 
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_element_type_def",
-      21,
-      0,
-      istub->orb_core ()
-    );
+      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+      CORBA::tk_TypeCode,
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
+      9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
+      CORBA::tk_objref, // typecode kind
+      48, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
+        8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType
+
+      5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
+      CORBA::tk_enum, // typecode kind
+      116, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParameterMode:1.0
+        14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
+        3, // member count
+        9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
+        10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
+        12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT
+
+
+    0U,
+
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_ParDescriptionSeq (CORBA::tk_alias, sizeof (_oc_IR_ParDescriptionSeq), (char *) &_oc_IR_ParDescriptionSeq, 0, sizeof (IR_ParDescriptionSeq));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ParDescriptionSeq, &_tc_TAO_tc_IR_ParDescriptionSeq)
+TAO_NAMESPACE_END
+
+static const CORBA::Long _oc_IR_ContextIdentifier[] =
+{
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ContextIdentifier:1.0
+  18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
+  CORBA::tk_alias, // typecode kind for typedefs
+  64, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+    CORBA::tk_string, 
+    0U, // string length
+
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_ContextIdentifier (CORBA::tk_alias, sizeof (_oc_IR_ContextIdentifier), (char *) &_oc_IR_ContextIdentifier, 0, sizeof (IR::ContextIdentifier));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ContextIdentifier, &_tc_TAO_tc_IR_ContextIdentifier)
+TAO_NAMESPACE_END
+
+// *************************************************************
+// IR_ContextIdSeq
+// *************************************************************
+
+IR_ContextIdSeq::IR_ContextIdSeq (void)
+{}
+IR_ContextIdSeq::IR_ContextIdSeq (CORBA::ULong max) // uses max size
+  : 
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
+  TAO_Unbounded_String_Sequence
+#else /* TAO_USE_SEQUENCE_TEMPLATES */
+  TAO_Unbounded_String_Sequence
+#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
+ (max)
+{}
+IR_ContextIdSeq::IR_ContextIdSeq (CORBA::ULong max, CORBA::ULong length, char * *buffer, CORBA::Boolean release)
+  : 
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
+  TAO_Unbounded_String_Sequence
+#else /* TAO_USE_SEQUENCE_TEMPLATES */
+  TAO_Unbounded_String_Sequence
+#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
+ (max, length, buffer, release)
+{}
+IR_ContextIdSeq::IR_ContextIdSeq (const IR_ContextIdSeq &seq) // copy ctor
+  : 
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
+  TAO_Unbounded_String_Sequence
+#else /* TAO_USE_SEQUENCE_TEMPLATES */
+  TAO_Unbounded_String_Sequence
+#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
+ (seq)
+{}
+IR_ContextIdSeq::~IR_ContextIdSeq (void) // dtor
+{}
+void IR_ContextIdSeq::_tao_any_destructor (void *x)
+{
+  IR_ContextIdSeq *tmp = ACE_static_cast (IR_ContextIdSeq*,x);
+  delete tmp;
+}
+
+static const CORBA::Long _oc_IR_ContextIdSeq[] =
+{
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ContextIdSeq:1.0
+  13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
+  CORBA::tk_sequence, // typecode kind
+  160, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    CORBA::tk_alias, // typecode kind for typedefs
+    144, // encapsulation length
+      TAO_ENCAP_BYTE_ORDER, // byte order
+      37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ContextIdentifier:1.0
+      18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
+      CORBA::tk_alias, // typecode kind for typedefs
+      64, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+        CORBA::tk_string, 
+        0U, // string length
+
+
+    0U,
+
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_ContextIdSeq (CORBA::tk_alias, sizeof (_oc_IR_ContextIdSeq), (char *) &_oc_IR_ContextIdSeq, 0, sizeof (IR_ContextIdSeq));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ContextIdSeq, &_tc_TAO_tc_IR_ContextIdSeq)
+TAO_NAMESPACE_END
+
+///////////////////////////////////////////////////////////////////////
+//                Base & Remote Proxy  Implementation. 
+//
+
+_TAO_OperationDef_Proxy_Impl::_TAO_OperationDef_Proxy_Impl (void)
+{}
+
+_TAO_OperationDef_Remote_Proxy_Impl::_TAO_OperationDef_Remote_Proxy_Impl (void)
+{}
+
+// Remote Implementation of the IDL interface methods
+
+CORBA::TypeCode_ptr _TAO_OperationDef_Remote_Proxy_Impl::result (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
   
-#endif  /* TAO_HAS_INTERCEPTORS */
+  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
+  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
   
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_def_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::IDLType_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_result",
+      11,
+      0,
+      istub->orb_core ()
+    );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
         }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
-void IR::_TAO_ArrayDef_Remote_Proxy_Impl::element_type_def (
+IR_IDLType_ptr _TAO_OperationDef_Remote_Proxy_Impl::result_def (
     CORBA_Object *_collocated_tao_target_,
-    IR::IDLType_ptr element_type_def,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -25545,374 +16315,264 @@
   ))
 {
   
-
+  IR_IDLType_ptr _tao_retval = IR_IDLType::_nil ();
+  IR_IDLType_var _tao_safe_retval (_tao_retval);
   
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
-    ACE_THROW (CORBA::INTERNAL ());
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
   
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_set_element_type_def",
-      21,
-      1,
+      "_get_result_def",
+      15,
+      0,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_def_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        element_type_def,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << element_type_def)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
         }
-      
-      break;
-    }
-  
-}
-
-
-//
-//            End  Base & Remote  Proxy Implemeentation. 
-///////////////////////////////////////////////////////////////////////
-
-
-///////////////////////////////////////////////////////////////////////
-//           Remote & Base  Proxy Broker Implementation
-//
-
-IR::_TAO_ArrayDef_Proxy_Broker::_TAO_ArrayDef_Proxy_Broker (void)
-{
-}
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-IR::_TAO_ArrayDef_Proxy_Broker::~_TAO_ArrayDef_Proxy_Broker (void)
-{
+  return _tao_safe_retval._retn ();
 }
 
-// Factory Member function Implementation.
-IR::_TAO_ArrayDef_Remote_Proxy_Broker *IR::_TAO_ArrayDef_Remote_Proxy_Broker::the_TAO_ArrayDef_Remote_Proxy_Broker (void)
+void _TAO_OperationDef_Remote_Proxy_Impl::result_def (
+    CORBA_Object *_collocated_tao_target_,
+    IR_IDLType_ptr result_def,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  static ::IR::_TAO_ArrayDef_Remote_Proxy_Broker remote_proxy_broker;
-  return &remote_proxy_broker;
-}
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW (CORBA::INTERNAL ());
 
-IR::_TAO_ArrayDef_Remote_Proxy_Broker::_TAO_ArrayDef_Remote_Proxy_Broker (void)
-{
-}
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_set_result_def",
+      15,
+      1,
+      istub->orb_core ()
+    );
 
-IR::_TAO_ArrayDef_Remote_Proxy_Broker::~_TAO_ArrayDef_Remote_Proxy_Broker (void)
-{
-}
-
-IR::_TAO_ArrayDef_Proxy_Impl&
-IR::_TAO_ArrayDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::ArrayDef *object,
-  CORBA::Environment &ACE_TRY_ENV
-)
-{
-  ACE_UNUSED_ARG (object);
-  ACE_UNUSED_ARG (ACE_TRY_ENV);
-  return remote_proxy_impl_;
-}
-
-
-//
-//           End Remote & Base Proxy Broker Implementation
-///////////////////////////////////////////////////////////////////////
-
-
-// default constructor
-IR::ArrayDef::ArrayDef (int collocated)
-{
-  this->_tao_setup_collocation (collocated);
-}
-
-// destructor
-IR::ArrayDef::~ArrayDef (void)
-{}
-
-void
-IR::ArrayDef::_tao_setup_collocation (int collocated)
-{
-  if (collocated)
-    this->the_TAO_ArrayDef_Proxy_Broker_ =
-      ::IR__TAO_ArrayDef_Proxy_Broker_Factory_function_pointer (this);
-  else
-    this->the_TAO_ArrayDef_Proxy_Broker_ =
-      ::IR::_TAO_ArrayDef_Remote_Proxy_Broker::the_TAO_ArrayDef_Remote_Proxy_Broker ();
-  
-  ACE_NESTED_CLASS (IR, IDLType)::_tao_setup_collocation (collocated);
-}
-
-void IR::ArrayDef::_tao_any_destructor (void *x)
-{
-  ArrayDef *tmp = ACE_static_cast (ArrayDef*,x);
-  CORBA::release (tmp);
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << result_def)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
+        }
+        
+        break;
+      }
 }
 
-IR::ArrayDef_ptr IR::ArrayDef::_narrow (
-    CORBA::Object_ptr obj,
+IR_ParDescriptionSeq * _TAO_OperationDef_Remote_Proxy_Impl::params (
+    CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  if (CORBA::is_nil (obj))
-    return ArrayDef::_nil ();
-  if (! obj->_is_local ())
-    {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ArrayDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (ArrayDef::_nil ());
-      if (is_a == 0)
-        return ArrayDef::_nil ();
-    }
-  return ArrayDef::_unchecked_narrow (obj, ACE_TRY_ENV);
-}
+  
+  IR_ParDescriptionSeq *_tao_retval = 0;
+  
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-IR::ArrayDef_ptr IR::ArrayDef::_unchecked_narrow (
-    CORBA::Object_ptr obj,
-    CORBA::Environment &
-  )
-{
-  if (CORBA::is_nil (obj))
-    return ArrayDef::_nil ();
-  if (! obj->_is_local ())
-    {
-      TAO_Stub* stub = obj->_stubobj ();
-      if (stub)
-        stub->_incr_refcnt ();
-      ArrayDef_ptr default_proxy = ArrayDef::_nil ();
+  
+  ACE_NEW_RETURN (_tao_retval, IR_ParDescriptionSeq, _tao_retval);
+  IR_ParDescriptionSeq_var _tao_safe_retval (_tao_retval);
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_params",
+      11,
+      0,
+      istub->orb_core ()
+    );
 
-      if (
-          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
-          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_ArrayDef_Proxy_Broker_Factory_function_pointer != 0
-        )
+      for (;;)
       {
-        ACE_NEW_RETURN (
-          default_proxy,
-          ::IR::ArrayDef (
-            stub,
-            1,
-            obj->_servant ()),
-            
-          ArrayDef::_nil ());
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
         }
-      if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::ArrayDef (stub, 0, obj->_servant ()), ArrayDef::_nil ());
-        return default_proxy;
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
       }
-    else 
-      return
-        ACE_reinterpret_cast
-          (
-            ArrayDef_ptr,
-              obj->_tao_QueryInterface
-                (
-                  ACE_reinterpret_cast
-                    (
-                      ptr_arith_t,
-                      &ArrayDef::_narrow
-                    )
-                )
-          );
-}
-
-IR::ArrayDef_ptr
-IR::ArrayDef::_duplicate (ArrayDef_ptr obj)
-{
-  if (!CORBA::is_nil (obj))
-    obj->_add_ref ();
-  return obj;
-}
-
-CORBA::Boolean IR::ArrayDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
-{
-  if (
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ArrayDef:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
-  return 1; // success using local knowledge
-  else
-    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
-}
-
-void *IR::ArrayDef::_tao_QueryInterface (ptr_arith_t type)
-{
-  void *retv = 0;
-  if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, ArrayDef)::_narrow))
-    retv = ACE_reinterpret_cast (void*, this);
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, IDLType)::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            IR::IDLType_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            CORBA::IRObject_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
-    retv = ACE_reinterpret_cast (void *,
-      ACE_static_cast (CORBA::Object_ptr, this));
-    
-  if (retv)
-    this->_add_ref ();
-  return retv;
-}
 
-const char* IR::ArrayDef::_interface_repository_id (void) const
-{
-  return "IDL:omg.org/IR/ArrayDef:1.0";
+  return _tao_safe_retval._retn ();
 }
 
-CORBA::ULong IR::ArrayDef::length (
+void _TAO_OperationDef_Remote_Proxy_Impl::params (
+    CORBA_Object *_collocated_tao_target_,
+    const IR_ParDescriptionSeq & params,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-  return this->the_TAO_ArrayDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).length (
-      this,
-      ACE_TRY_ENV
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW (CORBA::INTERNAL ());
+
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_set_params",
+      11,
+      1,
+      istub->orb_core ()
     );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << params)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
+        }
+        
+        break;
+      }
 }
 
-void IR::ArrayDef::length (
-    CORBA::ULong length,
+IR_OperationMode _TAO_OperationDef_Remote_Proxy_Impl::mode (
+    CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -25920,364 +16580,129 @@
   ))
 {
   
-  this->the_TAO_ArrayDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).length (
-      this,
-      length,
-      ACE_TRY_ENV
+  IR_OperationMode _tao_retval = (IR_OperationMode)0;
+  
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
+
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_mode",
+      9,
+      0,
+      istub->orb_core ()
     );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN  (_tao_retval);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              _tao_retval
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_retval)
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                _tao_retval
+              );
+          }
+        break;
+      }
+
+  return _tao_retval;
 }
 
-CORBA::TypeCode_ptr IR::ArrayDef::element_type (
+void _TAO_OperationDef_Remote_Proxy_Impl::mode (
+    CORBA_Object *_collocated_tao_target_,
+    IR_OperationMode mode,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-  return this->the_TAO_ArrayDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).element_type (
-      this,
-      ACE_TRY_ENV
-    );
-}
-
-IR::IDLType_ptr IR::ArrayDef::element_type_def (
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_ArrayDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).element_type_def (
-      this,
-      ACE_TRY_ENV
-    );
-}
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW (CORBA::INTERNAL ());
 
-void IR::ArrayDef::element_type_def (
-    IR::IDLType_ptr element_type_def,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  this->the_TAO_ArrayDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).element_type_def (
-      this,
-      element_type_def,
-      ACE_TRY_ENV
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_set_mode",
+      9,
+      1,
+      istub->orb_core ()
     );
-}
-
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-IR::ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_length_get::TAO_ClientRequestInfo_IR_ArrayDef_length_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_length_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_length_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_length_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_length_get::result (CORBA::ULong result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_length_set::TAO_ClientRequestInfo_IR_ArrayDef_length_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const CORBA::ULong & length,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    length_ (length)
-{}
-
-Dynamic::ParameterList *
-IR::ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_length_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_length = parameter_list->length ();
-  parameter_list->length (length_length + 1);
-  (*parameter_list)[length_length].argument <<= length_;
-  (*parameter_list)[length_length].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_length_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_length_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
-}
-
-IR::ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_get::TAO_ClientRequestInfo_IR_ArrayDef_element_type_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_get::result (CORBA::TypeCode_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_def_get::TAO_ClientRequestInfo_IR_ArrayDef_element_type_def_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_def_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_def_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_def_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_def_get::result (IR::IDLType_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_def_set::TAO_ClientRequestInfo_IR_ArrayDef_element_type_def_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    IR::IDLType_ptr element_type_def,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    element_type_def_ (element_type_def)
-{}
-
-Dynamic::ParameterList *
-IR::ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_def_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_element_type_def = parameter_list->length ();
-  parameter_list->length (length_element_type_def + 1);
-  (*parameter_list)[length_element_type_def].argument <<=  this->element_type_def_;
-  
-  (*parameter_list)[length_element_type_def].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_def_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
 
-CORBA::Any * 
-IR::ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_def_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << mode)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
+        }
+        
+        break;
+      }
 }
 
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_ArrayDef[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x72726179), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ArrayDef:1.0
-  9, ACE_NTOHL (0x41727261), ACE_NTOHL (0x79446566), ACE_NTOHL (0x0),  // name = ArrayDef
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_ArrayDef (CORBA::tk_objref, sizeof (_oc_IR_ArrayDef), (char *) &_oc_IR_ArrayDef, 0, sizeof (IR::ArrayDef));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ArrayDef, &_tc_TAO_tc_IR_ArrayDef)
-TAO_NAMESPACE_END
-
-///////////////////////////////////////////////////////////////////////
-//                Base & Remote Proxy  Implementation. 
-//
-
-IR::_TAO_ExceptionDef_Proxy_Impl::_TAO_ExceptionDef_Proxy_Impl (void)
-{}
-
-IR::_TAO_ExceptionDef_Remote_Proxy_Impl::_TAO_ExceptionDef_Remote_Proxy_Impl (void)
-{}
-
-// Remote Implementation of the IDL interface methods
-
-CORBA::TypeCode_ptr IR::_TAO_ExceptionDef_Remote_Proxy_Impl::type (
+IR_ContextIdSeq * _TAO_OperationDef_Remote_Proxy_Impl::contexts (
     CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -26286,8 +16711,7 @@
   ))
 {
   
-  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
-  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
+  IR_ContextIdSeq *_tao_retval = 0;
   
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
@@ -26295,312 +16719,124 @@
     ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
   
+  ACE_NEW_RETURN (_tao_retval, IR_ContextIdSeq, _tao_retval);
+  IR_ContextIdSeq_var _tao_safe_retval (_tao_retval);
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_get_type",
-      9,
+      "_get_contexts",
+      13,
       0,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_type_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              CORBA::TypeCode_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
         }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
-IR::StructMemberSeq * IR::_TAO_ExceptionDef_Remote_Proxy_Impl::members (
+void _TAO_OperationDef_Remote_Proxy_Impl::contexts (
     CORBA_Object *_collocated_tao_target_,
+    const IR_ContextIdSeq & contexts,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-  IR::StructMemberSeq *_tao_retval = 0;
-  
-  
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+    ACE_THROW (CORBA::INTERNAL ());
 
-  
-  ACE_NEW_RETURN (_tao_retval, IR::StructMemberSeq, _tao_retval);
-  IR::StructMemberSeq_var _tao_safe_retval (_tao_retval);
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_get_members",
-      12,
-      0,
+      "_set_contexts",
+      13,
+      1,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_members_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::StructMemberSeq * _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << contexts)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
       
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
         }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
+        
+        break;
+      }
 }
 
-void IR::_TAO_ExceptionDef_Remote_Proxy_Impl::members (
+IR_ExceptionDefSeq * _TAO_OperationDef_Remote_Proxy_Impl::exceptions (
     CORBA_Object *_collocated_tao_target_,
-    const IR::StructMemberSeq & members,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -26608,146 +16844,128 @@
   ))
 {
   
-
+  IR_ExceptionDefSeq *_tao_retval = 0;
   
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
-    ACE_THROW (CORBA::INTERNAL ());
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
   
+  ACE_NEW_RETURN (_tao_retval, IR_ExceptionDefSeq, _tao_retval);
+  IR_ExceptionDefSeq_var _tao_safe_retval (_tao_retval);
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_set_members",
-      12,
-      1,
+      "_get_exceptions",
+      15,
+      0,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_members_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        members,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << members)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
+
+  return _tao_safe_retval._retn ();
+}
+
+void _TAO_OperationDef_Remote_Proxy_Impl::exceptions (
+    CORBA_Object *_collocated_tao_target_,
+    const IR_ExceptionDefSeq & exceptions,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW (CORBA::INTERNAL ());
+
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_set_exceptions",
+      15,
+      1,
+      istub->orb_core ()
+    );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << exceptions)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
+          );
       
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
         }
-      
-      break;
-    }
-  
+        
+        break;
+      }
 }
 
 
@@ -26760,32 +16978,32 @@
 //           Remote & Base  Proxy Broker Implementation
 //
 
-IR::_TAO_ExceptionDef_Proxy_Broker::_TAO_ExceptionDef_Proxy_Broker (void)
+_TAO_OperationDef_Proxy_Broker::_TAO_OperationDef_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_ExceptionDef_Proxy_Broker::~_TAO_ExceptionDef_Proxy_Broker (void)
+_TAO_OperationDef_Proxy_Broker::~_TAO_OperationDef_Proxy_Broker (void)
 {
 }
 
-// Factory Member function Implementation.
-IR::_TAO_ExceptionDef_Remote_Proxy_Broker *IR::_TAO_ExceptionDef_Remote_Proxy_Broker::the_TAO_ExceptionDef_Remote_Proxy_Broker (void)
+// Factory function Implementation.
+_TAO_OperationDef_Remote_Proxy_Broker *the_TAO_OperationDef_Remote_Proxy_Broker (void)
 {
-  static ::IR::_TAO_ExceptionDef_Remote_Proxy_Broker remote_proxy_broker;
+  static ::_TAO_OperationDef_Remote_Proxy_Broker remote_proxy_broker;
   return &remote_proxy_broker;
 }
 
-IR::_TAO_ExceptionDef_Remote_Proxy_Broker::_TAO_ExceptionDef_Remote_Proxy_Broker (void)
+_TAO_OperationDef_Remote_Proxy_Broker::_TAO_OperationDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_ExceptionDef_Remote_Proxy_Broker::~_TAO_ExceptionDef_Remote_Proxy_Broker (void)
+_TAO_OperationDef_Remote_Proxy_Broker::~_TAO_OperationDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_ExceptionDef_Proxy_Impl&
-IR::_TAO_ExceptionDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::ExceptionDef *object,
+_TAO_OperationDef_Proxy_Impl&
+_TAO_OperationDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_OperationDef *object,
   CORBA::Environment &ACE_TRY_ENV
 )
 {
@@ -26801,115 +17019,114 @@
 
 
 // default constructor
-IR::ExceptionDef::ExceptionDef (int collocated)
+IR_OperationDef::IR_OperationDef (int collocated)
 {
   this->_tao_setup_collocation (collocated);
 }
 
 // destructor
-IR::ExceptionDef::~ExceptionDef (void)
+IR_OperationDef::~IR_OperationDef (void)
 {}
 
 void
-IR::ExceptionDef::_tao_setup_collocation (int collocated)
+IR_OperationDef::_tao_setup_collocation (int collocated)
 {
   if (collocated)
-    this->the_TAO_ExceptionDef_Proxy_Broker_ =
-      ::IR__TAO_ExceptionDef_Proxy_Broker_Factory_function_pointer (this);
+    this->the_TAO_OperationDef_Proxy_Broker_ =
+      _TAO_OperationDef_Proxy_Broker_Factory_function_pointer (this);
   else
-    this->the_TAO_ExceptionDef_Proxy_Broker_ =
-      ::IR::_TAO_ExceptionDef_Remote_Proxy_Broker::the_TAO_ExceptionDef_Remote_Proxy_Broker ();
+    this->the_TAO_OperationDef_Proxy_Broker_ =
+      ::the_TAO_OperationDef_Remote_Proxy_Broker ();
+  
+  IR_Contained::_tao_setup_collocation (collocated);
   
-  ACE_NESTED_CLASS (IR, Contained)::_tao_setup_collocation (collocated);
-  ACE_NESTED_CLASS (IR, Container)::_tao_setup_collocation (collocated);
 }
 
-void IR::ExceptionDef::_tao_any_destructor (void *x)
+void IR_OperationDef::_tao_any_destructor (void *x)
 {
-  ExceptionDef *tmp = ACE_static_cast (ExceptionDef*,x);
+  IR_OperationDef *tmp = ACE_static_cast (IR_OperationDef*,x);
   CORBA::release (tmp);
 }
 
-IR::ExceptionDef_ptr IR::ExceptionDef::_narrow (
+IR_OperationDef_ptr IR_OperationDef::_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
 {
   if (CORBA::is_nil (obj))
-    return ExceptionDef::_nil ();
+    return IR_OperationDef::_nil ();
   if (! obj->_is_local ())
     {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ExceptionDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (ExceptionDef::_nil ());
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/OperationDef:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (IR_OperationDef::_nil ());
       if (is_a == 0)
-        return ExceptionDef::_nil ();
+        return IR_OperationDef::_nil ();
     }
-  return ExceptionDef::_unchecked_narrow (obj, ACE_TRY_ENV);
+  return IR_OperationDef::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::ExceptionDef_ptr IR::ExceptionDef::_unchecked_narrow (
+IR_OperationDef_ptr IR_OperationDef::_unchecked_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &
   )
 {
   if (CORBA::is_nil (obj))
-    return ExceptionDef::_nil ();
+    return IR_OperationDef::_nil ();
   if (! obj->_is_local ())
     {
       TAO_Stub* stub = obj->_stubobj ();
       if (stub)
         stub->_incr_refcnt ();
-      ExceptionDef_ptr default_proxy = ExceptionDef::_nil ();
+      IR_OperationDef_ptr default_proxy = IR_OperationDef::_nil ();
 
       if (
           !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
           stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_ExceptionDef_Proxy_Broker_Factory_function_pointer != 0
+          obj->_is_collocated () &&_TAO_OperationDef_Proxy_Broker_Factory_function_pointer != 0
         )
       {
         ACE_NEW_RETURN (
           default_proxy,
-          ::IR::ExceptionDef (
+          ::IR_OperationDef (
             stub,
             1,
             obj->_servant ()),
             
-          ExceptionDef::_nil ());
+          IR_OperationDef::_nil ());
         }
       if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::ExceptionDef (stub, 0, obj->_servant ()), ExceptionDef::_nil ());
+        ACE_NEW_RETURN (default_proxy, ::IR_OperationDef (stub, 0, obj->_servant ()), IR_OperationDef::_nil ());
         return default_proxy;
       }
     else 
       return
         ACE_reinterpret_cast
           (
-            ExceptionDef_ptr,
+            IR_OperationDef_ptr,
               obj->_tao_QueryInterface
                 (
                   ACE_reinterpret_cast
                     (
                       ptr_arith_t,
-                      &ExceptionDef::_narrow
+                      &IR_OperationDef::_narrow
                     )
                 )
           );
 }
 
-IR::ExceptionDef_ptr
-IR::ExceptionDef::_duplicate (ExceptionDef_ptr obj)
+IR_OperationDef_ptr
+IR_OperationDef::_duplicate (IR_OperationDef_ptr obj)
 {
   if (!CORBA::is_nil (obj))
     obj->_add_ref ();
   return obj;
 }
 
-CORBA::Boolean IR::ExceptionDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+CORBA::Boolean IR_OperationDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
   if (
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ExceptionDef:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/OperationDef:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
   return 1; // success using local knowledge
@@ -26917,46 +17134,34 @@
     return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
 }
 
-void *IR::ExceptionDef::_tao_QueryInterface (ptr_arith_t type)
+void *IR_OperationDef::_tao_QueryInterface (ptr_arith_t type)
 {
   void *retv = 0;
   if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, ExceptionDef)::_narrow))
+      &IR_OperationDef::_narrow))
     retv = ACE_reinterpret_cast (void*, this);
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Contained)::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            IR::Contained_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Container)::_narrow))
+      &IR_Contained::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::Container_ptr,
+            IR_Contained_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
+      &CORBA_IRObject::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            CORBA::IRObject_ptr,
+            CORBA_IRObject_ptr,
             this
           )
       );
@@ -26969,12 +17174,12 @@
   return retv;
 }
 
-const char* IR::ExceptionDef::_interface_repository_id (void) const
+const char* IR_OperationDef::_interface_repository_id (void) const
 {
-  return "IDL:omg.org/IR/ExceptionDef:1.0";
+  return "IDL:omg.org/IR/OperationDef:1.0";
 }
 
-CORBA::TypeCode_ptr IR::ExceptionDef::type (
+CORBA::TypeCode_ptr IR_OperationDef::result (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -26982,13 +17187,13 @@
   ))
 {
   
-  return this->the_TAO_ExceptionDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type (
+  return this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).result (
       this,
       ACE_TRY_ENV
     );
 }
 
-IR::StructMemberSeq * IR::ExceptionDef::members (
+IR_IDLType_ptr IR_OperationDef::result_def (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -26996,14 +17201,14 @@
   ))
 {
   
-  return this->the_TAO_ExceptionDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).members (
+  return this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).result_def (
       this,
       ACE_TRY_ENV
     );
 }
 
-void IR::ExceptionDef::members (
-    const IR::StructMemberSeq & members,
+void IR_OperationDef::result_def (
+    IR_IDLType_ptr result_def,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -27011,201 +17216,151 @@
   ))
 {
   
-  this->the_TAO_ExceptionDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).members (
+  this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).result_def (
       this,
-      members,
+      result_def,
       ACE_TRY_ENV
     );
 }
 
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-IR::ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_type_get::TAO_ClientRequestInfo_IR_ExceptionDef_type_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
+IR_ParDescriptionSeq * IR_OperationDef::params (
+    CORBA::Environment &ACE_TRY_ENV
   )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
   
-  return exception_list;
+  return this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).params (
+      this,
+      ACE_TRY_ENV
+    );
 }
 
-
-CORBA::Any * 
-IR::ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_type_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+void IR_OperationDef::params (
+    const IR_ParDescriptionSeq & params,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
   
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_type_get::result (CORBA::TypeCode_ptr result)
-{
-  // update the result 
-  this->_result = result;
+  this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).params (
+      this,
+      params,
+      ACE_TRY_ENV
+    );
 }
 
-IR::ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_members_get::TAO_ClientRequestInfo_IR_ExceptionDef_members_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
+IR_OperationMode IR_OperationDef::mode (
+    CORBA::Environment &ACE_TRY_ENV
   )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_members_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
   
-  return parameter_list;
+  return this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).mode (
+      this,
+      ACE_TRY_ENV
+    );
 }
 
-Dynamic::ExceptionList *
-IR::ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_members_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+void IR_OperationDef::mode (
+    IR_OperationMode mode,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
   
-  return exception_list;
+  this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).mode (
+      this,
+      mode,
+      ACE_TRY_ENV
+    );
 }
 
-
-CORBA::Any * 
-IR::ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_members_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+IR_ContextIdSeq * IR_OperationDef::contexts (
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
   
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_members_get::result (IR::StructMemberSeq * result)
-{
-  // update the result 
-  this->_result = result;
+  return this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).contexts (
+      this,
+      ACE_TRY_ENV
+    );
 }
 
-IR::ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_members_set::TAO_ClientRequestInfo_IR_ExceptionDef_members_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const IR::StructMemberSeq & members,
-    CORBA::Environment &    
+void IR_OperationDef::contexts (
+    const IR_ContextIdSeq & contexts,
+    CORBA::Environment &ACE_TRY_ENV
   )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    members_ (members)
-{}
-
-Dynamic::ParameterList *
-IR::ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_members_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_members = parameter_list->length ();
-  parameter_list->length (length_members + 1);
-  (*parameter_list)[length_members].argument <<=  this->members_;
   
-  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
+  this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).contexts (
+      this,
+      contexts,
+      ACE_TRY_ENV
+    );
 }
 
-Dynamic::ExceptionList *
-IR::ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_members_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+IR_ExceptionDefSeq * IR_OperationDef::exceptions (
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
   
-  return exception_list;
+  return this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).exceptions (
+      this,
+      ACE_TRY_ENV
+    );
 }
 
-
-CORBA::Any * 
-IR::ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_members_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+void IR_OperationDef::exceptions (
+    const IR_ExceptionDefSeq & exceptions,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
   
-  return result_any;
+  this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).exceptions (
+      this,
+      exceptions,
+      ACE_TRY_ENV
+    );
 }
 
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_ExceptionDef[] =
+static const CORBA::Long _oc_IR_OperationDef[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
-  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDef:1.0
-  13, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446566), ACE_NTOHL (0x0),  // name = ExceptionDef
+  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OperationDef:1.0
+  13, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446566), ACE_NTOHL (0x0),  // name = IR_OperationDef
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_ExceptionDef (CORBA::tk_objref, sizeof (_oc_IR_ExceptionDef), (char *) &_oc_IR_ExceptionDef, 0, sizeof (IR::ExceptionDef));
+static CORBA::TypeCode _tc_TAO_tc_IR_OperationDef (CORBA::tk_objref, sizeof (_oc_IR_OperationDef), (char *) &_oc_IR_OperationDef, 0, sizeof (IR_OperationDef));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ExceptionDef, &_tc_TAO_tc_IR_ExceptionDef)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_OperationDef, &_tc_TAO_tc_IR_OperationDef)
 TAO_NAMESPACE_END
-static const CORBA::Long _oc_IR_ExceptionDescription[] =
+
+static const CORBA::Long _oc_IR_OperationDescription[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
-  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
-  21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
-  5, // member count
+  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OperationDescription:1.0
+  21, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = OperationDescription
+  9, // member count
   5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
   CORBA::tk_alias, // typecode kind for typedefs
   64, // encapsulation length
@@ -27242,283 +17397,327 @@
     CORBA::tk_string, 
     0U, // string length
 
-  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+  7, ACE_NTOHL (0x72657375), ACE_NTOHL (0x6c740000),  // name = result
   CORBA::tk_TypeCode,
 
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_ExceptionDescription (CORBA::tk_struct, sizeof (_oc_IR_ExceptionDescription), (char *) &_oc_IR_ExceptionDescription, 0, sizeof (IR::ExceptionDescription));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ExceptionDescription, &_tc_TAO_tc_IR_ExceptionDescription)
-TAO_NAMESPACE_END
-void IR::ExceptionDescription::_tao_any_destructor (void *x)
-{
-  ExceptionDescription *tmp = ACE_static_cast (ExceptionDescription*,x);
-  delete tmp;
-}
+  5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
+  CORBA::tk_enum, // typecode kind
+  100, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/OperationMode:1.0
+    14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
+    2, // member count
+    10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
+    10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY
 
+  9, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x65787473), ACE_NTOHL (0x0),  // name = contexts
+  CORBA::tk_alias, // typecode kind for typedefs
+  228, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ContextIdSeq:1.0
+    13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
+    CORBA::tk_sequence, // typecode kind
+    160, // encapsulation length
+      TAO_ENCAP_BYTE_ORDER, // byte order
+      CORBA::tk_alias, // typecode kind for typedefs
+      144, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ContextIdentifier:1.0
+        18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
+        CORBA::tk_alias, // typecode kind for typedefs
+        64, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+          CORBA::tk_string, 
+          0U, // string length
 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  
-#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_EXCEPTIONDEFSEQ_CS_)
-#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_EXCEPTIONDEFSEQ_CS_
 
-  // The Base_Sequence functions, please see tao/Sequence.h
-  void
-  IR::_TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::_allocate_buffer (CORBA::ULong length)
-  {
-    IR::ExceptionDef **tmp = 0;
-    tmp = _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::allocbuf (length);
-    
-    if (this->buffer_ != 0)
-    {
-      IR::ExceptionDef **old = ACE_reinterpret_cast (IR::ExceptionDef**, this->buffer_);
-      for (CORBA::ULong i = 0; i < this->length_; ++i)
-        if (!this->release_)
-          tmp[i] = IR::ExceptionDef::_duplicate (old[i]);
-        else
-          tmp[i] = old[i];
-        
-      if (this->release_)
-        delete[] old;
-      
-    }
-    this->buffer_ = tmp;
-  }
-  
-  void
-  IR::_TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::_deallocate_buffer (void)
-  {
-    if (this->buffer_ == 0 || this->release_ == 0)
-      return;
-    IR::ExceptionDef **tmp = ACE_reinterpret_cast (IR::ExceptionDef**, this->buffer_);
-    for (CORBA::ULong i = 0; i < this->length_; ++i)
-    {
-      CORBA::release (tmp[i]);
-      tmp[i] = IR::ExceptionDef::_nil ();
-    }
-    _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::freebuf (tmp);
-    this->buffer_ = 0;
-  }
-  
-  IR::_TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::~_TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq (void)
-  {
-    this->_deallocate_buffer ();
-  }
-  
-  void
-  IR::_TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
-  {
-    IR::ExceptionDef **tmp = ACE_reinterpret_cast (IR::ExceptionDef**, this->buffer_);
-    
-    for (CORBA::ULong i = nl; i < ol; ++i)
-    {
-      CORBA::release (tmp[i]);
-      tmp[i] = IR::ExceptionDef::_nil ();
-    }
-  }
-  void 
-  IR::_TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::_downcast (
-      void* target,
-      CORBA_Object *src,
-      CORBA_Environment &ACE_TRY_ENV
-    )
-  {
-    IR::ExceptionDef **tmp = ACE_static_cast (IR::ExceptionDef**, target);
-    *tmp = IR::ExceptionDef::_narrow (src, ACE_TRY_ENV);
-  }
+      0U,
 
-  CORBA_Object*
-  IR::_TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::_upcast (void *src) const
-  {
-    IR::ExceptionDef **tmp = ACE_static_cast (IR::ExceptionDef**, src);
-    return *tmp;
-  }
-  
-#endif /* end #if !defined */
 
+  11, ACE_NTOHL (0x70617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72730000),  // name = parameters
+  CORBA::tk_alias, // typecode kind for typedefs
+  484, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x61724465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParDescriptionSeq:1.0
+    18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
+    CORBA::tk_sequence, // typecode kind
+    404, // encapsulation length
+      TAO_ENCAP_BYTE_ORDER, // byte order
+      CORBA::tk_struct, // typecode kind
+      388, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ParameterDescription:1.0
+        21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
+        4, // member count
+        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+        CORBA::tk_alias, // typecode kind for typedefs
+        64, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+          CORBA::tk_string, 
+          0U, // string length
+
+        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+        CORBA::tk_TypeCode,
 
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
+        9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
+        CORBA::tk_objref, // typecode kind
+        48, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
+          8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType
+
+        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
+        CORBA::tk_enum, // typecode kind
+        116, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParameterMode:1.0
+          14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
+          3, // member count
+          9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
+          10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
+          12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT
+
+
+      0U,
+
+
+  11, ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = exceptions
+  CORBA::tk_alias, // typecode kind for typedefs
+  536, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
+    18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
+    CORBA::tk_sequence, // typecode kind
+    456, // encapsulation length
+      TAO_ENCAP_BYTE_ORDER, // byte order
+      CORBA::tk_struct, // typecode kind
+      440, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
+        21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
+        5, // member count
+        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+        CORBA::tk_alias, // typecode kind for typedefs
+        64, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+          CORBA::tk_string, 
+          0U, // string length
+
+        3, ACE_NTOHL (0x69640000),  // name = id
+        CORBA::tk_alias, // typecode kind for typedefs
+        68, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+          CORBA::tk_string, 
+          0U, // string length
+
+        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
+        CORBA::tk_alias, // typecode kind for typedefs
+        68, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+          CORBA::tk_string, 
+          0U, // string length
+
+        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
+        CORBA::tk_alias, // typecode kind for typedefs
+        64, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
+          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
+          CORBA::tk_string, 
+          0U, // string length
+
+        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+        CORBA::tk_TypeCode,
 
-#if !defined (_IR_EXCEPTIONDEFSEQ_CS_)
-#define _IR_EXCEPTIONDEFSEQ_CS_
+
+      0U,
+
+
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_OperationDescription (CORBA::tk_struct, sizeof (_oc_IR_OperationDescription), (char *) &_oc_IR_OperationDescription, 0, sizeof (IR_OperationDescription));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_OperationDescription, &_tc_TAO_tc_IR_OperationDescription)
+TAO_NAMESPACE_END
+
+void IR_OperationDescription::_tao_any_destructor (void *x)
+{
+  IR_OperationDescription *tmp = ACE_static_cast (IR_OperationDescription*,x);
+  delete tmp;
+}
 
 // *************************************************************
-// IR::ExceptionDefSeq
+// IR_RepositoryIdSeq
 // *************************************************************
 
-IR::ExceptionDefSeq::ExceptionDefSeq (void)
+IR_RepositoryIdSeq::IR_RepositoryIdSeq (void)
 {}
-IR::ExceptionDefSeq::ExceptionDefSeq (CORBA::ULong max) // uses max size
+IR_RepositoryIdSeq::IR_RepositoryIdSeq (CORBA::ULong max) // uses max size
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq
+  TAO_Unbounded_String_Sequence
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::ExceptionDef,IR::ExceptionDef_var>
+  TAO_Unbounded_String_Sequence
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max)
 {}
-IR::ExceptionDefSeq::ExceptionDefSeq (CORBA::ULong max, CORBA::ULong length, IR::ExceptionDef_ptr *buffer, CORBA::Boolean release)
+IR_RepositoryIdSeq::IR_RepositoryIdSeq (CORBA::ULong max, CORBA::ULong length, char * *buffer, CORBA::Boolean release)
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq
+  TAO_Unbounded_String_Sequence
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::ExceptionDef,IR::ExceptionDef_var>
+  TAO_Unbounded_String_Sequence
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max, length, buffer, release)
 {}
-IR::ExceptionDefSeq::ExceptionDefSeq (const ExceptionDefSeq &seq) // copy ctor
+IR_RepositoryIdSeq::IR_RepositoryIdSeq (const IR_RepositoryIdSeq &seq) // copy ctor
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq
+  TAO_Unbounded_String_Sequence
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<IR::ExceptionDef,IR::ExceptionDef_var>
+  TAO_Unbounded_String_Sequence
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (seq)
 {}
-IR::ExceptionDefSeq::~ExceptionDefSeq (void) // dtor
+IR_RepositoryIdSeq::~IR_RepositoryIdSeq (void) // dtor
 {}
-void IR::ExceptionDefSeq::_tao_any_destructor (void *x)
+void IR_RepositoryIdSeq::_tao_any_destructor (void *x)
 {
-  ExceptionDefSeq *tmp = ACE_static_cast (ExceptionDefSeq*,x);
+  IR_RepositoryIdSeq *tmp = ACE_static_cast (IR_RepositoryIdSeq*,x);
   delete tmp;
 }
 
-
-#endif /* end #if !defined */
-
-static const CORBA::Long _oc_IR_ExceptionDefSeq[] =
+static const CORBA::Long _oc_IR_RepositoryIdSeq[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
-  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ExceptionDefSeq:1.0
-  16, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446566), ACE_NTOHL (0x53657100),  // name = ExceptionDefSeq
+  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79496453), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/RepositoryIdSeq:1.0
+  16, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
   CORBA::tk_sequence, // typecode kind
-  76, // encapsulation length
+  84, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
-    CORBA::tk_objref, // typecode kind
-    60, // encapsulation length
+    CORBA::tk_alias, // typecode kind for typedefs
+    68, // encapsulation length
       TAO_ENCAP_BYTE_ORDER, // byte order
-      32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDef:1.0
-      13, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446566), ACE_NTOHL (0x0),  // name = ExceptionDef
+      32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+      CORBA::tk_string, 
+      0U, // string length
 
     0U,
 
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_ExceptionDefSeq (CORBA::tk_alias, sizeof (_oc_IR_ExceptionDefSeq), (char *) &_oc_IR_ExceptionDefSeq, 0, sizeof (IR::ExceptionDefSeq));
+static CORBA::TypeCode _tc_TAO_tc_IR_RepositoryIdSeq (CORBA::tk_alias, sizeof (_oc_IR_RepositoryIdSeq), (char *) &_oc_IR_RepositoryIdSeq, 0, sizeof (IR_RepositoryIdSeq));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ExceptionDefSeq, &_tc_TAO_tc_IR_ExceptionDefSeq)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RepositoryIdSeq, &_tc_TAO_tc_IR_RepositoryIdSeq)
 TAO_NAMESPACE_END
 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   
-#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_EXCDESCRIPTIONSEQ_CS_)
-#define __TAO_UNBOUNDED_SEQUENCE_IR_EXCDESCRIPTIONSEQ_CS_
-
   void
-  IR::_TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::_allocate_buffer (CORBA::ULong length)
+  _TAO_Unbounded_Sequence_IR_OpDescriptionSeq::_allocate_buffer (CORBA::ULong length)
   {
-    IR::ExceptionDescription* tmp = 0;
-    tmp = _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::allocbuf (length);
+    IR_OperationDescription* tmp = 0;
+    tmp = _TAO_Unbounded_Sequence_IR_OpDescriptionSeq::allocbuf (length);
     
     if (this->buffer_ != 0)
     {
-      IR::ExceptionDescription *old = ACE_reinterpret_cast (IR::ExceptionDescription *,this->buffer_);
+      IR_OperationDescription *old = ACE_reinterpret_cast (IR_OperationDescription *,this->buffer_);
       
       for (CORBA::ULong i = 0; i < this->length_; ++i)
         tmp[i] = old[i];
       
       if (this->release_)
-        _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::freebuf (old);
+        _TAO_Unbounded_Sequence_IR_OpDescriptionSeq::freebuf (old);
       
     }
     this->buffer_ = tmp;
   }
   
   void
-  IR::_TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::_deallocate_buffer (void)
+  _TAO_Unbounded_Sequence_IR_OpDescriptionSeq::_deallocate_buffer (void)
   {
     if (this->buffer_ == 0 || this->release_ == 0)
       return;
     
-    IR::ExceptionDescription *tmp = ACE_reinterpret_cast (IR::ExceptionDescription *,this->buffer_);
+    IR_OperationDescription *tmp = ACE_reinterpret_cast (IR_OperationDescription *,this->buffer_);
     
-    _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::freebuf (tmp);
+    _TAO_Unbounded_Sequence_IR_OpDescriptionSeq::freebuf (tmp);
     this->buffer_ = 0;
   } 
   
-  IR::_TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::~_TAO_Unbounded_Sequence_IR_ExcDescriptionSeq (void) // Dtor.
+  _TAO_Unbounded_Sequence_IR_OpDescriptionSeq::~_TAO_Unbounded_Sequence_IR_OpDescriptionSeq (void) // Dtor.
   {
     this->_deallocate_buffer ();
   }
   
-  
-#endif /* end #if !defined */
-
-
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 
-#if !defined (_IR_EXCDESCRIPTIONSEQ_CS_)
-#define _IR_EXCDESCRIPTIONSEQ_CS_
-
 // *************************************************************
-// IR::ExcDescriptionSeq
+// IR_OpDescriptionSeq
 // *************************************************************
 
-IR::ExcDescriptionSeq::ExcDescriptionSeq (void)
+IR_OpDescriptionSeq::IR_OpDescriptionSeq (void)
 {}
-IR::ExcDescriptionSeq::ExcDescriptionSeq (CORBA::ULong max) // uses max size
+IR_OpDescriptionSeq::IR_OpDescriptionSeq (CORBA::ULong max) // uses max size
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq
+  _TAO_Unbounded_Sequence_IR_OpDescriptionSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::ExceptionDescription>
+  TAO_Unbounded_Sequence<IR_OperationDescription>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max)
 {}
-IR::ExcDescriptionSeq::ExcDescriptionSeq (CORBA::ULong max, CORBA::ULong length, IR::ExceptionDescription *buffer, CORBA::Boolean release)
+IR_OpDescriptionSeq::IR_OpDescriptionSeq (CORBA::ULong max, CORBA::ULong length, IR_OperationDescription *buffer, CORBA::Boolean release)
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq
+  _TAO_Unbounded_Sequence_IR_OpDescriptionSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::ExceptionDescription>
+  TAO_Unbounded_Sequence<IR_OperationDescription>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max, length, buffer, release)
 {}
-IR::ExcDescriptionSeq::ExcDescriptionSeq (const ExcDescriptionSeq &seq) // copy ctor
+IR_OpDescriptionSeq::IR_OpDescriptionSeq (const IR_OpDescriptionSeq &seq) // copy ctor
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq
+  _TAO_Unbounded_Sequence_IR_OpDescriptionSeq
 #else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::ExceptionDescription>
+  TAO_Unbounded_Sequence<IR_OperationDescription>
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (seq)
 {}
-IR::ExcDescriptionSeq::~ExcDescriptionSeq (void) // dtor
+IR_OpDescriptionSeq::~IR_OpDescriptionSeq (void) // dtor
 {}
-void IR::ExcDescriptionSeq::_tao_any_destructor (void *x)
+void IR_OpDescriptionSeq::_tao_any_destructor (void *x)
 {
-  ExcDescriptionSeq *tmp = ACE_static_cast (ExcDescriptionSeq*,x);
+  IR_OpDescriptionSeq *tmp = ACE_static_cast (IR_OpDescriptionSeq*,x);
   delete tmp;
 }
 
-
-#endif /* end #if !defined */
-
-static const CORBA::Long _oc_IR_ExcDescriptionSeq[] =
+static const CORBA::Long _oc_IR_OpDescriptionSeq[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
-  37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
-  18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
+  36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OpDescriptionSeq:1.0
+  17, ACE_NTOHL (0x4f704465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x0),  // name = OpDescriptionSeq
   CORBA::tk_sequence, // typecode kind
-  456, // encapsulation length
+  1896, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
     CORBA::tk_struct, // typecode kind
-    440, // encapsulation length
+    1880, // encapsulation length
       TAO_ENCAP_BYTE_ORDER, // byte order
-      40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
-      21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
-      5, // member count
+      40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OperationDescription:1.0
+      21, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = OperationDescription
+      9, // member count
       5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
       CORBA::tk_alias, // typecode kind for typedefs
       64, // encapsulation length
@@ -27555,11712 +17754,446 @@
         CORBA::tk_string, 
         0U, // string length
 
-      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+      7, ACE_NTOHL (0x72657375), ACE_NTOHL (0x6c740000),  // name = result
       CORBA::tk_TypeCode,
 
+      5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
+      CORBA::tk_enum, // typecode kind
+      100, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/OperationMode:1.0
+        14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
+        2, // member count
+        10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
+        10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY
 
-    0U,
+      9, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x65787473), ACE_NTOHL (0x0),  // name = contexts
+      CORBA::tk_alias, // typecode kind for typedefs
+      228, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ContextIdSeq:1.0
+        13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
+        CORBA::tk_sequence, // typecode kind
+        160, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          CORBA::tk_alias, // typecode kind for typedefs
+          144, // encapsulation length
+            TAO_ENCAP_BYTE_ORDER, // byte order
+            37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ContextIdentifier:1.0
+            18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
+            CORBA::tk_alias, // typecode kind for typedefs
+            64, // encapsulation length
+              TAO_ENCAP_BYTE_ORDER, // byte order
+              30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+              11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+              CORBA::tk_string, 
+              0U, // string length
 
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_ExcDescriptionSeq (CORBA::tk_alias, sizeof (_oc_IR_ExcDescriptionSeq), (char *) &_oc_IR_ExcDescriptionSeq, 0, sizeof (IR::ExcDescriptionSeq));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ExcDescriptionSeq, &_tc_TAO_tc_IR_ExcDescriptionSeq)
-TAO_NAMESPACE_END
-static const CORBA::Long _oc_IR_AttributeMode[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/AttributeMode:1.0
-  14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
-  2, // member count
-  12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
-  14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_AttributeMode (CORBA::tk_enum, sizeof (_oc_IR_AttributeMode), (char *) &_oc_IR_AttributeMode, 0, sizeof (IR::AttributeMode));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AttributeMode, &_tc_TAO_tc_IR_AttributeMode)
-TAO_NAMESPACE_END
 
-///////////////////////////////////////////////////////////////////////
-//                Base & Remote Proxy  Implementation. 
-//
+          0U,
 
-IR::_TAO_AttributeDef_Proxy_Impl::_TAO_AttributeDef_Proxy_Impl (void)
-{}
 
-IR::_TAO_AttributeDef_Remote_Proxy_Impl::_TAO_AttributeDef_Remote_Proxy_Impl (void)
-{}
+      11, ACE_NTOHL (0x70617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72730000),  // name = parameters
+      CORBA::tk_alias, // typecode kind for typedefs
+      484, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x61724465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParDescriptionSeq:1.0
+        18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
+        CORBA::tk_sequence, // typecode kind
+        404, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          CORBA::tk_struct, // typecode kind
+          388, // encapsulation length
+            TAO_ENCAP_BYTE_ORDER, // byte order
+            40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ParameterDescription:1.0
+            21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
+            4, // member count
+            5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+            CORBA::tk_alias, // typecode kind for typedefs
+            64, // encapsulation length
+              TAO_ENCAP_BYTE_ORDER, // byte order
+              30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+              11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+              CORBA::tk_string, 
+              0U, // string length
 
-// Remote Implementation of the IDL interface methods
+            5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+            CORBA::tk_TypeCode,
 
-CORBA::TypeCode_ptr IR::_TAO_AttributeDef_Remote_Proxy_Impl::type (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
-  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+            9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
+            CORBA::tk_objref, // typecode kind
+            48, // encapsulation length
+              TAO_ENCAP_BYTE_ORDER, // byte order
+              27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
+              8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType
 
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_type",
-      9,
-      0,
-      istub->orb_core ()
-    );
+            5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
+            CORBA::tk_enum, // typecode kind
+            116, // encapsulation length
+              TAO_ENCAP_BYTE_ORDER, // byte order
+              33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParameterMode:1.0
+              14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
+              3, // member count
+              9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
+              10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
+              12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              CORBA::TypeCode_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
-}
+          0U,
 
-IR::IDLType_ptr IR::_TAO_AttributeDef_Remote_Proxy_Impl::type_def (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  IR::IDLType_ptr _tao_retval = IR::IDLType::_nil ();
-  IR::IDLType_var _tao_safe_retval (_tao_retval);
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_type_def",
-      13,
-      0,
-      istub->orb_core ()
-    );
+      11, ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = exceptions
+      CORBA::tk_alias, // typecode kind for typedefs
+      536, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
+        18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
+        CORBA::tk_sequence, // typecode kind
+        456, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          CORBA::tk_struct, // typecode kind
+          440, // encapsulation length
+            TAO_ENCAP_BYTE_ORDER, // byte order
+            40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
+            21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
+            5, // member count
+            5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+            CORBA::tk_alias, // typecode kind for typedefs
+            64, // encapsulation length
+              TAO_ENCAP_BYTE_ORDER, // byte order
+              30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+              11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+              CORBA::tk_string, 
+              0U, // string length
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
+            3, ACE_NTOHL (0x69640000),  // name = id
+            CORBA::tk_alias, // typecode kind for typedefs
+            68, // encapsulation length
+              TAO_ENCAP_BYTE_ORDER, // byte order
+              32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+              13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+              CORBA::tk_string, 
+              0U, // string length
+
+            11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
+            CORBA::tk_alias, // typecode kind for typedefs
+            68, // encapsulation length
+              TAO_ENCAP_BYTE_ORDER, // byte order
+              32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+              13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+              CORBA::tk_string, 
+              0U, // string length
+
+            8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
+            CORBA::tk_alias, // typecode kind for typedefs
+            64, // encapsulation length
+              TAO_ENCAP_BYTE_ORDER, // byte order
+              31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
+              12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
+              CORBA::tk_string, 
+              0U, // string length
+
+            5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+            CORBA::tk_TypeCode,
+
+
+          0U,
+
+
+
+    0U,
+
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_OpDescriptionSeq (CORBA::tk_alias, sizeof (_oc_IR_OpDescriptionSeq), (char *) &_oc_IR_OpDescriptionSeq, 0, sizeof (IR_OpDescriptionSeq));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_OpDescriptionSeq, &_tc_TAO_tc_IR_OpDescriptionSeq)
+TAO_NAMESPACE_END
+
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   
-  for (;;)
+  void
+  _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::_allocate_buffer (CORBA::ULong length)
+  {
+    IR_AttributeDescription* tmp = 0;
+    tmp = _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::allocbuf (length);
+    
+    if (this->buffer_ != 0)
     {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
+      IR_AttributeDescription *old = ACE_reinterpret_cast (IR_AttributeDescription *,this->buffer_);
       
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_def_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::IDLType_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
+      for (CORBA::ULong i = 0; i < this->length_; ++i)
+        tmp[i] = old[i];
       
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
+      if (this->release_)
+        _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::freebuf (old);
       
-      break;
     }
-  return _tao_safe_retval._retn ();
-}
-
-void IR::_TAO_AttributeDef_Remote_Proxy_Impl::type_def (
-    CORBA_Object *_collocated_tao_target_,
-    IR::IDLType_ptr type_def,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
+    this->buffer_ = tmp;
+  }
   
-
+  void
+  _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::_deallocate_buffer (void)
+  {
+    if (this->buffer_ == 0 || this->release_ == 0)
+      return;
+    
+    IR_AttributeDescription *tmp = ACE_reinterpret_cast (IR_AttributeDescription *,this->buffer_);
+    
+    _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::freebuf (tmp);
+    this->buffer_ = 0;
+  } 
   
+  _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::~_TAO_Unbounded_Sequence_IR_AttrDescriptionSeq (void) // Dtor.
+  {
+    this->_deallocate_buffer ();
+  }
   
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW (CORBA::INTERNAL ());
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_set_type_def",
-      13,
-      1,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_def_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        type_def,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << type_def)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  
-}
+// *************************************************************
+// IR_AttrDescriptionSeq
+// *************************************************************
 
-IR::AttributeMode IR::_TAO_AttributeDef_Remote_Proxy_Impl::mode (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
+IR_AttrDescriptionSeq::IR_AttrDescriptionSeq (void)
+{}
+IR_AttrDescriptionSeq::IR_AttrDescriptionSeq (CORBA::ULong max) // uses max size
+  : 
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
+  _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq
+#else /* TAO_USE_SEQUENCE_TEMPLATES */
+  TAO_Unbounded_Sequence<IR_AttributeDescription>
+#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
+ (max)
+{}
+IR_AttrDescriptionSeq::IR_AttrDescriptionSeq (CORBA::ULong max, CORBA::ULong length, IR_AttributeDescription *buffer, CORBA::Boolean release)
+  : 
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
+  _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq
+#else /* TAO_USE_SEQUENCE_TEMPLATES */
+  TAO_Unbounded_Sequence<IR_AttributeDescription>
+#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
+ (max, length, buffer, release)
+{}
+IR_AttrDescriptionSeq::IR_AttrDescriptionSeq (const IR_AttrDescriptionSeq &seq) // copy ctor
+  : 
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
+  _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq
+#else /* TAO_USE_SEQUENCE_TEMPLATES */
+  TAO_Unbounded_Sequence<IR_AttributeDescription>
+#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
+ (seq)
+{}
+IR_AttrDescriptionSeq::~IR_AttrDescriptionSeq (void) // dtor
+{}
+void IR_AttrDescriptionSeq::_tao_any_destructor (void *x)
 {
-  
-  IR::AttributeMode _tao_retval = (IR::AttributeMode)0;
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_mode",
-      9,
-      0,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_mode_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_retval)
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::AttributeMode  _tao_retval_info = _tao_retval;
-               ri.result (_tao_retval_info);
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_retval;
+  IR_AttrDescriptionSeq *tmp = ACE_static_cast (IR_AttrDescriptionSeq*,x);
+  delete tmp;
 }
 
-void IR::_TAO_AttributeDef_Remote_Proxy_Impl::mode (
-    CORBA_Object *_collocated_tao_target_,
-    IR::AttributeMode mode,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
+static const CORBA::Long _oc_IR_AttrDescriptionSeq[] =
 {
-  
-
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW (CORBA::INTERNAL ());
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_set_mode",
-      9,
-      1,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_mode_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        mode,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << mode)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  
-}
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/AttrDescriptionSeq:1.0
+  19, ACE_NTOHL (0x41747472), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65710000),  // name = AttrDescriptionSeq
+  CORBA::tk_sequence, // typecode kind
+  1708, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    CORBA::tk_struct, // typecode kind
+    1692, // encapsulation length
+      TAO_ENCAP_BYTE_ORDER, // byte order
+      40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/AttributeDescription:1.0
+      21, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = AttributeDescription
+      8, // member count
+      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+      CORBA::tk_alias, // typecode kind for typedefs
+      64, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+        CORBA::tk_string, 
+        0U, // string length
 
+      3, ACE_NTOHL (0x69640000),  // name = id
+      CORBA::tk_alias, // typecode kind for typedefs
+      68, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+        CORBA::tk_string, 
+        0U, // string length
 
-//
-//            End  Base & Remote  Proxy Implemeentation. 
-///////////////////////////////////////////////////////////////////////
+      11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
+      CORBA::tk_alias, // typecode kind for typedefs
+      68, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+        CORBA::tk_string, 
+        0U, // string length
 
+      8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
+      CORBA::tk_alias, // typecode kind for typedefs
+      64, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
+        12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
+        CORBA::tk_string, 
+        0U, // string length
 
-///////////////////////////////////////////////////////////////////////
-//           Remote & Base  Proxy Broker Implementation
-//
+      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+      CORBA::tk_TypeCode,
 
-IR::_TAO_AttributeDef_Proxy_Broker::_TAO_AttributeDef_Proxy_Broker (void)
-{
-}
+      5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
+      CORBA::tk_enum, // typecode kind
+      104, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/AttributeMode:1.0
+        14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
+        2, // member count
+        12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
+        14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY
 
-IR::_TAO_AttributeDef_Proxy_Broker::~_TAO_AttributeDef_Proxy_Broker (void)
-{
-}
+      15, ACE_NTOHL (0x6765745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = get_exceptions
+      CORBA::tk_alias, // typecode kind for typedefs
+      536, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
+        18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
+        CORBA::tk_sequence, // typecode kind
+        456, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          CORBA::tk_struct, // typecode kind
+          440, // encapsulation length
+            TAO_ENCAP_BYTE_ORDER, // byte order
+            40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
+            21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
+            5, // member count
+            5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+            CORBA::tk_alias, // typecode kind for typedefs
+            64, // encapsulation length
+              TAO_ENCAP_BYTE_ORDER, // byte order
+              30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+              11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+              CORBA::tk_string, 
+              0U, // string length
 
-// Factory Member function Implementation.
-IR::_TAO_AttributeDef_Remote_Proxy_Broker *IR::_TAO_AttributeDef_Remote_Proxy_Broker::the_TAO_AttributeDef_Remote_Proxy_Broker (void)
-{
-  static ::IR::_TAO_AttributeDef_Remote_Proxy_Broker remote_proxy_broker;
-  return &remote_proxy_broker;
-}
-
-IR::_TAO_AttributeDef_Remote_Proxy_Broker::_TAO_AttributeDef_Remote_Proxy_Broker (void)
-{
-}
-
-IR::_TAO_AttributeDef_Remote_Proxy_Broker::~_TAO_AttributeDef_Remote_Proxy_Broker (void)
-{
-}
-
-IR::_TAO_AttributeDef_Proxy_Impl&
-IR::_TAO_AttributeDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::AttributeDef *object,
-  CORBA::Environment &ACE_TRY_ENV
-)
-{
-  ACE_UNUSED_ARG (object);
-  ACE_UNUSED_ARG (ACE_TRY_ENV);
-  return remote_proxy_impl_;
-}
-
-
-//
-//           End Remote & Base Proxy Broker Implementation
-///////////////////////////////////////////////////////////////////////
-
-
-// default constructor
-IR::AttributeDef::AttributeDef (int collocated)
-{
-  this->_tao_setup_collocation (collocated);
-}
-
-// destructor
-IR::AttributeDef::~AttributeDef (void)
-{}
-
-void
-IR::AttributeDef::_tao_setup_collocation (int collocated)
-{
-  if (collocated)
-    this->the_TAO_AttributeDef_Proxy_Broker_ =
-      ::IR__TAO_AttributeDef_Proxy_Broker_Factory_function_pointer (this);
-  else
-    this->the_TAO_AttributeDef_Proxy_Broker_ =
-      ::IR::_TAO_AttributeDef_Remote_Proxy_Broker::the_TAO_AttributeDef_Remote_Proxy_Broker ();
-  
-  ACE_NESTED_CLASS (IR, Contained)::_tao_setup_collocation (collocated);
-}
-
-void IR::AttributeDef::_tao_any_destructor (void *x)
-{
-  AttributeDef *tmp = ACE_static_cast (AttributeDef*,x);
-  CORBA::release (tmp);
-}
-
-IR::AttributeDef_ptr IR::AttributeDef::_narrow (
-    CORBA::Object_ptr obj,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-{
-  if (CORBA::is_nil (obj))
-    return AttributeDef::_nil ();
-  if (! obj->_is_local ())
-    {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/AttributeDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (AttributeDef::_nil ());
-      if (is_a == 0)
-        return AttributeDef::_nil ();
-    }
-  return AttributeDef::_unchecked_narrow (obj, ACE_TRY_ENV);
-}
-
-IR::AttributeDef_ptr IR::AttributeDef::_unchecked_narrow (
-    CORBA::Object_ptr obj,
-    CORBA::Environment &
-  )
-{
-  if (CORBA::is_nil (obj))
-    return AttributeDef::_nil ();
-  if (! obj->_is_local ())
-    {
-      TAO_Stub* stub = obj->_stubobj ();
-      if (stub)
-        stub->_incr_refcnt ();
-      AttributeDef_ptr default_proxy = AttributeDef::_nil ();
-
-      if (
-          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
-          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_AttributeDef_Proxy_Broker_Factory_function_pointer != 0
-        )
-      {
-        ACE_NEW_RETURN (
-          default_proxy,
-          ::IR::AttributeDef (
-            stub,
-            1,
-            obj->_servant ()),
-            
-          AttributeDef::_nil ());
-        }
-      if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::AttributeDef (stub, 0, obj->_servant ()), AttributeDef::_nil ());
-        return default_proxy;
-      }
-    else 
-      return
-        ACE_reinterpret_cast
-          (
-            AttributeDef_ptr,
-              obj->_tao_QueryInterface
-                (
-                  ACE_reinterpret_cast
-                    (
-                      ptr_arith_t,
-                      &AttributeDef::_narrow
-                    )
-                )
-          );
-}
-
-IR::AttributeDef_ptr
-IR::AttributeDef::_duplicate (AttributeDef_ptr obj)
-{
-  if (!CORBA::is_nil (obj))
-    obj->_add_ref ();
-  return obj;
-}
-
-CORBA::Boolean IR::AttributeDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
-{
-  if (
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/AttributeDef:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
-  return 1; // success using local knowledge
-  else
-    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
-}
-
-void *IR::AttributeDef::_tao_QueryInterface (ptr_arith_t type)
-{
-  void *retv = 0;
-  if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, AttributeDef)::_narrow))
-    retv = ACE_reinterpret_cast (void*, this);
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Contained)::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            IR::Contained_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            CORBA::IRObject_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
-    retv = ACE_reinterpret_cast (void *,
-      ACE_static_cast (CORBA::Object_ptr, this));
-    
-  if (retv)
-    this->_add_ref ();
-  return retv;
-}
-
-const char* IR::AttributeDef::_interface_repository_id (void) const
-{
-  return "IDL:omg.org/IR/AttributeDef:1.0";
-}
-
-CORBA::TypeCode_ptr IR::AttributeDef::type (
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_AttributeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type (
-      this,
-      ACE_TRY_ENV
-    );
-}
-
-IR::IDLType_ptr IR::AttributeDef::type_def (
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_AttributeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type_def (
-      this,
-      ACE_TRY_ENV
-    );
-}
-
-void IR::AttributeDef::type_def (
-    IR::IDLType_ptr type_def,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  this->the_TAO_AttributeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type_def (
-      this,
-      type_def,
-      ACE_TRY_ENV
-    );
-}
-
-IR::AttributeMode IR::AttributeDef::mode (
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_AttributeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).mode (
-      this,
-      ACE_TRY_ENV
-    );
-}
-
-void IR::AttributeDef::mode (
-    IR::AttributeMode mode,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  this->the_TAO_AttributeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).mode (
-      this,
-      mode,
-      ACE_TRY_ENV
-    );
-}
-
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-IR::AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_get::TAO_ClientRequestInfo_IR_AttributeDef_type_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_get::result (CORBA::TypeCode_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_def_get::TAO_ClientRequestInfo_IR_AttributeDef_type_def_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_def_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_def_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_def_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_def_get::result (IR::IDLType_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_def_set::TAO_ClientRequestInfo_IR_AttributeDef_type_def_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    IR::IDLType_ptr type_def,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    type_def_ (type_def)
-{}
-
-Dynamic::ParameterList *
-IR::AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_def_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_type_def = parameter_list->length ();
-  parameter_list->length (length_type_def + 1);
-  (*parameter_list)[length_type_def].argument <<=  this->type_def_;
-  
-  (*parameter_list)[length_type_def].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_def_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_def_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
-}
-
-IR::AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_mode_get::TAO_ClientRequestInfo_IR_AttributeDef_mode_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_mode_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_mode_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_mode_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_mode_get::result (IR::AttributeMode result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_mode_set::TAO_ClientRequestInfo_IR_AttributeDef_mode_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    IR::AttributeMode & mode,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    mode_ (mode)
-{}
-
-Dynamic::ParameterList *
-IR::AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_mode_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_mode = parameter_list->length ();
-  parameter_list->length (length_mode + 1);
-  (*parameter_list)[length_mode].argument <<=  this->mode_;
-  
-  (*parameter_list)[length_mode].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_mode_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_mode_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
-}
-
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_AttributeDef[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/AttributeDef:1.0
-  13, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = AttributeDef
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_AttributeDef (CORBA::tk_objref, sizeof (_oc_IR_AttributeDef), (char *) &_oc_IR_AttributeDef, 0, sizeof (IR::AttributeDef));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AttributeDef, &_tc_TAO_tc_IR_AttributeDef)
-TAO_NAMESPACE_END
-static const CORBA::Long _oc_IR_AttributeDescription[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/AttributeDescription:1.0
-  21, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = AttributeDescription
-  8, // member count
-  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-  CORBA::tk_alias, // typecode kind for typedefs
-  64, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-    CORBA::tk_string, 
-    0U, // string length
-
-  3, ACE_NTOHL (0x69640000),  // name = id
-  CORBA::tk_alias, // typecode kind for typedefs
-  68, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-    CORBA::tk_string, 
-    0U, // string length
-
-  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
-  CORBA::tk_alias, // typecode kind for typedefs
-  68, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-    CORBA::tk_string, 
-    0U, // string length
-
-  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
-  CORBA::tk_alias, // typecode kind for typedefs
-  64, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
-    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
-    CORBA::tk_string, 
-    0U, // string length
-
-  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
-  CORBA::tk_TypeCode,
-
-  5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
-  CORBA::tk_enum, // typecode kind
-  104, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/AttributeMode:1.0
-    14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
-    2, // member count
-    12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
-    14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY
-
-  15, ACE_NTOHL (0x6765745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = get_exceptions
-  CORBA::tk_alias, // typecode kind for typedefs
-  536, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
-    18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
-    CORBA::tk_sequence, // typecode kind
-    456, // encapsulation length
-      TAO_ENCAP_BYTE_ORDER, // byte order
-      CORBA::tk_struct, // typecode kind
-      440, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
-        21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
-        5, // member count
-        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-        CORBA::tk_alias, // typecode kind for typedefs
-        64, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-          CORBA::tk_string, 
-          0U, // string length
-
-        3, ACE_NTOHL (0x69640000),  // name = id
-        CORBA::tk_alias, // typecode kind for typedefs
-        68, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-          CORBA::tk_string, 
-          0U, // string length
-
-        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
-        CORBA::tk_alias, // typecode kind for typedefs
-        68, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-          CORBA::tk_string, 
-          0U, // string length
-
-        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
-        CORBA::tk_alias, // typecode kind for typedefs
-        64, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
-          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
-          CORBA::tk_string, 
-          0U, // string length
-
-        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
-        CORBA::tk_TypeCode,
-
-
-      0U,
-
-
-  15, ACE_NTOHL (0x7075745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = put_exceptions
-  CORBA::tk_alias, // typecode kind for typedefs
-  536, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
-    18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
-    CORBA::tk_sequence, // typecode kind
-    456, // encapsulation length
-      TAO_ENCAP_BYTE_ORDER, // byte order
-      CORBA::tk_struct, // typecode kind
-      440, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
-        21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
-        5, // member count
-        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-        CORBA::tk_alias, // typecode kind for typedefs
-        64, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-          CORBA::tk_string, 
-          0U, // string length
-
-        3, ACE_NTOHL (0x69640000),  // name = id
-        CORBA::tk_alias, // typecode kind for typedefs
-        68, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-          CORBA::tk_string, 
-          0U, // string length
-
-        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
-        CORBA::tk_alias, // typecode kind for typedefs
-        68, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-          CORBA::tk_string, 
-          0U, // string length
-
-        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
-        CORBA::tk_alias, // typecode kind for typedefs
-        64, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
-          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
-          CORBA::tk_string, 
-          0U, // string length
-
-        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
-        CORBA::tk_TypeCode,
-
-
-      0U,
-
-
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_AttributeDescription (CORBA::tk_struct, sizeof (_oc_IR_AttributeDescription), (char *) &_oc_IR_AttributeDescription, 0, sizeof (IR::AttributeDescription));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AttributeDescription, &_tc_TAO_tc_IR_AttributeDescription)
-TAO_NAMESPACE_END
-void IR::AttributeDescription::_tao_any_destructor (void *x)
-{
-  AttributeDescription *tmp = ACE_static_cast (AttributeDescription*,x);
-  delete tmp;
-}
-
-static const CORBA::Long _oc_IR_OperationMode[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/OperationMode:1.0
-  14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
-  2, // member count
-  10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
-  10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_OperationMode (CORBA::tk_enum, sizeof (_oc_IR_OperationMode), (char *) &_oc_IR_OperationMode, 0, sizeof (IR::OperationMode));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_OperationMode, &_tc_TAO_tc_IR_OperationMode)
-TAO_NAMESPACE_END
-static const CORBA::Long _oc_IR_ParameterMode[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParameterMode:1.0
-  14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
-  3, // member count
-  9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
-  10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
-  12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_ParameterMode (CORBA::tk_enum, sizeof (_oc_IR_ParameterMode), (char *) &_oc_IR_ParameterMode, 0, sizeof (IR::ParameterMode));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ParameterMode, &_tc_TAO_tc_IR_ParameterMode)
-TAO_NAMESPACE_END
-static const CORBA::Long _oc_IR_ParameterDescription[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ParameterDescription:1.0
-  21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
-  4, // member count
-  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-  CORBA::tk_alias, // typecode kind for typedefs
-  64, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-    CORBA::tk_string, 
-    0U, // string length
-
-  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
-  CORBA::tk_TypeCode,
-
-  9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
-  CORBA::tk_objref, // typecode kind
-  48, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
-    8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType
-
-  5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
-  CORBA::tk_enum, // typecode kind
-  116, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParameterMode:1.0
-    14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
-    3, // member count
-    9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
-    10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
-    12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT
-
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_ParameterDescription (CORBA::tk_struct, sizeof (_oc_IR_ParameterDescription), (char *) &_oc_IR_ParameterDescription, 0, sizeof (IR::ParameterDescription));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ParameterDescription, &_tc_TAO_tc_IR_ParameterDescription)
-TAO_NAMESPACE_END
-void IR::ParameterDescription::_tao_any_destructor (void *x)
-{
-  ParameterDescription *tmp = ACE_static_cast (ParameterDescription*,x);
-  delete tmp;
-}
-
-
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  
-#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_PARDESCRIPTIONSEQ_CS_)
-#define __TAO_UNBOUNDED_SEQUENCE_IR_PARDESCRIPTIONSEQ_CS_
-
-  void
-  IR::_TAO_Unbounded_Sequence_IR_ParDescriptionSeq::_allocate_buffer (CORBA::ULong length)
-  {
-    IR::ParameterDescription* tmp = 0;
-    tmp = _TAO_Unbounded_Sequence_IR_ParDescriptionSeq::allocbuf (length);
-    
-    if (this->buffer_ != 0)
-    {
-      IR::ParameterDescription *old = ACE_reinterpret_cast (IR::ParameterDescription *,this->buffer_);
-      
-      for (CORBA::ULong i = 0; i < this->length_; ++i)
-        tmp[i] = old[i];
-      
-      if (this->release_)
-        _TAO_Unbounded_Sequence_IR_ParDescriptionSeq::freebuf (old);
-      
-    }
-    this->buffer_ = tmp;
-  }
-  
-  void
-  IR::_TAO_Unbounded_Sequence_IR_ParDescriptionSeq::_deallocate_buffer (void)
-  {
-    if (this->buffer_ == 0 || this->release_ == 0)
-      return;
-    
-    IR::ParameterDescription *tmp = ACE_reinterpret_cast (IR::ParameterDescription *,this->buffer_);
-    
-    _TAO_Unbounded_Sequence_IR_ParDescriptionSeq::freebuf (tmp);
-    this->buffer_ = 0;
-  } 
-  
-  IR::_TAO_Unbounded_Sequence_IR_ParDescriptionSeq::~_TAO_Unbounded_Sequence_IR_ParDescriptionSeq (void) // Dtor.
-  {
-    this->_deallocate_buffer ();
-  }
-  
-  
-#endif /* end #if !defined */
-
-
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
-
-#if !defined (_IR_PARDESCRIPTIONSEQ_CS_)
-#define _IR_PARDESCRIPTIONSEQ_CS_
-
-// *************************************************************
-// IR::ParDescriptionSeq
-// *************************************************************
-
-IR::ParDescriptionSeq::ParDescriptionSeq (void)
-{}
-IR::ParDescriptionSeq::ParDescriptionSeq (CORBA::ULong max) // uses max size
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Sequence_IR_ParDescriptionSeq
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::ParameterDescription>
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (max)
-{}
-IR::ParDescriptionSeq::ParDescriptionSeq (CORBA::ULong max, CORBA::ULong length, IR::ParameterDescription *buffer, CORBA::Boolean release)
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Sequence_IR_ParDescriptionSeq
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::ParameterDescription>
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (max, length, buffer, release)
-{}
-IR::ParDescriptionSeq::ParDescriptionSeq (const ParDescriptionSeq &seq) // copy ctor
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Sequence_IR_ParDescriptionSeq
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::ParameterDescription>
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (seq)
-{}
-IR::ParDescriptionSeq::~ParDescriptionSeq (void) // dtor
-{}
-void IR::ParDescriptionSeq::_tao_any_destructor (void *x)
-{
-  ParDescriptionSeq *tmp = ACE_static_cast (ParDescriptionSeq*,x);
-  delete tmp;
-}
-
-
-#endif /* end #if !defined */
-
-static const CORBA::Long _oc_IR_ParDescriptionSeq[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x61724465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParDescriptionSeq:1.0
-  18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
-  CORBA::tk_sequence, // typecode kind
-  404, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    CORBA::tk_struct, // typecode kind
-    388, // encapsulation length
-      TAO_ENCAP_BYTE_ORDER, // byte order
-      40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ParameterDescription:1.0
-      21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
-      4, // member count
-      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-      CORBA::tk_alias, // typecode kind for typedefs
-      64, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-        CORBA::tk_string, 
-        0U, // string length
-
-      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
-      CORBA::tk_TypeCode,
-
-      9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
-      CORBA::tk_objref, // typecode kind
-      48, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
-        8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType
-
-      5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
-      CORBA::tk_enum, // typecode kind
-      116, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParameterMode:1.0
-        14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
-        3, // member count
-        9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
-        10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
-        12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT
-
-
-    0U,
-
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_ParDescriptionSeq (CORBA::tk_alias, sizeof (_oc_IR_ParDescriptionSeq), (char *) &_oc_IR_ParDescriptionSeq, 0, sizeof (IR::ParDescriptionSeq));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ParDescriptionSeq, &_tc_TAO_tc_IR_ParDescriptionSeq)
-TAO_NAMESPACE_END
-static const CORBA::Long _oc_IR_ContextIdentifier[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ContextIdentifier:1.0
-  18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
-  CORBA::tk_alias, // typecode kind for typedefs
-  64, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-    CORBA::tk_string, 
-    0U, // string length
-
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_ContextIdentifier (CORBA::tk_alias, sizeof (_oc_IR_ContextIdentifier), (char *) &_oc_IR_ContextIdentifier, 0, sizeof (IR::ContextIdentifier));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ContextIdentifier, &_tc_TAO_tc_IR_ContextIdentifier)
-TAO_NAMESPACE_END
-
-#if !defined (_IR_CONTEXTIDSEQ_CS_)
-#define _IR_CONTEXTIDSEQ_CS_
-
-// *************************************************************
-// IR::ContextIdSeq
-// *************************************************************
-
-IR::ContextIdSeq::ContextIdSeq (void)
-{}
-IR::ContextIdSeq::ContextIdSeq (CORBA::ULong max) // uses max size
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  TAO_Unbounded_String_Sequence
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_String_Sequence
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (max)
-{}
-IR::ContextIdSeq::ContextIdSeq (CORBA::ULong max, CORBA::ULong length, char * *buffer, CORBA::Boolean release)
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  TAO_Unbounded_String_Sequence
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_String_Sequence
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (max, length, buffer, release)
-{}
-IR::ContextIdSeq::ContextIdSeq (const ContextIdSeq &seq) // copy ctor
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  TAO_Unbounded_String_Sequence
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_String_Sequence
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (seq)
-{}
-IR::ContextIdSeq::~ContextIdSeq (void) // dtor
-{}
-void IR::ContextIdSeq::_tao_any_destructor (void *x)
-{
-  ContextIdSeq *tmp = ACE_static_cast (ContextIdSeq*,x);
-  delete tmp;
-}
-
-
-#endif /* end #if !defined */
-
-static const CORBA::Long _oc_IR_ContextIdSeq[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ContextIdSeq:1.0
-  13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
-  CORBA::tk_sequence, // typecode kind
-  160, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    CORBA::tk_alias, // typecode kind for typedefs
-    144, // encapsulation length
-      TAO_ENCAP_BYTE_ORDER, // byte order
-      37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ContextIdentifier:1.0
-      18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
-      CORBA::tk_alias, // typecode kind for typedefs
-      64, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-        CORBA::tk_string, 
-        0U, // string length
-
-
-    0U,
-
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_ContextIdSeq (CORBA::tk_alias, sizeof (_oc_IR_ContextIdSeq), (char *) &_oc_IR_ContextIdSeq, 0, sizeof (IR::ContextIdSeq));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ContextIdSeq, &_tc_TAO_tc_IR_ContextIdSeq)
-TAO_NAMESPACE_END
-
-///////////////////////////////////////////////////////////////////////
-//                Base & Remote Proxy  Implementation. 
-//
-
-IR::_TAO_OperationDef_Proxy_Impl::_TAO_OperationDef_Proxy_Impl (void)
-{}
-
-IR::_TAO_OperationDef_Remote_Proxy_Impl::_TAO_OperationDef_Remote_Proxy_Impl (void)
-{}
-
-// Remote Implementation of the IDL interface methods
-
-CORBA::TypeCode_ptr IR::_TAO_OperationDef_Remote_Proxy_Impl::result (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
-  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_result",
-      11,
-      0,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              CORBA::TypeCode_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
-}
-
-IR::IDLType_ptr IR::_TAO_OperationDef_Remote_Proxy_Impl::result_def (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  IR::IDLType_ptr _tao_retval = IR::IDLType::_nil ();
-  IR::IDLType_var _tao_safe_retval (_tao_retval);
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_result_def",
-      15,
-      0,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_def_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::IDLType_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
-}
-
-void IR::_TAO_OperationDef_Remote_Proxy_Impl::result_def (
-    CORBA_Object *_collocated_tao_target_,
-    IR::IDLType_ptr result_def,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW (CORBA::INTERNAL ());
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_set_result_def",
-      15,
-      1,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_def_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        result_def,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << result_def)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  
-}
-
-IR::ParDescriptionSeq * IR::_TAO_OperationDef_Remote_Proxy_Impl::params (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  IR::ParDescriptionSeq *_tao_retval = 0;
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
-  
-  ACE_NEW_RETURN (_tao_retval, IR::ParDescriptionSeq, _tao_retval);
-  IR::ParDescriptionSeq_var _tao_safe_retval (_tao_retval);
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_params",
-      11,
-      0,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_params_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::ParDescriptionSeq * _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
-}
-
-void IR::_TAO_OperationDef_Remote_Proxy_Impl::params (
-    CORBA_Object *_collocated_tao_target_,
-    const IR::ParDescriptionSeq & params,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW (CORBA::INTERNAL ());
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_set_params",
-      11,
-      1,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_params_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        params,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << params)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  
-}
-
-IR::OperationMode IR::_TAO_OperationDef_Remote_Proxy_Impl::mode (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  IR::OperationMode _tao_retval = (IR::OperationMode)0;
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_mode",
-      9,
-      0,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_mode_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_retval)
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::OperationMode  _tao_retval_info = _tao_retval;
-               ri.result (_tao_retval_info);
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_retval;
-}
-
-void IR::_TAO_OperationDef_Remote_Proxy_Impl::mode (
-    CORBA_Object *_collocated_tao_target_,
-    IR::OperationMode mode,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW (CORBA::INTERNAL ());
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_set_mode",
-      9,
-      1,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_mode_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        mode,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << mode)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  
-}
-
-IR::ContextIdSeq * IR::_TAO_OperationDef_Remote_Proxy_Impl::contexts (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  IR::ContextIdSeq *_tao_retval = 0;
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
-  
-  ACE_NEW_RETURN (_tao_retval, IR::ContextIdSeq, _tao_retval);
-  IR::ContextIdSeq_var _tao_safe_retval (_tao_retval);
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_contexts",
-      13,
-      0,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_contexts_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::ContextIdSeq * _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
-}
-
-void IR::_TAO_OperationDef_Remote_Proxy_Impl::contexts (
-    CORBA_Object *_collocated_tao_target_,
-    const IR::ContextIdSeq & contexts,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW (CORBA::INTERNAL ());
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_set_contexts",
-      13,
-      1,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_contexts_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        contexts,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << contexts)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  
-}
-
-IR::ExceptionDefSeq * IR::_TAO_OperationDef_Remote_Proxy_Impl::exceptions (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  IR::ExceptionDefSeq *_tao_retval = 0;
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
-  
-  ACE_NEW_RETURN (_tao_retval, IR::ExceptionDefSeq, _tao_retval);
-  IR::ExceptionDefSeq_var _tao_safe_retval (_tao_retval);
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_exceptions",
-      15,
-      0,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_exceptions_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::ExceptionDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
-}
-
-void IR::_TAO_OperationDef_Remote_Proxy_Impl::exceptions (
-    CORBA_Object *_collocated_tao_target_,
-    const IR::ExceptionDefSeq & exceptions,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW (CORBA::INTERNAL ());
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_set_exceptions",
-      15,
-      1,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_exceptions_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        exceptions,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << exceptions)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  
-}
-
-
-//
-//            End  Base & Remote  Proxy Implemeentation. 
-///////////////////////////////////////////////////////////////////////
-
-
-///////////////////////////////////////////////////////////////////////
-//           Remote & Base  Proxy Broker Implementation
-//
-
-IR::_TAO_OperationDef_Proxy_Broker::_TAO_OperationDef_Proxy_Broker (void)
-{
-}
-
-IR::_TAO_OperationDef_Proxy_Broker::~_TAO_OperationDef_Proxy_Broker (void)
-{
-}
-
-// Factory Member function Implementation.
-IR::_TAO_OperationDef_Remote_Proxy_Broker *IR::_TAO_OperationDef_Remote_Proxy_Broker::the_TAO_OperationDef_Remote_Proxy_Broker (void)
-{
-  static ::IR::_TAO_OperationDef_Remote_Proxy_Broker remote_proxy_broker;
-  return &remote_proxy_broker;
-}
-
-IR::_TAO_OperationDef_Remote_Proxy_Broker::_TAO_OperationDef_Remote_Proxy_Broker (void)
-{
-}
-
-IR::_TAO_OperationDef_Remote_Proxy_Broker::~_TAO_OperationDef_Remote_Proxy_Broker (void)
-{
-}
-
-IR::_TAO_OperationDef_Proxy_Impl&
-IR::_TAO_OperationDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::OperationDef *object,
-  CORBA::Environment &ACE_TRY_ENV
-)
-{
-  ACE_UNUSED_ARG (object);
-  ACE_UNUSED_ARG (ACE_TRY_ENV);
-  return remote_proxy_impl_;
-}
-
-
-//
-//           End Remote & Base Proxy Broker Implementation
-///////////////////////////////////////////////////////////////////////
-
-
-// default constructor
-IR::OperationDef::OperationDef (int collocated)
-{
-  this->_tao_setup_collocation (collocated);
-}
-
-// destructor
-IR::OperationDef::~OperationDef (void)
-{}
-
-void
-IR::OperationDef::_tao_setup_collocation (int collocated)
-{
-  if (collocated)
-    this->the_TAO_OperationDef_Proxy_Broker_ =
-      ::IR__TAO_OperationDef_Proxy_Broker_Factory_function_pointer (this);
-  else
-    this->the_TAO_OperationDef_Proxy_Broker_ =
-      ::IR::_TAO_OperationDef_Remote_Proxy_Broker::the_TAO_OperationDef_Remote_Proxy_Broker ();
-  
-  ACE_NESTED_CLASS (IR, Contained)::_tao_setup_collocation (collocated);
-}
-
-void IR::OperationDef::_tao_any_destructor (void *x)
-{
-  OperationDef *tmp = ACE_static_cast (OperationDef*,x);
-  CORBA::release (tmp);
-}
-
-IR::OperationDef_ptr IR::OperationDef::_narrow (
-    CORBA::Object_ptr obj,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-{
-  if (CORBA::is_nil (obj))
-    return OperationDef::_nil ();
-  if (! obj->_is_local ())
-    {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/OperationDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (OperationDef::_nil ());
-      if (is_a == 0)
-        return OperationDef::_nil ();
-    }
-  return OperationDef::_unchecked_narrow (obj, ACE_TRY_ENV);
-}
-
-IR::OperationDef_ptr IR::OperationDef::_unchecked_narrow (
-    CORBA::Object_ptr obj,
-    CORBA::Environment &
-  )
-{
-  if (CORBA::is_nil (obj))
-    return OperationDef::_nil ();
-  if (! obj->_is_local ())
-    {
-      TAO_Stub* stub = obj->_stubobj ();
-      if (stub)
-        stub->_incr_refcnt ();
-      OperationDef_ptr default_proxy = OperationDef::_nil ();
-
-      if (
-          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
-          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_OperationDef_Proxy_Broker_Factory_function_pointer != 0
-        )
-      {
-        ACE_NEW_RETURN (
-          default_proxy,
-          ::IR::OperationDef (
-            stub,
-            1,
-            obj->_servant ()),
-            
-          OperationDef::_nil ());
-        }
-      if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::OperationDef (stub, 0, obj->_servant ()), OperationDef::_nil ());
-        return default_proxy;
-      }
-    else 
-      return
-        ACE_reinterpret_cast
-          (
-            OperationDef_ptr,
-              obj->_tao_QueryInterface
-                (
-                  ACE_reinterpret_cast
-                    (
-                      ptr_arith_t,
-                      &OperationDef::_narrow
-                    )
-                )
-          );
-}
-
-IR::OperationDef_ptr
-IR::OperationDef::_duplicate (OperationDef_ptr obj)
-{
-  if (!CORBA::is_nil (obj))
-    obj->_add_ref ();
-  return obj;
-}
-
-CORBA::Boolean IR::OperationDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
-{
-  if (
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/OperationDef:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
-  return 1; // success using local knowledge
-  else
-    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
-}
-
-void *IR::OperationDef::_tao_QueryInterface (ptr_arith_t type)
-{
-  void *retv = 0;
-  if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, OperationDef)::_narrow))
-    retv = ACE_reinterpret_cast (void*, this);
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Contained)::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            IR::Contained_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            CORBA::IRObject_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
-    retv = ACE_reinterpret_cast (void *,
-      ACE_static_cast (CORBA::Object_ptr, this));
-    
-  if (retv)
-    this->_add_ref ();
-  return retv;
-}
-
-const char* IR::OperationDef::_interface_repository_id (void) const
-{
-  return "IDL:omg.org/IR/OperationDef:1.0";
-}
-
-CORBA::TypeCode_ptr IR::OperationDef::result (
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).result (
-      this,
-      ACE_TRY_ENV
-    );
-}
-
-IR::IDLType_ptr IR::OperationDef::result_def (
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).result_def (
-      this,
-      ACE_TRY_ENV
-    );
-}
-
-void IR::OperationDef::result_def (
-    IR::IDLType_ptr result_def,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).result_def (
-      this,
-      result_def,
-      ACE_TRY_ENV
-    );
-}
-
-IR::ParDescriptionSeq * IR::OperationDef::params (
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).params (
-      this,
-      ACE_TRY_ENV
-    );
-}
-
-void IR::OperationDef::params (
-    const IR::ParDescriptionSeq & params,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).params (
-      this,
-      params,
-      ACE_TRY_ENV
-    );
-}
-
-IR::OperationMode IR::OperationDef::mode (
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).mode (
-      this,
-      ACE_TRY_ENV
-    );
-}
-
-void IR::OperationDef::mode (
-    IR::OperationMode mode,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).mode (
-      this,
-      mode,
-      ACE_TRY_ENV
-    );
-}
-
-IR::ContextIdSeq * IR::OperationDef::contexts (
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).contexts (
-      this,
-      ACE_TRY_ENV
-    );
-}
-
-void IR::OperationDef::contexts (
-    const IR::ContextIdSeq & contexts,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).contexts (
-      this,
-      contexts,
-      ACE_TRY_ENV
-    );
-}
-
-IR::ExceptionDefSeq * IR::OperationDef::exceptions (
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).exceptions (
-      this,
-      ACE_TRY_ENV
-    );
-}
-
-void IR::OperationDef::exceptions (
-    const IR::ExceptionDefSeq & exceptions,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).exceptions (
-      this,
-      exceptions,
-      ACE_TRY_ENV
-    );
-}
-
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_get::TAO_ClientRequestInfo_IR_OperationDef_result_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_get::result (CORBA::TypeCode_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_def_get::TAO_ClientRequestInfo_IR_OperationDef_result_def_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_def_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_def_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_def_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_def_get::result (IR::IDLType_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_def_set::TAO_ClientRequestInfo_IR_OperationDef_result_def_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    IR::IDLType_ptr result_def,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    result_def_ (result_def)
-{}
-
-Dynamic::ParameterList *
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_def_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_result_def = parameter_list->length ();
-  parameter_list->length (length_result_def + 1);
-  (*parameter_list)[length_result_def].argument <<=  this->result_def_;
-  
-  (*parameter_list)[length_result_def].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_def_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_def_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
-}
-
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_params_get::TAO_ClientRequestInfo_IR_OperationDef_params_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_params_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_params_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_params_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_params_get::result (IR::ParDescriptionSeq * result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_params_set::TAO_ClientRequestInfo_IR_OperationDef_params_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const IR::ParDescriptionSeq & params,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    params_ (params)
-{}
-
-Dynamic::ParameterList *
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_params_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_params = parameter_list->length ();
-  parameter_list->length (length_params + 1);
-  (*parameter_list)[length_params].argument <<=  this->params_;
-  
-  (*parameter_list)[length_params].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_params_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_params_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
-}
-
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_mode_get::TAO_ClientRequestInfo_IR_OperationDef_mode_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_mode_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_mode_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_mode_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_mode_get::result (IR::OperationMode result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_mode_set::TAO_ClientRequestInfo_IR_OperationDef_mode_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    IR::OperationMode & mode,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    mode_ (mode)
-{}
-
-Dynamic::ParameterList *
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_mode_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_mode = parameter_list->length ();
-  parameter_list->length (length_mode + 1);
-  (*parameter_list)[length_mode].argument <<=  this->mode_;
-  
-  (*parameter_list)[length_mode].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_mode_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_mode_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
-}
-
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_contexts_get::TAO_ClientRequestInfo_IR_OperationDef_contexts_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_contexts_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_contexts_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_contexts_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_contexts_get::result (IR::ContextIdSeq * result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_contexts_set::TAO_ClientRequestInfo_IR_OperationDef_contexts_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const IR::ContextIdSeq & contexts,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    contexts_ (contexts)
-{}
-
-Dynamic::ParameterList *
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_contexts_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_contexts = parameter_list->length ();
-  parameter_list->length (length_contexts + 1);
-  (*parameter_list)[length_contexts].argument <<=  this->contexts_;
-  
-  (*parameter_list)[length_contexts].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_contexts_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_contexts_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
-}
-
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_exceptions_get::TAO_ClientRequestInfo_IR_OperationDef_exceptions_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_exceptions_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_exceptions_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_exceptions_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_exceptions_get::result (IR::ExceptionDefSeq * result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_exceptions_set::TAO_ClientRequestInfo_IR_OperationDef_exceptions_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const IR::ExceptionDefSeq & exceptions,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    exceptions_ (exceptions)
-{}
-
-Dynamic::ParameterList *
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_exceptions_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_exceptions = parameter_list->length ();
-  parameter_list->length (length_exceptions + 1);
-  (*parameter_list)[length_exceptions].argument <<=  this->exceptions_;
-  
-  (*parameter_list)[length_exceptions].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_exceptions_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::OperationDef::TAO_ClientRequestInfo_IR_OperationDef_exceptions_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
-}
-
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_OperationDef[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OperationDef:1.0
-  13, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446566), ACE_NTOHL (0x0),  // name = OperationDef
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_OperationDef (CORBA::tk_objref, sizeof (_oc_IR_OperationDef), (char *) &_oc_IR_OperationDef, 0, sizeof (IR::OperationDef));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_OperationDef, &_tc_TAO_tc_IR_OperationDef)
-TAO_NAMESPACE_END
-static const CORBA::Long _oc_IR_OperationDescription[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OperationDescription:1.0
-  21, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = OperationDescription
-  9, // member count
-  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-  CORBA::tk_alias, // typecode kind for typedefs
-  64, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-    CORBA::tk_string, 
-    0U, // string length
-
-  3, ACE_NTOHL (0x69640000),  // name = id
-  CORBA::tk_alias, // typecode kind for typedefs
-  68, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-    CORBA::tk_string, 
-    0U, // string length
-
-  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
-  CORBA::tk_alias, // typecode kind for typedefs
-  68, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-    CORBA::tk_string, 
-    0U, // string length
-
-  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
-  CORBA::tk_alias, // typecode kind for typedefs
-  64, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
-    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
-    CORBA::tk_string, 
-    0U, // string length
-
-  7, ACE_NTOHL (0x72657375), ACE_NTOHL (0x6c740000),  // name = result
-  CORBA::tk_TypeCode,
-
-  5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
-  CORBA::tk_enum, // typecode kind
-  100, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/OperationMode:1.0
-    14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
-    2, // member count
-    10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
-    10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY
-
-  9, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x65787473), ACE_NTOHL (0x0),  // name = contexts
-  CORBA::tk_alias, // typecode kind for typedefs
-  228, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ContextIdSeq:1.0
-    13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
-    CORBA::tk_sequence, // typecode kind
-    160, // encapsulation length
-      TAO_ENCAP_BYTE_ORDER, // byte order
-      CORBA::tk_alias, // typecode kind for typedefs
-      144, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ContextIdentifier:1.0
-        18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
-        CORBA::tk_alias, // typecode kind for typedefs
-        64, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-          CORBA::tk_string, 
-          0U, // string length
-
-
-      0U,
-
-
-  11, ACE_NTOHL (0x70617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72730000),  // name = parameters
-  CORBA::tk_alias, // typecode kind for typedefs
-  484, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x61724465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParDescriptionSeq:1.0
-    18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
-    CORBA::tk_sequence, // typecode kind
-    404, // encapsulation length
-      TAO_ENCAP_BYTE_ORDER, // byte order
-      CORBA::tk_struct, // typecode kind
-      388, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ParameterDescription:1.0
-        21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
-        4, // member count
-        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-        CORBA::tk_alias, // typecode kind for typedefs
-        64, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-          CORBA::tk_string, 
-          0U, // string length
-
-        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
-        CORBA::tk_TypeCode,
-
-        9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
-        CORBA::tk_objref, // typecode kind
-        48, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
-          8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType
-
-        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
-        CORBA::tk_enum, // typecode kind
-        116, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParameterMode:1.0
-          14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
-          3, // member count
-          9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
-          10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
-          12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT
-
-
-      0U,
-
-
-  11, ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = exceptions
-  CORBA::tk_alias, // typecode kind for typedefs
-  536, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
-    18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
-    CORBA::tk_sequence, // typecode kind
-    456, // encapsulation length
-      TAO_ENCAP_BYTE_ORDER, // byte order
-      CORBA::tk_struct, // typecode kind
-      440, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
-        21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
-        5, // member count
-        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-        CORBA::tk_alias, // typecode kind for typedefs
-        64, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-          CORBA::tk_string, 
-          0U, // string length
-
-        3, ACE_NTOHL (0x69640000),  // name = id
-        CORBA::tk_alias, // typecode kind for typedefs
-        68, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-          CORBA::tk_string, 
-          0U, // string length
-
-        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
-        CORBA::tk_alias, // typecode kind for typedefs
-        68, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-          CORBA::tk_string, 
-          0U, // string length
-
-        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
-        CORBA::tk_alias, // typecode kind for typedefs
-        64, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
-          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
-          CORBA::tk_string, 
-          0U, // string length
-
-        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
-        CORBA::tk_TypeCode,
-
-
-      0U,
-
-
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_OperationDescription (CORBA::tk_struct, sizeof (_oc_IR_OperationDescription), (char *) &_oc_IR_OperationDescription, 0, sizeof (IR::OperationDescription));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_OperationDescription, &_tc_TAO_tc_IR_OperationDescription)
-TAO_NAMESPACE_END
-void IR::OperationDescription::_tao_any_destructor (void *x)
-{
-  OperationDescription *tmp = ACE_static_cast (OperationDescription*,x);
-  delete tmp;
-}
-
-
-#if !defined (_IR_REPOSITORYIDSEQ_CS_)
-#define _IR_REPOSITORYIDSEQ_CS_
-
-// *************************************************************
-// IR::RepositoryIdSeq
-// *************************************************************
-
-IR::RepositoryIdSeq::RepositoryIdSeq (void)
-{}
-IR::RepositoryIdSeq::RepositoryIdSeq (CORBA::ULong max) // uses max size
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  TAO_Unbounded_String_Sequence
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_String_Sequence
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (max)
-{}
-IR::RepositoryIdSeq::RepositoryIdSeq (CORBA::ULong max, CORBA::ULong length, char * *buffer, CORBA::Boolean release)
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  TAO_Unbounded_String_Sequence
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_String_Sequence
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (max, length, buffer, release)
-{}
-IR::RepositoryIdSeq::RepositoryIdSeq (const RepositoryIdSeq &seq) // copy ctor
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  TAO_Unbounded_String_Sequence
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_String_Sequence
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (seq)
-{}
-IR::RepositoryIdSeq::~RepositoryIdSeq (void) // dtor
-{}
-void IR::RepositoryIdSeq::_tao_any_destructor (void *x)
-{
-  RepositoryIdSeq *tmp = ACE_static_cast (RepositoryIdSeq*,x);
-  delete tmp;
-}
-
-
-#endif /* end #if !defined */
-
-static const CORBA::Long _oc_IR_RepositoryIdSeq[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79496453), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/RepositoryIdSeq:1.0
-  16, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
-  CORBA::tk_sequence, // typecode kind
-  84, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    CORBA::tk_alias, // typecode kind for typedefs
-    68, // encapsulation length
-      TAO_ENCAP_BYTE_ORDER, // byte order
-      32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-      CORBA::tk_string, 
-      0U, // string length
-
-    0U,
-
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_RepositoryIdSeq (CORBA::tk_alias, sizeof (_oc_IR_RepositoryIdSeq), (char *) &_oc_IR_RepositoryIdSeq, 0, sizeof (IR::RepositoryIdSeq));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RepositoryIdSeq, &_tc_TAO_tc_IR_RepositoryIdSeq)
-TAO_NAMESPACE_END
-
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  
-#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_OPDESCRIPTIONSEQ_CS_)
-#define __TAO_UNBOUNDED_SEQUENCE_IR_OPDESCRIPTIONSEQ_CS_
-
-  void
-  IR::_TAO_Unbounded_Sequence_IR_OpDescriptionSeq::_allocate_buffer (CORBA::ULong length)
-  {
-    IR::OperationDescription* tmp = 0;
-    tmp = _TAO_Unbounded_Sequence_IR_OpDescriptionSeq::allocbuf (length);
-    
-    if (this->buffer_ != 0)
-    {
-      IR::OperationDescription *old = ACE_reinterpret_cast (IR::OperationDescription *,this->buffer_);
-      
-      for (CORBA::ULong i = 0; i < this->length_; ++i)
-        tmp[i] = old[i];
-      
-      if (this->release_)
-        _TAO_Unbounded_Sequence_IR_OpDescriptionSeq::freebuf (old);
-      
-    }
-    this->buffer_ = tmp;
-  }
-  
-  void
-  IR::_TAO_Unbounded_Sequence_IR_OpDescriptionSeq::_deallocate_buffer (void)
-  {
-    if (this->buffer_ == 0 || this->release_ == 0)
-      return;
-    
-    IR::OperationDescription *tmp = ACE_reinterpret_cast (IR::OperationDescription *,this->buffer_);
-    
-    _TAO_Unbounded_Sequence_IR_OpDescriptionSeq::freebuf (tmp);
-    this->buffer_ = 0;
-  } 
-  
-  IR::_TAO_Unbounded_Sequence_IR_OpDescriptionSeq::~_TAO_Unbounded_Sequence_IR_OpDescriptionSeq (void) // Dtor.
-  {
-    this->_deallocate_buffer ();
-  }
-  
-  
-#endif /* end #if !defined */
-
-
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
-
-#if !defined (_IR_OPDESCRIPTIONSEQ_CS_)
-#define _IR_OPDESCRIPTIONSEQ_CS_
-
-// *************************************************************
-// IR::OpDescriptionSeq
-// *************************************************************
-
-IR::OpDescriptionSeq::OpDescriptionSeq (void)
-{}
-IR::OpDescriptionSeq::OpDescriptionSeq (CORBA::ULong max) // uses max size
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Sequence_IR_OpDescriptionSeq
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::OperationDescription>
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (max)
-{}
-IR::OpDescriptionSeq::OpDescriptionSeq (CORBA::ULong max, CORBA::ULong length, IR::OperationDescription *buffer, CORBA::Boolean release)
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Sequence_IR_OpDescriptionSeq
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::OperationDescription>
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (max, length, buffer, release)
-{}
-IR::OpDescriptionSeq::OpDescriptionSeq (const OpDescriptionSeq &seq) // copy ctor
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Sequence_IR_OpDescriptionSeq
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::OperationDescription>
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (seq)
-{}
-IR::OpDescriptionSeq::~OpDescriptionSeq (void) // dtor
-{}
-void IR::OpDescriptionSeq::_tao_any_destructor (void *x)
-{
-  OpDescriptionSeq *tmp = ACE_static_cast (OpDescriptionSeq*,x);
-  delete tmp;
-}
-
-
-#endif /* end #if !defined */
-
-static const CORBA::Long _oc_IR_OpDescriptionSeq[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OpDescriptionSeq:1.0
-  17, ACE_NTOHL (0x4f704465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x0),  // name = OpDescriptionSeq
-  CORBA::tk_sequence, // typecode kind
-  1896, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    CORBA::tk_struct, // typecode kind
-    1880, // encapsulation length
-      TAO_ENCAP_BYTE_ORDER, // byte order
-      40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OperationDescription:1.0
-      21, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = OperationDescription
-      9, // member count
-      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-      CORBA::tk_alias, // typecode kind for typedefs
-      64, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-        CORBA::tk_string, 
-        0U, // string length
-
-      3, ACE_NTOHL (0x69640000),  // name = id
-      CORBA::tk_alias, // typecode kind for typedefs
-      68, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-        CORBA::tk_string, 
-        0U, // string length
-
-      11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
-      CORBA::tk_alias, // typecode kind for typedefs
-      68, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-        CORBA::tk_string, 
-        0U, // string length
-
-      8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
-      CORBA::tk_alias, // typecode kind for typedefs
-      64, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
-        12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
-        CORBA::tk_string, 
-        0U, // string length
-
-      7, ACE_NTOHL (0x72657375), ACE_NTOHL (0x6c740000),  // name = result
-      CORBA::tk_TypeCode,
-
-      5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
-      CORBA::tk_enum, // typecode kind
-      100, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/OperationMode:1.0
-        14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
-        2, // member count
-        10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
-        10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY
-
-      9, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x65787473), ACE_NTOHL (0x0),  // name = contexts
-      CORBA::tk_alias, // typecode kind for typedefs
-      228, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ContextIdSeq:1.0
-        13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
-        CORBA::tk_sequence, // typecode kind
-        160, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          CORBA::tk_alias, // typecode kind for typedefs
-          144, // encapsulation length
-            TAO_ENCAP_BYTE_ORDER, // byte order
-            37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ContextIdentifier:1.0
-            18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
-            CORBA::tk_alias, // typecode kind for typedefs
-            64, // encapsulation length
-              TAO_ENCAP_BYTE_ORDER, // byte order
-              30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-              11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-              CORBA::tk_string, 
-              0U, // string length
-
-
-          0U,
-
-
-      11, ACE_NTOHL (0x70617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72730000),  // name = parameters
-      CORBA::tk_alias, // typecode kind for typedefs
-      484, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x61724465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParDescriptionSeq:1.0
-        18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
-        CORBA::tk_sequence, // typecode kind
-        404, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          CORBA::tk_struct, // typecode kind
-          388, // encapsulation length
-            TAO_ENCAP_BYTE_ORDER, // byte order
-            40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ParameterDescription:1.0
-            21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
-            4, // member count
-            5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-            CORBA::tk_alias, // typecode kind for typedefs
-            64, // encapsulation length
-              TAO_ENCAP_BYTE_ORDER, // byte order
-              30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-              11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-              CORBA::tk_string, 
-              0U, // string length
-
-            5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
-            CORBA::tk_TypeCode,
-
-            9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
-            CORBA::tk_objref, // typecode kind
-            48, // encapsulation length
-              TAO_ENCAP_BYTE_ORDER, // byte order
-              27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
-              8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType
-
-            5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
-            CORBA::tk_enum, // typecode kind
-            116, // encapsulation length
-              TAO_ENCAP_BYTE_ORDER, // byte order
-              33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParameterMode:1.0
-              14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
-              3, // member count
-              9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
-              10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
-              12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT
-
-
-          0U,
-
-
-      11, ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = exceptions
-      CORBA::tk_alias, // typecode kind for typedefs
-      536, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
-        18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
-        CORBA::tk_sequence, // typecode kind
-        456, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          CORBA::tk_struct, // typecode kind
-          440, // encapsulation length
-            TAO_ENCAP_BYTE_ORDER, // byte order
-            40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
-            21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
-            5, // member count
-            5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-            CORBA::tk_alias, // typecode kind for typedefs
-            64, // encapsulation length
-              TAO_ENCAP_BYTE_ORDER, // byte order
-              30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-              11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-              CORBA::tk_string, 
-              0U, // string length
-
-            3, ACE_NTOHL (0x69640000),  // name = id
-            CORBA::tk_alias, // typecode kind for typedefs
-            68, // encapsulation length
-              TAO_ENCAP_BYTE_ORDER, // byte order
-              32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-              13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-              CORBA::tk_string, 
-              0U, // string length
-
-            11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
-            CORBA::tk_alias, // typecode kind for typedefs
-            68, // encapsulation length
-              TAO_ENCAP_BYTE_ORDER, // byte order
-              32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-              13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-              CORBA::tk_string, 
-              0U, // string length
-
-            8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
-            CORBA::tk_alias, // typecode kind for typedefs
-            64, // encapsulation length
-              TAO_ENCAP_BYTE_ORDER, // byte order
-              31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
-              12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
-              CORBA::tk_string, 
-              0U, // string length
-
-            5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
-            CORBA::tk_TypeCode,
-
-
-          0U,
-
-
-
-    0U,
-
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_OpDescriptionSeq (CORBA::tk_alias, sizeof (_oc_IR_OpDescriptionSeq), (char *) &_oc_IR_OpDescriptionSeq, 0, sizeof (IR::OpDescriptionSeq));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_OpDescriptionSeq, &_tc_TAO_tc_IR_OpDescriptionSeq)
-TAO_NAMESPACE_END
-
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  
-#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_ATTRDESCRIPTIONSEQ_CS_)
-#define __TAO_UNBOUNDED_SEQUENCE_IR_ATTRDESCRIPTIONSEQ_CS_
-
-  void
-  IR::_TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::_allocate_buffer (CORBA::ULong length)
-  {
-    IR::AttributeDescription* tmp = 0;
-    tmp = _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::allocbuf (length);
-    
-    if (this->buffer_ != 0)
-    {
-      IR::AttributeDescription *old = ACE_reinterpret_cast (IR::AttributeDescription *,this->buffer_);
-      
-      for (CORBA::ULong i = 0; i < this->length_; ++i)
-        tmp[i] = old[i];
-      
-      if (this->release_)
-        _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::freebuf (old);
-      
-    }
-    this->buffer_ = tmp;
-  }
-  
-  void
-  IR::_TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::_deallocate_buffer (void)
-  {
-    if (this->buffer_ == 0 || this->release_ == 0)
-      return;
-    
-    IR::AttributeDescription *tmp = ACE_reinterpret_cast (IR::AttributeDescription *,this->buffer_);
-    
-    _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::freebuf (tmp);
-    this->buffer_ = 0;
-  } 
-  
-  IR::_TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::~_TAO_Unbounded_Sequence_IR_AttrDescriptionSeq (void) // Dtor.
-  {
-    this->_deallocate_buffer ();
-  }
-  
-  
-#endif /* end #if !defined */
-
-
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
-
-#if !defined (_IR_ATTRDESCRIPTIONSEQ_CS_)
-#define _IR_ATTRDESCRIPTIONSEQ_CS_
-
-// *************************************************************
-// IR::AttrDescriptionSeq
-// *************************************************************
-
-IR::AttrDescriptionSeq::AttrDescriptionSeq (void)
-{}
-IR::AttrDescriptionSeq::AttrDescriptionSeq (CORBA::ULong max) // uses max size
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::AttributeDescription>
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (max)
-{}
-IR::AttrDescriptionSeq::AttrDescriptionSeq (CORBA::ULong max, CORBA::ULong length, IR::AttributeDescription *buffer, CORBA::Boolean release)
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::AttributeDescription>
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (max, length, buffer, release)
-{}
-IR::AttrDescriptionSeq::AttrDescriptionSeq (const AttrDescriptionSeq &seq) // copy ctor
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::AttributeDescription>
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (seq)
-{}
-IR::AttrDescriptionSeq::~AttrDescriptionSeq (void) // dtor
-{}
-void IR::AttrDescriptionSeq::_tao_any_destructor (void *x)
-{
-  AttrDescriptionSeq *tmp = ACE_static_cast (AttrDescriptionSeq*,x);
-  delete tmp;
-}
-
-
-#endif /* end #if !defined */
-
-static const CORBA::Long _oc_IR_AttrDescriptionSeq[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/AttrDescriptionSeq:1.0
-  19, ACE_NTOHL (0x41747472), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65710000),  // name = AttrDescriptionSeq
-  CORBA::tk_sequence, // typecode kind
-  1708, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    CORBA::tk_struct, // typecode kind
-    1692, // encapsulation length
-      TAO_ENCAP_BYTE_ORDER, // byte order
-      40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/AttributeDescription:1.0
-      21, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = AttributeDescription
-      8, // member count
-      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-      CORBA::tk_alias, // typecode kind for typedefs
-      64, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-        CORBA::tk_string, 
-        0U, // string length
-
-      3, ACE_NTOHL (0x69640000),  // name = id
-      CORBA::tk_alias, // typecode kind for typedefs
-      68, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-        CORBA::tk_string, 
-        0U, // string length
-
-      11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
-      CORBA::tk_alias, // typecode kind for typedefs
-      68, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-        CORBA::tk_string, 
-        0U, // string length
-
-      8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
-      CORBA::tk_alias, // typecode kind for typedefs
-      64, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
-        12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
-        CORBA::tk_string, 
-        0U, // string length
-
-      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
-      CORBA::tk_TypeCode,
-
-      5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
-      CORBA::tk_enum, // typecode kind
-      104, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/AttributeMode:1.0
-        14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
-        2, // member count
-        12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
-        14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY
-
-      15, ACE_NTOHL (0x6765745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = get_exceptions
-      CORBA::tk_alias, // typecode kind for typedefs
-      536, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
-        18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
-        CORBA::tk_sequence, // typecode kind
-        456, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          CORBA::tk_struct, // typecode kind
-          440, // encapsulation length
-            TAO_ENCAP_BYTE_ORDER, // byte order
-            40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
-            21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
-            5, // member count
-            5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-            CORBA::tk_alias, // typecode kind for typedefs
-            64, // encapsulation length
-              TAO_ENCAP_BYTE_ORDER, // byte order
-              30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-              11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-              CORBA::tk_string, 
-              0U, // string length
-
-            3, ACE_NTOHL (0x69640000),  // name = id
-            CORBA::tk_alias, // typecode kind for typedefs
-            68, // encapsulation length
-              TAO_ENCAP_BYTE_ORDER, // byte order
-              32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-              13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-              CORBA::tk_string, 
-              0U, // string length
-
-            11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
-            CORBA::tk_alias, // typecode kind for typedefs
-            68, // encapsulation length
-              TAO_ENCAP_BYTE_ORDER, // byte order
-              32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-              13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-              CORBA::tk_string, 
-              0U, // string length
-
-            8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
-            CORBA::tk_alias, // typecode kind for typedefs
-            64, // encapsulation length
-              TAO_ENCAP_BYTE_ORDER, // byte order
-              31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
-              12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
-              CORBA::tk_string, 
-              0U, // string length
-
-            5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
-            CORBA::tk_TypeCode,
-
-
-          0U,
-
-
-      15, ACE_NTOHL (0x7075745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = put_exceptions
-      CORBA::tk_alias, // typecode kind for typedefs
-      536, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
-        18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
-        CORBA::tk_sequence, // typecode kind
-        456, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          CORBA::tk_struct, // typecode kind
-          440, // encapsulation length
-            TAO_ENCAP_BYTE_ORDER, // byte order
-            40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
-            21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
-            5, // member count
-            5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-            CORBA::tk_alias, // typecode kind for typedefs
-            64, // encapsulation length
-              TAO_ENCAP_BYTE_ORDER, // byte order
-              30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-              11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-              CORBA::tk_string, 
-              0U, // string length
-
-            3, ACE_NTOHL (0x69640000),  // name = id
-            CORBA::tk_alias, // typecode kind for typedefs
-            68, // encapsulation length
-              TAO_ENCAP_BYTE_ORDER, // byte order
-              32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-              13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-              CORBA::tk_string, 
-              0U, // string length
-
-            11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
-            CORBA::tk_alias, // typecode kind for typedefs
-            68, // encapsulation length
-              TAO_ENCAP_BYTE_ORDER, // byte order
-              32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-              13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-              CORBA::tk_string, 
-              0U, // string length
-
-            8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
-            CORBA::tk_alias, // typecode kind for typedefs
-            64, // encapsulation length
-              TAO_ENCAP_BYTE_ORDER, // byte order
-              31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
-              12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
-              CORBA::tk_string, 
-              0U, // string length
-
-            5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
-            CORBA::tk_TypeCode,
-
-
-          0U,
-
-
-
-    0U,
-
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_AttrDescriptionSeq (CORBA::tk_alias, sizeof (_oc_IR_AttrDescriptionSeq), (char *) &_oc_IR_AttrDescriptionSeq, 0, sizeof (IR::AttrDescriptionSeq));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AttrDescriptionSeq, &_tc_TAO_tc_IR_AttrDescriptionSeq)
-TAO_NAMESPACE_END
-
-///////////////////////////////////////////////////////////////////////
-//                Base & Remote Proxy  Implementation. 
-//
-
-IR::_TAO_InterfaceDef_Proxy_Impl::_TAO_InterfaceDef_Proxy_Impl (void)
-{}
-
-IR::_TAO_InterfaceDef_Remote_Proxy_Impl::_TAO_InterfaceDef_Remote_Proxy_Impl (void)
-{}
-
-// Remote Implementation of the IDL interface methods
-
-IR::InterfaceDefSeq * IR::_TAO_InterfaceDef_Remote_Proxy_Impl::base_interfaces (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  IR::InterfaceDefSeq *_tao_retval = 0;
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
-  
-  ACE_NEW_RETURN (_tao_retval, IR::InterfaceDefSeq, _tao_retval);
-  IR::InterfaceDefSeq_var _tao_safe_retval (_tao_retval);
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_base_interfaces",
-      20,
-      0,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_base_interfaces_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::InterfaceDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
-}
-
-void IR::_TAO_InterfaceDef_Remote_Proxy_Impl::base_interfaces (
-    CORBA_Object *_collocated_tao_target_,
-    const IR::InterfaceDefSeq & base_interfaces,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW (CORBA::INTERNAL ());
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_set_base_interfaces",
-      20,
-      1,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_base_interfaces_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        base_interfaces,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << base_interfaces)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  
-}
-
-CORBA::Boolean IR::_TAO_InterfaceDef_Remote_Proxy_Impl::is_abstract (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  CORBA::Boolean _tao_retval = 0;
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_is_abstract",
-      16,
-      0,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_abstract_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              CORBA::Boolean  _tao_retval_info = _tao_retval;
-               ri.result (_tao_retval_info);
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_retval;
-}
-
-void IR::_TAO_InterfaceDef_Remote_Proxy_Impl::is_abstract (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Boolean is_abstract,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW (CORBA::INTERNAL ());
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_set_is_abstract",
-      16,
-      1,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_abstract_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        is_abstract,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << CORBA::Any::from_boolean (is_abstract))
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  
-}
-
-CORBA::Boolean IR::_TAO_InterfaceDef_Remote_Proxy_Impl::is_local (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  CORBA::Boolean _tao_retval = 0;
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_is_local",
-      13,
-      0,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_local_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              CORBA::Boolean  _tao_retval_info = _tao_retval;
-               ri.result (_tao_retval_info);
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_retval;
-}
-
-void IR::_TAO_InterfaceDef_Remote_Proxy_Impl::is_local (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Boolean is_local,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW (CORBA::INTERNAL ());
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_set_is_local",
-      13,
-      1,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_local_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        is_local,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << CORBA::Any::from_boolean (is_local))
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  
-}
-
-CORBA::Boolean IR::_TAO_InterfaceDef_Remote_Proxy_Impl::is_a (
-    CORBA_Object *_collocated_tao_target_,
-    const char * interface_id,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  CORBA::Boolean _tao_retval = 0;
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "is_a",
-      4,
-      1,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_a ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        interface_id,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << interface_id)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
-              _tao_retval
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              CORBA::Boolean  _tao_retval_info = _tao_retval;
-               ri.result (_tao_retval_info);
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_retval;
-}
-
-IR::AttributeDef_ptr IR::_TAO_InterfaceDef_Remote_Proxy_Impl::create_attribute (
-    CORBA_Object *_collocated_tao_target_,
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::IDLType_ptr type,
-    IR::AttributeMode mode,
-    const IR::ExceptionDefSeq & get_exceptions,
-    const IR::ExceptionDefSeq & put_exceptions,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  IR::AttributeDef_ptr _tao_retval = IR::AttributeDef::_nil ();
-  IR::AttributeDef_var _tao_safe_retval (_tao_retval);
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "create_attribute",
-      16,
-      1,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_create_attribute ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        id,
-        name,
-        version,
-        type,
-        mode,
-        get_exceptions,
-        put_exceptions,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << id) &&
-              (_tao_out << name) &&
-              (_tao_out << version) &&
-              (_tao_out << type) &&
-              (_tao_out << mode) &&
-              (_tao_out << get_exceptions) &&
-              (_tao_out << put_exceptions)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
-              0
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::AttributeDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
-}
-
-IR::OperationDef_ptr IR::_TAO_InterfaceDef_Remote_Proxy_Impl::create_operation (
-    CORBA_Object *_collocated_tao_target_,
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::IDLType_ptr result,
-    IR::OperationMode mode,
-    const IR::ParDescriptionSeq & params,
-    const IR::ExceptionDefSeq & exceptions,
-    const IR::ContextIdSeq & contexts,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  IR::OperationDef_ptr _tao_retval = IR::OperationDef::_nil ();
-  IR::OperationDef_var _tao_safe_retval (_tao_retval);
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "create_operation",
-      16,
-      1,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_create_operation ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        id,
-        name,
-        version,
-        result,
-        mode,
-        params,
-        exceptions,
-        contexts,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << id) &&
-              (_tao_out << name) &&
-              (_tao_out << version) &&
-              (_tao_out << result) &&
-              (_tao_out << mode) &&
-              (_tao_out << params) &&
-              (_tao_out << exceptions) &&
-              (_tao_out << contexts)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
-              0
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::OperationDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
-}
-
-
-//
-//            End  Base & Remote  Proxy Implemeentation. 
-///////////////////////////////////////////////////////////////////////
-
-
-///////////////////////////////////////////////////////////////////////
-//           Remote & Base  Proxy Broker Implementation
-//
-
-IR::_TAO_InterfaceDef_Proxy_Broker::_TAO_InterfaceDef_Proxy_Broker (void)
-{
-}
-
-IR::_TAO_InterfaceDef_Proxy_Broker::~_TAO_InterfaceDef_Proxy_Broker (void)
-{
-}
-
-// Factory Member function Implementation.
-IR::_TAO_InterfaceDef_Remote_Proxy_Broker *IR::_TAO_InterfaceDef_Remote_Proxy_Broker::the_TAO_InterfaceDef_Remote_Proxy_Broker (void)
-{
-  static ::IR::_TAO_InterfaceDef_Remote_Proxy_Broker remote_proxy_broker;
-  return &remote_proxy_broker;
-}
-
-IR::_TAO_InterfaceDef_Remote_Proxy_Broker::_TAO_InterfaceDef_Remote_Proxy_Broker (void)
-{
-}
-
-IR::_TAO_InterfaceDef_Remote_Proxy_Broker::~_TAO_InterfaceDef_Remote_Proxy_Broker (void)
-{
-}
-
-IR::_TAO_InterfaceDef_Proxy_Impl&
-IR::_TAO_InterfaceDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::InterfaceDef *object,
-  CORBA::Environment &ACE_TRY_ENV
-)
-{
-  ACE_UNUSED_ARG (object);
-  ACE_UNUSED_ARG (ACE_TRY_ENV);
-  return remote_proxy_impl_;
-}
-
-
-//
-//           End Remote & Base Proxy Broker Implementation
-///////////////////////////////////////////////////////////////////////
-
-
-// default constructor
-IR::InterfaceDef::InterfaceDef (int collocated)
-{
-  this->_tao_setup_collocation (collocated);
-}
-
-// destructor
-IR::InterfaceDef::~InterfaceDef (void)
-{}
-
-void
-IR::InterfaceDef::_tao_setup_collocation (int collocated)
-{
-  if (collocated)
-    this->the_TAO_InterfaceDef_Proxy_Broker_ =
-      ::IR__TAO_InterfaceDef_Proxy_Broker_Factory_function_pointer (this);
-  else
-    this->the_TAO_InterfaceDef_Proxy_Broker_ =
-      ::IR::_TAO_InterfaceDef_Remote_Proxy_Broker::the_TAO_InterfaceDef_Remote_Proxy_Broker ();
-  
-  ACE_NESTED_CLASS (IR, Container)::_tao_setup_collocation (collocated);
-  ACE_NESTED_CLASS (IR, Contained)::_tao_setup_collocation (collocated);
-  ACE_NESTED_CLASS (IR, IDLType)::_tao_setup_collocation (collocated);
-}
-
-void IR::InterfaceDef::_tao_any_destructor (void *x)
-{
-  InterfaceDef *tmp = ACE_static_cast (InterfaceDef*,x);
-  CORBA::release (tmp);
-}
-
-IR::InterfaceDef_ptr IR::InterfaceDef::_narrow (
-    CORBA::Object_ptr obj,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-{
-  if (CORBA::is_nil (obj))
-    return InterfaceDef::_nil ();
-  if (! obj->_is_local ())
-    {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/InterfaceDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (InterfaceDef::_nil ());
-      if (is_a == 0)
-        return InterfaceDef::_nil ();
-    }
-  return InterfaceDef::_unchecked_narrow (obj, ACE_TRY_ENV);
-}
-
-IR::InterfaceDef_ptr IR::InterfaceDef::_unchecked_narrow (
-    CORBA::Object_ptr obj,
-    CORBA::Environment &
-  )
-{
-  if (CORBA::is_nil (obj))
-    return InterfaceDef::_nil ();
-  if (! obj->_is_local ())
-    {
-      TAO_Stub* stub = obj->_stubobj ();
-      if (stub)
-        stub->_incr_refcnt ();
-      InterfaceDef_ptr default_proxy = InterfaceDef::_nil ();
-
-      if (
-          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
-          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_InterfaceDef_Proxy_Broker_Factory_function_pointer != 0
-        )
-      {
-        ACE_NEW_RETURN (
-          default_proxy,
-          ::IR::InterfaceDef (
-            stub,
-            1,
-            obj->_servant ()),
-            
-          InterfaceDef::_nil ());
-        }
-      if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::InterfaceDef (stub, 0, obj->_servant ()), InterfaceDef::_nil ());
-        return default_proxy;
-      }
-    else 
-      return
-        ACE_reinterpret_cast
-          (
-            InterfaceDef_ptr,
-              obj->_tao_QueryInterface
-                (
-                  ACE_reinterpret_cast
-                    (
-                      ptr_arith_t,
-                      &InterfaceDef::_narrow
-                    )
-                )
-          );
-}
-
-IR::InterfaceDef_ptr
-IR::InterfaceDef::_duplicate (InterfaceDef_ptr obj)
-{
-  if (!CORBA::is_nil (obj))
-    obj->_add_ref ();
-  return obj;
-}
-
-CORBA::Boolean IR::InterfaceDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
-{
-  if (
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/InterfaceDef:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
-  return 1; // success using local knowledge
-  else
-    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
-}
-
-void *IR::InterfaceDef::_tao_QueryInterface (ptr_arith_t type)
-{
-  void *retv = 0;
-  if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, InterfaceDef)::_narrow))
-    retv = ACE_reinterpret_cast (void*, this);
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Container)::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            IR::Container_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Contained)::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            IR::Contained_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, IDLType)::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            IR::IDLType_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            CORBA::IRObject_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
-    retv = ACE_reinterpret_cast (void *,
-      ACE_static_cast (CORBA::Object_ptr, this));
-    
-  if (retv)
-    this->_add_ref ();
-  return retv;
-}
-
-const char* IR::InterfaceDef::_interface_repository_id (void) const
-{
-  return "IDL:omg.org/IR/InterfaceDef:1.0";
-}
-
-IR::InterfaceDefSeq * IR::InterfaceDef::base_interfaces (
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).base_interfaces (
-      this,
-      ACE_TRY_ENV
-    );
-}
-
-void IR::InterfaceDef::base_interfaces (
-    const IR::InterfaceDefSeq & base_interfaces,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).base_interfaces (
-      this,
-      base_interfaces,
-      ACE_TRY_ENV
-    );
-}
-
-CORBA::Boolean IR::InterfaceDef::is_abstract (
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_abstract (
-      this,
-      ACE_TRY_ENV
-    );
-}
-
-void IR::InterfaceDef::is_abstract (
-    CORBA::Boolean is_abstract,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_abstract (
-      this,
-      is_abstract,
-      ACE_TRY_ENV
-    );
-}
-
-CORBA::Boolean IR::InterfaceDef::is_local (
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_local (
-      this,
-      ACE_TRY_ENV
-    );
-}
-
-void IR::InterfaceDef::is_local (
-    CORBA::Boolean is_local,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_local (
-      this,
-      is_local,
-      ACE_TRY_ENV
-    );
-}
-
-CORBA::Boolean IR::InterfaceDef::is_a (
-    const char * interface_id,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_a (
-      this,
-      interface_id,
-      ACE_TRY_ENV
-    );
-}
-
-IR::AttributeDef_ptr IR::InterfaceDef::create_attribute (
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::IDLType_ptr type,
-    IR::AttributeMode mode,
-    const IR::ExceptionDefSeq & get_exceptions,
-    const IR::ExceptionDefSeq & put_exceptions,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_attribute (
-      this,
-      id,
-      name,
-      version,
-      type,
-      mode,
-      get_exceptions,
-      put_exceptions,
-      ACE_TRY_ENV
-    );
-}
-
-IR::OperationDef_ptr IR::InterfaceDef::create_operation (
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::IDLType_ptr result,
-    IR::OperationMode mode,
-    const IR::ParDescriptionSeq & params,
-    const IR::ExceptionDefSeq & exceptions,
-    const IR::ContextIdSeq & contexts,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_operation (
-      this,
-      id,
-      name,
-      version,
-      result,
-      mode,
-      params,
-      exceptions,
-      contexts,
-      ACE_TRY_ENV
-    );
-}
-
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_base_interfaces_get::TAO_ClientRequestInfo_IR_InterfaceDef_base_interfaces_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_base_interfaces_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_base_interfaces_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_base_interfaces_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_base_interfaces_get::result (IR::InterfaceDefSeq * result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_base_interfaces_set::TAO_ClientRequestInfo_IR_InterfaceDef_base_interfaces_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const IR::InterfaceDefSeq & base_interfaces,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    base_interfaces_ (base_interfaces)
-{}
-
-Dynamic::ParameterList *
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_base_interfaces_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_base_interfaces = parameter_list->length ();
-  parameter_list->length (length_base_interfaces + 1);
-  (*parameter_list)[length_base_interfaces].argument <<=  this->base_interfaces_;
-  
-  (*parameter_list)[length_base_interfaces].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_base_interfaces_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_base_interfaces_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
-}
-
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_abstract_get::TAO_ClientRequestInfo_IR_InterfaceDef_is_abstract_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_abstract_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_abstract_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_abstract_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
-  return safe_result_any._retn ();
-}
-
-void 
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_abstract_get::result (CORBA::Boolean result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_abstract_set::TAO_ClientRequestInfo_IR_InterfaceDef_is_abstract_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const CORBA::Boolean & is_abstract,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    is_abstract_ (is_abstract)
-{}
-
-Dynamic::ParameterList *
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_abstract_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_is_abstract = parameter_list->length ();
-  parameter_list->length (length_is_abstract + 1);
-  (*parameter_list)[length_is_abstract].argument <<= CORBA::Any::from_boolean (this->is_abstract_);
-  (*parameter_list)[length_is_abstract].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_abstract_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_abstract_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
-}
-
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_local_get::TAO_ClientRequestInfo_IR_InterfaceDef_is_local_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_local_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_local_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_local_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
-  return safe_result_any._retn ();
-}
-
-void 
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_local_get::result (CORBA::Boolean result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_local_set::TAO_ClientRequestInfo_IR_InterfaceDef_is_local_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const CORBA::Boolean & is_local,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    is_local_ (is_local)
-{}
-
-Dynamic::ParameterList *
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_local_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_is_local = parameter_list->length ();
-  parameter_list->length (length_is_local + 1);
-  (*parameter_list)[length_is_local].argument <<= CORBA::Any::from_boolean (this->is_local_);
-  (*parameter_list)[length_is_local].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_local_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_local_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
-}
-
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_a::TAO_ClientRequestInfo_IR_InterfaceDef_is_a (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * interface_id,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    interface_id_ (interface_id)
-{}
-
-Dynamic::ParameterList *
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_a::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_interface_id = parameter_list->length ();
-  parameter_list->length (length_interface_id + 1);
-  (*parameter_list)[length_interface_id].argument <<= interface_id_;
-  (*parameter_list)[length_interface_id].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_a::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_a::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
-  return safe_result_any._retn ();
-}
-
-void 
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_a::result (CORBA::Boolean result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_create_attribute::TAO_ClientRequestInfo_IR_InterfaceDef_create_attribute (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::IDLType_ptr type,
-    IR::AttributeMode & mode,
-    const IR::ExceptionDefSeq & get_exceptions,
-    const IR::ExceptionDefSeq & put_exceptions,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    id_ (id),
-    name_ (name),
-    version_ (version),
-    type_ (type),
-    mode_ (mode),
-    get_exceptions_ (get_exceptions),
-    put_exceptions_ (put_exceptions)
-{}
-
-Dynamic::ParameterList *
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_create_attribute::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_id = parameter_list->length ();
-  parameter_list->length (length_id + 1);
-  (*parameter_list)[length_id].argument <<= id_;
-  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_name = parameter_list->length ();
-  parameter_list->length (length_name + 1);
-  (*parameter_list)[length_name].argument <<= name_;
-  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_version = parameter_list->length ();
-  parameter_list->length (length_version + 1);
-  (*parameter_list)[length_version].argument <<= version_;
-  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_type = parameter_list->length ();
-  parameter_list->length (length_type + 1);
-  (*parameter_list)[length_type].argument <<=  this->type_;
-  
-  (*parameter_list)[length_type].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_mode = parameter_list->length ();
-  parameter_list->length (length_mode + 1);
-  (*parameter_list)[length_mode].argument <<=  this->mode_;
-  
-  (*parameter_list)[length_mode].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_get_exceptions = parameter_list->length ();
-  parameter_list->length (length_get_exceptions + 1);
-  (*parameter_list)[length_get_exceptions].argument <<=  this->get_exceptions_;
-  
-  (*parameter_list)[length_get_exceptions].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_put_exceptions = parameter_list->length ();
-  parameter_list->length (length_put_exceptions + 1);
-  (*parameter_list)[length_put_exceptions].argument <<=  this->put_exceptions_;
-  
-  (*parameter_list)[length_put_exceptions].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_create_attribute::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_create_attribute::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_create_attribute::result (IR::AttributeDef_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_create_operation::TAO_ClientRequestInfo_IR_InterfaceDef_create_operation (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::IDLType_ptr result,
-    IR::OperationMode & mode,
-    const IR::ParDescriptionSeq & params,
-    const IR::ExceptionDefSeq & exceptions,
-    const IR::ContextIdSeq & contexts,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    id_ (id),
-    name_ (name),
-    version_ (version),
-    result_ (result),
-    mode_ (mode),
-    params_ (params),
-    exceptions_ (exceptions),
-    contexts_ (contexts)
-{}
-
-Dynamic::ParameterList *
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_create_operation::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_id = parameter_list->length ();
-  parameter_list->length (length_id + 1);
-  (*parameter_list)[length_id].argument <<= id_;
-  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_name = parameter_list->length ();
-  parameter_list->length (length_name + 1);
-  (*parameter_list)[length_name].argument <<= name_;
-  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_version = parameter_list->length ();
-  parameter_list->length (length_version + 1);
-  (*parameter_list)[length_version].argument <<= version_;
-  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_result = parameter_list->length ();
-  parameter_list->length (length_result + 1);
-  (*parameter_list)[length_result].argument <<=  this->result_;
-  
-  (*parameter_list)[length_result].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_mode = parameter_list->length ();
-  parameter_list->length (length_mode + 1);
-  (*parameter_list)[length_mode].argument <<=  this->mode_;
-  
-  (*parameter_list)[length_mode].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_params = parameter_list->length ();
-  parameter_list->length (length_params + 1);
-  (*parameter_list)[length_params].argument <<=  this->params_;
-  
-  (*parameter_list)[length_params].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_exceptions = parameter_list->length ();
-  parameter_list->length (length_exceptions + 1);
-  (*parameter_list)[length_exceptions].argument <<=  this->exceptions_;
-  
-  (*parameter_list)[length_exceptions].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_contexts = parameter_list->length ();
-  parameter_list->length (length_contexts + 1);
-  (*parameter_list)[length_contexts].argument <<=  this->contexts_;
-  
-  (*parameter_list)[length_contexts].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_create_operation::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_create_operation::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_create_operation::result (IR::OperationDef_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_InterfaceDef[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/InterfaceDef:1.0
-  13, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = InterfaceDef
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_InterfaceDef (CORBA::tk_objref, sizeof (_oc_IR_InterfaceDef), (char *) &_oc_IR_InterfaceDef, 0, sizeof (IR::InterfaceDef));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_InterfaceDef, &_tc_TAO_tc_IR_InterfaceDef)
-TAO_NAMESPACE_END
-static const CORBA::Long _oc_IR_InterfaceDescription[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/InterfaceDescription:1.0
-  21, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = InterfaceDescription
-  10, // member count
-  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-  CORBA::tk_alias, // typecode kind for typedefs
-  64, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-    CORBA::tk_string, 
-    0U, // string length
-
-  3, ACE_NTOHL (0x69640000),  // name = id
-  CORBA::tk_alias, // typecode kind for typedefs
-  68, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-    CORBA::tk_string, 
-    0U, // string length
-
-  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
-  CORBA::tk_alias, // typecode kind for typedefs
-  68, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-    CORBA::tk_string, 
-    0U, // string length
-
-  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
-  CORBA::tk_alias, // typecode kind for typedefs
-  64, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
-    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
-    CORBA::tk_string, 
-    0U, // string length
-
-  11, ACE_NTOHL (0x6f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e730000),  // name = operations
-  CORBA::tk_alias, // typecode kind for typedefs
-  1972, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OpDescriptionSeq:1.0
-    17, ACE_NTOHL (0x4f704465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x0),  // name = OpDescriptionSeq
-    CORBA::tk_sequence, // typecode kind
-    1896, // encapsulation length
-      TAO_ENCAP_BYTE_ORDER, // byte order
-      CORBA::tk_struct, // typecode kind
-      1880, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OperationDescription:1.0
-        21, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = OperationDescription
-        9, // member count
-        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-        CORBA::tk_alias, // typecode kind for typedefs
-        64, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-          CORBA::tk_string, 
-          0U, // string length
-
-        3, ACE_NTOHL (0x69640000),  // name = id
-        CORBA::tk_alias, // typecode kind for typedefs
-        68, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-          CORBA::tk_string, 
-          0U, // string length
-
-        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
-        CORBA::tk_alias, // typecode kind for typedefs
-        68, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-          CORBA::tk_string, 
-          0U, // string length
-
-        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
-        CORBA::tk_alias, // typecode kind for typedefs
-        64, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
-          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
-          CORBA::tk_string, 
-          0U, // string length
-
-        7, ACE_NTOHL (0x72657375), ACE_NTOHL (0x6c740000),  // name = result
-        CORBA::tk_TypeCode,
-
-        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
-        CORBA::tk_enum, // typecode kind
-        100, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/OperationMode:1.0
-          14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
-          2, // member count
-          10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
-          10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY
-
-        9, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x65787473), ACE_NTOHL (0x0),  // name = contexts
-        CORBA::tk_alias, // typecode kind for typedefs
-        228, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ContextIdSeq:1.0
-          13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
-          CORBA::tk_sequence, // typecode kind
-          160, // encapsulation length
-            TAO_ENCAP_BYTE_ORDER, // byte order
-            CORBA::tk_alias, // typecode kind for typedefs
-            144, // encapsulation length
-              TAO_ENCAP_BYTE_ORDER, // byte order
-              37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ContextIdentifier:1.0
-              18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
-              CORBA::tk_alias, // typecode kind for typedefs
-              64, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-                CORBA::tk_string, 
-                0U, // string length
-
-
-            0U,
-
-
-        11, ACE_NTOHL (0x70617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72730000),  // name = parameters
-        CORBA::tk_alias, // typecode kind for typedefs
-        484, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x61724465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParDescriptionSeq:1.0
-          18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
-          CORBA::tk_sequence, // typecode kind
-          404, // encapsulation length
-            TAO_ENCAP_BYTE_ORDER, // byte order
-            CORBA::tk_struct, // typecode kind
-            388, // encapsulation length
-              TAO_ENCAP_BYTE_ORDER, // byte order
-              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ParameterDescription:1.0
-              21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
-              4, // member count
-              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-              CORBA::tk_alias, // typecode kind for typedefs
-              64, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-                CORBA::tk_string, 
-                0U, // string length
-
-              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
-              CORBA::tk_TypeCode,
-
-              9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
-              CORBA::tk_objref, // typecode kind
-              48, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
-                8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType
-
-              5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
-              CORBA::tk_enum, // typecode kind
-              116, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParameterMode:1.0
-                14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
-                3, // member count
-                9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
-                10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
-                12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT
-
-
-            0U,
-
-
-        11, ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = exceptions
-        CORBA::tk_alias, // typecode kind for typedefs
-        536, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
-          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
-          CORBA::tk_sequence, // typecode kind
-          456, // encapsulation length
-            TAO_ENCAP_BYTE_ORDER, // byte order
-            CORBA::tk_struct, // typecode kind
-            440, // encapsulation length
-              TAO_ENCAP_BYTE_ORDER, // byte order
-              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
-              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
-              5, // member count
-              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-              CORBA::tk_alias, // typecode kind for typedefs
-              64, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-                CORBA::tk_string, 
-                0U, // string length
-
-              3, ACE_NTOHL (0x69640000),  // name = id
-              CORBA::tk_alias, // typecode kind for typedefs
-              68, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-                CORBA::tk_string, 
-                0U, // string length
-
-              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
-              CORBA::tk_alias, // typecode kind for typedefs
-              68, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-                CORBA::tk_string, 
-                0U, // string length
-
-              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
-              CORBA::tk_alias, // typecode kind for typedefs
-              64, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
-                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
-                CORBA::tk_string, 
-                0U, // string length
-
-              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
-              CORBA::tk_TypeCode,
-
-
-            0U,
-
-
-
-      0U,
-
-
-  11, ACE_NTOHL (0x61747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65730000),  // name = attributes
-  CORBA::tk_alias, // typecode kind for typedefs
-  1788, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/AttrDescriptionSeq:1.0
-    19, ACE_NTOHL (0x41747472), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65710000),  // name = AttrDescriptionSeq
-    CORBA::tk_sequence, // typecode kind
-    1708, // encapsulation length
-      TAO_ENCAP_BYTE_ORDER, // byte order
-      CORBA::tk_struct, // typecode kind
-      1692, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/AttributeDescription:1.0
-        21, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = AttributeDescription
-        8, // member count
-        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-        CORBA::tk_alias, // typecode kind for typedefs
-        64, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-          CORBA::tk_string, 
-          0U, // string length
-
-        3, ACE_NTOHL (0x69640000),  // name = id
-        CORBA::tk_alias, // typecode kind for typedefs
-        68, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-          CORBA::tk_string, 
-          0U, // string length
-
-        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
-        CORBA::tk_alias, // typecode kind for typedefs
-        68, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-          CORBA::tk_string, 
-          0U, // string length
-
-        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
-        CORBA::tk_alias, // typecode kind for typedefs
-        64, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
-          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
-          CORBA::tk_string, 
-          0U, // string length
-
-        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
-        CORBA::tk_TypeCode,
-
-        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
-        CORBA::tk_enum, // typecode kind
-        104, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/AttributeMode:1.0
-          14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
-          2, // member count
-          12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
-          14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY
-
-        15, ACE_NTOHL (0x6765745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = get_exceptions
-        CORBA::tk_alias, // typecode kind for typedefs
-        536, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
-          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
-          CORBA::tk_sequence, // typecode kind
-          456, // encapsulation length
-            TAO_ENCAP_BYTE_ORDER, // byte order
-            CORBA::tk_struct, // typecode kind
-            440, // encapsulation length
-              TAO_ENCAP_BYTE_ORDER, // byte order
-              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
-              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
-              5, // member count
-              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-              CORBA::tk_alias, // typecode kind for typedefs
-              64, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-                CORBA::tk_string, 
-                0U, // string length
-
-              3, ACE_NTOHL (0x69640000),  // name = id
-              CORBA::tk_alias, // typecode kind for typedefs
-              68, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-                CORBA::tk_string, 
-                0U, // string length
-
-              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
-              CORBA::tk_alias, // typecode kind for typedefs
-              68, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-                CORBA::tk_string, 
-                0U, // string length
-
-              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
-              CORBA::tk_alias, // typecode kind for typedefs
-              64, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
-                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
-                CORBA::tk_string, 
-                0U, // string length
-
-              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
-              CORBA::tk_TypeCode,
-
-
-            0U,
-
-
-        15, ACE_NTOHL (0x7075745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = put_exceptions
-        CORBA::tk_alias, // typecode kind for typedefs
-        536, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
-          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
-          CORBA::tk_sequence, // typecode kind
-          456, // encapsulation length
-            TAO_ENCAP_BYTE_ORDER, // byte order
-            CORBA::tk_struct, // typecode kind
-            440, // encapsulation length
-              TAO_ENCAP_BYTE_ORDER, // byte order
-              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
-              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
-              5, // member count
-              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-              CORBA::tk_alias, // typecode kind for typedefs
-              64, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-                CORBA::tk_string, 
-                0U, // string length
-
-              3, ACE_NTOHL (0x69640000),  // name = id
-              CORBA::tk_alias, // typecode kind for typedefs
-              68, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-                CORBA::tk_string, 
-                0U, // string length
-
-              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
-              CORBA::tk_alias, // typecode kind for typedefs
-              68, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-                CORBA::tk_string, 
-                0U, // string length
-
-              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
-              CORBA::tk_alias, // typecode kind for typedefs
-              64, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
-                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
-                CORBA::tk_string, 
-                0U, // string length
-
-              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
-              CORBA::tk_TypeCode,
-
-
-            0U,
-
-
-
-      0U,
-
-
-  16, ACE_NTOHL (0x62617365), ACE_NTOHL (0x5f696e74), ACE_NTOHL (0x65726661), ACE_NTOHL (0x63657300),  // name = base_interfaces
-  CORBA::tk_alias, // typecode kind for typedefs
-  156, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79496453), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/RepositoryIdSeq:1.0
-    16, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
-    CORBA::tk_sequence, // typecode kind
-    84, // encapsulation length
-      TAO_ENCAP_BYTE_ORDER, // byte order
-      CORBA::tk_alias, // typecode kind for typedefs
-      68, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-        CORBA::tk_string, 
-        0U, // string length
-
-      0U,
-
-
-  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
-  CORBA::tk_TypeCode,
-
-  12, ACE_NTOHL (0x69735f61), ACE_NTOHL (0x62737472), ACE_NTOHL (0x61637400),  // name = is_abstract
-  CORBA::tk_boolean,
-
-  9, ACE_NTOHL (0x69735f6c), ACE_NTOHL (0x6f63616c), ACE_NTOHL (0x0),  // name = is_local
-  CORBA::tk_boolean,
-
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_InterfaceDescription (CORBA::tk_struct, sizeof (_oc_IR_InterfaceDescription), (char *) &_oc_IR_InterfaceDescription, 0, sizeof (IR::InterfaceDescription));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_InterfaceDescription, &_tc_TAO_tc_IR_InterfaceDescription)
-TAO_NAMESPACE_END
-void IR::InterfaceDescription::_tao_any_destructor (void *x)
-{
-  InterfaceDescription *tmp = ACE_static_cast (InterfaceDescription*,x);
-  delete tmp;
-}
-
-static const CORBA::Long _oc_IR_ValueMember[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ValueMember:1.0
-  12, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657200),  // name = ValueMember
-  7, // member count
-  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-  CORBA::tk_alias, // typecode kind for typedefs
-  64, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-    CORBA::tk_string, 
-    0U, // string length
-
-  3, ACE_NTOHL (0x69640000),  // name = id
-  CORBA::tk_alias, // typecode kind for typedefs
-  68, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-    CORBA::tk_string, 
-    0U, // string length
-
-  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
-  CORBA::tk_alias, // typecode kind for typedefs
-  68, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-    CORBA::tk_string, 
-    0U, // string length
-
-  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
-  CORBA::tk_alias, // typecode kind for typedefs
-  64, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
-    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
-    CORBA::tk_string, 
-    0U, // string length
-
-  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
-  CORBA::tk_TypeCode,
-
-  9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
-  CORBA::tk_objref, // typecode kind
-  48, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
-    8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType
-
-  7, ACE_NTOHL (0x61636365), ACE_NTOHL (0x73730000),  // name = access
-  CORBA::tk_alias, // typecode kind for typedefs
-  64, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5669), ACE_NTOHL (0x73696269), ACE_NTOHL (0x6c697479), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Visibility:1.0
-    11, ACE_NTOHL (0x56697369), ACE_NTOHL (0x62696c69), ACE_NTOHL (0x74790000),  // name = Visibility
-    CORBA::tk_short,
-
-
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_ValueMember (CORBA::tk_struct, sizeof (_oc_IR_ValueMember), (char *) &_oc_IR_ValueMember, 0, sizeof (IR::ValueMember));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueMember, &_tc_TAO_tc_IR_ValueMember)
-TAO_NAMESPACE_END
-void IR::ValueMember::_tao_any_destructor (void *x)
-{
-  ValueMember *tmp = ACE_static_cast (ValueMember*,x);
-  delete tmp;
-}
-
-
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  
-#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_VALUEMEMBERSEQ_CS_)
-#define __TAO_UNBOUNDED_SEQUENCE_IR_VALUEMEMBERSEQ_CS_
-
-  void
-  IR::_TAO_Unbounded_Sequence_IR_ValueMemberSeq::_allocate_buffer (CORBA::ULong length)
-  {
-    IR::ValueMember* tmp = 0;
-    tmp = _TAO_Unbounded_Sequence_IR_ValueMemberSeq::allocbuf (length);
-    
-    if (this->buffer_ != 0)
-    {
-      IR::ValueMember *old = ACE_reinterpret_cast (IR::ValueMember *,this->buffer_);
-      
-      for (CORBA::ULong i = 0; i < this->length_; ++i)
-        tmp[i] = old[i];
-      
-      if (this->release_)
-        _TAO_Unbounded_Sequence_IR_ValueMemberSeq::freebuf (old);
-      
-    }
-    this->buffer_ = tmp;
-  }
-  
-  void
-  IR::_TAO_Unbounded_Sequence_IR_ValueMemberSeq::_deallocate_buffer (void)
-  {
-    if (this->buffer_ == 0 || this->release_ == 0)
-      return;
-    
-    IR::ValueMember *tmp = ACE_reinterpret_cast (IR::ValueMember *,this->buffer_);
-    
-    _TAO_Unbounded_Sequence_IR_ValueMemberSeq::freebuf (tmp);
-    this->buffer_ = 0;
-  } 
-  
-  IR::_TAO_Unbounded_Sequence_IR_ValueMemberSeq::~_TAO_Unbounded_Sequence_IR_ValueMemberSeq (void) // Dtor.
-  {
-    this->_deallocate_buffer ();
-  }
-  
-  
-#endif /* end #if !defined */
-
-
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
-
-#if !defined (_IR_VALUEMEMBERSEQ_CS_)
-#define _IR_VALUEMEMBERSEQ_CS_
-
-// *************************************************************
-// IR::ValueMemberSeq
-// *************************************************************
-
-IR::ValueMemberSeq::ValueMemberSeq (void)
-{}
-IR::ValueMemberSeq::ValueMemberSeq (CORBA::ULong max) // uses max size
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Sequence_IR_ValueMemberSeq
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::ValueMember>
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (max)
-{}
-IR::ValueMemberSeq::ValueMemberSeq (CORBA::ULong max, CORBA::ULong length, IR::ValueMember *buffer, CORBA::Boolean release)
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Sequence_IR_ValueMemberSeq
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::ValueMember>
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (max, length, buffer, release)
-{}
-IR::ValueMemberSeq::ValueMemberSeq (const ValueMemberSeq &seq) // copy ctor
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Sequence_IR_ValueMemberSeq
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::ValueMember>
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (seq)
-{}
-IR::ValueMemberSeq::~ValueMemberSeq (void) // dtor
-{}
-void IR::ValueMemberSeq::_tao_any_destructor (void *x)
-{
-  ValueMemberSeq *tmp = ACE_static_cast (ValueMemberSeq*,x);
-  delete tmp;
-}
-
-
-#endif /* end #if !defined */
-
-static const CORBA::Long _oc_IR_ValueMemberSeq[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65725365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ValueMemberSeq:1.0
-  15, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657253), ACE_NTOHL (0x65710000),  // name = ValueMemberSeq
-  CORBA::tk_sequence, // typecode kind
-  592, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    CORBA::tk_struct, // typecode kind
-    576, // encapsulation length
-      TAO_ENCAP_BYTE_ORDER, // byte order
-      31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ValueMember:1.0
-      12, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657200),  // name = ValueMember
-      7, // member count
-      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-      CORBA::tk_alias, // typecode kind for typedefs
-      64, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-        CORBA::tk_string, 
-        0U, // string length
-
-      3, ACE_NTOHL (0x69640000),  // name = id
-      CORBA::tk_alias, // typecode kind for typedefs
-      68, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-        CORBA::tk_string, 
-        0U, // string length
-
-      11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
-      CORBA::tk_alias, // typecode kind for typedefs
-      68, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-        CORBA::tk_string, 
-        0U, // string length
-
-      8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
-      CORBA::tk_alias, // typecode kind for typedefs
-      64, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
-        12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
-        CORBA::tk_string, 
-        0U, // string length
-
-      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
-      CORBA::tk_TypeCode,
-
-      9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
-      CORBA::tk_objref, // typecode kind
-      48, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
-        8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType
-
-      7, ACE_NTOHL (0x61636365), ACE_NTOHL (0x73730000),  // name = access
-      CORBA::tk_alias, // typecode kind for typedefs
-      64, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5669), ACE_NTOHL (0x73696269), ACE_NTOHL (0x6c697479), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Visibility:1.0
-        11, ACE_NTOHL (0x56697369), ACE_NTOHL (0x62696c69), ACE_NTOHL (0x74790000),  // name = Visibility
-        CORBA::tk_short,
-
-
-
-    0U,
-
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_ValueMemberSeq (CORBA::tk_alias, sizeof (_oc_IR_ValueMemberSeq), (char *) &_oc_IR_ValueMemberSeq, 0, sizeof (IR::ValueMemberSeq));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueMemberSeq, &_tc_TAO_tc_IR_ValueMemberSeq)
-TAO_NAMESPACE_END
-
-///////////////////////////////////////////////////////////////////////
-//                Base & Remote Proxy  Implementation. 
-//
-
-IR::_TAO_ValueMemberDef_Proxy_Impl::_TAO_ValueMemberDef_Proxy_Impl (void)
-{}
-
-IR::_TAO_ValueMemberDef_Remote_Proxy_Impl::_TAO_ValueMemberDef_Remote_Proxy_Impl (void)
-{}
-
-// Remote Implementation of the IDL interface methods
-
-CORBA::TypeCode_ptr IR::_TAO_ValueMemberDef_Remote_Proxy_Impl::type (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
-  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_type",
-      9,
-      0,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              CORBA::TypeCode_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
-}
-
-IR::IDLType_ptr IR::_TAO_ValueMemberDef_Remote_Proxy_Impl::type_def (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  IR::IDLType_ptr _tao_retval = IR::IDLType::_nil ();
-  IR::IDLType_var _tao_safe_retval (_tao_retval);
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_type_def",
-      13,
-      0,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_def_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::IDLType_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
-}
-
-void IR::_TAO_ValueMemberDef_Remote_Proxy_Impl::type_def (
-    CORBA_Object *_collocated_tao_target_,
-    IR::IDLType_ptr type_def,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW (CORBA::INTERNAL ());
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_set_type_def",
-      13,
-      1,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_def_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        type_def,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << type_def)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  
-}
-
-CORBA::Visibility IR::_TAO_ValueMemberDef_Remote_Proxy_Impl::access (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  CORBA::Visibility _tao_retval = 0;
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_access",
-      11,
-      0,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_access_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_retval)
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              CORBA::Visibility  _tao_retval_info = _tao_retval;
-               ri.result (_tao_retval_info);
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_retval;
-}
-
-void IR::_TAO_ValueMemberDef_Remote_Proxy_Impl::access (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Visibility access,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW (CORBA::INTERNAL ());
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_set_access",
-      11,
-      1,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_access_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        access,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << access)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  
-}
-
-
-//
-//            End  Base & Remote  Proxy Implemeentation. 
-///////////////////////////////////////////////////////////////////////
-
-
-///////////////////////////////////////////////////////////////////////
-//           Remote & Base  Proxy Broker Implementation
-//
-
-IR::_TAO_ValueMemberDef_Proxy_Broker::_TAO_ValueMemberDef_Proxy_Broker (void)
-{
-}
-
-IR::_TAO_ValueMemberDef_Proxy_Broker::~_TAO_ValueMemberDef_Proxy_Broker (void)
-{
-}
-
-// Factory Member function Implementation.
-IR::_TAO_ValueMemberDef_Remote_Proxy_Broker *IR::_TAO_ValueMemberDef_Remote_Proxy_Broker::the_TAO_ValueMemberDef_Remote_Proxy_Broker (void)
-{
-  static ::IR::_TAO_ValueMemberDef_Remote_Proxy_Broker remote_proxy_broker;
-  return &remote_proxy_broker;
-}
-
-IR::_TAO_ValueMemberDef_Remote_Proxy_Broker::_TAO_ValueMemberDef_Remote_Proxy_Broker (void)
-{
-}
-
-IR::_TAO_ValueMemberDef_Remote_Proxy_Broker::~_TAO_ValueMemberDef_Remote_Proxy_Broker (void)
-{
-}
-
-IR::_TAO_ValueMemberDef_Proxy_Impl&
-IR::_TAO_ValueMemberDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::ValueMemberDef *object,
-  CORBA::Environment &ACE_TRY_ENV
-)
-{
-  ACE_UNUSED_ARG (object);
-  ACE_UNUSED_ARG (ACE_TRY_ENV);
-  return remote_proxy_impl_;
-}
-
-
-//
-//           End Remote & Base Proxy Broker Implementation
-///////////////////////////////////////////////////////////////////////
-
-
-// default constructor
-IR::ValueMemberDef::ValueMemberDef (int collocated)
-{
-  this->_tao_setup_collocation (collocated);
-}
-
-// destructor
-IR::ValueMemberDef::~ValueMemberDef (void)
-{}
-
-void
-IR::ValueMemberDef::_tao_setup_collocation (int collocated)
-{
-  if (collocated)
-    this->the_TAO_ValueMemberDef_Proxy_Broker_ =
-      ::IR__TAO_ValueMemberDef_Proxy_Broker_Factory_function_pointer (this);
-  else
-    this->the_TAO_ValueMemberDef_Proxy_Broker_ =
-      ::IR::_TAO_ValueMemberDef_Remote_Proxy_Broker::the_TAO_ValueMemberDef_Remote_Proxy_Broker ();
-  
-  ACE_NESTED_CLASS (IR, Contained)::_tao_setup_collocation (collocated);
-}
-
-void IR::ValueMemberDef::_tao_any_destructor (void *x)
-{
-  ValueMemberDef *tmp = ACE_static_cast (ValueMemberDef*,x);
-  CORBA::release (tmp);
-}
-
-IR::ValueMemberDef_ptr IR::ValueMemberDef::_narrow (
-    CORBA::Object_ptr obj,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-{
-  if (CORBA::is_nil (obj))
-    return ValueMemberDef::_nil ();
-  if (! obj->_is_local ())
-    {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ValueMemberDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (ValueMemberDef::_nil ());
-      if (is_a == 0)
-        return ValueMemberDef::_nil ();
-    }
-  return ValueMemberDef::_unchecked_narrow (obj, ACE_TRY_ENV);
-}
-
-IR::ValueMemberDef_ptr IR::ValueMemberDef::_unchecked_narrow (
-    CORBA::Object_ptr obj,
-    CORBA::Environment &
-  )
-{
-  if (CORBA::is_nil (obj))
-    return ValueMemberDef::_nil ();
-  if (! obj->_is_local ())
-    {
-      TAO_Stub* stub = obj->_stubobj ();
-      if (stub)
-        stub->_incr_refcnt ();
-      ValueMemberDef_ptr default_proxy = ValueMemberDef::_nil ();
-
-      if (
-          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
-          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_ValueMemberDef_Proxy_Broker_Factory_function_pointer != 0
-        )
-      {
-        ACE_NEW_RETURN (
-          default_proxy,
-          ::IR::ValueMemberDef (
-            stub,
-            1,
-            obj->_servant ()),
-            
-          ValueMemberDef::_nil ());
-        }
-      if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::ValueMemberDef (stub, 0, obj->_servant ()), ValueMemberDef::_nil ());
-        return default_proxy;
-      }
-    else 
-      return
-        ACE_reinterpret_cast
-          (
-            ValueMemberDef_ptr,
-              obj->_tao_QueryInterface
-                (
-                  ACE_reinterpret_cast
-                    (
-                      ptr_arith_t,
-                      &ValueMemberDef::_narrow
-                    )
-                )
-          );
-}
-
-IR::ValueMemberDef_ptr
-IR::ValueMemberDef::_duplicate (ValueMemberDef_ptr obj)
-{
-  if (!CORBA::is_nil (obj))
-    obj->_add_ref ();
-  return obj;
-}
-
-CORBA::Boolean IR::ValueMemberDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
-{
-  if (
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ValueMemberDef:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
-  return 1; // success using local knowledge
-  else
-    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
-}
-
-void *IR::ValueMemberDef::_tao_QueryInterface (ptr_arith_t type)
-{
-  void *retv = 0;
-  if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, ValueMemberDef)::_narrow))
-    retv = ACE_reinterpret_cast (void*, this);
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Contained)::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            IR::Contained_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            CORBA::IRObject_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
-    retv = ACE_reinterpret_cast (void *,
-      ACE_static_cast (CORBA::Object_ptr, this));
-    
-  if (retv)
-    this->_add_ref ();
-  return retv;
-}
-
-const char* IR::ValueMemberDef::_interface_repository_id (void) const
-{
-  return "IDL:omg.org/IR/ValueMemberDef:1.0";
-}
-
-CORBA::TypeCode_ptr IR::ValueMemberDef::type (
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_ValueMemberDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type (
-      this,
-      ACE_TRY_ENV
-    );
-}
-
-IR::IDLType_ptr IR::ValueMemberDef::type_def (
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_ValueMemberDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type_def (
-      this,
-      ACE_TRY_ENV
-    );
-}
-
-void IR::ValueMemberDef::type_def (
-    IR::IDLType_ptr type_def,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  this->the_TAO_ValueMemberDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type_def (
-      this,
-      type_def,
-      ACE_TRY_ENV
-    );
-}
-
-CORBA::Visibility IR::ValueMemberDef::access (
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_ValueMemberDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).access (
-      this,
-      ACE_TRY_ENV
-    );
-}
-
-void IR::ValueMemberDef::access (
-    CORBA::Visibility access,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  this->the_TAO_ValueMemberDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).access (
-      this,
-      access,
-      ACE_TRY_ENV
-    );
-}
-
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-IR::ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_get::TAO_ClientRequestInfo_IR_ValueMemberDef_type_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_get::result (CORBA::TypeCode_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_def_get::TAO_ClientRequestInfo_IR_ValueMemberDef_type_def_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_def_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_def_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_def_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_def_get::result (IR::IDLType_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_def_set::TAO_ClientRequestInfo_IR_ValueMemberDef_type_def_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    IR::IDLType_ptr type_def,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    type_def_ (type_def)
-{}
-
-Dynamic::ParameterList *
-IR::ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_def_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_type_def = parameter_list->length ();
-  parameter_list->length (length_type_def + 1);
-  (*parameter_list)[length_type_def].argument <<=  this->type_def_;
-  
-  (*parameter_list)[length_type_def].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_def_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_def_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
-}
-
-IR::ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_access_get::TAO_ClientRequestInfo_IR_ValueMemberDef_access_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_access_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_access_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_access_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_access_get::result (CORBA::Visibility result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_access_set::TAO_ClientRequestInfo_IR_ValueMemberDef_access_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const CORBA::Visibility & access,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    access_ (access)
-{}
-
-Dynamic::ParameterList *
-IR::ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_access_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_access = parameter_list->length ();
-  parameter_list->length (length_access + 1);
-  (*parameter_list)[length_access].argument <<= access_;
-  (*parameter_list)[length_access].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_access_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_access_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
-}
-
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_ValueMemberDef[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65724465), ACE_NTOHL (0x663a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ValueMemberDef:1.0
-  15, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657244), ACE_NTOHL (0x65660000),  // name = ValueMemberDef
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_ValueMemberDef (CORBA::tk_objref, sizeof (_oc_IR_ValueMemberDef), (char *) &_oc_IR_ValueMemberDef, 0, sizeof (IR::ValueMemberDef));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueMemberDef, &_tc_TAO_tc_IR_ValueMemberDef)
-TAO_NAMESPACE_END
-
-///////////////////////////////////////////////////////////////////////
-//                Base & Remote Proxy  Implementation. 
-//
-
-IR::_TAO_ValueDef_Proxy_Impl::_TAO_ValueDef_Proxy_Impl (void)
-{}
-
-IR::_TAO_ValueDef_Remote_Proxy_Impl::_TAO_ValueDef_Remote_Proxy_Impl (void)
-{}
-
-// Remote Implementation of the IDL interface methods
-
-IR::InterfaceDefSeq * IR::_TAO_ValueDef_Remote_Proxy_Impl::supported_interfaces (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  IR::InterfaceDefSeq *_tao_retval = 0;
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
-  
-  ACE_NEW_RETURN (_tao_retval, IR::InterfaceDefSeq, _tao_retval);
-  IR::InterfaceDefSeq_var _tao_safe_retval (_tao_retval);
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_supported_interfaces",
-      25,
-      0,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_supported_interfaces_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::InterfaceDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
-}
-
-void IR::_TAO_ValueDef_Remote_Proxy_Impl::supported_interfaces (
-    CORBA_Object *_collocated_tao_target_,
-    const IR::InterfaceDefSeq & supported_interfaces,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW (CORBA::INTERNAL ());
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_set_supported_interfaces",
-      25,
-      1,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_supported_interfaces_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        supported_interfaces,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << supported_interfaces)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  
-}
-
-IR::InitializerSeq * IR::_TAO_ValueDef_Remote_Proxy_Impl::initializers (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  IR::InitializerSeq *_tao_retval = 0;
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
-  
-  ACE_NEW_RETURN (_tao_retval, IR::InitializerSeq, _tao_retval);
-  IR::InitializerSeq_var _tao_safe_retval (_tao_retval);
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_initializers",
-      17,
-      0,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_initializers_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::InitializerSeq * _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
-}
-
-void IR::_TAO_ValueDef_Remote_Proxy_Impl::initializers (
-    CORBA_Object *_collocated_tao_target_,
-    const IR::InitializerSeq & initializers,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW (CORBA::INTERNAL ());
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_set_initializers",
-      17,
-      1,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_initializers_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        initializers,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << initializers)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  
-}
-
-IR::ValueDef_ptr IR::_TAO_ValueDef_Remote_Proxy_Impl::base_value (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  IR::ValueDef_ptr _tao_retval = IR::ValueDef::_nil ();
-  IR::ValueDef_var _tao_safe_retval (_tao_retval);
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_base_value",
-      15,
-      0,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_base_value_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::ValueDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
-}
-
-void IR::_TAO_ValueDef_Remote_Proxy_Impl::base_value (
-    CORBA_Object *_collocated_tao_target_,
-    IR::ValueDef_ptr base_value,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW (CORBA::INTERNAL ());
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_set_base_value",
-      15,
-      1,
-      istub->orb_core ()
-    );
+            3, ACE_NTOHL (0x69640000),  // name = id
+            CORBA::tk_alias, // typecode kind for typedefs
+            68, // encapsulation length
+              TAO_ENCAP_BYTE_ORDER, // byte order
+              32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+              13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+              CORBA::tk_string, 
+              0U, // string length
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_base_value_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        base_value,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << base_value)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+            11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
+            CORBA::tk_alias, // typecode kind for typedefs
+            68, // encapsulation length
+              TAO_ENCAP_BYTE_ORDER, // byte order
+              32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+              13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+              CORBA::tk_string, 
+              0U, // string length
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  
-}
+            8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
+            CORBA::tk_alias, // typecode kind for typedefs
+            64, // encapsulation length
+              TAO_ENCAP_BYTE_ORDER, // byte order
+              31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
+              12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
+              CORBA::tk_string, 
+              0U, // string length
 
-IR::ValueDefSeq * IR::_TAO_ValueDef_Remote_Proxy_Impl::abstract_base_values (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  IR::ValueDefSeq *_tao_retval = 0;
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+            5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+            CORBA::tk_TypeCode,
 
-  
-  ACE_NEW_RETURN (_tao_retval, IR::ValueDefSeq, _tao_retval);
-  IR::ValueDefSeq_var _tao_safe_retval (_tao_retval);
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_abstract_base_values",
-      25,
-      0,
-      istub->orb_core ()
-    );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_abstract_base_values_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::ValueDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+          0U,
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
-}
 
-void IR::_TAO_ValueDef_Remote_Proxy_Impl::abstract_base_values (
-    CORBA_Object *_collocated_tao_target_,
-    const IR::ValueDefSeq & abstract_base_values,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
+      15, ACE_NTOHL (0x7075745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = put_exceptions
+      CORBA::tk_alias, // typecode kind for typedefs
+      536, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
+        18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
+        CORBA::tk_sequence, // typecode kind
+        456, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          CORBA::tk_struct, // typecode kind
+          440, // encapsulation length
+            TAO_ENCAP_BYTE_ORDER, // byte order
+            40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
+            21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
+            5, // member count
+            5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+            CORBA::tk_alias, // typecode kind for typedefs
+            64, // encapsulation length
+              TAO_ENCAP_BYTE_ORDER, // byte order
+              30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+              11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+              CORBA::tk_string, 
+              0U, // string length
 
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW (CORBA::INTERNAL ());
+            3, ACE_NTOHL (0x69640000),  // name = id
+            CORBA::tk_alias, // typecode kind for typedefs
+            68, // encapsulation length
+              TAO_ENCAP_BYTE_ORDER, // byte order
+              32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+              13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+              CORBA::tk_string, 
+              0U, // string length
 
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_set_abstract_base_values",
-      25,
-      1,
-      istub->orb_core ()
-    );
+            11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
+            CORBA::tk_alias, // typecode kind for typedefs
+            68, // encapsulation length
+              TAO_ENCAP_BYTE_ORDER, // byte order
+              32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+              13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+              CORBA::tk_string, 
+              0U, // string length
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_abstract_base_values_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        abstract_base_values,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << abstract_base_values)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+            8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
+            CORBA::tk_alias, // typecode kind for typedefs
+            64, // encapsulation length
+              TAO_ENCAP_BYTE_ORDER, // byte order
+              31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
+              12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
+              CORBA::tk_string, 
+              0U, // string length
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  
-}
+            5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+            CORBA::tk_TypeCode,
 
-CORBA::Boolean IR::_TAO_ValueDef_Remote_Proxy_Impl::is_abstract (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  CORBA::Boolean _tao_retval = 0;
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
 
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_is_abstract",
-      16,
-      0,
-      istub->orb_core ()
-    );
+          0U,
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_abstract_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              CORBA::Boolean  _tao_retval_info = _tao_retval;
-               ri.result (_tao_retval_info);
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_retval;
-}
 
-void IR::_TAO_ValueDef_Remote_Proxy_Impl::is_abstract (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Boolean is_abstract,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
+    0U,
 
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW (CORBA::INTERNAL ());
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_AttrDescriptionSeq (CORBA::tk_alias, sizeof (_oc_IR_AttrDescriptionSeq), (char *) &_oc_IR_AttrDescriptionSeq, 0, sizeof (IR_AttrDescriptionSeq));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AttrDescriptionSeq, &_tc_TAO_tc_IR_AttrDescriptionSeq)
+TAO_NAMESPACE_END
 
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_set_is_abstract",
-      16,
-      1,
-      istub->orb_core ()
-    );
+///////////////////////////////////////////////////////////////////////
+//                Base & Remote Proxy  Implementation. 
+//
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_abstract_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        is_abstract,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << CORBA::Any::from_boolean (is_abstract))
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+_TAO_InterfaceDef_Proxy_Impl::_TAO_InterfaceDef_Proxy_Impl (void)
+{}
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  
-}
+_TAO_InterfaceDef_Remote_Proxy_Impl::_TAO_InterfaceDef_Remote_Proxy_Impl (void)
+{}
+
+// Remote Implementation of the IDL interface methods
 
-CORBA::Boolean IR::_TAO_ValueDef_Remote_Proxy_Impl::is_custom (
+IR_InterfaceDefSeq * _TAO_InterfaceDef_Remote_Proxy_Impl::base_interfaces (
     CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -39269,168 +18202,77 @@
   ))
 {
   
-  CORBA::Boolean _tao_retval = 0;
+  IR_InterfaceDefSeq *_tao_retval = 0;
   
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
   
+  ACE_NEW_RETURN (_tao_retval, IR_InterfaceDefSeq, _tao_retval);
+  IR_InterfaceDefSeq_var _tao_safe_retval (_tao_retval);
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_get_is_custom",
-      14,
+      "_get_base_interfaces",
+      20,
       0,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_custom_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              CORBA::Boolean  _tao_retval_info = _tao_retval;
-               ri.result (_tao_retval_info);
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
         }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_retval;
+  return _tao_safe_retval._retn ();
 }
 
-void IR::_TAO_ValueDef_Remote_Proxy_Impl::is_custom (
+void _TAO_InterfaceDef_Remote_Proxy_Impl::base_interfaces (
     CORBA_Object *_collocated_tao_target_,
-    CORBA::Boolean is_custom,
+    const IR_InterfaceDefSeq & base_interfaces,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-
-  
-  
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW (CORBA::INTERNAL ());
@@ -39438,139 +18280,54 @@
   
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_set_is_custom",
-      14,
+      "_set_base_interfaces",
+      20,
       1,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_custom_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        is_custom,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << CORBA::Any::from_boolean (is_custom))
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << base_interfaces)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
       
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
         }
-      
-      break;
-    }
-  
+        
+        break;
+      }
 }
 
-CORBA::Boolean IR::_TAO_ValueDef_Remote_Proxy_Impl::is_truncatable (
+CORBA::Boolean _TAO_InterfaceDef_Remote_Proxy_Impl::is_abstract (
     CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -39589,158 +18346,65 @@
   
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_get_is_truncatable",
-      19,
+      "_get_is_abstract",
+      16,
       0,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_truncatable_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              CORBA::Boolean  _tao_retval_info = _tao_retval;
-               ri.result (_tao_retval_info);
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
+        ACE_CHECK_RETURN  (_tao_retval);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              _tao_retval
+            );
         }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                _tao_retval
+              );
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_retval;
 }
 
-void IR::_TAO_ValueDef_Remote_Proxy_Impl::is_truncatable (
+void _TAO_InterfaceDef_Remote_Proxy_Impl::is_abstract (
     CORBA_Object *_collocated_tao_target_,
-    CORBA::Boolean is_truncatable,
+    CORBA::Boolean is_abstract,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
-  
-
-  
-  
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
     ACE_THROW (CORBA::INTERNAL ());
@@ -39748,141 +18412,55 @@
   
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_set_is_truncatable",
-      19,
+      "_set_is_abstract",
+      16,
       1,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_truncatable_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        is_truncatable,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << CORBA::Any::from_boolean (is_truncatable))
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << CORBA::Any::from_boolean (is_abstract))
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
       
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
         }
-      
-      break;
-    }
-  
+        
+        break;
+      }
 }
 
-CORBA::Boolean IR::_TAO_ValueDef_Remote_Proxy_Impl::is_a (
+CORBA::Boolean _TAO_InterfaceDef_Remote_Proxy_Impl::is_local (
     CORBA_Object *_collocated_tao_target_,
-    const char * id,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -39900,163 +18478,122 @@
   
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "is_a",
-      4,
-      1,
+      "_get_is_local",
+      13,
+      0,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_a ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        id,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << id)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN  (_tao_retval);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
               _tao_retval
             );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
+          ))
+          {
+            ACE_THROW_RETURN (
                 CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                 _tao_retval
               );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              CORBA::Boolean  _tao_retval_info = _tao_retval;
-               ri.result (_tao_retval_info);
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+          }
+        break;
+      }
+
+  return _tao_retval;
+}
+
+void _TAO_InterfaceDef_Remote_Proxy_Impl::is_local (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::Boolean is_local,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW (CORBA::INTERNAL ());
+
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_set_is_local",
+      13,
+      1,
+      istub->orb_core ()
+    );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << CORBA::Any::from_boolean (is_local))
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN  (_tao_retval);
       
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
         }
-      
-      break;
-    }
-  return _tao_retval;
+        
+        break;
+      }
 }
 
-IR::ValueMemberDef_ptr IR::_TAO_ValueDef_Remote_Proxy_Impl::create_value_member (
+CORBA::Boolean _TAO_InterfaceDef_Remote_Proxy_Impl::is_a (
     CORBA_Object *_collocated_tao_target_,
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::IDLType_ptr type,
-    CORBA::Visibility access,
+    const char * interface_id,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -40064,185 +18601,85 @@
   ))
 {
   
-  IR::ValueMemberDef_ptr _tao_retval = IR::ValueMemberDef::_nil ();
-  IR::ValueMemberDef_var _tao_safe_retval (_tao_retval);
+  CORBA::Boolean _tao_retval = 0;
   
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
 
   
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "create_value_member",
-      19,
+      "is_a",
+      4,
       1,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_value_member ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        id,
-        name,
-        version,
-        type,
-        access,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << id) &&
-              (_tao_out << name) &&
-              (_tao_out << version) &&
-              (_tao_out << type) &&
-              (_tao_out << access)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
-              0
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::ValueMemberDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << interface_id)
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            _tao_retval
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
       
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              _tao_retval
+            );
         }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                _tao_retval
+              );
+          }
+        break;
+      }
+
+  return _tao_retval;
 }
 
-IR::AttributeDef_ptr IR::_TAO_ValueDef_Remote_Proxy_Impl::create_attribute (
+IR_AttributeDef_ptr _TAO_InterfaceDef_Remote_Proxy_Impl::create_attribute (
     CORBA_Object *_collocated_tao_target_,
     const char * id,
     const char * name,
     const char * version,
-    IR::IDLType_ptr type,
-    IR::AttributeMode mode,
-    const IR::ExceptionDefSeq & get_exceptions,
-    const IR::ExceptionDefSeq & put_exceptions,
+    IR_IDLType_ptr type,
+    IR_AttributeMode mode,
+    const IR_ExceptionDefSeq & get_exceptions,
+    const IR_ExceptionDefSeq & put_exceptions,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -40250,8 +18687,8 @@
   ))
 {
   
-  IR::AttributeDef_ptr _tao_retval = IR::AttributeDef::_nil ();
-  IR::AttributeDef_var _tao_safe_retval (_tao_retval);
+  IR_AttributeDef_ptr _tao_retval = IR_AttributeDef::_nil ();
+  IR_AttributeDef_var _tao_safe_retval (_tao_retval);
   
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
@@ -40267,173 +18704,76 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_attribute ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        id,
-        name,
-        version,
-        type,
-        mode,
-        get_exceptions,
-        put_exceptions,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << id) &&
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << id) &&
               (_tao_out << name) &&
               (_tao_out << version) &&
               (_tao_out << type) &&
               (_tao_out << mode) &&
               (_tao_out << get_exceptions) &&
               (_tao_out << put_exceptions)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
               0
             );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
                 CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                 0
               );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::AttributeDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
-IR::OperationDef_ptr IR::_TAO_ValueDef_Remote_Proxy_Impl::create_operation (
+IR_OperationDef_ptr _TAO_InterfaceDef_Remote_Proxy_Impl::create_operation (
     CORBA_Object *_collocated_tao_target_,
     const char * id,
     const char * name,
     const char * version,
-    IR::IDLType_ptr result,
-    IR::OperationMode mode,
-    const IR::ParDescriptionSeq & params,
-    const IR::ExceptionDefSeq & exceptions,
-    const IR::ContextIdSeq & contexts,
+    IR_IDLType_ptr result,
+    IR_OperationMode mode,
+    const IR_ParDescriptionSeq & params,
+    const IR_ExceptionDefSeq & exceptions,
+    const IR_ContextIdSeq & contexts,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -40441,8 +18781,8 @@
   ))
 {
   
-  IR::OperationDef_ptr _tao_retval = IR::OperationDef::_nil ();
-  IR::OperationDef_var _tao_safe_retval (_tao_retval);
+  IR_OperationDef_ptr _tao_retval = IR_OperationDef::_nil ();
+  IR_OperationDef_var _tao_safe_retval (_tao_retval);
   
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
@@ -40458,60 +18798,22 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_operation ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        id,
-        name,
-        version,
-        result,
-        mode,
-        params,
-        exceptions,
-        contexts,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << id) &&
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << id) &&
               (_tao_out << name) &&
               (_tao_out << version) &&
               (_tao_out << result) &&
@@ -40519,101 +18821,41 @@
               (_tao_out << params) &&
               (_tao_out << exceptions) &&
               (_tao_out << contexts)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
               0
             );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
                 CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                 0
               );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::OperationDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
@@ -40627,32 +18869,32 @@
 //           Remote & Base  Proxy Broker Implementation
 //
 
-IR::_TAO_ValueDef_Proxy_Broker::_TAO_ValueDef_Proxy_Broker (void)
+_TAO_InterfaceDef_Proxy_Broker::_TAO_InterfaceDef_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_ValueDef_Proxy_Broker::~_TAO_ValueDef_Proxy_Broker (void)
+_TAO_InterfaceDef_Proxy_Broker::~_TAO_InterfaceDef_Proxy_Broker (void)
 {
 }
 
-// Factory Member function Implementation.
-IR::_TAO_ValueDef_Remote_Proxy_Broker *IR::_TAO_ValueDef_Remote_Proxy_Broker::the_TAO_ValueDef_Remote_Proxy_Broker (void)
+// Factory function Implementation.
+_TAO_InterfaceDef_Remote_Proxy_Broker *the_TAO_InterfaceDef_Remote_Proxy_Broker (void)
 {
-  static ::IR::_TAO_ValueDef_Remote_Proxy_Broker remote_proxy_broker;
+  static ::_TAO_InterfaceDef_Remote_Proxy_Broker remote_proxy_broker;
   return &remote_proxy_broker;
 }
 
-IR::_TAO_ValueDef_Remote_Proxy_Broker::_TAO_ValueDef_Remote_Proxy_Broker (void)
+_TAO_InterfaceDef_Remote_Proxy_Broker::_TAO_InterfaceDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_ValueDef_Remote_Proxy_Broker::~_TAO_ValueDef_Remote_Proxy_Broker (void)
+_TAO_InterfaceDef_Remote_Proxy_Broker::~_TAO_InterfaceDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_ValueDef_Proxy_Impl&
-IR::_TAO_ValueDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::ValueDef *object,
+_TAO_InterfaceDef_Proxy_Impl&
+_TAO_InterfaceDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_InterfaceDef *object,
   CORBA::Environment &ACE_TRY_ENV
 )
 {
@@ -40668,114 +18910,115 @@
 
 
 // default constructor
-IR::ValueDef::ValueDef (int collocated)
+IR_InterfaceDef::IR_InterfaceDef (int collocated)
 {
   this->_tao_setup_collocation (collocated);
 }
 
 // destructor
-IR::ValueDef::~ValueDef (void)
+IR_InterfaceDef::~IR_InterfaceDef (void)
 {}
 
 void
-IR::ValueDef::_tao_setup_collocation (int collocated)
+IR_InterfaceDef::_tao_setup_collocation (int collocated)
 {
   if (collocated)
-    this->the_TAO_ValueDef_Proxy_Broker_ =
-      ::IR__TAO_ValueDef_Proxy_Broker_Factory_function_pointer (this);
+    this->the_TAO_InterfaceDef_Proxy_Broker_ =
+      _TAO_InterfaceDef_Proxy_Broker_Factory_function_pointer (this);
   else
-    this->the_TAO_ValueDef_Proxy_Broker_ =
-      ::IR::_TAO_ValueDef_Remote_Proxy_Broker::the_TAO_ValueDef_Remote_Proxy_Broker ();
+    this->the_TAO_InterfaceDef_Proxy_Broker_ =
+      ::the_TAO_InterfaceDef_Remote_Proxy_Broker ();
+  
+  IR_Container::_tao_setup_collocation (collocated);
+  IR_Contained::_tao_setup_collocation (collocated);
+  IR_IDLType::_tao_setup_collocation (collocated);
   
-  ACE_NESTED_CLASS (IR, Container)::_tao_setup_collocation (collocated);
-  ACE_NESTED_CLASS (IR, Contained)::_tao_setup_collocation (collocated);
-  ACE_NESTED_CLASS (IR, IDLType)::_tao_setup_collocation (collocated);
 }
 
-void IR::ValueDef::_tao_any_destructor (void *x)
+void IR_InterfaceDef::_tao_any_destructor (void *x)
 {
-  ValueDef *tmp = ACE_static_cast (ValueDef*,x);
+  IR_InterfaceDef *tmp = ACE_static_cast (IR_InterfaceDef*,x);
   CORBA::release (tmp);
 }
 
-IR::ValueDef_ptr IR::ValueDef::_narrow (
+IR_InterfaceDef_ptr IR_InterfaceDef::_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
 {
   if (CORBA::is_nil (obj))
-    return ValueDef::_nil ();
+    return IR_InterfaceDef::_nil ();
   if (! obj->_is_local ())
     {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ValueDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (ValueDef::_nil ());
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/InterfaceDef:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (IR_InterfaceDef::_nil ());
       if (is_a == 0)
-        return ValueDef::_nil ();
+        return IR_InterfaceDef::_nil ();
     }
-  return ValueDef::_unchecked_narrow (obj, ACE_TRY_ENV);
+  return IR_InterfaceDef::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::ValueDef_ptr IR::ValueDef::_unchecked_narrow (
+IR_InterfaceDef_ptr IR_InterfaceDef::_unchecked_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &
   )
 {
   if (CORBA::is_nil (obj))
-    return ValueDef::_nil ();
+    return IR_InterfaceDef::_nil ();
   if (! obj->_is_local ())
     {
       TAO_Stub* stub = obj->_stubobj ();
       if (stub)
         stub->_incr_refcnt ();
-      ValueDef_ptr default_proxy = ValueDef::_nil ();
+      IR_InterfaceDef_ptr default_proxy = IR_InterfaceDef::_nil ();
 
       if (
           !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
           stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_ValueDef_Proxy_Broker_Factory_function_pointer != 0
+          obj->_is_collocated () &&_TAO_InterfaceDef_Proxy_Broker_Factory_function_pointer != 0
         )
       {
         ACE_NEW_RETURN (
           default_proxy,
-          ::IR::ValueDef (
+          ::IR_InterfaceDef (
             stub,
             1,
             obj->_servant ()),
             
-          ValueDef::_nil ());
+          IR_InterfaceDef::_nil ());
         }
       if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::ValueDef (stub, 0, obj->_servant ()), ValueDef::_nil ());
+        ACE_NEW_RETURN (default_proxy, ::IR_InterfaceDef (stub, 0, obj->_servant ()), IR_InterfaceDef::_nil ());
         return default_proxy;
       }
     else 
       return
         ACE_reinterpret_cast
           (
-            ValueDef_ptr,
+            IR_InterfaceDef_ptr,
               obj->_tao_QueryInterface
                 (
                   ACE_reinterpret_cast
                     (
                       ptr_arith_t,
-                      &ValueDef::_narrow
+                      &IR_InterfaceDef::_narrow
                     )
                 )
           );
 }
 
-IR::ValueDef_ptr
-IR::ValueDef::_duplicate (ValueDef_ptr obj)
+IR_InterfaceDef_ptr
+IR_InterfaceDef::_duplicate (IR_InterfaceDef_ptr obj)
 {
   if (!CORBA::is_nil (obj))
     obj->_add_ref ();
   return obj;
 }
 
-CORBA::Boolean IR::ValueDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+CORBA::Boolean IR_InterfaceDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
   if (
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ValueDef:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/InterfaceDef:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
@@ -40786,166 +19029,76 @@
     return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
 }
 
-void *IR::ValueDef::_tao_QueryInterface (ptr_arith_t type)
+void *IR_InterfaceDef::_tao_QueryInterface (ptr_arith_t type)
 {
   void *retv = 0;
   if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, ValueDef)::_narrow))
+      &IR_InterfaceDef::_narrow))
     retv = ACE_reinterpret_cast (void*, this);
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Container)::_narrow))
+      &IR_Container::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::Container_ptr,
+            IR_Container_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Contained)::_narrow))
+      &IR_Contained::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::Contained_ptr,
+            IR_Contained_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, IDLType)::_narrow))
+      &IR_IDLType::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::IDLType_ptr,
+            IR_IDLType_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
+      &CORBA_IRObject::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
-        ACE_static_cast
-          (
-            CORBA::IRObject_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
-    retv = ACE_reinterpret_cast (void *,
-      ACE_static_cast (CORBA::Object_ptr, this));
-    
-  if (retv)
-    this->_add_ref ();
-  return retv;
-}
-
-const char* IR::ValueDef::_interface_repository_id (void) const
-{
-  return "IDL:omg.org/IR/ValueDef:1.0";
-}
-
-IR::InterfaceDefSeq * IR::ValueDef::supported_interfaces (
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).supported_interfaces (
-      this,
-      ACE_TRY_ENV
-    );
-}
-
-void IR::ValueDef::supported_interfaces (
-    const IR::InterfaceDefSeq & supported_interfaces,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).supported_interfaces (
-      this,
-      supported_interfaces,
-      ACE_TRY_ENV
-    );
-}
-
-IR::InitializerSeq * IR::ValueDef::initializers (
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).initializers (
-      this,
-      ACE_TRY_ENV
-    );
-}
-
-void IR::ValueDef::initializers (
-    const IR::InitializerSeq & initializers,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).initializers (
-      this,
-      initializers,
-      ACE_TRY_ENV
-    );
-}
-
-IR::ValueDef_ptr IR::ValueDef::base_value (
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).base_value (
-      this,
-      ACE_TRY_ENV
-    );
+        ACE_static_cast
+          (
+            CORBA_IRObject_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
+    retv = ACE_reinterpret_cast (void *,
+      ACE_static_cast (CORBA::Object_ptr, this));
+    
+  if (retv)
+    this->_add_ref ();
+  return retv;
 }
 
-void IR::ValueDef::base_value (
-    IR::ValueDef_ptr base_value,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
+const char* IR_InterfaceDef::_interface_repository_id (void) const
 {
-  
-  this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).base_value (
-      this,
-      base_value,
-      ACE_TRY_ENV
-    );
+  return "IDL:omg.org/IR/InterfaceDef:1.0";
 }
 
-IR::ValueDefSeq * IR::ValueDef::abstract_base_values (
+IR_InterfaceDefSeq * IR_InterfaceDef::base_interfaces (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -40953,14 +19106,14 @@
   ))
 {
   
-  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).abstract_base_values (
+  return this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).base_interfaces (
       this,
       ACE_TRY_ENV
     );
 }
 
-void IR::ValueDef::abstract_base_values (
-    const IR::ValueDefSeq & abstract_base_values,
+void IR_InterfaceDef::base_interfaces (
+    const IR_InterfaceDefSeq & base_interfaces,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -40968,14 +19121,14 @@
   ))
 {
   
-  this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).abstract_base_values (
+  this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).base_interfaces (
       this,
-      abstract_base_values,
+      base_interfaces,
       ACE_TRY_ENV
     );
 }
 
-CORBA::Boolean IR::ValueDef::is_abstract (
+CORBA::Boolean IR_InterfaceDef::is_abstract (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -40983,13 +19136,13 @@
   ))
 {
   
-  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_abstract (
+  return this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_abstract (
       this,
       ACE_TRY_ENV
     );
 }
 
-void IR::ValueDef::is_abstract (
+void IR_InterfaceDef::is_abstract (
     CORBA::Boolean is_abstract,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -40998,59 +19151,14 @@
   ))
 {
   
-  this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_abstract (
+  this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_abstract (
       this,
       is_abstract,
       ACE_TRY_ENV
     );
 }
 
-CORBA::Boolean IR::ValueDef::is_custom (
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_custom (
-      this,
-      ACE_TRY_ENV
-    );
-}
-
-void IR::ValueDef::is_custom (
-    CORBA::Boolean is_custom,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_custom (
-      this,
-      is_custom,
-      ACE_TRY_ENV
-    );
-}
-
-CORBA::Boolean IR::ValueDef::is_truncatable (
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_truncatable (
-      this,
-      ACE_TRY_ENV
-    );
-}
-
-void IR::ValueDef::is_truncatable (
-    CORBA::Boolean is_truncatable,
+CORBA::Boolean IR_InterfaceDef::is_local (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -41058,15 +19166,14 @@
   ))
 {
   
-  this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_truncatable (
+  return this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_local (
       this,
-      is_truncatable,
       ACE_TRY_ENV
     );
 }
 
-CORBA::Boolean IR::ValueDef::is_a (
-    const char * id,
+void IR_InterfaceDef::is_local (
+    CORBA::Boolean is_local,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -41074,19 +19181,15 @@
   ))
 {
   
-  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_a (
+  this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_local (
       this,
-      id,
+      is_local,
       ACE_TRY_ENV
     );
 }
 
-IR::ValueMemberDef_ptr IR::ValueDef::create_value_member (
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::IDLType_ptr type,
-    CORBA::Visibility access,
+CORBA::Boolean IR_InterfaceDef::is_a (
+    const char * interface_id,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -41094,25 +19197,21 @@
   ))
 {
   
-  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_value_member (
+  return this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_a (
       this,
-      id,
-      name,
-      version,
-      type,
-      access,
+      interface_id,
       ACE_TRY_ENV
     );
 }
 
-IR::AttributeDef_ptr IR::ValueDef::create_attribute (
+IR_AttributeDef_ptr IR_InterfaceDef::create_attribute (
     const char * id,
     const char * name,
     const char * version,
-    IR::IDLType_ptr type,
-    IR::AttributeMode mode,
-    const IR::ExceptionDefSeq & get_exceptions,
-    const IR::ExceptionDefSeq & put_exceptions,
+    IR_IDLType_ptr type,
+    IR_AttributeMode mode,
+    const IR_ExceptionDefSeq & get_exceptions,
+    const IR_ExceptionDefSeq & put_exceptions,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -41120,7 +19219,7 @@
   ))
 {
   
-  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_attribute (
+  return this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_attribute (
       this,
       id,
       name,
@@ -41133,15 +19232,15 @@
     );
 }
 
-IR::OperationDef_ptr IR::ValueDef::create_operation (
+IR_OperationDef_ptr IR_InterfaceDef::create_operation (
     const char * id,
     const char * name,
     const char * version,
-    IR::IDLType_ptr result,
-    IR::OperationMode mode,
-    const IR::ParDescriptionSeq & params,
-    const IR::ExceptionDefSeq & exceptions,
-    const IR::ContextIdSeq & contexts,
+    IR_IDLType_ptr result,
+    IR_OperationMode mode,
+    const IR_ParDescriptionSeq & params,
+    const IR_ExceptionDefSeq & exceptions,
+    const IR_ContextIdSeq & contexts,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -41149,7 +19248,7 @@
   ))
 {
   
-  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_operation (
+  return this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_operation (
       this,
       id,
       name,
@@ -41163,1196 +19262,493 @@
     );
 }
 
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_supported_interfaces_get::TAO_ClientRequestInfo_IR_ValueDef_supported_interfaces_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_supported_interfaces_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_supported_interfaces_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_supported_interfaces_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_supported_interfaces_get::result (IR::InterfaceDefSeq * result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_supported_interfaces_set::TAO_ClientRequestInfo_IR_ValueDef_supported_interfaces_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const IR::InterfaceDefSeq & supported_interfaces,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    supported_interfaces_ (supported_interfaces)
-{}
-
-Dynamic::ParameterList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_supported_interfaces_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_supported_interfaces = parameter_list->length ();
-  parameter_list->length (length_supported_interfaces + 1);
-  (*parameter_list)[length_supported_interfaces].argument <<=  this->supported_interfaces_;
-  
-  (*parameter_list)[length_supported_interfaces].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_supported_interfaces_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_supported_interfaces_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
-}
-
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_initializers_get::TAO_ClientRequestInfo_IR_ValueDef_initializers_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_initializers_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_initializers_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_initializers_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_initializers_get::result (IR::InitializerSeq * result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_initializers_set::TAO_ClientRequestInfo_IR_ValueDef_initializers_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const IR::InitializerSeq & initializers,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    initializers_ (initializers)
-{}
-
-Dynamic::ParameterList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_initializers_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_initializers = parameter_list->length ();
-  parameter_list->length (length_initializers + 1);
-  (*parameter_list)[length_initializers].argument <<=  this->initializers_;
-  
-  (*parameter_list)[length_initializers].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_initializers_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_initializers_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
-}
-
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_base_value_get::TAO_ClientRequestInfo_IR_ValueDef_base_value_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_base_value_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_base_value_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_base_value_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_base_value_get::result (IR::ValueDef_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_base_value_set::TAO_ClientRequestInfo_IR_ValueDef_base_value_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    IR::ValueDef_ptr base_value,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    base_value_ (base_value)
-{}
-
-Dynamic::ParameterList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_base_value_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_base_value = parameter_list->length ();
-  parameter_list->length (length_base_value + 1);
-  (*parameter_list)[length_base_value].argument <<=  this->base_value_;
-  
-  (*parameter_list)[length_base_value].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_base_value_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_base_value_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
-}
-
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_abstract_base_values_get::TAO_ClientRequestInfo_IR_ValueDef_abstract_base_values_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_abstract_base_values_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_abstract_base_values_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_abstract_base_values_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_abstract_base_values_get::result (IR::ValueDefSeq * result)
+static const CORBA::Long _oc_IR_InterfaceDef[] =
 {
-  // update the result 
-  this->_result = result;
-}
-
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_abstract_base_values_set::TAO_ClientRequestInfo_IR_ValueDef_abstract_base_values_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const IR::ValueDefSeq & abstract_base_values,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    abstract_base_values_ (abstract_base_values)
-{}
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/InterfaceDef:1.0
+  13, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = IR_InterfaceDef
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_InterfaceDef (CORBA::tk_objref, sizeof (_oc_IR_InterfaceDef), (char *) &_oc_IR_InterfaceDef, 0, sizeof (IR_InterfaceDef));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_InterfaceDef, &_tc_TAO_tc_IR_InterfaceDef)
+TAO_NAMESPACE_END
 
-Dynamic::ParameterList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_abstract_base_values_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+static const CORBA::Long _oc_IR_InterfaceDescription[] =
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_abstract_base_values = parameter_list->length ();
-  parameter_list->length (length_abstract_base_values + 1);
-  (*parameter_list)[length_abstract_base_values].argument <<=  this->abstract_base_values_;
-  
-  (*parameter_list)[length_abstract_base_values].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/InterfaceDescription:1.0
+  21, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = InterfaceDescription
+  10, // member count
+  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+  CORBA::tk_alias, // typecode kind for typedefs
+  64, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+    CORBA::tk_string, 
+    0U, // string length
 
-Dynamic::ExceptionList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_abstract_base_values_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
+  3, ACE_NTOHL (0x69640000),  // name = id
+  CORBA::tk_alias, // typecode kind for typedefs
+  68, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+    CORBA::tk_string, 
+    0U, // string length
 
+  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
+  CORBA::tk_alias, // typecode kind for typedefs
+  68, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+    CORBA::tk_string, 
+    0U, // string length
 
-CORBA::Any * 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_abstract_base_values_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
-}
+  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
+  CORBA::tk_alias, // typecode kind for typedefs
+  64, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
+    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
+    CORBA::tk_string, 
+    0U, // string length
 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_abstract_get::TAO_ClientRequestInfo_IR_ValueDef_is_abstract_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
+  11, ACE_NTOHL (0x6f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e730000),  // name = operations
+  CORBA::tk_alias, // typecode kind for typedefs
+  1972, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OpDescriptionSeq:1.0
+    17, ACE_NTOHL (0x4f704465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x0),  // name = OpDescriptionSeq
+    CORBA::tk_sequence, // typecode kind
+    1896, // encapsulation length
+      TAO_ENCAP_BYTE_ORDER, // byte order
+      CORBA::tk_struct, // typecode kind
+      1880, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OperationDescription:1.0
+        21, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = OperationDescription
+        9, // member count
+        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+        CORBA::tk_alias, // typecode kind for typedefs
+        64, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+          CORBA::tk_string, 
+          0U, // string length
 
-Dynamic::ParameterList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_abstract_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
+        3, ACE_NTOHL (0x69640000),  // name = id
+        CORBA::tk_alias, // typecode kind for typedefs
+        68, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+          CORBA::tk_string, 
+          0U, // string length
 
-Dynamic::ExceptionList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_abstract_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
+        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
+        CORBA::tk_alias, // typecode kind for typedefs
+        68, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+          CORBA::tk_string, 
+          0U, // string length
 
+        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
+        CORBA::tk_alias, // typecode kind for typedefs
+        64, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
+          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
+          CORBA::tk_string, 
+          0U, // string length
 
-CORBA::Any * 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_abstract_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
-  return safe_result_any._retn ();
-}
+        7, ACE_NTOHL (0x72657375), ACE_NTOHL (0x6c740000),  // name = result
+        CORBA::tk_TypeCode,
 
-void 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_abstract_get::result (CORBA::Boolean result)
-{
-  // update the result 
-  this->_result = result;
-}
+        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
+        CORBA::tk_enum, // typecode kind
+        100, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/OperationMode:1.0
+          14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
+          2, // member count
+          10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
+          10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY
 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_abstract_set::TAO_ClientRequestInfo_IR_ValueDef_is_abstract_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const CORBA::Boolean & is_abstract,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    is_abstract_ (is_abstract)
-{}
+        9, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x65787473), ACE_NTOHL (0x0),  // name = contexts
+        CORBA::tk_alias, // typecode kind for typedefs
+        228, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ContextIdSeq:1.0
+          13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
+          CORBA::tk_sequence, // typecode kind
+          160, // encapsulation length
+            TAO_ENCAP_BYTE_ORDER, // byte order
+            CORBA::tk_alias, // typecode kind for typedefs
+            144, // encapsulation length
+              TAO_ENCAP_BYTE_ORDER, // byte order
+              37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ContextIdentifier:1.0
+              18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
+              CORBA::tk_alias, // typecode kind for typedefs
+              64, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+                CORBA::tk_string, 
+                0U, // string length
 
-Dynamic::ParameterList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_abstract_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_is_abstract = parameter_list->length ();
-  parameter_list->length (length_is_abstract + 1);
-  (*parameter_list)[length_is_abstract].argument <<= CORBA::Any::from_boolean (this->is_abstract_);
-  (*parameter_list)[length_is_abstract].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
 
-Dynamic::ExceptionList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_abstract_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
+            0U,
 
 
-CORBA::Any * 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_abstract_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
-}
+        11, ACE_NTOHL (0x70617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72730000),  // name = parameters
+        CORBA::tk_alias, // typecode kind for typedefs
+        484, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x61724465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParDescriptionSeq:1.0
+          18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
+          CORBA::tk_sequence, // typecode kind
+          404, // encapsulation length
+            TAO_ENCAP_BYTE_ORDER, // byte order
+            CORBA::tk_struct, // typecode kind
+            388, // encapsulation length
+              TAO_ENCAP_BYTE_ORDER, // byte order
+              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ParameterDescription:1.0
+              21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
+              4, // member count
+              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+              CORBA::tk_alias, // typecode kind for typedefs
+              64, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+                CORBA::tk_string, 
+                0U, // string length
 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_custom_get::TAO_ClientRequestInfo_IR_ValueDef_is_custom_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
+              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+              CORBA::tk_TypeCode,
 
-Dynamic::ParameterList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_custom_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
+              9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
+              CORBA::tk_objref, // typecode kind
+              48, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
+                8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType
 
-Dynamic::ExceptionList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_custom_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
+              5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
+              CORBA::tk_enum, // typecode kind
+              116, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParameterMode:1.0
+                14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
+                3, // member count
+                9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
+                10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
+                12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT
 
 
-CORBA::Any * 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_custom_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
-  return safe_result_any._retn ();
-}
+            0U,
 
-void 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_custom_get::result (CORBA::Boolean result)
-{
-  // update the result 
-  this->_result = result;
-}
 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_custom_set::TAO_ClientRequestInfo_IR_ValueDef_is_custom_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const CORBA::Boolean & is_custom,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    is_custom_ (is_custom)
-{}
+        11, ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = exceptions
+        CORBA::tk_alias, // typecode kind for typedefs
+        536, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
+          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
+          CORBA::tk_sequence, // typecode kind
+          456, // encapsulation length
+            TAO_ENCAP_BYTE_ORDER, // byte order
+            CORBA::tk_struct, // typecode kind
+            440, // encapsulation length
+              TAO_ENCAP_BYTE_ORDER, // byte order
+              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
+              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
+              5, // member count
+              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+              CORBA::tk_alias, // typecode kind for typedefs
+              64, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+                CORBA::tk_string, 
+                0U, // string length
 
-Dynamic::ParameterList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_custom_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_is_custom = parameter_list->length ();
-  parameter_list->length (length_is_custom + 1);
-  (*parameter_list)[length_is_custom].argument <<= CORBA::Any::from_boolean (this->is_custom_);
-  (*parameter_list)[length_is_custom].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
+              3, ACE_NTOHL (0x69640000),  // name = id
+              CORBA::tk_alias, // typecode kind for typedefs
+              68, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+                CORBA::tk_string, 
+                0U, // string length
 
-Dynamic::ExceptionList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_custom_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
+              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
+              CORBA::tk_alias, // typecode kind for typedefs
+              68, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+                CORBA::tk_string, 
+                0U, // string length
 
+              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
+              CORBA::tk_alias, // typecode kind for typedefs
+              64, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
+                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
+                CORBA::tk_string, 
+                0U, // string length
 
-CORBA::Any * 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_custom_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
-}
+              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+              CORBA::tk_TypeCode,
 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_truncatable_get::TAO_ClientRequestInfo_IR_ValueDef_is_truncatable_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
 
-Dynamic::ParameterList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_truncatable_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
+            0U,
 
-Dynamic::ExceptionList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_truncatable_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
 
 
-CORBA::Any * 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_truncatable_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
-  return safe_result_any._retn ();
-}
+      0U,
 
-void 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_truncatable_get::result (CORBA::Boolean result)
-{
-  // update the result 
-  this->_result = result;
-}
 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_truncatable_set::TAO_ClientRequestInfo_IR_ValueDef_is_truncatable_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const CORBA::Boolean & is_truncatable,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    is_truncatable_ (is_truncatable)
-{}
+  11, ACE_NTOHL (0x61747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65730000),  // name = attributes
+  CORBA::tk_alias, // typecode kind for typedefs
+  1788, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/AttrDescriptionSeq:1.0
+    19, ACE_NTOHL (0x41747472), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65710000),  // name = AttrDescriptionSeq
+    CORBA::tk_sequence, // typecode kind
+    1708, // encapsulation length
+      TAO_ENCAP_BYTE_ORDER, // byte order
+      CORBA::tk_struct, // typecode kind
+      1692, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/AttributeDescription:1.0
+        21, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = AttributeDescription
+        8, // member count
+        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+        CORBA::tk_alias, // typecode kind for typedefs
+        64, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+          CORBA::tk_string, 
+          0U, // string length
 
-Dynamic::ParameterList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_truncatable_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_is_truncatable = parameter_list->length ();
-  parameter_list->length (length_is_truncatable + 1);
-  (*parameter_list)[length_is_truncatable].argument <<= CORBA::Any::from_boolean (this->is_truncatable_);
-  (*parameter_list)[length_is_truncatable].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
+        3, ACE_NTOHL (0x69640000),  // name = id
+        CORBA::tk_alias, // typecode kind for typedefs
+        68, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+          CORBA::tk_string, 
+          0U, // string length
 
-Dynamic::ExceptionList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_truncatable_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
+        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
+        CORBA::tk_alias, // typecode kind for typedefs
+        68, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+          CORBA::tk_string, 
+          0U, // string length
 
+        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
+        CORBA::tk_alias, // typecode kind for typedefs
+        64, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
+          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
+          CORBA::tk_string, 
+          0U, // string length
 
-CORBA::Any * 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_truncatable_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
-}
+        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+        CORBA::tk_TypeCode,
 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_a::TAO_ClientRequestInfo_IR_ValueDef_is_a (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * id,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    id_ (id)
-{}
+        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
+        CORBA::tk_enum, // typecode kind
+        104, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/AttributeMode:1.0
+          14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
+          2, // member count
+          12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
+          14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY
 
-Dynamic::ParameterList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_a::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_id = parameter_list->length ();
-  parameter_list->length (length_id + 1);
-  (*parameter_list)[length_id].argument <<= id_;
-  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
+        15, ACE_NTOHL (0x6765745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = get_exceptions
+        CORBA::tk_alias, // typecode kind for typedefs
+        536, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
+          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
+          CORBA::tk_sequence, // typecode kind
+          456, // encapsulation length
+            TAO_ENCAP_BYTE_ORDER, // byte order
+            CORBA::tk_struct, // typecode kind
+            440, // encapsulation length
+              TAO_ENCAP_BYTE_ORDER, // byte order
+              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
+              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
+              5, // member count
+              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+              CORBA::tk_alias, // typecode kind for typedefs
+              64, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+                CORBA::tk_string, 
+                0U, // string length
 
-Dynamic::ExceptionList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_a::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
+              3, ACE_NTOHL (0x69640000),  // name = id
+              CORBA::tk_alias, // typecode kind for typedefs
+              68, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+                CORBA::tk_string, 
+                0U, // string length
 
+              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
+              CORBA::tk_alias, // typecode kind for typedefs
+              68, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+                CORBA::tk_string, 
+                0U, // string length
 
-CORBA::Any * 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_a::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
-  return safe_result_any._retn ();
-}
+              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
+              CORBA::tk_alias, // typecode kind for typedefs
+              64, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
+                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
+                CORBA::tk_string, 
+                0U, // string length
 
-void 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_a::result (CORBA::Boolean result)
-{
-  // update the result 
-  this->_result = result;
-}
+              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+              CORBA::tk_TypeCode,
 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_value_member::TAO_ClientRequestInfo_IR_ValueDef_create_value_member (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::IDLType_ptr type,
-    const CORBA::Visibility & access,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    id_ (id),
-    name_ (name),
-    version_ (version),
-    type_ (type),
-    access_ (access)
-{}
 
-Dynamic::ParameterList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_value_member::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_id = parameter_list->length ();
-  parameter_list->length (length_id + 1);
-  (*parameter_list)[length_id].argument <<= id_;
-  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_name = parameter_list->length ();
-  parameter_list->length (length_name + 1);
-  (*parameter_list)[length_name].argument <<= name_;
-  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_version = parameter_list->length ();
-  parameter_list->length (length_version + 1);
-  (*parameter_list)[length_version].argument <<= version_;
-  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_type = parameter_list->length ();
-  parameter_list->length (length_type + 1);
-  (*parameter_list)[length_type].argument <<=  this->type_;
-  
-  (*parameter_list)[length_type].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_access = parameter_list->length ();
-  parameter_list->length (length_access + 1);
-  (*parameter_list)[length_access].argument <<= access_;
-  (*parameter_list)[length_access].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
+            0U,
 
-Dynamic::ExceptionList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_value_member::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
 
+        15, ACE_NTOHL (0x7075745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = put_exceptions
+        CORBA::tk_alias, // typecode kind for typedefs
+        536, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
+          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
+          CORBA::tk_sequence, // typecode kind
+          456, // encapsulation length
+            TAO_ENCAP_BYTE_ORDER, // byte order
+            CORBA::tk_struct, // typecode kind
+            440, // encapsulation length
+              TAO_ENCAP_BYTE_ORDER, // byte order
+              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
+              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
+              5, // member count
+              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+              CORBA::tk_alias, // typecode kind for typedefs
+              64, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+                CORBA::tk_string, 
+                0U, // string length
 
-CORBA::Any * 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_value_member::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
+              3, ACE_NTOHL (0x69640000),  // name = id
+              CORBA::tk_alias, // typecode kind for typedefs
+              68, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+                CORBA::tk_string, 
+                0U, // string length
 
-void 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_value_member::result (IR::ValueMemberDef_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
+              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
+              CORBA::tk_alias, // typecode kind for typedefs
+              68, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+                CORBA::tk_string, 
+                0U, // string length
 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_attribute::TAO_ClientRequestInfo_IR_ValueDef_create_attribute (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::IDLType_ptr type,
-    IR::AttributeMode & mode,
-    const IR::ExceptionDefSeq & get_exceptions,
-    const IR::ExceptionDefSeq & put_exceptions,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    id_ (id),
-    name_ (name),
-    version_ (version),
-    type_ (type),
-    mode_ (mode),
-    get_exceptions_ (get_exceptions),
-    put_exceptions_ (put_exceptions)
-{}
+              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
+              CORBA::tk_alias, // typecode kind for typedefs
+              64, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
+                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
+                CORBA::tk_string, 
+                0U, // string length
 
-Dynamic::ParameterList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_attribute::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_id = parameter_list->length ();
-  parameter_list->length (length_id + 1);
-  (*parameter_list)[length_id].argument <<= id_;
-  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_name = parameter_list->length ();
-  parameter_list->length (length_name + 1);
-  (*parameter_list)[length_name].argument <<= name_;
-  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_version = parameter_list->length ();
-  parameter_list->length (length_version + 1);
-  (*parameter_list)[length_version].argument <<= version_;
-  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_type = parameter_list->length ();
-  parameter_list->length (length_type + 1);
-  (*parameter_list)[length_type].argument <<=  this->type_;
-  
-  (*parameter_list)[length_type].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_mode = parameter_list->length ();
-  parameter_list->length (length_mode + 1);
-  (*parameter_list)[length_mode].argument <<=  this->mode_;
-  
-  (*parameter_list)[length_mode].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_get_exceptions = parameter_list->length ();
-  parameter_list->length (length_get_exceptions + 1);
-  (*parameter_list)[length_get_exceptions].argument <<=  this->get_exceptions_;
-  
-  (*parameter_list)[length_get_exceptions].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_put_exceptions = parameter_list->length ();
-  parameter_list->length (length_put_exceptions + 1);
-  (*parameter_list)[length_put_exceptions].argument <<=  this->put_exceptions_;
-  
-  (*parameter_list)[length_put_exceptions].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
+              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+              CORBA::tk_TypeCode,
 
-Dynamic::ExceptionList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_attribute::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
 
+            0U,
 
-CORBA::Any * 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_attribute::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
 
-void 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_attribute::result (IR::AttributeDef_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_operation::TAO_ClientRequestInfo_IR_ValueDef_create_operation (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::IDLType_ptr result,
-    IR::OperationMode & mode,
-    const IR::ParDescriptionSeq & params,
-    const IR::ExceptionDefSeq & exceptions,
-    const IR::ContextIdSeq & contexts,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    id_ (id),
-    name_ (name),
-    version_ (version),
-    result_ (result),
-    mode_ (mode),
-    params_ (params),
-    exceptions_ (exceptions),
-    contexts_ (contexts)
-{}
+      0U,
 
-Dynamic::ParameterList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_operation::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_id = parameter_list->length ();
-  parameter_list->length (length_id + 1);
-  (*parameter_list)[length_id].argument <<= id_;
-  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_name = parameter_list->length ();
-  parameter_list->length (length_name + 1);
-  (*parameter_list)[length_name].argument <<= name_;
-  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_version = parameter_list->length ();
-  parameter_list->length (length_version + 1);
-  (*parameter_list)[length_version].argument <<= version_;
-  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_result = parameter_list->length ();
-  parameter_list->length (length_result + 1);
-  (*parameter_list)[length_result].argument <<=  this->result_;
-  
-  (*parameter_list)[length_result].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_mode = parameter_list->length ();
-  parameter_list->length (length_mode + 1);
-  (*parameter_list)[length_mode].argument <<=  this->mode_;
-  
-  (*parameter_list)[length_mode].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_params = parameter_list->length ();
-  parameter_list->length (length_params + 1);
-  (*parameter_list)[length_params].argument <<=  this->params_;
-  
-  (*parameter_list)[length_params].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_exceptions = parameter_list->length ();
-  parameter_list->length (length_exceptions + 1);
-  (*parameter_list)[length_exceptions].argument <<=  this->exceptions_;
-  
-  (*parameter_list)[length_exceptions].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_contexts = parameter_list->length ();
-  parameter_list->length (length_contexts + 1);
-  (*parameter_list)[length_contexts].argument <<=  this->contexts_;
-  
-  (*parameter_list)[length_contexts].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
 
-Dynamic::ExceptionList *
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_operation::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
+  16, ACE_NTOHL (0x62617365), ACE_NTOHL (0x5f696e74), ACE_NTOHL (0x65726661), ACE_NTOHL (0x63657300),  // name = base_interfaces
+  CORBA::tk_alias, // typecode kind for typedefs
+  156, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79496453), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/RepositoryIdSeq:1.0
+    16, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
+    CORBA::tk_sequence, // typecode kind
+    84, // encapsulation length
+      TAO_ENCAP_BYTE_ORDER, // byte order
+      CORBA::tk_alias, // typecode kind for typedefs
+      68, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+        CORBA::tk_string, 
+        0U, // string length
 
+      0U,
 
-CORBA::Any * 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_operation::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
 
-void 
-IR::ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_operation::result (IR::OperationDef_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
+  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+  CORBA::tk_TypeCode,
+
+  12, ACE_NTOHL (0x69735f61), ACE_NTOHL (0x62737472), ACE_NTOHL (0x61637400),  // name = is_abstract
+  CORBA::tk_boolean,
+
+  9, ACE_NTOHL (0x69735f6c), ACE_NTOHL (0x6f63616c), ACE_NTOHL (0x0),  // name = is_local
+  CORBA::tk_boolean,
 
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_ValueDef[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ValueDef:1.0
-  9, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = ValueDef
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_ValueDef (CORBA::tk_objref, sizeof (_oc_IR_ValueDef), (char *) &_oc_IR_ValueDef, 0, sizeof (IR::ValueDef));
+static CORBA::TypeCode _tc_TAO_tc_IR_InterfaceDescription (CORBA::tk_struct, sizeof (_oc_IR_InterfaceDescription), (char *) &_oc_IR_InterfaceDescription, 0, sizeof (IR_InterfaceDescription));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueDef, &_tc_TAO_tc_IR_ValueDef)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_InterfaceDescription, &_tc_TAO_tc_IR_InterfaceDescription)
 TAO_NAMESPACE_END
-static const CORBA::Long _oc_IR_ValueDescription[] =
+
+void IR_InterfaceDescription::_tao_any_destructor (void *x)
+{
+  IR_InterfaceDescription *tmp = ACE_static_cast (IR_InterfaceDescription*,x);
+  delete tmp;
+}
+
+static const CORBA::Long _oc_IR_ValueMember[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
-  36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ValueDescription:1.0
-  17, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ValueDescription
-  15, // member count
+  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ValueMember:1.0
+  12, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657200),  // name = ValueMember
+  7, // member count
   5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
   CORBA::tk_alias, // typecode kind for typedefs
   64, // encapsulation length
@@ -42371,12 +19767,6 @@
     CORBA::tk_string, 
     0U, // string length
 
-  12, ACE_NTOHL (0x69735f61), ACE_NTOHL (0x62737472), ACE_NTOHL (0x61637400),  // name = is_abstract
-  CORBA::tk_boolean,
-
-  10, ACE_NTOHL (0x69735f63), ACE_NTOHL (0x7573746f), ACE_NTOHL (0x6d000000),  // name = is_custom
-  CORBA::tk_boolean,
-
   11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
   CORBA::tk_alias, // typecode kind for typedefs
   68, // encapsulation length
@@ -42395,612 +19785,1391 @@
     CORBA::tk_string, 
     0U, // string length
 
-  11, ACE_NTOHL (0x6f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e730000),  // name = operations
+  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+  CORBA::tk_TypeCode,
+
+  9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
+  CORBA::tk_objref, // typecode kind
+  48, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
+    8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType
+
+  7, ACE_NTOHL (0x61636365), ACE_NTOHL (0x73730000),  // name = access
   CORBA::tk_alias, // typecode kind for typedefs
-  1972, // encapsulation length
+  64, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
-    36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OpDescriptionSeq:1.0
-    17, ACE_NTOHL (0x4f704465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x0),  // name = OpDescriptionSeq
-    CORBA::tk_sequence, // typecode kind
-    1896, // encapsulation length
-      TAO_ENCAP_BYTE_ORDER, // byte order
-      CORBA::tk_struct, // typecode kind
-      1880, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OperationDescription:1.0
-        21, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = OperationDescription
-        9, // member count
-        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-        CORBA::tk_alias, // typecode kind for typedefs
-        64, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-          CORBA::tk_string, 
-          0U, // string length
+    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5669), ACE_NTOHL (0x73696269), ACE_NTOHL (0x6c697479), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Visibility:1.0
+    11, ACE_NTOHL (0x56697369), ACE_NTOHL (0x62696c69), ACE_NTOHL (0x74790000),  // name = Visibility
+    CORBA::tk_short,
 
-        3, ACE_NTOHL (0x69640000),  // name = id
-        CORBA::tk_alias, // typecode kind for typedefs
-        68, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-          CORBA::tk_string, 
-          0U, // string length
 
-        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
-        CORBA::tk_alias, // typecode kind for typedefs
-        68, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-          CORBA::tk_string, 
-          0U, // string length
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_ValueMember (CORBA::tk_struct, sizeof (_oc_IR_ValueMember), (char *) &_oc_IR_ValueMember, 0, sizeof (IR_ValueMember));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueMember, &_tc_TAO_tc_IR_ValueMember)
+TAO_NAMESPACE_END
 
-        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
-        CORBA::tk_alias, // typecode kind for typedefs
-        64, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
-          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
-          CORBA::tk_string, 
-          0U, // string length
+void IR_ValueMember::_tao_any_destructor (void *x)
+{
+  IR_ValueMember *tmp = ACE_static_cast (IR_ValueMember*,x);
+  delete tmp;
+}
+
+
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
+  
+  void
+  _TAO_Unbounded_Sequence_IR_ValueMemberSeq::_allocate_buffer (CORBA::ULong length)
+  {
+    IR_ValueMember* tmp = 0;
+    tmp = _TAO_Unbounded_Sequence_IR_ValueMemberSeq::allocbuf (length);
+    
+    if (this->buffer_ != 0)
+    {
+      IR_ValueMember *old = ACE_reinterpret_cast (IR_ValueMember *,this->buffer_);
+      
+      for (CORBA::ULong i = 0; i < this->length_; ++i)
+        tmp[i] = old[i];
+      
+      if (this->release_)
+        _TAO_Unbounded_Sequence_IR_ValueMemberSeq::freebuf (old);
+      
+    }
+    this->buffer_ = tmp;
+  }
+  
+  void
+  _TAO_Unbounded_Sequence_IR_ValueMemberSeq::_deallocate_buffer (void)
+  {
+    if (this->buffer_ == 0 || this->release_ == 0)
+      return;
+    
+    IR_ValueMember *tmp = ACE_reinterpret_cast (IR_ValueMember *,this->buffer_);
+    
+    _TAO_Unbounded_Sequence_IR_ValueMemberSeq::freebuf (tmp);
+    this->buffer_ = 0;
+  } 
+  
+  _TAO_Unbounded_Sequence_IR_ValueMemberSeq::~_TAO_Unbounded_Sequence_IR_ValueMemberSeq (void) // Dtor.
+  {
+    this->_deallocate_buffer ();
+  }
+  
+#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
+
+// *************************************************************
+// IR_ValueMemberSeq
+// *************************************************************
+
+IR_ValueMemberSeq::IR_ValueMemberSeq (void)
+{}
+IR_ValueMemberSeq::IR_ValueMemberSeq (CORBA::ULong max) // uses max size
+  : 
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
+  _TAO_Unbounded_Sequence_IR_ValueMemberSeq
+#else /* TAO_USE_SEQUENCE_TEMPLATES */
+  TAO_Unbounded_Sequence<IR_ValueMember>
+#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
+ (max)
+{}
+IR_ValueMemberSeq::IR_ValueMemberSeq (CORBA::ULong max, CORBA::ULong length, IR_ValueMember *buffer, CORBA::Boolean release)
+  : 
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
+  _TAO_Unbounded_Sequence_IR_ValueMemberSeq
+#else /* TAO_USE_SEQUENCE_TEMPLATES */
+  TAO_Unbounded_Sequence<IR_ValueMember>
+#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
+ (max, length, buffer, release)
+{}
+IR_ValueMemberSeq::IR_ValueMemberSeq (const IR_ValueMemberSeq &seq) // copy ctor
+  : 
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
+  _TAO_Unbounded_Sequence_IR_ValueMemberSeq
+#else /* TAO_USE_SEQUENCE_TEMPLATES */
+  TAO_Unbounded_Sequence<IR_ValueMember>
+#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
+ (seq)
+{}
+IR_ValueMemberSeq::~IR_ValueMemberSeq (void) // dtor
+{}
+void IR_ValueMemberSeq::_tao_any_destructor (void *x)
+{
+  IR_ValueMemberSeq *tmp = ACE_static_cast (IR_ValueMemberSeq*,x);
+  delete tmp;
+}
+
+static const CORBA::Long _oc_IR_ValueMemberSeq[] =
+{
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65725365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ValueMemberSeq:1.0
+  15, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657253), ACE_NTOHL (0x65710000),  // name = ValueMemberSeq
+  CORBA::tk_sequence, // typecode kind
+  592, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    CORBA::tk_struct, // typecode kind
+    576, // encapsulation length
+      TAO_ENCAP_BYTE_ORDER, // byte order
+      31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ValueMember:1.0
+      12, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657200),  // name = ValueMember
+      7, // member count
+      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+      CORBA::tk_alias, // typecode kind for typedefs
+      64, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+        CORBA::tk_string, 
+        0U, // string length
+
+      3, ACE_NTOHL (0x69640000),  // name = id
+      CORBA::tk_alias, // typecode kind for typedefs
+      68, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+        CORBA::tk_string, 
+        0U, // string length
 
-        7, ACE_NTOHL (0x72657375), ACE_NTOHL (0x6c740000),  // name = result
-        CORBA::tk_TypeCode,
+      11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
+      CORBA::tk_alias, // typecode kind for typedefs
+      68, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+        CORBA::tk_string, 
+        0U, // string length
 
-        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
-        CORBA::tk_enum, // typecode kind
-        100, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/OperationMode:1.0
-          14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
-          2, // member count
-          10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
-          10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY
+      8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
+      CORBA::tk_alias, // typecode kind for typedefs
+      64, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
+        12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
+        CORBA::tk_string, 
+        0U, // string length
 
-        9, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x65787473), ACE_NTOHL (0x0),  // name = contexts
-        CORBA::tk_alias, // typecode kind for typedefs
-        228, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ContextIdSeq:1.0
-          13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
-          CORBA::tk_sequence, // typecode kind
-          160, // encapsulation length
-            TAO_ENCAP_BYTE_ORDER, // byte order
-            CORBA::tk_alias, // typecode kind for typedefs
-            144, // encapsulation length
-              TAO_ENCAP_BYTE_ORDER, // byte order
-              37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ContextIdentifier:1.0
-              18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
-              CORBA::tk_alias, // typecode kind for typedefs
-              64, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-                CORBA::tk_string, 
-                0U, // string length
+      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+      CORBA::tk_TypeCode,
 
+      9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
+      CORBA::tk_objref, // typecode kind
+      48, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
+        8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType
 
-            0U,
+      7, ACE_NTOHL (0x61636365), ACE_NTOHL (0x73730000),  // name = access
+      CORBA::tk_alias, // typecode kind for typedefs
+      64, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5669), ACE_NTOHL (0x73696269), ACE_NTOHL (0x6c697479), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Visibility:1.0
+        11, ACE_NTOHL (0x56697369), ACE_NTOHL (0x62696c69), ACE_NTOHL (0x74790000),  // name = Visibility
+        CORBA::tk_short,
 
 
-        11, ACE_NTOHL (0x70617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72730000),  // name = parameters
-        CORBA::tk_alias, // typecode kind for typedefs
-        484, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x61724465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParDescriptionSeq:1.0
-          18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
-          CORBA::tk_sequence, // typecode kind
-          404, // encapsulation length
-            TAO_ENCAP_BYTE_ORDER, // byte order
-            CORBA::tk_struct, // typecode kind
-            388, // encapsulation length
-              TAO_ENCAP_BYTE_ORDER, // byte order
-              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ParameterDescription:1.0
-              21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
-              4, // member count
-              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-              CORBA::tk_alias, // typecode kind for typedefs
-              64, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-                CORBA::tk_string, 
-                0U, // string length
 
-              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
-              CORBA::tk_TypeCode,
+    0U,
 
-              9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
-              CORBA::tk_objref, // typecode kind
-              48, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
-                8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_ValueMemberSeq (CORBA::tk_alias, sizeof (_oc_IR_ValueMemberSeq), (char *) &_oc_IR_ValueMemberSeq, 0, sizeof (IR_ValueMemberSeq));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueMemberSeq, &_tc_TAO_tc_IR_ValueMemberSeq)
+TAO_NAMESPACE_END
 
-              5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
-              CORBA::tk_enum, // typecode kind
-              116, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParameterMode:1.0
-                14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
-                3, // member count
-                9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
-                10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
-                12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT
+///////////////////////////////////////////////////////////////////////
+//                Base & Remote Proxy  Implementation. 
+//
 
+_TAO_ValueMemberDef_Proxy_Impl::_TAO_ValueMemberDef_Proxy_Impl (void)
+{}
 
-            0U,
+_TAO_ValueMemberDef_Remote_Proxy_Impl::_TAO_ValueMemberDef_Remote_Proxy_Impl (void)
+{}
 
+// Remote Implementation of the IDL interface methods
 
-        11, ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = exceptions
-        CORBA::tk_alias, // typecode kind for typedefs
-        536, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
-          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
-          CORBA::tk_sequence, // typecode kind
-          456, // encapsulation length
-            TAO_ENCAP_BYTE_ORDER, // byte order
-            CORBA::tk_struct, // typecode kind
-            440, // encapsulation length
-              TAO_ENCAP_BYTE_ORDER, // byte order
-              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
-              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
-              5, // member count
-              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-              CORBA::tk_alias, // typecode kind for typedefs
-              64, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-                CORBA::tk_string, 
-                0U, // string length
+CORBA::TypeCode_ptr _TAO_ValueMemberDef_Remote_Proxy_Impl::type (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
+  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
+  
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-              3, ACE_NTOHL (0x69640000),  // name = id
-              CORBA::tk_alias, // typecode kind for typedefs
-              68, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-                CORBA::tk_string, 
-                0U, // string length
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_type",
+      9,
+      0,
+      istub->orb_core ()
+    );
 
-              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
-              CORBA::tk_alias, // typecode kind for typedefs
-              68, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-                CORBA::tk_string, 
-                0U, // string length
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
+  return _tao_safe_retval._retn ();
+}
 
-              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
-              CORBA::tk_alias, // typecode kind for typedefs
-              64, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
-                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
-                CORBA::tk_string, 
-                0U, // string length
+IR_IDLType_ptr _TAO_ValueMemberDef_Remote_Proxy_Impl::type_def (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  IR_IDLType_ptr _tao_retval = IR_IDLType::_nil ();
+  IR_IDLType_var _tao_safe_retval (_tao_retval);
+  
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
-              CORBA::tk_TypeCode,
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_type_def",
+      13,
+      0,
+      istub->orb_core ()
+    );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
+  return _tao_safe_retval._retn ();
+}
 
-            0U,
+void _TAO_ValueMemberDef_Remote_Proxy_Impl::type_def (
+    CORBA_Object *_collocated_tao_target_,
+    IR_IDLType_ptr type_def,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW (CORBA::INTERNAL ());
 
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_set_type_def",
+      13,
+      1,
+      istub->orb_core ()
+    );
 
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << type_def)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
+        }
+        
+        break;
+      }
+}
 
-      0U,
+CORBA::Visibility _TAO_ValueMemberDef_Remote_Proxy_Impl::access (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  CORBA::Visibility _tao_retval = 0;
+  
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
 
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_access",
+      11,
+      0,
+      istub->orb_core ()
+    );
 
-  11, ACE_NTOHL (0x61747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65730000),  // name = attributes
-  CORBA::tk_alias, // typecode kind for typedefs
-  1788, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/AttrDescriptionSeq:1.0
-    19, ACE_NTOHL (0x41747472), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65710000),  // name = AttrDescriptionSeq
-    CORBA::tk_sequence, // typecode kind
-    1708, // encapsulation length
-      TAO_ENCAP_BYTE_ORDER, // byte order
-      CORBA::tk_struct, // typecode kind
-      1692, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/AttributeDescription:1.0
-        21, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = AttributeDescription
-        8, // member count
-        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-        CORBA::tk_alias, // typecode kind for typedefs
-        64, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-          CORBA::tk_string, 
-          0U, // string length
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN  (_tao_retval);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              _tao_retval
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_retval)
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                _tao_retval
+              );
+          }
+        break;
+      }
 
-        3, ACE_NTOHL (0x69640000),  // name = id
-        CORBA::tk_alias, // typecode kind for typedefs
-        68, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-          CORBA::tk_string, 
-          0U, // string length
+  return _tao_retval;
+}
 
-        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
-        CORBA::tk_alias, // typecode kind for typedefs
-        68, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-          CORBA::tk_string, 
-          0U, // string length
+void _TAO_ValueMemberDef_Remote_Proxy_Impl::access (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::Visibility access,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW (CORBA::INTERNAL ());
 
-        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
-        CORBA::tk_alias, // typecode kind for typedefs
-        64, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
-          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
-          CORBA::tk_string, 
-          0U, // string length
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_set_access",
+      11,
+      1,
+      istub->orb_core ()
+    );
 
-        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
-        CORBA::tk_TypeCode,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << access)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
+        }
+        
+        break;
+      }
+}
 
-        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
-        CORBA::tk_enum, // typecode kind
-        104, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/AttributeMode:1.0
-          14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
-          2, // member count
-          12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
-          14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY
 
-        15, ACE_NTOHL (0x6765745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = get_exceptions
-        CORBA::tk_alias, // typecode kind for typedefs
-        536, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
-          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
-          CORBA::tk_sequence, // typecode kind
-          456, // encapsulation length
-            TAO_ENCAP_BYTE_ORDER, // byte order
-            CORBA::tk_struct, // typecode kind
-            440, // encapsulation length
-              TAO_ENCAP_BYTE_ORDER, // byte order
-              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
-              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
-              5, // member count
-              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-              CORBA::tk_alias, // typecode kind for typedefs
-              64, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-                CORBA::tk_string, 
-                0U, // string length
+//
+//            End  Base & Remote  Proxy Implemeentation. 
+///////////////////////////////////////////////////////////////////////
 
-              3, ACE_NTOHL (0x69640000),  // name = id
-              CORBA::tk_alias, // typecode kind for typedefs
-              68, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-                CORBA::tk_string, 
-                0U, // string length
 
-              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
-              CORBA::tk_alias, // typecode kind for typedefs
-              68, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-                CORBA::tk_string, 
-                0U, // string length
+///////////////////////////////////////////////////////////////////////
+//           Remote & Base  Proxy Broker Implementation
+//
 
-              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
-              CORBA::tk_alias, // typecode kind for typedefs
-              64, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
-                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
-                CORBA::tk_string, 
-                0U, // string length
+_TAO_ValueMemberDef_Proxy_Broker::_TAO_ValueMemberDef_Proxy_Broker (void)
+{
+}
 
-              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
-              CORBA::tk_TypeCode,
+_TAO_ValueMemberDef_Proxy_Broker::~_TAO_ValueMemberDef_Proxy_Broker (void)
+{
+}
 
+// Factory function Implementation.
+_TAO_ValueMemberDef_Remote_Proxy_Broker *the_TAO_ValueMemberDef_Remote_Proxy_Broker (void)
+{
+  static ::_TAO_ValueMemberDef_Remote_Proxy_Broker remote_proxy_broker;
+  return &remote_proxy_broker;
+}
 
-            0U,
+_TAO_ValueMemberDef_Remote_Proxy_Broker::_TAO_ValueMemberDef_Remote_Proxy_Broker (void)
+{
+}
 
+_TAO_ValueMemberDef_Remote_Proxy_Broker::~_TAO_ValueMemberDef_Remote_Proxy_Broker (void)
+{
+}
 
-        15, ACE_NTOHL (0x7075745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = put_exceptions
-        CORBA::tk_alias, // typecode kind for typedefs
-        536, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
-          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
-          CORBA::tk_sequence, // typecode kind
-          456, // encapsulation length
-            TAO_ENCAP_BYTE_ORDER, // byte order
-            CORBA::tk_struct, // typecode kind
-            440, // encapsulation length
-              TAO_ENCAP_BYTE_ORDER, // byte order
-              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
-              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
-              5, // member count
-              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-              CORBA::tk_alias, // typecode kind for typedefs
-              64, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-                CORBA::tk_string, 
-                0U, // string length
+_TAO_ValueMemberDef_Proxy_Impl&
+_TAO_ValueMemberDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_ValueMemberDef *object,
+  CORBA::Environment &ACE_TRY_ENV
+)
+{
+  ACE_UNUSED_ARG (object);
+  ACE_UNUSED_ARG (ACE_TRY_ENV);
+  return remote_proxy_impl_;
+}
 
-              3, ACE_NTOHL (0x69640000),  // name = id
-              CORBA::tk_alias, // typecode kind for typedefs
-              68, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-                CORBA::tk_string, 
-                0U, // string length
 
-              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
-              CORBA::tk_alias, // typecode kind for typedefs
-              68, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-                CORBA::tk_string, 
-                0U, // string length
+//
+//           End Remote & Base Proxy Broker Implementation
+///////////////////////////////////////////////////////////////////////
 
-              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
-              CORBA::tk_alias, // typecode kind for typedefs
-              64, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
-                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
-                CORBA::tk_string, 
-                0U, // string length
 
-              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
-              CORBA::tk_TypeCode,
+// default constructor
+IR_ValueMemberDef::IR_ValueMemberDef (int collocated)
+{
+  this->_tao_setup_collocation (collocated);
+}
 
+// destructor
+IR_ValueMemberDef::~IR_ValueMemberDef (void)
+{}
 
-            0U,
+void
+IR_ValueMemberDef::_tao_setup_collocation (int collocated)
+{
+  if (collocated)
+    this->the_TAO_ValueMemberDef_Proxy_Broker_ =
+      _TAO_ValueMemberDef_Proxy_Broker_Factory_function_pointer (this);
+  else
+    this->the_TAO_ValueMemberDef_Proxy_Broker_ =
+      ::the_TAO_ValueMemberDef_Remote_Proxy_Broker ();
+  
+  IR_Contained::_tao_setup_collocation (collocated);
+  
+}
 
+void IR_ValueMemberDef::_tao_any_destructor (void *x)
+{
+  IR_ValueMemberDef *tmp = ACE_static_cast (IR_ValueMemberDef*,x);
+  CORBA::release (tmp);
+}
 
+IR_ValueMemberDef_ptr IR_ValueMemberDef::_narrow (
+    CORBA::Object_ptr obj,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+{
+  if (CORBA::is_nil (obj))
+    return IR_ValueMemberDef::_nil ();
+  if (! obj->_is_local ())
+    {
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ValueMemberDef:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (IR_ValueMemberDef::_nil ());
+      if (is_a == 0)
+        return IR_ValueMemberDef::_nil ();
+    }
+  return IR_ValueMemberDef::_unchecked_narrow (obj, ACE_TRY_ENV);
+}
 
-      0U,
+IR_ValueMemberDef_ptr IR_ValueMemberDef::_unchecked_narrow (
+    CORBA::Object_ptr obj,
+    CORBA::Environment &
+  )
+{
+  if (CORBA::is_nil (obj))
+    return IR_ValueMemberDef::_nil ();
+  if (! obj->_is_local ())
+    {
+      TAO_Stub* stub = obj->_stubobj ();
+      if (stub)
+        stub->_incr_refcnt ();
+      IR_ValueMemberDef_ptr default_proxy = IR_ValueMemberDef::_nil ();
 
+      if (
+          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
+          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
+          obj->_is_collocated () &&_TAO_ValueMemberDef_Proxy_Broker_Factory_function_pointer != 0
+        )
+      {
+        ACE_NEW_RETURN (
+          default_proxy,
+          ::IR_ValueMemberDef (
+            stub,
+            1,
+            obj->_servant ()),
+            
+          IR_ValueMemberDef::_nil ());
+        }
+      if (CORBA::is_nil (default_proxy))
+        ACE_NEW_RETURN (default_proxy, ::IR_ValueMemberDef (stub, 0, obj->_servant ()), IR_ValueMemberDef::_nil ());
+        return default_proxy;
+      }
+    else 
+      return
+        ACE_reinterpret_cast
+          (
+            IR_ValueMemberDef_ptr,
+              obj->_tao_QueryInterface
+                (
+                  ACE_reinterpret_cast
+                    (
+                      ptr_arith_t,
+                      &IR_ValueMemberDef::_narrow
+                    )
+                )
+          );
+}
 
-  8, ACE_NTOHL (0x6d656d62), ACE_NTOHL (0x65727300),  // name = members
-  CORBA::tk_alias, // typecode kind for typedefs
-  664, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65725365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ValueMemberSeq:1.0
-    15, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657253), ACE_NTOHL (0x65710000),  // name = ValueMemberSeq
-    CORBA::tk_sequence, // typecode kind
-    592, // encapsulation length
-      TAO_ENCAP_BYTE_ORDER, // byte order
-      CORBA::tk_struct, // typecode kind
-      576, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ValueMember:1.0
-        12, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657200),  // name = ValueMember
-        7, // member count
-        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-        CORBA::tk_alias, // typecode kind for typedefs
-        64, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-          CORBA::tk_string, 
-          0U, // string length
+IR_ValueMemberDef_ptr
+IR_ValueMemberDef::_duplicate (IR_ValueMemberDef_ptr obj)
+{
+  if (!CORBA::is_nil (obj))
+    obj->_add_ref ();
+  return obj;
+}
 
-        3, ACE_NTOHL (0x69640000),  // name = id
-        CORBA::tk_alias, // typecode kind for typedefs
-        68, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-          CORBA::tk_string, 
-          0U, // string length
+CORBA::Boolean IR_ValueMemberDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+{
+  if (
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ValueMemberDef:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
+  return 1; // success using local knowledge
+  else
+    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
+}
 
-        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
-        CORBA::tk_alias, // typecode kind for typedefs
-        68, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-          CORBA::tk_string, 
-          0U, // string length
+void *IR_ValueMemberDef::_tao_QueryInterface (ptr_arith_t type)
+{
+  void *retv = 0;
+  if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_ValueMemberDef::_narrow))
+    retv = ACE_reinterpret_cast (void*, this);
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_Contained::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            IR_Contained_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &CORBA_IRObject::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            CORBA_IRObject_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
+    retv = ACE_reinterpret_cast (void *,
+      ACE_static_cast (CORBA::Object_ptr, this));
+    
+  if (retv)
+    this->_add_ref ();
+  return retv;
+}
 
-        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
-        CORBA::tk_alias, // typecode kind for typedefs
-        64, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
-          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
-          CORBA::tk_string, 
-          0U, // string length
+const char* IR_ValueMemberDef::_interface_repository_id (void) const
+{
+  return "IDL:omg.org/IR/ValueMemberDef:1.0";
+}
+
+CORBA::TypeCode_ptr IR_ValueMemberDef::type (
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  return this->the_TAO_ValueMemberDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type (
+      this,
+      ACE_TRY_ENV
+    );
+}
+
+IR_IDLType_ptr IR_ValueMemberDef::type_def (
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  return this->the_TAO_ValueMemberDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type_def (
+      this,
+      ACE_TRY_ENV
+    );
+}
+
+void IR_ValueMemberDef::type_def (
+    IR_IDLType_ptr type_def,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  this->the_TAO_ValueMemberDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type_def (
+      this,
+      type_def,
+      ACE_TRY_ENV
+    );
+}
+
+CORBA::Visibility IR_ValueMemberDef::access (
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  return this->the_TAO_ValueMemberDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).access (
+      this,
+      ACE_TRY_ENV
+    );
+}
+
+void IR_ValueMemberDef::access (
+    CORBA::Visibility access,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  this->the_TAO_ValueMemberDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).access (
+      this,
+      access,
+      ACE_TRY_ENV
+    );
+}
 
-        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
-        CORBA::tk_TypeCode,
+static const CORBA::Long _oc_IR_ValueMemberDef[] =
+{
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65724465), ACE_NTOHL (0x663a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ValueMemberDef:1.0
+  15, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657244), ACE_NTOHL (0x65660000),  // name = IR_ValueMemberDef
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_ValueMemberDef (CORBA::tk_objref, sizeof (_oc_IR_ValueMemberDef), (char *) &_oc_IR_ValueMemberDef, 0, sizeof (IR_ValueMemberDef));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueMemberDef, &_tc_TAO_tc_IR_ValueMemberDef)
+TAO_NAMESPACE_END
 
-        9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
-        CORBA::tk_objref, // typecode kind
-        48, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
-          8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType
+///////////////////////////////////////////////////////////////////////
+//                Base & Remote Proxy  Implementation. 
+//
 
-        7, ACE_NTOHL (0x61636365), ACE_NTOHL (0x73730000),  // name = access
-        CORBA::tk_alias, // typecode kind for typedefs
-        64, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5669), ACE_NTOHL (0x73696269), ACE_NTOHL (0x6c697479), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Visibility:1.0
-          11, ACE_NTOHL (0x56697369), ACE_NTOHL (0x62696c69), ACE_NTOHL (0x74790000),  // name = Visibility
-          CORBA::tk_short,
+_TAO_ValueDef_Proxy_Impl::_TAO_ValueDef_Proxy_Impl (void)
+{}
 
+_TAO_ValueDef_Remote_Proxy_Impl::_TAO_ValueDef_Remote_Proxy_Impl (void)
+{}
 
+// Remote Implementation of the IDL interface methods
 
-      0U,
+IR_InterfaceDefSeq * _TAO_ValueDef_Remote_Proxy_Impl::supported_interfaces (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  IR_InterfaceDefSeq *_tao_retval = 0;
+  
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
+  
+  ACE_NEW_RETURN (_tao_retval, IR_InterfaceDefSeq, _tao_retval);
+  IR_InterfaceDefSeq_var _tao_safe_retval (_tao_retval);
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_supported_interfaces",
+      25,
+      0,
+      istub->orb_core ()
+    );
 
-  13, ACE_NTOHL (0x696e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657273), ACE_NTOHL (0x0),  // name = initializers
-  CORBA::tk_alias, // typecode kind for typedefs
-  576, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x616c697a), ACE_NTOHL (0x65725365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/InitializerSeq:1.0
-    15, ACE_NTOHL (0x496e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657253), ACE_NTOHL (0x65710000),  // name = InitializerSeq
-    CORBA::tk_sequence, // typecode kind
-    504, // encapsulation length
-      TAO_ENCAP_BYTE_ORDER, // byte order
-      CORBA::tk_struct, // typecode kind
-      488, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x616c697a), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/Initializer:1.0
-        12, ACE_NTOHL (0x496e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657200),  // name = Initializer
-        2, // member count
-        8, ACE_NTOHL (0x6d656d62), ACE_NTOHL (0x65727300),  // name = members
-        CORBA::tk_alias, // typecode kind for typedefs
-        324, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x744d656d), ACE_NTOHL (0x62657253), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/StructMemberSeq:1.0
-          16, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x53657100),  // name = StructMemberSeq
-          CORBA::tk_sequence, // typecode kind
-          252, // encapsulation length
-            TAO_ENCAP_BYTE_ORDER, // byte order
-            CORBA::tk_struct, // typecode kind
-            236, // encapsulation length
-              TAO_ENCAP_BYTE_ORDER, // byte order
-              32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x744d656d), ACE_NTOHL (0x6265723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/StructMember:1.0
-              13, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x0),  // name = StructMember
-              3, // member count
-              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-              CORBA::tk_alias, // typecode kind for typedefs
-              64, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-                CORBA::tk_string, 
-                0U, // string length
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
-              CORBA::tk_TypeCode,
+  return _tao_safe_retval._retn ();
+}
 
-              9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
-              CORBA::tk_objref, // typecode kind
-              48, // encapsulation length
-                TAO_ENCAP_BYTE_ORDER, // byte order
-                27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
-                8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType
+void _TAO_ValueDef_Remote_Proxy_Impl::supported_interfaces (
+    CORBA_Object *_collocated_tao_target_,
+    const IR_InterfaceDefSeq & supported_interfaces,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW (CORBA::INTERNAL ());
 
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_set_supported_interfaces",
+      25,
+      1,
+      istub->orb_core ()
+    );
 
-            0U,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << supported_interfaces)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
+        }
+        
+        break;
+      }
+}
 
+IR_InitializerSeq * _TAO_ValueDef_Remote_Proxy_Impl::initializers (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  IR_InitializerSeq *_tao_retval = 0;
+  
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-        CORBA::tk_alias, // typecode kind for typedefs
-        64, // encapsulation length
-          TAO_ENCAP_BYTE_ORDER, // byte order
-          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-          CORBA::tk_string, 
-          0U, // string length
+  
+  ACE_NEW_RETURN (_tao_retval, IR_InitializerSeq, _tao_retval);
+  IR_InitializerSeq_var _tao_safe_retval (_tao_retval);
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_initializers",
+      17,
+      0,
+      istub->orb_core ()
+    );
 
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-      0U,
+  return _tao_safe_retval._retn ();
+}
 
+void _TAO_ValueDef_Remote_Proxy_Impl::initializers (
+    CORBA_Object *_collocated_tao_target_,
+    const IR_InitializerSeq & initializers,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW (CORBA::INTERNAL ());
 
-  21, ACE_NTOHL (0x73757070), ACE_NTOHL (0x6f727465), ACE_NTOHL (0x645f696e), ACE_NTOHL (0x74657266), ACE_NTOHL (0x61636573), ACE_NTOHL (0x0),  // name = supported_interfaces
-  CORBA::tk_alias, // typecode kind for typedefs
-  156, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79496453), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/RepositoryIdSeq:1.0
-    16, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
-    CORBA::tk_sequence, // typecode kind
-    84, // encapsulation length
-      TAO_ENCAP_BYTE_ORDER, // byte order
-      CORBA::tk_alias, // typecode kind for typedefs
-      68, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-        CORBA::tk_string, 
-        0U, // string length
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_set_initializers",
+      17,
+      1,
+      istub->orb_core ()
+    );
 
-      0U,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << initializers)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
+        }
+        
+        break;
+      }
+}
 
+IR_ValueDef_ptr _TAO_ValueDef_Remote_Proxy_Impl::base_value (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  IR_ValueDef_ptr _tao_retval = IR_ValueDef::_nil ();
+  IR_ValueDef_var _tao_safe_retval (_tao_retval);
+  
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-  21, ACE_NTOHL (0x61627374), ACE_NTOHL (0x72616374), ACE_NTOHL (0x5f626173), ACE_NTOHL (0x655f7661), ACE_NTOHL (0x6c756573), ACE_NTOHL (0x0),  // name = abstract_base_values
-  CORBA::tk_alias, // typecode kind for typedefs
-  156, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79496453), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/RepositoryIdSeq:1.0
-    16, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
-    CORBA::tk_sequence, // typecode kind
-    84, // encapsulation length
-      TAO_ENCAP_BYTE_ORDER, // byte order
-      CORBA::tk_alias, // typecode kind for typedefs
-      68, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-        CORBA::tk_string, 
-        0U, // string length
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_base_value",
+      15,
+      0,
+      istub->orb_core ()
+    );
 
-      0U,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
+  return _tao_safe_retval._retn ();
+}
 
-  15, ACE_NTOHL (0x69735f74), ACE_NTOHL (0x72756e63), ACE_NTOHL (0x61746162), ACE_NTOHL (0x6c650000),  // name = is_truncatable
-  CORBA::tk_boolean,
+void _TAO_ValueDef_Remote_Proxy_Impl::base_value (
+    CORBA_Object *_collocated_tao_target_,
+    IR_ValueDef_ptr base_value,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW (CORBA::INTERNAL ());
 
-  11, ACE_NTOHL (0x62617365), ACE_NTOHL (0x5f76616c), ACE_NTOHL (0x75650000),  // name = base_value
-  CORBA::tk_alias, // typecode kind for typedefs
-  68, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-    CORBA::tk_string, 
-    0U, // string length
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_set_base_value",
+      15,
+      1,
+      istub->orb_core ()
+    );
 
-  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
-  CORBA::tk_TypeCode,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << base_value)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
+        }
+        
+        break;
+      }
+}
 
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_ValueDescription (CORBA::tk_struct, sizeof (_oc_IR_ValueDescription), (char *) &_oc_IR_ValueDescription, 0, sizeof (IR::ValueDescription));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueDescription, &_tc_TAO_tc_IR_ValueDescription)
-TAO_NAMESPACE_END
-void IR::ValueDescription::_tao_any_destructor (void *x)
+IR_ValueDefSeq * _TAO_ValueDef_Remote_Proxy_Impl::abstract_base_values (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  ValueDescription *tmp = ACE_static_cast (ValueDescription*,x);
-  delete tmp;
-}
+  
+  IR_ValueDefSeq *_tao_retval = 0;
+  
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
+  
+  ACE_NEW_RETURN (_tao_retval, IR_ValueDefSeq, _tao_retval);
+  IR_ValueDefSeq_var _tao_safe_retval (_tao_retval);
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_abstract_base_values",
+      25,
+      0,
+      istub->orb_core ()
+    );
 
-///////////////////////////////////////////////////////////////////////
-//                Base & Remote Proxy  Implementation. 
-//
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-IR::_TAO_ValueBoxDef_Proxy_Impl::_TAO_ValueBoxDef_Proxy_Impl (void)
-{}
+  return _tao_safe_retval._retn ();
+}
 
-IR::_TAO_ValueBoxDef_Remote_Proxy_Impl::_TAO_ValueBoxDef_Remote_Proxy_Impl (void)
-{}
+void _TAO_ValueDef_Remote_Proxy_Impl::abstract_base_values (
+    CORBA_Object *_collocated_tao_target_,
+    const IR_ValueDefSeq & abstract_base_values,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW (CORBA::INTERNAL ());
 
-// Remote Implementation of the IDL interface methods
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_set_abstract_base_values",
+      25,
+      1,
+      istub->orb_core ()
+    );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << abstract_base_values)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
+        }
+        
+        break;
+      }
+}
 
-IR::IDLType_ptr IR::_TAO_ValueBoxDef_Remote_Proxy_Impl::original_type_def (
+CORBA::Boolean _TAO_ValueDef_Remote_Proxy_Impl::is_abstract (
     CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -43009,160 +21178,131 @@
   ))
 {
   
-  IR::IDLType_ptr _tao_retval = IR::IDLType::_nil ();
-  IR::IDLType_var _tao_safe_retval (_tao_retval);
+  CORBA::Boolean _tao_retval = 0;
   
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
 
   
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_get_original_type_def",
-      22,
+      "_get_is_abstract",
+      16,
       0,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ValueBoxDef::TAO_ClientRequestInfo_IR_ValueBoxDef_original_type_def_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::IDLType_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
+        ACE_CHECK_RETURN  (_tao_retval);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              _tao_retval
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                _tao_retval
+              );
+          }
+        break;
+      }
+
+  return _tao_retval;
+}
+
+void _TAO_ValueDef_Remote_Proxy_Impl::is_abstract (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::Boolean is_abstract,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW (CORBA::INTERNAL ());
+
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_set_is_abstract",
+      16,
+      1,
+      istub->orb_core ()
+    );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << CORBA::Any::from_boolean (is_abstract))
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
+          );
       
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
+        }
+        
+        break;
+      }
 }
 
-void IR::_TAO_ValueBoxDef_Remote_Proxy_Impl::original_type_def (
+CORBA::Boolean _TAO_ValueDef_Remote_Proxy_Impl::is_custom (
     CORBA_Object *_collocated_tao_target_,
-    IR::IDLType_ptr original_type_def,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -43170,385 +21310,131 @@
   ))
 {
   
-
+  CORBA::Boolean _tao_retval = 0;
   
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
   if (istub == 0)
-    ACE_THROW (CORBA::INTERNAL ());
+    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
 
   
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_set_original_type_def",
-      22,
-      1,
+      "_get_is_custom",
+      14,
+      0,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ValueBoxDef::TAO_ClientRequestInfo_IR_ValueBoxDef_original_type_def_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        original_type_def,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << original_type_def)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        ACE_CHECK_RETURN  (_tao_retval);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              _tao_retval
+            );
         }
-      
-      break;
-    }
-  
-}
-
-
-//
-//            End  Base & Remote  Proxy Implemeentation. 
-///////////////////////////////////////////////////////////////////////
-
-
-///////////////////////////////////////////////////////////////////////
-//           Remote & Base  Proxy Broker Implementation
-//
-
-IR::_TAO_ValueBoxDef_Proxy_Broker::_TAO_ValueBoxDef_Proxy_Broker (void)
-{
-}
-
-IR::_TAO_ValueBoxDef_Proxy_Broker::~_TAO_ValueBoxDef_Proxy_Broker (void)
-{
-}
-
-// Factory Member function Implementation.
-IR::_TAO_ValueBoxDef_Remote_Proxy_Broker *IR::_TAO_ValueBoxDef_Remote_Proxy_Broker::the_TAO_ValueBoxDef_Remote_Proxy_Broker (void)
-{
-  static ::IR::_TAO_ValueBoxDef_Remote_Proxy_Broker remote_proxy_broker;
-  return &remote_proxy_broker;
-}
-
-IR::_TAO_ValueBoxDef_Remote_Proxy_Broker::_TAO_ValueBoxDef_Remote_Proxy_Broker (void)
-{
-}
-
-IR::_TAO_ValueBoxDef_Remote_Proxy_Broker::~_TAO_ValueBoxDef_Remote_Proxy_Broker (void)
-{
-}
-
-IR::_TAO_ValueBoxDef_Proxy_Impl&
-IR::_TAO_ValueBoxDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::ValueBoxDef *object,
-  CORBA::Environment &ACE_TRY_ENV
-)
-{
-  ACE_UNUSED_ARG (object);
-  ACE_UNUSED_ARG (ACE_TRY_ENV);
-  return remote_proxy_impl_;
-}
-
-
-//
-//           End Remote & Base Proxy Broker Implementation
-///////////////////////////////////////////////////////////////////////
-
-
-// default constructor
-IR::ValueBoxDef::ValueBoxDef (int collocated)
-{
-  this->_tao_setup_collocation (collocated);
-}
-
-// destructor
-IR::ValueBoxDef::~ValueBoxDef (void)
-{}
-
-void
-IR::ValueBoxDef::_tao_setup_collocation (int collocated)
-{
-  if (collocated)
-    this->the_TAO_ValueBoxDef_Proxy_Broker_ =
-      ::IR__TAO_ValueBoxDef_Proxy_Broker_Factory_function_pointer (this);
-  else
-    this->the_TAO_ValueBoxDef_Proxy_Broker_ =
-      ::IR::_TAO_ValueBoxDef_Remote_Proxy_Broker::the_TAO_ValueBoxDef_Remote_Proxy_Broker ();
-  
-  ACE_NESTED_CLASS (IR, TypedefDef)::_tao_setup_collocation (collocated);
-}
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                _tao_retval
+              );
+          }
+        break;
+      }
 
-void IR::ValueBoxDef::_tao_any_destructor (void *x)
-{
-  ValueBoxDef *tmp = ACE_static_cast (ValueBoxDef*,x);
-  CORBA::release (tmp);
+  return _tao_retval;
 }
 
-IR::ValueBoxDef_ptr IR::ValueBoxDef::_narrow (
-    CORBA::Object_ptr obj,
+void _TAO_ValueDef_Remote_Proxy_Impl::is_custom (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::Boolean is_custom,
     CORBA::Environment &ACE_TRY_ENV
   )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  if (CORBA::is_nil (obj))
-    return ValueBoxDef::_nil ();
-  if (! obj->_is_local ())
-    {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ValueBoxDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (ValueBoxDef::_nil ());
-      if (is_a == 0)
-        return ValueBoxDef::_nil ();
-    }
-  return ValueBoxDef::_unchecked_narrow (obj, ACE_TRY_ENV);
-}
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW (CORBA::INTERNAL ());
 
-IR::ValueBoxDef_ptr IR::ValueBoxDef::_unchecked_narrow (
-    CORBA::Object_ptr obj,
-    CORBA::Environment &
-  )
-{
-  if (CORBA::is_nil (obj))
-    return ValueBoxDef::_nil ();
-  if (! obj->_is_local ())
-    {
-      TAO_Stub* stub = obj->_stubobj ();
-      if (stub)
-        stub->_incr_refcnt ();
-      ValueBoxDef_ptr default_proxy = ValueBoxDef::_nil ();
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_set_is_custom",
+      14,
+      1,
+      istub->orb_core ()
+    );
 
-      if (
-          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
-          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_ValueBoxDef_Proxy_Broker_Factory_function_pointer != 0
-        )
+      for (;;)
       {
-        ACE_NEW_RETURN (
-          default_proxy,
-          ::IR::ValueBoxDef (
-            stub,
-            1,
-            obj->_servant ()),
-            
-          ValueBoxDef::_nil ());
-        }
-      if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::ValueBoxDef (stub, 0, obj->_servant ()), ValueBoxDef::_nil ());
-        return default_proxy;
-      }
-    else 
-      return
-        ACE_reinterpret_cast
-          (
-            ValueBoxDef_ptr,
-              obj->_tao_QueryInterface
-                (
-                  ACE_reinterpret_cast
-                    (
-                      ptr_arith_t,
-                      &ValueBoxDef::_narrow
-                    )
-                )
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
           );
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << CORBA::Any::from_boolean (is_custom))
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
+        }
+        
+        break;
+      }
 }
 
-IR::ValueBoxDef_ptr
-IR::ValueBoxDef::_duplicate (ValueBoxDef_ptr obj)
-{
-  if (!CORBA::is_nil (obj))
-    obj->_add_ref ();
-  return obj;
-}
-
-CORBA::Boolean IR::ValueBoxDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
-{
-  if (
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ValueBoxDef:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
-  return 1; // success using local knowledge
-  else
-    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
-}
-
-void *IR::ValueBoxDef::_tao_QueryInterface (ptr_arith_t type)
-{
-  void *retv = 0;
-  if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, ValueBoxDef)::_narrow))
-    retv = ACE_reinterpret_cast (void*, this);
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, TypedefDef)::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            IR::TypedefDef_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Contained)::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            IR::Contained_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, IDLType)::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            IR::IDLType_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            CORBA::IRObject_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
-    retv = ACE_reinterpret_cast (void *,
-      ACE_static_cast (CORBA::Object_ptr, this));
-    
-  if (retv)
-    this->_add_ref ();
-  return retv;
-}
-
-const char* IR::ValueBoxDef::_interface_repository_id (void) const
-{
-  return "IDL:omg.org/IR/ValueBoxDef:1.0";
-}
-
-IR::IDLType_ptr IR::ValueBoxDef::original_type_def (
+CORBA::Boolean _TAO_ValueDef_Remote_Proxy_Impl::is_truncatable (
+    CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -43556,169 +21442,401 @@
   ))
 {
   
-  return this->the_TAO_ValueBoxDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).original_type_def (
-      this,
-      ACE_TRY_ENV
+  CORBA::Boolean _tao_retval = 0;
+  
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
+
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_is_truncatable",
+      19,
+      0,
+      istub->orb_core ()
     );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN  (_tao_retval);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              _tao_retval
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                _tao_retval
+              );
+          }
+        break;
+      }
+
+  return _tao_retval;
 }
 
-void IR::ValueBoxDef::original_type_def (
-    IR::IDLType_ptr original_type_def,
+void _TAO_ValueDef_Remote_Proxy_Impl::is_truncatable (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::Boolean is_truncatable,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW (CORBA::INTERNAL ());
+
   
-  this->the_TAO_ValueBoxDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).original_type_def (
-      this,
-      original_type_def,
-      ACE_TRY_ENV
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_set_is_truncatable",
+      19,
+      1,
+      istub->orb_core ()
     );
-}
 
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << CORBA::Any::from_boolean (is_truncatable))
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
+        }
+        
+        break;
+      }
+}
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-IR::ValueBoxDef::TAO_ClientRequestInfo_IR_ValueBoxDef_original_type_def_get::TAO_ClientRequestInfo_IR_ValueBoxDef_original_type_def_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
+CORBA::Boolean _TAO_ValueDef_Remote_Proxy_Impl::is_a (
+    CORBA_Object *_collocated_tao_target_,
+    const char * id,
+    CORBA::Environment &ACE_TRY_ENV
   )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::ValueBoxDef::TAO_ClientRequestInfo_IR_ValueBoxDef_original_type_def_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
   
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::ValueBoxDef::TAO_ClientRequestInfo_IR_ValueBoxDef_original_type_def_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
+  CORBA::Boolean _tao_retval = 0;
   
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::ValueBoxDef::TAO_ClientRequestInfo_IR_ValueBoxDef_original_type_def_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
   
-  CORBA::Any_var safe_result_any = result_any;
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
+
   
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "is_a",
+      4,
+      1,
+      istub->orb_core ()
+    );
 
-void 
-IR::ValueBoxDef::TAO_ClientRequestInfo_IR_ValueBoxDef_original_type_def_get::result (IR::IDLType_ptr result)
-{
-  // update the result 
-  this->_result = result;
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << id)
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            _tao_retval
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              _tao_retval
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                _tao_retval
+              );
+          }
+        break;
+      }
+
+  return _tao_retval;
 }
 
-IR::ValueBoxDef::TAO_ClientRequestInfo_IR_ValueBoxDef_original_type_def_set::TAO_ClientRequestInfo_IR_ValueBoxDef_original_type_def_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    IR::IDLType_ptr original_type_def,
-    CORBA::Environment &    
+IR_ValueMemberDef_ptr _TAO_ValueDef_Remote_Proxy_Impl::create_value_member (
+    CORBA_Object *_collocated_tao_target_,
+    const char * id,
+    const char * name,
+    const char * version,
+    IR_IDLType_ptr type,
+    CORBA::Visibility access,
+    CORBA::Environment &ACE_TRY_ENV
   )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    original_type_def_ (original_type_def)
-{}
-
-Dynamic::ParameterList *
-IR::ValueBoxDef::TAO_ClientRequestInfo_IR_ValueBoxDef_original_type_def_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
   
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_original_type_def = parameter_list->length ();
-  parameter_list->length (length_original_type_def + 1);
-  (*parameter_list)[length_original_type_def].argument <<=  this->original_type_def_;
+  IR_ValueMemberDef_ptr _tao_retval = IR_ValueMemberDef::_nil ();
+  IR_ValueMemberDef_var _tao_safe_retval (_tao_retval);
   
-  (*parameter_list)[length_original_type_def].mode = Dynamic::PARAM_IN;
   
-  return safe_parameter_list._retn ();
-}
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-Dynamic::ExceptionList *
-IR::ValueBoxDef::TAO_ClientRequestInfo_IR_ValueBoxDef_original_type_def_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
   
-  return exception_list;
-}
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "create_value_member",
+      19,
+      1,
+      istub->orb_core ()
+    );
 
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << id) &&
+              (_tao_out << name) &&
+              (_tao_out << version) &&
+              (_tao_out << type) &&
+              (_tao_out << access)
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-CORBA::Any * 
-IR::ValueBoxDef::TAO_ClientRequestInfo_IR_ValueBoxDef_original_type_def_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return result_any;
+  return _tao_safe_retval._retn ();
 }
 
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_ValueBoxDef[] =
+IR_AttributeDef_ptr _TAO_ValueDef_Remote_Proxy_Impl::create_attribute (
+    CORBA_Object *_collocated_tao_target_,
+    const char * id,
+    const char * name,
+    const char * version,
+    IR_IDLType_ptr type,
+    IR_AttributeMode mode,
+    const IR_ExceptionDefSeq & get_exceptions,
+    const IR_ExceptionDefSeq & put_exceptions,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x426f7844), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ValueBoxDef:1.0
-  12, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65426f78), ACE_NTOHL (0x44656600),  // name = ValueBoxDef
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_ValueBoxDef (CORBA::tk_objref, sizeof (_oc_IR_ValueBoxDef), (char *) &_oc_IR_ValueBoxDef, 0, sizeof (IR::ValueBoxDef));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueBoxDef, &_tc_TAO_tc_IR_ValueBoxDef)
-TAO_NAMESPACE_END
-
-///////////////////////////////////////////////////////////////////////
-//                Base & Remote Proxy  Implementation. 
-//
+  
+  IR_AttributeDef_ptr _tao_retval = IR_AttributeDef::_nil ();
+  IR_AttributeDef_var _tao_safe_retval (_tao_retval);
+  
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-IR::_TAO_ProvidesDef_Proxy_Impl::_TAO_ProvidesDef_Proxy_Impl (void)
-{}
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "create_attribute",
+      16,
+      1,
+      istub->orb_core ()
+    );
 
-IR::_TAO_ProvidesDef_Remote_Proxy_Impl::_TAO_ProvidesDef_Remote_Proxy_Impl (void)
-{}
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << id) &&
+              (_tao_out << name) &&
+              (_tao_out << version) &&
+              (_tao_out << type) &&
+              (_tao_out << mode) &&
+              (_tao_out << get_exceptions) &&
+              (_tao_out << put_exceptions)
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-// Remote Implementation of the IDL interface methods
+  return _tao_safe_retval._retn ();
+}
 
-IR::InterfaceDef_ptr IR::_TAO_ProvidesDef_Remote_Proxy_Impl::interface_type (
+IR_OperationDef_ptr _TAO_ValueDef_Remote_Proxy_Impl::create_operation (
     CORBA_Object *_collocated_tao_target_,
+    const char * id,
+    const char * name,
+    const char * version,
+    IR_IDLType_ptr result,
+    IR_OperationMode mode,
+    const IR_ParDescriptionSeq & params,
+    const IR_ExceptionDefSeq & exceptions,
+    const IR_ContextIdSeq & contexts,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -43726,8 +21844,8 @@
   ))
 {
   
-  IR::InterfaceDef_ptr _tao_retval = IR::InterfaceDef::_nil ();
-  IR::InterfaceDef_var _tao_safe_retval (_tao_retval);
+  IR_OperationDef_ptr _tao_retval = IR_OperationDef::_nil ();
+  IR_OperationDef_var _tao_safe_retval (_tao_retval);
   
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
@@ -43737,143 +21855,70 @@
   
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_get_interface_type",
-      19,
-      0,
+      "create_operation",
+      16,
+      1,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ProvidesDef::TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::InterfaceDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << id) &&
+              (_tao_out << name) &&
+              (_tao_out << version) &&
+              (_tao_out << result) &&
+              (_tao_out << mode) &&
+              (_tao_out << params) &&
+              (_tao_out << exceptions) &&
+              (_tao_out << contexts)
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
       
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          _tao_call.restart_flag (1);
-          continue;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
         }
-      
-      break;
-    }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
+
   return _tao_safe_retval._retn ();
 }
 
@@ -43887,32 +21932,32 @@
 //           Remote & Base  Proxy Broker Implementation
 //
 
-IR::_TAO_ProvidesDef_Proxy_Broker::_TAO_ProvidesDef_Proxy_Broker (void)
+_TAO_ValueDef_Proxy_Broker::_TAO_ValueDef_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_ProvidesDef_Proxy_Broker::~_TAO_ProvidesDef_Proxy_Broker (void)
+_TAO_ValueDef_Proxy_Broker::~_TAO_ValueDef_Proxy_Broker (void)
 {
 }
 
-// Factory Member function Implementation.
-IR::_TAO_ProvidesDef_Remote_Proxy_Broker *IR::_TAO_ProvidesDef_Remote_Proxy_Broker::the_TAO_ProvidesDef_Remote_Proxy_Broker (void)
+// Factory function Implementation.
+_TAO_ValueDef_Remote_Proxy_Broker *the_TAO_ValueDef_Remote_Proxy_Broker (void)
 {
-  static ::IR::_TAO_ProvidesDef_Remote_Proxy_Broker remote_proxy_broker;
+  static ::_TAO_ValueDef_Remote_Proxy_Broker remote_proxy_broker;
   return &remote_proxy_broker;
 }
 
-IR::_TAO_ProvidesDef_Remote_Proxy_Broker::_TAO_ProvidesDef_Remote_Proxy_Broker (void)
+_TAO_ValueDef_Remote_Proxy_Broker::_TAO_ValueDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_ProvidesDef_Remote_Proxy_Broker::~_TAO_ProvidesDef_Remote_Proxy_Broker (void)
+_TAO_ValueDef_Remote_Proxy_Broker::~_TAO_ValueDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_ProvidesDef_Proxy_Impl&
-IR::_TAO_ProvidesDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::ProvidesDef *object,
+_TAO_ValueDef_Proxy_Impl&
+_TAO_ValueDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_ValueDef *object,
   CORBA::Environment &ACE_TRY_ENV
 )
 {
@@ -43928,166 +21973,426 @@
 
 
 // default constructor
-IR::ProvidesDef::ProvidesDef (int collocated)
+IR_ValueDef::IR_ValueDef (int collocated)
 {
   this->_tao_setup_collocation (collocated);
 }
 
 // destructor
-IR::ProvidesDef::~ProvidesDef (void)
+IR_ValueDef::~IR_ValueDef (void)
 {}
 
 void
-IR::ProvidesDef::_tao_setup_collocation (int collocated)
+IR_ValueDef::_tao_setup_collocation (int collocated)
 {
   if (collocated)
-    this->the_TAO_ProvidesDef_Proxy_Broker_ =
-      ::IR__TAO_ProvidesDef_Proxy_Broker_Factory_function_pointer (this);
+    this->the_TAO_ValueDef_Proxy_Broker_ =
+      _TAO_ValueDef_Proxy_Broker_Factory_function_pointer (this);
   else
-    this->the_TAO_ProvidesDef_Proxy_Broker_ =
-      ::IR::_TAO_ProvidesDef_Remote_Proxy_Broker::the_TAO_ProvidesDef_Remote_Proxy_Broker ();
+    this->the_TAO_ValueDef_Proxy_Broker_ =
+      ::the_TAO_ValueDef_Remote_Proxy_Broker ();
+  
+  IR_Container::_tao_setup_collocation (collocated);
+  IR_Contained::_tao_setup_collocation (collocated);
+  IR_IDLType::_tao_setup_collocation (collocated);
   
-  ACE_NESTED_CLASS (IR, Contained)::_tao_setup_collocation (collocated);
 }
 
-void IR::ProvidesDef::_tao_any_destructor (void *x)
+void IR_ValueDef::_tao_any_destructor (void *x)
 {
-  ProvidesDef *tmp = ACE_static_cast (ProvidesDef*,x);
+  IR_ValueDef *tmp = ACE_static_cast (IR_ValueDef*,x);
   CORBA::release (tmp);
 }
 
-IR::ProvidesDef_ptr IR::ProvidesDef::_narrow (
+IR_ValueDef_ptr IR_ValueDef::_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
 {
   if (CORBA::is_nil (obj))
-    return ProvidesDef::_nil ();
+    return IR_ValueDef::_nil ();
   if (! obj->_is_local ())
     {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ProvidesDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (ProvidesDef::_nil ());
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ValueDef:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (IR_ValueDef::_nil ());
       if (is_a == 0)
-        return ProvidesDef::_nil ();
+        return IR_ValueDef::_nil ();
     }
-  return ProvidesDef::_unchecked_narrow (obj, ACE_TRY_ENV);
+  return IR_ValueDef::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::ProvidesDef_ptr IR::ProvidesDef::_unchecked_narrow (
+IR_ValueDef_ptr IR_ValueDef::_unchecked_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &
   )
 {
   if (CORBA::is_nil (obj))
-    return ProvidesDef::_nil ();
+    return IR_ValueDef::_nil ();
   if (! obj->_is_local ())
     {
       TAO_Stub* stub = obj->_stubobj ();
       if (stub)
         stub->_incr_refcnt ();
-      ProvidesDef_ptr default_proxy = ProvidesDef::_nil ();
+      IR_ValueDef_ptr default_proxy = IR_ValueDef::_nil ();
 
       if (
           !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
           stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_ProvidesDef_Proxy_Broker_Factory_function_pointer != 0
+          obj->_is_collocated () &&_TAO_ValueDef_Proxy_Broker_Factory_function_pointer != 0
         )
       {
         ACE_NEW_RETURN (
           default_proxy,
-          ::IR::ProvidesDef (
+          ::IR_ValueDef (
             stub,
             1,
             obj->_servant ()),
             
-          ProvidesDef::_nil ());
+          IR_ValueDef::_nil ());
         }
       if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::ProvidesDef (stub, 0, obj->_servant ()), ProvidesDef::_nil ());
+        ACE_NEW_RETURN (default_proxy, ::IR_ValueDef (stub, 0, obj->_servant ()), IR_ValueDef::_nil ());
         return default_proxy;
       }
     else 
       return
         ACE_reinterpret_cast
           (
-            ProvidesDef_ptr,
+            IR_ValueDef_ptr,
               obj->_tao_QueryInterface
                 (
                   ACE_reinterpret_cast
                     (
                       ptr_arith_t,
-                      &ProvidesDef::_narrow
+                      &IR_ValueDef::_narrow
                     )
                 )
           );
 }
 
-IR::ProvidesDef_ptr
-IR::ProvidesDef::_duplicate (ProvidesDef_ptr obj)
+IR_ValueDef_ptr
+IR_ValueDef::_duplicate (IR_ValueDef_ptr obj)
+{
+  if (!CORBA::is_nil (obj))
+    obj->_add_ref ();
+  return obj;
+}
+
+CORBA::Boolean IR_ValueDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+{
+  if (
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ValueDef:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
+  return 1; // success using local knowledge
+  else
+    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
+}
+
+void *IR_ValueDef::_tao_QueryInterface (ptr_arith_t type)
+{
+  void *retv = 0;
+  if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_ValueDef::_narrow))
+    retv = ACE_reinterpret_cast (void*, this);
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_Container::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            IR_Container_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_Contained::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            IR_Contained_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_IDLType::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            IR_IDLType_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &CORBA_IRObject::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            CORBA_IRObject_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
+    retv = ACE_reinterpret_cast (void *,
+      ACE_static_cast (CORBA::Object_ptr, this));
+    
+  if (retv)
+    this->_add_ref ();
+  return retv;
+}
+
+const char* IR_ValueDef::_interface_repository_id (void) const
+{
+  return "IDL:omg.org/IR/ValueDef:1.0";
+}
+
+IR_InterfaceDefSeq * IR_ValueDef::supported_interfaces (
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).supported_interfaces (
+      this,
+      ACE_TRY_ENV
+    );
+}
+
+void IR_ValueDef::supported_interfaces (
+    const IR_InterfaceDefSeq & supported_interfaces,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).supported_interfaces (
+      this,
+      supported_interfaces,
+      ACE_TRY_ENV
+    );
+}
+
+IR_InitializerSeq * IR_ValueDef::initializers (
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).initializers (
+      this,
+      ACE_TRY_ENV
+    );
+}
+
+void IR_ValueDef::initializers (
+    const IR_InitializerSeq & initializers,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).initializers (
+      this,
+      initializers,
+      ACE_TRY_ENV
+    );
+}
+
+IR_ValueDef_ptr IR_ValueDef::base_value (
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).base_value (
+      this,
+      ACE_TRY_ENV
+    );
+}
+
+void IR_ValueDef::base_value (
+    IR_ValueDef_ptr base_value,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).base_value (
+      this,
+      base_value,
+      ACE_TRY_ENV
+    );
+}
+
+IR_ValueDefSeq * IR_ValueDef::abstract_base_values (
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).abstract_base_values (
+      this,
+      ACE_TRY_ENV
+    );
+}
+
+void IR_ValueDef::abstract_base_values (
+    const IR_ValueDefSeq & abstract_base_values,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).abstract_base_values (
+      this,
+      abstract_base_values,
+      ACE_TRY_ENV
+    );
+}
+
+CORBA::Boolean IR_ValueDef::is_abstract (
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_abstract (
+      this,
+      ACE_TRY_ENV
+    );
+}
+
+void IR_ValueDef::is_abstract (
+    CORBA::Boolean is_abstract,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_abstract (
+      this,
+      is_abstract,
+      ACE_TRY_ENV
+    );
+}
+
+CORBA::Boolean IR_ValueDef::is_custom (
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_custom (
+      this,
+      ACE_TRY_ENV
+    );
+}
+
+void IR_ValueDef::is_custom (
+    CORBA::Boolean is_custom,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  if (!CORBA::is_nil (obj))
-    obj->_add_ref ();
-  return obj;
+  
+  this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_custom (
+      this,
+      is_custom,
+      ACE_TRY_ENV
+    );
 }
 
-CORBA::Boolean IR::ProvidesDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+CORBA::Boolean IR_ValueDef::is_truncatable (
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  if (
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ProvidesDef:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
-  return 1; // success using local knowledge
-  else
-    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
+  
+  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_truncatable (
+      this,
+      ACE_TRY_ENV
+    );
 }
 
-void *IR::ProvidesDef::_tao_QueryInterface (ptr_arith_t type)
+void IR_ValueDef::is_truncatable (
+    CORBA::Boolean is_truncatable,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  void *retv = 0;
-  if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, ProvidesDef)::_narrow))
-    retv = ACE_reinterpret_cast (void*, this);
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Contained)::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            IR::Contained_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            CORBA::IRObject_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
-    retv = ACE_reinterpret_cast (void *,
-      ACE_static_cast (CORBA::Object_ptr, this));
-    
-  if (retv)
-    this->_add_ref ();
-  return retv;
+  
+  this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_truncatable (
+      this,
+      is_truncatable,
+      ACE_TRY_ENV
+    );
 }
 
-const char* IR::ProvidesDef::_interface_repository_id (void) const
+CORBA::Boolean IR_ValueDef::is_a (
+    const char * id,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  return "IDL:omg.org/IR/ProvidesDef:1.0";
+  
+  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_a (
+      this,
+      id,
+      ACE_TRY_ENV
+    );
 }
 
-IR::InterfaceDef_ptr IR::ProvidesDef::interface_type (
+IR_ValueMemberDef_ptr IR_ValueDef::create_value_member (
+    const char * id,
+    const char * name,
+    const char * version,
+    IR_IDLType_ptr type,
+    CORBA::Visibility access,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -44095,863 +22400,704 @@
   ))
 {
   
-  return this->the_TAO_ProvidesDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).interface_type (
+  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_value_member (
       this,
+      id,
+      name,
+      version,
+      type,
+      access,
       ACE_TRY_ENV
     );
 }
 
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-IR::ProvidesDef::TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get::TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
+IR_AttributeDef_ptr IR_ValueDef::create_attribute (
+    const char * id,
+    const char * name,
+    const char * version,
+    IR_IDLType_ptr type,
+    IR_AttributeMode mode,
+    const IR_ExceptionDefSeq & get_exceptions,
+    const IR_ExceptionDefSeq & put_exceptions,
+    CORBA::Environment &ACE_TRY_ENV
   )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::ProvidesDef::TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
   
-  return parameter_list;
+  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_attribute (
+      this,
+      id,
+      name,
+      version,
+      type,
+      mode,
+      get_exceptions,
+      put_exceptions,
+      ACE_TRY_ENV
+    );
 }
 
-Dynamic::ExceptionList *
-IR::ProvidesDef::TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+IR_OperationDef_ptr IR_ValueDef::create_operation (
+    const char * id,
+    const char * name,
+    const char * version,
+    IR_IDLType_ptr result,
+    IR_OperationMode mode,
+    const IR_ParDescriptionSeq & params,
+    const IR_ExceptionDefSeq & exceptions,
+    const IR_ContextIdSeq & contexts,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
   
-  return exception_list;
+  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_operation (
+      this,
+      id,
+      name,
+      version,
+      result,
+      mode,
+      params,
+      exceptions,
+      contexts,
+      ACE_TRY_ENV
+    );
 }
 
+static const CORBA::Long _oc_IR_ValueDef[] =
+{
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ValueDef:1.0
+  9, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = IR_ValueDef
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_ValueDef (CORBA::tk_objref, sizeof (_oc_IR_ValueDef), (char *) &_oc_IR_ValueDef, 0, sizeof (IR_ValueDef));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueDef, &_tc_TAO_tc_IR_ValueDef)
+TAO_NAMESPACE_END
+
+static const CORBA::Long _oc_IR_ValueDescription[] =
+{
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ValueDescription:1.0
+  17, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ValueDescription
+  15, // member count
+  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+  CORBA::tk_alias, // typecode kind for typedefs
+  64, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+    CORBA::tk_string, 
+    0U, // string length
+
+  3, ACE_NTOHL (0x69640000),  // name = id
+  CORBA::tk_alias, // typecode kind for typedefs
+  68, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+    CORBA::tk_string, 
+    0U, // string length
+
+  12, ACE_NTOHL (0x69735f61), ACE_NTOHL (0x62737472), ACE_NTOHL (0x61637400),  // name = is_abstract
+  CORBA::tk_boolean,
+
+  10, ACE_NTOHL (0x69735f63), ACE_NTOHL (0x7573746f), ACE_NTOHL (0x6d000000),  // name = is_custom
+  CORBA::tk_boolean,
+
+  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
+  CORBA::tk_alias, // typecode kind for typedefs
+  68, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+    CORBA::tk_string, 
+    0U, // string length
+
+  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
+  CORBA::tk_alias, // typecode kind for typedefs
+  64, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
+    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
+    CORBA::tk_string, 
+    0U, // string length
+
+  11, ACE_NTOHL (0x6f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e730000),  // name = operations
+  CORBA::tk_alias, // typecode kind for typedefs
+  1972, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OpDescriptionSeq:1.0
+    17, ACE_NTOHL (0x4f704465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x0),  // name = OpDescriptionSeq
+    CORBA::tk_sequence, // typecode kind
+    1896, // encapsulation length
+      TAO_ENCAP_BYTE_ORDER, // byte order
+      CORBA::tk_struct, // typecode kind
+      1880, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OperationDescription:1.0
+        21, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = OperationDescription
+        9, // member count
+        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+        CORBA::tk_alias, // typecode kind for typedefs
+        64, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+          CORBA::tk_string, 
+          0U, // string length
+
+        3, ACE_NTOHL (0x69640000),  // name = id
+        CORBA::tk_alias, // typecode kind for typedefs
+        68, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+          CORBA::tk_string, 
+          0U, // string length
+
+        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
+        CORBA::tk_alias, // typecode kind for typedefs
+        68, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+          CORBA::tk_string, 
+          0U, // string length
+
+        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
+        CORBA::tk_alias, // typecode kind for typedefs
+        64, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
+          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
+          CORBA::tk_string, 
+          0U, // string length
+
+        7, ACE_NTOHL (0x72657375), ACE_NTOHL (0x6c740000),  // name = result
+        CORBA::tk_TypeCode,
+
+        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
+        CORBA::tk_enum, // typecode kind
+        100, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/OperationMode:1.0
+          14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
+          2, // member count
+          10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
+          10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY
 
-CORBA::Any * 
-IR::ProvidesDef::TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
+        9, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x65787473), ACE_NTOHL (0x0),  // name = contexts
+        CORBA::tk_alias, // typecode kind for typedefs
+        228, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ContextIdSeq:1.0
+          13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
+          CORBA::tk_sequence, // typecode kind
+          160, // encapsulation length
+            TAO_ENCAP_BYTE_ORDER, // byte order
+            CORBA::tk_alias, // typecode kind for typedefs
+            144, // encapsulation length
+              TAO_ENCAP_BYTE_ORDER, // byte order
+              37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ContextIdentifier:1.0
+              18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
+              CORBA::tk_alias, // typecode kind for typedefs
+              64, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+                CORBA::tk_string, 
+                0U, // string length
 
-void 
-IR::ProvidesDef::TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get::result (IR::InterfaceDef_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
 
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_ProvidesDef[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDef:1.0
-  12, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44656600),  // name = ProvidesDef
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_ProvidesDef (CORBA::tk_objref, sizeof (_oc_IR_ProvidesDef), (char *) &_oc_IR_ProvidesDef, 0, sizeof (IR::ProvidesDef));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ProvidesDef, &_tc_TAO_tc_IR_ProvidesDef)
-TAO_NAMESPACE_END
-static const CORBA::Long _oc_IR_ProvidesDescription[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  39, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDescription:1.0
-  20, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = ProvidesDescription
-  5, // member count
-  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-  CORBA::tk_alias, // typecode kind for typedefs
-  64, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-    CORBA::tk_string, 
-    0U, // string length
+            0U,
 
-  3, ACE_NTOHL (0x69640000),  // name = id
-  CORBA::tk_alias, // typecode kind for typedefs
-  68, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-    CORBA::tk_string, 
-    0U, // string length
 
-  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
-  CORBA::tk_alias, // typecode kind for typedefs
-  68, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-    CORBA::tk_string, 
-    0U, // string length
+        11, ACE_NTOHL (0x70617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72730000),  // name = parameters
+        CORBA::tk_alias, // typecode kind for typedefs
+        484, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x61724465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParDescriptionSeq:1.0
+          18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
+          CORBA::tk_sequence, // typecode kind
+          404, // encapsulation length
+            TAO_ENCAP_BYTE_ORDER, // byte order
+            CORBA::tk_struct, // typecode kind
+            388, // encapsulation length
+              TAO_ENCAP_BYTE_ORDER, // byte order
+              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ParameterDescription:1.0
+              21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
+              4, // member count
+              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+              CORBA::tk_alias, // typecode kind for typedefs
+              64, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+                CORBA::tk_string, 
+                0U, // string length
 
-  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
-  CORBA::tk_alias, // typecode kind for typedefs
-  64, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
-    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
-    CORBA::tk_string, 
-    0U, // string length
+              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+              CORBA::tk_TypeCode,
 
-  15, ACE_NTOHL (0x696e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x655f7479), ACE_NTOHL (0x70650000),  // name = interface_type
-  CORBA::tk_objref, // typecode kind
-  60, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/InterfaceDef:1.0
-    13, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = InterfaceDef
+              9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
+              CORBA::tk_objref, // typecode kind
+              48, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
+                8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType
 
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_ProvidesDescription (CORBA::tk_struct, sizeof (_oc_IR_ProvidesDescription), (char *) &_oc_IR_ProvidesDescription, 0, sizeof (IR::ProvidesDescription));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ProvidesDescription, &_tc_TAO_tc_IR_ProvidesDescription)
-TAO_NAMESPACE_END
-void IR::ProvidesDescription::_tao_any_destructor (void *x)
-{
-  ProvidesDescription *tmp = ACE_static_cast (ProvidesDescription*,x);
-  delete tmp;
-}
+              5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
+              CORBA::tk_enum, // typecode kind
+              116, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParameterMode:1.0
+                14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
+                3, // member count
+                9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
+                10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
+                12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT
 
 
-///////////////////////////////////////////////////////////////////////
-//                Base & Remote Proxy  Implementation. 
-//
+            0U,
 
-IR::_TAO_UsesDef_Proxy_Impl::_TAO_UsesDef_Proxy_Impl (void)
-{}
 
-IR::_TAO_UsesDef_Remote_Proxy_Impl::_TAO_UsesDef_Remote_Proxy_Impl (void)
-{}
+        11, ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = exceptions
+        CORBA::tk_alias, // typecode kind for typedefs
+        536, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
+          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
+          CORBA::tk_sequence, // typecode kind
+          456, // encapsulation length
+            TAO_ENCAP_BYTE_ORDER, // byte order
+            CORBA::tk_struct, // typecode kind
+            440, // encapsulation length
+              TAO_ENCAP_BYTE_ORDER, // byte order
+              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
+              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
+              5, // member count
+              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+              CORBA::tk_alias, // typecode kind for typedefs
+              64, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+                CORBA::tk_string, 
+                0U, // string length
 
-// Remote Implementation of the IDL interface methods
+              3, ACE_NTOHL (0x69640000),  // name = id
+              CORBA::tk_alias, // typecode kind for typedefs
+              68, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+                CORBA::tk_string, 
+                0U, // string length
 
-IR::InterfaceDef_ptr IR::_TAO_UsesDef_Remote_Proxy_Impl::interface_type (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  IR::InterfaceDef_ptr _tao_retval = IR::InterfaceDef::_nil ();
-  IR::InterfaceDef_var _tao_safe_retval (_tao_retval);
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
+              CORBA::tk_alias, // typecode kind for typedefs
+              68, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+                CORBA::tk_string, 
+                0U, // string length
 
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_interface_type",
-      19,
-      0,
-      istub->orb_core ()
-    );
+              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
+              CORBA::tk_alias, // typecode kind for typedefs
+              64, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
+                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
+                CORBA::tk_string, 
+                0U, // string length
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::UsesDef::TAO_ClientRequestInfo_IR_UsesDef_interface_type_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::InterfaceDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+              CORBA::tk_TypeCode,
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
-}
 
-CORBA::Boolean IR::_TAO_UsesDef_Remote_Proxy_Impl::is_multiple (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  CORBA::Boolean _tao_retval = 0;
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
+            0U,
+
 
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_is_multiple",
-      16,
-      0,
-      istub->orb_core ()
-    );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::UsesDef::TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              CORBA::Boolean  _tao_retval_info = _tao_retval;
-               ri.result (_tao_retval_info);
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+      0U,
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_retval;
-}
 
+  11, ACE_NTOHL (0x61747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65730000),  // name = attributes
+  CORBA::tk_alias, // typecode kind for typedefs
+  1788, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/AttrDescriptionSeq:1.0
+    19, ACE_NTOHL (0x41747472), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65710000),  // name = AttrDescriptionSeq
+    CORBA::tk_sequence, // typecode kind
+    1708, // encapsulation length
+      TAO_ENCAP_BYTE_ORDER, // byte order
+      CORBA::tk_struct, // typecode kind
+      1692, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/AttributeDescription:1.0
+        21, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = AttributeDescription
+        8, // member count
+        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+        CORBA::tk_alias, // typecode kind for typedefs
+        64, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+          CORBA::tk_string, 
+          0U, // string length
 
-//
-//            End  Base & Remote  Proxy Implemeentation. 
-///////////////////////////////////////////////////////////////////////
+        3, ACE_NTOHL (0x69640000),  // name = id
+        CORBA::tk_alias, // typecode kind for typedefs
+        68, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+          CORBA::tk_string, 
+          0U, // string length
 
+        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
+        CORBA::tk_alias, // typecode kind for typedefs
+        68, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+          CORBA::tk_string, 
+          0U, // string length
 
-///////////////////////////////////////////////////////////////////////
-//           Remote & Base  Proxy Broker Implementation
-//
+        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
+        CORBA::tk_alias, // typecode kind for typedefs
+        64, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
+          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
+          CORBA::tk_string, 
+          0U, // string length
 
-IR::_TAO_UsesDef_Proxy_Broker::_TAO_UsesDef_Proxy_Broker (void)
-{
-}
+        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+        CORBA::tk_TypeCode,
 
-IR::_TAO_UsesDef_Proxy_Broker::~_TAO_UsesDef_Proxy_Broker (void)
-{
-}
+        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
+        CORBA::tk_enum, // typecode kind
+        104, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/AttributeMode:1.0
+          14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
+          2, // member count
+          12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
+          14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY
 
-// Factory Member function Implementation.
-IR::_TAO_UsesDef_Remote_Proxy_Broker *IR::_TAO_UsesDef_Remote_Proxy_Broker::the_TAO_UsesDef_Remote_Proxy_Broker (void)
-{
-  static ::IR::_TAO_UsesDef_Remote_Proxy_Broker remote_proxy_broker;
-  return &remote_proxy_broker;
-}
+        15, ACE_NTOHL (0x6765745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = get_exceptions
+        CORBA::tk_alias, // typecode kind for typedefs
+        536, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
+          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
+          CORBA::tk_sequence, // typecode kind
+          456, // encapsulation length
+            TAO_ENCAP_BYTE_ORDER, // byte order
+            CORBA::tk_struct, // typecode kind
+            440, // encapsulation length
+              TAO_ENCAP_BYTE_ORDER, // byte order
+              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
+              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
+              5, // member count
+              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+              CORBA::tk_alias, // typecode kind for typedefs
+              64, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+                CORBA::tk_string, 
+                0U, // string length
 
-IR::_TAO_UsesDef_Remote_Proxy_Broker::_TAO_UsesDef_Remote_Proxy_Broker (void)
-{
-}
+              3, ACE_NTOHL (0x69640000),  // name = id
+              CORBA::tk_alias, // typecode kind for typedefs
+              68, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+                CORBA::tk_string, 
+                0U, // string length
 
-IR::_TAO_UsesDef_Remote_Proxy_Broker::~_TAO_UsesDef_Remote_Proxy_Broker (void)
-{
-}
+              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
+              CORBA::tk_alias, // typecode kind for typedefs
+              68, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+                CORBA::tk_string, 
+                0U, // string length
 
-IR::_TAO_UsesDef_Proxy_Impl&
-IR::_TAO_UsesDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::UsesDef *object,
-  CORBA::Environment &ACE_TRY_ENV
-)
-{
-  ACE_UNUSED_ARG (object);
-  ACE_UNUSED_ARG (ACE_TRY_ENV);
-  return remote_proxy_impl_;
-}
+              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
+              CORBA::tk_alias, // typecode kind for typedefs
+              64, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
+                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
+                CORBA::tk_string, 
+                0U, // string length
 
+              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+              CORBA::tk_TypeCode,
 
-//
-//           End Remote & Base Proxy Broker Implementation
-///////////////////////////////////////////////////////////////////////
 
+            0U,
 
-// default constructor
-IR::UsesDef::UsesDef (int collocated)
-{
-  this->_tao_setup_collocation (collocated);
-}
 
-// destructor
-IR::UsesDef::~UsesDef (void)
-{}
+        15, ACE_NTOHL (0x7075745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = put_exceptions
+        CORBA::tk_alias, // typecode kind for typedefs
+        536, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
+          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
+          CORBA::tk_sequence, // typecode kind
+          456, // encapsulation length
+            TAO_ENCAP_BYTE_ORDER, // byte order
+            CORBA::tk_struct, // typecode kind
+            440, // encapsulation length
+              TAO_ENCAP_BYTE_ORDER, // byte order
+              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
+              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
+              5, // member count
+              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+              CORBA::tk_alias, // typecode kind for typedefs
+              64, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+                CORBA::tk_string, 
+                0U, // string length
 
-void
-IR::UsesDef::_tao_setup_collocation (int collocated)
-{
-  if (collocated)
-    this->the_TAO_UsesDef_Proxy_Broker_ =
-      ::IR__TAO_UsesDef_Proxy_Broker_Factory_function_pointer (this);
-  else
-    this->the_TAO_UsesDef_Proxy_Broker_ =
-      ::IR::_TAO_UsesDef_Remote_Proxy_Broker::the_TAO_UsesDef_Remote_Proxy_Broker ();
-  
-  ACE_NESTED_CLASS (IR, Contained)::_tao_setup_collocation (collocated);
-}
+              3, ACE_NTOHL (0x69640000),  // name = id
+              CORBA::tk_alias, // typecode kind for typedefs
+              68, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+                CORBA::tk_string, 
+                0U, // string length
 
-void IR::UsesDef::_tao_any_destructor (void *x)
-{
-  UsesDef *tmp = ACE_static_cast (UsesDef*,x);
-  CORBA::release (tmp);
-}
+              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
+              CORBA::tk_alias, // typecode kind for typedefs
+              68, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+                CORBA::tk_string, 
+                0U, // string length
+
+              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
+              CORBA::tk_alias, // typecode kind for typedefs
+              64, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
+                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
+                CORBA::tk_string, 
+                0U, // string length
+
+              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+              CORBA::tk_TypeCode,
+
+
+            0U,
 
-IR::UsesDef_ptr IR::UsesDef::_narrow (
-    CORBA::Object_ptr obj,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-{
-  if (CORBA::is_nil (obj))
-    return UsesDef::_nil ();
-  if (! obj->_is_local ())
-    {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/UsesDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (UsesDef::_nil ());
-      if (is_a == 0)
-        return UsesDef::_nil ();
-    }
-  return UsesDef::_unchecked_narrow (obj, ACE_TRY_ENV);
-}
 
-IR::UsesDef_ptr IR::UsesDef::_unchecked_narrow (
-    CORBA::Object_ptr obj,
-    CORBA::Environment &
-  )
-{
-  if (CORBA::is_nil (obj))
-    return UsesDef::_nil ();
-  if (! obj->_is_local ())
-    {
-      TAO_Stub* stub = obj->_stubobj ();
-      if (stub)
-        stub->_incr_refcnt ();
-      UsesDef_ptr default_proxy = UsesDef::_nil ();
 
-      if (
-          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
-          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_UsesDef_Proxy_Broker_Factory_function_pointer != 0
-        )
-      {
-        ACE_NEW_RETURN (
-          default_proxy,
-          ::IR::UsesDef (
-            stub,
-            1,
-            obj->_servant ()),
-            
-          UsesDef::_nil ());
-        }
-      if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::UsesDef (stub, 0, obj->_servant ()), UsesDef::_nil ());
-        return default_proxy;
-      }
-    else 
-      return
-        ACE_reinterpret_cast
-          (
-            UsesDef_ptr,
-              obj->_tao_QueryInterface
-                (
-                  ACE_reinterpret_cast
-                    (
-                      ptr_arith_t,
-                      &UsesDef::_narrow
-                    )
-                )
-          );
-}
+      0U,
 
-IR::UsesDef_ptr
-IR::UsesDef::_duplicate (UsesDef_ptr obj)
-{
-  if (!CORBA::is_nil (obj))
-    obj->_add_ref ();
-  return obj;
-}
 
-CORBA::Boolean IR::UsesDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
-{
-  if (
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/UsesDef:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
-  return 1; // success using local knowledge
-  else
-    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
-}
+  8, ACE_NTOHL (0x6d656d62), ACE_NTOHL (0x65727300),  // name = members
+  CORBA::tk_alias, // typecode kind for typedefs
+  664, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65725365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ValueMemberSeq:1.0
+    15, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657253), ACE_NTOHL (0x65710000),  // name = ValueMemberSeq
+    CORBA::tk_sequence, // typecode kind
+    592, // encapsulation length
+      TAO_ENCAP_BYTE_ORDER, // byte order
+      CORBA::tk_struct, // typecode kind
+      576, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ValueMember:1.0
+        12, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657200),  // name = ValueMember
+        7, // member count
+        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+        CORBA::tk_alias, // typecode kind for typedefs
+        64, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+          CORBA::tk_string, 
+          0U, // string length
 
-void *IR::UsesDef::_tao_QueryInterface (ptr_arith_t type)
-{
-  void *retv = 0;
-  if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, UsesDef)::_narrow))
-    retv = ACE_reinterpret_cast (void*, this);
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Contained)::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            IR::Contained_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            CORBA::IRObject_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
-    retv = ACE_reinterpret_cast (void *,
-      ACE_static_cast (CORBA::Object_ptr, this));
-    
-  if (retv)
-    this->_add_ref ();
-  return retv;
-}
+        3, ACE_NTOHL (0x69640000),  // name = id
+        CORBA::tk_alias, // typecode kind for typedefs
+        68, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+          CORBA::tk_string, 
+          0U, // string length
 
-const char* IR::UsesDef::_interface_repository_id (void) const
-{
-  return "IDL:omg.org/IR/UsesDef:1.0";
-}
+        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
+        CORBA::tk_alias, // typecode kind for typedefs
+        68, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+          CORBA::tk_string, 
+          0U, // string length
 
-IR::InterfaceDef_ptr IR::UsesDef::interface_type (
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_UsesDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).interface_type (
-      this,
-      ACE_TRY_ENV
-    );
-}
+        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
+        CORBA::tk_alias, // typecode kind for typedefs
+        64, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
+          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
+          CORBA::tk_string, 
+          0U, // string length
 
-CORBA::Boolean IR::UsesDef::is_multiple (
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_UsesDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_multiple (
-      this,
-      ACE_TRY_ENV
-    );
-}
+        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+        CORBA::tk_TypeCode,
 
+        9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
+        CORBA::tk_objref, // typecode kind
+        48, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
+          8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-IR::UsesDef::TAO_ClientRequestInfo_IR_UsesDef_interface_type_get::TAO_ClientRequestInfo_IR_UsesDef_interface_type_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
+        7, ACE_NTOHL (0x61636365), ACE_NTOHL (0x73730000),  // name = access
+        CORBA::tk_alias, // typecode kind for typedefs
+        64, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5669), ACE_NTOHL (0x73696269), ACE_NTOHL (0x6c697479), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Visibility:1.0
+          11, ACE_NTOHL (0x56697369), ACE_NTOHL (0x62696c69), ACE_NTOHL (0x74790000),  // name = Visibility
+          CORBA::tk_short,
 
-Dynamic::ParameterList *
-IR::UsesDef::TAO_ClientRequestInfo_IR_UsesDef_interface_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
 
-Dynamic::ExceptionList *
-IR::UsesDef::TAO_ClientRequestInfo_IR_UsesDef_interface_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
 
+      0U,
 
-CORBA::Any * 
-IR::UsesDef::TAO_ClientRequestInfo_IR_UsesDef_interface_type_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
 
-void 
-IR::UsesDef::TAO_ClientRequestInfo_IR_UsesDef_interface_type_get::result (IR::InterfaceDef_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
+  13, ACE_NTOHL (0x696e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657273), ACE_NTOHL (0x0),  // name = initializers
+  CORBA::tk_alias, // typecode kind for typedefs
+  576, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x616c697a), ACE_NTOHL (0x65725365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/InitializerSeq:1.0
+    15, ACE_NTOHL (0x496e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657253), ACE_NTOHL (0x65710000),  // name = IR_InitializerSeq
+    CORBA::tk_sequence, // typecode kind
+    504, // encapsulation length
+      TAO_ENCAP_BYTE_ORDER, // byte order
+      CORBA::tk_struct, // typecode kind
+      488, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x616c697a), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/Initializer:1.0
+        12, ACE_NTOHL (0x496e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657200),  // name = IR_Initializer
+        2, // member count
+        8, ACE_NTOHL (0x6d656d62), ACE_NTOHL (0x65727300),  // name = members
+        CORBA::tk_alias, // typecode kind for typedefs
+        324, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x744d656d), ACE_NTOHL (0x62657253), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/StructMemberSeq:1.0
+          16, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x53657100),  // name = IR_StructMemberSeq
+          CORBA::tk_sequence, // typecode kind
+          252, // encapsulation length
+            TAO_ENCAP_BYTE_ORDER, // byte order
+            CORBA::tk_struct, // typecode kind
+            236, // encapsulation length
+              TAO_ENCAP_BYTE_ORDER, // byte order
+              32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x744d656d), ACE_NTOHL (0x6265723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/StructMember:1.0
+              13, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x0),  // name = IR_StructMember
+              3, // member count
+              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+              CORBA::tk_alias, // typecode kind for typedefs
+              64, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+                CORBA::tk_string, 
+                0U, // string length
 
-IR::UsesDef::TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get::TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
+              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+              CORBA::tk_TypeCode,
 
-Dynamic::ParameterList *
-IR::UsesDef::TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
+              9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
+              CORBA::tk_objref, // typecode kind
+              48, // encapsulation length
+                TAO_ENCAP_BYTE_ORDER, // byte order
+                27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
+                8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType
 
-Dynamic::ExceptionList *
-IR::UsesDef::TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
+
+            0U,
 
 
-CORBA::Any * 
-IR::UsesDef::TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
-  return safe_result_any._retn ();
-}
+        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+        CORBA::tk_alias, // typecode kind for typedefs
+        64, // encapsulation length
+          TAO_ENCAP_BYTE_ORDER, // byte order
+          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+          CORBA::tk_string, 
+          0U, // string length
+
+
+      0U,
 
-void 
-IR::UsesDef::TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get::result (CORBA::Boolean result)
-{
-  // update the result 
-  this->_result = result;
-}
 
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_UsesDef[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x73657344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDef:1.0
-  8, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44656600),  // name = UsesDef
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_UsesDef (CORBA::tk_objref, sizeof (_oc_IR_UsesDef), (char *) &_oc_IR_UsesDef, 0, sizeof (IR::UsesDef));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UsesDef, &_tc_TAO_tc_IR_UsesDef)
-TAO_NAMESPACE_END
-static const CORBA::Long _oc_IR_UsesDescription[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x73657344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDescription:1.0
-  16, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = UsesDescription
-  6, // member count
-  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+  21, ACE_NTOHL (0x73757070), ACE_NTOHL (0x6f727465), ACE_NTOHL (0x645f696e), ACE_NTOHL (0x74657266), ACE_NTOHL (0x61636573), ACE_NTOHL (0x0),  // name = supported_interfaces
   CORBA::tk_alias, // typecode kind for typedefs
-  64, // encapsulation length
+  156, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
-    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-    CORBA::tk_string, 
-    0U, // string length
+    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79496453), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/RepositoryIdSeq:1.0
+    16, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
+    CORBA::tk_sequence, // typecode kind
+    84, // encapsulation length
+      TAO_ENCAP_BYTE_ORDER, // byte order
+      CORBA::tk_alias, // typecode kind for typedefs
+      68, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+        CORBA::tk_string, 
+        0U, // string length
 
-  3, ACE_NTOHL (0x69640000),  // name = id
+      0U,
+
+
+  21, ACE_NTOHL (0x61627374), ACE_NTOHL (0x72616374), ACE_NTOHL (0x5f626173), ACE_NTOHL (0x655f7661), ACE_NTOHL (0x6c756573), ACE_NTOHL (0x0),  // name = abstract_base_values
   CORBA::tk_alias, // typecode kind for typedefs
-  68, // encapsulation length
+  156, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
-    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-    CORBA::tk_string, 
-    0U, // string length
+    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79496453), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/RepositoryIdSeq:1.0
+    16, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
+    CORBA::tk_sequence, // typecode kind
+    84, // encapsulation length
+      TAO_ENCAP_BYTE_ORDER, // byte order
+      CORBA::tk_alias, // typecode kind for typedefs
+      68, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+        CORBA::tk_string, 
+        0U, // string length
 
-  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
+      0U,
+
+
+  15, ACE_NTOHL (0x69735f74), ACE_NTOHL (0x72756e63), ACE_NTOHL (0x61746162), ACE_NTOHL (0x6c650000),  // name = is_truncatable
+  CORBA::tk_boolean,
+
+  11, ACE_NTOHL (0x62617365), ACE_NTOHL (0x5f76616c), ACE_NTOHL (0x75650000),  // name = base_value
   CORBA::tk_alias, // typecode kind for typedefs
   68, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
@@ -44960,558 +23106,470 @@
     CORBA::tk_string, 
     0U, // string length
 
-  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
-  CORBA::tk_alias, // typecode kind for typedefs
-  64, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
-    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
-    CORBA::tk_string, 
-    0U, // string length
-
-  15, ACE_NTOHL (0x696e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x655f7479), ACE_NTOHL (0x70650000),  // name = interface_type
-  CORBA::tk_objref, // typecode kind
-  60, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/InterfaceDef:1.0
-    13, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = InterfaceDef
-
-  12, ACE_NTOHL (0x69735f6d), ACE_NTOHL (0x756c7469), ACE_NTOHL (0x706c6500),  // name = is_multiple
-  CORBA::tk_boolean,
+  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
+  CORBA::tk_TypeCode,
 
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_UsesDescription (CORBA::tk_struct, sizeof (_oc_IR_UsesDescription), (char *) &_oc_IR_UsesDescription, 0, sizeof (IR::UsesDescription));
+static CORBA::TypeCode _tc_TAO_tc_IR_ValueDescription (CORBA::tk_struct, sizeof (_oc_IR_ValueDescription), (char *) &_oc_IR_ValueDescription, 0, sizeof (IR_ValueDescription));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UsesDescription, &_tc_TAO_tc_IR_UsesDescription)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueDescription, &_tc_TAO_tc_IR_ValueDescription)
 TAO_NAMESPACE_END
-void IR::UsesDescription::_tao_any_destructor (void *x)
+
+void IR_ValueDescription::_tao_any_destructor (void *x)
 {
-  UsesDescription *tmp = ACE_static_cast (UsesDescription*,x);
+  IR_ValueDescription *tmp = ACE_static_cast (IR_ValueDescription*,x);
   delete tmp;
 }
 
 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  
-#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_PROVIDESDESCSEQ_CS_)
-#define __TAO_UNBOUNDED_SEQUENCE_IR_PROVIDESDESCSEQ_CS_
+///////////////////////////////////////////////////////////////////////
+//                Base & Remote Proxy  Implementation. 
+//
 
-  void
-  IR::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq::_allocate_buffer (CORBA::ULong length)
-  {
-    IR::ProvidesDescription* tmp = 0;
-    tmp = _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::allocbuf (length);
-    
-    if (this->buffer_ != 0)
-    {
-      IR::ProvidesDescription *old = ACE_reinterpret_cast (IR::ProvidesDescription *,this->buffer_);
-      
-      for (CORBA::ULong i = 0; i < this->length_; ++i)
-        tmp[i] = old[i];
-      
-      if (this->release_)
-        _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::freebuf (old);
-      
-    }
-    this->buffer_ = tmp;
-  }
+_TAO_ValueBoxDef_Proxy_Impl::_TAO_ValueBoxDef_Proxy_Impl (void)
+{}
+
+_TAO_ValueBoxDef_Remote_Proxy_Impl::_TAO_ValueBoxDef_Remote_Proxy_Impl (void)
+{}
+
+// Remote Implementation of the IDL interface methods
+
+IR_IDLType_ptr _TAO_ValueBoxDef_Remote_Proxy_Impl::original_type_def (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
   
-  void
-  IR::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq::_deallocate_buffer (void)
-  {
-    if (this->buffer_ == 0 || this->release_ == 0)
-      return;
-    
-    IR::ProvidesDescription *tmp = ACE_reinterpret_cast (IR::ProvidesDescription *,this->buffer_);
-    
-    _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::freebuf (tmp);
-    this->buffer_ = 0;
-  } 
+  IR_IDLType_ptr _tao_retval = IR_IDLType::_nil ();
+  IR_IDLType_var _tao_safe_retval (_tao_retval);
   
-  IR::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq::~_TAO_Unbounded_Sequence_IR_ProvidesDescSeq (void) // Dtor.
-  {
-    this->_deallocate_buffer ();
-  }
   
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+
   
-#endif /* end #if !defined */
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_original_type_def",
+      22,
+      0,
+      istub->orb_core ()
+    );
 
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
+  return _tao_safe_retval._retn ();
+}
 
-#if !defined (_IR_PROVIDESDESCSEQ_CS_)
-#define _IR_PROVIDESDESCSEQ_CS_
+void _TAO_ValueBoxDef_Remote_Proxy_Impl::original_type_def (
+    CORBA_Object *_collocated_tao_target_,
+    IR_IDLType_ptr original_type_def,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW (CORBA::INTERNAL ());
 
-// *************************************************************
-// IR::ProvidesDescSeq
-// *************************************************************
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_set_original_type_def",
+      22,
+      1,
+      istub->orb_core ()
+    );
 
-IR::ProvidesDescSeq::ProvidesDescSeq (void)
-{}
-IR::ProvidesDescSeq::ProvidesDescSeq (CORBA::ULong max) // uses max size
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Sequence_IR_ProvidesDescSeq
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::ProvidesDescription>
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (max)
-{}
-IR::ProvidesDescSeq::ProvidesDescSeq (CORBA::ULong max, CORBA::ULong length, IR::ProvidesDescription *buffer, CORBA::Boolean release)
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Sequence_IR_ProvidesDescSeq
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::ProvidesDescription>
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (max, length, buffer, release)
-{}
-IR::ProvidesDescSeq::ProvidesDescSeq (const ProvidesDescSeq &seq) // copy ctor
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Sequence_IR_ProvidesDescSeq
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::ProvidesDescription>
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (seq)
-{}
-IR::ProvidesDescSeq::~ProvidesDescSeq (void) // dtor
-{}
-void IR::ProvidesDescSeq::_tao_any_destructor (void *x)
-{
-  ProvidesDescSeq *tmp = ACE_static_cast (ProvidesDescSeq*,x);
-  delete tmp;
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << original_type_def)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
+        }
+        
+        break;
+      }
 }
 
 
-#endif /* end #if !defined */
+//
+//            End  Base & Remote  Proxy Implemeentation. 
+///////////////////////////////////////////////////////////////////////
+
 
-static const CORBA::Long _oc_IR_ProvidesDescSeq[] =
+///////////////////////////////////////////////////////////////////////
+//           Remote & Base  Proxy Broker Implementation
+//
+
+_TAO_ValueBoxDef_Proxy_Broker::_TAO_ValueBoxDef_Proxy_Broker (void)
 {
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657344), ACE_NTOHL (0x65736353), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDescSeq:1.0
-  16, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44657363), ACE_NTOHL (0x53657100),  // name = ProvidesDescSeq
-  CORBA::tk_sequence, // typecode kind
-  524, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    CORBA::tk_struct, // typecode kind
-    508, // encapsulation length
-      TAO_ENCAP_BYTE_ORDER, // byte order
-      39, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDescription:1.0
-      20, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = ProvidesDescription
-      5, // member count
-      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-      CORBA::tk_alias, // typecode kind for typedefs
-      64, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-        CORBA::tk_string, 
-        0U, // string length
+}
 
-      3, ACE_NTOHL (0x69640000),  // name = id
-      CORBA::tk_alias, // typecode kind for typedefs
-      68, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-        CORBA::tk_string, 
-        0U, // string length
+_TAO_ValueBoxDef_Proxy_Broker::~_TAO_ValueBoxDef_Proxy_Broker (void)
+{
+}
 
-      11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
-      CORBA::tk_alias, // typecode kind for typedefs
-      68, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-        CORBA::tk_string, 
-        0U, // string length
+// Factory function Implementation.
+_TAO_ValueBoxDef_Remote_Proxy_Broker *the_TAO_ValueBoxDef_Remote_Proxy_Broker (void)
+{
+  static ::_TAO_ValueBoxDef_Remote_Proxy_Broker remote_proxy_broker;
+  return &remote_proxy_broker;
+}
 
-      8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
-      CORBA::tk_alias, // typecode kind for typedefs
-      64, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
-        12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
-        CORBA::tk_string, 
-        0U, // string length
+_TAO_ValueBoxDef_Remote_Proxy_Broker::_TAO_ValueBoxDef_Remote_Proxy_Broker (void)
+{
+}
 
-      15, ACE_NTOHL (0x696e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x655f7479), ACE_NTOHL (0x70650000),  // name = interface_type
-      CORBA::tk_objref, // typecode kind
-      60, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/InterfaceDef:1.0
-        13, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = InterfaceDef
+_TAO_ValueBoxDef_Remote_Proxy_Broker::~_TAO_ValueBoxDef_Remote_Proxy_Broker (void)
+{
+}
 
+_TAO_ValueBoxDef_Proxy_Impl&
+_TAO_ValueBoxDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_ValueBoxDef *object,
+  CORBA::Environment &ACE_TRY_ENV
+)
+{
+  ACE_UNUSED_ARG (object);
+  ACE_UNUSED_ARG (ACE_TRY_ENV);
+  return remote_proxy_impl_;
+}
 
-    0U,
 
-};
-static CORBA::TypeCode _tc_TAO_tc_IR_ProvidesDescSeq (CORBA::tk_alias, sizeof (_oc_IR_ProvidesDescSeq), (char *) &_oc_IR_ProvidesDescSeq, 0, sizeof (IR::ProvidesDescSeq));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ProvidesDescSeq, &_tc_TAO_tc_IR_ProvidesDescSeq)
-TAO_NAMESPACE_END
+//
+//           End Remote & Base Proxy Broker Implementation
+///////////////////////////////////////////////////////////////////////
 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
+
+// default constructor
+IR_ValueBoxDef::IR_ValueBoxDef (int collocated)
+{
+  this->_tao_setup_collocation (collocated);
+}
+
+// destructor
+IR_ValueBoxDef::~IR_ValueBoxDef (void)
+{}
+
+void
+IR_ValueBoxDef::_tao_setup_collocation (int collocated)
+{
+  if (collocated)
+    this->the_TAO_ValueBoxDef_Proxy_Broker_ =
+      _TAO_ValueBoxDef_Proxy_Broker_Factory_function_pointer (this);
+  else
+    this->the_TAO_ValueBoxDef_Proxy_Broker_ =
+      ::the_TAO_ValueBoxDef_Remote_Proxy_Broker ();
   
-#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_USESDESCSEQ_CS_)
-#define __TAO_UNBOUNDED_SEQUENCE_IR_USESDESCSEQ_CS_
+  IR_TypedefDef::_tao_setup_collocation (collocated);
+  
+}
 
-  void
-  IR::_TAO_Unbounded_Sequence_IR_UsesDescSeq::_allocate_buffer (CORBA::ULong length)
-  {
-    IR::UsesDescription* tmp = 0;
-    tmp = _TAO_Unbounded_Sequence_IR_UsesDescSeq::allocbuf (length);
-    
-    if (this->buffer_ != 0)
+void IR_ValueBoxDef::_tao_any_destructor (void *x)
+{
+  IR_ValueBoxDef *tmp = ACE_static_cast (IR_ValueBoxDef*,x);
+  CORBA::release (tmp);
+}
+
+IR_ValueBoxDef_ptr IR_ValueBoxDef::_narrow (
+    CORBA::Object_ptr obj,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+{
+  if (CORBA::is_nil (obj))
+    return IR_ValueBoxDef::_nil ();
+  if (! obj->_is_local ())
     {
-      IR::UsesDescription *old = ACE_reinterpret_cast (IR::UsesDescription *,this->buffer_);
-      
-      for (CORBA::ULong i = 0; i < this->length_; ++i)
-        tmp[i] = old[i];
-      
-      if (this->release_)
-        _TAO_Unbounded_Sequence_IR_UsesDescSeq::freebuf (old);
-      
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ValueBoxDef:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (IR_ValueBoxDef::_nil ());
+      if (is_a == 0)
+        return IR_ValueBoxDef::_nil ();
     }
-    this->buffer_ = tmp;
-  }
-  
-  void
-  IR::_TAO_Unbounded_Sequence_IR_UsesDescSeq::_deallocate_buffer (void)
-  {
-    if (this->buffer_ == 0 || this->release_ == 0)
-      return;
-    
-    IR::UsesDescription *tmp = ACE_reinterpret_cast (IR::UsesDescription *,this->buffer_);
-    
-    _TAO_Unbounded_Sequence_IR_UsesDescSeq::freebuf (tmp);
-    this->buffer_ = 0;
-  } 
-  
-  IR::_TAO_Unbounded_Sequence_IR_UsesDescSeq::~_TAO_Unbounded_Sequence_IR_UsesDescSeq (void) // Dtor.
-  {
-    this->_deallocate_buffer ();
-  }
-  
-  
-#endif /* end #if !defined */
+  return IR_ValueBoxDef::_unchecked_narrow (obj, ACE_TRY_ENV);
+}
 
+IR_ValueBoxDef_ptr IR_ValueBoxDef::_unchecked_narrow (
+    CORBA::Object_ptr obj,
+    CORBA::Environment &
+  )
+{
+  if (CORBA::is_nil (obj))
+    return IR_ValueBoxDef::_nil ();
+  if (! obj->_is_local ())
+    {
+      TAO_Stub* stub = obj->_stubobj ();
+      if (stub)
+        stub->_incr_refcnt ();
+      IR_ValueBoxDef_ptr default_proxy = IR_ValueBoxDef::_nil ();
 
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
+      if (
+          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
+          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
+          obj->_is_collocated () &&_TAO_ValueBoxDef_Proxy_Broker_Factory_function_pointer != 0
+        )
+      {
+        ACE_NEW_RETURN (
+          default_proxy,
+          ::IR_ValueBoxDef (
+            stub,
+            1,
+            obj->_servant ()),
+            
+          IR_ValueBoxDef::_nil ());
+        }
+      if (CORBA::is_nil (default_proxy))
+        ACE_NEW_RETURN (default_proxy, ::IR_ValueBoxDef (stub, 0, obj->_servant ()), IR_ValueBoxDef::_nil ());
+        return default_proxy;
+      }
+    else 
+      return
+        ACE_reinterpret_cast
+          (
+            IR_ValueBoxDef_ptr,
+              obj->_tao_QueryInterface
+                (
+                  ACE_reinterpret_cast
+                    (
+                      ptr_arith_t,
+                      &IR_ValueBoxDef::_narrow
+                    )
+                )
+          );
+}
 
-#if !defined (_IR_USESDESCSEQ_CS_)
-#define _IR_USESDESCSEQ_CS_
+IR_ValueBoxDef_ptr
+IR_ValueBoxDef::_duplicate (IR_ValueBoxDef_ptr obj)
+{
+  if (!CORBA::is_nil (obj))
+    obj->_add_ref ();
+  return obj;
+}
 
-// *************************************************************
-// IR::UsesDescSeq
-// *************************************************************
+CORBA::Boolean IR_ValueBoxDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+{
+  if (
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ValueBoxDef:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
+  return 1; // success using local knowledge
+  else
+    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
+}
 
-IR::UsesDescSeq::UsesDescSeq (void)
-{}
-IR::UsesDescSeq::UsesDescSeq (CORBA::ULong max) // uses max size
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Sequence_IR_UsesDescSeq
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::UsesDescription>
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (max)
-{}
-IR::UsesDescSeq::UsesDescSeq (CORBA::ULong max, CORBA::ULong length, IR::UsesDescription *buffer, CORBA::Boolean release)
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Sequence_IR_UsesDescSeq
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::UsesDescription>
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (max, length, buffer, release)
-{}
-IR::UsesDescSeq::UsesDescSeq (const UsesDescSeq &seq) // copy ctor
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Sequence_IR_UsesDescSeq
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<IR::UsesDescription>
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (seq)
-{}
-IR::UsesDescSeq::~UsesDescSeq (void) // dtor
-{}
-void IR::UsesDescSeq::_tao_any_destructor (void *x)
+void *IR_ValueBoxDef::_tao_QueryInterface (ptr_arith_t type)
+{
+  void *retv = 0;
+  if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_ValueBoxDef::_narrow))
+    retv = ACE_reinterpret_cast (void*, this);
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_TypedefDef::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            IR_TypedefDef_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_Contained::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            IR_Contained_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_IDLType::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            IR_IDLType_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &CORBA_IRObject::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            CORBA_IRObject_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
+    retv = ACE_reinterpret_cast (void *,
+      ACE_static_cast (CORBA::Object_ptr, this));
+    
+  if (retv)
+    this->_add_ref ();
+  return retv;
+}
+
+const char* IR_ValueBoxDef::_interface_repository_id (void) const
+{
+  return "IDL:omg.org/IR/ValueBoxDef:1.0";
+}
+
+IR_IDLType_ptr IR_ValueBoxDef::original_type_def (
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  UsesDescSeq *tmp = ACE_static_cast (UsesDescSeq*,x);
-  delete tmp;
+  
+  return this->the_TAO_ValueBoxDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).original_type_def (
+      this,
+      ACE_TRY_ENV
+    );
 }
 
+void IR_ValueBoxDef::original_type_def (
+    IR_IDLType_ptr original_type_def,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  this->the_TAO_ValueBoxDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).original_type_def (
+      this,
+      original_type_def,
+      ACE_TRY_ENV
+    );
+}
 
-#endif /* end #if !defined */
-
-static const CORBA::Long _oc_IR_UsesDescSeq[] =
+static const CORBA::Long _oc_IR_ValueBoxDef[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
-  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x73657344), ACE_NTOHL (0x65736353), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDescSeq:1.0
-  12, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44657363), ACE_NTOHL (0x53657100),  // name = UsesDescSeq
-  CORBA::tk_sequence, // typecode kind
-  536, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    CORBA::tk_struct, // typecode kind
-    520, // encapsulation length
-      TAO_ENCAP_BYTE_ORDER, // byte order
-      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x73657344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDescription:1.0
-      16, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = UsesDescription
-      6, // member count
-      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
-      CORBA::tk_alias, // typecode kind for typedefs
-      64, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
-        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
-        CORBA::tk_string, 
-        0U, // string length
-
-      3, ACE_NTOHL (0x69640000),  // name = id
-      CORBA::tk_alias, // typecode kind for typedefs
-      68, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-        CORBA::tk_string, 
-        0U, // string length
-
-      11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
-      CORBA::tk_alias, // typecode kind for typedefs
-      68, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
-        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
-        CORBA::tk_string, 
-        0U, // string length
-
-      8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
-      CORBA::tk_alias, // typecode kind for typedefs
-      64, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
-        12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
-        CORBA::tk_string, 
-        0U, // string length
-
-      15, ACE_NTOHL (0x696e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x655f7479), ACE_NTOHL (0x70650000),  // name = interface_type
-      CORBA::tk_objref, // typecode kind
-      60, // encapsulation length
-        TAO_ENCAP_BYTE_ORDER, // byte order
-        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/InterfaceDef:1.0
-        13, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = InterfaceDef
-
-      12, ACE_NTOHL (0x69735f6d), ACE_NTOHL (0x756c7469), ACE_NTOHL (0x706c6500),  // name = is_multiple
-      CORBA::tk_boolean,
-
-
-    0U,
-
+  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x426f7844), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ValueBoxDef:1.0
+  12, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65426f78), ACE_NTOHL (0x44656600),  // name = IR_ValueBoxDef
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_UsesDescSeq (CORBA::tk_alias, sizeof (_oc_IR_UsesDescSeq), (char *) &_oc_IR_UsesDescSeq, 0, sizeof (IR::UsesDescSeq));
+static CORBA::TypeCode _tc_TAO_tc_IR_ValueBoxDef (CORBA::tk_objref, sizeof (_oc_IR_ValueBoxDef), (char *) &_oc_IR_ValueBoxDef, 0, sizeof (IR_ValueBoxDef));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UsesDescSeq, &_tc_TAO_tc_IR_UsesDescSeq)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueBoxDef, &_tc_TAO_tc_IR_ValueBoxDef)
 TAO_NAMESPACE_END
 
 ///////////////////////////////////////////////////////////////////////
 //                Base & Remote Proxy  Implementation. 
 //
 
-IR::_TAO_EventDef_Proxy_Impl::_TAO_EventDef_Proxy_Impl (void)
+_TAO_ProvidesDef_Proxy_Impl::_TAO_ProvidesDef_Proxy_Impl (void)
 {}
 
-IR::_TAO_EventDef_Remote_Proxy_Impl::_TAO_EventDef_Remote_Proxy_Impl (void)
+_TAO_ProvidesDef_Remote_Proxy_Impl::_TAO_ProvidesDef_Remote_Proxy_Impl (void)
 {}
 
 // Remote Implementation of the IDL interface methods
 
-CORBA::Boolean IR::_TAO_EventDef_Remote_Proxy_Impl::is_a (
-    CORBA_Object *_collocated_tao_target_,
-    const char * event_id,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  CORBA::Boolean _tao_retval = 0;
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "is_a",
-      4,
-      1,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::EventDef::TAO_ClientRequestInfo_IR_EventDef_is_a ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        event_id,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << event_id)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
-              _tao_retval
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              CORBA::Boolean  _tao_retval_info = _tao_retval;
-               ri.result (_tao_retval_info);
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_retval;
-}
-
-IR::ValueDef_ptr IR::_TAO_EventDef_Remote_Proxy_Impl::event (
+IR_InterfaceDef_ptr _TAO_ProvidesDef_Remote_Proxy_Impl::interface_type (
     CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
+     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
   
-  IR::ValueDef_ptr _tao_retval = IR::ValueDef::_nil ();
-  IR::ValueDef_var _tao_safe_retval (_tao_retval);
+  IR_InterfaceDef_ptr _tao_retval = IR_InterfaceDef::_nil ();
+  IR_InterfaceDef_var _tao_safe_retval (_tao_retval);
   
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
@@ -45521,143 +23579,53 @@
   
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_get_event",
-      10,
+      "_get_interface_type",
+      19,
       0,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::EventDef::TAO_ClientRequestInfo_IR_EventDef_event_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::ValueDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
         }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
@@ -45671,32 +23639,32 @@
 //           Remote & Base  Proxy Broker Implementation
 //
 
-IR::_TAO_EventDef_Proxy_Broker::_TAO_EventDef_Proxy_Broker (void)
+_TAO_ProvidesDef_Proxy_Broker::_TAO_ProvidesDef_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_EventDef_Proxy_Broker::~_TAO_EventDef_Proxy_Broker (void)
+_TAO_ProvidesDef_Proxy_Broker::~_TAO_ProvidesDef_Proxy_Broker (void)
 {
 }
 
-// Factory Member function Implementation.
-IR::_TAO_EventDef_Remote_Proxy_Broker *IR::_TAO_EventDef_Remote_Proxy_Broker::the_TAO_EventDef_Remote_Proxy_Broker (void)
+// Factory function Implementation.
+_TAO_ProvidesDef_Remote_Proxy_Broker *the_TAO_ProvidesDef_Remote_Proxy_Broker (void)
 {
-  static ::IR::_TAO_EventDef_Remote_Proxy_Broker remote_proxy_broker;
+  static ::_TAO_ProvidesDef_Remote_Proxy_Broker remote_proxy_broker;
   return &remote_proxy_broker;
 }
 
-IR::_TAO_EventDef_Remote_Proxy_Broker::_TAO_EventDef_Remote_Proxy_Broker (void)
+_TAO_ProvidesDef_Remote_Proxy_Broker::_TAO_ProvidesDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_EventDef_Remote_Proxy_Broker::~_TAO_EventDef_Remote_Proxy_Broker (void)
+_TAO_ProvidesDef_Remote_Proxy_Broker::~_TAO_ProvidesDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_EventDef_Proxy_Impl&
-IR::_TAO_EventDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::EventDef *object,
+_TAO_ProvidesDef_Proxy_Impl&
+_TAO_ProvidesDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_ProvidesDef *object,
   CORBA::Environment &ACE_TRY_ENV
 )
 {
@@ -45712,112 +23680,113 @@
 
 
 // default constructor
-IR::EventDef::EventDef (int collocated)
+IR_ProvidesDef::IR_ProvidesDef (int collocated)
 {
   this->_tao_setup_collocation (collocated);
 }
 
 // destructor
-IR::EventDef::~EventDef (void)
+IR_ProvidesDef::~IR_ProvidesDef (void)
 {}
 
 void
-IR::EventDef::_tao_setup_collocation (int collocated)
+IR_ProvidesDef::_tao_setup_collocation (int collocated)
 {
   if (collocated)
-    this->the_TAO_EventDef_Proxy_Broker_ =
-      ::IR__TAO_EventDef_Proxy_Broker_Factory_function_pointer (this);
+    this->the_TAO_ProvidesDef_Proxy_Broker_ =
+      _TAO_ProvidesDef_Proxy_Broker_Factory_function_pointer (this);
   else
-    this->the_TAO_EventDef_Proxy_Broker_ =
-      ::IR::_TAO_EventDef_Remote_Proxy_Broker::the_TAO_EventDef_Remote_Proxy_Broker ();
+    this->the_TAO_ProvidesDef_Proxy_Broker_ =
+      ::the_TAO_ProvidesDef_Remote_Proxy_Broker ();
+  
+  IR_Contained::_tao_setup_collocation (collocated);
   
-  ACE_NESTED_CLASS (IR, Contained)::_tao_setup_collocation (collocated);
 }
 
-void IR::EventDef::_tao_any_destructor (void *x)
+void IR_ProvidesDef::_tao_any_destructor (void *x)
 {
-  EventDef *tmp = ACE_static_cast (EventDef*,x);
+  IR_ProvidesDef *tmp = ACE_static_cast (IR_ProvidesDef*,x);
   CORBA::release (tmp);
 }
 
-IR::EventDef_ptr IR::EventDef::_narrow (
+IR_ProvidesDef_ptr IR_ProvidesDef::_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
 {
   if (CORBA::is_nil (obj))
-    return EventDef::_nil ();
+    return IR_ProvidesDef::_nil ();
   if (! obj->_is_local ())
     {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/EventDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (EventDef::_nil ());
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ProvidesDef:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (IR_ProvidesDef::_nil ());
       if (is_a == 0)
-        return EventDef::_nil ();
+        return IR_ProvidesDef::_nil ();
     }
-  return EventDef::_unchecked_narrow (obj, ACE_TRY_ENV);
+  return IR_ProvidesDef::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::EventDef_ptr IR::EventDef::_unchecked_narrow (
+IR_ProvidesDef_ptr IR_ProvidesDef::_unchecked_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &
   )
 {
   if (CORBA::is_nil (obj))
-    return EventDef::_nil ();
+    return IR_ProvidesDef::_nil ();
   if (! obj->_is_local ())
     {
       TAO_Stub* stub = obj->_stubobj ();
       if (stub)
         stub->_incr_refcnt ();
-      EventDef_ptr default_proxy = EventDef::_nil ();
+      IR_ProvidesDef_ptr default_proxy = IR_ProvidesDef::_nil ();
 
       if (
           !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
           stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_EventDef_Proxy_Broker_Factory_function_pointer != 0
+          obj->_is_collocated () &&_TAO_ProvidesDef_Proxy_Broker_Factory_function_pointer != 0
         )
       {
         ACE_NEW_RETURN (
           default_proxy,
-          ::IR::EventDef (
+          ::IR_ProvidesDef (
             stub,
             1,
             obj->_servant ()),
             
-          EventDef::_nil ());
+          IR_ProvidesDef::_nil ());
         }
       if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::EventDef (stub, 0, obj->_servant ()), EventDef::_nil ());
+        ACE_NEW_RETURN (default_proxy, ::IR_ProvidesDef (stub, 0, obj->_servant ()), IR_ProvidesDef::_nil ());
         return default_proxy;
       }
     else 
       return
         ACE_reinterpret_cast
           (
-            EventDef_ptr,
+            IR_ProvidesDef_ptr,
               obj->_tao_QueryInterface
                 (
                   ACE_reinterpret_cast
                     (
                       ptr_arith_t,
-                      &EventDef::_narrow
+                      &IR_ProvidesDef::_narrow
                     )
                 )
           );
 }
 
-IR::EventDef_ptr
-IR::EventDef::_duplicate (EventDef_ptr obj)
+IR_ProvidesDef_ptr
+IR_ProvidesDef::_duplicate (IR_ProvidesDef_ptr obj)
 {
   if (!CORBA::is_nil (obj))
     obj->_add_ref ();
   return obj;
 }
 
-CORBA::Boolean IR::EventDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+CORBA::Boolean IR_ProvidesDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
   if (
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ProvidesDef:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
@@ -45826,34 +23795,34 @@
     return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
 }
 
-void *IR::EventDef::_tao_QueryInterface (ptr_arith_t type)
+void *IR_ProvidesDef::_tao_QueryInterface (ptr_arith_t type)
 {
   void *retv = 0;
   if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, EventDef)::_narrow))
+      &IR_ProvidesDef::_narrow))
     retv = ACE_reinterpret_cast (void*, this);
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Contained)::_narrow))
+      &IR_Contained::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::Contained_ptr,
+            IR_Contained_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
+      &CORBA_IRObject::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            CORBA::IRObject_ptr,
+            CORBA_IRObject_ptr,
             this
           )
       );
@@ -45866,28 +23835,12 @@
   return retv;
 }
 
-const char* IR::EventDef::_interface_repository_id (void) const
+const char* IR_ProvidesDef::_interface_repository_id (void) const
 {
-  return "IDL:omg.org/IR/EventDef:1.0";
-}
-
-CORBA::Boolean IR::EventDef::is_a (
-    const char * event_id,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  return this->the_TAO_EventDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_a (
-      this,
-      event_id,
-      ACE_TRY_ENV
-    );
+  return "IDL:omg.org/IR/ProvidesDef:1.0";
 }
 
-IR::ValueDef_ptr IR::EventDef::event (
+IR_InterfaceDef_ptr IR_ProvidesDef::interface_type (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -45895,152 +23848,29 @@
   ))
 {
   
-  return this->the_TAO_EventDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).event (
+  return this->the_TAO_ProvidesDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).interface_type (
       this,
       ACE_TRY_ENV
     );
 }
 
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-IR::EventDef::TAO_ClientRequestInfo_IR_EventDef_is_a::TAO_ClientRequestInfo_IR_EventDef_is_a (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * event_id,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    event_id_ (event_id)
-{}
-
-Dynamic::ParameterList *
-IR::EventDef::TAO_ClientRequestInfo_IR_EventDef_is_a::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_event_id = parameter_list->length ();
-  parameter_list->length (length_event_id + 1);
-  (*parameter_list)[length_event_id].argument <<= event_id_;
-  (*parameter_list)[length_event_id].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::EventDef::TAO_ClientRequestInfo_IR_EventDef_is_a::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::EventDef::TAO_ClientRequestInfo_IR_EventDef_is_a::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
-  return safe_result_any._retn ();
-}
-
-void 
-IR::EventDef::TAO_ClientRequestInfo_IR_EventDef_is_a::result (CORBA::Boolean result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::EventDef::TAO_ClientRequestInfo_IR_EventDef_event_get::TAO_ClientRequestInfo_IR_EventDef_event_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::EventDef::TAO_ClientRequestInfo_IR_EventDef_event_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::EventDef::TAO_ClientRequestInfo_IR_EventDef_event_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::EventDef::TAO_ClientRequestInfo_IR_EventDef_event_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::EventDef::TAO_ClientRequestInfo_IR_EventDef_event_get::result (IR::ValueDef_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_EventDef[] =
+static const CORBA::Long _oc_IR_ProvidesDef[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
-  28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x76656e74), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/EventDef:1.0
-  9, ACE_NTOHL (0x4576656e), ACE_NTOHL (0x74446566), ACE_NTOHL (0x0),  // name = EventDef
+  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDef:1.0
+  12, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44656600),  // name = IR_ProvidesDef
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_EventDef (CORBA::tk_objref, sizeof (_oc_IR_EventDef), (char *) &_oc_IR_EventDef, 0, sizeof (IR::EventDef));
+static CORBA::TypeCode _tc_TAO_tc_IR_ProvidesDef (CORBA::tk_objref, sizeof (_oc_IR_ProvidesDef), (char *) &_oc_IR_ProvidesDef, 0, sizeof (IR_ProvidesDef));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EventDef, &_tc_TAO_tc_IR_EventDef)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ProvidesDef, &_tc_TAO_tc_IR_ProvidesDef)
 TAO_NAMESPACE_END
-static const CORBA::Long _oc_IR_EventDescription[] =
+
+static const CORBA::Long _oc_IR_ProvidesDescription[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
-  36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x76656e74), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/EventDescription:1.0
-  17, ACE_NTOHL (0x4576656e), ACE_NTOHL (0x74446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = EventDescription
+  39, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDescription:1.0
+  20, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = ProvidesDescription
   5, // member count
   5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
   CORBA::tk_alias, // typecode kind for typedefs
@@ -46078,22 +23908,23 @@
     CORBA::tk_string, 
     0U, // string length
 
-  6, ACE_NTOHL (0x76616c75), ACE_NTOHL (0x65000000),  // name = value
+  15, ACE_NTOHL (0x696e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x655f7479), ACE_NTOHL (0x70650000),  // name = interface_type
   CORBA::tk_objref, // typecode kind
-  52, // encapsulation length
+  60, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
-    28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ValueDef:1.0
-    9, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = ValueDef
+    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/InterfaceDef:1.0
+    13, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = IR_InterfaceDef
 
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_EventDescription (CORBA::tk_struct, sizeof (_oc_IR_EventDescription), (char *) &_oc_IR_EventDescription, 0, sizeof (IR::EventDescription));
+static CORBA::TypeCode _tc_TAO_tc_IR_ProvidesDescription (CORBA::tk_struct, sizeof (_oc_IR_ProvidesDescription), (char *) &_oc_IR_ProvidesDescription, 0, sizeof (IR_ProvidesDescription));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EventDescription, &_tc_TAO_tc_IR_EventDescription)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ProvidesDescription, &_tc_TAO_tc_IR_ProvidesDescription)
 TAO_NAMESPACE_END
-void IR::EventDescription::_tao_any_destructor (void *x)
+
+void IR_ProvidesDescription::_tao_any_destructor (void *x)
 {
-  EventDescription *tmp = ACE_static_cast (EventDescription*,x);
+  IR_ProvidesDescription *tmp = ACE_static_cast (IR_ProvidesDescription*,x);
   delete tmp;
 }
 
@@ -46102,14 +23933,153 @@
 //                Base & Remote Proxy  Implementation. 
 //
 
-IR::_TAO_EmitsDef_Proxy_Impl::_TAO_EmitsDef_Proxy_Impl (void)
+_TAO_UsesDef_Proxy_Impl::_TAO_UsesDef_Proxy_Impl (void)
 {}
 
-IR::_TAO_EmitsDef_Remote_Proxy_Impl::_TAO_EmitsDef_Remote_Proxy_Impl (void)
+_TAO_UsesDef_Remote_Proxy_Impl::_TAO_UsesDef_Remote_Proxy_Impl (void)
 {}
 
 // Remote Implementation of the IDL interface methods
 
+IR_InterfaceDef_ptr _TAO_UsesDef_Remote_Proxy_Impl::interface_type (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  IR_InterfaceDef_ptr _tao_retval = IR_InterfaceDef::_nil ();
+  IR_InterfaceDef_var _tao_safe_retval (_tao_retval);
+  
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_interface_type",
+      19,
+      0,
+      istub->orb_core ()
+    );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
+
+  return _tao_safe_retval._retn ();
+}
+
+CORBA::Boolean _TAO_UsesDef_Remote_Proxy_Impl::is_multiple (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  CORBA::Boolean _tao_retval = 0;
+  
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
+
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_is_multiple",
+      16,
+      0,
+      istub->orb_core ()
+    );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN  (_tao_retval);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              _tao_retval
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                _tao_retval
+              );
+          }
+        break;
+      }
+
+  return _tao_retval;
+}
+
 
 //
 //            End  Base & Remote  Proxy Implemeentation. 
@@ -46120,32 +24090,32 @@
 //           Remote & Base  Proxy Broker Implementation
 //
 
-IR::_TAO_EmitsDef_Proxy_Broker::_TAO_EmitsDef_Proxy_Broker (void)
+_TAO_UsesDef_Proxy_Broker::_TAO_UsesDef_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_EmitsDef_Proxy_Broker::~_TAO_EmitsDef_Proxy_Broker (void)
+_TAO_UsesDef_Proxy_Broker::~_TAO_UsesDef_Proxy_Broker (void)
 {
 }
 
-// Factory Member function Implementation.
-IR::_TAO_EmitsDef_Remote_Proxy_Broker *IR::_TAO_EmitsDef_Remote_Proxy_Broker::the_TAO_EmitsDef_Remote_Proxy_Broker (void)
+// Factory function Implementation.
+_TAO_UsesDef_Remote_Proxy_Broker *the_TAO_UsesDef_Remote_Proxy_Broker (void)
 {
-  static ::IR::_TAO_EmitsDef_Remote_Proxy_Broker remote_proxy_broker;
+  static ::_TAO_UsesDef_Remote_Proxy_Broker remote_proxy_broker;
   return &remote_proxy_broker;
 }
 
-IR::_TAO_EmitsDef_Remote_Proxy_Broker::_TAO_EmitsDef_Remote_Proxy_Broker (void)
+_TAO_UsesDef_Remote_Proxy_Broker::_TAO_UsesDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_EmitsDef_Remote_Proxy_Broker::~_TAO_EmitsDef_Remote_Proxy_Broker (void)
+_TAO_UsesDef_Remote_Proxy_Broker::~_TAO_UsesDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_EmitsDef_Proxy_Impl&
-IR::_TAO_EmitsDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::EmitsDef *object,
+_TAO_UsesDef_Proxy_Impl&
+_TAO_UsesDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_UsesDef *object,
   CORBA::Environment &ACE_TRY_ENV
 )
 {
@@ -46161,113 +24131,113 @@
 
 
 // default constructor
-IR::EmitsDef::EmitsDef (int collocated)
+IR_UsesDef::IR_UsesDef (int collocated)
 {
   this->_tao_setup_collocation (collocated);
 }
 
 // destructor
-IR::EmitsDef::~EmitsDef (void)
+IR_UsesDef::~IR_UsesDef (void)
 {}
 
 void
-IR::EmitsDef::_tao_setup_collocation (int collocated)
+IR_UsesDef::_tao_setup_collocation (int collocated)
 {
   if (collocated)
-    this->the_TAO_EmitsDef_Proxy_Broker_ =
-      ::IR__TAO_EmitsDef_Proxy_Broker_Factory_function_pointer (this);
+    this->the_TAO_UsesDef_Proxy_Broker_ =
+      _TAO_UsesDef_Proxy_Broker_Factory_function_pointer (this);
   else
-    this->the_TAO_EmitsDef_Proxy_Broker_ =
-      ::IR::_TAO_EmitsDef_Remote_Proxy_Broker::the_TAO_EmitsDef_Remote_Proxy_Broker ();
+    this->the_TAO_UsesDef_Proxy_Broker_ =
+      ::the_TAO_UsesDef_Remote_Proxy_Broker ();
+  
+  IR_Contained::_tao_setup_collocation (collocated);
   
-  ACE_NESTED_CLASS (IR, EventDef)::_tao_setup_collocation (collocated);
 }
 
-void IR::EmitsDef::_tao_any_destructor (void *x)
+void IR_UsesDef::_tao_any_destructor (void *x)
 {
-  EmitsDef *tmp = ACE_static_cast (EmitsDef*,x);
+  IR_UsesDef *tmp = ACE_static_cast (IR_UsesDef*,x);
   CORBA::release (tmp);
 }
 
-IR::EmitsDef_ptr IR::EmitsDef::_narrow (
+IR_UsesDef_ptr IR_UsesDef::_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
 {
   if (CORBA::is_nil (obj))
-    return EmitsDef::_nil ();
+    return IR_UsesDef::_nil ();
   if (! obj->_is_local ())
     {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/EmitsDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (EmitsDef::_nil ());
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/UsesDef:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (IR_UsesDef::_nil ());
       if (is_a == 0)
-        return EmitsDef::_nil ();
+        return IR_UsesDef::_nil ();
     }
-  return EmitsDef::_unchecked_narrow (obj, ACE_TRY_ENV);
+  return IR_UsesDef::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::EmitsDef_ptr IR::EmitsDef::_unchecked_narrow (
+IR_UsesDef_ptr IR_UsesDef::_unchecked_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &
   )
 {
   if (CORBA::is_nil (obj))
-    return EmitsDef::_nil ();
+    return IR_UsesDef::_nil ();
   if (! obj->_is_local ())
     {
       TAO_Stub* stub = obj->_stubobj ();
       if (stub)
         stub->_incr_refcnt ();
-      EmitsDef_ptr default_proxy = EmitsDef::_nil ();
+      IR_UsesDef_ptr default_proxy = IR_UsesDef::_nil ();
 
       if (
           !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
           stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_EmitsDef_Proxy_Broker_Factory_function_pointer != 0
+          obj->_is_collocated () &&_TAO_UsesDef_Proxy_Broker_Factory_function_pointer != 0
         )
       {
         ACE_NEW_RETURN (
           default_proxy,
-          ::IR::EmitsDef (
+          ::IR_UsesDef (
             stub,
             1,
             obj->_servant ()),
             
-          EmitsDef::_nil ());
+          IR_UsesDef::_nil ());
         }
       if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::EmitsDef (stub, 0, obj->_servant ()), EmitsDef::_nil ());
+        ACE_NEW_RETURN (default_proxy, ::IR_UsesDef (stub, 0, obj->_servant ()), IR_UsesDef::_nil ());
         return default_proxy;
       }
     else 
       return
         ACE_reinterpret_cast
           (
-            EmitsDef_ptr,
+            IR_UsesDef_ptr,
               obj->_tao_QueryInterface
                 (
                   ACE_reinterpret_cast
                     (
                       ptr_arith_t,
-                      &EmitsDef::_narrow
+                      &IR_UsesDef::_narrow
                     )
                 )
           );
 }
 
-IR::EmitsDef_ptr
-IR::EmitsDef::_duplicate (EmitsDef_ptr obj)
+IR_UsesDef_ptr
+IR_UsesDef::_duplicate (IR_UsesDef_ptr obj)
 {
   if (!CORBA::is_nil (obj))
     obj->_add_ref ();
   return obj;
 }
 
-CORBA::Boolean IR::EmitsDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+CORBA::Boolean IR_UsesDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
   if (
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EmitsDef:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/UsesDef:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
@@ -46276,46 +24246,34 @@
     return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
 }
 
-void *IR::EmitsDef::_tao_QueryInterface (ptr_arith_t type)
+void *IR_UsesDef::_tao_QueryInterface (ptr_arith_t type)
 {
   void *retv = 0;
   if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, EmitsDef)::_narrow))
+      &IR_UsesDef::_narrow))
     retv = ACE_reinterpret_cast (void*, this);
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, EventDef)::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            IR::EventDef_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Contained)::_narrow))
+      &IR_Contained::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::Contained_ptr,
+            IR_Contained_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
+      &CORBA_IRObject::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            CORBA::IRObject_ptr,
+            CORBA_IRObject_ptr,
             this
           )
       );
@@ -46328,288 +24286,579 @@
   return retv;
 }
 
-const char* IR::EmitsDef::_interface_repository_id (void) const
+const char* IR_UsesDef::_interface_repository_id (void) const
 {
-  return "IDL:omg.org/IR/EmitsDef:1.0";
+  return "IDL:omg.org/IR/UsesDef:1.0";
 }
 
+IR_InterfaceDef_ptr IR_UsesDef::interface_type (
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  return this->the_TAO_UsesDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).interface_type (
+      this,
+      ACE_TRY_ENV
+    );
+}
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_EmitsDef[] =
+CORBA::Boolean IR_UsesDef::is_multiple (
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  return this->the_TAO_UsesDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_multiple (
+      this,
+      ACE_TRY_ENV
+    );
+}
+
+static const CORBA::Long _oc_IR_UsesDef[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
-  28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x6d697473), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/EmitsDef:1.0
-  9, ACE_NTOHL (0x456d6974), ACE_NTOHL (0x73446566), ACE_NTOHL (0x0),  // name = EmitsDef
+  27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x73657344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDef:1.0
+  8, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44656600),  // name = IR_UsesDef
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_EmitsDef (CORBA::tk_objref, sizeof (_oc_IR_EmitsDef), (char *) &_oc_IR_EmitsDef, 0, sizeof (IR::EmitsDef));
+static CORBA::TypeCode _tc_TAO_tc_IR_UsesDef (CORBA::tk_objref, sizeof (_oc_IR_UsesDef), (char *) &_oc_IR_UsesDef, 0, sizeof (IR_UsesDef));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EmitsDef, &_tc_TAO_tc_IR_EmitsDef)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UsesDef, &_tc_TAO_tc_IR_UsesDef)
 TAO_NAMESPACE_END
 
-///////////////////////////////////////////////////////////////////////
-//                Base & Remote Proxy  Implementation. 
-//
-
-IR::_TAO_PublishesDef_Proxy_Impl::_TAO_PublishesDef_Proxy_Impl (void)
-{}
+static const CORBA::Long _oc_IR_UsesDescription[] =
+{
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x73657344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDescription:1.0
+  16, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = UsesDescription
+  6, // member count
+  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+  CORBA::tk_alias, // typecode kind for typedefs
+  64, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+    CORBA::tk_string, 
+    0U, // string length
 
-IR::_TAO_PublishesDef_Remote_Proxy_Impl::_TAO_PublishesDef_Remote_Proxy_Impl (void)
-{}
+  3, ACE_NTOHL (0x69640000),  // name = id
+  CORBA::tk_alias, // typecode kind for typedefs
+  68, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+    CORBA::tk_string, 
+    0U, // string length
 
-// Remote Implementation of the IDL interface methods
+  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
+  CORBA::tk_alias, // typecode kind for typedefs
+  68, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+    CORBA::tk_string, 
+    0U, // string length
 
+  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
+  CORBA::tk_alias, // typecode kind for typedefs
+  64, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
+    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
+    CORBA::tk_string, 
+    0U, // string length
 
-//
-//            End  Base & Remote  Proxy Implemeentation. 
-///////////////////////////////////////////////////////////////////////
+  15, ACE_NTOHL (0x696e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x655f7479), ACE_NTOHL (0x70650000),  // name = interface_type
+  CORBA::tk_objref, // typecode kind
+  60, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/InterfaceDef:1.0
+    13, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = IR_InterfaceDef
 
+  12, ACE_NTOHL (0x69735f6d), ACE_NTOHL (0x756c7469), ACE_NTOHL (0x706c6500),  // name = is_multiple
+  CORBA::tk_boolean,
 
-///////////////////////////////////////////////////////////////////////
-//           Remote & Base  Proxy Broker Implementation
-//
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_UsesDescription (CORBA::tk_struct, sizeof (_oc_IR_UsesDescription), (char *) &_oc_IR_UsesDescription, 0, sizeof (IR_UsesDescription));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UsesDescription, &_tc_TAO_tc_IR_UsesDescription)
+TAO_NAMESPACE_END
 
-IR::_TAO_PublishesDef_Proxy_Broker::_TAO_PublishesDef_Proxy_Broker (void)
+void IR_UsesDescription::_tao_any_destructor (void *x)
 {
+  IR_UsesDescription *tmp = ACE_static_cast (IR_UsesDescription*,x);
+  delete tmp;
 }
 
-IR::_TAO_PublishesDef_Proxy_Broker::~_TAO_PublishesDef_Proxy_Broker (void)
-{
-}
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
+  
+  void
+  _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::_allocate_buffer (CORBA::ULong length)
+  {
+    IR_ProvidesDescription* tmp = 0;
+    tmp = _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::allocbuf (length);
+    
+    if (this->buffer_ != 0)
+    {
+      IR_ProvidesDescription *old = ACE_reinterpret_cast (IR_ProvidesDescription *,this->buffer_);
+      
+      for (CORBA::ULong i = 0; i < this->length_; ++i)
+        tmp[i] = old[i];
+      
+      if (this->release_)
+        _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::freebuf (old);
+      
+    }
+    this->buffer_ = tmp;
+  }
+  
+  void
+  _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::_deallocate_buffer (void)
+  {
+    if (this->buffer_ == 0 || this->release_ == 0)
+      return;
+    
+    IR_ProvidesDescription *tmp = ACE_reinterpret_cast (IR_ProvidesDescription *,this->buffer_);
+    
+    _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::freebuf (tmp);
+    this->buffer_ = 0;
+  } 
+  
+  _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::~_TAO_Unbounded_Sequence_IR_ProvidesDescSeq (void) // Dtor.
+  {
+    this->_deallocate_buffer ();
+  }
+  
+#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
+
+// *************************************************************
+// IR_ProvidesDescSeq
+// *************************************************************
 
-// Factory Member function Implementation.
-IR::_TAO_PublishesDef_Remote_Proxy_Broker *IR::_TAO_PublishesDef_Remote_Proxy_Broker::the_TAO_PublishesDef_Remote_Proxy_Broker (void)
+IR_ProvidesDescSeq::IR_ProvidesDescSeq (void)
+{}
+IR_ProvidesDescSeq::IR_ProvidesDescSeq (CORBA::ULong max) // uses max size
+  : 
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
+  _TAO_Unbounded_Sequence_IR_ProvidesDescSeq
+#else /* TAO_USE_SEQUENCE_TEMPLATES */
+  TAO_Unbounded_Sequence<IR_ProvidesDescription>
+#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
+ (max)
+{}
+IR_ProvidesDescSeq::IR_ProvidesDescSeq (CORBA::ULong max, CORBA::ULong length, IR_ProvidesDescription *buffer, CORBA::Boolean release)
+  : 
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
+  _TAO_Unbounded_Sequence_IR_ProvidesDescSeq
+#else /* TAO_USE_SEQUENCE_TEMPLATES */
+  TAO_Unbounded_Sequence<IR_ProvidesDescription>
+#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
+ (max, length, buffer, release)
+{}
+IR_ProvidesDescSeq::IR_ProvidesDescSeq (const IR_ProvidesDescSeq &seq) // copy ctor
+  : 
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
+  _TAO_Unbounded_Sequence_IR_ProvidesDescSeq
+#else /* TAO_USE_SEQUENCE_TEMPLATES */
+  TAO_Unbounded_Sequence<IR_ProvidesDescription>
+#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
+ (seq)
+{}
+IR_ProvidesDescSeq::~IR_ProvidesDescSeq (void) // dtor
+{}
+void IR_ProvidesDescSeq::_tao_any_destructor (void *x)
 {
-  static ::IR::_TAO_PublishesDef_Remote_Proxy_Broker remote_proxy_broker;
-  return &remote_proxy_broker;
+  IR_ProvidesDescSeq *tmp = ACE_static_cast (IR_ProvidesDescSeq*,x);
+  delete tmp;
 }
 
-IR::_TAO_PublishesDef_Remote_Proxy_Broker::_TAO_PublishesDef_Remote_Proxy_Broker (void)
+static const CORBA::Long _oc_IR_ProvidesDescSeq[] =
 {
-}
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657344), ACE_NTOHL (0x65736353), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDescSeq:1.0
+  16, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44657363), ACE_NTOHL (0x53657100),  // name = ProvidesDescSeq
+  CORBA::tk_sequence, // typecode kind
+  524, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    CORBA::tk_struct, // typecode kind
+    508, // encapsulation length
+      TAO_ENCAP_BYTE_ORDER, // byte order
+      39, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDescription:1.0
+      20, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = ProvidesDescription
+      5, // member count
+      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+      CORBA::tk_alias, // typecode kind for typedefs
+      64, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+        CORBA::tk_string, 
+        0U, // string length
 
-IR::_TAO_PublishesDef_Remote_Proxy_Broker::~_TAO_PublishesDef_Remote_Proxy_Broker (void)
-{
-}
+      3, ACE_NTOHL (0x69640000),  // name = id
+      CORBA::tk_alias, // typecode kind for typedefs
+      68, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+        CORBA::tk_string, 
+        0U, // string length
 
-IR::_TAO_PublishesDef_Proxy_Impl&
-IR::_TAO_PublishesDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::PublishesDef *object,
-  CORBA::Environment &ACE_TRY_ENV
-)
-{
-  ACE_UNUSED_ARG (object);
-  ACE_UNUSED_ARG (ACE_TRY_ENV);
-  return remote_proxy_impl_;
-}
+      11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
+      CORBA::tk_alias, // typecode kind for typedefs
+      68, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+        CORBA::tk_string, 
+        0U, // string length
 
+      8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
+      CORBA::tk_alias, // typecode kind for typedefs
+      64, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
+        12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
+        CORBA::tk_string, 
+        0U, // string length
 
-//
-//           End Remote & Base Proxy Broker Implementation
-///////////////////////////////////////////////////////////////////////
+      15, ACE_NTOHL (0x696e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x655f7479), ACE_NTOHL (0x70650000),  // name = interface_type
+      CORBA::tk_objref, // typecode kind
+      60, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/InterfaceDef:1.0
+        13, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = IR_InterfaceDef
 
 
-// default constructor
-IR::PublishesDef::PublishesDef (int collocated)
-{
-  this->_tao_setup_collocation (collocated);
-}
+    0U,
 
-// destructor
-IR::PublishesDef::~PublishesDef (void)
-{}
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_ProvidesDescSeq (CORBA::tk_alias, sizeof (_oc_IR_ProvidesDescSeq), (char *) &_oc_IR_ProvidesDescSeq, 0, sizeof (IR_ProvidesDescSeq));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ProvidesDescSeq, &_tc_TAO_tc_IR_ProvidesDescSeq)
+TAO_NAMESPACE_END
 
-void
-IR::PublishesDef::_tao_setup_collocation (int collocated)
-{
-  if (collocated)
-    this->the_TAO_PublishesDef_Proxy_Broker_ =
-      ::IR__TAO_PublishesDef_Proxy_Broker_Factory_function_pointer (this);
-  else
-    this->the_TAO_PublishesDef_Proxy_Broker_ =
-      ::IR::_TAO_PublishesDef_Remote_Proxy_Broker::the_TAO_PublishesDef_Remote_Proxy_Broker ();
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   
-  ACE_NESTED_CLASS (IR, EventDef)::_tao_setup_collocation (collocated);
-}
-
-void IR::PublishesDef::_tao_any_destructor (void *x)
-{
-  PublishesDef *tmp = ACE_static_cast (PublishesDef*,x);
-  CORBA::release (tmp);
-}
-
-IR::PublishesDef_ptr IR::PublishesDef::_narrow (
-    CORBA::Object_ptr obj,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-{
-  if (CORBA::is_nil (obj))
-    return PublishesDef::_nil ();
-  if (! obj->_is_local ())
+  void
+  _TAO_Unbounded_Sequence_IR_UsesDescSeq::_allocate_buffer (CORBA::ULong length)
+  {
+    IR_UsesDescription* tmp = 0;
+    tmp = _TAO_Unbounded_Sequence_IR_UsesDescSeq::allocbuf (length);
+    
+    if (this->buffer_ != 0)
     {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/PublishesDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (PublishesDef::_nil ());
-      if (is_a == 0)
-        return PublishesDef::_nil ();
+      IR_UsesDescription *old = ACE_reinterpret_cast (IR_UsesDescription *,this->buffer_);
+      
+      for (CORBA::ULong i = 0; i < this->length_; ++i)
+        tmp[i] = old[i];
+      
+      if (this->release_)
+        _TAO_Unbounded_Sequence_IR_UsesDescSeq::freebuf (old);
+      
     }
-  return PublishesDef::_unchecked_narrow (obj, ACE_TRY_ENV);
-}
-
-IR::PublishesDef_ptr IR::PublishesDef::_unchecked_narrow (
-    CORBA::Object_ptr obj,
-    CORBA::Environment &
-  )
-{
-  if (CORBA::is_nil (obj))
-    return PublishesDef::_nil ();
-  if (! obj->_is_local ())
-    {
-      TAO_Stub* stub = obj->_stubobj ();
-      if (stub)
-        stub->_incr_refcnt ();
-      PublishesDef_ptr default_proxy = PublishesDef::_nil ();
-
-      if (
-          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
-          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_PublishesDef_Proxy_Broker_Factory_function_pointer != 0
-        )
-      {
-        ACE_NEW_RETURN (
-          default_proxy,
-          ::IR::PublishesDef (
-            stub,
-            1,
-            obj->_servant ()),
-            
-          PublishesDef::_nil ());
-        }
-      if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::PublishesDef (stub, 0, obj->_servant ()), PublishesDef::_nil ());
-        return default_proxy;
-      }
-    else 
-      return
-        ACE_reinterpret_cast
-          (
-            PublishesDef_ptr,
-              obj->_tao_QueryInterface
-                (
-                  ACE_reinterpret_cast
-                    (
-                      ptr_arith_t,
-                      &PublishesDef::_narrow
-                    )
-                )
-          );
-}
-
-IR::PublishesDef_ptr
-IR::PublishesDef::_duplicate (PublishesDef_ptr obj)
-{
-  if (!CORBA::is_nil (obj))
-    obj->_add_ref ();
-  return obj;
-}
-
-CORBA::Boolean IR::PublishesDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
-{
-  if (
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/PublishesDef:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
-  return 1; // success using local knowledge
-  else
-    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
-}
-
-void *IR::PublishesDef::_tao_QueryInterface (ptr_arith_t type)
-{
-  void *retv = 0;
-  if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, PublishesDef)::_narrow))
-    retv = ACE_reinterpret_cast (void*, this);
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, EventDef)::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            IR::EventDef_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Contained)::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            IR::Contained_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            CORBA::IRObject_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
-    retv = ACE_reinterpret_cast (void *,
-      ACE_static_cast (CORBA::Object_ptr, this));
+    this->buffer_ = tmp;
+  }
+  
+  void
+  _TAO_Unbounded_Sequence_IR_UsesDescSeq::_deallocate_buffer (void)
+  {
+    if (this->buffer_ == 0 || this->release_ == 0)
+      return;
     
-  if (retv)
-    this->_add_ref ();
-  return retv;
-}
+    IR_UsesDescription *tmp = ACE_reinterpret_cast (IR_UsesDescription *,this->buffer_);
+    
+    _TAO_Unbounded_Sequence_IR_UsesDescSeq::freebuf (tmp);
+    this->buffer_ = 0;
+  } 
+  
+  _TAO_Unbounded_Sequence_IR_UsesDescSeq::~_TAO_Unbounded_Sequence_IR_UsesDescSeq (void) // Dtor.
+  {
+    this->_deallocate_buffer ();
+  }
+  
+#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 
-const char* IR::PublishesDef::_interface_repository_id (void) const
+// *************************************************************
+// IR_UsesDescSeq
+// *************************************************************
+
+IR_UsesDescSeq::IR_UsesDescSeq (void)
+{}
+IR_UsesDescSeq::IR_UsesDescSeq (CORBA::ULong max) // uses max size
+  : 
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
+  _TAO_Unbounded_Sequence_IR_UsesDescSeq
+#else /* TAO_USE_SEQUENCE_TEMPLATES */
+  TAO_Unbounded_Sequence<IR_UsesDescription>
+#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
+ (max)
+{}
+IR_UsesDescSeq::IR_UsesDescSeq (CORBA::ULong max, CORBA::ULong length, IR_UsesDescription *buffer, CORBA::Boolean release)
+  : 
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
+  _TAO_Unbounded_Sequence_IR_UsesDescSeq
+#else /* TAO_USE_SEQUENCE_TEMPLATES */
+  TAO_Unbounded_Sequence<IR_UsesDescription>
+#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
+ (max, length, buffer, release)
+{}
+IR_UsesDescSeq::IR_UsesDescSeq (const IR_UsesDescSeq &seq) // copy ctor
+  : 
+#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
+  _TAO_Unbounded_Sequence_IR_UsesDescSeq
+#else /* TAO_USE_SEQUENCE_TEMPLATES */
+  TAO_Unbounded_Sequence<IR_UsesDescription>
+#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
+ (seq)
+{}
+IR_UsesDescSeq::~IR_UsesDescSeq (void) // dtor
+{}
+void IR_UsesDescSeq::_tao_any_destructor (void *x)
 {
-  return "IDL:omg.org/IR/PublishesDef:1.0";
+  IR_UsesDescSeq *tmp = ACE_static_cast (IR_UsesDescSeq*,x);
+  delete tmp;
 }
 
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_PublishesDef[] =
+static const CORBA::Long _oc_IR_UsesDescSeq[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
-  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x75626c69), ACE_NTOHL (0x73686573), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/PublishesDef:1.0
-  13, ACE_NTOHL (0x5075626c), ACE_NTOHL (0x69736865), ACE_NTOHL (0x73446566), ACE_NTOHL (0x0),  // name = PublishesDef
+  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x73657344), ACE_NTOHL (0x65736353), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDescSeq:1.0
+  12, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44657363), ACE_NTOHL (0x53657100),  // name = UsesDescSeq
+  CORBA::tk_sequence, // typecode kind
+  536, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    CORBA::tk_struct, // typecode kind
+    520, // encapsulation length
+      TAO_ENCAP_BYTE_ORDER, // byte order
+      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x73657344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDescription:1.0
+      16, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = UsesDescription
+      6, // member count
+      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+      CORBA::tk_alias, // typecode kind for typedefs
+      64, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+        CORBA::tk_string, 
+        0U, // string length
+
+      3, ACE_NTOHL (0x69640000),  // name = id
+      CORBA::tk_alias, // typecode kind for typedefs
+      68, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+        CORBA::tk_string, 
+        0U, // string length
+
+      11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
+      CORBA::tk_alias, // typecode kind for typedefs
+      68, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+        CORBA::tk_string, 
+        0U, // string length
+
+      8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
+      CORBA::tk_alias, // typecode kind for typedefs
+      64, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
+        12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
+        CORBA::tk_string, 
+        0U, // string length
+
+      15, ACE_NTOHL (0x696e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x655f7479), ACE_NTOHL (0x70650000),  // name = interface_type
+      CORBA::tk_objref, // typecode kind
+      60, // encapsulation length
+        TAO_ENCAP_BYTE_ORDER, // byte order
+        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/InterfaceDef:1.0
+        13, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = IR_InterfaceDef
+
+      12, ACE_NTOHL (0x69735f6d), ACE_NTOHL (0x756c7469), ACE_NTOHL (0x706c6500),  // name = is_multiple
+      CORBA::tk_boolean,
+
+
+    0U,
+
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_PublishesDef (CORBA::tk_objref, sizeof (_oc_IR_PublishesDef), (char *) &_oc_IR_PublishesDef, 0, sizeof (IR::PublishesDef));
+static CORBA::TypeCode _tc_TAO_tc_IR_UsesDescSeq (CORBA::tk_alias, sizeof (_oc_IR_UsesDescSeq), (char *) &_oc_IR_UsesDescSeq, 0, sizeof (IR_UsesDescSeq));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PublishesDef, &_tc_TAO_tc_IR_PublishesDef)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UsesDescSeq, &_tc_TAO_tc_IR_UsesDescSeq)
 TAO_NAMESPACE_END
 
 ///////////////////////////////////////////////////////////////////////
 //                Base & Remote Proxy  Implementation. 
 //
 
-IR::_TAO_ConsumesDef_Proxy_Impl::_TAO_ConsumesDef_Proxy_Impl (void)
+_TAO_EventDef_Proxy_Impl::_TAO_EventDef_Proxy_Impl (void)
 {}
 
-IR::_TAO_ConsumesDef_Remote_Proxy_Impl::_TAO_ConsumesDef_Remote_Proxy_Impl (void)
+_TAO_EventDef_Remote_Proxy_Impl::_TAO_EventDef_Remote_Proxy_Impl (void)
 {}
 
 // Remote Implementation of the IDL interface methods
 
+CORBA::Boolean _TAO_EventDef_Remote_Proxy_Impl::is_a (
+    CORBA_Object *_collocated_tao_target_,
+    const char * event_id,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  CORBA::Boolean _tao_retval = 0;
+  
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
+
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "is_a",
+      4,
+      1,
+      istub->orb_core ()
+    );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << event_id)
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            _tao_retval
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              _tao_retval
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                _tao_retval
+              );
+          }
+        break;
+      }
+
+  return _tao_retval;
+}
+
+IR_ValueDef_ptr _TAO_EventDef_Remote_Proxy_Impl::event (
+    CORBA_Object *_collocated_tao_target_,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  IR_ValueDef_ptr _tao_retval = IR_ValueDef::_nil ();
+  IR_ValueDef_var _tao_safe_retval (_tao_retval);
+  
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_event",
+      10,
+      0,
+      istub->orb_core ()
+    );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
+
+  return _tao_safe_retval._retn ();
+}
+
 
 //
 //            End  Base & Remote  Proxy Implemeentation. 
@@ -46620,32 +24869,32 @@
 //           Remote & Base  Proxy Broker Implementation
 //
 
-IR::_TAO_ConsumesDef_Proxy_Broker::_TAO_ConsumesDef_Proxy_Broker (void)
+_TAO_EventDef_Proxy_Broker::_TAO_EventDef_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_ConsumesDef_Proxy_Broker::~_TAO_ConsumesDef_Proxy_Broker (void)
+_TAO_EventDef_Proxy_Broker::~_TAO_EventDef_Proxy_Broker (void)
 {
 }
 
-// Factory Member function Implementation.
-IR::_TAO_ConsumesDef_Remote_Proxy_Broker *IR::_TAO_ConsumesDef_Remote_Proxy_Broker::the_TAO_ConsumesDef_Remote_Proxy_Broker (void)
+// Factory function Implementation.
+_TAO_EventDef_Remote_Proxy_Broker *the_TAO_EventDef_Remote_Proxy_Broker (void)
 {
-  static ::IR::_TAO_ConsumesDef_Remote_Proxy_Broker remote_proxy_broker;
+  static ::_TAO_EventDef_Remote_Proxy_Broker remote_proxy_broker;
   return &remote_proxy_broker;
 }
 
-IR::_TAO_ConsumesDef_Remote_Proxy_Broker::_TAO_ConsumesDef_Remote_Proxy_Broker (void)
+_TAO_EventDef_Remote_Proxy_Broker::_TAO_EventDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_ConsumesDef_Remote_Proxy_Broker::~_TAO_ConsumesDef_Remote_Proxy_Broker (void)
+_TAO_EventDef_Remote_Proxy_Broker::~_TAO_EventDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_ConsumesDef_Proxy_Impl&
-IR::_TAO_ConsumesDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::ConsumesDef *object,
+_TAO_EventDef_Proxy_Impl&
+_TAO_EventDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_EventDef *object,
   CORBA::Environment &ACE_TRY_ENV
 )
 {
@@ -46661,112 +24910,112 @@
 
 
 // default constructor
-IR::ConsumesDef::ConsumesDef (int collocated)
+IR_EventDef::IR_EventDef (int collocated)
 {
   this->_tao_setup_collocation (collocated);
 }
 
 // destructor
-IR::ConsumesDef::~ConsumesDef (void)
+IR_EventDef::~IR_EventDef (void)
 {}
 
 void
-IR::ConsumesDef::_tao_setup_collocation (int collocated)
+IR_EventDef::_tao_setup_collocation (int collocated)
 {
   if (collocated)
-    this->the_TAO_ConsumesDef_Proxy_Broker_ =
-      ::IR__TAO_ConsumesDef_Proxy_Broker_Factory_function_pointer (this);
+    this->the_TAO_EventDef_Proxy_Broker_ =
+      _TAO_EventDef_Proxy_Broker_Factory_function_pointer (this);
   else
-    this->the_TAO_ConsumesDef_Proxy_Broker_ =
-      ::IR::_TAO_ConsumesDef_Remote_Proxy_Broker::the_TAO_ConsumesDef_Remote_Proxy_Broker ();
+    this->the_TAO_EventDef_Proxy_Broker_ =
+      ::the_TAO_EventDef_Remote_Proxy_Broker ();
+  
+  IR_Contained::_tao_setup_collocation (collocated);
   
-  ACE_NESTED_CLASS (IR, EventDef)::_tao_setup_collocation (collocated);
 }
 
-void IR::ConsumesDef::_tao_any_destructor (void *x)
+void IR_EventDef::_tao_any_destructor (void *x)
 {
-  ConsumesDef *tmp = ACE_static_cast (ConsumesDef*,x);
+  IR_EventDef *tmp = ACE_static_cast (IR_EventDef*,x);
   CORBA::release (tmp);
 }
 
-IR::ConsumesDef_ptr IR::ConsumesDef::_narrow (
+IR_EventDef_ptr IR_EventDef::_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
 {
   if (CORBA::is_nil (obj))
-    return ConsumesDef::_nil ();
+    return IR_EventDef::_nil ();
   if (! obj->_is_local ())
     {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ConsumesDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (ConsumesDef::_nil ());
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/EventDef:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (IR_EventDef::_nil ());
       if (is_a == 0)
-        return ConsumesDef::_nil ();
+        return IR_EventDef::_nil ();
     }
-  return ConsumesDef::_unchecked_narrow (obj, ACE_TRY_ENV);
+  return IR_EventDef::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::ConsumesDef_ptr IR::ConsumesDef::_unchecked_narrow (
+IR_EventDef_ptr IR_EventDef::_unchecked_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &
   )
 {
   if (CORBA::is_nil (obj))
-    return ConsumesDef::_nil ();
+    return IR_EventDef::_nil ();
   if (! obj->_is_local ())
     {
       TAO_Stub* stub = obj->_stubobj ();
       if (stub)
         stub->_incr_refcnt ();
-      ConsumesDef_ptr default_proxy = ConsumesDef::_nil ();
+      IR_EventDef_ptr default_proxy = IR_EventDef::_nil ();
 
       if (
           !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
           stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_ConsumesDef_Proxy_Broker_Factory_function_pointer != 0
+          obj->_is_collocated () &&_TAO_EventDef_Proxy_Broker_Factory_function_pointer != 0
         )
       {
         ACE_NEW_RETURN (
           default_proxy,
-          ::IR::ConsumesDef (
+          ::IR_EventDef (
             stub,
             1,
             obj->_servant ()),
             
-          ConsumesDef::_nil ());
+          IR_EventDef::_nil ());
         }
       if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::ConsumesDef (stub, 0, obj->_servant ()), ConsumesDef::_nil ());
+        ACE_NEW_RETURN (default_proxy, ::IR_EventDef (stub, 0, obj->_servant ()), IR_EventDef::_nil ());
         return default_proxy;
       }
     else 
       return
         ACE_reinterpret_cast
           (
-            ConsumesDef_ptr,
+            IR_EventDef_ptr,
               obj->_tao_QueryInterface
                 (
                   ACE_reinterpret_cast
                     (
                       ptr_arith_t,
-                      &ConsumesDef::_narrow
+                      &IR_EventDef::_narrow
                     )
                 )
           );
 }
 
-IR::ConsumesDef_ptr
-IR::ConsumesDef::_duplicate (ConsumesDef_ptr obj)
+IR_EventDef_ptr
+IR_EventDef::_duplicate (IR_EventDef_ptr obj)
 {
   if (!CORBA::is_nil (obj))
     obj->_add_ref ();
   return obj;
 }
 
-CORBA::Boolean IR::ConsumesDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+CORBA::Boolean IR_EventDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
   if (
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ConsumesDef:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
@@ -46776,46 +25025,34 @@
     return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
 }
 
-void *IR::ConsumesDef::_tao_QueryInterface (ptr_arith_t type)
+void *IR_EventDef::_tao_QueryInterface (ptr_arith_t type)
 {
   void *retv = 0;
   if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, ConsumesDef)::_narrow))
+      &IR_EventDef::_narrow))
     retv = ACE_reinterpret_cast (void*, this);
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, EventDef)::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            IR::EventDef_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Contained)::_narrow))
+      &IR_Contained::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::Contained_ptr,
+            IR_Contained_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
+      &CORBA_IRObject::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            CORBA::IRObject_ptr,
+            CORBA_IRObject_ptr,
             this
           )
       );
@@ -46828,2382 +25065,624 @@
   return retv;
 }
 
-const char* IR::ConsumesDef::_interface_repository_id (void) const
-{
-  return "IDL:omg.org/IR/ConsumesDef:1.0";
-}
+const char* IR_EventDef::_interface_repository_id (void) const
+{
+  return "IDL:omg.org/IR/EventDef:1.0";
+}
+
+CORBA::Boolean IR_EventDef::is_a (
+    const char * event_id,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  return this->the_TAO_EventDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_a (
+      this,
+      event_id,
+      ACE_TRY_ENV
+    );
+}
+
+IR_ValueDef_ptr IR_EventDef::event (
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
+  
+  return this->the_TAO_EventDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).event (
+      this,
+      ACE_TRY_ENV
+    );
+}
+
+static const CORBA::Long _oc_IR_EventDef[] =
+{
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x76656e74), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/EventDef:1.0
+  9, ACE_NTOHL (0x4576656e), ACE_NTOHL (0x74446566), ACE_NTOHL (0x0),  // name = IR_EventDef
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_EventDef (CORBA::tk_objref, sizeof (_oc_IR_EventDef), (char *) &_oc_IR_EventDef, 0, sizeof (IR_EventDef));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EventDef, &_tc_TAO_tc_IR_EventDef)
+TAO_NAMESPACE_END
+
+static const CORBA::Long _oc_IR_EventDescription[] =
+{
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x76656e74), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/EventDescription:1.0
+  17, ACE_NTOHL (0x4576656e), ACE_NTOHL (0x74446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = EventDescription
+  5, // member count
+  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
+  CORBA::tk_alias, // typecode kind for typedefs
+  64, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
+    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
+    CORBA::tk_string, 
+    0U, // string length
+
+  3, ACE_NTOHL (0x69640000),  // name = id
+  CORBA::tk_alias, // typecode kind for typedefs
+  68, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+    CORBA::tk_string, 
+    0U, // string length
 
+  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
+  CORBA::tk_alias, // typecode kind for typedefs
+  68, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
+    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
+    CORBA::tk_string, 
+    0U, // string length
+
+  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
+  CORBA::tk_alias, // typecode kind for typedefs
+  64, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
+    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
+    CORBA::tk_string, 
+    0U, // string length
+
+  6, ACE_NTOHL (0x76616c75), ACE_NTOHL (0x65000000),  // name = value
+  CORBA::tk_objref, // typecode kind
+  52, // encapsulation length
+    TAO_ENCAP_BYTE_ORDER, // byte order
+    28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ValueDef:1.0
+    9, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = IR_ValueDef
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-#endif /* TAO_HAS_INTERCEPTORS */
-static const CORBA::Long _oc_IR_ConsumesDef[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7375), ACE_NTOHL (0x6d657344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ConsumesDef:1.0
-  12, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x756d6573), ACE_NTOHL (0x44656600),  // name = ConsumesDef
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_ConsumesDef (CORBA::tk_objref, sizeof (_oc_IR_ConsumesDef), (char *) &_oc_IR_ConsumesDef, 0, sizeof (IR::ConsumesDef));
+static CORBA::TypeCode _tc_TAO_tc_IR_EventDescription (CORBA::tk_struct, sizeof (_oc_IR_EventDescription), (char *) &_oc_IR_EventDescription, 0, sizeof (IR_EventDescription));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ConsumesDef, &_tc_TAO_tc_IR_ConsumesDef)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EventDescription, &_tc_TAO_tc_IR_EventDescription)
 TAO_NAMESPACE_END
 
+void IR_EventDescription::_tao_any_destructor (void *x)
+{
+  IR_EventDescription *tmp = ACE_static_cast (IR_EventDescription*,x);
+  delete tmp;
+}
+
+
 ///////////////////////////////////////////////////////////////////////
 //                Base & Remote Proxy  Implementation. 
 //
 
-IR::_TAO_ComponentDef_Proxy_Impl::_TAO_ComponentDef_Proxy_Impl (void)
+_TAO_EmitsDef_Proxy_Impl::_TAO_EmitsDef_Proxy_Impl (void)
 {}
 
-IR::_TAO_ComponentDef_Remote_Proxy_Impl::_TAO_ComponentDef_Remote_Proxy_Impl (void)
+_TAO_EmitsDef_Remote_Proxy_Impl::_TAO_EmitsDef_Remote_Proxy_Impl (void)
 {}
 
 // Remote Implementation of the IDL interface methods
 
-IR::InterfaceDefSeq * IR::_TAO_ComponentDef_Remote_Proxy_Impl::supported_interfaces (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  IR::InterfaceDefSeq *_tao_retval = 0;
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-  
-  ACE_NEW_RETURN (_tao_retval, IR::InterfaceDefSeq, _tao_retval);
-  IR::InterfaceDefSeq_var _tao_safe_retval (_tao_retval);
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_supported_interfaces",
-      25,
-      0,
-      istub->orb_core ()
-    );
+//
+//            End  Base & Remote  Proxy Implemeentation. 
+///////////////////////////////////////////////////////////////////////
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::InterfaceDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
-}
+///////////////////////////////////////////////////////////////////////
+//           Remote & Base  Proxy Broker Implementation
+//
 
-void IR::_TAO_ComponentDef_Remote_Proxy_Impl::supported_interfaces (
-    CORBA_Object *_collocated_tao_target_,
-    const IR::InterfaceDefSeq & supported_interfaces,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
+_TAO_EmitsDef_Proxy_Broker::_TAO_EmitsDef_Proxy_Broker (void)
 {
-  
-
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW (CORBA::INTERNAL ());
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_set_supported_interfaces",
-      25,
-      1,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        supported_interfaces,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK;
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK;
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << supported_interfaces)
-            ))
-            TAO_INTERCEPTOR_THROW (
-              CORBA::MARSHAL ()
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK;
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
-              );
-              
-            }
-          
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK;
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK;
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  
 }
 
-IR::ComponentDef_ptr IR::_TAO_ComponentDef_Remote_Proxy_Impl::base_component (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
+_TAO_EmitsDef_Proxy_Broker::~_TAO_EmitsDef_Proxy_Broker (void)
 {
-  
-  IR::ComponentDef_ptr _tao_retval = IR::ComponentDef::_nil ();
-  IR::ComponentDef_var _tao_safe_retval (_tao_retval);
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_base_component",
-      19,
-      0,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_base_component_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::ComponentDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
 }
 
-IR::ProvidesDefSeq * IR::_TAO_ComponentDef_Remote_Proxy_Impl::provides_interfaces (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
+// Factory function Implementation.
+_TAO_EmitsDef_Remote_Proxy_Broker *the_TAO_EmitsDef_Remote_Proxy_Broker (void)
 {
-  
-  IR::ProvidesDefSeq *_tao_retval = 0;
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+  static ::_TAO_EmitsDef_Remote_Proxy_Broker remote_proxy_broker;
+  return &remote_proxy_broker;
+}
 
-  
-  ACE_NEW_RETURN (_tao_retval, IR::ProvidesDefSeq, _tao_retval);
-  IR::ProvidesDefSeq_var _tao_safe_retval (_tao_retval);
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_provides_interfaces",
-      24,
-      0,
-      istub->orb_core ()
-    );
+_TAO_EmitsDef_Remote_Proxy_Broker::_TAO_EmitsDef_Remote_Proxy_Broker (void)
+{
+}
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::ProvidesDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+_TAO_EmitsDef_Remote_Proxy_Broker::~_TAO_EmitsDef_Remote_Proxy_Broker (void)
+{
+}
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
+_TAO_EmitsDef_Proxy_Impl&
+_TAO_EmitsDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_EmitsDef *object,
+  CORBA::Environment &ACE_TRY_ENV
+)
+{
+  ACE_UNUSED_ARG (object);
+  ACE_UNUSED_ARG (ACE_TRY_ENV);
+  return remote_proxy_impl_;
 }
 
-IR::UsesDefSeq * IR::_TAO_ComponentDef_Remote_Proxy_Impl::uses_interfaces (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
+
+//
+//           End Remote & Base Proxy Broker Implementation
+///////////////////////////////////////////////////////////////////////
+
+
+// default constructor
+IR_EmitsDef::IR_EmitsDef (int collocated)
 {
-  
-  IR::UsesDefSeq *_tao_retval = 0;
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+  this->_tao_setup_collocation (collocated);
+}
 
-  
-  ACE_NEW_RETURN (_tao_retval, IR::UsesDefSeq, _tao_retval);
-  IR::UsesDefSeq_var _tao_safe_retval (_tao_retval);
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_uses_interfaces",
-      20,
-      0,
-      istub->orb_core ()
-    );
+// destructor
+IR_EmitsDef::~IR_EmitsDef (void)
+{}
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
+void
+IR_EmitsDef::_tao_setup_collocation (int collocated)
+{
+  if (collocated)
+    this->the_TAO_EmitsDef_Proxy_Broker_ =
+      _TAO_EmitsDef_Proxy_Broker_Factory_function_pointer (this);
+  else
+    this->the_TAO_EmitsDef_Proxy_Broker_ =
+      ::the_TAO_EmitsDef_Remote_Proxy_Broker ();
   
-#endif  /* TAO_HAS_INTERCEPTORS */
+  IR_EventDef::_tao_setup_collocation (collocated);
   
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::UsesDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+}
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
+void IR_EmitsDef::_tao_any_destructor (void *x)
+{
+  IR_EmitsDef *tmp = ACE_static_cast (IR_EmitsDef*,x);
+  CORBA::release (tmp);
 }
 
-IR::EmitsDefSeq * IR::_TAO_ComponentDef_Remote_Proxy_Impl::emits_events (
-    CORBA_Object *_collocated_tao_target_,
+IR_EmitsDef_ptr IR_EmitsDef::_narrow (
+    CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
 {
-  
-  IR::EmitsDefSeq *_tao_retval = 0;
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
-  
-  ACE_NEW_RETURN (_tao_retval, IR::EmitsDefSeq, _tao_retval);
-  IR::EmitsDefSeq_var _tao_safe_retval (_tao_retval);
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_emits_events",
-      17,
-      0,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
+  if (CORBA::is_nil (obj))
+    return IR_EmitsDef::_nil ();
+  if (! obj->_is_local ())
     {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::EmitsDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/EmitsDef:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (IR_EmitsDef::_nil ());
+      if (is_a == 0)
+        return IR_EmitsDef::_nil ();
     }
-  return _tao_safe_retval._retn ();
+  return IR_EmitsDef::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::PublishesDefSeq * IR::_TAO_ComponentDef_Remote_Proxy_Impl::publishes_events (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
+IR_EmitsDef_ptr IR_EmitsDef::_unchecked_narrow (
+    CORBA::Object_ptr obj,
+    CORBA::Environment &
   )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
 {
-  
-  IR::PublishesDefSeq *_tao_retval = 0;
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
-  
-  ACE_NEW_RETURN (_tao_retval, IR::PublishesDefSeq, _tao_retval);
-  IR::PublishesDefSeq_var _tao_safe_retval (_tao_retval);
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_publishes_events",
-      21,
-      0,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
+  if (CORBA::is_nil (obj))
+    return IR_EmitsDef::_nil ();
+  if (! obj->_is_local ())
     {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::PublishesDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
+      TAO_Stub* stub = obj->_stubobj ();
+      if (stub)
+        stub->_incr_refcnt ();
+      IR_EmitsDef_ptr default_proxy = IR_EmitsDef::_nil ();
+
+      if (
+          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
+          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
+          obj->_is_collocated () &&_TAO_EmitsDef_Proxy_Broker_Factory_function_pointer != 0
+        )
+      {
+        ACE_NEW_RETURN (
+          default_proxy,
+          ::IR_EmitsDef (
+            stub,
+            1,
+            obj->_servant ()),
             
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
+          IR_EmitsDef::_nil ());
         }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
+      if (CORBA::is_nil (default_proxy))
+        ACE_NEW_RETURN (default_proxy, ::IR_EmitsDef (stub, 0, obj->_servant ()), IR_EmitsDef::_nil ());
+        return default_proxy;
+      }
+    else 
+      return
+        ACE_reinterpret_cast
+          (
+            IR_EmitsDef_ptr,
+              obj->_tao_QueryInterface
+                (
+                  ACE_reinterpret_cast
+                    (
+                      ptr_arith_t,
+                      &IR_EmitsDef::_narrow
+                    )
+                )
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
 }
 
-IR::ConsumesDefSeq * IR::_TAO_ComponentDef_Remote_Proxy_Impl::consumes_events (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
+IR_EmitsDef_ptr
+IR_EmitsDef::_duplicate (IR_EmitsDef_ptr obj)
 {
-  
-  IR::ConsumesDefSeq *_tao_retval = 0;
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+  if (!CORBA::is_nil (obj))
+    obj->_add_ref ();
+  return obj;
+}
 
-  
-  ACE_NEW_RETURN (_tao_retval, IR::ConsumesDefSeq, _tao_retval);
-  IR::ConsumesDefSeq_var _tao_safe_retval (_tao_retval);
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_consumes_events",
-      20,
-      0,
-      istub->orb_core ()
-    );
+CORBA::Boolean IR_EmitsDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+{
+  if (
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EmitsDef:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
+  return 1; // success using local knowledge
+  else
+    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
+}
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::ConsumesDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+void *IR_EmitsDef::_tao_QueryInterface (ptr_arith_t type)
+{
+  void *retv = 0;
+  if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_EmitsDef::_narrow))
+    retv = ACE_reinterpret_cast (void*, this);
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_EventDef::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            IR_EventDef_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_Contained::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            IR_Contained_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &CORBA_IRObject::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            CORBA_IRObject_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
+    retv = ACE_reinterpret_cast (void *,
+      ACE_static_cast (CORBA::Object_ptr, this));
+    
+  if (retv)
+    this->_add_ref ();
+  return retv;
+}
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
+const char* IR_EmitsDef::_interface_repository_id (void) const
+{
+  return "IDL:omg.org/IR/EmitsDef:1.0";
 }
 
-CORBA::Boolean IR::_TAO_ComponentDef_Remote_Proxy_Impl::is_basic (
-    CORBA_Object *_collocated_tao_target_,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
+static const CORBA::Long _oc_IR_EmitsDef[] =
 {
-  
-  CORBA::Boolean _tao_retval = 0;
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x6d697473), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/EmitsDef:1.0
+  9, ACE_NTOHL (0x456d6974), ACE_NTOHL (0x73446566), ACE_NTOHL (0x0),  // name = IR_EmitsDef
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_EmitsDef (CORBA::tk_objref, sizeof (_oc_IR_EmitsDef), (char *) &_oc_IR_EmitsDef, 0, sizeof (IR_EmitsDef));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EmitsDef, &_tc_TAO_tc_IR_EmitsDef)
+TAO_NAMESPACE_END
 
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "_get_is_basic",
-      13,
-      0,
-      istub->orb_core ()
-    );
+///////////////////////////////////////////////////////////////////////
+//                Base & Remote Proxy  Implementation. 
+//
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              CORBA::Boolean  _tao_retval_info = _tao_retval;
-               ri.result (_tao_retval_info);
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+_TAO_PublishesDef_Proxy_Impl::_TAO_PublishesDef_Proxy_Impl (void)
+{}
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_retval;
-}
+_TAO_PublishesDef_Remote_Proxy_Impl::_TAO_PublishesDef_Remote_Proxy_Impl (void)
+{}
 
-IR::ProvidesDef_ptr IR::_TAO_ComponentDef_Remote_Proxy_Impl::create_provides (
-    CORBA_Object *_collocated_tao_target_,
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::InterfaceDef_ptr interface_type,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  IR::ProvidesDef_ptr _tao_retval = IR::ProvidesDef::_nil ();
-  IR::ProvidesDef_var _tao_safe_retval (_tao_retval);
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+// Remote Implementation of the IDL interface methods
 
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "create_provides",
-      15,
-      1,
-      istub->orb_core ()
-    );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_provides ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        id,
-        name,
-        version,
-        interface_type,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << id) &&
-              (_tao_out << name) &&
-              (_tao_out << version) &&
-              (_tao_out << interface_type)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
-              0
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::ProvidesDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+//
+//            End  Base & Remote  Proxy Implemeentation. 
+///////////////////////////////////////////////////////////////////////
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
+
+///////////////////////////////////////////////////////////////////////
+//           Remote & Base  Proxy Broker Implementation
+//
+
+_TAO_PublishesDef_Proxy_Broker::_TAO_PublishesDef_Proxy_Broker (void)
+{
 }
 
-IR::UsesDef_ptr IR::_TAO_ComponentDef_Remote_Proxy_Impl::create_uses (
-    CORBA_Object *_collocated_tao_target_,
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::InterfaceDef_ptr interface_type,
-    CORBA::Boolean is_multiple,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
+_TAO_PublishesDef_Proxy_Broker::~_TAO_PublishesDef_Proxy_Broker (void)
 {
-  
-  IR::UsesDef_ptr _tao_retval = IR::UsesDef::_nil ();
-  IR::UsesDef_var _tao_safe_retval (_tao_retval);
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+}
 
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "create_uses",
-      11,
-      1,
-      istub->orb_core ()
-    );
+// Factory function Implementation.
+_TAO_PublishesDef_Remote_Proxy_Broker *the_TAO_PublishesDef_Remote_Proxy_Broker (void)
+{
+  static ::_TAO_PublishesDef_Remote_Proxy_Broker remote_proxy_broker;
+  return &remote_proxy_broker;
+}
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_uses ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        id,
-        name,
-        version,
-        interface_type,
-        is_multiple,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << id) &&
-              (_tao_out << name) &&
-              (_tao_out << version) &&
-              (_tao_out << interface_type) &&
-              (_tao_out << CORBA::Any::from_boolean (is_multiple))
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
-              0
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::UsesDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+_TAO_PublishesDef_Remote_Proxy_Broker::_TAO_PublishesDef_Remote_Proxy_Broker (void)
+{
+}
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
+_TAO_PublishesDef_Remote_Proxy_Broker::~_TAO_PublishesDef_Remote_Proxy_Broker (void)
+{
 }
 
-IR::EmitsDef_ptr IR::_TAO_ComponentDef_Remote_Proxy_Impl::create_emits (
-    CORBA_Object *_collocated_tao_target_,
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::ValueDef_ptr value,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
+_TAO_PublishesDef_Proxy_Impl&
+_TAO_PublishesDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_PublishesDef *object,
+  CORBA::Environment &ACE_TRY_ENV
+)
 {
-  
-  IR::EmitsDef_ptr _tao_retval = IR::EmitsDef::_nil ();
-  IR::EmitsDef_var _tao_safe_retval (_tao_retval);
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+  ACE_UNUSED_ARG (object);
+  ACE_UNUSED_ARG (ACE_TRY_ENV);
+  return remote_proxy_impl_;
+}
+
+
+//
+//           End Remote & Base Proxy Broker Implementation
+///////////////////////////////////////////////////////////////////////
+
 
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "create_emits",
-      12,
-      1,
-      istub->orb_core ()
-    );
+// default constructor
+IR_PublishesDef::IR_PublishesDef (int collocated)
+{
+  this->_tao_setup_collocation (collocated);
+}
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
+// destructor
+IR_PublishesDef::~IR_PublishesDef (void)
+{}
+
+void
+IR_PublishesDef::_tao_setup_collocation (int collocated)
+{
+  if (collocated)
+    this->the_TAO_PublishesDef_Proxy_Broker_ =
+      _TAO_PublishesDef_Proxy_Broker_Factory_function_pointer (this);
+  else
+    this->the_TAO_PublishesDef_Proxy_Broker_ =
+      ::the_TAO_PublishesDef_Remote_Proxy_Broker ();
   
-#endif  /* TAO_HAS_INTERCEPTORS */
+  IR_EventDef::_tao_setup_collocation (collocated);
   
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_emits ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        id,
-        name,
-        version,
-        value,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << id) &&
-              (_tao_out << name) &&
-              (_tao_out << version) &&
-              (_tao_out << value)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
-              0
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::EmitsDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+}
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
+void IR_PublishesDef::_tao_any_destructor (void *x)
+{
+  IR_PublishesDef *tmp = ACE_static_cast (IR_PublishesDef*,x);
+  CORBA::release (tmp);
 }
 
-IR::PublishesDef_ptr IR::_TAO_ComponentDef_Remote_Proxy_Impl::create_publishes (
-    CORBA_Object *_collocated_tao_target_,
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::ValueDef_ptr value,
+IR_PublishesDef_ptr IR_PublishesDef::_narrow (
+    CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
 {
-  
-  IR::PublishesDef_ptr _tao_retval = IR::PublishesDef::_nil ();
-  IR::PublishesDef_var _tao_safe_retval (_tao_retval);
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "create_publishes",
-      16,
-      1,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
+  if (CORBA::is_nil (obj))
+    return IR_PublishesDef::_nil ();
+  if (! obj->_is_local ())
     {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_publishes ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        id,
-        name,
-        version,
-        value,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << id) &&
-              (_tao_out << name) &&
-              (_tao_out << version) &&
-              (_tao_out << value)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
-              0
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::PublishesDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/PublishesDef:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (IR_PublishesDef::_nil ());
+      if (is_a == 0)
+        return IR_PublishesDef::_nil ();
     }
-  return _tao_safe_retval._retn ();
+  return IR_PublishesDef::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::ConsumesDef_ptr IR::_TAO_ComponentDef_Remote_Proxy_Impl::create_consumes (
-    CORBA_Object *_collocated_tao_target_,
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::ValueDef_ptr value,
-    CORBA::Environment &ACE_TRY_ENV
+IR_PublishesDef_ptr IR_PublishesDef::_unchecked_narrow (
+    CORBA::Object_ptr obj,
+    CORBA::Environment &
   )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
 {
-  
-  IR::ConsumesDef_ptr _tao_retval = IR::ConsumesDef::_nil ();
-  IR::ConsumesDef_var _tao_safe_retval (_tao_retval);
-  
-  
-  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "create_consumes",
-      15,
-      1,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
+  if (CORBA::is_nil (obj))
+    return IR_PublishesDef::_nil ();
+  if (! obj->_is_local ())
     {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_consumes ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        id,
-        name,
-        version,
-        value,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << id) &&
-              (_tao_out << name) &&
-              (_tao_out << version) &&
-              (_tao_out << value)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
-              0
-            );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::ConsumesDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
+      TAO_Stub* stub = obj->_stubobj ();
+      if (stub)
+        stub->_incr_refcnt ();
+      IR_PublishesDef_ptr default_proxy = IR_PublishesDef::_nil ();
+
+      if (
+          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
+          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
+          obj->_is_collocated () &&_TAO_PublishesDef_Proxy_Broker_Factory_function_pointer != 0
+        )
+      {
+        ACE_NEW_RETURN (
+          default_proxy,
+          ::IR_PublishesDef (
+            stub,
+            1,
+            obj->_servant ()),
             
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
+          IR_PublishesDef::_nil ());
         }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
+      if (CORBA::is_nil (default_proxy))
+        ACE_NEW_RETURN (default_proxy, ::IR_PublishesDef (stub, 0, obj->_servant ()), IR_PublishesDef::_nil ());
+        return default_proxy;
+      }
+    else 
+      return
+        ACE_reinterpret_cast
+          (
+            IR_PublishesDef_ptr,
+              obj->_tao_QueryInterface
+                (
+                  ACE_reinterpret_cast
+                    (
+                      ptr_arith_t,
+                      &IR_PublishesDef::_narrow
+                    )
+                )
           );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+}
+
+IR_PublishesDef_ptr
+IR_PublishesDef::_duplicate (IR_PublishesDef_ptr obj)
+{
+  if (!CORBA::is_nil (obj))
+    obj->_add_ref ();
+  return obj;
+}
+
+CORBA::Boolean IR_PublishesDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+{
+  if (
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/PublishesDef:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
+  return 1; // success using local knowledge
+  else
+    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
+}
+
+void *IR_PublishesDef::_tao_QueryInterface (ptr_arith_t type)
+{
+  void *retv = 0;
+  if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_PublishesDef::_narrow))
+    retv = ACE_reinterpret_cast (void*, this);
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_EventDef::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            IR_EventDef_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_Contained::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            IR_Contained_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &CORBA_IRObject::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            CORBA_IRObject_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
+    retv = ACE_reinterpret_cast (void *,
+      ACE_static_cast (CORBA::Object_ptr, this));
+    
+  if (retv)
+    this->_add_ref ();
+  return retv;
+}
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
-  return _tao_safe_retval._retn ();
+const char* IR_PublishesDef::_interface_repository_id (void) const
+{
+  return "IDL:omg.org/IR/PublishesDef:1.0";
 }
 
+static const CORBA::Long _oc_IR_PublishesDef[] =
+{
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x75626c69), ACE_NTOHL (0x73686573), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/PublishesDef:1.0
+  13, ACE_NTOHL (0x5075626c), ACE_NTOHL (0x69736865), ACE_NTOHL (0x73446566), ACE_NTOHL (0x0),  // name = IR_PublishesDef
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_PublishesDef (CORBA::tk_objref, sizeof (_oc_IR_PublishesDef), (char *) &_oc_IR_PublishesDef, 0, sizeof (IR_PublishesDef));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PublishesDef, &_tc_TAO_tc_IR_PublishesDef)
+TAO_NAMESPACE_END
+
+///////////////////////////////////////////////////////////////////////
+//                Base & Remote Proxy  Implementation. 
+//
+
+_TAO_ConsumesDef_Proxy_Impl::_TAO_ConsumesDef_Proxy_Impl (void)
+{}
+
+_TAO_ConsumesDef_Remote_Proxy_Impl::_TAO_ConsumesDef_Remote_Proxy_Impl (void)
+{}
+
+// Remote Implementation of the IDL interface methods
+
 
 //
 //            End  Base & Remote  Proxy Implemeentation. 
@@ -49214,32 +25693,32 @@
 //           Remote & Base  Proxy Broker Implementation
 //
 
-IR::_TAO_ComponentDef_Proxy_Broker::_TAO_ComponentDef_Proxy_Broker (void)
+_TAO_ConsumesDef_Proxy_Broker::_TAO_ConsumesDef_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_ComponentDef_Proxy_Broker::~_TAO_ComponentDef_Proxy_Broker (void)
+_TAO_ConsumesDef_Proxy_Broker::~_TAO_ConsumesDef_Proxy_Broker (void)
 {
 }
 
-// Factory Member function Implementation.
-IR::_TAO_ComponentDef_Remote_Proxy_Broker *IR::_TAO_ComponentDef_Remote_Proxy_Broker::the_TAO_ComponentDef_Remote_Proxy_Broker (void)
+// Factory function Implementation.
+_TAO_ConsumesDef_Remote_Proxy_Broker *the_TAO_ConsumesDef_Remote_Proxy_Broker (void)
 {
-  static ::IR::_TAO_ComponentDef_Remote_Proxy_Broker remote_proxy_broker;
+  static ::_TAO_ConsumesDef_Remote_Proxy_Broker remote_proxy_broker;
   return &remote_proxy_broker;
 }
 
-IR::_TAO_ComponentDef_Remote_Proxy_Broker::_TAO_ComponentDef_Remote_Proxy_Broker (void)
+_TAO_ConsumesDef_Remote_Proxy_Broker::_TAO_ConsumesDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_ComponentDef_Remote_Proxy_Broker::~_TAO_ComponentDef_Remote_Proxy_Broker (void)
+_TAO_ConsumesDef_Remote_Proxy_Broker::~_TAO_ConsumesDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_ComponentDef_Proxy_Impl&
-IR::_TAO_ComponentDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::ComponentDef *object,
+_TAO_ConsumesDef_Proxy_Impl&
+_TAO_ConsumesDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_ConsumesDef *object,
   CORBA::Environment &ACE_TRY_ENV
 )
 {
@@ -49255,116 +25734,115 @@
 
 
 // default constructor
-IR::ComponentDef::ComponentDef (int collocated)
+IR_ConsumesDef::IR_ConsumesDef (int collocated)
 {
   this->_tao_setup_collocation (collocated);
 }
 
 // destructor
-IR::ComponentDef::~ComponentDef (void)
+IR_ConsumesDef::~IR_ConsumesDef (void)
 {}
 
 void
-IR::ComponentDef::_tao_setup_collocation (int collocated)
+IR_ConsumesDef::_tao_setup_collocation (int collocated)
 {
   if (collocated)
-    this->the_TAO_ComponentDef_Proxy_Broker_ =
-      ::IR__TAO_ComponentDef_Proxy_Broker_Factory_function_pointer (this);
+    this->the_TAO_ConsumesDef_Proxy_Broker_ =
+      _TAO_ConsumesDef_Proxy_Broker_Factory_function_pointer (this);
   else
-    this->the_TAO_ComponentDef_Proxy_Broker_ =
-      ::IR::_TAO_ComponentDef_Remote_Proxy_Broker::the_TAO_ComponentDef_Remote_Proxy_Broker ();
+    this->the_TAO_ConsumesDef_Proxy_Broker_ =
+      ::the_TAO_ConsumesDef_Remote_Proxy_Broker ();
+  
+  IR_EventDef::_tao_setup_collocation (collocated);
   
-  ACE_NESTED_CLASS (IR, InterfaceDef)::_tao_setup_collocation (collocated);
 }
 
-void IR::ComponentDef::_tao_any_destructor (void *x)
+void IR_ConsumesDef::_tao_any_destructor (void *x)
 {
-  ComponentDef *tmp = ACE_static_cast (ComponentDef*,x);
+  IR_ConsumesDef *tmp = ACE_static_cast (IR_ConsumesDef*,x);
   CORBA::release (tmp);
 }
 
-IR::ComponentDef_ptr IR::ComponentDef::_narrow (
+IR_ConsumesDef_ptr IR_ConsumesDef::_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
 {
   if (CORBA::is_nil (obj))
-    return ComponentDef::_nil ();
+    return IR_ConsumesDef::_nil ();
   if (! obj->_is_local ())
     {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ComponentDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (ComponentDef::_nil ());
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ConsumesDef:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (IR_ConsumesDef::_nil ());
       if (is_a == 0)
-        return ComponentDef::_nil ();
+        return IR_ConsumesDef::_nil ();
     }
-  return ComponentDef::_unchecked_narrow (obj, ACE_TRY_ENV);
+  return IR_ConsumesDef::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::ComponentDef_ptr IR::ComponentDef::_unchecked_narrow (
+IR_ConsumesDef_ptr IR_ConsumesDef::_unchecked_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &
   )
 {
   if (CORBA::is_nil (obj))
-    return ComponentDef::_nil ();
+    return IR_ConsumesDef::_nil ();
   if (! obj->_is_local ())
     {
       TAO_Stub* stub = obj->_stubobj ();
       if (stub)
         stub->_incr_refcnt ();
-      ComponentDef_ptr default_proxy = ComponentDef::_nil ();
+      IR_ConsumesDef_ptr default_proxy = IR_ConsumesDef::_nil ();
 
       if (
           !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
           stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_ComponentDef_Proxy_Broker_Factory_function_pointer != 0
+          obj->_is_collocated () &&_TAO_ConsumesDef_Proxy_Broker_Factory_function_pointer != 0
         )
       {
         ACE_NEW_RETURN (
           default_proxy,
-          ::IR::ComponentDef (
+          ::IR_ConsumesDef (
             stub,
             1,
             obj->_servant ()),
             
-          ComponentDef::_nil ());
+          IR_ConsumesDef::_nil ());
         }
       if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::ComponentDef (stub, 0, obj->_servant ()), ComponentDef::_nil ());
+        ACE_NEW_RETURN (default_proxy, ::IR_ConsumesDef (stub, 0, obj->_servant ()), IR_ConsumesDef::_nil ());
         return default_proxy;
       }
     else 
       return
         ACE_reinterpret_cast
           (
-            ComponentDef_ptr,
+            IR_ConsumesDef_ptr,
               obj->_tao_QueryInterface
                 (
                   ACE_reinterpret_cast
                     (
                       ptr_arith_t,
-                      &ComponentDef::_narrow
+                      &IR_ConsumesDef::_narrow
                     )
                 )
           );
 }
 
-IR::ComponentDef_ptr
-IR::ComponentDef::_duplicate (ComponentDef_ptr obj)
+IR_ConsumesDef_ptr
+IR_ConsumesDef::_duplicate (IR_ConsumesDef_ptr obj)
 {
   if (!CORBA::is_nil (obj))
     obj->_add_ref ();
   return obj;
 }
 
-CORBA::Boolean IR::ComponentDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+CORBA::Boolean IR_ConsumesDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
   if (
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ComponentDef:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/InterfaceDef:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ConsumesDef:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
   return 1; // success using local knowledge
@@ -49372,70 +25850,46 @@
     return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
 }
 
-void *IR::ComponentDef::_tao_QueryInterface (ptr_arith_t type)
+void *IR_ConsumesDef::_tao_QueryInterface (ptr_arith_t type)
 {
   void *retv = 0;
   if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, ComponentDef)::_narrow))
+      &IR_ConsumesDef::_narrow))
     retv = ACE_reinterpret_cast (void*, this);
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, InterfaceDef)::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            IR::InterfaceDef_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Container)::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            IR::Container_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Contained)::_narrow))
+      &IR_EventDef::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::Contained_ptr,
+            IR_EventDef_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, IDLType)::_narrow))
+      &IR_Contained::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::IDLType_ptr,
+            IR_Contained_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
+      &CORBA_IRObject::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            CORBA::IRObject_ptr,
+            CORBA_IRObject_ptr,
             this
           )
       );
@@ -49448,12 +25902,37 @@
   return retv;
 }
 
-const char* IR::ComponentDef::_interface_repository_id (void) const
+const char* IR_ConsumesDef::_interface_repository_id (void) const
 {
-  return "IDL:omg.org/IR/ComponentDef:1.0";
+  return "IDL:omg.org/IR/ConsumesDef:1.0";
 }
 
-IR::InterfaceDefSeq * IR::ComponentDef::supported_interfaces (
+static const CORBA::Long _oc_IR_ConsumesDef[] =
+{
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7375), ACE_NTOHL (0x6d657344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ConsumesDef:1.0
+  12, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x756d6573), ACE_NTOHL (0x44656600),  // name = IR_ConsumesDef
+};
+static CORBA::TypeCode _tc_TAO_tc_IR_ConsumesDef (CORBA::tk_objref, sizeof (_oc_IR_ConsumesDef), (char *) &_oc_IR_ConsumesDef, 0, sizeof (IR_ConsumesDef));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (IR)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ConsumesDef, &_tc_TAO_tc_IR_ConsumesDef)
+TAO_NAMESPACE_END
+
+///////////////////////////////////////////////////////////////////////
+//                Base & Remote Proxy  Implementation. 
+//
+
+_TAO_ComponentDef_Proxy_Impl::_TAO_ComponentDef_Proxy_Impl (void)
+{}
+
+_TAO_ComponentDef_Remote_Proxy_Impl::_TAO_ComponentDef_Remote_Proxy_Impl (void)
+{}
+
+// Remote Implementation of the IDL interface methods
+
+IR_InterfaceDefSeq * _TAO_ComponentDef_Remote_Proxy_Impl::supported_interfaces (
+    CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -49461,29 +25940,133 @@
   ))
 {
   
-  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).supported_interfaces (
-      this,
-      ACE_TRY_ENV
+  IR_InterfaceDefSeq *_tao_retval = 0;
+  
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+
+  
+  ACE_NEW_RETURN (_tao_retval, IR_InterfaceDefSeq, _tao_retval);
+  IR_InterfaceDefSeq_var _tao_safe_retval (_tao_retval);
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_supported_interfaces",
+      25,
+      0,
+      istub->orb_core ()
     );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
+
+  return _tao_safe_retval._retn ();
 }
 
-void IR::ComponentDef::supported_interfaces (
-    const IR::InterfaceDefSeq & supported_interfaces,
+void _TAO_ComponentDef_Remote_Proxy_Impl::supported_interfaces (
+    CORBA_Object *_collocated_tao_target_,
+    const IR_InterfaceDefSeq & supported_interfaces,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
     CORBA::SystemException
   ))
 {
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW (CORBA::INTERNAL ());
+
   
-  this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).supported_interfaces (
-      this,
-      supported_interfaces,
-      ACE_TRY_ENV
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_set_supported_interfaces",
+      25,
+      1,
+      istub->orb_core ()
     );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK;
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << supported_interfaces)
+          ))
+        ACE_THROW (
+            CORBA::MARSHAL ()
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
+            );
+        }
+        
+        break;
+      }
 }
 
-IR::ComponentDef_ptr IR::ComponentDef::base_component (
+IR_ComponentDef_ptr _TAO_ComponentDef_Remote_Proxy_Impl::base_component (
+    CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -49491,13 +26074,69 @@
   ))
 {
   
-  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).base_component (
-      this,
-      ACE_TRY_ENV
+  IR_ComponentDef_ptr _tao_retval = IR_ComponentDef::_nil ();
+  IR_ComponentDef_var _tao_safe_retval (_tao_retval);
+  
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_base_component",
+      19,
+      0,
+      istub->orb_core ()
     );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
+
+  return _tao_safe_retval._retn ();
 }
 
-IR::ProvidesDefSeq * IR::ComponentDef::provides_interfaces (
+IR_ProvidesDefSeq * _TAO_ComponentDef_Remote_Proxy_Impl::provides_interfaces (
+    CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -49505,13 +26144,70 @@
   ))
 {
   
-  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).provides_interfaces (
-      this,
-      ACE_TRY_ENV
+  IR_ProvidesDefSeq *_tao_retval = 0;
+  
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+
+  
+  ACE_NEW_RETURN (_tao_retval, IR_ProvidesDefSeq, _tao_retval);
+  IR_ProvidesDefSeq_var _tao_safe_retval (_tao_retval);
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_provides_interfaces",
+      24,
+      0,
+      istub->orb_core ()
     );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
+
+  return _tao_safe_retval._retn ();
 }
 
-IR::UsesDefSeq * IR::ComponentDef::uses_interfaces (
+IR_UsesDefSeq * _TAO_ComponentDef_Remote_Proxy_Impl::uses_interfaces (
+    CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -49519,13 +26215,70 @@
   ))
 {
   
-  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).uses_interfaces (
-      this,
-      ACE_TRY_ENV
+  IR_UsesDefSeq *_tao_retval = 0;
+  
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+
+  
+  ACE_NEW_RETURN (_tao_retval, IR_UsesDefSeq, _tao_retval);
+  IR_UsesDefSeq_var _tao_safe_retval (_tao_retval);
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_uses_interfaces",
+      20,
+      0,
+      istub->orb_core ()
     );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
+
+  return _tao_safe_retval._retn ();
 }
 
-IR::EmitsDefSeq * IR::ComponentDef::emits_events (
+IR_EmitsDefSeq * _TAO_ComponentDef_Remote_Proxy_Impl::emits_events (
+    CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -49533,13 +26286,70 @@
   ))
 {
   
-  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).emits_events (
-      this,
-      ACE_TRY_ENV
+  IR_EmitsDefSeq *_tao_retval = 0;
+  
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+
+  
+  ACE_NEW_RETURN (_tao_retval, IR_EmitsDefSeq, _tao_retval);
+  IR_EmitsDefSeq_var _tao_safe_retval (_tao_retval);
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_emits_events",
+      17,
+      0,
+      istub->orb_core ()
     );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
+
+  return _tao_safe_retval._retn ();
 }
 
-IR::PublishesDefSeq * IR::ComponentDef::publishes_events (
+IR_PublishesDefSeq * _TAO_ComponentDef_Remote_Proxy_Impl::publishes_events (
+    CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -49547,13 +26357,70 @@
   ))
 {
   
-  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).publishes_events (
-      this,
-      ACE_TRY_ENV
+  IR_PublishesDefSeq *_tao_retval = 0;
+  
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+
+  
+  ACE_NEW_RETURN (_tao_retval, IR_PublishesDefSeq, _tao_retval);
+  IR_PublishesDefSeq_var _tao_safe_retval (_tao_retval);
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_publishes_events",
+      21,
+      0,
+      istub->orb_core ()
     );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
+
+  return _tao_safe_retval._retn ();
 }
 
-IR::ConsumesDefSeq * IR::ComponentDef::consumes_events (
+IR_ConsumesDefSeq * _TAO_ComponentDef_Remote_Proxy_Impl::consumes_events (
+    CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -49561,13 +26428,70 @@
   ))
 {
   
-  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).consumes_events (
-      this,
-      ACE_TRY_ENV
+  IR_ConsumesDefSeq *_tao_retval = 0;
+  
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+
+  
+  ACE_NEW_RETURN (_tao_retval, IR_ConsumesDefSeq, _tao_retval);
+  IR_ConsumesDefSeq_var _tao_safe_retval (_tao_retval);
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_consumes_events",
+      20,
+      0,
+      istub->orb_core ()
     );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
+
+  return _tao_safe_retval._retn ();
 }
 
-CORBA::Boolean IR::ComponentDef::is_basic (
+CORBA::Boolean _TAO_ComponentDef_Remote_Proxy_Impl::is_basic (
+    CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -49575,17 +26499,72 @@
   ))
 {
   
-  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_basic (
-      this,
-      ACE_TRY_ENV
+  CORBA::Boolean _tao_retval = 0;
+  
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
+
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "_get_is_basic",
+      13,
+      0,
+      istub->orb_core ()
     );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN  (_tao_retval);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              _tao_retval
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                _tao_retval
+              );
+          }
+        break;
+      }
+
+  return _tao_retval;
 }
 
-IR::ProvidesDef_ptr IR::ComponentDef::create_provides (
+IR_ProvidesDef_ptr _TAO_ComponentDef_Remote_Proxy_Impl::create_provides (
+    CORBA_Object *_collocated_tao_target_,
     const char * id,
     const char * name,
     const char * version,
-    IR::InterfaceDef_ptr interface_type,
+    IR_InterfaceDef_ptr interface_type,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -49593,21 +26572,86 @@
   ))
 {
   
-  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_provides (
-      this,
-      id,
-      name,
-      version,
-      interface_type,
-      ACE_TRY_ENV
+  IR_ProvidesDef_ptr _tao_retval = IR_ProvidesDef::_nil ();
+  IR_ProvidesDef_var _tao_safe_retval (_tao_retval);
+  
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "create_provides",
+      15,
+      1,
+      istub->orb_core ()
     );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << id) &&
+              (_tao_out << name) &&
+              (_tao_out << version) &&
+              (_tao_out << interface_type)
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
+
+  return _tao_safe_retval._retn ();
 }
 
-IR::UsesDef_ptr IR::ComponentDef::create_uses (
+IR_UsesDef_ptr _TAO_ComponentDef_Remote_Proxy_Impl::create_uses (
+    CORBA_Object *_collocated_tao_target_,
     const char * id,
     const char * name,
     const char * version,
-    IR::InterfaceDef_ptr interface_type,
+    IR_InterfaceDef_ptr interface_type,
     CORBA::Boolean is_multiple,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -49616,44 +26660,87 @@
   ))
 {
   
-  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_uses (
-      this,
-      id,
-      name,
-      version,
-      interface_type,
-      is_multiple,
-      ACE_TRY_ENV
-    );
-}
+  IR_UsesDef_ptr _tao_retval = IR_UsesDef::_nil ();
+  IR_UsesDef_var _tao_safe_retval (_tao_retval);
+  
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-IR::EmitsDef_ptr IR::ComponentDef::create_emits (
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::ValueDef_ptr value,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
   
-  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_emits (
-      this,
-      id,
-      name,
-      version,
-      value,
-      ACE_TRY_ENV
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "create_uses",
+      11,
+      1,
+      istub->orb_core ()
     );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << id) &&
+              (_tao_out << name) &&
+              (_tao_out << version) &&
+              (_tao_out << interface_type) &&
+              (_tao_out << CORBA::Any::from_boolean (is_multiple))
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
+
+  return _tao_safe_retval._retn ();
 }
 
-IR::PublishesDef_ptr IR::ComponentDef::create_publishes (
+IR_EmitsDef_ptr _TAO_ComponentDef_Remote_Proxy_Impl::create_emits (
+    CORBA_Object *_collocated_tao_target_,
     const char * id,
     const char * name,
     const char * version,
-    IR::ValueDef_ptr value,
+    IR_ValueDef_ptr value,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -49661,21 +26748,86 @@
   ))
 {
   
-  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_publishes (
-      this,
-      id,
-      name,
-      version,
-      value,
-      ACE_TRY_ENV
+  IR_EmitsDef_ptr _tao_retval = IR_EmitsDef::_nil ();
+  IR_EmitsDef_var _tao_safe_retval (_tao_retval);
+  
+  
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+
+  
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "create_emits",
+      12,
+      1,
+      istub->orb_core ()
     );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << id) &&
+              (_tao_out << name) &&
+              (_tao_out << version) &&
+              (_tao_out << value)
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
+
+  return _tao_safe_retval._retn ();
 }
 
-IR::ConsumesDef_ptr IR::ComponentDef::create_consumes (
+IR_PublishesDef_ptr _TAO_ComponentDef_Remote_Proxy_Impl::create_publishes (
+    CORBA_Object *_collocated_tao_target_,
     const char * id,
     const char * name,
     const char * version,
-    IR::ValueDef_ptr value,
+    IR_ValueDef_ptr value,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -49683,976 +26835,669 @@
   ))
 {
   
-  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_consumes (
-      this,
-      id,
-      name,
-      version,
-      value,
-      ACE_TRY_ENV
-    );
-}
-
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get::TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get::result (IR::InterfaceDefSeq * result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set::TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const IR::InterfaceDefSeq & supported_interfaces,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    supported_interfaces_ (supported_interfaces)
-{}
-
-Dynamic::ParameterList *
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_supported_interfaces = parameter_list->length ();
-  parameter_list->length (length_supported_interfaces + 1);
-  (*parameter_list)[length_supported_interfaces].argument <<=  this->supported_interfaces_;
-  
-  (*parameter_list)[length_supported_interfaces].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 1;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
+  IR_PublishesDef_ptr _tao_retval = IR_PublishesDef::_nil ();
+  IR_PublishesDef_var _tao_safe_retval (_tao_retval);
   
-  return result_any;
-}
-
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_base_component_get::TAO_ClientRequestInfo_IR_ComponentDef_base_component_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_base_component_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
   
-  return parameter_list;
-}
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-Dynamic::ExceptionList *
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_base_component_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
   
-  return exception_list;
-}
-
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "create_publishes",
+      16,
+      1,
+      istub->orb_core ()
+    );
 
-CORBA::Any * 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_base_component_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << id) &&
+              (_tao_out << name) &&
+              (_tao_out << version) &&
+              (_tao_out << value)
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-void 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_base_component_get::result (IR::ComponentDef_ptr result)
-{
-  // update the result 
-  this->_result = result;
+  return _tao_safe_retval._retn ();
 }
 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get::TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
+IR_ConsumesDef_ptr _TAO_ComponentDef_Remote_Proxy_Impl::create_consumes (
+    CORBA_Object *_collocated_tao_target_,
+    const char * id,
+    const char * name,
+    const char * version,
+    IR_ValueDef_ptr value,
+    CORBA::Environment &ACE_TRY_ENV
   )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
   
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get::result (IR::ProvidesDefSeq * result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get::TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
+  IR_ConsumesDef_ptr _tao_retval = IR_ConsumesDef::_nil ();
+  IR_ConsumesDef_var _tao_safe_retval (_tao_retval);
   
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
   
-  return exception_list;
-}
-
+  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
+  if (istub == 0)
+    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
-CORBA::Any * 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
   
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get::result (IR::UsesDefSeq * result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get::TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
+  TAO_GIOP_Twoway_Invocation _tao_call (
+      istub,
+      "create_consumes",
+      15,
+      1,
+      istub->orb_core ()
+    );
 
-Dynamic::ParameterList *
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << id) &&
+              (_tao_out << name) &&
+              (_tao_out << version) &&
+              (_tao_out << value)
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-Dynamic::ExceptionList *
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
+  return _tao_safe_retval._retn ();
 }
 
 
-CORBA::Any * 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get::result (IR::EmitsDefSeq * result)
-{
-  // update the result 
-  this->_result = result;
-}
+//
+//            End  Base & Remote  Proxy Implemeentation. 
+///////////////////////////////////////////////////////////////////////
 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get::TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
 
-Dynamic::ParameterList *
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
+///////////////////////////////////////////////////////////////////////
+//           Remote & Base  Proxy Broker Implementation
+//
 
-Dynamic::ExceptionList *
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+_TAO_ComponentDef_Proxy_Broker::_TAO_ComponentDef_Proxy_Broker (void)
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
 }
 
-
-CORBA::Any * 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+_TAO_ComponentDef_Proxy_Broker::~_TAO_ComponentDef_Proxy_Broker (void)
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
 }
 
-void 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get::result (IR::PublishesDefSeq * result)
+// Factory function Implementation.
+_TAO_ComponentDef_Remote_Proxy_Broker *the_TAO_ComponentDef_Remote_Proxy_Broker (void)
 {
-  // update the result 
-  this->_result = result;
+  static ::_TAO_ComponentDef_Remote_Proxy_Broker remote_proxy_broker;
+  return &remote_proxy_broker;
 }
 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get::TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+_TAO_ComponentDef_Remote_Proxy_Broker::_TAO_ComponentDef_Remote_Proxy_Broker (void)
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
 }
 
-Dynamic::ExceptionList *
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+_TAO_ComponentDef_Remote_Proxy_Broker::~_TAO_ComponentDef_Remote_Proxy_Broker (void)
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
 }
 
-
-CORBA::Any * 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+_TAO_ComponentDef_Proxy_Impl&
+_TAO_ComponentDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_ComponentDef *object,
+  CORBA::Environment &ACE_TRY_ENV
+)
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
+  ACE_UNUSED_ARG (object);
+  ACE_UNUSED_ARG (ACE_TRY_ENV);
+  return remote_proxy_impl_;
 }
 
-void 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get::result (IR::ConsumesDefSeq * result)
-{
-  // update the result 
-  this->_result = result;
-}
 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get::TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
+//
+//           End Remote & Base Proxy Broker Implementation
+///////////////////////////////////////////////////////////////////////
 
-Dynamic::ParameterList *
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
 
-Dynamic::ExceptionList *
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+// default constructor
+IR_ComponentDef::IR_ComponentDef (int collocated)
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
+  this->_tao_setup_collocation (collocated);
 }
 
+// destructor
+IR_ComponentDef::~IR_ComponentDef (void)
+{}
 
-CORBA::Any * 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+void
+IR_ComponentDef::_tao_setup_collocation (int collocated)
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
+  if (collocated)
+    this->the_TAO_ComponentDef_Proxy_Broker_ =
+      _TAO_ComponentDef_Proxy_Broker_Factory_function_pointer (this);
+  else
+    this->the_TAO_ComponentDef_Proxy_Broker_ =
+      ::the_TAO_ComponentDef_Remote_Proxy_Broker ();
   
-  CORBA::Any_var safe_result_any = result_any;
+  IR_InterfaceDef::_tao_setup_collocation (collocated);
   
-  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
-  return safe_result_any._retn ();
 }
 
-void 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get::result (CORBA::Boolean result)
+void IR_ComponentDef::_tao_any_destructor (void *x)
 {
-  // update the result 
-  this->_result = result;
+  IR_ComponentDef *tmp = ACE_static_cast (IR_ComponentDef*,x);
+  CORBA::release (tmp);
 }
 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_provides::TAO_ClientRequestInfo_IR_ComponentDef_create_provides (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::InterfaceDef_ptr interface_type,
-    CORBA::Environment &    
+IR_ComponentDef_ptr IR_ComponentDef::_narrow (
+    CORBA::Object_ptr obj,
+    CORBA::Environment &ACE_TRY_ENV
   )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    id_ (id),
-    name_ (name),
-    version_ (version),
-    interface_type_ (interface_type)
-{}
-
-Dynamic::ParameterList *
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_provides::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_id = parameter_list->length ();
-  parameter_list->length (length_id + 1);
-  (*parameter_list)[length_id].argument <<= id_;
-  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_name = parameter_list->length ();
-  parameter_list->length (length_name + 1);
-  (*parameter_list)[length_name].argument <<= name_;
-  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_version = parameter_list->length ();
-  parameter_list->length (length_version + 1);
-  (*parameter_list)[length_version].argument <<= version_;
-  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_interface_type = parameter_list->length ();
-  parameter_list->length (length_interface_type + 1);
-  (*parameter_list)[length_interface_type].argument <<=  this->interface_type_;
-  
-  (*parameter_list)[length_interface_type].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
+  if (CORBA::is_nil (obj))
+    return IR_ComponentDef::_nil ();
+  if (! obj->_is_local ())
+    {
+      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ComponentDef:1.0", ACE_TRY_ENV);
+      ACE_CHECK_RETURN (IR_ComponentDef::_nil ());
+      if (is_a == 0)
+        return IR_ComponentDef::_nil ();
+    }
+  return IR_ComponentDef::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-Dynamic::ExceptionList *
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_provides::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+IR_ComponentDef_ptr IR_ComponentDef::_unchecked_narrow (
+    CORBA::Object_ptr obj,
+    CORBA::Environment &
+  )
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
+  if (CORBA::is_nil (obj))
+    return IR_ComponentDef::_nil ();
+  if (! obj->_is_local ())
+    {
+      TAO_Stub* stub = obj->_stubobj ();
+      if (stub)
+        stub->_incr_refcnt ();
+      IR_ComponentDef_ptr default_proxy = IR_ComponentDef::_nil ();
 
+      if (
+          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
+          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
+          obj->_is_collocated () &&_TAO_ComponentDef_Proxy_Broker_Factory_function_pointer != 0
+        )
+      {
+        ACE_NEW_RETURN (
+          default_proxy,
+          ::IR_ComponentDef (
+            stub,
+            1,
+            obj->_servant ()),
+            
+          IR_ComponentDef::_nil ());
+        }
+      if (CORBA::is_nil (default_proxy))
+        ACE_NEW_RETURN (default_proxy, ::IR_ComponentDef (stub, 0, obj->_servant ()), IR_ComponentDef::_nil ());
+        return default_proxy;
+      }
+    else 
+      return
+        ACE_reinterpret_cast
+          (
+            IR_ComponentDef_ptr,
+              obj->_tao_QueryInterface
+                (
+                  ACE_reinterpret_cast
+                    (
+                      ptr_arith_t,
+                      &IR_ComponentDef::_narrow
+                    )
+                )
+          );
+}
 
-CORBA::Any * 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_provides::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+IR_ComponentDef_ptr
+IR_ComponentDef::_duplicate (IR_ComponentDef_ptr obj)
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
+  if (!CORBA::is_nil (obj))
+    obj->_add_ref ();
+  return obj;
 }
 
-void 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_provides::result (IR::ProvidesDef_ptr result)
+CORBA::Boolean IR_ComponentDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
-  // update the result 
-  this->_result = result;
+  if (
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ComponentDef:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/InterfaceDef:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
+  return 1; // success using local knowledge
+  else
+    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
 }
 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_uses::TAO_ClientRequestInfo_IR_ComponentDef_create_uses (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::InterfaceDef_ptr interface_type,
-    const CORBA::Boolean & is_multiple,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    id_ (id),
-    name_ (name),
-    version_ (version),
-    interface_type_ (interface_type),
-    is_multiple_ (is_multiple)
-{}
-
-Dynamic::ParameterList *
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_uses::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+void *IR_ComponentDef::_tao_QueryInterface (ptr_arith_t type)
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_id = parameter_list->length ();
-  parameter_list->length (length_id + 1);
-  (*parameter_list)[length_id].argument <<= id_;
-  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_name = parameter_list->length ();
-  parameter_list->length (length_name + 1);
-  (*parameter_list)[length_name].argument <<= name_;
-  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_version = parameter_list->length ();
-  parameter_list->length (length_version + 1);
-  (*parameter_list)[length_version].argument <<= version_;
-  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_interface_type = parameter_list->length ();
-  parameter_list->length (length_interface_type + 1);
-  (*parameter_list)[length_interface_type].argument <<=  this->interface_type_;
-  
-  (*parameter_list)[length_interface_type].mode = Dynamic::PARAM_IN;
+  void *retv = 0;
+  if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_ComponentDef::_narrow))
+    retv = ACE_reinterpret_cast (void*, this);
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_InterfaceDef::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            IR_InterfaceDef_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_Container::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            IR_Container_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_Contained::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            IR_Contained_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &IR_IDLType::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            IR_IDLType_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast
+    (ptr_arith_t,
+      &CORBA_IRObject::_narrow))
+    retv = ACE_reinterpret_cast
+      (
+        void *,
+        ACE_static_cast
+          (
+            CORBA_IRObject_ptr,
+            this
+          )
+      );
+  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
+    retv = ACE_reinterpret_cast (void *,
+      ACE_static_cast (CORBA::Object_ptr, this));
     
-  CORBA::ULong length_is_multiple = parameter_list->length ();
-  parameter_list->length (length_is_multiple + 1);
-  (*parameter_list)[length_is_multiple].argument <<= CORBA::Any::from_boolean (this->is_multiple_);
-  (*parameter_list)[length_is_multiple].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
+  if (retv)
+    this->_add_ref ();
+  return retv;
 }
 
-Dynamic::ExceptionList *
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_uses::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+const char* IR_ComponentDef::_interface_repository_id (void) const
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
+  return "IDL:omg.org/IR/ComponentDef:1.0";
 }
 
-
-CORBA::Any * 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_uses::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+IR_InterfaceDefSeq * IR_ComponentDef::supported_interfaces (
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
   
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
+  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).supported_interfaces (
+      this,
+      ACE_TRY_ENV
+    );
 }
 
-void 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_uses::result (IR::UsesDef_ptr result)
+void IR_ComponentDef::supported_interfaces (
+    const IR_InterfaceDefSeq & supported_interfaces,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // update the result 
-  this->_result = result;
+  
+  this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).supported_interfaces (
+      this,
+      supported_interfaces,
+      ACE_TRY_ENV
+    );
 }
 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_emits::TAO_ClientRequestInfo_IR_ComponentDef_create_emits (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::ValueDef_ptr value,
-    CORBA::Environment &    
+IR_ComponentDef_ptr IR_ComponentDef::base_component (
+    CORBA::Environment &ACE_TRY_ENV
   )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    id_ (id),
-    name_ (name),
-    version_ (version),
-    value_ (value)
-{}
-
-Dynamic::ParameterList *
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_emits::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_id = parameter_list->length ();
-  parameter_list->length (length_id + 1);
-  (*parameter_list)[length_id].argument <<= id_;
-  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_name = parameter_list->length ();
-  parameter_list->length (length_name + 1);
-  (*parameter_list)[length_name].argument <<= name_;
-  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_version = parameter_list->length ();
-  parameter_list->length (length_version + 1);
-  (*parameter_list)[length_version].argument <<= version_;
-  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_value = parameter_list->length ();
-  parameter_list->length (length_value + 1);
-  (*parameter_list)[length_value].argument <<=  this->value_;
-  
-  (*parameter_list)[length_value].mode = Dynamic::PARAM_IN;
   
-  return safe_parameter_list._retn ();
+  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).base_component (
+      this,
+      ACE_TRY_ENV
+    );
 }
 
-Dynamic::ExceptionList *
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_emits::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+IR_ProvidesDefSeq * IR_ComponentDef::provides_interfaces (
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
   
-  return exception_list;
+  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).provides_interfaces (
+      this,
+      ACE_TRY_ENV
+    );
 }
 
-
-CORBA::Any * 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_emits::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+IR_UsesDefSeq * IR_ComponentDef::uses_interfaces (
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
   
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
+  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).uses_interfaces (
+      this,
+      ACE_TRY_ENV
+    );
 }
 
-void 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_emits::result (IR::EmitsDef_ptr result)
+IR_EmitsDefSeq * IR_ComponentDef::emits_events (
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // update the result 
-  this->_result = result;
+  
+  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).emits_events (
+      this,
+      ACE_TRY_ENV
+    );
 }
 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_publishes::TAO_ClientRequestInfo_IR_ComponentDef_create_publishes (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::ValueDef_ptr value,
-    CORBA::Environment &    
+IR_PublishesDefSeq * IR_ComponentDef::publishes_events (
+    CORBA::Environment &ACE_TRY_ENV
   )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    id_ (id),
-    name_ (name),
-    version_ (version),
-    value_ (value)
-{}
-
-Dynamic::ParameterList *
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_publishes::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_id = parameter_list->length ();
-  parameter_list->length (length_id + 1);
-  (*parameter_list)[length_id].argument <<= id_;
-  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_name = parameter_list->length ();
-  parameter_list->length (length_name + 1);
-  (*parameter_list)[length_name].argument <<= name_;
-  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_version = parameter_list->length ();
-  parameter_list->length (length_version + 1);
-  (*parameter_list)[length_version].argument <<= version_;
-  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_value = parameter_list->length ();
-  parameter_list->length (length_value + 1);
-  (*parameter_list)[length_value].argument <<=  this->value_;
-  
-  (*parameter_list)[length_value].mode = Dynamic::PARAM_IN;
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
+{
   
-  return safe_parameter_list._retn ();
+  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).publishes_events (
+      this,
+      ACE_TRY_ENV
+    );
 }
 
-Dynamic::ExceptionList *
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_publishes::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+IR_ConsumesDefSeq * IR_ComponentDef::consumes_events (
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
   
-  return exception_list;
+  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).consumes_events (
+      this,
+      ACE_TRY_ENV
+    );
 }
 
-
-CORBA::Any * 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_publishes::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+CORBA::Boolean IR_ComponentDef::is_basic (
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
   
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
+  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_basic (
+      this,
+      ACE_TRY_ENV
+    );
 }
 
-void 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_publishes::result (IR::PublishesDef_ptr result)
+IR_ProvidesDef_ptr IR_ComponentDef::create_provides (
+    const char * id,
+    const char * name,
+    const char * version,
+    IR_InterfaceDef_ptr interface_type,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // update the result 
-  this->_result = result;
+  
+  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_provides (
+      this,
+      id,
+      name,
+      version,
+      interface_type,
+      ACE_TRY_ENV
+    );
 }
 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_consumes::TAO_ClientRequestInfo_IR_ComponentDef_create_consumes (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
+IR_UsesDef_ptr IR_ComponentDef::create_uses (
     const char * id,
     const char * name,
     const char * version,
-    IR::ValueDef_ptr value,
-    CORBA::Environment &    
+    IR_InterfaceDef_ptr interface_type,
+    CORBA::Boolean is_multiple,
+    CORBA::Environment &ACE_TRY_ENV
   )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    id_ (id),
-    name_ (name),
-    version_ (version),
-    value_ (value)
-{}
-
-Dynamic::ParameterList *
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_consumes::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_id = parameter_list->length ();
-  parameter_list->length (length_id + 1);
-  (*parameter_list)[length_id].argument <<= id_;
-  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_name = parameter_list->length ();
-  parameter_list->length (length_name + 1);
-  (*parameter_list)[length_name].argument <<= name_;
-  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_version = parameter_list->length ();
-  parameter_list->length (length_version + 1);
-  (*parameter_list)[length_version].argument <<= version_;
-  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_value = parameter_list->length ();
-  parameter_list->length (length_value + 1);
-  (*parameter_list)[length_value].argument <<=  this->value_;
   
-  (*parameter_list)[length_value].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
+  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_uses (
+      this,
+      id,
+      name,
+      version,
+      interface_type,
+      is_multiple,
+      ACE_TRY_ENV
+    );
 }
 
-Dynamic::ExceptionList *
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_consumes::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+IR_EmitsDef_ptr IR_ComponentDef::create_emits (
+    const char * id,
+    const char * name,
+    const char * version,
+    IR_ValueDef_ptr value,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
   
-  return exception_list;
+  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_emits (
+      this,
+      id,
+      name,
+      version,
+      value,
+      ACE_TRY_ENV
+    );
 }
 
-
-CORBA::Any * 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_consumes::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
+IR_PublishesDef_ptr IR_ComponentDef::create_publishes (
+    const char * id,
+    const char * name,
+    const char * version,
+    IR_ValueDef_ptr value,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
   
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
+  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_publishes (
+      this,
+      id,
+      name,
+      version,
+      value,
+      ACE_TRY_ENV
+    );
 }
 
-void 
-IR::ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_consumes::result (IR::ConsumesDef_ptr result)
+IR_ConsumesDef_ptr IR_ComponentDef::create_consumes (
+    const char * id,
+    const char * name,
+    const char * version,
+    IR_ValueDef_ptr value,
+    CORBA::Environment &ACE_TRY_ENV
+  )
+  ACE_THROW_SPEC ((
+    CORBA::SystemException
+  ))
 {
-  // update the result 
-  this->_result = result;
+  
+  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_consumes (
+      this,
+      id,
+      name,
+      version,
+      value,
+      ACE_TRY_ENV
+    );
 }
 
-#endif /* TAO_HAS_INTERCEPTORS */
 static const CORBA::Long _oc_IR_ComponentDef[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
   32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6d706f), ACE_NTOHL (0x6e656e74), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ComponentDef:1.0
-  13, ACE_NTOHL (0x436f6d70), ACE_NTOHL (0x6f6e656e), ACE_NTOHL (0x74446566), ACE_NTOHL (0x0),  // name = ComponentDef
+  13, ACE_NTOHL (0x436f6d70), ACE_NTOHL (0x6f6e656e), ACE_NTOHL (0x74446566), ACE_NTOHL (0x0),  // name = IR_ComponentDef
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_ComponentDef (CORBA::tk_objref, sizeof (_oc_IR_ComponentDef), (char *) &_oc_IR_ComponentDef, 0, sizeof (IR::ComponentDef));
+static CORBA::TypeCode _tc_TAO_tc_IR_ComponentDef (CORBA::tk_objref, sizeof (_oc_IR_ComponentDef), (char *) &_oc_IR_ComponentDef, 0, sizeof (IR_ComponentDef));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
 TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ComponentDef, &_tc_TAO_tc_IR_ComponentDef)
 TAO_NAMESPACE_END
+
 static const CORBA::Long _oc_IR_ComponentDescription[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
@@ -50729,7 +27574,7 @@
   144, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
     34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657344), ACE_NTOHL (0x65665365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ProvidesDefSeq:1.0
-    15, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65710000),  // name = ProvidesDefSeq
+    15, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65710000),  // name = IR_ProvidesDefSeq
     CORBA::tk_sequence, // typecode kind
     72, // encapsulation length
       TAO_ENCAP_BYTE_ORDER, // byte order
@@ -50737,7 +27582,7 @@
       56, // encapsulation length
         TAO_ENCAP_BYTE_ORDER, // byte order
         31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDef:1.0
-        12, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44656600),  // name = ProvidesDef
+        12, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44656600),  // name = IR_ProvidesDef
 
       0U,
 
@@ -50747,7 +27592,7 @@
   128, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
     30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x73657344), ACE_NTOHL (0x65665365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/UsesDefSeq:1.0
-    11, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65710000),  // name = UsesDefSeq
+    11, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65710000),  // name = IR_UsesDefSeq
     CORBA::tk_sequence, // typecode kind
     64, // encapsulation length
       TAO_ENCAP_BYTE_ORDER, // byte order
@@ -50755,7 +27600,7 @@
       48, // encapsulation length
         TAO_ENCAP_BYTE_ORDER, // byte order
         27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x73657344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDef:1.0
-        8, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44656600),  // name = UsesDef
+        8, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44656600),  // name = IR_UsesDef
 
       0U,
 
@@ -50949,7 +27794,7 @@
   132, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
     31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x6d697473), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/EmitsDefSeq:1.0
-    12, ACE_NTOHL (0x456d6974), ACE_NTOHL (0x73446566), ACE_NTOHL (0x53657100),  // name = EmitsDefSeq
+    12, ACE_NTOHL (0x456d6974), ACE_NTOHL (0x73446566), ACE_NTOHL (0x53657100),  // name = IR_EmitsDefSeq
     CORBA::tk_sequence, // typecode kind
     68, // encapsulation length
       TAO_ENCAP_BYTE_ORDER, // byte order
@@ -50957,7 +27802,7 @@
       52, // encapsulation length
         TAO_ENCAP_BYTE_ORDER, // byte order
         28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x6d697473), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/EmitsDef:1.0
-        9, ACE_NTOHL (0x456d6974), ACE_NTOHL (0x73446566), ACE_NTOHL (0x0),  // name = EmitsDef
+        9, ACE_NTOHL (0x456d6974), ACE_NTOHL (0x73446566), ACE_NTOHL (0x0),  // name = IR_EmitsDef
 
       0U,
 
@@ -50967,7 +27812,7 @@
   148, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
     35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x75626c69), ACE_NTOHL (0x73686573), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/PublishesDefSeq:1.0
-    16, ACE_NTOHL (0x5075626c), ACE_NTOHL (0x69736865), ACE_NTOHL (0x73446566), ACE_NTOHL (0x53657100),  // name = PublishesDefSeq
+    16, ACE_NTOHL (0x5075626c), ACE_NTOHL (0x69736865), ACE_NTOHL (0x73446566), ACE_NTOHL (0x53657100),  // name = IR_PublishesDefSeq
     CORBA::tk_sequence, // typecode kind
     76, // encapsulation length
       TAO_ENCAP_BYTE_ORDER, // byte order
@@ -50975,7 +27820,7 @@
       60, // encapsulation length
         TAO_ENCAP_BYTE_ORDER, // byte order
         32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x75626c69), ACE_NTOHL (0x73686573), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/PublishesDef:1.0
-        13, ACE_NTOHL (0x5075626c), ACE_NTOHL (0x69736865), ACE_NTOHL (0x73446566), ACE_NTOHL (0x0),  // name = PublishesDef
+        13, ACE_NTOHL (0x5075626c), ACE_NTOHL (0x69736865), ACE_NTOHL (0x73446566), ACE_NTOHL (0x0),  // name = IR_PublishesDef
 
       0U,
 
@@ -50985,7 +27830,7 @@
   144, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
     34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7375), ACE_NTOHL (0x6d657344), ACE_NTOHL (0x65665365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ConsumesDefSeq:1.0
-    15, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x756d6573), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65710000),  // name = ConsumesDefSeq
+    15, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x756d6573), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65710000),  // name = IR_ConsumesDefSeq
     CORBA::tk_sequence, // typecode kind
     72, // encapsulation length
       TAO_ENCAP_BYTE_ORDER, // byte order
@@ -50993,7 +27838,7 @@
       56, // encapsulation length
         TAO_ENCAP_BYTE_ORDER, // byte order
         31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7375), ACE_NTOHL (0x6d657344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ConsumesDef:1.0
-        12, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x756d6573), ACE_NTOHL (0x44656600),  // name = ConsumesDef
+        12, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x756d6573), ACE_NTOHL (0x44656600),  // name = IR_ConsumesDef
 
       0U,
 
@@ -51002,14 +27847,15 @@
   CORBA::tk_boolean,
 
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_ComponentDescription (CORBA::tk_struct, sizeof (_oc_IR_ComponentDescription), (char *) &_oc_IR_ComponentDescription, 0, sizeof (IR::ComponentDescription));
+static CORBA::TypeCode _tc_TAO_tc_IR_ComponentDescription (CORBA::tk_struct, sizeof (_oc_IR_ComponentDescription), (char *) &_oc_IR_ComponentDescription, 0, sizeof (IR_ComponentDescription));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
 TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ComponentDescription, &_tc_TAO_tc_IR_ComponentDescription)
 TAO_NAMESPACE_END
-void IR::ComponentDescription::_tao_any_destructor (void *x)
+
+void IR_ComponentDescription::_tao_any_destructor (void *x)
 {
-  ComponentDescription *tmp = ACE_static_cast (ComponentDescription*,x);
+  IR_ComponentDescription *tmp = ACE_static_cast (IR_ComponentDescription*,x);
   delete tmp;
 }
 
@@ -51018,15 +27864,15 @@
 //                Base & Remote Proxy  Implementation. 
 //
 
-IR::_TAO_PrimaryKeyDef_Proxy_Impl::_TAO_PrimaryKeyDef_Proxy_Impl (void)
+_TAO_PrimaryKeyDef_Proxy_Impl::_TAO_PrimaryKeyDef_Proxy_Impl (void)
 {}
 
-IR::_TAO_PrimaryKeyDef_Remote_Proxy_Impl::_TAO_PrimaryKeyDef_Remote_Proxy_Impl (void)
+_TAO_PrimaryKeyDef_Remote_Proxy_Impl::_TAO_PrimaryKeyDef_Remote_Proxy_Impl (void)
 {}
 
 // Remote Implementation of the IDL interface methods
 
-CORBA::Boolean IR::_TAO_PrimaryKeyDef_Remote_Proxy_Impl::is_a (
+CORBA::Boolean _TAO_PrimaryKeyDef_Remote_Proxy_Impl::is_a (
     CORBA_Object *_collocated_tao_target_,
     const char * primary_key_id,
     CORBA::Environment &ACE_TRY_ENV
@@ -51052,151 +27898,61 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << primary_key_id)
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            _tao_retval
+          );
       
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::PrimaryKeyDef::TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        primary_key_id,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << primary_key_id)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
               _tao_retval
             );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
+          ))
+          {
+            ACE_THROW_RETURN (
                 CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                 _tao_retval
               );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              CORBA::Boolean  _tao_retval_info = _tao_retval;
-               ri.result (_tao_retval_info);
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_retval;
 }
 
-IR::ValueDef_ptr IR::_TAO_PrimaryKeyDef_Remote_Proxy_Impl::primary_key (
+IR_ValueDef_ptr _TAO_PrimaryKeyDef_Remote_Proxy_Impl::primary_key (
     CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -51205,8 +27961,8 @@
   ))
 {
   
-  IR::ValueDef_ptr _tao_retval = IR::ValueDef::_nil ();
-  IR::ValueDef_var _tao_safe_retval (_tao_retval);
+  IR_ValueDef_ptr _tao_retval = IR_ValueDef::_nil ();
+  IR_ValueDef_var _tao_safe_retval (_tao_retval);
   
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
@@ -51222,137 +27978,47 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::PrimaryKeyDef::TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::ValueDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
         }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
@@ -51366,32 +28032,32 @@
 //           Remote & Base  Proxy Broker Implementation
 //
 
-IR::_TAO_PrimaryKeyDef_Proxy_Broker::_TAO_PrimaryKeyDef_Proxy_Broker (void)
+_TAO_PrimaryKeyDef_Proxy_Broker::_TAO_PrimaryKeyDef_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_PrimaryKeyDef_Proxy_Broker::~_TAO_PrimaryKeyDef_Proxy_Broker (void)
+_TAO_PrimaryKeyDef_Proxy_Broker::~_TAO_PrimaryKeyDef_Proxy_Broker (void)
 {
 }
 
-// Factory Member function Implementation.
-IR::_TAO_PrimaryKeyDef_Remote_Proxy_Broker *IR::_TAO_PrimaryKeyDef_Remote_Proxy_Broker::the_TAO_PrimaryKeyDef_Remote_Proxy_Broker (void)
+// Factory function Implementation.
+_TAO_PrimaryKeyDef_Remote_Proxy_Broker *the_TAO_PrimaryKeyDef_Remote_Proxy_Broker (void)
 {
-  static ::IR::_TAO_PrimaryKeyDef_Remote_Proxy_Broker remote_proxy_broker;
+  static ::_TAO_PrimaryKeyDef_Remote_Proxy_Broker remote_proxy_broker;
   return &remote_proxy_broker;
 }
 
-IR::_TAO_PrimaryKeyDef_Remote_Proxy_Broker::_TAO_PrimaryKeyDef_Remote_Proxy_Broker (void)
+_TAO_PrimaryKeyDef_Remote_Proxy_Broker::_TAO_PrimaryKeyDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_PrimaryKeyDef_Remote_Proxy_Broker::~_TAO_PrimaryKeyDef_Remote_Proxy_Broker (void)
+_TAO_PrimaryKeyDef_Remote_Proxy_Broker::~_TAO_PrimaryKeyDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_PrimaryKeyDef_Proxy_Impl&
-IR::_TAO_PrimaryKeyDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::PrimaryKeyDef *object,
+_TAO_PrimaryKeyDef_Proxy_Impl&
+_TAO_PrimaryKeyDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_PrimaryKeyDef *object,
   CORBA::Environment &ACE_TRY_ENV
 )
 {
@@ -51407,109 +28073,110 @@
 
 
 // default constructor
-IR::PrimaryKeyDef::PrimaryKeyDef (int collocated)
+IR_PrimaryKeyDef::IR_PrimaryKeyDef (int collocated)
 {
   this->_tao_setup_collocation (collocated);
 }
 
 // destructor
-IR::PrimaryKeyDef::~PrimaryKeyDef (void)
+IR_PrimaryKeyDef::~IR_PrimaryKeyDef (void)
 {}
 
 void
-IR::PrimaryKeyDef::_tao_setup_collocation (int collocated)
+IR_PrimaryKeyDef::_tao_setup_collocation (int collocated)
 {
   if (collocated)
     this->the_TAO_PrimaryKeyDef_Proxy_Broker_ =
-      ::IR__TAO_PrimaryKeyDef_Proxy_Broker_Factory_function_pointer (this);
+      _TAO_PrimaryKeyDef_Proxy_Broker_Factory_function_pointer (this);
   else
     this->the_TAO_PrimaryKeyDef_Proxy_Broker_ =
-      ::IR::_TAO_PrimaryKeyDef_Remote_Proxy_Broker::the_TAO_PrimaryKeyDef_Remote_Proxy_Broker ();
+      ::the_TAO_PrimaryKeyDef_Remote_Proxy_Broker ();
+  
+  IR_Contained::_tao_setup_collocation (collocated);
   
-  ACE_NESTED_CLASS (IR, Contained)::_tao_setup_collocation (collocated);
 }
 
-void IR::PrimaryKeyDef::_tao_any_destructor (void *x)
+void IR_PrimaryKeyDef::_tao_any_destructor (void *x)
 {
-  PrimaryKeyDef *tmp = ACE_static_cast (PrimaryKeyDef*,x);
+  IR_PrimaryKeyDef *tmp = ACE_static_cast (IR_PrimaryKeyDef*,x);
   CORBA::release (tmp);
 }
 
-IR::PrimaryKeyDef_ptr IR::PrimaryKeyDef::_narrow (
+IR_PrimaryKeyDef_ptr IR_PrimaryKeyDef::_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
 {
   if (CORBA::is_nil (obj))
-    return PrimaryKeyDef::_nil ();
+    return IR_PrimaryKeyDef::_nil ();
   if (! obj->_is_local ())
     {
       CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/PrimaryKeyDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (PrimaryKeyDef::_nil ());
+      ACE_CHECK_RETURN (IR_PrimaryKeyDef::_nil ());
       if (is_a == 0)
-        return PrimaryKeyDef::_nil ();
+        return IR_PrimaryKeyDef::_nil ();
     }
-  return PrimaryKeyDef::_unchecked_narrow (obj, ACE_TRY_ENV);
+  return IR_PrimaryKeyDef::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::PrimaryKeyDef_ptr IR::PrimaryKeyDef::_unchecked_narrow (
+IR_PrimaryKeyDef_ptr IR_PrimaryKeyDef::_unchecked_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &
   )
 {
   if (CORBA::is_nil (obj))
-    return PrimaryKeyDef::_nil ();
+    return IR_PrimaryKeyDef::_nil ();
   if (! obj->_is_local ())
     {
       TAO_Stub* stub = obj->_stubobj ();
       if (stub)
         stub->_incr_refcnt ();
-      PrimaryKeyDef_ptr default_proxy = PrimaryKeyDef::_nil ();
+      IR_PrimaryKeyDef_ptr default_proxy = IR_PrimaryKeyDef::_nil ();
 
       if (
           !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
           stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_PrimaryKeyDef_Proxy_Broker_Factory_function_pointer != 0
+          obj->_is_collocated () &&_TAO_PrimaryKeyDef_Proxy_Broker_Factory_function_pointer != 0
         )
       {
         ACE_NEW_RETURN (
           default_proxy,
-          ::IR::PrimaryKeyDef (
+          ::IR_PrimaryKeyDef (
             stub,
             1,
             obj->_servant ()),
             
-          PrimaryKeyDef::_nil ());
+          IR_PrimaryKeyDef::_nil ());
         }
       if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::PrimaryKeyDef (stub, 0, obj->_servant ()), PrimaryKeyDef::_nil ());
+        ACE_NEW_RETURN (default_proxy, ::IR_PrimaryKeyDef (stub, 0, obj->_servant ()), IR_PrimaryKeyDef::_nil ());
         return default_proxy;
       }
     else 
       return
         ACE_reinterpret_cast
           (
-            PrimaryKeyDef_ptr,
+            IR_PrimaryKeyDef_ptr,
               obj->_tao_QueryInterface
                 (
                   ACE_reinterpret_cast
                     (
                       ptr_arith_t,
-                      &PrimaryKeyDef::_narrow
+                      &IR_PrimaryKeyDef::_narrow
                     )
                 )
           );
 }
 
-IR::PrimaryKeyDef_ptr
-IR::PrimaryKeyDef::_duplicate (PrimaryKeyDef_ptr obj)
+IR_PrimaryKeyDef_ptr
+IR_PrimaryKeyDef::_duplicate (IR_PrimaryKeyDef_ptr obj)
 {
   if (!CORBA::is_nil (obj))
     obj->_add_ref ();
   return obj;
 }
 
-CORBA::Boolean IR::PrimaryKeyDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+CORBA::Boolean IR_PrimaryKeyDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
   if (
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/PrimaryKeyDef:1.0")) ||
@@ -51521,34 +28188,34 @@
     return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
 }
 
-void *IR::PrimaryKeyDef::_tao_QueryInterface (ptr_arith_t type)
+void *IR_PrimaryKeyDef::_tao_QueryInterface (ptr_arith_t type)
 {
   void *retv = 0;
   if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, PrimaryKeyDef)::_narrow))
+      &IR_PrimaryKeyDef::_narrow))
     retv = ACE_reinterpret_cast (void*, this);
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Contained)::_narrow))
+      &IR_Contained::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::Contained_ptr,
+            IR_Contained_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
+      &CORBA_IRObject::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            CORBA::IRObject_ptr,
+            CORBA_IRObject_ptr,
             this
           )
       );
@@ -51561,12 +28228,12 @@
   return retv;
 }
 
-const char* IR::PrimaryKeyDef::_interface_repository_id (void) const
+const char* IR_PrimaryKeyDef::_interface_repository_id (void) const
 {
   return "IDL:omg.org/IR/PrimaryKeyDef:1.0";
 }
 
-CORBA::Boolean IR::PrimaryKeyDef::is_a (
+CORBA::Boolean IR_PrimaryKeyDef::is_a (
     const char * primary_key_id,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -51582,7 +28249,7 @@
     );
 }
 
-IR::ValueDef_ptr IR::PrimaryKeyDef::primary_key (
+IR_ValueDef_ptr IR_PrimaryKeyDef::primary_key (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -51596,141 +28263,18 @@
     );
 }
 
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-IR::PrimaryKeyDef::TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a::TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * primary_key_id,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    primary_key_id_ (primary_key_id)
-{}
-
-Dynamic::ParameterList *
-IR::PrimaryKeyDef::TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_primary_key_id = parameter_list->length ();
-  parameter_list->length (length_primary_key_id + 1);
-  (*parameter_list)[length_primary_key_id].argument <<= primary_key_id_;
-  (*parameter_list)[length_primary_key_id].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::PrimaryKeyDef::TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::PrimaryKeyDef::TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
-  return safe_result_any._retn ();
-}
-
-void 
-IR::PrimaryKeyDef::TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a::result (CORBA::Boolean result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::PrimaryKeyDef::TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get::TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::PrimaryKeyDef::TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::PrimaryKeyDef::TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::PrimaryKeyDef::TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::PrimaryKeyDef::TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get::result (IR::ValueDef_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-#endif /* TAO_HAS_INTERCEPTORS */
 static const CORBA::Long _oc_IR_PrimaryKeyDef[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
   33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x72696d61), ACE_NTOHL (0x72794b65), ACE_NTOHL (0x79446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/PrimaryKeyDef:1.0
-  14, ACE_NTOHL (0x5072696d), ACE_NTOHL (0x6172794b), ACE_NTOHL (0x65794465), ACE_NTOHL (0x66000000),  // name = PrimaryKeyDef
+  14, ACE_NTOHL (0x5072696d), ACE_NTOHL (0x6172794b), ACE_NTOHL (0x65794465), ACE_NTOHL (0x66000000),  // name = IR_PrimaryKeyDef
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_PrimaryKeyDef (CORBA::tk_objref, sizeof (_oc_IR_PrimaryKeyDef), (char *) &_oc_IR_PrimaryKeyDef, 0, sizeof (IR::PrimaryKeyDef));
+static CORBA::TypeCode _tc_TAO_tc_IR_PrimaryKeyDef (CORBA::tk_objref, sizeof (_oc_IR_PrimaryKeyDef), (char *) &_oc_IR_PrimaryKeyDef, 0, sizeof (IR_PrimaryKeyDef));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
 TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PrimaryKeyDef, &_tc_TAO_tc_IR_PrimaryKeyDef)
 TAO_NAMESPACE_END
+
 static const CORBA::Long _oc_IR_PrimaryKeyDescription[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
@@ -51778,17 +28322,18 @@
   52, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
     28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ValueDef:1.0
-    9, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = ValueDef
+    9, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = IR_ValueDef
 
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_PrimaryKeyDescription (CORBA::tk_struct, sizeof (_oc_IR_PrimaryKeyDescription), (char *) &_oc_IR_PrimaryKeyDescription, 0, sizeof (IR::PrimaryKeyDescription));
+static CORBA::TypeCode _tc_TAO_tc_IR_PrimaryKeyDescription (CORBA::tk_struct, sizeof (_oc_IR_PrimaryKeyDescription), (char *) &_oc_IR_PrimaryKeyDescription, 0, sizeof (IR_PrimaryKeyDescription));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
 TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PrimaryKeyDescription, &_tc_TAO_tc_IR_PrimaryKeyDescription)
 TAO_NAMESPACE_END
-void IR::PrimaryKeyDescription::_tao_any_destructor (void *x)
+
+void IR_PrimaryKeyDescription::_tao_any_destructor (void *x)
 {
-  PrimaryKeyDescription *tmp = ACE_static_cast (PrimaryKeyDescription*,x);
+  IR_PrimaryKeyDescription *tmp = ACE_static_cast (IR_PrimaryKeyDescription*,x);
   delete tmp;
 }
 
@@ -51797,10 +28342,10 @@
 //                Base & Remote Proxy  Implementation. 
 //
 
-IR::_TAO_FactoryDef_Proxy_Impl::_TAO_FactoryDef_Proxy_Impl (void)
+_TAO_FactoryDef_Proxy_Impl::_TAO_FactoryDef_Proxy_Impl (void)
 {}
 
-IR::_TAO_FactoryDef_Remote_Proxy_Impl::_TAO_FactoryDef_Remote_Proxy_Impl (void)
+_TAO_FactoryDef_Remote_Proxy_Impl::_TAO_FactoryDef_Remote_Proxy_Impl (void)
 {}
 
 // Remote Implementation of the IDL interface methods
@@ -51815,32 +28360,32 @@
 //           Remote & Base  Proxy Broker Implementation
 //
 
-IR::_TAO_FactoryDef_Proxy_Broker::_TAO_FactoryDef_Proxy_Broker (void)
+_TAO_FactoryDef_Proxy_Broker::_TAO_FactoryDef_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_FactoryDef_Proxy_Broker::~_TAO_FactoryDef_Proxy_Broker (void)
+_TAO_FactoryDef_Proxy_Broker::~_TAO_FactoryDef_Proxy_Broker (void)
 {
 }
 
-// Factory Member function Implementation.
-IR::_TAO_FactoryDef_Remote_Proxy_Broker *IR::_TAO_FactoryDef_Remote_Proxy_Broker::the_TAO_FactoryDef_Remote_Proxy_Broker (void)
+// Factory function Implementation.
+_TAO_FactoryDef_Remote_Proxy_Broker *the_TAO_FactoryDef_Remote_Proxy_Broker (void)
 {
-  static ::IR::_TAO_FactoryDef_Remote_Proxy_Broker remote_proxy_broker;
+  static ::_TAO_FactoryDef_Remote_Proxy_Broker remote_proxy_broker;
   return &remote_proxy_broker;
 }
 
-IR::_TAO_FactoryDef_Remote_Proxy_Broker::_TAO_FactoryDef_Remote_Proxy_Broker (void)
+_TAO_FactoryDef_Remote_Proxy_Broker::_TAO_FactoryDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_FactoryDef_Remote_Proxy_Broker::~_TAO_FactoryDef_Remote_Proxy_Broker (void)
+_TAO_FactoryDef_Remote_Proxy_Broker::~_TAO_FactoryDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_FactoryDef_Proxy_Impl&
-IR::_TAO_FactoryDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::FactoryDef *object,
+_TAO_FactoryDef_Proxy_Impl&
+_TAO_FactoryDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_FactoryDef *object,
   CORBA::Environment &ACE_TRY_ENV
 )
 {
@@ -51856,109 +28401,110 @@
 
 
 // default constructor
-IR::FactoryDef::FactoryDef (int collocated)
+IR_FactoryDef::IR_FactoryDef (int collocated)
 {
   this->_tao_setup_collocation (collocated);
 }
 
 // destructor
-IR::FactoryDef::~FactoryDef (void)
+IR_FactoryDef::~IR_FactoryDef (void)
 {}
 
 void
-IR::FactoryDef::_tao_setup_collocation (int collocated)
+IR_FactoryDef::_tao_setup_collocation (int collocated)
 {
   if (collocated)
     this->the_TAO_FactoryDef_Proxy_Broker_ =
-      ::IR__TAO_FactoryDef_Proxy_Broker_Factory_function_pointer (this);
+      _TAO_FactoryDef_Proxy_Broker_Factory_function_pointer (this);
   else
     this->the_TAO_FactoryDef_Proxy_Broker_ =
-      ::IR::_TAO_FactoryDef_Remote_Proxy_Broker::the_TAO_FactoryDef_Remote_Proxy_Broker ();
+      ::the_TAO_FactoryDef_Remote_Proxy_Broker ();
+  
+  IR_OperationDef::_tao_setup_collocation (collocated);
   
-  ACE_NESTED_CLASS (IR, OperationDef)::_tao_setup_collocation (collocated);
 }
 
-void IR::FactoryDef::_tao_any_destructor (void *x)
+void IR_FactoryDef::_tao_any_destructor (void *x)
 {
-  FactoryDef *tmp = ACE_static_cast (FactoryDef*,x);
+  IR_FactoryDef *tmp = ACE_static_cast (IR_FactoryDef*,x);
   CORBA::release (tmp);
 }
 
-IR::FactoryDef_ptr IR::FactoryDef::_narrow (
+IR_FactoryDef_ptr IR_FactoryDef::_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
 {
   if (CORBA::is_nil (obj))
-    return FactoryDef::_nil ();
+    return IR_FactoryDef::_nil ();
   if (! obj->_is_local ())
     {
       CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/FactoryDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (FactoryDef::_nil ());
+      ACE_CHECK_RETURN (IR_FactoryDef::_nil ());
       if (is_a == 0)
-        return FactoryDef::_nil ();
+        return IR_FactoryDef::_nil ();
     }
-  return FactoryDef::_unchecked_narrow (obj, ACE_TRY_ENV);
+  return IR_FactoryDef::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::FactoryDef_ptr IR::FactoryDef::_unchecked_narrow (
+IR_FactoryDef_ptr IR_FactoryDef::_unchecked_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &
   )
 {
   if (CORBA::is_nil (obj))
-    return FactoryDef::_nil ();
+    return IR_FactoryDef::_nil ();
   if (! obj->_is_local ())
     {
       TAO_Stub* stub = obj->_stubobj ();
       if (stub)
         stub->_incr_refcnt ();
-      FactoryDef_ptr default_proxy = FactoryDef::_nil ();
+      IR_FactoryDef_ptr default_proxy = IR_FactoryDef::_nil ();
 
       if (
           !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
           stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_FactoryDef_Proxy_Broker_Factory_function_pointer != 0
+          obj->_is_collocated () &&_TAO_FactoryDef_Proxy_Broker_Factory_function_pointer != 0
         )
       {
         ACE_NEW_RETURN (
           default_proxy,
-          ::IR::FactoryDef (
+          ::IR_FactoryDef (
             stub,
             1,
             obj->_servant ()),
             
-          FactoryDef::_nil ());
+          IR_FactoryDef::_nil ());
         }
       if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::FactoryDef (stub, 0, obj->_servant ()), FactoryDef::_nil ());
+        ACE_NEW_RETURN (default_proxy, ::IR_FactoryDef (stub, 0, obj->_servant ()), IR_FactoryDef::_nil ());
         return default_proxy;
       }
     else 
       return
         ACE_reinterpret_cast
           (
-            FactoryDef_ptr,
+            IR_FactoryDef_ptr,
               obj->_tao_QueryInterface
                 (
                   ACE_reinterpret_cast
                     (
                       ptr_arith_t,
-                      &FactoryDef::_narrow
+                      &IR_FactoryDef::_narrow
                     )
                 )
           );
 }
 
-IR::FactoryDef_ptr
-IR::FactoryDef::_duplicate (FactoryDef_ptr obj)
+IR_FactoryDef_ptr
+IR_FactoryDef::_duplicate (IR_FactoryDef_ptr obj)
 {
   if (!CORBA::is_nil (obj))
     obj->_add_ref ();
   return obj;
 }
 
-CORBA::Boolean IR::FactoryDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+CORBA::Boolean IR_FactoryDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
   if (
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/FactoryDef:1.0")) ||
@@ -51971,46 +28517,46 @@
     return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
 }
 
-void *IR::FactoryDef::_tao_QueryInterface (ptr_arith_t type)
+void *IR_FactoryDef::_tao_QueryInterface (ptr_arith_t type)
 {
   void *retv = 0;
   if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, FactoryDef)::_narrow))
+      &IR_FactoryDef::_narrow))
     retv = ACE_reinterpret_cast (void*, this);
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, OperationDef)::_narrow))
+      &IR_OperationDef::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::OperationDef_ptr,
+            IR_OperationDef_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Contained)::_narrow))
+      &IR_Contained::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::Contained_ptr,
+            IR_Contained_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
+      &CORBA_IRObject::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            CORBA::IRObject_ptr,
+            CORBA_IRObject_ptr,
             this
           )
       );
@@ -52023,21 +28569,18 @@
   return retv;
 }
 
-const char* IR::FactoryDef::_interface_repository_id (void) const
+const char* IR_FactoryDef::_interface_repository_id (void) const
 {
   return "IDL:omg.org/IR/FactoryDef:1.0";
 }
 
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-#endif /* TAO_HAS_INTERCEPTORS */
 static const CORBA::Long _oc_IR_FactoryDef[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
   30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x6163746f), ACE_NTOHL (0x72794465), ACE_NTOHL (0x663a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/FactoryDef:1.0
-  11, ACE_NTOHL (0x46616374), ACE_NTOHL (0x6f727944), ACE_NTOHL (0x65660000),  // name = FactoryDef
+  11, ACE_NTOHL (0x46616374), ACE_NTOHL (0x6f727944), ACE_NTOHL (0x65660000),  // name = IR_FactoryDef
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_FactoryDef (CORBA::tk_objref, sizeof (_oc_IR_FactoryDef), (char *) &_oc_IR_FactoryDef, 0, sizeof (IR::FactoryDef));
+static CORBA::TypeCode _tc_TAO_tc_IR_FactoryDef (CORBA::tk_objref, sizeof (_oc_IR_FactoryDef), (char *) &_oc_IR_FactoryDef, 0, sizeof (IR_FactoryDef));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
 TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FactoryDef, &_tc_TAO_tc_IR_FactoryDef)
@@ -52047,10 +28590,10 @@
 //                Base & Remote Proxy  Implementation. 
 //
 
-IR::_TAO_FinderDef_Proxy_Impl::_TAO_FinderDef_Proxy_Impl (void)
+_TAO_FinderDef_Proxy_Impl::_TAO_FinderDef_Proxy_Impl (void)
 {}
 
-IR::_TAO_FinderDef_Remote_Proxy_Impl::_TAO_FinderDef_Remote_Proxy_Impl (void)
+_TAO_FinderDef_Remote_Proxy_Impl::_TAO_FinderDef_Remote_Proxy_Impl (void)
 {}
 
 // Remote Implementation of the IDL interface methods
@@ -52065,32 +28608,32 @@
 //           Remote & Base  Proxy Broker Implementation
 //
 
-IR::_TAO_FinderDef_Proxy_Broker::_TAO_FinderDef_Proxy_Broker (void)
+_TAO_FinderDef_Proxy_Broker::_TAO_FinderDef_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_FinderDef_Proxy_Broker::~_TAO_FinderDef_Proxy_Broker (void)
+_TAO_FinderDef_Proxy_Broker::~_TAO_FinderDef_Proxy_Broker (void)
 {
 }
 
-// Factory Member function Implementation.
-IR::_TAO_FinderDef_Remote_Proxy_Broker *IR::_TAO_FinderDef_Remote_Proxy_Broker::the_TAO_FinderDef_Remote_Proxy_Broker (void)
+// Factory function Implementation.
+_TAO_FinderDef_Remote_Proxy_Broker *the_TAO_FinderDef_Remote_Proxy_Broker (void)
 {
-  static ::IR::_TAO_FinderDef_Remote_Proxy_Broker remote_proxy_broker;
+  static ::_TAO_FinderDef_Remote_Proxy_Broker remote_proxy_broker;
   return &remote_proxy_broker;
 }
 
-IR::_TAO_FinderDef_Remote_Proxy_Broker::_TAO_FinderDef_Remote_Proxy_Broker (void)
+_TAO_FinderDef_Remote_Proxy_Broker::_TAO_FinderDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_FinderDef_Remote_Proxy_Broker::~_TAO_FinderDef_Remote_Proxy_Broker (void)
+_TAO_FinderDef_Remote_Proxy_Broker::~_TAO_FinderDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_FinderDef_Proxy_Impl&
-IR::_TAO_FinderDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::FinderDef *object,
+_TAO_FinderDef_Proxy_Impl&
+_TAO_FinderDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_FinderDef *object,
   CORBA::Environment &ACE_TRY_ENV
 )
 {
@@ -52106,109 +28649,110 @@
 
 
 // default constructor
-IR::FinderDef::FinderDef (int collocated)
+IR_FinderDef::IR_FinderDef (int collocated)
 {
   this->_tao_setup_collocation (collocated);
 }
 
 // destructor
-IR::FinderDef::~FinderDef (void)
+IR_FinderDef::~IR_FinderDef (void)
 {}
 
 void
-IR::FinderDef::_tao_setup_collocation (int collocated)
+IR_FinderDef::_tao_setup_collocation (int collocated)
 {
   if (collocated)
     this->the_TAO_FinderDef_Proxy_Broker_ =
-      ::IR__TAO_FinderDef_Proxy_Broker_Factory_function_pointer (this);
+      _TAO_FinderDef_Proxy_Broker_Factory_function_pointer (this);
   else
     this->the_TAO_FinderDef_Proxy_Broker_ =
-      ::IR::_TAO_FinderDef_Remote_Proxy_Broker::the_TAO_FinderDef_Remote_Proxy_Broker ();
+      ::the_TAO_FinderDef_Remote_Proxy_Broker ();
+  
+  IR_OperationDef::_tao_setup_collocation (collocated);
   
-  ACE_NESTED_CLASS (IR, OperationDef)::_tao_setup_collocation (collocated);
 }
 
-void IR::FinderDef::_tao_any_destructor (void *x)
+void IR_FinderDef::_tao_any_destructor (void *x)
 {
-  FinderDef *tmp = ACE_static_cast (FinderDef*,x);
+  IR_FinderDef *tmp = ACE_static_cast (IR_FinderDef*,x);
   CORBA::release (tmp);
 }
 
-IR::FinderDef_ptr IR::FinderDef::_narrow (
+IR_FinderDef_ptr IR_FinderDef::_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
 {
   if (CORBA::is_nil (obj))
-    return FinderDef::_nil ();
+    return IR_FinderDef::_nil ();
   if (! obj->_is_local ())
     {
       CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/FinderDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (FinderDef::_nil ());
+      ACE_CHECK_RETURN (IR_FinderDef::_nil ());
       if (is_a == 0)
-        return FinderDef::_nil ();
+        return IR_FinderDef::_nil ();
     }
-  return FinderDef::_unchecked_narrow (obj, ACE_TRY_ENV);
+  return IR_FinderDef::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::FinderDef_ptr IR::FinderDef::_unchecked_narrow (
+IR_FinderDef_ptr IR_FinderDef::_unchecked_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &
   )
 {
   if (CORBA::is_nil (obj))
-    return FinderDef::_nil ();
+    return IR_FinderDef::_nil ();
   if (! obj->_is_local ())
     {
       TAO_Stub* stub = obj->_stubobj ();
       if (stub)
         stub->_incr_refcnt ();
-      FinderDef_ptr default_proxy = FinderDef::_nil ();
+      IR_FinderDef_ptr default_proxy = IR_FinderDef::_nil ();
 
       if (
           !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
           stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_FinderDef_Proxy_Broker_Factory_function_pointer != 0
+          obj->_is_collocated () &&_TAO_FinderDef_Proxy_Broker_Factory_function_pointer != 0
         )
       {
         ACE_NEW_RETURN (
           default_proxy,
-          ::IR::FinderDef (
+          ::IR_FinderDef (
             stub,
             1,
             obj->_servant ()),
             
-          FinderDef::_nil ());
+          IR_FinderDef::_nil ());
         }
       if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::FinderDef (stub, 0, obj->_servant ()), FinderDef::_nil ());
+        ACE_NEW_RETURN (default_proxy, ::IR_FinderDef (stub, 0, obj->_servant ()), IR_FinderDef::_nil ());
         return default_proxy;
       }
     else 
       return
         ACE_reinterpret_cast
           (
-            FinderDef_ptr,
+            IR_FinderDef_ptr,
               obj->_tao_QueryInterface
                 (
                   ACE_reinterpret_cast
                     (
                       ptr_arith_t,
-                      &FinderDef::_narrow
+                      &IR_FinderDef::_narrow
                     )
                 )
           );
 }
 
-IR::FinderDef_ptr
-IR::FinderDef::_duplicate (FinderDef_ptr obj)
+IR_FinderDef_ptr
+IR_FinderDef::_duplicate (IR_FinderDef_ptr obj)
 {
   if (!CORBA::is_nil (obj))
     obj->_add_ref ();
   return obj;
 }
 
-CORBA::Boolean IR::FinderDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+CORBA::Boolean IR_FinderDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
   if (
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/FinderDef:1.0")) ||
@@ -52221,46 +28765,46 @@
     return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
 }
 
-void *IR::FinderDef::_tao_QueryInterface (ptr_arith_t type)
+void *IR_FinderDef::_tao_QueryInterface (ptr_arith_t type)
 {
   void *retv = 0;
   if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, FinderDef)::_narrow))
+      &IR_FinderDef::_narrow))
     retv = ACE_reinterpret_cast (void*, this);
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, OperationDef)::_narrow))
+      &IR_OperationDef::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::OperationDef_ptr,
+            IR_OperationDef_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Contained)::_narrow))
+      &IR_Contained::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::Contained_ptr,
+            IR_Contained_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
+      &CORBA_IRObject::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            CORBA::IRObject_ptr,
+            CORBA_IRObject_ptr,
             this
           )
       );
@@ -52273,21 +28817,18 @@
   return retv;
 }
 
-const char* IR::FinderDef::_interface_repository_id (void) const
+const char* IR_FinderDef::_interface_repository_id (void) const
 {
   return "IDL:omg.org/IR/FinderDef:1.0";
 }
 
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-#endif /* TAO_HAS_INTERCEPTORS */
 static const CORBA::Long _oc_IR_FinderDef[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
   29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x696e6465), ACE_NTOHL (0x72446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/FinderDef:1.0
-  10, ACE_NTOHL (0x46696e64), ACE_NTOHL (0x65724465), ACE_NTOHL (0x66000000),  // name = FinderDef
+  10, ACE_NTOHL (0x46696e64), ACE_NTOHL (0x65724465), ACE_NTOHL (0x66000000),  // name = IR_FinderDef
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_FinderDef (CORBA::tk_objref, sizeof (_oc_IR_FinderDef), (char *) &_oc_IR_FinderDef, 0, sizeof (IR::FinderDef));
+static CORBA::TypeCode _tc_TAO_tc_IR_FinderDef (CORBA::tk_objref, sizeof (_oc_IR_FinderDef), (char *) &_oc_IR_FinderDef, 0, sizeof (IR_FinderDef));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
 TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FinderDef, &_tc_TAO_tc_IR_FinderDef)
@@ -52297,15 +28838,15 @@
 //                Base & Remote Proxy  Implementation. 
 //
 
-IR::_TAO_HomeDef_Proxy_Impl::_TAO_HomeDef_Proxy_Impl (void)
+_TAO_HomeDef_Proxy_Impl::_TAO_HomeDef_Proxy_Impl (void)
 {}
 
-IR::_TAO_HomeDef_Remote_Proxy_Impl::_TAO_HomeDef_Remote_Proxy_Impl (void)
+_TAO_HomeDef_Remote_Proxy_Impl::_TAO_HomeDef_Remote_Proxy_Impl (void)
 {}
 
 // Remote Implementation of the IDL interface methods
 
-IR::HomeDef_ptr IR::_TAO_HomeDef_Remote_Proxy_Impl::base_home (
+IR_HomeDef_ptr _TAO_HomeDef_Remote_Proxy_Impl::base_home (
     CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -52314,8 +28855,8 @@
   ))
 {
   
-  IR::HomeDef_ptr _tao_retval = IR::HomeDef::_nil ();
-  IR::HomeDef_var _tao_safe_retval (_tao_retval);
+  IR_HomeDef_ptr _tao_retval = IR_HomeDef::_nil ();
+  IR_HomeDef_var _tao_safe_retval (_tao_retval);
   
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
@@ -52325,147 +28866,57 @@
   
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_get_base_home",
-      14,
-      0,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_base_home_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::HomeDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      "_get_base_home",
+      14,
+      0,
+      istub->orb_core ()
+    );
+
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
         }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
-IR::ComponentDef_ptr IR::_TAO_HomeDef_Remote_Proxy_Impl::managed_component (
+IR_ComponentDef_ptr _TAO_HomeDef_Remote_Proxy_Impl::managed_component (
     CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -52474,8 +28925,8 @@
   ))
 {
   
-  IR::ComponentDef_ptr _tao_retval = IR::ComponentDef::_nil ();
-  IR::ComponentDef_var _tao_safe_retval (_tao_retval);
+  IR_ComponentDef_ptr _tao_retval = IR_ComponentDef::_nil ();
+  IR_ComponentDef_var _tao_safe_retval (_tao_retval);
   
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
@@ -52491,141 +28942,51 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_managed_component_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::ComponentDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
         }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
-IR::PrimaryKeyDef_ptr IR::_TAO_HomeDef_Remote_Proxy_Impl::primary_key (
+IR_PrimaryKeyDef_ptr _TAO_HomeDef_Remote_Proxy_Impl::primary_key (
     CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -52634,8 +28995,8 @@
   ))
 {
   
-  IR::PrimaryKeyDef_ptr _tao_retval = IR::PrimaryKeyDef::_nil ();
-  IR::PrimaryKeyDef_var _tao_safe_retval (_tao_retval);
+  IR_PrimaryKeyDef_ptr _tao_retval = IR_PrimaryKeyDef::_nil ();
+  IR_PrimaryKeyDef_var _tao_safe_retval (_tao_retval);
   
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
@@ -52651,141 +29012,51 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_primary_key_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::PrimaryKeyDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
         }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
-IR::FactoryDefSeq * IR::_TAO_HomeDef_Remote_Proxy_Impl::factories (
+IR_FactoryDefSeq * _TAO_HomeDef_Remote_Proxy_Impl::factories (
     CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -52794,7 +29065,7 @@
   ))
 {
   
-  IR::FactoryDefSeq *_tao_retval = 0;
+  IR_FactoryDefSeq *_tao_retval = 0;
   
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
@@ -52802,8 +29073,8 @@
     ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
   
-  ACE_NEW_RETURN (_tao_retval, IR::FactoryDefSeq, _tao_retval);
-  IR::FactoryDefSeq_var _tao_safe_retval (_tao_retval);
+  ACE_NEW_RETURN (_tao_retval, IR_FactoryDefSeq, _tao_retval);
+  IR_FactoryDefSeq_var _tao_safe_retval (_tao_retval);
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
       "_get_factories",
@@ -52812,141 +29083,51 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_factories_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::FactoryDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
         }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
-IR::FinderDefSeq * IR::_TAO_HomeDef_Remote_Proxy_Impl::finders (
+IR_FinderDefSeq * _TAO_HomeDef_Remote_Proxy_Impl::finders (
     CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -52955,7 +29136,7 @@
   ))
 {
   
-  IR::FinderDefSeq *_tao_retval = 0;
+  IR_FinderDefSeq *_tao_retval = 0;
   
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
@@ -52963,8 +29144,8 @@
     ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
 
   
-  ACE_NEW_RETURN (_tao_retval, IR::FinderDefSeq, _tao_retval);
-  IR::FinderDefSeq_var _tao_safe_retval (_tao_retval);
+  ACE_NEW_RETURN (_tao_retval, IR_FinderDefSeq, _tao_retval);
+  IR_FinderDefSeq_var _tao_safe_retval (_tao_retval);
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
       "_get_finders",
@@ -52973,141 +29154,51 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_finders_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::FinderDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
+        ACE_CHECK_RETURN (0);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              0
+            );
         }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                0
+              );
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
-CORBA::Boolean IR::_TAO_HomeDef_Remote_Proxy_Impl::is_basic (
+CORBA::Boolean _TAO_HomeDef_Remote_Proxy_Impl::is_basic (
     CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
   )
@@ -53132,145 +29223,56 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_is_basic_get ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                _tao_retval
-              );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              CORBA::Boolean  _tao_retval_info = _tao_retval;
-               ri.result (_tao_retval_info);
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
             ACE_TRY_ENV
           );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
+        ACE_CHECK_RETURN  (_tao_retval);
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN  (_tao_retval);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
         {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+              _tao_retval
+            );
         }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN  (_tao_retval);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
+          ))
+          {
+            ACE_THROW_RETURN (
+                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
+                _tao_retval
+              );
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_retval;
 }
 
-IR::PrimaryKeyDef_ptr IR::_TAO_HomeDef_Remote_Proxy_Impl::create_primary_key (
+IR_PrimaryKeyDef_ptr _TAO_HomeDef_Remote_Proxy_Impl::create_primary_key (
     CORBA_Object *_collocated_tao_target_,
     const char * id,
     const char * name,
     const char * version,
-    IR::ValueDef_ptr primary_key,
+    IR_ValueDef_ptr primary_key,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -53278,8 +29280,8 @@
   ))
 {
   
-  IR::PrimaryKeyDef_ptr _tao_retval = IR::PrimaryKeyDef::_nil ();
-  IR::PrimaryKeyDef_var _tao_safe_retval (_tao_retval);
+  IR_PrimaryKeyDef_ptr _tao_retval = IR_PrimaryKeyDef::_nil ();
+  IR_PrimaryKeyDef_var _tao_safe_retval (_tao_retval);
   
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
@@ -53295,164 +29297,70 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_primary_key ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        id,
-        name,
-        version,
-        primary_key,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << id) &&
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << id) &&
               (_tao_out << name) &&
               (_tao_out << version) &&
               (_tao_out << primary_key)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
               0
             );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
                 CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                 0
               );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::PrimaryKeyDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
-IR::FactoryDef_ptr IR::_TAO_HomeDef_Remote_Proxy_Impl::create_factory (
+IR_FactoryDef_ptr _TAO_HomeDef_Remote_Proxy_Impl::create_factory (
     CORBA_Object *_collocated_tao_target_,
     const char * id,
     const char * name,
     const char * version,
-    const IR::ParDescriptionSeq & params,
-    const IR::ExceptionDefSeq & exceptions,
+    const IR_ParDescriptionSeq & params,
+    const IR_ExceptionDefSeq & exceptions,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -53460,8 +29368,8 @@
   ))
 {
   
-  IR::FactoryDef_ptr _tao_retval = IR::FactoryDef::_nil ();
-  IR::FactoryDef_var _tao_safe_retval (_tao_retval);
+  IR_FactoryDef_ptr _tao_retval = IR_FactoryDef::_nil ();
+  IR_FactoryDef_var _tao_safe_retval (_tao_retval);
   
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
@@ -53477,166 +29385,71 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_factory ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        id,
-        name,
-        version,
-        params,
-        exceptions,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << id) &&
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << id) &&
               (_tao_out << name) &&
               (_tao_out << version) &&
               (_tao_out << params) &&
               (_tao_out << exceptions)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
               0
             );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
                 CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                 0
               );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::FactoryDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
-IR::FinderDef_ptr IR::_TAO_HomeDef_Remote_Proxy_Impl::create_finder (
+IR_FinderDef_ptr _TAO_HomeDef_Remote_Proxy_Impl::create_finder (
     CORBA_Object *_collocated_tao_target_,
     const char * id,
     const char * name,
     const char * version,
-    const IR::ParDescriptionSeq & params,
-    const IR::ExceptionDefSeq & exceptions,
+    const IR_ParDescriptionSeq & params,
+    const IR_ExceptionDefSeq & exceptions,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -53644,8 +29457,8 @@
   ))
 {
   
-  IR::FinderDef_ptr _tao_retval = IR::FinderDef::_nil ();
-  IR::FinderDef_var _tao_safe_retval (_tao_retval);
+  IR_FinderDef_ptr _tao_retval = IR_FinderDef::_nil ();
+  IR_FinderDef_var _tao_safe_retval (_tao_retval);
   
   
   TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
@@ -53661,156 +29474,61 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
-      istub->orb_core ()->client_request_interceptors ()
-    );
-  
-#endif  /* TAO_HAS_INTERCEPTORS */
-  
-  for (;;)
-    {
-      int _invoke_status = TAO_INVOKE_EXCEPTION;
-      
-#if TAO_HAS_INTERCEPTORS == 1
-      IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_finder ri (
-        &_tao_call,
-        _collocated_tao_target_,
-        id,
-        name,
-        version,
-        params,
-        exceptions,
-        ACE_TRY_ENV
-      );
-      ACE_CHECK_RETURN (0);
-      
-      ACE_TRY
-        {
-#endif /* TAO_HAS_INTERCEPTORS */
-        
-          _tao_call.start (ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
-          TAO_INTERCEPTOR (ri.response_expected (1));
-          
-          TAO_INTERCEPTOR (
-            _tao_vfr.send_request (
-              &ri,
-              ACE_TRY_ENV
-            )
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          _tao_call.prepare_header (
-              ACE_static_cast (CORBA::Octet, _tao_response_flag),
-              ACE_TRY_ENV
-            );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-          if (!(
-                            (_tao_out << id) &&
+      for (;;)
+      {
+        _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
+        
+        _tao_call.prepare_header (
+            ACE_static_cast (CORBA::Octet, _tao_response_flag),
+            ACE_TRY_ENV
+          );
+        ACE_CHECK_RETURN (0);
+        
+        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
+        if (!(
+              (_tao_out << id) &&
               (_tao_out << name) &&
               (_tao_out << version) &&
               (_tao_out << params) &&
               (_tao_out << exceptions)
-            ))
-            TAO_INTERCEPTOR_THROW_RETURN (
-              CORBA::MARSHAL (),
+          ))
+        ACE_THROW_RETURN (
+            CORBA::MARSHAL (),
+            0
+          );
+      
+        int _invoke_status =
+          _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (0);
+        
+        if (_invoke_status == TAO_INVOKE_RESTART)
+          {
+            _tao_call.restart_flag (1);
+            continue;
+          }
+        if (_invoke_status != TAO_INVOKE_OK)
+        {
+          ACE_THROW_RETURN (
+              CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
               0
             );
-            
-          _invoke_status =
-            _tao_call.invoke (0, 0, ACE_TRY_ENV);
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-          if (_invoke_status == TAO_INVOKE_EXCEPTION)
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
-                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
-                0
-              );
-              
-            }
-          
-          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-          if (!(
-                            (_tao_in >> _tao_safe_retval.inout ())
-              ))
-            {
-              TAO_INTERCEPTOR_THROW_RETURN (
+        }
+        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+        if (!(
+              (_tao_in >> _tao_safe_retval.inout ())
+          ))
+          {
+            ACE_THROW_RETURN (
                 CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                 0
               );
-              
-            }
-          
-          TAO_INTERCEPTOR (
-              IR::FinderDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
-              ri.result (_tao_retval_info);
-              _tao_safe_retval = _tao_retval_info;
-            );
-          
-          TAO_INTERCEPTOR (
-            ri.reply_status (_invoke_status);
-            if (_invoke_status == TAO_INVOKE_OK)
-              {
-                _tao_vfr.receive_reply (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            else
-              {
-                _tao_vfr.receive_other (
-                  &ri,
-                  ACE_TRY_ENV
-                );
-              }
-            
-          );
-          TAO_INTERCEPTOR_CHECK_RETURN (0);
-          
-#if TAO_HAS_INTERCEPTORS == 1
-        }
-      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
-        {
-          _invoke_status =
-            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
-          ACE_TRY_CHECK;
-          
-          ri.forward_reference (exc); 
-          _tao_vfr.receive_other (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-        }
-      ACE_CATCHANY
-        {
-          ri.exception (&ACE_ANY_EXCEPTION);
-          _tao_vfr.receive_exception (
-            &ri,
-            ACE_TRY_ENV
-          );
-          ACE_TRY_CHECK;
-          ACE_RE_THROW;
-        }
-      ACE_ENDTRY;
-      ACE_CHECK_RETURN (0);
-      
-#endif /* TAO_HAS_INTERCEPTORS */
+          }
+        break;
+      }
 
-      if (_invoke_status == TAO_INVOKE_RESTART)
-        {
-          _tao_call.restart_flag (1);
-          continue;
-        }
-      
-      break;
-    }
   return _tao_safe_retval._retn ();
 }
 
@@ -53824,32 +29542,32 @@
 //           Remote & Base  Proxy Broker Implementation
 //
 
-IR::_TAO_HomeDef_Proxy_Broker::_TAO_HomeDef_Proxy_Broker (void)
+_TAO_HomeDef_Proxy_Broker::_TAO_HomeDef_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_HomeDef_Proxy_Broker::~_TAO_HomeDef_Proxy_Broker (void)
+_TAO_HomeDef_Proxy_Broker::~_TAO_HomeDef_Proxy_Broker (void)
 {
 }
 
-// Factory Member function Implementation.
-IR::_TAO_HomeDef_Remote_Proxy_Broker *IR::_TAO_HomeDef_Remote_Proxy_Broker::the_TAO_HomeDef_Remote_Proxy_Broker (void)
+// Factory function Implementation.
+_TAO_HomeDef_Remote_Proxy_Broker *the_TAO_HomeDef_Remote_Proxy_Broker (void)
 {
-  static ::IR::_TAO_HomeDef_Remote_Proxy_Broker remote_proxy_broker;
+  static ::_TAO_HomeDef_Remote_Proxy_Broker remote_proxy_broker;
   return &remote_proxy_broker;
 }
 
-IR::_TAO_HomeDef_Remote_Proxy_Broker::_TAO_HomeDef_Remote_Proxy_Broker (void)
+_TAO_HomeDef_Remote_Proxy_Broker::_TAO_HomeDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_HomeDef_Remote_Proxy_Broker::~_TAO_HomeDef_Remote_Proxy_Broker (void)
+_TAO_HomeDef_Remote_Proxy_Broker::~_TAO_HomeDef_Remote_Proxy_Broker (void)
 {
 }
 
-IR::_TAO_HomeDef_Proxy_Impl&
-IR::_TAO_HomeDef_Remote_Proxy_Broker::select_proxy (
-  ::IR::HomeDef *object,
+_TAO_HomeDef_Proxy_Impl&
+_TAO_HomeDef_Remote_Proxy_Broker::select_proxy (
+  ::IR_HomeDef *object,
   CORBA::Environment &ACE_TRY_ENV
 )
 {
@@ -53865,109 +29583,110 @@
 
 
 // default constructor
-IR::HomeDef::HomeDef (int collocated)
+IR_HomeDef::IR_HomeDef (int collocated)
 {
   this->_tao_setup_collocation (collocated);
 }
 
 // destructor
-IR::HomeDef::~HomeDef (void)
+IR_HomeDef::~IR_HomeDef (void)
 {}
 
 void
-IR::HomeDef::_tao_setup_collocation (int collocated)
+IR_HomeDef::_tao_setup_collocation (int collocated)
 {
   if (collocated)
     this->the_TAO_HomeDef_Proxy_Broker_ =
-      ::IR__TAO_HomeDef_Proxy_Broker_Factory_function_pointer (this);
+      _TAO_HomeDef_Proxy_Broker_Factory_function_pointer (this);
   else
     this->the_TAO_HomeDef_Proxy_Broker_ =
-      ::IR::_TAO_HomeDef_Remote_Proxy_Broker::the_TAO_HomeDef_Remote_Proxy_Broker ();
+      ::the_TAO_HomeDef_Remote_Proxy_Broker ();
+  
+  IR_InterfaceDef::_tao_setup_collocation (collocated);
   
-  ACE_NESTED_CLASS (IR, InterfaceDef)::_tao_setup_collocation (collocated);
 }
 
-void IR::HomeDef::_tao_any_destructor (void *x)
+void IR_HomeDef::_tao_any_destructor (void *x)
 {
-  HomeDef *tmp = ACE_static_cast (HomeDef*,x);
+  IR_HomeDef *tmp = ACE_static_cast (IR_HomeDef*,x);
   CORBA::release (tmp);
 }
 
-IR::HomeDef_ptr IR::HomeDef::_narrow (
+IR_HomeDef_ptr IR_HomeDef::_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
 {
   if (CORBA::is_nil (obj))
-    return HomeDef::_nil ();
+    return IR_HomeDef::_nil ();
   if (! obj->_is_local ())
     {
       CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/HomeDef:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (HomeDef::_nil ());
+      ACE_CHECK_RETURN (IR_HomeDef::_nil ());
       if (is_a == 0)
-        return HomeDef::_nil ();
+        return IR_HomeDef::_nil ();
     }
-  return HomeDef::_unchecked_narrow (obj, ACE_TRY_ENV);
+  return IR_HomeDef::_unchecked_narrow (obj, ACE_TRY_ENV);
 }
 
-IR::HomeDef_ptr IR::HomeDef::_unchecked_narrow (
+IR_HomeDef_ptr IR_HomeDef::_unchecked_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &
   )
 {
   if (CORBA::is_nil (obj))
-    return HomeDef::_nil ();
+    return IR_HomeDef::_nil ();
   if (! obj->_is_local ())
     {
       TAO_Stub* stub = obj->_stubobj ();
       if (stub)
         stub->_incr_refcnt ();
-      HomeDef_ptr default_proxy = HomeDef::_nil ();
+      IR_HomeDef_ptr default_proxy = IR_HomeDef::_nil ();
 
       if (
           !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
           stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
-          obj->_is_collocated () &&IR__TAO_HomeDef_Proxy_Broker_Factory_function_pointer != 0
+          obj->_is_collocated () &&_TAO_HomeDef_Proxy_Broker_Factory_function_pointer != 0
         )
       {
         ACE_NEW_RETURN (
           default_proxy,
-          ::IR::HomeDef (
+          ::IR_HomeDef (
             stub,
             1,
             obj->_servant ()),
             
-          HomeDef::_nil ());
+          IR_HomeDef::_nil ());
         }
       if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, ::IR::HomeDef (stub, 0, obj->_servant ()), HomeDef::_nil ());
+        ACE_NEW_RETURN (default_proxy, ::IR_HomeDef (stub, 0, obj->_servant ()), IR_HomeDef::_nil ());
         return default_proxy;
       }
     else 
       return
         ACE_reinterpret_cast
           (
-            HomeDef_ptr,
+            IR_HomeDef_ptr,
               obj->_tao_QueryInterface
                 (
                   ACE_reinterpret_cast
                     (
                       ptr_arith_t,
-                      &HomeDef::_narrow
+                      &IR_HomeDef::_narrow
                     )
                 )
           );
 }
 
-IR::HomeDef_ptr
-IR::HomeDef::_duplicate (HomeDef_ptr obj)
+IR_HomeDef_ptr
+IR_HomeDef::_duplicate (IR_HomeDef_ptr obj)
 {
   if (!CORBA::is_nil (obj))
     obj->_add_ref ();
   return obj;
 }
 
-CORBA::Boolean IR::HomeDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+CORBA::Boolean IR_HomeDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
   if (
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/HomeDef:1.0")) ||
@@ -53982,70 +29701,70 @@
     return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
 }
 
-void *IR::HomeDef::_tao_QueryInterface (ptr_arith_t type)
+void *IR_HomeDef::_tao_QueryInterface (ptr_arith_t type)
 {
   void *retv = 0;
   if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, HomeDef)::_narrow))
+      &IR_HomeDef::_narrow))
     retv = ACE_reinterpret_cast (void*, this);
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, InterfaceDef)::_narrow))
+      &IR_InterfaceDef::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::InterfaceDef_ptr,
+            IR_InterfaceDef_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Container)::_narrow))
+      &IR_Container::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::Container_ptr,
+            IR_Container_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, Contained)::_narrow))
+      &IR_Contained::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::Contained_ptr,
+            IR_Contained_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &ACE_NESTED_CLASS (::IR, IDLType)::_narrow))
+      &IR_IDLType::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            IR::IDLType_ptr,
+            IR_IDLType_ptr,
             this
           )
       );
   else if (type == ACE_reinterpret_cast
     (ptr_arith_t,
-      &::CORBA::IRObject::_narrow))
+      &CORBA_IRObject::_narrow))
     retv = ACE_reinterpret_cast
       (
         void *,
         ACE_static_cast
           (
-            CORBA::IRObject_ptr,
+            CORBA_IRObject_ptr,
             this
           )
       );
@@ -54058,12 +29777,12 @@
   return retv;
 }
 
-const char* IR::HomeDef::_interface_repository_id (void) const
+const char* IR_HomeDef::_interface_repository_id (void) const
 {
   return "IDL:omg.org/IR/HomeDef:1.0";
 }
 
-IR::HomeDef_ptr IR::HomeDef::base_home (
+IR_HomeDef_ptr IR_HomeDef::base_home (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -54077,7 +29796,7 @@
     );
 }
 
-IR::ComponentDef_ptr IR::HomeDef::managed_component (
+IR_ComponentDef_ptr IR_HomeDef::managed_component (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -54091,7 +29810,7 @@
     );
 }
 
-IR::PrimaryKeyDef_ptr IR::HomeDef::primary_key (
+IR_PrimaryKeyDef_ptr IR_HomeDef::primary_key (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -54105,7 +29824,7 @@
     );
 }
 
-IR::FactoryDefSeq * IR::HomeDef::factories (
+IR_FactoryDefSeq * IR_HomeDef::factories (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -54119,7 +29838,7 @@
     );
 }
 
-IR::FinderDefSeq * IR::HomeDef::finders (
+IR_FinderDefSeq * IR_HomeDef::finders (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -54133,7 +29852,7 @@
     );
 }
 
-CORBA::Boolean IR::HomeDef::is_basic (
+CORBA::Boolean IR_HomeDef::is_basic (
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -54147,11 +29866,11 @@
     );
 }
 
-IR::PrimaryKeyDef_ptr IR::HomeDef::create_primary_key (
+IR_PrimaryKeyDef_ptr IR_HomeDef::create_primary_key (
     const char * id,
     const char * name,
     const char * version,
-    IR::ValueDef_ptr primary_key,
+    IR_ValueDef_ptr primary_key,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -54169,12 +29888,12 @@
     );
 }
 
-IR::FactoryDef_ptr IR::HomeDef::create_factory (
+IR_FactoryDef_ptr IR_HomeDef::create_factory (
     const char * id,
     const char * name,
     const char * version,
-    const IR::ParDescriptionSeq & params,
-    const IR::ExceptionDefSeq & exceptions,
+    const IR_ParDescriptionSeq & params,
+    const IR_ExceptionDefSeq & exceptions,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -54193,12 +29912,12 @@
     );
 }
 
-IR::FinderDef_ptr IR::HomeDef::create_finder (
+IR_FinderDef_ptr IR_HomeDef::create_finder (
     const char * id,
     const char * name,
     const char * version,
-    const IR::ParDescriptionSeq & params,
-    const IR::ExceptionDefSeq & exceptions,
+    const IR_ParDescriptionSeq & params,
+    const IR_ExceptionDefSeq & exceptions,
     CORBA::Environment &ACE_TRY_ENV
   )
   ACE_THROW_SPEC ((
@@ -54217,633 +29936,18 @@
     );
 }
 
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_base_home_get::TAO_ClientRequestInfo_IR_HomeDef_base_home_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_base_home_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_base_home_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_base_home_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_base_home_get::result (IR::HomeDef_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_managed_component_get::TAO_ClientRequestInfo_IR_HomeDef_managed_component_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_managed_component_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_managed_component_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_managed_component_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_managed_component_get::result (IR::ComponentDef_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_primary_key_get::TAO_ClientRequestInfo_IR_HomeDef_primary_key_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_primary_key_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_primary_key_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_primary_key_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_primary_key_get::result (IR::PrimaryKeyDef_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_factories_get::TAO_ClientRequestInfo_IR_HomeDef_factories_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_factories_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_factories_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_factories_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_factories_get::result (IR::FactoryDefSeq * result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_finders_get::TAO_ClientRequestInfo_IR_HomeDef_finders_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_finders_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_finders_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_finders_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_finders_get::result (IR::FinderDefSeq * result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_is_basic_get::TAO_ClientRequestInfo_IR_HomeDef_is_basic_get (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
-{}
-
-Dynamic::ParameterList *
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_is_basic_get::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return parameter_list;
-}
-
-Dynamic::ExceptionList *
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_is_basic_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_is_basic_get::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
-  return safe_result_any._retn ();
-}
-
-void 
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_is_basic_get::result (CORBA::Boolean result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_primary_key::TAO_ClientRequestInfo_IR_HomeDef_create_primary_key (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * id,
-    const char * name,
-    const char * version,
-    IR::ValueDef_ptr primary_key,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    id_ (id),
-    name_ (name),
-    version_ (version),
-    primary_key_ (primary_key)
-{}
-
-Dynamic::ParameterList *
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_primary_key::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_id = parameter_list->length ();
-  parameter_list->length (length_id + 1);
-  (*parameter_list)[length_id].argument <<= id_;
-  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_name = parameter_list->length ();
-  parameter_list->length (length_name + 1);
-  (*parameter_list)[length_name].argument <<= name_;
-  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_version = parameter_list->length ();
-  parameter_list->length (length_version + 1);
-  (*parameter_list)[length_version].argument <<= version_;
-  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_primary_key = parameter_list->length ();
-  parameter_list->length (length_primary_key + 1);
-  (*parameter_list)[length_primary_key].argument <<=  this->primary_key_;
-  
-  (*parameter_list)[length_primary_key].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_primary_key::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_primary_key::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_primary_key::result (IR::PrimaryKeyDef_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_factory::TAO_ClientRequestInfo_IR_HomeDef_create_factory (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * id,
-    const char * name,
-    const char * version,
-    const IR::ParDescriptionSeq & params,
-    const IR::ExceptionDefSeq & exceptions,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    id_ (id),
-    name_ (name),
-    version_ (version),
-    params_ (params),
-    exceptions_ (exceptions)
-{}
-
-Dynamic::ParameterList *
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_factory::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_id = parameter_list->length ();
-  parameter_list->length (length_id + 1);
-  (*parameter_list)[length_id].argument <<= id_;
-  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_name = parameter_list->length ();
-  parameter_list->length (length_name + 1);
-  (*parameter_list)[length_name].argument <<= name_;
-  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_version = parameter_list->length ();
-  parameter_list->length (length_version + 1);
-  (*parameter_list)[length_version].argument <<= version_;
-  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_params = parameter_list->length ();
-  parameter_list->length (length_params + 1);
-  (*parameter_list)[length_params].argument <<=  this->params_;
-  
-  (*parameter_list)[length_params].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_exceptions = parameter_list->length ();
-  parameter_list->length (length_exceptions + 1);
-  (*parameter_list)[length_exceptions].argument <<=  this->exceptions_;
-  
-  (*parameter_list)[length_exceptions].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_factory::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_factory::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_factory::result (IR::FactoryDef_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_finder::TAO_ClientRequestInfo_IR_HomeDef_create_finder (
-    TAO_GIOP_Invocation *_tao_invocation,
-    CORBA::Object_ptr _tao_target,
-    const char * id,
-    const char * name,
-    const char * version,
-    const IR::ParDescriptionSeq & params,
-    const IR::ExceptionDefSeq & exceptions,
-    CORBA::Environment &    
-  )
-  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
-    id_ (id),
-    name_ (name),
-    version_ (version),
-    params_ (params),
-    exceptions_ (exceptions)
-{}
-
-Dynamic::ParameterList *
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_finder::arguments (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the argument list on demand.
-  Dynamic::ParameterList *parameter_list =
-    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
-    
-  CORBA::ULong length_id = parameter_list->length ();
-  parameter_list->length (length_id + 1);
-  (*parameter_list)[length_id].argument <<= id_;
-  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_name = parameter_list->length ();
-  parameter_list->length (length_name + 1);
-  (*parameter_list)[length_name].argument <<= name_;
-  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_version = parameter_list->length ();
-  parameter_list->length (length_version + 1);
-  (*parameter_list)[length_version].argument <<= version_;
-  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_params = parameter_list->length ();
-  parameter_list->length (length_params + 1);
-  (*parameter_list)[length_params].argument <<=  this->params_;
-  
-  (*parameter_list)[length_params].mode = Dynamic::PARAM_IN;
-    
-  CORBA::ULong length_exceptions = parameter_list->length ();
-  parameter_list->length (length_exceptions + 1);
-  (*parameter_list)[length_exceptions].argument <<=  this->exceptions_;
-  
-  (*parameter_list)[length_exceptions].mode = Dynamic::PARAM_IN;
-  
-  return safe_parameter_list._retn ();
-}
-
-Dynamic::ExceptionList *
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_finder::exceptions (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the exception list on demand.
-  Dynamic::ExceptionList *exception_list =
-    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  return exception_list;
-}
-
-
-CORBA::Any * 
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_finder::result (CORBA::Environment &ACE_TRY_ENV)
-  ACE_THROW_SPEC ((CORBA::SystemException))
-{
-  // Generate the result on demand.
-  CORBA::Boolean tk_void_any = 0;
-  CORBA::Any *result_any =
-    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
-  ACE_CHECK_RETURN (0);
-  
-  CORBA::Any_var safe_result_any = result_any;
-  
-  (*result_any) <<= this->_result;
-  return safe_result_any._retn ();
-}
-
-void 
-IR::HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_finder::result (IR::FinderDef_ptr result)
-{
-  // update the result 
-  this->_result = result;
-}
-
-#endif /* TAO_HAS_INTERCEPTORS */
 static const CORBA::Long _oc_IR_HomeDef[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
   27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f48), ACE_NTOHL (0x6f6d6544), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/HomeDef:1.0
-  8, ACE_NTOHL (0x486f6d65), ACE_NTOHL (0x44656600),  // name = HomeDef
+  8, ACE_NTOHL (0x486f6d65), ACE_NTOHL (0x44656600),  // name = IR_HomeDef
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_HomeDef (CORBA::tk_objref, sizeof (_oc_IR_HomeDef), (char *) &_oc_IR_HomeDef, 0, sizeof (IR::HomeDef));
+static CORBA::TypeCode _tc_TAO_tc_IR_HomeDef (CORBA::tk_objref, sizeof (_oc_IR_HomeDef), (char *) &_oc_IR_HomeDef, 0, sizeof (IR_HomeDef));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
 TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_HomeDef, &_tc_TAO_tc_IR_HomeDef)
 TAO_NAMESPACE_END
+
 static const CORBA::Long _oc_IR_HomeDescription[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
@@ -54909,14 +30013,14 @@
   64, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
     33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x72696d61), ACE_NTOHL (0x72794b65), ACE_NTOHL (0x79446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/PrimaryKeyDef:1.0
-    14, ACE_NTOHL (0x5072696d), ACE_NTOHL (0x6172794b), ACE_NTOHL (0x65794465), ACE_NTOHL (0x66000000),  // name = PrimaryKeyDef
+    14, ACE_NTOHL (0x5072696d), ACE_NTOHL (0x6172794b), ACE_NTOHL (0x65794465), ACE_NTOHL (0x66000000),  // name = IR_PrimaryKeyDef
 
   10, ACE_NTOHL (0x66616374), ACE_NTOHL (0x6f726965), ACE_NTOHL (0x73000000),  // name = factories
   CORBA::tk_alias, // typecode kind for typedefs
   144, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
     33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x6163746f), ACE_NTOHL (0x72794465), ACE_NTOHL (0x66536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/FactoryDefSeq:1.0
-    14, ACE_NTOHL (0x46616374), ACE_NTOHL (0x6f727944), ACE_NTOHL (0x65665365), ACE_NTOHL (0x71000000),  // name = FactoryDefSeq
+    14, ACE_NTOHL (0x46616374), ACE_NTOHL (0x6f727944), ACE_NTOHL (0x65665365), ACE_NTOHL (0x71000000),  // name = IR_FactoryDefSeq
     CORBA::tk_sequence, // typecode kind
     72, // encapsulation length
       TAO_ENCAP_BYTE_ORDER, // byte order
@@ -54924,7 +30028,7 @@
       56, // encapsulation length
         TAO_ENCAP_BYTE_ORDER, // byte order
         30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x6163746f), ACE_NTOHL (0x72794465), ACE_NTOHL (0x663a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/FactoryDef:1.0
-        11, ACE_NTOHL (0x46616374), ACE_NTOHL (0x6f727944), ACE_NTOHL (0x65660000),  // name = FactoryDef
+        11, ACE_NTOHL (0x46616374), ACE_NTOHL (0x6f727944), ACE_NTOHL (0x65660000),  // name = IR_FactoryDef
 
       0U,
 
@@ -54934,7 +30038,7 @@
   140, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
     32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x696e6465), ACE_NTOHL (0x72446566), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/FinderDefSeq:1.0
-    13, ACE_NTOHL (0x46696e64), ACE_NTOHL (0x65724465), ACE_NTOHL (0x66536571), ACE_NTOHL (0x0),  // name = FinderDefSeq
+    13, ACE_NTOHL (0x46696e64), ACE_NTOHL (0x65724465), ACE_NTOHL (0x66536571), ACE_NTOHL (0x0),  // name = IR_FinderDefSeq
     CORBA::tk_sequence, // typecode kind
     72, // encapsulation length
       TAO_ENCAP_BYTE_ORDER, // byte order
@@ -54942,7 +30046,7 @@
       56, // encapsulation length
         TAO_ENCAP_BYTE_ORDER, // byte order
         29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x696e6465), ACE_NTOHL (0x72446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/FinderDef:1.0
-        10, ACE_NTOHL (0x46696e64), ACE_NTOHL (0x65724465), ACE_NTOHL (0x66000000),  // name = FinderDef
+        10, ACE_NTOHL (0x46696e64), ACE_NTOHL (0x65724465), ACE_NTOHL (0x66000000),  // name = IR_FinderDef
 
       0U,
 
@@ -55069,7 +30173,7 @@
               48, // encapsulation length
                 TAO_ENCAP_BYTE_ORDER, // byte order
                 27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
-                8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType
+                8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType
 
               5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
               CORBA::tk_enum, // typecode kind
@@ -55336,18 +30440,19 @@
   CORBA::tk_boolean,
 
 };
-static CORBA::TypeCode _tc_TAO_tc_IR_HomeDescription (CORBA::tk_struct, sizeof (_oc_IR_HomeDescription), (char *) &_oc_IR_HomeDescription, 0, sizeof (IR::HomeDescription));
+static CORBA::TypeCode _tc_TAO_tc_IR_HomeDescription (CORBA::tk_struct, sizeof (_oc_IR_HomeDescription), (char *) &_oc_IR_HomeDescription, 0, sizeof (IR_HomeDescription));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (IR)
 TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_HomeDescription, &_tc_TAO_tc_IR_HomeDescription)
 TAO_NAMESPACE_END
-void IR::HomeDescription::_tao_any_destructor (void *x)
+
+void IR_HomeDescription::_tao_any_destructor (void *x)
 {
-  HomeDescription *tmp = ACE_static_cast (HomeDescription*,x);
+  IR_HomeDescription *tmp = ACE_static_cast (IR_HomeDescription*,x);
   delete tmp;
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::DefinitionKind _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_DefinitionKind _tao_elem)
 {
   TAO_OutputCDR stream;
   stream << _tao_elem;
@@ -55358,7 +30463,7 @@
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::DefinitionKind &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_DefinitionKind &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
@@ -55385,11 +30490,11 @@
   return 0;
 }
 
-CORBA::_TAO_IRObject_Proxy_Broker * (*CORBA__TAO_IRObject_Proxy_Broker_Factory_function_pointer) (
+_TAO_IRObject_Proxy_Broker * (*_TAO_IRObject_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, CORBA::IRObject_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, CORBA_IRObject_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -55399,17 +30504,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        CORBA::IRObject::_duplicate (_tao_elem),
-        CORBA::IRObject::_tao_any_destructor
+        CORBA_IRObject::_duplicate (_tao_elem),
+        CORBA_IRObject::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::IRObject_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_IRObject_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = CORBA::IRObject::_nil ();
+    _tao_elem = CORBA_IRObject::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (CORBA::_tc_IRObject, ACE_TRY_ENV)) // not equal
       {
@@ -55426,33 +30531,33 @@
           CORBA::_tc_IRObject,
           1,
           _tao_elem,
-          CORBA::IRObject::_tao_any_destructor
+          CORBA_IRObject::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = CORBA::IRObject::_nil ();
+    _tao_elem = CORBA_IRObject::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = CORBA::IRObject::_nil ();
+  _tao_elem = CORBA_IRObject::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<CORBA::IRObject,CORBA::IRObject_var>;
+    template class TAO_Object_Manager<CORBA_IRObject,CORBA::IRObject_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<CORBA::IRObject,CORBA::IRObject_var>
+  #  pragma instantiate TAO_Object_Manager<CORBA_IRObject,CORBA::IRObject_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-IR::_TAO_Contained_Proxy_Broker * (*IR__TAO_Contained_Proxy_Broker_Factory_function_pointer) (
+_TAO_Contained_Proxy_Broker * (*_TAO_Contained_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::Contained_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_Contained_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -55462,17 +30567,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::Contained::_duplicate (_tao_elem),
-        IR::Contained::_tao_any_destructor
+        IR_Contained::_duplicate (_tao_elem),
+        IR_Contained::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::Contained_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_Contained_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::Contained::_nil ();
+    _tao_elem = IR_Contained::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_Contained, ACE_TRY_ENV)) // not equal
       {
@@ -55489,65 +30594,65 @@
           IR::_tc_Contained,
           1,
           _tao_elem,
-          IR::Contained::_tao_any_destructor
+          IR_Contained::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::Contained::_nil ();
+    _tao_elem = IR_Contained::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::Contained::_nil ();
+  _tao_elem = IR_Contained::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::Contained,IR::Contained_var>;
+    template class TAO_Object_Manager<IR_Contained,IR_Contained_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::Contained,IR::Contained_var>
+  #  pragma instantiate TAO_Object_Manager<IR_Contained,IR_Contained_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-void operator<<= (CORBA::Any &_tao_any, const IR::Contained::Description &_tao_elem) // copying
+void operator<<= (CORBA::Any &_tao_any, const IR_Contained::Description &_tao_elem) // copying
 {
   TAO_OutputCDR stream;
   stream << _tao_elem;
   _tao_any._tao_replace (
-      IR::Contained::_tc_Description,
+      IR_Contained::_tc_Description,
       TAO_ENCAP_BYTE_ORDER,
       stream.begin ()
     );
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::Contained::Description *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_Contained::Description *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
   _tao_any._tao_replace (
-      IR::Contained::_tc_Description,
+      IR_Contained::_tc_Description,
       TAO_ENCAP_BYTE_ORDER,
       stream.begin (),
       1,
       _tao_elem,
-      IR::Contained::Description::_tao_any_destructor
+      IR_Contained::Description::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::Contained::Description *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_Contained::Description *&_tao_elem)
 {
-  return _tao_any >>= ACE_const_cast(const IR::Contained::Description*&,_tao_elem);
+  return _tao_any >>= ACE_const_cast(const IR_Contained::Description*&,_tao_elem);
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::Contained::Description *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_Contained::Description *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
   {
     CORBA::TypeCode_var type = _tao_any.type ();
-    if (!type->equivalent (IR::Contained::_tc_Description, ACE_TRY_ENV)) // not equal
+    if (!type->equivalent (IR_Contained::_tc_Description, ACE_TRY_ENV)) // not equal
       {
         return 0;
       }
@@ -55555,15 +30660,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::Contained::Description*,
+          const IR_Contained::Description*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::Contained::Description *tmp;
-      ACE_NEW_RETURN (tmp, IR::Contained::Description, 0);
+      IR_Contained::Description *tmp;
+      ACE_NEW_RETURN (tmp, IR_Contained::Description, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -55571,10 +30676,10 @@
       if (stream >> *tmp)
       {
         ((CORBA::Any *)&_tao_any)->_tao_replace (
-            IR::Contained::_tc_Description,
+            IR_Contained::_tc_Description,
             1,
             ACE_static_cast (void *, tmp),
-            IR::Contained::Description::_tao_any_destructor
+            IR_Contained::Description::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -55594,7 +30699,7 @@
 
 void operator<<= (
     CORBA::Any &_tao_any,
-    const IR::InterfaceDefSeq &_tao_elem
+    const IR_InterfaceDefSeq &_tao_elem
   ) // copying
 {
   TAO_OutputCDR stream;
@@ -55608,7 +30713,7 @@
   }
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::InterfaceDefSeq *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_InterfaceDefSeq *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -55618,19 +30723,19 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::InterfaceDefSeq::_tao_any_destructor
+      IR_InterfaceDefSeq::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::InterfaceDefSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_InterfaceDefSeq *&_tao_elem)
 {
   return _tao_any >>= ACE_const_cast(
-      const IR::InterfaceDefSeq*&,
+      const IR_InterfaceDefSeq*&,
       _tao_elem
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::InterfaceDefSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_InterfaceDefSeq *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -55644,15 +30749,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::InterfaceDefSeq*,
+          const IR_InterfaceDefSeq*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::InterfaceDefSeq *tmp;
-      ACE_NEW_RETURN (tmp, IR::InterfaceDefSeq, 0);
+      IR_InterfaceDefSeq *tmp;
+      ACE_NEW_RETURN (tmp, IR_InterfaceDefSeq, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -55663,7 +30768,7 @@
             IR::_tc_InterfaceDefSeq,
             1,
             ACE_static_cast (void *, tmp),
-            IR::InterfaceDefSeq::_tao_any_destructor
+            IR_InterfaceDefSeq::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -55683,7 +30788,7 @@
 
 void operator<<= (
     CORBA::Any &_tao_any,
-    const IR::ValueDefSeq &_tao_elem
+    const IR_ValueDefSeq &_tao_elem
   ) // copying
 {
   TAO_OutputCDR stream;
@@ -55697,7 +30802,7 @@
   }
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::ValueDefSeq *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_ValueDefSeq *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -55707,19 +30812,19 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::ValueDefSeq::_tao_any_destructor
+      IR_ValueDefSeq::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ValueDefSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ValueDefSeq *&_tao_elem)
 {
   return _tao_any >>= ACE_const_cast(
-      const IR::ValueDefSeq*&,
+      const IR_ValueDefSeq*&,
       _tao_elem
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ValueDefSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ValueDefSeq *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -55733,15 +30838,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::ValueDefSeq*,
+          const IR_ValueDefSeq*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::ValueDefSeq *tmp;
-      ACE_NEW_RETURN (tmp, IR::ValueDefSeq, 0);
+      IR_ValueDefSeq *tmp;
+      ACE_NEW_RETURN (tmp, IR_ValueDefSeq, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -55752,7 +30857,7 @@
             IR::_tc_ValueDefSeq,
             1,
             ACE_static_cast (void *, tmp),
-            IR::ValueDefSeq::_tao_any_destructor
+            IR_ValueDefSeq::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -55772,7 +30877,7 @@
 
 void operator<<= (
     CORBA::Any &_tao_any,
-    const IR::ComponentDefSeq &_tao_elem
+    const IR_ComponentDefSeq &_tao_elem
   ) // copying
 {
   TAO_OutputCDR stream;
@@ -55786,7 +30891,7 @@
   }
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::ComponentDefSeq *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_ComponentDefSeq *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -55796,19 +30901,19 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::ComponentDefSeq::_tao_any_destructor
+      IR_ComponentDefSeq::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ComponentDefSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ComponentDefSeq *&_tao_elem)
 {
   return _tao_any >>= ACE_const_cast(
-      const IR::ComponentDefSeq*&,
+      const IR_ComponentDefSeq*&,
       _tao_elem
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ComponentDefSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ComponentDefSeq *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -55822,15 +30927,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::ComponentDefSeq*,
+          const IR_ComponentDefSeq*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::ComponentDefSeq *tmp;
-      ACE_NEW_RETURN (tmp, IR::ComponentDefSeq, 0);
+      IR_ComponentDefSeq *tmp;
+      ACE_NEW_RETURN (tmp, IR_ComponentDefSeq, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -55841,7 +30946,7 @@
             IR::_tc_ComponentDefSeq,
             1,
             ACE_static_cast (void *, tmp),
-            IR::ComponentDefSeq::_tao_any_destructor
+            IR_ComponentDefSeq::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -55861,7 +30966,7 @@
 
 void operator<<= (
     CORBA::Any &_tao_any,
-    const IR::ProvidesDefSeq &_tao_elem
+    const IR_ProvidesDefSeq &_tao_elem
   ) // copying
 {
   TAO_OutputCDR stream;
@@ -55875,7 +30980,7 @@
   }
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::ProvidesDefSeq *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_ProvidesDefSeq *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -55885,19 +30990,19 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::ProvidesDefSeq::_tao_any_destructor
+      IR_ProvidesDefSeq::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ProvidesDefSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ProvidesDefSeq *&_tao_elem)
 {
   return _tao_any >>= ACE_const_cast(
-      const IR::ProvidesDefSeq*&,
+      const IR_ProvidesDefSeq*&,
       _tao_elem
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ProvidesDefSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ProvidesDefSeq *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -55911,15 +31016,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::ProvidesDefSeq*,
+          const IR_ProvidesDefSeq*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::ProvidesDefSeq *tmp;
-      ACE_NEW_RETURN (tmp, IR::ProvidesDefSeq, 0);
+      IR_ProvidesDefSeq *tmp;
+      ACE_NEW_RETURN (tmp, IR_ProvidesDefSeq, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -55930,7 +31035,7 @@
             IR::_tc_ProvidesDefSeq,
             1,
             ACE_static_cast (void *, tmp),
-            IR::ProvidesDefSeq::_tao_any_destructor
+            IR_ProvidesDefSeq::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -55950,7 +31055,7 @@
 
 void operator<<= (
     CORBA::Any &_tao_any,
-    const IR::UsesDefSeq &_tao_elem
+    const IR_UsesDefSeq &_tao_elem
   ) // copying
 {
   TAO_OutputCDR stream;
@@ -55964,7 +31069,7 @@
   }
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::UsesDefSeq *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_UsesDefSeq *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -55974,19 +31079,19 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::UsesDefSeq::_tao_any_destructor
+      IR_UsesDefSeq::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::UsesDefSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_UsesDefSeq *&_tao_elem)
 {
   return _tao_any >>= ACE_const_cast(
-      const IR::UsesDefSeq*&,
+      const IR_UsesDefSeq*&,
       _tao_elem
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::UsesDefSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_UsesDefSeq *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -56000,15 +31105,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::UsesDefSeq*,
+          const IR_UsesDefSeq*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::UsesDefSeq *tmp;
-      ACE_NEW_RETURN (tmp, IR::UsesDefSeq, 0);
+      IR_UsesDefSeq *tmp;
+      ACE_NEW_RETURN (tmp, IR_UsesDefSeq, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -56019,7 +31124,7 @@
             IR::_tc_UsesDefSeq,
             1,
             ACE_static_cast (void *, tmp),
-            IR::UsesDefSeq::_tao_any_destructor
+            IR_UsesDefSeq::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -56039,7 +31144,7 @@
 
 void operator<<= (
     CORBA::Any &_tao_any,
-    const IR::HomeDefSeq &_tao_elem
+    const IR_HomeDefSeq &_tao_elem
   ) // copying
 {
   TAO_OutputCDR stream;
@@ -56053,7 +31158,7 @@
   }
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::HomeDefSeq *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_HomeDefSeq *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -56063,19 +31168,19 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::HomeDefSeq::_tao_any_destructor
+      IR_HomeDefSeq::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::HomeDefSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_HomeDefSeq *&_tao_elem)
 {
   return _tao_any >>= ACE_const_cast(
-      const IR::HomeDefSeq*&,
+      const IR_HomeDefSeq*&,
       _tao_elem
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::HomeDefSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_HomeDefSeq *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -56089,15 +31194,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::HomeDefSeq*,
+          const IR_HomeDefSeq*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::HomeDefSeq *tmp;
-      ACE_NEW_RETURN (tmp, IR::HomeDefSeq, 0);
+      IR_HomeDefSeq *tmp;
+      ACE_NEW_RETURN (tmp, IR_HomeDefSeq, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -56108,7 +31213,7 @@
             IR::_tc_HomeDefSeq,
             1,
             ACE_static_cast (void *, tmp),
-            IR::HomeDefSeq::_tao_any_destructor
+            IR_HomeDefSeq::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -56128,7 +31233,7 @@
 
 void operator<<= (
     CORBA::Any &_tao_any,
-    const IR::EmitsDefSeq &_tao_elem
+    const IR_EmitsDefSeq &_tao_elem
   ) // copying
 {
   TAO_OutputCDR stream;
@@ -56142,7 +31247,7 @@
   }
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::EmitsDefSeq *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_EmitsDefSeq *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -56152,19 +31257,19 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::EmitsDefSeq::_tao_any_destructor
+      IR_EmitsDefSeq::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::EmitsDefSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_EmitsDefSeq *&_tao_elem)
 {
   return _tao_any >>= ACE_const_cast(
-      const IR::EmitsDefSeq*&,
+      const IR_EmitsDefSeq*&,
       _tao_elem
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::EmitsDefSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_EmitsDefSeq *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -56178,15 +31283,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::EmitsDefSeq*,
+          const IR_EmitsDefSeq*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::EmitsDefSeq *tmp;
-      ACE_NEW_RETURN (tmp, IR::EmitsDefSeq, 0);
+      IR_EmitsDefSeq *tmp;
+      ACE_NEW_RETURN (tmp, IR_EmitsDefSeq, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -56197,7 +31302,7 @@
             IR::_tc_EmitsDefSeq,
             1,
             ACE_static_cast (void *, tmp),
-            IR::EmitsDefSeq::_tao_any_destructor
+            IR_EmitsDefSeq::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -56217,7 +31322,7 @@
 
 void operator<<= (
     CORBA::Any &_tao_any,
-    const IR::PublishesDefSeq &_tao_elem
+    const IR_PublishesDefSeq &_tao_elem
   ) // copying
 {
   TAO_OutputCDR stream;
@@ -56231,7 +31336,7 @@
   }
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::PublishesDefSeq *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_PublishesDefSeq *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -56241,19 +31346,19 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::PublishesDefSeq::_tao_any_destructor
+      IR_PublishesDefSeq::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::PublishesDefSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_PublishesDefSeq *&_tao_elem)
 {
   return _tao_any >>= ACE_const_cast(
-      const IR::PublishesDefSeq*&,
+      const IR_PublishesDefSeq*&,
       _tao_elem
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::PublishesDefSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_PublishesDefSeq *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -56267,15 +31372,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::PublishesDefSeq*,
+          const IR_PublishesDefSeq*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::PublishesDefSeq *tmp;
-      ACE_NEW_RETURN (tmp, IR::PublishesDefSeq, 0);
+      IR_PublishesDefSeq *tmp;
+      ACE_NEW_RETURN (tmp, IR_PublishesDefSeq, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -56286,7 +31391,7 @@
             IR::_tc_PublishesDefSeq,
             1,
             ACE_static_cast (void *, tmp),
-            IR::PublishesDefSeq::_tao_any_destructor
+            IR_PublishesDefSeq::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -56306,7 +31411,7 @@
 
 void operator<<= (
     CORBA::Any &_tao_any,
-    const IR::ConsumesDefSeq &_tao_elem
+    const IR_ConsumesDefSeq &_tao_elem
   ) // copying
 {
   TAO_OutputCDR stream;
@@ -56320,7 +31425,7 @@
   }
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::ConsumesDefSeq *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_ConsumesDefSeq *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -56330,19 +31435,19 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::ConsumesDefSeq::_tao_any_destructor
+      IR_ConsumesDefSeq::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ConsumesDefSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ConsumesDefSeq *&_tao_elem)
 {
   return _tao_any >>= ACE_const_cast(
-      const IR::ConsumesDefSeq*&,
+      const IR_ConsumesDefSeq*&,
       _tao_elem
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ConsumesDefSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ConsumesDefSeq *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -56356,15 +31461,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::ConsumesDefSeq*,
+          const IR_ConsumesDefSeq*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::ConsumesDefSeq *tmp;
-      ACE_NEW_RETURN (tmp, IR::ConsumesDefSeq, 0);
+      IR_ConsumesDefSeq *tmp;
+      ACE_NEW_RETURN (tmp, IR_ConsumesDefSeq, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -56375,7 +31480,7 @@
             IR::_tc_ConsumesDefSeq,
             1,
             ACE_static_cast (void *, tmp),
-            IR::ConsumesDefSeq::_tao_any_destructor
+            IR_ConsumesDefSeq::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -56395,7 +31500,7 @@
 
 void operator<<= (
     CORBA::Any &_tao_any,
-    const IR::FactoryDefSeq &_tao_elem
+    const IR_FactoryDefSeq &_tao_elem
   ) // copying
 {
   TAO_OutputCDR stream;
@@ -56409,7 +31514,7 @@
   }
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::FactoryDefSeq *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_FactoryDefSeq *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -56419,19 +31524,19 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::FactoryDefSeq::_tao_any_destructor
+      IR_FactoryDefSeq::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::FactoryDefSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_FactoryDefSeq *&_tao_elem)
 {
   return _tao_any >>= ACE_const_cast(
-      const IR::FactoryDefSeq*&,
+      const IR_FactoryDefSeq*&,
       _tao_elem
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::FactoryDefSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_FactoryDefSeq *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -56445,15 +31550,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::FactoryDefSeq*,
+          const IR_FactoryDefSeq*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::FactoryDefSeq *tmp;
-      ACE_NEW_RETURN (tmp, IR::FactoryDefSeq, 0);
+      IR_FactoryDefSeq *tmp;
+      ACE_NEW_RETURN (tmp, IR_FactoryDefSeq, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -56464,7 +31569,7 @@
             IR::_tc_FactoryDefSeq,
             1,
             ACE_static_cast (void *, tmp),
-            IR::FactoryDefSeq::_tao_any_destructor
+            IR_FactoryDefSeq::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -56484,7 +31589,7 @@
 
 void operator<<= (
     CORBA::Any &_tao_any,
-    const IR::FinderDefSeq &_tao_elem
+    const IR_FinderDefSeq &_tao_elem
   ) // copying
 {
   TAO_OutputCDR stream;
@@ -56498,7 +31603,7 @@
   }
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::FinderDefSeq *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_FinderDefSeq *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -56508,19 +31613,19 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::FinderDefSeq::_tao_any_destructor
+      IR_FinderDefSeq::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::FinderDefSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_FinderDefSeq *&_tao_elem)
 {
   return _tao_any >>= ACE_const_cast(
-      const IR::FinderDefSeq*&,
+      const IR_FinderDefSeq*&,
       _tao_elem
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::FinderDefSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_FinderDefSeq *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -56534,15 +31639,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::FinderDefSeq*,
+          const IR_FinderDefSeq*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::FinderDefSeq *tmp;
-      ACE_NEW_RETURN (tmp, IR::FinderDefSeq, 0);
+      IR_FinderDefSeq *tmp;
+      ACE_NEW_RETURN (tmp, IR_FinderDefSeq, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -56553,7 +31658,7 @@
             IR::_tc_FinderDefSeq,
             1,
             ACE_static_cast (void *, tmp),
-            IR::FinderDefSeq::_tao_any_destructor
+            IR_FinderDefSeq::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -56573,7 +31678,7 @@
 
 void operator<<= (
     CORBA::Any &_tao_any,
-    const IR::ContainedSeq &_tao_elem
+    const IR_ContainedSeq &_tao_elem
   ) // copying
 {
   TAO_OutputCDR stream;
@@ -56587,7 +31692,7 @@
   }
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::ContainedSeq *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_ContainedSeq *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -56597,19 +31702,19 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::ContainedSeq::_tao_any_destructor
+      IR_ContainedSeq::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ContainedSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ContainedSeq *&_tao_elem)
 {
   return _tao_any >>= ACE_const_cast(
-      const IR::ContainedSeq*&,
+      const IR_ContainedSeq*&,
       _tao_elem
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ContainedSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ContainedSeq *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -56623,15 +31728,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::ContainedSeq*,
+          const IR_ContainedSeq*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::ContainedSeq *tmp;
-      ACE_NEW_RETURN (tmp, IR::ContainedSeq, 0);
+      IR_ContainedSeq *tmp;
+      ACE_NEW_RETURN (tmp, IR_ContainedSeq, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -56642,7 +31747,7 @@
             IR::_tc_ContainedSeq,
             1,
             ACE_static_cast (void *, tmp),
-            IR::ContainedSeq::_tao_any_destructor
+            IR_ContainedSeq::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -56660,7 +31765,7 @@
   return 0;
 }
 
-void operator<<= (CORBA::Any &_tao_any, const IR::StructMember &_tao_elem) // copying
+void operator<<= (CORBA::Any &_tao_any, const IR_StructMember &_tao_elem) // copying
 {
   TAO_OutputCDR stream;
   stream << _tao_elem;
@@ -56671,7 +31776,7 @@
     );
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::StructMember *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_StructMember *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -56681,16 +31786,16 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::StructMember::_tao_any_destructor
+      IR_StructMember::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::StructMember *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_StructMember *&_tao_elem)
 {
-  return _tao_any >>= ACE_const_cast(const IR::StructMember*&,_tao_elem);
+  return _tao_any >>= ACE_const_cast(const IR_StructMember*&,_tao_elem);
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::StructMember *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_StructMember *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -56704,15 +31809,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::StructMember*,
+          const IR_StructMember*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::StructMember *tmp;
-      ACE_NEW_RETURN (tmp, IR::StructMember, 0);
+      IR_StructMember *tmp;
+      ACE_NEW_RETURN (tmp, IR_StructMember, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -56723,7 +31828,7 @@
             IR::_tc_StructMember,
             1,
             ACE_static_cast (void *, tmp),
-            IR::StructMember::_tao_any_destructor
+            IR_StructMember::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -56743,7 +31848,7 @@
 
 void operator<<= (
     CORBA::Any &_tao_any,
-    const IR::StructMemberSeq &_tao_elem
+    const IR_StructMemberSeq &_tao_elem
   ) // copying
 {
   TAO_OutputCDR stream;
@@ -56757,7 +31862,7 @@
   }
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::StructMemberSeq *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_StructMemberSeq *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -56767,19 +31872,19 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::StructMemberSeq::_tao_any_destructor
+      IR_StructMemberSeq::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::StructMemberSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_StructMemberSeq *&_tao_elem)
 {
   return _tao_any >>= ACE_const_cast(
-      const IR::StructMemberSeq*&,
+      const IR_StructMemberSeq*&,
       _tao_elem
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::StructMemberSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_StructMemberSeq *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -56793,15 +31898,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::StructMemberSeq*,
+          const IR_StructMemberSeq*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::StructMemberSeq *tmp;
-      ACE_NEW_RETURN (tmp, IR::StructMemberSeq, 0);
+      IR_StructMemberSeq *tmp;
+      ACE_NEW_RETURN (tmp, IR_StructMemberSeq, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -56812,7 +31917,7 @@
             IR::_tc_StructMemberSeq,
             1,
             ACE_static_cast (void *, tmp),
-            IR::StructMemberSeq::_tao_any_destructor
+            IR_StructMemberSeq::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -56830,7 +31935,7 @@
   return 0;
 }
 
-void operator<<= (CORBA::Any &_tao_any, const IR::Initializer &_tao_elem) // copying
+void operator<<= (CORBA::Any &_tao_any, const IR_Initializer &_tao_elem) // copying
 {
   TAO_OutputCDR stream;
   stream << _tao_elem;
@@ -56841,7 +31946,7 @@
     );
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::Initializer *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_Initializer *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -56851,16 +31956,16 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::Initializer::_tao_any_destructor
+      IR_Initializer::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::Initializer *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_Initializer *&_tao_elem)
 {
-  return _tao_any >>= ACE_const_cast(const IR::Initializer*&,_tao_elem);
+  return _tao_any >>= ACE_const_cast(const IR_Initializer*&,_tao_elem);
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::Initializer *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_Initializer *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -56874,15 +31979,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::Initializer*,
+          const IR_Initializer*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::Initializer *tmp;
-      ACE_NEW_RETURN (tmp, IR::Initializer, 0);
+      IR_Initializer *tmp;
+      ACE_NEW_RETURN (tmp, IR_Initializer, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -56893,7 +31998,7 @@
             IR::_tc_Initializer,
             1,
             ACE_static_cast (void *, tmp),
-            IR::Initializer::_tao_any_destructor
+            IR_Initializer::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -56913,7 +32018,7 @@
 
 void operator<<= (
     CORBA::Any &_tao_any,
-    const IR::InitializerSeq &_tao_elem
+    const IR_InitializerSeq &_tao_elem
   ) // copying
 {
   TAO_OutputCDR stream;
@@ -56927,7 +32032,7 @@
   }
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::InitializerSeq *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_InitializerSeq *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -56937,19 +32042,19 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::InitializerSeq::_tao_any_destructor
+      IR_InitializerSeq::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::InitializerSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_InitializerSeq *&_tao_elem)
 {
   return _tao_any >>= ACE_const_cast(
-      const IR::InitializerSeq*&,
+      const IR_InitializerSeq*&,
       _tao_elem
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::InitializerSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_InitializerSeq *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -56963,15 +32068,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::InitializerSeq*,
+          const IR_InitializerSeq*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::InitializerSeq *tmp;
-      ACE_NEW_RETURN (tmp, IR::InitializerSeq, 0);
+      IR_InitializerSeq *tmp;
+      ACE_NEW_RETURN (tmp, IR_InitializerSeq, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -56982,7 +32087,7 @@
             IR::_tc_InitializerSeq,
             1,
             ACE_static_cast (void *, tmp),
-            IR::InitializerSeq::_tao_any_destructor
+            IR_InitializerSeq::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -57000,7 +32105,7 @@
   return 0;
 }
 
-void operator<<= (CORBA::Any &_tao_any, const IR::UnionMember &_tao_elem) // copying
+void operator<<= (CORBA::Any &_tao_any, const IR_UnionMember &_tao_elem) // copying
 {
   TAO_OutputCDR stream;
   stream << _tao_elem;
@@ -57011,7 +32116,7 @@
     );
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::UnionMember *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_UnionMember *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -57021,16 +32126,16 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::UnionMember::_tao_any_destructor
+      IR_UnionMember::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::UnionMember *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_UnionMember *&_tao_elem)
 {
-  return _tao_any >>= ACE_const_cast(const IR::UnionMember*&,_tao_elem);
+  return _tao_any >>= ACE_const_cast(const IR_UnionMember*&,_tao_elem);
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::UnionMember *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_UnionMember *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -57044,15 +32149,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::UnionMember*,
+          const IR_UnionMember*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::UnionMember *tmp;
-      ACE_NEW_RETURN (tmp, IR::UnionMember, 0);
+      IR_UnionMember *tmp;
+      ACE_NEW_RETURN (tmp, IR_UnionMember, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -57063,7 +32168,7 @@
             IR::_tc_UnionMember,
             1,
             ACE_static_cast (void *, tmp),
-            IR::UnionMember::_tao_any_destructor
+            IR_UnionMember::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -57083,7 +32188,7 @@
 
 void operator<<= (
     CORBA::Any &_tao_any,
-    const IR::UnionMemberSeq &_tao_elem
+    const IR_UnionMemberSeq &_tao_elem
   ) // copying
 {
   TAO_OutputCDR stream;
@@ -57097,7 +32202,7 @@
   }
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::UnionMemberSeq *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_UnionMemberSeq *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -57107,19 +32212,19 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::UnionMemberSeq::_tao_any_destructor
+      IR_UnionMemberSeq::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::UnionMemberSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_UnionMemberSeq *&_tao_elem)
 {
   return _tao_any >>= ACE_const_cast(
-      const IR::UnionMemberSeq*&,
+      const IR_UnionMemberSeq*&,
       _tao_elem
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::UnionMemberSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_UnionMemberSeq *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -57133,15 +32238,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::UnionMemberSeq*,
+          const IR_UnionMemberSeq*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::UnionMemberSeq *tmp;
-      ACE_NEW_RETURN (tmp, IR::UnionMemberSeq, 0);
+      IR_UnionMemberSeq *tmp;
+      ACE_NEW_RETURN (tmp, IR_UnionMemberSeq, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -57152,7 +32257,7 @@
             IR::_tc_UnionMemberSeq,
             1,
             ACE_static_cast (void *, tmp),
-            IR::UnionMemberSeq::_tao_any_destructor
+            IR_UnionMemberSeq::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -57172,7 +32277,7 @@
 
 void operator<<= (
     CORBA::Any &_tao_any,
-    const IR::EnumMemberSeq &_tao_elem
+    const IR_EnumMemberSeq &_tao_elem
   ) // copying
 {
   TAO_OutputCDR stream;
@@ -57186,7 +32291,7 @@
   }
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::EnumMemberSeq *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_EnumMemberSeq *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -57196,19 +32301,19 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::EnumMemberSeq::_tao_any_destructor
+      IR_EnumMemberSeq::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::EnumMemberSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_EnumMemberSeq *&_tao_elem)
 {
   return _tao_any >>= ACE_const_cast(
-      const IR::EnumMemberSeq*&,
+      const IR_EnumMemberSeq*&,
       _tao_elem
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::EnumMemberSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_EnumMemberSeq *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -57222,15 +32327,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::EnumMemberSeq*,
+          const IR_EnumMemberSeq*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::EnumMemberSeq *tmp;
-      ACE_NEW_RETURN (tmp, IR::EnumMemberSeq, 0);
+      IR_EnumMemberSeq *tmp;
+      ACE_NEW_RETURN (tmp, IR_EnumMemberSeq, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -57241,7 +32346,7 @@
             IR::_tc_EnumMemberSeq,
             1,
             ACE_static_cast (void *, tmp),
-            IR::EnumMemberSeq::_tao_any_destructor
+            IR_EnumMemberSeq::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -57259,11 +32364,11 @@
   return 0;
 }
 
-IR::_TAO_Container_Proxy_Broker * (*IR__TAO_Container_Proxy_Broker_Factory_function_pointer) (
+_TAO_Container_Proxy_Broker * (*_TAO_Container_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::Container_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_Container_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -57273,17 +32378,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::Container::_duplicate (_tao_elem),
-        IR::Container::_tao_any_destructor
+        IR_Container::_duplicate (_tao_elem),
+        IR_Container::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::Container_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_Container_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::Container::_nil ();
+    _tao_elem = IR_Container::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_Container, ACE_TRY_ENV)) // not equal
       {
@@ -57300,65 +32405,65 @@
           IR::_tc_Container,
           1,
           _tao_elem,
-          IR::Container::_tao_any_destructor
+          IR_Container::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::Container::_nil ();
+    _tao_elem = IR_Container::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::Container::_nil ();
+  _tao_elem = IR_Container::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::Container,IR::Container_var>;
+    template class TAO_Object_Manager<IR_Container,IR_Container_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::Container,IR::Container_var>
+  #  pragma instantiate TAO_Object_Manager<IR_Container,IR_Container_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-void operator<<= (CORBA::Any &_tao_any, const IR::Container::Description &_tao_elem) // copying
+void operator<<= (CORBA::Any &_tao_any, const IR_Container::Description &_tao_elem) // copying
 {
   TAO_OutputCDR stream;
   stream << _tao_elem;
   _tao_any._tao_replace (
-      IR::Container::_tc_Description,
+      IR_Container::_tc_Description,
       TAO_ENCAP_BYTE_ORDER,
       stream.begin ()
     );
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::Container::Description *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_Container::Description *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
   _tao_any._tao_replace (
-      IR::Container::_tc_Description,
+      IR_Container::_tc_Description,
       TAO_ENCAP_BYTE_ORDER,
       stream.begin (),
       1,
       _tao_elem,
-      IR::Container::Description::_tao_any_destructor
+      IR_Container::Description::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::Container::Description *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_Container::Description *&_tao_elem)
 {
-  return _tao_any >>= ACE_const_cast(const IR::Container::Description*&,_tao_elem);
+  return _tao_any >>= ACE_const_cast(const IR_Container::Description*&,_tao_elem);
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::Container::Description *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_Container::Description *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
   {
     CORBA::TypeCode_var type = _tao_any.type ();
-    if (!type->equivalent (IR::Container::_tc_Description, ACE_TRY_ENV)) // not equal
+    if (!type->equivalent (IR_Container::_tc_Description, ACE_TRY_ENV)) // not equal
       {
         return 0;
       }
@@ -57366,15 +32471,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::Container::Description*,
+          const IR_Container::Description*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::Container::Description *tmp;
-      ACE_NEW_RETURN (tmp, IR::Container::Description, 0);
+      IR_Container::Description *tmp;
+      ACE_NEW_RETURN (tmp, IR_Container::Description, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -57382,10 +32487,10 @@
       if (stream >> *tmp)
       {
         ((CORBA::Any *)&_tao_any)->_tao_replace (
-            IR::Container::_tc_Description,
+            IR_Container::_tc_Description,
             1,
             ACE_static_cast (void *, tmp),
-            IR::Container::Description::_tao_any_destructor
+            IR_Container::Description::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -57405,49 +32510,49 @@
 
 void operator<<= (
     CORBA::Any &_tao_any,
-    const IR::Container::DescriptionSeq &_tao_elem
+    const IR_Container::DescriptionSeq &_tao_elem
   ) // copying
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
   {
     _tao_any._tao_replace (
-        IR::Container::_tc_DescriptionSeq,
+        IR_Container::_tc_DescriptionSeq,
         TAO_ENCAP_BYTE_ORDER,
         stream.begin ()
       );
   }
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::Container::DescriptionSeq *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_Container::DescriptionSeq *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
   _tao_any._tao_replace (
-      IR::Container::_tc_DescriptionSeq,
+      IR_Container::_tc_DescriptionSeq,
       TAO_ENCAP_BYTE_ORDER,
       stream.begin (),
       1,
       _tao_elem,
-      IR::Container::DescriptionSeq::_tao_any_destructor
+      IR_Container::DescriptionSeq::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::Container::DescriptionSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_Container::DescriptionSeq *&_tao_elem)
 {
   return _tao_any >>= ACE_const_cast(
-      const IR::Container::DescriptionSeq*&,
+      const IR_Container::DescriptionSeq*&,
       _tao_elem
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::Container::DescriptionSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_Container::DescriptionSeq *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
   {
     CORBA::TypeCode_var type = _tao_any.type ();
-    if (!type->equivalent (IR::Container::_tc_DescriptionSeq, ACE_TRY_ENV)) // not equal
+    if (!type->equivalent (IR_Container::_tc_DescriptionSeq, ACE_TRY_ENV)) // not equal
       {
         return 0;
       }
@@ -57455,15 +32560,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::Container::DescriptionSeq*,
+          const IR_Container::DescriptionSeq*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::Container::DescriptionSeq *tmp;
-      ACE_NEW_RETURN (tmp, IR::Container::DescriptionSeq, 0);
+      IR_Container::DescriptionSeq *tmp;
+      ACE_NEW_RETURN (tmp, IR_Container::DescriptionSeq, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -57471,10 +32576,10 @@
       if (stream >> *tmp)
       {
         ((CORBA::Any *)&_tao_any)->_tao_replace (
-            IR::Container::_tc_DescriptionSeq,
+            IR_Container::_tc_DescriptionSeq,
             1,
             ACE_static_cast (void *, tmp),
-            IR::Container::DescriptionSeq::_tao_any_destructor
+            IR_Container::DescriptionSeq::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -57492,11 +32597,11 @@
   return 0;
 }
 
-IR::_TAO_IDLType_Proxy_Broker * (*IR__TAO_IDLType_Proxy_Broker_Factory_function_pointer) (
+_TAO_IDLType_Proxy_Broker * (*_TAO_IDLType_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::IDLType_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_IDLType_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -57506,17 +32611,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::IDLType::_duplicate (_tao_elem),
-        IR::IDLType::_tao_any_destructor
+        IR_IDLType::_duplicate (_tao_elem),
+        IR_IDLType::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::IDLType_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_IDLType_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::IDLType::_nil ();
+    _tao_elem = IR_IDLType::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_IDLType, ACE_TRY_ENV)) // not equal
       {
@@ -57533,29 +32638,29 @@
           IR::_tc_IDLType,
           1,
           _tao_elem,
-          IR::IDLType::_tao_any_destructor
+          IR_IDLType::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::IDLType::_nil ();
+    _tao_elem = IR_IDLType::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::IDLType::_nil ();
+  _tao_elem = IR_IDLType::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::IDLType,IR::IDLType_var>;
+    template class TAO_Object_Manager<IR_IDLType,IR_IDLType_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::IDLType,IR::IDLType_var>
+  #  pragma instantiate TAO_Object_Manager<IR_IDLType,IR_IDLType_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-void operator<<= (CORBA::Any &_tao_any, IR::PrimitiveKind _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_PrimitiveKind _tao_elem)
 {
   TAO_OutputCDR stream;
   stream << _tao_elem;
@@ -57566,7 +32671,7 @@
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::PrimitiveKind &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_PrimitiveKind &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
@@ -57593,11 +32698,11 @@
   return 0;
 }
 
-IR::_TAO_Repository_Proxy_Broker * (*IR__TAO_Repository_Proxy_Broker_Factory_function_pointer) (
+_TAO_Repository_Proxy_Broker * (*_TAO_Repository_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::Repository_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_Repository_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -57607,17 +32712,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::Repository::_duplicate (_tao_elem),
-        IR::Repository::_tao_any_destructor
+        IR_Repository::_duplicate (_tao_elem),
+        IR_Repository::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::Repository_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_Repository_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::Repository::_nil ();
+    _tao_elem = IR_Repository::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_Repository, ACE_TRY_ENV)) // not equal
       {
@@ -57634,33 +32739,33 @@
           IR::_tc_Repository,
           1,
           _tao_elem,
-          IR::Repository::_tao_any_destructor
+          IR_Repository::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::Repository::_nil ();
+    _tao_elem = IR_Repository::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::Repository::_nil ();
+  _tao_elem = IR_Repository::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::Repository,IR::Repository_var>;
+    template class TAO_Object_Manager<IR_Repository,IR_Repository_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::Repository,IR::Repository_var>
+  #  pragma instantiate TAO_Object_Manager<IR_Repository,IR_Repository_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-IR::_TAO_ComponentRepository_Proxy_Broker * (*IR__TAO_ComponentRepository_Proxy_Broker_Factory_function_pointer) (
+_TAO_ComponentRepository_Proxy_Broker * (*_TAO_ComponentRepository_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::ComponentRepository_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_ComponentRepository_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -57670,17 +32775,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::ComponentRepository::_duplicate (_tao_elem),
-        IR::ComponentRepository::_tao_any_destructor
+        IR_ComponentRepository::_duplicate (_tao_elem),
+        IR_ComponentRepository::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ComponentRepository_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ComponentRepository_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::ComponentRepository::_nil ();
+    _tao_elem = IR_ComponentRepository::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_ComponentRepository, ACE_TRY_ENV)) // not equal
       {
@@ -57697,33 +32802,33 @@
           IR::_tc_ComponentRepository,
           1,
           _tao_elem,
-          IR::ComponentRepository::_tao_any_destructor
+          IR_ComponentRepository::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::ComponentRepository::_nil ();
+    _tao_elem = IR_ComponentRepository::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::ComponentRepository::_nil ();
+  _tao_elem = IR_ComponentRepository::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::ComponentRepository,IR::ComponentRepository_var>;
+    template class TAO_Object_Manager<IR_ComponentRepository,IR_ComponentRepository_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::ComponentRepository,IR::ComponentRepository_var>
+  #  pragma instantiate TAO_Object_Manager<IR_ComponentRepository,IR_ComponentRepository_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-IR::_TAO_ModuleDef_Proxy_Broker * (*IR__TAO_ModuleDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_ModuleDef_Proxy_Broker * (*_TAO_ModuleDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::ModuleDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_ModuleDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -57733,17 +32838,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::ModuleDef::_duplicate (_tao_elem),
-        IR::ModuleDef::_tao_any_destructor
+        IR_ModuleDef::_duplicate (_tao_elem),
+        IR_ModuleDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ModuleDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ModuleDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::ModuleDef::_nil ();
+    _tao_elem = IR_ModuleDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_ModuleDef, ACE_TRY_ENV)) // not equal
       {
@@ -57760,29 +32865,29 @@
           IR::_tc_ModuleDef,
           1,
           _tao_elem,
-          IR::ModuleDef::_tao_any_destructor
+          IR_ModuleDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::ModuleDef::_nil ();
+    _tao_elem = IR_ModuleDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::ModuleDef::_nil ();
+  _tao_elem = IR_ModuleDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::ModuleDef,IR::ModuleDef_var>;
+    template class TAO_Object_Manager<IR_ModuleDef,IR_ModuleDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::ModuleDef,IR::ModuleDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_ModuleDef,IR_ModuleDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-void operator<<= (CORBA::Any &_tao_any, const IR::ModuleDescription &_tao_elem) // copying
+void operator<<= (CORBA::Any &_tao_any, const IR_ModuleDescription &_tao_elem) // copying
 {
   TAO_OutputCDR stream;
   stream << _tao_elem;
@@ -57793,7 +32898,7 @@
     );
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::ModuleDescription *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_ModuleDescription *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -57803,16 +32908,16 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::ModuleDescription::_tao_any_destructor
+      IR_ModuleDescription::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ModuleDescription *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ModuleDescription *&_tao_elem)
 {
-  return _tao_any >>= ACE_const_cast(const IR::ModuleDescription*&,_tao_elem);
+  return _tao_any >>= ACE_const_cast(const IR_ModuleDescription*&,_tao_elem);
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ModuleDescription *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ModuleDescription *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -57826,15 +32931,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::ModuleDescription*,
+          const IR_ModuleDescription*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::ModuleDescription *tmp;
-      ACE_NEW_RETURN (tmp, IR::ModuleDescription, 0);
+      IR_ModuleDescription *tmp;
+      ACE_NEW_RETURN (tmp, IR_ModuleDescription, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -57845,7 +32950,7 @@
             IR::_tc_ModuleDescription,
             1,
             ACE_static_cast (void *, tmp),
-            IR::ModuleDescription::_tao_any_destructor
+            IR_ModuleDescription::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -57863,11 +32968,11 @@
   return 0;
 }
 
-IR::_TAO_ConstantDef_Proxy_Broker * (*IR__TAO_ConstantDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_ConstantDef_Proxy_Broker * (*_TAO_ConstantDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::ConstantDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_ConstantDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -57877,17 +32982,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::ConstantDef::_duplicate (_tao_elem),
-        IR::ConstantDef::_tao_any_destructor
+        IR_ConstantDef::_duplicate (_tao_elem),
+        IR_ConstantDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ConstantDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ConstantDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::ConstantDef::_nil ();
+    _tao_elem = IR_ConstantDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_ConstantDef, ACE_TRY_ENV)) // not equal
       {
@@ -57904,29 +33009,29 @@
           IR::_tc_ConstantDef,
           1,
           _tao_elem,
-          IR::ConstantDef::_tao_any_destructor
+          IR_ConstantDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::ConstantDef::_nil ();
+    _tao_elem = IR_ConstantDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::ConstantDef::_nil ();
+  _tao_elem = IR_ConstantDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::ConstantDef,IR::ConstantDef_var>;
+    template class TAO_Object_Manager<IR_ConstantDef,IR_ConstantDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::ConstantDef,IR::ConstantDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_ConstantDef,IR_ConstantDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-void operator<<= (CORBA::Any &_tao_any, const IR::ConstantDescription &_tao_elem) // copying
+void operator<<= (CORBA::Any &_tao_any, const IR_ConstantDescription &_tao_elem) // copying
 {
   TAO_OutputCDR stream;
   stream << _tao_elem;
@@ -57937,7 +33042,7 @@
     );
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::ConstantDescription *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_ConstantDescription *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -57947,16 +33052,16 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::ConstantDescription::_tao_any_destructor
+      IR_ConstantDescription::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ConstantDescription *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ConstantDescription *&_tao_elem)
 {
-  return _tao_any >>= ACE_const_cast(const IR::ConstantDescription*&,_tao_elem);
+  return _tao_any >>= ACE_const_cast(const IR_ConstantDescription*&,_tao_elem);
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ConstantDescription *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ConstantDescription *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -57970,15 +33075,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::ConstantDescription*,
+          const IR_ConstantDescription*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::ConstantDescription *tmp;
-      ACE_NEW_RETURN (tmp, IR::ConstantDescription, 0);
+      IR_ConstantDescription *tmp;
+      ACE_NEW_RETURN (tmp, IR_ConstantDescription, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -57989,7 +33094,7 @@
             IR::_tc_ConstantDescription,
             1,
             ACE_static_cast (void *, tmp),
-            IR::ConstantDescription::_tao_any_destructor
+            IR_ConstantDescription::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -58007,11 +33112,11 @@
   return 0;
 }
 
-IR::_TAO_TypedefDef_Proxy_Broker * (*IR__TAO_TypedefDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_TypedefDef_Proxy_Broker * (*_TAO_TypedefDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::TypedefDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_TypedefDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -58021,17 +33126,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::TypedefDef::_duplicate (_tao_elem),
-        IR::TypedefDef::_tao_any_destructor
+        IR_TypedefDef::_duplicate (_tao_elem),
+        IR_TypedefDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::TypedefDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_TypedefDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::TypedefDef::_nil ();
+    _tao_elem = IR_TypedefDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_TypedefDef, ACE_TRY_ENV)) // not equal
       {
@@ -58048,29 +33153,29 @@
           IR::_tc_TypedefDef,
           1,
           _tao_elem,
-          IR::TypedefDef::_tao_any_destructor
+          IR_TypedefDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::TypedefDef::_nil ();
+    _tao_elem = IR_TypedefDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::TypedefDef::_nil ();
+  _tao_elem = IR_TypedefDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::TypedefDef,IR::TypedefDef_var>;
+    template class TAO_Object_Manager<IR_TypedefDef,IR_TypedefDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::TypedefDef,IR::TypedefDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_TypedefDef,IR_TypedefDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-void operator<<= (CORBA::Any &_tao_any, const IR::TypeDescription &_tao_elem) // copying
+void operator<<= (CORBA::Any &_tao_any, const IR_TypeDescription &_tao_elem) // copying
 {
   TAO_OutputCDR stream;
   stream << _tao_elem;
@@ -58081,7 +33186,7 @@
     );
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::TypeDescription *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_TypeDescription *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -58091,16 +33196,16 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::TypeDescription::_tao_any_destructor
+      IR_TypeDescription::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::TypeDescription *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_TypeDescription *&_tao_elem)
 {
-  return _tao_any >>= ACE_const_cast(const IR::TypeDescription*&,_tao_elem);
+  return _tao_any >>= ACE_const_cast(const IR_TypeDescription*&,_tao_elem);
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::TypeDescription *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_TypeDescription *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -58114,15 +33219,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::TypeDescription*,
+          const IR_TypeDescription*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::TypeDescription *tmp;
-      ACE_NEW_RETURN (tmp, IR::TypeDescription, 0);
+      IR_TypeDescription *tmp;
+      ACE_NEW_RETURN (tmp, IR_TypeDescription, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -58133,7 +33238,7 @@
             IR::_tc_TypeDescription,
             1,
             ACE_static_cast (void *, tmp),
-            IR::TypeDescription::_tao_any_destructor
+            IR_TypeDescription::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -58151,11 +33256,11 @@
   return 0;
 }
 
-IR::_TAO_StructDef_Proxy_Broker * (*IR__TAO_StructDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_StructDef_Proxy_Broker * (*_TAO_StructDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::StructDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_StructDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -58165,17 +33270,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::StructDef::_duplicate (_tao_elem),
-        IR::StructDef::_tao_any_destructor
+        IR_StructDef::_duplicate (_tao_elem),
+        IR_StructDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::StructDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_StructDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::StructDef::_nil ();
+    _tao_elem = IR_StructDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_StructDef, ACE_TRY_ENV)) // not equal
       {
@@ -58192,33 +33297,33 @@
           IR::_tc_StructDef,
           1,
           _tao_elem,
-          IR::StructDef::_tao_any_destructor
+          IR_StructDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::StructDef::_nil ();
+    _tao_elem = IR_StructDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::StructDef::_nil ();
+  _tao_elem = IR_StructDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::StructDef,IR::StructDef_var>;
+    template class TAO_Object_Manager<IR_StructDef,IR_StructDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::StructDef,IR::StructDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_StructDef,IR_StructDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-IR::_TAO_UnionDef_Proxy_Broker * (*IR__TAO_UnionDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_UnionDef_Proxy_Broker * (*_TAO_UnionDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::UnionDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_UnionDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -58228,17 +33333,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::UnionDef::_duplicate (_tao_elem),
-        IR::UnionDef::_tao_any_destructor
+        IR_UnionDef::_duplicate (_tao_elem),
+        IR_UnionDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::UnionDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_UnionDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::UnionDef::_nil ();
+    _tao_elem = IR_UnionDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_UnionDef, ACE_TRY_ENV)) // not equal
       {
@@ -58255,33 +33360,33 @@
           IR::_tc_UnionDef,
           1,
           _tao_elem,
-          IR::UnionDef::_tao_any_destructor
+          IR_UnionDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::UnionDef::_nil ();
+    _tao_elem = IR_UnionDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::UnionDef::_nil ();
+  _tao_elem = IR_UnionDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::UnionDef,IR::UnionDef_var>;
+    template class TAO_Object_Manager<IR_UnionDef,IR_UnionDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::UnionDef,IR::UnionDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_UnionDef,IR_UnionDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-IR::_TAO_EnumDef_Proxy_Broker * (*IR__TAO_EnumDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_EnumDef_Proxy_Broker * (*_TAO_EnumDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::EnumDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_EnumDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -58291,17 +33396,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::EnumDef::_duplicate (_tao_elem),
-        IR::EnumDef::_tao_any_destructor
+        IR_EnumDef::_duplicate (_tao_elem),
+        IR_EnumDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::EnumDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_EnumDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::EnumDef::_nil ();
+    _tao_elem = IR_EnumDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_EnumDef, ACE_TRY_ENV)) // not equal
       {
@@ -58318,33 +33423,33 @@
           IR::_tc_EnumDef,
           1,
           _tao_elem,
-          IR::EnumDef::_tao_any_destructor
+          IR_EnumDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::EnumDef::_nil ();
+    _tao_elem = IR_EnumDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::EnumDef::_nil ();
+  _tao_elem = IR_EnumDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::EnumDef,IR::EnumDef_var>;
+    template class TAO_Object_Manager<IR_EnumDef,IR_EnumDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::EnumDef,IR::EnumDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_EnumDef,IR_EnumDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-IR::_TAO_AliasDef_Proxy_Broker * (*IR__TAO_AliasDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_AliasDef_Proxy_Broker * (*_TAO_AliasDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::AliasDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_AliasDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -58354,17 +33459,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::AliasDef::_duplicate (_tao_elem),
-        IR::AliasDef::_tao_any_destructor
+        IR_AliasDef::_duplicate (_tao_elem),
+        IR_AliasDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::AliasDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_AliasDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::AliasDef::_nil ();
+    _tao_elem = IR_AliasDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_AliasDef, ACE_TRY_ENV)) // not equal
       {
@@ -58381,33 +33486,33 @@
           IR::_tc_AliasDef,
           1,
           _tao_elem,
-          IR::AliasDef::_tao_any_destructor
+          IR_AliasDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::AliasDef::_nil ();
+    _tao_elem = IR_AliasDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::AliasDef::_nil ();
+  _tao_elem = IR_AliasDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::AliasDef,IR::AliasDef_var>;
+    template class TAO_Object_Manager<IR_AliasDef,IR_AliasDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::AliasDef,IR::AliasDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_AliasDef,IR_AliasDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-IR::_TAO_NativeDef_Proxy_Broker * (*IR__TAO_NativeDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_NativeDef_Proxy_Broker * (*_TAO_NativeDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::NativeDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_NativeDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -58417,17 +33522,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::NativeDef::_duplicate (_tao_elem),
-        IR::NativeDef::_tao_any_destructor
+        IR_NativeDef::_duplicate (_tao_elem),
+        IR_NativeDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::NativeDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_NativeDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::NativeDef::_nil ();
+    _tao_elem = IR_NativeDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_NativeDef, ACE_TRY_ENV)) // not equal
       {
@@ -58444,33 +33549,33 @@
           IR::_tc_NativeDef,
           1,
           _tao_elem,
-          IR::NativeDef::_tao_any_destructor
+          IR_NativeDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::NativeDef::_nil ();
+    _tao_elem = IR_NativeDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::NativeDef::_nil ();
+  _tao_elem = IR_NativeDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::NativeDef,IR::NativeDef_var>;
+    template class TAO_Object_Manager<IR_NativeDef,IR_NativeDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::NativeDef,IR::NativeDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_NativeDef,IR_NativeDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-IR::_TAO_PrimitiveDef_Proxy_Broker * (*IR__TAO_PrimitiveDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_PrimitiveDef_Proxy_Broker * (*_TAO_PrimitiveDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::PrimitiveDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_PrimitiveDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -58480,17 +33585,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::PrimitiveDef::_duplicate (_tao_elem),
-        IR::PrimitiveDef::_tao_any_destructor
+        IR_PrimitiveDef::_duplicate (_tao_elem),
+        IR_PrimitiveDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::PrimitiveDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_PrimitiveDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::PrimitiveDef::_nil ();
+    _tao_elem = IR_PrimitiveDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_PrimitiveDef, ACE_TRY_ENV)) // not equal
       {
@@ -58507,33 +33612,33 @@
           IR::_tc_PrimitiveDef,
           1,
           _tao_elem,
-          IR::PrimitiveDef::_tao_any_destructor
+          IR_PrimitiveDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::PrimitiveDef::_nil ();
+    _tao_elem = IR_PrimitiveDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::PrimitiveDef::_nil ();
+  _tao_elem = IR_PrimitiveDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::PrimitiveDef,IR::PrimitiveDef_var>;
+    template class TAO_Object_Manager<IR_PrimitiveDef,IR_PrimitiveDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::PrimitiveDef,IR::PrimitiveDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_PrimitiveDef,IR_PrimitiveDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-IR::_TAO_StringDef_Proxy_Broker * (*IR__TAO_StringDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_StringDef_Proxy_Broker * (*_TAO_StringDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::StringDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_StringDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -58543,17 +33648,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::StringDef::_duplicate (_tao_elem),
-        IR::StringDef::_tao_any_destructor
+        IR_StringDef::_duplicate (_tao_elem),
+        IR_StringDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::StringDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_StringDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::StringDef::_nil ();
+    _tao_elem = IR_StringDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_StringDef, ACE_TRY_ENV)) // not equal
       {
@@ -58570,33 +33675,33 @@
           IR::_tc_StringDef,
           1,
           _tao_elem,
-          IR::StringDef::_tao_any_destructor
+          IR_StringDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::StringDef::_nil ();
+    _tao_elem = IR_StringDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::StringDef::_nil ();
+  _tao_elem = IR_StringDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::StringDef,IR::StringDef_var>;
+    template class TAO_Object_Manager<IR_StringDef,IR_StringDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::StringDef,IR::StringDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_StringDef,IR_StringDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-IR::_TAO_WstringDef_Proxy_Broker * (*IR__TAO_WstringDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_WstringDef_Proxy_Broker * (*_TAO_WstringDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::WstringDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_WstringDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -58606,17 +33711,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::WstringDef::_duplicate (_tao_elem),
-        IR::WstringDef::_tao_any_destructor
+        IR_WstringDef::_duplicate (_tao_elem),
+        IR_WstringDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::WstringDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_WstringDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::WstringDef::_nil ();
+    _tao_elem = IR_WstringDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_WstringDef, ACE_TRY_ENV)) // not equal
       {
@@ -58633,33 +33738,33 @@
           IR::_tc_WstringDef,
           1,
           _tao_elem,
-          IR::WstringDef::_tao_any_destructor
+          IR_WstringDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::WstringDef::_nil ();
+    _tao_elem = IR_WstringDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::WstringDef::_nil ();
+  _tao_elem = IR_WstringDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::WstringDef,IR::WstringDef_var>;
+    template class TAO_Object_Manager<IR_WstringDef,IR_WstringDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::WstringDef,IR::WstringDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_WstringDef,IR_WstringDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-IR::_TAO_FixedDef_Proxy_Broker * (*IR__TAO_FixedDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_FixedDef_Proxy_Broker * (*_TAO_FixedDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::FixedDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_FixedDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -58669,17 +33774,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::FixedDef::_duplicate (_tao_elem),
-        IR::FixedDef::_tao_any_destructor
+        IR_FixedDef::_duplicate (_tao_elem),
+        IR_FixedDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::FixedDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_FixedDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::FixedDef::_nil ();
+    _tao_elem = IR_FixedDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_FixedDef, ACE_TRY_ENV)) // not equal
       {
@@ -58696,33 +33801,33 @@
           IR::_tc_FixedDef,
           1,
           _tao_elem,
-          IR::FixedDef::_tao_any_destructor
+          IR_FixedDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::FixedDef::_nil ();
+    _tao_elem = IR_FixedDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::FixedDef::_nil ();
+  _tao_elem = IR_FixedDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::FixedDef,IR::FixedDef_var>;
+    template class TAO_Object_Manager<IR_FixedDef,IR_FixedDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::FixedDef,IR::FixedDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_FixedDef,IR_FixedDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-IR::_TAO_SequenceDef_Proxy_Broker * (*IR__TAO_SequenceDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_SequenceDef_Proxy_Broker * (*_TAO_SequenceDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::SequenceDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_SequenceDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -58732,17 +33837,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::SequenceDef::_duplicate (_tao_elem),
-        IR::SequenceDef::_tao_any_destructor
+        IR_SequenceDef::_duplicate (_tao_elem),
+        IR_SequenceDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::SequenceDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_SequenceDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::SequenceDef::_nil ();
+    _tao_elem = IR_SequenceDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_SequenceDef, ACE_TRY_ENV)) // not equal
       {
@@ -58759,33 +33864,33 @@
           IR::_tc_SequenceDef,
           1,
           _tao_elem,
-          IR::SequenceDef::_tao_any_destructor
+          IR_SequenceDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::SequenceDef::_nil ();
+    _tao_elem = IR_SequenceDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::SequenceDef::_nil ();
+  _tao_elem = IR_SequenceDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::SequenceDef,IR::SequenceDef_var>;
+    template class TAO_Object_Manager<IR_SequenceDef,IR_SequenceDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::SequenceDef,IR::SequenceDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_SequenceDef,IR_SequenceDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-IR::_TAO_ArrayDef_Proxy_Broker * (*IR__TAO_ArrayDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_ArrayDef_Proxy_Broker * (*_TAO_ArrayDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::ArrayDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_ArrayDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -58795,17 +33900,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::ArrayDef::_duplicate (_tao_elem),
-        IR::ArrayDef::_tao_any_destructor
+        IR_ArrayDef::_duplicate (_tao_elem),
+        IR_ArrayDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ArrayDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ArrayDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::ArrayDef::_nil ();
+    _tao_elem = IR_ArrayDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_ArrayDef, ACE_TRY_ENV)) // not equal
       {
@@ -58822,33 +33927,33 @@
           IR::_tc_ArrayDef,
           1,
           _tao_elem,
-          IR::ArrayDef::_tao_any_destructor
+          IR_ArrayDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::ArrayDef::_nil ();
+    _tao_elem = IR_ArrayDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::ArrayDef::_nil ();
+  _tao_elem = IR_ArrayDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::ArrayDef,IR::ArrayDef_var>;
+    template class TAO_Object_Manager<IR_ArrayDef,IR_ArrayDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::ArrayDef,IR::ArrayDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_ArrayDef,IR_ArrayDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-IR::_TAO_ExceptionDef_Proxy_Broker * (*IR__TAO_ExceptionDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_ExceptionDef_Proxy_Broker * (*_TAO_ExceptionDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::ExceptionDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_ExceptionDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -58858,17 +33963,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::ExceptionDef::_duplicate (_tao_elem),
-        IR::ExceptionDef::_tao_any_destructor
+        IR_ExceptionDef::_duplicate (_tao_elem),
+        IR_ExceptionDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ExceptionDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ExceptionDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::ExceptionDef::_nil ();
+    _tao_elem = IR_ExceptionDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_ExceptionDef, ACE_TRY_ENV)) // not equal
       {
@@ -58885,29 +33990,29 @@
           IR::_tc_ExceptionDef,
           1,
           _tao_elem,
-          IR::ExceptionDef::_tao_any_destructor
+          IR_ExceptionDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::ExceptionDef::_nil ();
+    _tao_elem = IR_ExceptionDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::ExceptionDef::_nil ();
+  _tao_elem = IR_ExceptionDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::ExceptionDef,IR::ExceptionDef_var>;
+    template class TAO_Object_Manager<IR_ExceptionDef,IR_ExceptionDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::ExceptionDef,IR::ExceptionDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_ExceptionDef,IR_ExceptionDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-void operator<<= (CORBA::Any &_tao_any, const IR::ExceptionDescription &_tao_elem) // copying
+void operator<<= (CORBA::Any &_tao_any, const IR_ExceptionDescription &_tao_elem) // copying
 {
   TAO_OutputCDR stream;
   stream << _tao_elem;
@@ -58918,7 +34023,7 @@
     );
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::ExceptionDescription *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_ExceptionDescription *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -58928,16 +34033,16 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::ExceptionDescription::_tao_any_destructor
+      IR_ExceptionDescription::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ExceptionDescription *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ExceptionDescription *&_tao_elem)
 {
-  return _tao_any >>= ACE_const_cast(const IR::ExceptionDescription*&,_tao_elem);
+  return _tao_any >>= ACE_const_cast(const IR_ExceptionDescription*&,_tao_elem);
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ExceptionDescription *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ExceptionDescription *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -58951,15 +34056,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::ExceptionDescription*,
+          const IR_ExceptionDescription*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::ExceptionDescription *tmp;
-      ACE_NEW_RETURN (tmp, IR::ExceptionDescription, 0);
+      IR_ExceptionDescription *tmp;
+      ACE_NEW_RETURN (tmp, IR_ExceptionDescription, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -58970,7 +34075,7 @@
             IR::_tc_ExceptionDescription,
             1,
             ACE_static_cast (void *, tmp),
-            IR::ExceptionDescription::_tao_any_destructor
+            IR_ExceptionDescription::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -58990,7 +34095,7 @@
 
 void operator<<= (
     CORBA::Any &_tao_any,
-    const IR::ExceptionDefSeq &_tao_elem
+    const IR_ExceptionDefSeq &_tao_elem
   ) // copying
 {
   TAO_OutputCDR stream;
@@ -59004,7 +34109,7 @@
   }
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::ExceptionDefSeq *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_ExceptionDefSeq *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -59014,19 +34119,19 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::ExceptionDefSeq::_tao_any_destructor
+      IR_ExceptionDefSeq::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ExceptionDefSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ExceptionDefSeq *&_tao_elem)
 {
   return _tao_any >>= ACE_const_cast(
-      const IR::ExceptionDefSeq*&,
+      const IR_ExceptionDefSeq*&,
       _tao_elem
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ExceptionDefSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ExceptionDefSeq *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -59040,15 +34145,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::ExceptionDefSeq*,
+          const IR_ExceptionDefSeq*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::ExceptionDefSeq *tmp;
-      ACE_NEW_RETURN (tmp, IR::ExceptionDefSeq, 0);
+      IR_ExceptionDefSeq *tmp;
+      ACE_NEW_RETURN (tmp, IR_ExceptionDefSeq, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -59059,7 +34164,7 @@
             IR::_tc_ExceptionDefSeq,
             1,
             ACE_static_cast (void *, tmp),
-            IR::ExceptionDefSeq::_tao_any_destructor
+            IR_ExceptionDefSeq::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -59079,7 +34184,7 @@
 
 void operator<<= (
     CORBA::Any &_tao_any,
-    const IR::ExcDescriptionSeq &_tao_elem
+    const IR_ExcDescriptionSeq &_tao_elem
   ) // copying
 {
   TAO_OutputCDR stream;
@@ -59093,7 +34198,7 @@
   }
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::ExcDescriptionSeq *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_ExcDescriptionSeq *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -59103,19 +34208,19 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::ExcDescriptionSeq::_tao_any_destructor
+      IR_ExcDescriptionSeq::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ExcDescriptionSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ExcDescriptionSeq *&_tao_elem)
 {
   return _tao_any >>= ACE_const_cast(
-      const IR::ExcDescriptionSeq*&,
+      const IR_ExcDescriptionSeq*&,
       _tao_elem
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ExcDescriptionSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ExcDescriptionSeq *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -59129,15 +34234,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::ExcDescriptionSeq*,
+          const IR_ExcDescriptionSeq*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::ExcDescriptionSeq *tmp;
-      ACE_NEW_RETURN (tmp, IR::ExcDescriptionSeq, 0);
+      IR_ExcDescriptionSeq *tmp;
+      ACE_NEW_RETURN (tmp, IR_ExcDescriptionSeq, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -59148,7 +34253,7 @@
             IR::_tc_ExcDescriptionSeq,
             1,
             ACE_static_cast (void *, tmp),
-            IR::ExcDescriptionSeq::_tao_any_destructor
+            IR_ExcDescriptionSeq::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -59166,7 +34271,7 @@
   return 0;
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::AttributeMode _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_AttributeMode _tao_elem)
 {
   TAO_OutputCDR stream;
   stream << _tao_elem;
@@ -59177,7 +34282,7 @@
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::AttributeMode &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_AttributeMode &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
@@ -59204,11 +34309,11 @@
   return 0;
 }
 
-IR::_TAO_AttributeDef_Proxy_Broker * (*IR__TAO_AttributeDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_AttributeDef_Proxy_Broker * (*_TAO_AttributeDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::AttributeDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_AttributeDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -59218,17 +34323,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::AttributeDef::_duplicate (_tao_elem),
-        IR::AttributeDef::_tao_any_destructor
+        IR_AttributeDef::_duplicate (_tao_elem),
+        IR_AttributeDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::AttributeDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_AttributeDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::AttributeDef::_nil ();
+    _tao_elem = IR_AttributeDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_AttributeDef, ACE_TRY_ENV)) // not equal
       {
@@ -59245,29 +34350,29 @@
           IR::_tc_AttributeDef,
           1,
           _tao_elem,
-          IR::AttributeDef::_tao_any_destructor
+          IR_AttributeDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::AttributeDef::_nil ();
+    _tao_elem = IR_AttributeDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::AttributeDef::_nil ();
+  _tao_elem = IR_AttributeDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::AttributeDef,IR::AttributeDef_var>;
+    template class TAO_Object_Manager<IR_AttributeDef,IR_AttributeDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::AttributeDef,IR::AttributeDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_AttributeDef,IR_AttributeDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-void operator<<= (CORBA::Any &_tao_any, const IR::AttributeDescription &_tao_elem) // copying
+void operator<<= (CORBA::Any &_tao_any, const IR_AttributeDescription &_tao_elem) // copying
 {
   TAO_OutputCDR stream;
   stream << _tao_elem;
@@ -59278,7 +34383,7 @@
     );
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::AttributeDescription *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_AttributeDescription *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -59288,16 +34393,16 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::AttributeDescription::_tao_any_destructor
+      IR_AttributeDescription::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::AttributeDescription *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_AttributeDescription *&_tao_elem)
 {
-  return _tao_any >>= ACE_const_cast(const IR::AttributeDescription*&,_tao_elem);
+  return _tao_any >>= ACE_const_cast(const IR_AttributeDescription*&,_tao_elem);
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::AttributeDescription *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_AttributeDescription *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -59311,15 +34416,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::AttributeDescription*,
+          const IR_AttributeDescription*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::AttributeDescription *tmp;
-      ACE_NEW_RETURN (tmp, IR::AttributeDescription, 0);
+      IR_AttributeDescription *tmp;
+      ACE_NEW_RETURN (tmp, IR_AttributeDescription, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -59330,7 +34435,7 @@
             IR::_tc_AttributeDescription,
             1,
             ACE_static_cast (void *, tmp),
-            IR::AttributeDescription::_tao_any_destructor
+            IR_AttributeDescription::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -59348,7 +34453,7 @@
   return 0;
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::OperationMode _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_OperationMode _tao_elem)
 {
   TAO_OutputCDR stream;
   stream << _tao_elem;
@@ -59359,7 +34464,7 @@
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::OperationMode &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_OperationMode &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
@@ -59386,7 +34491,7 @@
   return 0;
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::ParameterMode _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_ParameterMode _tao_elem)
 {
   TAO_OutputCDR stream;
   stream << _tao_elem;
@@ -59397,7 +34502,7 @@
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ParameterMode &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ParameterMode &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
@@ -59424,7 +34529,7 @@
   return 0;
 }
 
-void operator<<= (CORBA::Any &_tao_any, const IR::ParameterDescription &_tao_elem) // copying
+void operator<<= (CORBA::Any &_tao_any, const IR_ParameterDescription &_tao_elem) // copying
 {
   TAO_OutputCDR stream;
   stream << _tao_elem;
@@ -59435,7 +34540,7 @@
     );
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::ParameterDescription *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_ParameterDescription *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -59445,16 +34550,16 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::ParameterDescription::_tao_any_destructor
+      IR_ParameterDescription::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ParameterDescription *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ParameterDescription *&_tao_elem)
 {
-  return _tao_any >>= ACE_const_cast(const IR::ParameterDescription*&,_tao_elem);
+  return _tao_any >>= ACE_const_cast(const IR_ParameterDescription*&,_tao_elem);
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ParameterDescription *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ParameterDescription *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -59468,15 +34573,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::ParameterDescription*,
+          const IR_ParameterDescription*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::ParameterDescription *tmp;
-      ACE_NEW_RETURN (tmp, IR::ParameterDescription, 0);
+      IR_ParameterDescription *tmp;
+      ACE_NEW_RETURN (tmp, IR_ParameterDescription, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -59487,7 +34592,7 @@
             IR::_tc_ParameterDescription,
             1,
             ACE_static_cast (void *, tmp),
-            IR::ParameterDescription::_tao_any_destructor
+            IR_ParameterDescription::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -59507,7 +34612,7 @@
 
 void operator<<= (
     CORBA::Any &_tao_any,
-    const IR::ParDescriptionSeq &_tao_elem
+    const IR_ParDescriptionSeq &_tao_elem
   ) // copying
 {
   TAO_OutputCDR stream;
@@ -59521,7 +34626,7 @@
   }
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::ParDescriptionSeq *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_ParDescriptionSeq *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -59531,19 +34636,19 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::ParDescriptionSeq::_tao_any_destructor
+      IR_ParDescriptionSeq::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ParDescriptionSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ParDescriptionSeq *&_tao_elem)
 {
   return _tao_any >>= ACE_const_cast(
-      const IR::ParDescriptionSeq*&,
+      const IR_ParDescriptionSeq*&,
       _tao_elem
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ParDescriptionSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ParDescriptionSeq *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -59557,15 +34662,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::ParDescriptionSeq*,
+          const IR_ParDescriptionSeq*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::ParDescriptionSeq *tmp;
-      ACE_NEW_RETURN (tmp, IR::ParDescriptionSeq, 0);
+      IR_ParDescriptionSeq *tmp;
+      ACE_NEW_RETURN (tmp, IR_ParDescriptionSeq, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -59576,7 +34681,7 @@
             IR::_tc_ParDescriptionSeq,
             1,
             ACE_static_cast (void *, tmp),
-            IR::ParDescriptionSeq::_tao_any_destructor
+            IR_ParDescriptionSeq::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -59596,7 +34701,7 @@
 
 void operator<<= (
     CORBA::Any &_tao_any,
-    const IR::ContextIdSeq &_tao_elem
+    const IR_ContextIdSeq &_tao_elem
   ) // copying
 {
   TAO_OutputCDR stream;
@@ -59610,7 +34715,7 @@
   }
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::ContextIdSeq *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_ContextIdSeq *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -59620,19 +34725,19 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::ContextIdSeq::_tao_any_destructor
+      IR_ContextIdSeq::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ContextIdSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ContextIdSeq *&_tao_elem)
 {
   return _tao_any >>= ACE_const_cast(
-      const IR::ContextIdSeq*&,
+      const IR_ContextIdSeq*&,
       _tao_elem
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ContextIdSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ContextIdSeq *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -59646,15 +34751,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::ContextIdSeq*,
+          const IR_ContextIdSeq*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::ContextIdSeq *tmp;
-      ACE_NEW_RETURN (tmp, IR::ContextIdSeq, 0);
+      IR_ContextIdSeq *tmp;
+      ACE_NEW_RETURN (tmp, IR_ContextIdSeq, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -59665,7 +34770,7 @@
             IR::_tc_ContextIdSeq,
             1,
             ACE_static_cast (void *, tmp),
-            IR::ContextIdSeq::_tao_any_destructor
+            IR_ContextIdSeq::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -59683,11 +34788,11 @@
   return 0;
 }
 
-IR::_TAO_OperationDef_Proxy_Broker * (*IR__TAO_OperationDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_OperationDef_Proxy_Broker * (*_TAO_OperationDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::OperationDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_OperationDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -59697,17 +34802,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::OperationDef::_duplicate (_tao_elem),
-        IR::OperationDef::_tao_any_destructor
+        IR_OperationDef::_duplicate (_tao_elem),
+        IR_OperationDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::OperationDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_OperationDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::OperationDef::_nil ();
+    _tao_elem = IR_OperationDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_OperationDef, ACE_TRY_ENV)) // not equal
       {
@@ -59724,29 +34829,29 @@
           IR::_tc_OperationDef,
           1,
           _tao_elem,
-          IR::OperationDef::_tao_any_destructor
+          IR_OperationDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::OperationDef::_nil ();
+    _tao_elem = IR_OperationDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::OperationDef::_nil ();
+  _tao_elem = IR_OperationDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::OperationDef,IR::OperationDef_var>;
+    template class TAO_Object_Manager<IR_OperationDef,IR_OperationDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::OperationDef,IR::OperationDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_OperationDef,IR_OperationDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-void operator<<= (CORBA::Any &_tao_any, const IR::OperationDescription &_tao_elem) // copying
+void operator<<= (CORBA::Any &_tao_any, const IR_OperationDescription &_tao_elem) // copying
 {
   TAO_OutputCDR stream;
   stream << _tao_elem;
@@ -59757,7 +34862,7 @@
     );
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::OperationDescription *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_OperationDescription *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -59767,16 +34872,16 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::OperationDescription::_tao_any_destructor
+      IR_OperationDescription::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::OperationDescription *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_OperationDescription *&_tao_elem)
 {
-  return _tao_any >>= ACE_const_cast(const IR::OperationDescription*&,_tao_elem);
+  return _tao_any >>= ACE_const_cast(const IR_OperationDescription*&,_tao_elem);
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::OperationDescription *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_OperationDescription *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -59790,15 +34895,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::OperationDescription*,
+          const IR_OperationDescription*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::OperationDescription *tmp;
-      ACE_NEW_RETURN (tmp, IR::OperationDescription, 0);
+      IR_OperationDescription *tmp;
+      ACE_NEW_RETURN (tmp, IR_OperationDescription, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -59809,7 +34914,7 @@
             IR::_tc_OperationDescription,
             1,
             ACE_static_cast (void *, tmp),
-            IR::OperationDescription::_tao_any_destructor
+            IR_OperationDescription::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -59829,7 +34934,7 @@
 
 void operator<<= (
     CORBA::Any &_tao_any,
-    const IR::RepositoryIdSeq &_tao_elem
+    const IR_RepositoryIdSeq &_tao_elem
   ) // copying
 {
   TAO_OutputCDR stream;
@@ -59843,7 +34948,7 @@
   }
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::RepositoryIdSeq *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_RepositoryIdSeq *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -59853,19 +34958,19 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::RepositoryIdSeq::_tao_any_destructor
+      IR_RepositoryIdSeq::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::RepositoryIdSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_RepositoryIdSeq *&_tao_elem)
 {
   return _tao_any >>= ACE_const_cast(
-      const IR::RepositoryIdSeq*&,
+      const IR_RepositoryIdSeq*&,
       _tao_elem
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::RepositoryIdSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_RepositoryIdSeq *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -59879,15 +34984,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::RepositoryIdSeq*,
+          const IR_RepositoryIdSeq*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::RepositoryIdSeq *tmp;
-      ACE_NEW_RETURN (tmp, IR::RepositoryIdSeq, 0);
+      IR_RepositoryIdSeq *tmp;
+      ACE_NEW_RETURN (tmp, IR_RepositoryIdSeq, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -59898,7 +35003,7 @@
             IR::_tc_RepositoryIdSeq,
             1,
             ACE_static_cast (void *, tmp),
-            IR::RepositoryIdSeq::_tao_any_destructor
+            IR_RepositoryIdSeq::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -59918,7 +35023,7 @@
 
 void operator<<= (
     CORBA::Any &_tao_any,
-    const IR::OpDescriptionSeq &_tao_elem
+    const IR_OpDescriptionSeq &_tao_elem
   ) // copying
 {
   TAO_OutputCDR stream;
@@ -59932,7 +35037,7 @@
   }
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::OpDescriptionSeq *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_OpDescriptionSeq *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -59942,19 +35047,19 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::OpDescriptionSeq::_tao_any_destructor
+      IR_OpDescriptionSeq::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::OpDescriptionSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_OpDescriptionSeq *&_tao_elem)
 {
   return _tao_any >>= ACE_const_cast(
-      const IR::OpDescriptionSeq*&,
+      const IR_OpDescriptionSeq*&,
       _tao_elem
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::OpDescriptionSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_OpDescriptionSeq *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -59968,15 +35073,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::OpDescriptionSeq*,
+          const IR_OpDescriptionSeq*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::OpDescriptionSeq *tmp;
-      ACE_NEW_RETURN (tmp, IR::OpDescriptionSeq, 0);
+      IR_OpDescriptionSeq *tmp;
+      ACE_NEW_RETURN (tmp, IR_OpDescriptionSeq, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -59987,7 +35092,7 @@
             IR::_tc_OpDescriptionSeq,
             1,
             ACE_static_cast (void *, tmp),
-            IR::OpDescriptionSeq::_tao_any_destructor
+            IR_OpDescriptionSeq::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -60007,7 +35112,7 @@
 
 void operator<<= (
     CORBA::Any &_tao_any,
-    const IR::AttrDescriptionSeq &_tao_elem
+    const IR_AttrDescriptionSeq &_tao_elem
   ) // copying
 {
   TAO_OutputCDR stream;
@@ -60021,7 +35126,7 @@
   }
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::AttrDescriptionSeq *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_AttrDescriptionSeq *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -60031,19 +35136,19 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::AttrDescriptionSeq::_tao_any_destructor
+      IR_AttrDescriptionSeq::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::AttrDescriptionSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_AttrDescriptionSeq *&_tao_elem)
 {
   return _tao_any >>= ACE_const_cast(
-      const IR::AttrDescriptionSeq*&,
+      const IR_AttrDescriptionSeq*&,
       _tao_elem
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::AttrDescriptionSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_AttrDescriptionSeq *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -60057,15 +35162,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::AttrDescriptionSeq*,
+          const IR_AttrDescriptionSeq*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::AttrDescriptionSeq *tmp;
-      ACE_NEW_RETURN (tmp, IR::AttrDescriptionSeq, 0);
+      IR_AttrDescriptionSeq *tmp;
+      ACE_NEW_RETURN (tmp, IR_AttrDescriptionSeq, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -60076,7 +35181,7 @@
             IR::_tc_AttrDescriptionSeq,
             1,
             ACE_static_cast (void *, tmp),
-            IR::AttrDescriptionSeq::_tao_any_destructor
+            IR_AttrDescriptionSeq::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -60094,11 +35199,11 @@
   return 0;
 }
 
-IR::_TAO_InterfaceDef_Proxy_Broker * (*IR__TAO_InterfaceDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_InterfaceDef_Proxy_Broker * (*_TAO_InterfaceDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::InterfaceDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_InterfaceDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -60108,17 +35213,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::InterfaceDef::_duplicate (_tao_elem),
-        IR::InterfaceDef::_tao_any_destructor
+        IR_InterfaceDef::_duplicate (_tao_elem),
+        IR_InterfaceDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::InterfaceDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_InterfaceDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::InterfaceDef::_nil ();
+    _tao_elem = IR_InterfaceDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_InterfaceDef, ACE_TRY_ENV)) // not equal
       {
@@ -60135,29 +35240,29 @@
           IR::_tc_InterfaceDef,
           1,
           _tao_elem,
-          IR::InterfaceDef::_tao_any_destructor
+          IR_InterfaceDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::InterfaceDef::_nil ();
+    _tao_elem = IR_InterfaceDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::InterfaceDef::_nil ();
+  _tao_elem = IR_InterfaceDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::InterfaceDef,IR::InterfaceDef_var>;
+    template class TAO_Object_Manager<IR_InterfaceDef,IR_InterfaceDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::InterfaceDef,IR::InterfaceDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_InterfaceDef,IR_InterfaceDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-void operator<<= (CORBA::Any &_tao_any, const IR::InterfaceDescription &_tao_elem) // copying
+void operator<<= (CORBA::Any &_tao_any, const IR_InterfaceDescription &_tao_elem) // copying
 {
   TAO_OutputCDR stream;
   stream << _tao_elem;
@@ -60168,7 +35273,7 @@
     );
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::InterfaceDescription *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_InterfaceDescription *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -60178,16 +35283,16 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::InterfaceDescription::_tao_any_destructor
+      IR_InterfaceDescription::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::InterfaceDescription *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_InterfaceDescription *&_tao_elem)
 {
-  return _tao_any >>= ACE_const_cast(const IR::InterfaceDescription*&,_tao_elem);
+  return _tao_any >>= ACE_const_cast(const IR_InterfaceDescription*&,_tao_elem);
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::InterfaceDescription *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_InterfaceDescription *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -60201,15 +35306,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::InterfaceDescription*,
+          const IR_InterfaceDescription*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::InterfaceDescription *tmp;
-      ACE_NEW_RETURN (tmp, IR::InterfaceDescription, 0);
+      IR_InterfaceDescription *tmp;
+      ACE_NEW_RETURN (tmp, IR_InterfaceDescription, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -60220,7 +35325,7 @@
             IR::_tc_InterfaceDescription,
             1,
             ACE_static_cast (void *, tmp),
-            IR::InterfaceDescription::_tao_any_destructor
+            IR_InterfaceDescription::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -60238,7 +35343,7 @@
   return 0;
 }
 
-void operator<<= (CORBA::Any &_tao_any, const IR::ValueMember &_tao_elem) // copying
+void operator<<= (CORBA::Any &_tao_any, const IR_ValueMember &_tao_elem) // copying
 {
   TAO_OutputCDR stream;
   stream << _tao_elem;
@@ -60249,7 +35354,7 @@
     );
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::ValueMember *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_ValueMember *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -60259,16 +35364,16 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::ValueMember::_tao_any_destructor
+      IR_ValueMember::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ValueMember *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ValueMember *&_tao_elem)
 {
-  return _tao_any >>= ACE_const_cast(const IR::ValueMember*&,_tao_elem);
+  return _tao_any >>= ACE_const_cast(const IR_ValueMember*&,_tao_elem);
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ValueMember *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ValueMember *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -60282,15 +35387,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::ValueMember*,
+          const IR_ValueMember*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::ValueMember *tmp;
-      ACE_NEW_RETURN (tmp, IR::ValueMember, 0);
+      IR_ValueMember *tmp;
+      ACE_NEW_RETURN (tmp, IR_ValueMember, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -60301,7 +35406,7 @@
             IR::_tc_ValueMember,
             1,
             ACE_static_cast (void *, tmp),
-            IR::ValueMember::_tao_any_destructor
+            IR_ValueMember::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -60321,7 +35426,7 @@
 
 void operator<<= (
     CORBA::Any &_tao_any,
-    const IR::ValueMemberSeq &_tao_elem
+    const IR_ValueMemberSeq &_tao_elem
   ) // copying
 {
   TAO_OutputCDR stream;
@@ -60335,7 +35440,7 @@
   }
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::ValueMemberSeq *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_ValueMemberSeq *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -60345,19 +35450,19 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::ValueMemberSeq::_tao_any_destructor
+      IR_ValueMemberSeq::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ValueMemberSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ValueMemberSeq *&_tao_elem)
 {
   return _tao_any >>= ACE_const_cast(
-      const IR::ValueMemberSeq*&,
+      const IR_ValueMemberSeq*&,
       _tao_elem
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ValueMemberSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ValueMemberSeq *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -60371,15 +35476,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::ValueMemberSeq*,
+          const IR_ValueMemberSeq*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::ValueMemberSeq *tmp;
-      ACE_NEW_RETURN (tmp, IR::ValueMemberSeq, 0);
+      IR_ValueMemberSeq *tmp;
+      ACE_NEW_RETURN (tmp, IR_ValueMemberSeq, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -60390,7 +35495,7 @@
             IR::_tc_ValueMemberSeq,
             1,
             ACE_static_cast (void *, tmp),
-            IR::ValueMemberSeq::_tao_any_destructor
+            IR_ValueMemberSeq::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -60408,11 +35513,11 @@
   return 0;
 }
 
-IR::_TAO_ValueMemberDef_Proxy_Broker * (*IR__TAO_ValueMemberDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_ValueMemberDef_Proxy_Broker * (*_TAO_ValueMemberDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::ValueMemberDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_ValueMemberDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -60422,17 +35527,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::ValueMemberDef::_duplicate (_tao_elem),
-        IR::ValueMemberDef::_tao_any_destructor
+        IR_ValueMemberDef::_duplicate (_tao_elem),
+        IR_ValueMemberDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ValueMemberDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ValueMemberDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::ValueMemberDef::_nil ();
+    _tao_elem = IR_ValueMemberDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_ValueMemberDef, ACE_TRY_ENV)) // not equal
       {
@@ -60449,33 +35554,33 @@
           IR::_tc_ValueMemberDef,
           1,
           _tao_elem,
-          IR::ValueMemberDef::_tao_any_destructor
+          IR_ValueMemberDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::ValueMemberDef::_nil ();
+    _tao_elem = IR_ValueMemberDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::ValueMemberDef::_nil ();
+  _tao_elem = IR_ValueMemberDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::ValueMemberDef,IR::ValueMemberDef_var>;
+    template class TAO_Object_Manager<IR_ValueMemberDef,IR_ValueMemberDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::ValueMemberDef,IR::ValueMemberDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_ValueMemberDef,IR_ValueMemberDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-IR::_TAO_ValueDef_Proxy_Broker * (*IR__TAO_ValueDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_ValueDef_Proxy_Broker * (*_TAO_ValueDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::ValueDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_ValueDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -60485,17 +35590,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::ValueDef::_duplicate (_tao_elem),
-        IR::ValueDef::_tao_any_destructor
+        IR_ValueDef::_duplicate (_tao_elem),
+        IR_ValueDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ValueDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ValueDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::ValueDef::_nil ();
+    _tao_elem = IR_ValueDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_ValueDef, ACE_TRY_ENV)) // not equal
       {
@@ -60512,29 +35617,29 @@
           IR::_tc_ValueDef,
           1,
           _tao_elem,
-          IR::ValueDef::_tao_any_destructor
+          IR_ValueDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::ValueDef::_nil ();
+    _tao_elem = IR_ValueDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::ValueDef::_nil ();
+  _tao_elem = IR_ValueDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::ValueDef,IR::ValueDef_var>;
+    template class TAO_Object_Manager<IR_ValueDef,IR_ValueDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::ValueDef,IR::ValueDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_ValueDef,IR_ValueDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-void operator<<= (CORBA::Any &_tao_any, const IR::ValueDescription &_tao_elem) // copying
+void operator<<= (CORBA::Any &_tao_any, const IR_ValueDescription &_tao_elem) // copying
 {
   TAO_OutputCDR stream;
   stream << _tao_elem;
@@ -60545,7 +35650,7 @@
     );
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::ValueDescription *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_ValueDescription *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -60555,16 +35660,16 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::ValueDescription::_tao_any_destructor
+      IR_ValueDescription::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ValueDescription *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ValueDescription *&_tao_elem)
 {
-  return _tao_any >>= ACE_const_cast(const IR::ValueDescription*&,_tao_elem);
+  return _tao_any >>= ACE_const_cast(const IR_ValueDescription*&,_tao_elem);
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ValueDescription *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ValueDescription *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -60578,15 +35683,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::ValueDescription*,
+          const IR_ValueDescription*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::ValueDescription *tmp;
-      ACE_NEW_RETURN (tmp, IR::ValueDescription, 0);
+      IR_ValueDescription *tmp;
+      ACE_NEW_RETURN (tmp, IR_ValueDescription, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -60597,7 +35702,7 @@
             IR::_tc_ValueDescription,
             1,
             ACE_static_cast (void *, tmp),
-            IR::ValueDescription::_tao_any_destructor
+            IR_ValueDescription::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -60615,11 +35720,11 @@
   return 0;
 }
 
-IR::_TAO_ValueBoxDef_Proxy_Broker * (*IR__TAO_ValueBoxDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_ValueBoxDef_Proxy_Broker * (*_TAO_ValueBoxDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::ValueBoxDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_ValueBoxDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -60629,17 +35734,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::ValueBoxDef::_duplicate (_tao_elem),
-        IR::ValueBoxDef::_tao_any_destructor
+        IR_ValueBoxDef::_duplicate (_tao_elem),
+        IR_ValueBoxDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ValueBoxDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ValueBoxDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::ValueBoxDef::_nil ();
+    _tao_elem = IR_ValueBoxDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_ValueBoxDef, ACE_TRY_ENV)) // not equal
       {
@@ -60656,33 +35761,33 @@
           IR::_tc_ValueBoxDef,
           1,
           _tao_elem,
-          IR::ValueBoxDef::_tao_any_destructor
+          IR_ValueBoxDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::ValueBoxDef::_nil ();
+    _tao_elem = IR_ValueBoxDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::ValueBoxDef::_nil ();
+  _tao_elem = IR_ValueBoxDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::ValueBoxDef,IR::ValueBoxDef_var>;
+    template class TAO_Object_Manager<IR_ValueBoxDef,IR_ValueBoxDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::ValueBoxDef,IR::ValueBoxDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_ValueBoxDef,IR_ValueBoxDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-IR::_TAO_ProvidesDef_Proxy_Broker * (*IR__TAO_ProvidesDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_ProvidesDef_Proxy_Broker * (*_TAO_ProvidesDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::ProvidesDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_ProvidesDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -60692,17 +35797,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::ProvidesDef::_duplicate (_tao_elem),
-        IR::ProvidesDef::_tao_any_destructor
+        IR_ProvidesDef::_duplicate (_tao_elem),
+        IR_ProvidesDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ProvidesDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ProvidesDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::ProvidesDef::_nil ();
+    _tao_elem = IR_ProvidesDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_ProvidesDef, ACE_TRY_ENV)) // not equal
       {
@@ -60719,29 +35824,29 @@
           IR::_tc_ProvidesDef,
           1,
           _tao_elem,
-          IR::ProvidesDef::_tao_any_destructor
+          IR_ProvidesDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::ProvidesDef::_nil ();
+    _tao_elem = IR_ProvidesDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::ProvidesDef::_nil ();
+  _tao_elem = IR_ProvidesDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::ProvidesDef,IR::ProvidesDef_var>;
+    template class TAO_Object_Manager<IR_ProvidesDef,IR_ProvidesDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::ProvidesDef,IR::ProvidesDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_ProvidesDef,IR_ProvidesDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-void operator<<= (CORBA::Any &_tao_any, const IR::ProvidesDescription &_tao_elem) // copying
+void operator<<= (CORBA::Any &_tao_any, const IR_ProvidesDescription &_tao_elem) // copying
 {
   TAO_OutputCDR stream;
   stream << _tao_elem;
@@ -60752,7 +35857,7 @@
     );
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::ProvidesDescription *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_ProvidesDescription *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -60762,16 +35867,16 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::ProvidesDescription::_tao_any_destructor
+      IR_ProvidesDescription::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ProvidesDescription *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ProvidesDescription *&_tao_elem)
 {
-  return _tao_any >>= ACE_const_cast(const IR::ProvidesDescription*&,_tao_elem);
+  return _tao_any >>= ACE_const_cast(const IR_ProvidesDescription*&,_tao_elem);
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ProvidesDescription *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ProvidesDescription *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -60785,15 +35890,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::ProvidesDescription*,
+          const IR_ProvidesDescription*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::ProvidesDescription *tmp;
-      ACE_NEW_RETURN (tmp, IR::ProvidesDescription, 0);
+      IR_ProvidesDescription *tmp;
+      ACE_NEW_RETURN (tmp, IR_ProvidesDescription, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -60804,7 +35909,7 @@
             IR::_tc_ProvidesDescription,
             1,
             ACE_static_cast (void *, tmp),
-            IR::ProvidesDescription::_tao_any_destructor
+            IR_ProvidesDescription::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -60822,11 +35927,11 @@
   return 0;
 }
 
-IR::_TAO_UsesDef_Proxy_Broker * (*IR__TAO_UsesDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_UsesDef_Proxy_Broker * (*_TAO_UsesDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::UsesDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_UsesDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -60836,17 +35941,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::UsesDef::_duplicate (_tao_elem),
-        IR::UsesDef::_tao_any_destructor
+        IR_UsesDef::_duplicate (_tao_elem),
+        IR_UsesDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::UsesDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_UsesDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::UsesDef::_nil ();
+    _tao_elem = IR_UsesDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_UsesDef, ACE_TRY_ENV)) // not equal
       {
@@ -60863,29 +35968,29 @@
           IR::_tc_UsesDef,
           1,
           _tao_elem,
-          IR::UsesDef::_tao_any_destructor
+          IR_UsesDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::UsesDef::_nil ();
+    _tao_elem = IR_UsesDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::UsesDef::_nil ();
+  _tao_elem = IR_UsesDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::UsesDef,IR::UsesDef_var>;
+    template class TAO_Object_Manager<IR_UsesDef,IR_UsesDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::UsesDef,IR::UsesDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_UsesDef,IR_UsesDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-void operator<<= (CORBA::Any &_tao_any, const IR::UsesDescription &_tao_elem) // copying
+void operator<<= (CORBA::Any &_tao_any, const IR_UsesDescription &_tao_elem) // copying
 {
   TAO_OutputCDR stream;
   stream << _tao_elem;
@@ -60896,7 +36001,7 @@
     );
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::UsesDescription *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_UsesDescription *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -60906,16 +36011,16 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::UsesDescription::_tao_any_destructor
+      IR_UsesDescription::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::UsesDescription *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_UsesDescription *&_tao_elem)
 {
-  return _tao_any >>= ACE_const_cast(const IR::UsesDescription*&,_tao_elem);
+  return _tao_any >>= ACE_const_cast(const IR_UsesDescription*&,_tao_elem);
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::UsesDescription *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_UsesDescription *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -60929,15 +36034,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::UsesDescription*,
+          const IR_UsesDescription*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::UsesDescription *tmp;
-      ACE_NEW_RETURN (tmp, IR::UsesDescription, 0);
+      IR_UsesDescription *tmp;
+      ACE_NEW_RETURN (tmp, IR_UsesDescription, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -60948,7 +36053,7 @@
             IR::_tc_UsesDescription,
             1,
             ACE_static_cast (void *, tmp),
-            IR::UsesDescription::_tao_any_destructor
+            IR_UsesDescription::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -60968,7 +36073,7 @@
 
 void operator<<= (
     CORBA::Any &_tao_any,
-    const IR::ProvidesDescSeq &_tao_elem
+    const IR_ProvidesDescSeq &_tao_elem
   ) // copying
 {
   TAO_OutputCDR stream;
@@ -60982,7 +36087,7 @@
   }
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::ProvidesDescSeq *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_ProvidesDescSeq *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -60992,19 +36097,19 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::ProvidesDescSeq::_tao_any_destructor
+      IR_ProvidesDescSeq::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ProvidesDescSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ProvidesDescSeq *&_tao_elem)
 {
   return _tao_any >>= ACE_const_cast(
-      const IR::ProvidesDescSeq*&,
+      const IR_ProvidesDescSeq*&,
       _tao_elem
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ProvidesDescSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ProvidesDescSeq *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -61018,15 +36123,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::ProvidesDescSeq*,
+          const IR_ProvidesDescSeq*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::ProvidesDescSeq *tmp;
-      ACE_NEW_RETURN (tmp, IR::ProvidesDescSeq, 0);
+      IR_ProvidesDescSeq *tmp;
+      ACE_NEW_RETURN (tmp, IR_ProvidesDescSeq, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -61037,7 +36142,7 @@
             IR::_tc_ProvidesDescSeq,
             1,
             ACE_static_cast (void *, tmp),
-            IR::ProvidesDescSeq::_tao_any_destructor
+            IR_ProvidesDescSeq::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -61057,7 +36162,7 @@
 
 void operator<<= (
     CORBA::Any &_tao_any,
-    const IR::UsesDescSeq &_tao_elem
+    const IR_UsesDescSeq &_tao_elem
   ) // copying
 {
   TAO_OutputCDR stream;
@@ -61071,7 +36176,7 @@
   }
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::UsesDescSeq *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_UsesDescSeq *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -61081,19 +36186,19 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::UsesDescSeq::_tao_any_destructor
+      IR_UsesDescSeq::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::UsesDescSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_UsesDescSeq *&_tao_elem)
 {
   return _tao_any >>= ACE_const_cast(
-      const IR::UsesDescSeq*&,
+      const IR_UsesDescSeq*&,
       _tao_elem
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::UsesDescSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_UsesDescSeq *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -61107,15 +36212,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::UsesDescSeq*,
+          const IR_UsesDescSeq*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::UsesDescSeq *tmp;
-      ACE_NEW_RETURN (tmp, IR::UsesDescSeq, 0);
+      IR_UsesDescSeq *tmp;
+      ACE_NEW_RETURN (tmp, IR_UsesDescSeq, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -61126,7 +36231,7 @@
             IR::_tc_UsesDescSeq,
             1,
             ACE_static_cast (void *, tmp),
-            IR::UsesDescSeq::_tao_any_destructor
+            IR_UsesDescSeq::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -61144,11 +36249,11 @@
   return 0;
 }
 
-IR::_TAO_EventDef_Proxy_Broker * (*IR__TAO_EventDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_EventDef_Proxy_Broker * (*_TAO_EventDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::EventDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_EventDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -61158,17 +36263,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::EventDef::_duplicate (_tao_elem),
-        IR::EventDef::_tao_any_destructor
+        IR_EventDef::_duplicate (_tao_elem),
+        IR_EventDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::EventDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_EventDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::EventDef::_nil ();
+    _tao_elem = IR_EventDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_EventDef, ACE_TRY_ENV)) // not equal
       {
@@ -61185,29 +36290,29 @@
           IR::_tc_EventDef,
           1,
           _tao_elem,
-          IR::EventDef::_tao_any_destructor
+          IR_EventDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::EventDef::_nil ();
+    _tao_elem = IR_EventDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::EventDef::_nil ();
+  _tao_elem = IR_EventDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::EventDef,IR::EventDef_var>;
+    template class TAO_Object_Manager<IR_EventDef,IR_EventDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::EventDef,IR::EventDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_EventDef,IR_EventDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-void operator<<= (CORBA::Any &_tao_any, const IR::EventDescription &_tao_elem) // copying
+void operator<<= (CORBA::Any &_tao_any, const IR_EventDescription &_tao_elem) // copying
 {
   TAO_OutputCDR stream;
   stream << _tao_elem;
@@ -61218,7 +36323,7 @@
     );
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::EventDescription *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_EventDescription *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -61228,16 +36333,16 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::EventDescription::_tao_any_destructor
+      IR_EventDescription::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::EventDescription *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_EventDescription *&_tao_elem)
 {
-  return _tao_any >>= ACE_const_cast(const IR::EventDescription*&,_tao_elem);
+  return _tao_any >>= ACE_const_cast(const IR_EventDescription*&,_tao_elem);
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::EventDescription *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_EventDescription *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -61251,15 +36356,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::EventDescription*,
+          const IR_EventDescription*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::EventDescription *tmp;
-      ACE_NEW_RETURN (tmp, IR::EventDescription, 0);
+      IR_EventDescription *tmp;
+      ACE_NEW_RETURN (tmp, IR_EventDescription, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -61270,7 +36375,7 @@
             IR::_tc_EventDescription,
             1,
             ACE_static_cast (void *, tmp),
-            IR::EventDescription::_tao_any_destructor
+            IR_EventDescription::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -61288,11 +36393,11 @@
   return 0;
 }
 
-IR::_TAO_EmitsDef_Proxy_Broker * (*IR__TAO_EmitsDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_EmitsDef_Proxy_Broker * (*_TAO_EmitsDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::EmitsDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_EmitsDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -61302,17 +36407,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::EmitsDef::_duplicate (_tao_elem),
-        IR::EmitsDef::_tao_any_destructor
+        IR_EmitsDef::_duplicate (_tao_elem),
+        IR_EmitsDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::EmitsDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_EmitsDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::EmitsDef::_nil ();
+    _tao_elem = IR_EmitsDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_EmitsDef, ACE_TRY_ENV)) // not equal
       {
@@ -61329,33 +36434,33 @@
           IR::_tc_EmitsDef,
           1,
           _tao_elem,
-          IR::EmitsDef::_tao_any_destructor
+          IR_EmitsDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::EmitsDef::_nil ();
+    _tao_elem = IR_EmitsDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::EmitsDef::_nil ();
+  _tao_elem = IR_EmitsDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::EmitsDef,IR::EmitsDef_var>;
+    template class TAO_Object_Manager<IR_EmitsDef,IR_EmitsDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::EmitsDef,IR::EmitsDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_EmitsDef,IR_EmitsDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-IR::_TAO_PublishesDef_Proxy_Broker * (*IR__TAO_PublishesDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_PublishesDef_Proxy_Broker * (*_TAO_PublishesDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::PublishesDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_PublishesDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -61365,17 +36470,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::PublishesDef::_duplicate (_tao_elem),
-        IR::PublishesDef::_tao_any_destructor
+        IR_PublishesDef::_duplicate (_tao_elem),
+        IR_PublishesDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::PublishesDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_PublishesDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::PublishesDef::_nil ();
+    _tao_elem = IR_PublishesDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_PublishesDef, ACE_TRY_ENV)) // not equal
       {
@@ -61392,33 +36497,33 @@
           IR::_tc_PublishesDef,
           1,
           _tao_elem,
-          IR::PublishesDef::_tao_any_destructor
+          IR_PublishesDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::PublishesDef::_nil ();
+    _tao_elem = IR_PublishesDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::PublishesDef::_nil ();
+  _tao_elem = IR_PublishesDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::PublishesDef,IR::PublishesDef_var>;
+    template class TAO_Object_Manager<IR_PublishesDef,IR_PublishesDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::PublishesDef,IR::PublishesDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_PublishesDef,IR_PublishesDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-IR::_TAO_ConsumesDef_Proxy_Broker * (*IR__TAO_ConsumesDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_ConsumesDef_Proxy_Broker * (*_TAO_ConsumesDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::ConsumesDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_ConsumesDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -61428,17 +36533,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::ConsumesDef::_duplicate (_tao_elem),
-        IR::ConsumesDef::_tao_any_destructor
+        IR_ConsumesDef::_duplicate (_tao_elem),
+        IR_ConsumesDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ConsumesDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ConsumesDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::ConsumesDef::_nil ();
+    _tao_elem = IR_ConsumesDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_ConsumesDef, ACE_TRY_ENV)) // not equal
       {
@@ -61455,33 +36560,33 @@
           IR::_tc_ConsumesDef,
           1,
           _tao_elem,
-          IR::ConsumesDef::_tao_any_destructor
+          IR_ConsumesDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::ConsumesDef::_nil ();
+    _tao_elem = IR_ConsumesDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::ConsumesDef::_nil ();
+  _tao_elem = IR_ConsumesDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::ConsumesDef,IR::ConsumesDef_var>;
+    template class TAO_Object_Manager<IR_ConsumesDef,IR_ConsumesDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::ConsumesDef,IR::ConsumesDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_ConsumesDef,IR_ConsumesDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-IR::_TAO_ComponentDef_Proxy_Broker * (*IR__TAO_ComponentDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_ComponentDef_Proxy_Broker * (*_TAO_ComponentDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::ComponentDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_ComponentDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -61491,17 +36596,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::ComponentDef::_duplicate (_tao_elem),
-        IR::ComponentDef::_tao_any_destructor
+        IR_ComponentDef::_duplicate (_tao_elem),
+        IR_ComponentDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ComponentDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ComponentDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::ComponentDef::_nil ();
+    _tao_elem = IR_ComponentDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_ComponentDef, ACE_TRY_ENV)) // not equal
       {
@@ -61518,29 +36623,29 @@
           IR::_tc_ComponentDef,
           1,
           _tao_elem,
-          IR::ComponentDef::_tao_any_destructor
+          IR_ComponentDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::ComponentDef::_nil ();
+    _tao_elem = IR_ComponentDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::ComponentDef::_nil ();
+  _tao_elem = IR_ComponentDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::ComponentDef,IR::ComponentDef_var>;
+    template class TAO_Object_Manager<IR_ComponentDef,IR_ComponentDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::ComponentDef,IR::ComponentDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_ComponentDef,IR_ComponentDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-void operator<<= (CORBA::Any &_tao_any, const IR::ComponentDescription &_tao_elem) // copying
+void operator<<= (CORBA::Any &_tao_any, const IR_ComponentDescription &_tao_elem) // copying
 {
   TAO_OutputCDR stream;
   stream << _tao_elem;
@@ -61551,7 +36656,7 @@
     );
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::ComponentDescription *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_ComponentDescription *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -61561,16 +36666,16 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::ComponentDescription::_tao_any_destructor
+      IR_ComponentDescription::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ComponentDescription *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ComponentDescription *&_tao_elem)
 {
-  return _tao_any >>= ACE_const_cast(const IR::ComponentDescription*&,_tao_elem);
+  return _tao_any >>= ACE_const_cast(const IR_ComponentDescription*&,_tao_elem);
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ComponentDescription *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ComponentDescription *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -61584,15 +36689,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::ComponentDescription*,
+          const IR_ComponentDescription*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::ComponentDescription *tmp;
-      ACE_NEW_RETURN (tmp, IR::ComponentDescription, 0);
+      IR_ComponentDescription *tmp;
+      ACE_NEW_RETURN (tmp, IR_ComponentDescription, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -61603,7 +36708,7 @@
             IR::_tc_ComponentDescription,
             1,
             ACE_static_cast (void *, tmp),
-            IR::ComponentDescription::_tao_any_destructor
+            IR_ComponentDescription::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -61621,11 +36726,11 @@
   return 0;
 }
 
-IR::_TAO_PrimaryKeyDef_Proxy_Broker * (*IR__TAO_PrimaryKeyDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_PrimaryKeyDef_Proxy_Broker * (*_TAO_PrimaryKeyDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::PrimaryKeyDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_PrimaryKeyDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -61635,17 +36740,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::PrimaryKeyDef::_duplicate (_tao_elem),
-        IR::PrimaryKeyDef::_tao_any_destructor
+        IR_PrimaryKeyDef::_duplicate (_tao_elem),
+        IR_PrimaryKeyDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::PrimaryKeyDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_PrimaryKeyDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::PrimaryKeyDef::_nil ();
+    _tao_elem = IR_PrimaryKeyDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_PrimaryKeyDef, ACE_TRY_ENV)) // not equal
       {
@@ -61662,29 +36767,29 @@
           IR::_tc_PrimaryKeyDef,
           1,
           _tao_elem,
-          IR::PrimaryKeyDef::_tao_any_destructor
+          IR_PrimaryKeyDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::PrimaryKeyDef::_nil ();
+    _tao_elem = IR_PrimaryKeyDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::PrimaryKeyDef::_nil ();
+  _tao_elem = IR_PrimaryKeyDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::PrimaryKeyDef,IR::PrimaryKeyDef_var>;
+    template class TAO_Object_Manager<IR_PrimaryKeyDef,IR_PrimaryKeyDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::PrimaryKeyDef,IR::PrimaryKeyDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_PrimaryKeyDef,IR_PrimaryKeyDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-void operator<<= (CORBA::Any &_tao_any, const IR::PrimaryKeyDescription &_tao_elem) // copying
+void operator<<= (CORBA::Any &_tao_any, const IR_PrimaryKeyDescription &_tao_elem) // copying
 {
   TAO_OutputCDR stream;
   stream << _tao_elem;
@@ -61695,7 +36800,7 @@
     );
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::PrimaryKeyDescription *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_PrimaryKeyDescription *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -61705,16 +36810,16 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::PrimaryKeyDescription::_tao_any_destructor
+      IR_PrimaryKeyDescription::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::PrimaryKeyDescription *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_PrimaryKeyDescription *&_tao_elem)
 {
-  return _tao_any >>= ACE_const_cast(const IR::PrimaryKeyDescription*&,_tao_elem);
+  return _tao_any >>= ACE_const_cast(const IR_PrimaryKeyDescription*&,_tao_elem);
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::PrimaryKeyDescription *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_PrimaryKeyDescription *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -61728,15 +36833,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::PrimaryKeyDescription*,
+          const IR_PrimaryKeyDescription*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::PrimaryKeyDescription *tmp;
-      ACE_NEW_RETURN (tmp, IR::PrimaryKeyDescription, 0);
+      IR_PrimaryKeyDescription *tmp;
+      ACE_NEW_RETURN (tmp, IR_PrimaryKeyDescription, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -61747,7 +36852,7 @@
             IR::_tc_PrimaryKeyDescription,
             1,
             ACE_static_cast (void *, tmp),
-            IR::PrimaryKeyDescription::_tao_any_destructor
+            IR_PrimaryKeyDescription::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -61765,11 +36870,11 @@
   return 0;
 }
 
-IR::_TAO_FactoryDef_Proxy_Broker * (*IR__TAO_FactoryDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_FactoryDef_Proxy_Broker * (*_TAO_FactoryDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::FactoryDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_FactoryDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -61779,17 +36884,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::FactoryDef::_duplicate (_tao_elem),
-        IR::FactoryDef::_tao_any_destructor
+        IR_FactoryDef::_duplicate (_tao_elem),
+        IR_FactoryDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::FactoryDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_FactoryDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::FactoryDef::_nil ();
+    _tao_elem = IR_FactoryDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_FactoryDef, ACE_TRY_ENV)) // not equal
       {
@@ -61806,33 +36911,33 @@
           IR::_tc_FactoryDef,
           1,
           _tao_elem,
-          IR::FactoryDef::_tao_any_destructor
+          IR_FactoryDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::FactoryDef::_nil ();
+    _tao_elem = IR_FactoryDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::FactoryDef::_nil ();
+  _tao_elem = IR_FactoryDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::FactoryDef,IR::FactoryDef_var>;
+    template class TAO_Object_Manager<IR_FactoryDef,IR_FactoryDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::FactoryDef,IR::FactoryDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_FactoryDef,IR_FactoryDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-IR::_TAO_FinderDef_Proxy_Broker * (*IR__TAO_FinderDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_FinderDef_Proxy_Broker * (*_TAO_FinderDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::FinderDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_FinderDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -61842,17 +36947,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::FinderDef::_duplicate (_tao_elem),
-        IR::FinderDef::_tao_any_destructor
+        IR_FinderDef::_duplicate (_tao_elem),
+        IR_FinderDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::FinderDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_FinderDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::FinderDef::_nil ();
+    _tao_elem = IR_FinderDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_FinderDef, ACE_TRY_ENV)) // not equal
       {
@@ -61869,33 +36974,33 @@
           IR::_tc_FinderDef,
           1,
           _tao_elem,
-          IR::FinderDef::_tao_any_destructor
+          IR_FinderDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::FinderDef::_nil ();
+    _tao_elem = IR_FinderDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::FinderDef::_nil ();
+  _tao_elem = IR_FinderDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::FinderDef,IR::FinderDef_var>;
+    template class TAO_Object_Manager<IR_FinderDef,IR_FinderDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::FinderDef,IR::FinderDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_FinderDef,IR_FinderDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-IR::_TAO_HomeDef_Proxy_Broker * (*IR__TAO_HomeDef_Proxy_Broker_Factory_function_pointer) (
+_TAO_HomeDef_Proxy_Broker * (*_TAO_HomeDef_Proxy_Broker_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 
-void operator<<= (CORBA::Any &_tao_any, IR::HomeDef_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, IR_HomeDef_ptr _tao_elem)
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
@@ -61905,17 +37010,17 @@
         TAO_ENCAP_BYTE_ORDER,
         stream.begin (),
         1,
-        IR::HomeDef::_duplicate (_tao_elem),
-        IR::HomeDef::_tao_any_destructor
+        IR_HomeDef::_duplicate (_tao_elem),
+        IR_HomeDef::_tao_any_destructor
       );
   }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::HomeDef_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_HomeDef_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = IR::HomeDef::_nil ();
+    _tao_elem = IR_HomeDef::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (IR::_tc_HomeDef, ACE_TRY_ENV)) // not equal
       {
@@ -61932,29 +37037,29 @@
           IR::_tc_HomeDef,
           1,
           _tao_elem,
-          IR::HomeDef::_tao_any_destructor
+          IR_HomeDef::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = IR::HomeDef::_nil ();
+    _tao_elem = IR_HomeDef::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = IR::HomeDef::_nil ();
+  _tao_elem = IR_HomeDef::_nil ();
   return 0;
 }
 
 #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
     defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<IR::HomeDef,IR::HomeDef_var>;
+    template class TAO_Object_Manager<IR_HomeDef,IR_HomeDef_var>;
   #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<IR::HomeDef,IR::HomeDef_var>
+  #  pragma instantiate TAO_Object_Manager<IR_HomeDef,IR_HomeDef_var>
 #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
 
-void operator<<= (CORBA::Any &_tao_any, const IR::HomeDescription &_tao_elem) // copying
+void operator<<= (CORBA::Any &_tao_any, const IR_HomeDescription &_tao_elem) // copying
 {
   TAO_OutputCDR stream;
   stream << _tao_elem;
@@ -61965,7 +37070,7 @@
     );
 }
 
-void operator<<= (CORBA::Any &_tao_any, IR::HomeDescription *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, IR_HomeDescription *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -61975,16 +37080,16 @@
       stream.begin (),
       1,
       _tao_elem,
-      IR::HomeDescription::_tao_any_destructor
+      IR_HomeDescription::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::HomeDescription *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_HomeDescription *&_tao_elem)
 {
-  return _tao_any >>= ACE_const_cast(const IR::HomeDescription*&,_tao_elem);
+  return _tao_any >>= ACE_const_cast(const IR_HomeDescription*&,_tao_elem);
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::HomeDescription *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_HomeDescription *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
@@ -61998,15 +37103,15 @@
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const IR::HomeDescription*,
+          const IR_HomeDescription*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      IR::HomeDescription *tmp;
-      ACE_NEW_RETURN (tmp, IR::HomeDescription, 0);
+      IR_HomeDescription *tmp;
+      ACE_NEW_RETURN (tmp, IR_HomeDescription, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -62017,7 +37122,7 @@
             IR::_tc_HomeDescription,
             1,
             ACE_static_cast (void *, tmp),
-            IR::HomeDescription::_tao_any_destructor
+            IR_HomeDescription::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -62037,7 +37142,7 @@
 
 CORBA::Boolean operator<< (
     TAO_OutputCDR &strm,
-    const IR::InterfaceDefSeq &_tao_sequence
+    const IR_InterfaceDefSeq &_tao_sequence
   )
 {
   if (strm << _tao_sequence.length ())
@@ -62055,7 +37160,7 @@
 
 CORBA::Boolean operator>> (
     TAO_InputCDR &strm,
-    IR::InterfaceDefSeq &_tao_sequence
+    IR_InterfaceDefSeq &_tao_sequence
   )
 {
   CORBA::ULong _tao_seq_len;
@@ -62079,7 +37184,7 @@
 
 CORBA::Boolean operator<< (
     TAO_OutputCDR &strm,
-    const IR::ValueDefSeq &_tao_sequence
+    const IR_ValueDefSeq &_tao_sequence
   )
 {
   if (strm << _tao_sequence.length ())
@@ -62097,7 +37202,7 @@
 
 CORBA::Boolean operator>> (
     TAO_InputCDR &strm,
-    IR::ValueDefSeq &_tao_sequence
+    IR_ValueDefSeq &_tao_sequence
   )
 {
   CORBA::ULong _tao_seq_len;
@@ -62121,7 +37226,7 @@
 
 CORBA::Boolean operator<< (
     TAO_OutputCDR &strm,
-    const IR::ComponentDefSeq &_tao_sequence
+    const IR_ComponentDefSeq &_tao_sequence
   )
 {
   if (strm << _tao_sequence.length ())
@@ -62139,7 +37244,7 @@
 
 CORBA::Boolean operator>> (
     TAO_InputCDR &strm,
-    IR::ComponentDefSeq &_tao_sequence
+    IR_ComponentDefSeq &_tao_sequence
   )
 {
   CORBA::ULong _tao_seq_len;
@@ -62163,7 +37268,7 @@
 
 CORBA::Boolean operator<< (
     TAO_OutputCDR &strm,
-    const IR::ProvidesDefSeq &_tao_sequence
+    const IR_ProvidesDefSeq &_tao_sequence
   )
 {
   if (strm << _tao_sequence.length ())
@@ -62181,7 +37286,7 @@
 
 CORBA::Boolean operator>> (
     TAO_InputCDR &strm,
-    IR::ProvidesDefSeq &_tao_sequence
+    IR_ProvidesDefSeq &_tao_sequence
   )
 {
   CORBA::ULong _tao_seq_len;
@@ -62205,7 +37310,7 @@
 
 CORBA::Boolean operator<< (
     TAO_OutputCDR &strm,
-    const IR::UsesDefSeq &_tao_sequence
+    const IR_UsesDefSeq &_tao_sequence
   )
 {
   if (strm << _tao_sequence.length ())
@@ -62223,7 +37328,7 @@
 
 CORBA::Boolean operator>> (
     TAO_InputCDR &strm,
-    IR::UsesDefSeq &_tao_sequence
+    IR_UsesDefSeq &_tao_sequence
   )
 {
   CORBA::ULong _tao_seq_len;
@@ -62247,7 +37352,7 @@
 
 CORBA::Boolean operator<< (
     TAO_OutputCDR &strm,
-    const IR::HomeDefSeq &_tao_sequence
+    const IR_HomeDefSeq &_tao_sequence
   )
 {
   if (strm << _tao_sequence.length ())
@@ -62265,7 +37370,7 @@
 
 CORBA::Boolean operator>> (
     TAO_InputCDR &strm,
-    IR::HomeDefSeq &_tao_sequence
+    IR_HomeDefSeq &_tao_sequence
   )
 {
   CORBA::ULong _tao_seq_len;
@@ -62289,7 +37394,7 @@
 
 CORBA::Boolean operator<< (
     TAO_OutputCDR &strm,
-    const IR::EmitsDefSeq &_tao_sequence
+    const IR_EmitsDefSeq &_tao_sequence
   )
 {
   if (strm << _tao_sequence.length ())
@@ -62307,7 +37412,7 @@
 
 CORBA::Boolean operator>> (
     TAO_InputCDR &strm,
-    IR::EmitsDefSeq &_tao_sequence
+    IR_EmitsDefSeq &_tao_sequence
   )
 {
   CORBA::ULong _tao_seq_len;
@@ -62331,7 +37436,7 @@
 
 CORBA::Boolean operator<< (
     TAO_OutputCDR &strm,
-    const IR::PublishesDefSeq &_tao_sequence
+    const IR_PublishesDefSeq &_tao_sequence
   )
 {
   if (strm << _tao_sequence.length ())
@@ -62349,7 +37454,7 @@
 
 CORBA::Boolean operator>> (
     TAO_InputCDR &strm,
-    IR::PublishesDefSeq &_tao_sequence
+    IR_PublishesDefSeq &_tao_sequence
   )
 {
   CORBA::ULong _tao_seq_len;
@@ -62373,7 +37478,7 @@
 
 CORBA::Boolean operator<< (
     TAO_OutputCDR &strm,
-    const IR::ConsumesDefSeq &_tao_sequence
+    const IR_ConsumesDefSeq &_tao_sequence
   )
 {
   if (strm << _tao_sequence.length ())
@@ -62391,7 +37496,7 @@
 
 CORBA::Boolean operator>> (
     TAO_InputCDR &strm,
-    IR::ConsumesDefSeq &_tao_sequence
+    IR_ConsumesDefSeq &_tao_sequence
   )
 {
   CORBA::ULong _tao_seq_len;
@@ -62415,7 +37520,7 @@
 
 CORBA::Boolean operator<< (
     TAO_OutputCDR &strm,
-    const IR::FactoryDefSeq &_tao_sequence
+    const IR_FactoryDefSeq &_tao_sequence
   )
 {
   if (strm << _tao_sequence.length ())
@@ -62433,7 +37538,7 @@
 
 CORBA::Boolean operator>> (
     TAO_InputCDR &strm,
-    IR::FactoryDefSeq &_tao_sequence
+    IR_FactoryDefSeq &_tao_sequence
   )
 {
   CORBA::ULong _tao_seq_len;
@@ -62457,7 +37562,7 @@
 
 CORBA::Boolean operator<< (
     TAO_OutputCDR &strm,
-    const IR::FinderDefSeq &_tao_sequence
+    const IR_FinderDefSeq &_tao_sequence
   )
 {
   if (strm << _tao_sequence.length ())
@@ -62475,7 +37580,7 @@
 
 CORBA::Boolean operator>> (
     TAO_InputCDR &strm,
-    IR::FinderDefSeq &_tao_sequence
+    IR_FinderDefSeq &_tao_sequence
   )
 {
   CORBA::ULong _tao_seq_len;
@@ -62499,7 +37604,7 @@
 
 CORBA::Boolean operator<< (
     TAO_OutputCDR &strm,
-    const IR::ContainedSeq &_tao_sequence
+    const IR_ContainedSeq &_tao_sequence
   )
 {
   if (strm << _tao_sequence.length ())
@@ -62517,7 +37622,7 @@
 
 CORBA::Boolean operator>> (
     TAO_InputCDR &strm,
-    IR::ContainedSeq &_tao_sequence
+    IR_ContainedSeq &_tao_sequence
   )
 {
   CORBA::ULong _tao_seq_len;
@@ -62541,7 +37646,7 @@
 
 CORBA::Boolean operator<< (
     TAO_OutputCDR &strm,
-    const IR::StructMemberSeq &_tao_sequence
+    const IR_StructMemberSeq &_tao_sequence
   )
 {
   if (strm << _tao_sequence.length ())
@@ -62559,7 +37664,7 @@
 
 CORBA::Boolean operator>> (
     TAO_InputCDR &strm,
-    IR::StructMemberSeq &_tao_sequence
+    IR_StructMemberSeq &_tao_sequence
   )
 {
   CORBA::ULong _tao_seq_len;
@@ -62583,7 +37688,7 @@
 
 CORBA::Boolean operator<< (
     TAO_OutputCDR &strm,
-    const IR::InitializerSeq &_tao_sequence
+    const IR_InitializerSeq &_tao_sequence
   )
 {
   if (strm << _tao_sequence.length ())
@@ -62601,7 +37706,7 @@
 
 CORBA::Boolean operator>> (
     TAO_InputCDR &strm,
-    IR::InitializerSeq &_tao_sequence
+    IR_InitializerSeq &_tao_sequence
   )
 {
   CORBA::ULong _tao_seq_len;
@@ -62625,7 +37730,7 @@
 
 CORBA::Boolean operator<< (
     TAO_OutputCDR &strm,
-    const IR::UnionMemberSeq &_tao_sequence
+    const IR_UnionMemberSeq &_tao_sequence
   )
 {
   if (strm << _tao_sequence.length ())
@@ -62643,7 +37748,7 @@
 
 CORBA::Boolean operator>> (
     TAO_InputCDR &strm,
-    IR::UnionMemberSeq &_tao_sequence
+    IR_UnionMemberSeq &_tao_sequence
   )
 {
   CORBA::ULong _tao_seq_len;
@@ -62667,7 +37772,7 @@
 
 CORBA::Boolean operator<< (
     TAO_OutputCDR &strm,
-    const IR::EnumMemberSeq &_tao_sequence
+    const IR_EnumMemberSeq &_tao_sequence
   )
 {
   if (strm << _tao_sequence.length ())
@@ -62685,7 +37790,7 @@
 
 CORBA::Boolean operator>> (
     TAO_InputCDR &strm,
-    IR::EnumMemberSeq &_tao_sequence
+    IR_EnumMemberSeq &_tao_sequence
   )
 {
   CORBA::ULong _tao_seq_len;
@@ -62709,7 +37814,7 @@
 
 CORBA::Boolean operator<< (
     TAO_OutputCDR &strm,
-    const IR::Container::DescriptionSeq &_tao_sequence
+    const IR_Container::DescriptionSeq &_tao_sequence
   )
 {
   if (strm << _tao_sequence.length ())
@@ -62727,7 +37832,7 @@
 
 CORBA::Boolean operator>> (
     TAO_InputCDR &strm,
-    IR::Container::DescriptionSeq &_tao_sequence
+    IR_Container::DescriptionSeq &_tao_sequence
   )
 {
   CORBA::ULong _tao_seq_len;
@@ -62751,7 +37856,7 @@
 
 CORBA::Boolean operator<< (
     TAO_OutputCDR &strm,
-    const IR::ExceptionDefSeq &_tao_sequence
+    const IR_ExceptionDefSeq &_tao_sequence
   )
 {
   if (strm << _tao_sequence.length ())
@@ -62769,7 +37874,7 @@
 
 CORBA::Boolean operator>> (
     TAO_InputCDR &strm,
-    IR::ExceptionDefSeq &_tao_sequence
+    IR_ExceptionDefSeq &_tao_sequence
   )
 {
   CORBA::ULong _tao_seq_len;
@@ -62793,7 +37898,7 @@
 
 CORBA::Boolean operator<< (
     TAO_OutputCDR &strm,
-    const IR::ExcDescriptionSeq &_tao_sequence
+    const IR_ExcDescriptionSeq &_tao_sequence
   )
 {
   if (strm << _tao_sequence.length ())
@@ -62811,7 +37916,7 @@
 
 CORBA::Boolean operator>> (
     TAO_InputCDR &strm,
-    IR::ExcDescriptionSeq &_tao_sequence
+    IR_ExcDescriptionSeq &_tao_sequence
   )
 {
   CORBA::ULong _tao_seq_len;
@@ -62835,7 +37940,7 @@
 
 CORBA::Boolean operator<< (
     TAO_OutputCDR &strm,
-    const IR::ParDescriptionSeq &_tao_sequence
+    const IR_ParDescriptionSeq &_tao_sequence
   )
 {
   if (strm << _tao_sequence.length ())
@@ -62853,7 +37958,7 @@
 
 CORBA::Boolean operator>> (
     TAO_InputCDR &strm,
-    IR::ParDescriptionSeq &_tao_sequence
+    IR_ParDescriptionSeq &_tao_sequence
   )
 {
   CORBA::ULong _tao_seq_len;
@@ -62877,7 +37982,7 @@
 
 CORBA::Boolean operator<< (
     TAO_OutputCDR &strm,
-    const IR::ContextIdSeq &_tao_sequence
+    const IR_ContextIdSeq &_tao_sequence
   )
 {
   if (strm << _tao_sequence.length ())
@@ -62895,7 +38000,7 @@
 
 CORBA::Boolean operator>> (
     TAO_InputCDR &strm,
-    IR::ContextIdSeq &_tao_sequence
+    IR_ContextIdSeq &_tao_sequence
   )
 {
   CORBA::ULong _tao_seq_len;
@@ -62919,7 +38024,7 @@
 
 CORBA::Boolean operator<< (
     TAO_OutputCDR &strm,
-    const IR::RepositoryIdSeq &_tao_sequence
+    const IR_RepositoryIdSeq &_tao_sequence
   )
 {
   if (strm << _tao_sequence.length ())
@@ -62937,7 +38042,7 @@
 
 CORBA::Boolean operator>> (
     TAO_InputCDR &strm,
-    IR::RepositoryIdSeq &_tao_sequence
+    IR_RepositoryIdSeq &_tao_sequence
   )
 {
   CORBA::ULong _tao_seq_len;
@@ -62961,7 +38066,7 @@
 
 CORBA::Boolean operator<< (
     TAO_OutputCDR &strm,
-    const IR::OpDescriptionSeq &_tao_sequence
+    const IR_OpDescriptionSeq &_tao_sequence
   )
 {
   if (strm << _tao_sequence.length ())
@@ -62979,7 +38084,7 @@
 
 CORBA::Boolean operator>> (
     TAO_InputCDR &strm,
-    IR::OpDescriptionSeq &_tao_sequence
+    IR_OpDescriptionSeq &_tao_sequence
   )
 {
   CORBA::ULong _tao_seq_len;
@@ -63003,7 +38108,7 @@
 
 CORBA::Boolean operator<< (
     TAO_OutputCDR &strm,
-    const IR::AttrDescriptionSeq &_tao_sequence
+    const IR_AttrDescriptionSeq &_tao_sequence
   )
 {
   if (strm << _tao_sequence.length ())
@@ -63021,7 +38126,7 @@
 
 CORBA::Boolean operator>> (
     TAO_InputCDR &strm,
-    IR::AttrDescriptionSeq &_tao_sequence
+    IR_AttrDescriptionSeq &_tao_sequence
   )
 {
   CORBA::ULong _tao_seq_len;
@@ -63045,7 +38150,7 @@
 
 CORBA::Boolean operator<< (
     TAO_OutputCDR &strm,
-    const IR::ValueMemberSeq &_tao_sequence
+    const IR_ValueMemberSeq &_tao_sequence
   )
 {
   if (strm << _tao_sequence.length ())
@@ -63063,7 +38168,7 @@
 
 CORBA::Boolean operator>> (
     TAO_InputCDR &strm,
-    IR::ValueMemberSeq &_tao_sequence
+    IR_ValueMemberSeq &_tao_sequence
   )
 {
   CORBA::ULong _tao_seq_len;
@@ -63087,7 +38192,7 @@
 
 CORBA::Boolean operator<< (
     TAO_OutputCDR &strm,
-    const IR::ProvidesDescSeq &_tao_sequence
+    const IR_ProvidesDescSeq &_tao_sequence
   )
 {
   if (strm << _tao_sequence.length ())
@@ -63105,7 +38210,7 @@
 
 CORBA::Boolean operator>> (
     TAO_InputCDR &strm,
-    IR::ProvidesDescSeq &_tao_sequence
+    IR_ProvidesDescSeq &_tao_sequence
   )
 {
   CORBA::ULong _tao_seq_len;
@@ -63129,7 +38234,7 @@
 
 CORBA::Boolean operator<< (
     TAO_OutputCDR &strm,
-    const IR::UsesDescSeq &_tao_sequence
+    const IR_UsesDescSeq &_tao_sequence
   )
 {
   if (strm << _tao_sequence.length ())
@@ -63147,7 +38252,7 @@
 
 CORBA::Boolean operator>> (
     TAO_InputCDR &strm,
-    IR::UsesDescSeq &_tao_sequence
+    IR_UsesDescSeq &_tao_sequence
   )
 {
   CORBA::ULong _tao_seq_len;
