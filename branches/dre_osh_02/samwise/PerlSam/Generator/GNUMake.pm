# $Id$

package PerlSam::Generator::GNUMake;

use Cwd;
use Data::Dumper;
use File::Basename;
use FileHandle;
use strict;

###############################################################################
# Forward Declarations


###############################################################################
# Constructor

sub new (@)
{
    my $proto = shift;
    my $class = ref ($proto) || $proto;
    my $self = {};

    bless ($self, $class);
    return $self;
}

###############################################################################
# Methods

sub GenerateWorkspace (\%)
{
    my $self = shift;
    my $data = shift;

    my $string;

    $string .= "#----------------------------------------------------------------------------\n";
    $string .= "#\n";
    $string .= "#      \$Id\$\n";
    $string .= "#\n";
    $string .= "#      GNU Workspace Makefile generated by the Samwise Compiler\n";
    $string .= "#\n";
    $string .= "#----------------------------------------------------------------------------\n";
    $string .= "\n";
    $string .= "#----------------------------------------------------------------------------\n";
    $string .= "#       Subdirectories\n";
    $string .= "#----------------------------------------------------------------------------\n";
    $string .= "\n";
    $string .= "DIRS =";

    foreach my $dir (@{$data->{WORKSPACE}->{SUBDIRS}}) {
        $string .= " \\\n  $dir";
    }
    $string .= "\n";
    $string .= "\n";

    $string .= "#----------------------------------------------------------------------------\n";
    $string .= "#       Subprojects\n";
    $string .= "#----------------------------------------------------------------------------\n";

    $string .= "\n";
    $string .= "MAKEFILES =";

    foreach my $project (PerlSam::Generator::ProjectOrder (%{$data})) {
        $string .= " \\\n  $project.gnu";
    }
    $string .= "\n";
    $string .= "\n";

    $string .= "#----------------------------------------------------------------------------\n";
    $string .= "#       Include macros and targets\n";
    $string .= "#----------------------------------------------------------------------------\n";
    $string .= "\n";

    my $ace_root = PerlSam::Generator::ConvertPathToRelative ("/");

    # Only put this in if we are in the ACE_wrappers tree
    if ($ace_root ne "\$ACE_ROOT/") {
        $string .= "ifndef ACE_ROOT\n";
        $string .= "  ACE_ROOT = $ace_root\n";
        $string .= "endif\n";
        $string .= "\n";
    }

    $string .= "include \$(ACE_ROOT)/samwise/makeinclude/workspace.GNU\n";
    $string .= "\n";

    my $file_name = "GNUmakefile";

    print "Creating Workspace: $file_name\n";

    my $file_handle = new FileHandle ($file_name, "w");
    print $file_handle $string;
}

sub GenerateProjects (\%)
{
    my $self = shift;
    my $data = shift;

    foreach my $project (sort keys %{$data->{PROJECTS}}) {
        my $string;
        my $description = $data->{PROJECTS}->{$project}->{DESCRIPTION};
        my $target = $data->{PROJECTS}->{$project}->{TARGET};
        my $type = $data->{PROJECTS}->{$project}->{TYPE};

        my $file_name = $project . ".gnu";

        $string .= "#----------------------------------------------------------------------------\n";
        $string .= "#\n";
        $string .= "#      \$Id\$\n";
        $string .= "#\n";
        $string .= "#      GNU Project Makefile generated by the Samwise Compiler\n";
        $string .= "#      Project Description: $description\n";
        $string .= "#\n";
        $string .= "#----------------------------------------------------------------------------\n";
        $string .= "\n";

        my $ace_root = PerlSam::Generator::ConvertPathToRelative ("/");

        # Only put this in if we are in the ACE_wrappers tree
        if ($ace_root ne "\$ACE_ROOT/") {
            $string .= "ifndef ACE_ROOT\n";
            $string .= "  ACE_ROOT = $ace_root\n";
            $string .= "endif\n";
            $string .= "\n";
        }

        if ($type ne 'executable' && $type ne 'library') {
            die "Unknown project type $type\n";
        }

        $string .= "MAKEFILE = $file_name\n\n";

        my @project_libs = ();
        if (defined $data->{PROJECTS}->{$project}->{LIBS}) {
          @project_libs = @{$data->{PROJECTS}->{$project}->{LIBS}};
        }
        # Libraries need to add their own -I directory to the list!
        if (defined $data->{PROJECTS}->{$project}->{LIBINFO}->{NAMESPACE}
            && defined $data->{PROJECTS}->{$project}->{LIBINFO}->{NAME}) {
          push @project_libs,
               $data->{PROJECTS}->{$project}->{LIBINFO}->{NAMESPACE}
               .'::'
               .$data->{PROJECTS}->{$project}->{LIBINFO}->{NAME};
        }
        my $dirs = PerlSam::Generator::ExpandIncludeDirs (@project_libs);
	my $include_dirs = PerlSam::Generator::ConvertPathToRelative ($dirs);

        $string .= "CPPFLAGS += ";
        foreach my $inc (split / /, $include_dirs) {
	  $string .= "\\\n  -I".$inc;
        }

        # and we also need to add any local includes....
        if (defined $data->{PROJECTS}->{$project}->{LIBINFO}->{INCLUDE}) {
          foreach my $inc (split / /, $data->{PROJECTS}->{$project}->{LIBINFO}->{INCLUDE}) {
            $string .= "\\\n  -I".$inc;
          }
        }

        $string .= "\n";

        $string .= "LDLIBS =";

        my $libs = PerlSam::Generator::ExpandLibraries (@{$data->{PROJECTS}->{$project}->{LIBS}});

        foreach my $lib (reverse split / /, $libs) {
            $string .= " \\\n  -L".File::Basename::dirname ($lib);
            $string .= " \\\n  -l".File::Basename::basename ($lib);
        }
        $string .= "\n";

        if ($type eq 'library') {
            $string .= "ACE_SHLIBS =";

            foreach my $lib (split / /, $libs) {
                $string .= " \\\n  -L".File::Basename::dirname ($lib);
                $string .= " \\\n  -l".File::Basename::basename ($lib);
            }
            $string .= "\n";
        }

        my $SRC_MACRO = '';
        my $GNU_INCLUDE = '';

        if ($type eq 'executable') {
            $string .= "BIN = $target\n";
            $SRC_MACRO = 'SRC';
            $GNU_INCLUDE = 'executable.GNU';
        }
        elsif ($type eq 'library') {
            $string .= "LIBNAME = $target\n";
            $string .= "LIB = lib\$(LIBNAME).a\n";
            $string .= "SHLIB = lib\$(LIBNAME).\$(SOEXT)\n";
            $SRC_MACRO = 'LSRC';
            $GNU_INCLUDE = 'library.GNU';
        }

        my %vpath = ();
        $string .= "$SRC_MACRO=";
        foreach my $src (sort keys %{$data->{PROJECTS}->{$project}->{SOURCES}}) {
            my $type = $data->{PROJECTS}->{$project}->{SOURCES}->{$src}->{TYPE};

            if (defined $type && $type eq 'template') {
                next;
            }

            if ($src =~ /\.cpp$/
                || $src =~ /\.cc$/
                || $src =~ /\.C$/
                || $src =~ /\.c$/) {
                $string .= " \\\n  $src";
            }
            $vpath{File::Basename::dirname ($src)} = '1';
        }
        $string .= "\n";
        $string .= "\n";
        $string .= 'VPATH=' . join(':', sort keys %vpath) . "\n";
        $string .= "\n";
        $string .= "TEMPLATE_FILES =";

        foreach my $src (sort keys %{$data->{PROJECTS}->{$project}->{SOURCES}}) {
            my $type = $data->{PROJECTS}->{$project}->{SOURCES}->{$src}->{TYPE};

            if (defined $type && $type eq 'template') {
                $string .= " \\\n  $src";
            }
        }
        $string .= "\n";

        $string .= "HEADERS =";

        foreach my $src (sort keys %{$data->{PROJECTS}->{$project}->{SOURCES}}) {
            if ($src =~ /.h$/ || $src =~ /.i$/ || $src =~ /.inl$/) {
                $string .= " \\\n  $src";
            }
        }
        $string .= "\n";
        $string .= "\n";

        my $has_idls = 0;

        foreach my $file (keys %{$data->{PROJECTS}->{$project}->{SOURCES}}) {
            my $type = $data->{PROJECTS}->{$project}->{SOURCES}->{$file}->{TYPE};
            if (defined $type && ($type eq 'idl' || $type eq 'clientidl')) {
                $has_idls = 1;
            }
        }

        if ($has_idls) {
            $string .= "IDL_FILES=";

            foreach my $file (sort keys %{$data->{PROJECTS}->{$project}->{SOURCES}}) {
                my $type = $data->{PROJECTS}->{$project}->{SOURCES}->{$file}->{TYPE};
                if (defined $type && ($type eq 'idl' || $type eq 'clientidl')) {
                    my $base = $file;
                    $base =~ s/\.idl$//;
                    $string .= "\\\n  $base";
                }
            }
            $string .= "\n";

            $string .= "$SRC_MACRO+=";
            foreach my $file (sort keys %{$data->{PROJECTS}->{$project}->{SOURCES}}) {
                my $type = $data->{PROJECTS}->{$project}->{SOURCES}->{$file}->{TYPE};
                if (defined $type && ($type eq 'idl' || $type eq 'clientidl')) {
                    my $idl = $file;
                    my $base = $idl;
                    $base =~ s/\.idl$//;

                    $string .= "\\\n  $base\$(IDL_CLIENT_SRC_EXT)";

                    if ($type ne 'clientidl') {
                        $string .= "\\\n  $base\$(IDL_SERVER_SRC_EXT)";
                    }
                }
            }
            $string .= "\n";

            $string .= "HEADERS+=";
            foreach my $file (sort keys %{$data->{PROJECTS}->{$project}->{SOURCES}}) {
                my $type = $data->{PROJECTS}->{$project}->{SOURCES}->{$file}->{TYPE};
                if (defined $type && ($type eq 'idl' || $type eq 'clientidl')) {
                    my $idl = $file;

                    my $base = $idl;
                    $base =~ s/\.idl$//;

                    $string .= "\\\n  $base\$(IDL_CLIENT_HDR_EXT)";
                    $string .= "\\\n  $base\$(IDL_CLIENT_INL_EXT)";

                    if ($type ne 'clientidl') {
                        $string .= "\\\n  $base\$(IDL_SERVER_HDR_EXT)";
                        $string .= "\\\n  $base\$(IDL_SERVER_INL_EXT)";
                        $string .= "\\\n  $base\$(IDL_SERVER_THDR_EXT)";
                        $string .= "\\\n  $base\$(IDL_SERVER_TINL_EXT)";
                    }
                }
            }
            $string .= "\n";

            $string .= "TEMPLATE_FILES+=";
            foreach my $file (sort keys %{$data->{PROJECTS}->{$project}->{SOURCES}}) {
                my $type = $data->{PROJECTS}->{$project}->{SOURCES}->{$file}->{TYPE};
                if (defined $type && ($type eq 'idl' || $type eq 'clientidl')) {
                    if ($type ne 'clientidl') {
                        my $base = $file;
                        $base =~ s/\.idl$//;

                        $string .= "\\\n  $base\$(IDL_SERVER_TSRC_EXT)";
                    }
                }
            }
            $string .= "\n";

            my @opts = ();
            foreach my $file (sort keys %{$data->{PROJECTS}->{$project}->{SOURCES}}) {
                my $type = $data->{PROJECTS}->{$project}->{SOURCES}->{$file}->{TYPE};
                if (defined $type && ($type eq 'idl' || $type eq 'clientidl')) {
                    push @opts,
                    $data->{PROJECTS}->{$project}->{SOURCES}->{$file}->{OPTS};
                }
            }
            my @unique_opts = sort @opts;
            $string .= "TAO_IDLFLAGS+=";
            my $previous_opt = '';
            foreach my $o (@unique_opts) {
              if ($o ne $previous_opt) {
                $string .= "\\\n  $o";
                $previous_opt = $o;
              }
            }
            $string .= "\n";

        }
        $string .= "\n";
        $string .= "include \$(ACE_ROOT)/samwise/makeinclude/$GNU_INCLUDE\n";
        $string .= "\n";

        if ($has_idls) {
            my $idl_deps = "";
            my $realclean_cmds = "";
            foreach my $file (sort keys %{$data->{PROJECTS}->{$project}->{SOURCES}}) {
                my $type = $data->{PROJECTS}->{$project}->{SOURCES}->{$file}->{TYPE};
                if (defined $type && ($type eq 'idl' || $type eq 'clientidl')) {
                    my $base = $file;
                    $base =~ s/\.idl$//;

                    $realclean_cmds .= "\t\-\$(RM) \$(foreach ext, \$(IDL_EXT), $base\$(ext))\n";
                    $string .= "\n";
                    $string .= ".PRECIOUS: \$(foreach ext, \$(IDL_EXT), $base\$(ext))\n";
                    $string .= "\n";

                    $idl_deps .= " $base\$(IDL_CLIENT_HDR_EXT)";
                }
            }
            $string .= "realclean:\n";
            $string .= $realclean_cmds;
            $string .= "\n";

            foreach my $src (sort keys %{$data->{PROJECTS}->{$project}->{SOURCES}}) {
                my $type = $data->{PROJECTS}->{$project}->{SOURCES}->{$src}->{TYPE};

                if ((!defined $type || $type ne 'template') && $src =~ /.cpp$/) {
                    my $base = $src;
                    $base =~ s/\.cpp$//;
                    $base = File::Basename::basename ($base);

                    $string .= ".shobj/$base.o .obj/$base.o ";
                    $string .= ".shobj/$base.so .obj/$base.so:";
                    $string .= $idl_deps . "\n";
                }
            }
            $string .= "\n";
        }

        print "Creating Project: $file_name\n";

        my $file_handle = new FileHandle ($file_name, "w");

        print $file_handle $string;
    }
}

###############################################################################
# Internal Methods

1;
