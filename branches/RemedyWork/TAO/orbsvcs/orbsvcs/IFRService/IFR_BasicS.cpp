// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
// and
//       Institute for Software Integrated Systems
//       Vanderbilt University
//       Nashville, TN
//       USA
//       http://www.isis.vanderbilt.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html


// TAO_IDL - Generated from
// be\be_codegen.cpp:603

#ifndef _TAO_IDL____ORBSVCS_ORBSVCS_IFRSERVICE_IFR_BASICS_CPP_
#define _TAO_IDL____ORBSVCS_ORBSVCS_IFRSERVICE_IFR_BASICS_CPP_


#include "IFR_BasicS.h"
#include "tao/PortableServer/Operation_Table_Perfect_Hash.h"
#include "tao/PortableServer/Upcall_Command.h"
#include "tao/PortableServer/Upcall_Wrapper.h"
#include "tao/TAO_Server_Request.h"
#include "tao/ORB_Core.h"
#include "tao/Profile.h"
#include "tao/Stub.h"
#include "tao/IFR_Client_Adapter.h"
#include "tao/Object_T.h"
#include "tao/AnyTypeCode/TypeCode.h"
#include "tao/AnyTypeCode/DynamicC.h"
#include "tao/CDR.h"
#include "tao/operation_details.h"
#include "tao/PortableInterceptor.h"
#include "tao/PortableServer/Basic_SArguments.h"
#include "tao/PortableServer/Object_SArgument_T.h"
#include "tao/PortableServer/Special_Basic_SArguments.h"
#include "tao/PortableServer/UB_String_SArguments.h"
#include "tao/PortableServer/Var_Size_SArgument_T.h"
#include "tao/PortableServer/Any_SArg_Traits.h"
#include "tao/PortableServer/TypeCode_SArg_Traits.h"
#include "tao/PortableServer/Object_SArg_Traits.h"
#include "tao/PortableServer/get_arg.h"
#include "tao/Special_Basic_Arguments.h"
#include "tao/UB_String_Arguments.h"
#include "tao/Basic_Arguments.h"
#include "tao/Object_Argument_T.h"
#include "tao/Special_Basic_Arguments.h"
#include "tao/UB_String_Arguments.h"
#include "tao/Var_Size_Argument_T.h"
#include "tao/AnyTypeCode/Any_Arg_Traits.h"
#include "ace/Dynamic_Service.h"
#include "ace/Malloc_Allocator.h"

#if !defined (__ACE_INLINE__)
#include "IFR_BasicS.inl"
#endif /* !defined INLINE */

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be\be_visitor_arg_traits.cpp:72


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Arg traits specializations.
namespace TAO
{

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:817

#if !defined (_CORBA_DEFINITIONKIND__SARG_TRAITS_)
#define _CORBA_DEFINITIONKIND__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::DefinitionKind>
    : public
        Basic_SArg_Traits_T<
            CORBA::DefinitionKind,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_CONTAINED__SARG_TRAITS_)
#define _CORBA_CONTAINED__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::Contained>
    : public
        Object_SArg_Traits_T<
            CORBA::Contained_ptr,
            CORBA::Contained_var,
            CORBA::Contained_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_REPOSITORY__SARG_TRAITS_)
#define _CORBA_REPOSITORY__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::Repository>
    : public
        Object_SArg_Traits_T<
            CORBA::Repository_ptr,
            CORBA::Repository_var,
            CORBA::Repository_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_CONTAINER__SARG_TRAITS_)
#define _CORBA_CONTAINER__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::Container>
    : public
        Object_SArg_Traits_T<
            CORBA::Container_ptr,
            CORBA::Container_var,
            CORBA::Container_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_IDLTYPE__SARG_TRAITS_)
#define _CORBA_IDLTYPE__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::IDLType>
    : public
        Object_SArg_Traits_T<
            CORBA::IDLType_ptr,
            CORBA::IDLType_var,
            CORBA::IDLType_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_INTERFACEDEFSEQ__SARG_TRAITS_)
#define _CORBA_INTERFACEDEFSEQ__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::InterfaceDefSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::InterfaceDefSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_STRUCTMEMBERSEQ__SARG_TRAITS_)
#define _CORBA_STRUCTMEMBERSEQ__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::StructMemberSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::StructMemberSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_EXCDESCRIPTIONSEQ__SARG_TRAITS_)
#define _CORBA_EXCDESCRIPTIONSEQ__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::ExcDescriptionSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::ExcDescriptionSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_UNIONMEMBERSEQ__SARG_TRAITS_)
#define _CORBA_UNIONMEMBERSEQ__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::UnionMemberSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::UnionMemberSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_ENUMMEMBERSEQ__SARG_TRAITS_)
#define _CORBA_ENUMMEMBERSEQ__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::EnumMemberSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::EnumMemberSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_PRIMITIVEDEF__SARG_TRAITS_)
#define _CORBA_PRIMITIVEDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::PrimitiveDef>
    : public
        Object_SArg_Traits_T<
            CORBA::PrimitiveDef_ptr,
            CORBA::PrimitiveDef_var,
            CORBA::PrimitiveDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_STRINGDEF__SARG_TRAITS_)
#define _CORBA_STRINGDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::StringDef>
    : public
        Object_SArg_Traits_T<
            CORBA::StringDef_ptr,
            CORBA::StringDef_var,
            CORBA::StringDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_SEQUENCEDEF__SARG_TRAITS_)
#define _CORBA_SEQUENCEDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::SequenceDef>
    : public
        Object_SArg_Traits_T<
            CORBA::SequenceDef_ptr,
            CORBA::SequenceDef_var,
            CORBA::SequenceDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_ARRAYDEF__SARG_TRAITS_)
#define _CORBA_ARRAYDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::ArrayDef>
    : public
        Object_SArg_Traits_T<
            CORBA::ArrayDef_ptr,
            CORBA::ArrayDef_var,
            CORBA::ArrayDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_WSTRINGDEF__SARG_TRAITS_)
#define _CORBA_WSTRINGDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::WstringDef>
    : public
        Object_SArg_Traits_T<
            CORBA::WstringDef_ptr,
            CORBA::WstringDef_var,
            CORBA::WstringDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_FIXEDDEF__SARG_TRAITS_)
#define _CORBA_FIXEDDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::FixedDef>
    : public
        Object_SArg_Traits_T<
            CORBA::FixedDef_ptr,
            CORBA::FixedDef_var,
            CORBA::FixedDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:817

#if !defined (_CORBA_PRIMITIVEKIND__SARG_TRAITS_)
#define _CORBA_PRIMITIVEKIND__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::PrimitiveKind>
    : public
        Basic_SArg_Traits_T<
            CORBA::PrimitiveKind,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_EXCEPTIONDEFSEQ__SARG_TRAITS_)
#define _CORBA_EXCEPTIONDEFSEQ__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::ExceptionDefSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::ExceptionDefSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:817

#if !defined (_CORBA_ATTRIBUTEMODE__SARG_TRAITS_)
#define _CORBA_ATTRIBUTEMODE__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::AttributeMode>
    : public
        Basic_SArg_Traits_T<
            CORBA::AttributeMode,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_ATTRIBUTEDEF__SARG_TRAITS_)
#define _CORBA_ATTRIBUTEDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::AttributeDef>
    : public
        Object_SArg_Traits_T<
            CORBA::AttributeDef_ptr,
            CORBA::AttributeDef_var,
            CORBA::AttributeDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:859

#if !defined (_CORBA_EXTATTRIBUTEDESCRIPTION__SARG_TRAITS_)
#define _CORBA_EXTATTRIBUTEDESCRIPTION__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::ExtAttributeDescription>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::ExtAttributeDescription,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_EXTATTRIBUTEDEF__SARG_TRAITS_)
#define _CORBA_EXTATTRIBUTEDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::ExtAttributeDef>
    : public
        Object_SArg_Traits_T<
            CORBA::ExtAttributeDef_ptr,
            CORBA::ExtAttributeDef_var,
            CORBA::ExtAttributeDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:817

#if !defined (_CORBA_OPERATIONMODE__SARG_TRAITS_)
#define _CORBA_OPERATIONMODE__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::OperationMode>
    : public
        Basic_SArg_Traits_T<
            CORBA::OperationMode,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_PARDESCRIPTIONSEQ__SARG_TRAITS_)
#define _CORBA_PARDESCRIPTIONSEQ__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::ParDescriptionSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::ParDescriptionSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_CONTEXTIDSEQ__SARG_TRAITS_)
#define _CORBA_CONTEXTIDSEQ__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::ContextIdSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::ContextIdSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_OPERATIONDEF__SARG_TRAITS_)
#define _CORBA_OPERATIONDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::OperationDef>
    : public
        Object_SArg_Traits_T<
            CORBA::OperationDef_ptr,
            CORBA::OperationDef_var,
            CORBA::OperationDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:859

#if !defined (_CORBA_INTERFACEDEF_FULLINTERFACEDESCRIPTION__SARG_TRAITS_)
#define _CORBA_INTERFACEDEF_FULLINTERFACEDESCRIPTION__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::InterfaceDef::FullInterfaceDescription>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::InterfaceDef::FullInterfaceDescription,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:859

#if !defined (_CORBA_INTERFACEATTREXTENSION_EXTFULLINTERFACEDESCRIPTION__SARG_TRAITS_)
#define _CORBA_INTERFACEATTREXTENSION_EXTFULLINTERFACEDESCRIPTION__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be\be_visitor_arg_traits.cpp:72


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Arg traits specializations.
namespace TAO
{

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:817

#if !defined (_CORBA_DEFINITIONKIND__ARG_TRAITS_)
#define _CORBA_DEFINITIONKIND__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::DefinitionKind>
    : public
        Basic_Arg_Traits_T<
            CORBA::DefinitionKind,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_CONTAINED__ARG_TRAITS_)
#define _CORBA_CONTAINED__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::Contained>
    : public
        Object_Arg_Traits_T<
            CORBA::Contained_ptr,
            CORBA::Contained_var,
            CORBA::Contained_out,
            TAO::Objref_Traits<CORBA::Contained>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_REPOSITORY__ARG_TRAITS_)
#define _CORBA_REPOSITORY__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::Repository>
    : public
        Object_Arg_Traits_T<
            CORBA::Repository_ptr,
            CORBA::Repository_var,
            CORBA::Repository_out,
            TAO::Objref_Traits<CORBA::Repository>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_CONTAINER__ARG_TRAITS_)
#define _CORBA_CONTAINER__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::Container>
    : public
        Object_Arg_Traits_T<
            CORBA::Container_ptr,
            CORBA::Container_var,
            CORBA::Container_out,
            TAO::Objref_Traits<CORBA::Container>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_IDLTYPE__ARG_TRAITS_)
#define _CORBA_IDLTYPE__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::IDLType>
    : public
        Object_Arg_Traits_T<
            CORBA::IDLType_ptr,
            CORBA::IDLType_var,
            CORBA::IDLType_out,
            TAO::Objref_Traits<CORBA::IDLType>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_INTERFACEDEFSEQ__ARG_TRAITS_)
#define _CORBA_INTERFACEDEFSEQ__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::InterfaceDefSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::InterfaceDefSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_STRUCTMEMBERSEQ__ARG_TRAITS_)
#define _CORBA_STRUCTMEMBERSEQ__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::StructMemberSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::StructMemberSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_EXCDESCRIPTIONSEQ__ARG_TRAITS_)
#define _CORBA_EXCDESCRIPTIONSEQ__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::ExcDescriptionSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::ExcDescriptionSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_UNIONMEMBERSEQ__ARG_TRAITS_)
#define _CORBA_UNIONMEMBERSEQ__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::UnionMemberSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::UnionMemberSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_ENUMMEMBERSEQ__ARG_TRAITS_)
#define _CORBA_ENUMMEMBERSEQ__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::EnumMemberSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::EnumMemberSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_PRIMITIVEDEF__ARG_TRAITS_)
#define _CORBA_PRIMITIVEDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::PrimitiveDef>
    : public
        Object_Arg_Traits_T<
            CORBA::PrimitiveDef_ptr,
            CORBA::PrimitiveDef_var,
            CORBA::PrimitiveDef_out,
            TAO::Objref_Traits<CORBA::PrimitiveDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_STRINGDEF__ARG_TRAITS_)
#define _CORBA_STRINGDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::StringDef>
    : public
        Object_Arg_Traits_T<
            CORBA::StringDef_ptr,
            CORBA::StringDef_var,
            CORBA::StringDef_out,
            TAO::Objref_Traits<CORBA::StringDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_SEQUENCEDEF__ARG_TRAITS_)
#define _CORBA_SEQUENCEDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::SequenceDef>
    : public
        Object_Arg_Traits_T<
            CORBA::SequenceDef_ptr,
            CORBA::SequenceDef_var,
            CORBA::SequenceDef_out,
            TAO::Objref_Traits<CORBA::SequenceDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_ARRAYDEF__ARG_TRAITS_)
#define _CORBA_ARRAYDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::ArrayDef>
    : public
        Object_Arg_Traits_T<
            CORBA::ArrayDef_ptr,
            CORBA::ArrayDef_var,
            CORBA::ArrayDef_out,
            TAO::Objref_Traits<CORBA::ArrayDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_WSTRINGDEF__ARG_TRAITS_)
#define _CORBA_WSTRINGDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::WstringDef>
    : public
        Object_Arg_Traits_T<
            CORBA::WstringDef_ptr,
            CORBA::WstringDef_var,
            CORBA::WstringDef_out,
            TAO::Objref_Traits<CORBA::WstringDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_FIXEDDEF__ARG_TRAITS_)
#define _CORBA_FIXEDDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::FixedDef>
    : public
        Object_Arg_Traits_T<
            CORBA::FixedDef_ptr,
            CORBA::FixedDef_var,
            CORBA::FixedDef_out,
            TAO::Objref_Traits<CORBA::FixedDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:817

#if !defined (_CORBA_PRIMITIVEKIND__ARG_TRAITS_)
#define _CORBA_PRIMITIVEKIND__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::PrimitiveKind>
    : public
        Basic_Arg_Traits_T<
            CORBA::PrimitiveKind,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_EXCEPTIONDEFSEQ__ARG_TRAITS_)
#define _CORBA_EXCEPTIONDEFSEQ__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::ExceptionDefSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::ExceptionDefSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:817

#if !defined (_CORBA_ATTRIBUTEMODE__ARG_TRAITS_)
#define _CORBA_ATTRIBUTEMODE__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::AttributeMode>
    : public
        Basic_Arg_Traits_T<
            CORBA::AttributeMode,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_ATTRIBUTEDEF__ARG_TRAITS_)
#define _CORBA_ATTRIBUTEDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::AttributeDef>
    : public
        Object_Arg_Traits_T<
            CORBA::AttributeDef_ptr,
            CORBA::AttributeDef_var,
            CORBA::AttributeDef_out,
            TAO::Objref_Traits<CORBA::AttributeDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:859

#if !defined (_CORBA_EXTATTRIBUTEDESCRIPTION__ARG_TRAITS_)
#define _CORBA_EXTATTRIBUTEDESCRIPTION__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::ExtAttributeDescription>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::ExtAttributeDescription,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_EXTATTRIBUTEDEF__ARG_TRAITS_)
#define _CORBA_EXTATTRIBUTEDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::ExtAttributeDef>
    : public
        Object_Arg_Traits_T<
            CORBA::ExtAttributeDef_ptr,
            CORBA::ExtAttributeDef_var,
            CORBA::ExtAttributeDef_out,
            TAO::Objref_Traits<CORBA::ExtAttributeDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:817

#if !defined (_CORBA_OPERATIONMODE__ARG_TRAITS_)
#define _CORBA_OPERATIONMODE__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::OperationMode>
    : public
        Basic_Arg_Traits_T<
            CORBA::OperationMode,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_PARDESCRIPTIONSEQ__ARG_TRAITS_)
#define _CORBA_PARDESCRIPTIONSEQ__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::ParDescriptionSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::ParDescriptionSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_CONTEXTIDSEQ__ARG_TRAITS_)
#define _CORBA_CONTEXTIDSEQ__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::ContextIdSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::ContextIdSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_OPERATIONDEF__ARG_TRAITS_)
#define _CORBA_OPERATIONDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::OperationDef>
    : public
        Object_Arg_Traits_T<
            CORBA::OperationDef_ptr,
            CORBA::OperationDef_var,
            CORBA::OperationDef_out,
            TAO::Objref_Traits<CORBA::OperationDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:859

#if !defined (_CORBA_INTERFACEDEF_FULLINTERFACEDESCRIPTION__ARG_TRAITS_)
#define _CORBA_INTERFACEDEF_FULLINTERFACEDESCRIPTION__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::InterfaceDef::FullInterfaceDescription>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::InterfaceDef::FullInterfaceDescription,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:859

#if !defined (_CORBA_INTERFACEATTREXTENSION_EXTFULLINTERFACEDESCRIPTION__ARG_TRAITS_)
#define _CORBA_INTERFACEATTREXTENSION_EXTFULLINTERFACEDESCRIPTION__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_Repository_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_Repository_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_Repository_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 27,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 25,
     58,  0,  4, 10, 58, 20, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58,  8, 25, 15,
     58,  0, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 30,  0, 58, 58, 58, 25,  0, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58,
#else
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 27, 58, 25, 58,  0,
      4, 10, 58, 20, 58, 58, 58, 58,  8, 25,
     15, 58,  0, 58, 58, 30,  0, 58, 58, 58,
     25,  0, 58, 58, 58, 58, 58, 58,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_Repository_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 33,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 25,
      MIN_HASH_VALUE = 11,
      MAX_HASH_VALUE = 57,
      HASH_VALUE_RANGE = 47,
      DUPLICATES = 3,
      WORDLIST_SIZE = 44
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"",0,0},{"",0,0},
      {"destroy", &POA_CORBA::Repository::destroy_skel, 0},
      {"create_array", &POA_CORBA::Repository::create_array_skel, 0},
      {"create_struct", &POA_CORBA::Repository::create_struct_skel, 0},
      {"lookup", &POA_CORBA::Repository::lookup_skel, 0},
      {"create_constant", &POA_CORBA::Repository::create_constant_skel, 0},
      {"create_fixed", &POA_CORBA::Repository::create_fixed_skel, 0},
      {"lookup_id", &POA_CORBA::Repository::lookup_id_skel, 0},
      {"create_value", &POA_CORBA::Repository::create_value_skel, 0},
      {"create_module", &POA_CORBA::Repository::create_module_skel, 0},
      {"create_native", &POA_CORBA::Repository::create_native_skel, 0},
      {"create_sequence", &POA_CORBA::Repository::create_sequence_skel, 0},
      {"create_interface", &POA_CORBA::Repository::create_interface_skel, 0},
      {"create_ext_value", &POA_CORBA::Repository::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::Repository::create_union_skel, 0},
      {"lookup_name", &POA_CORBA::Repository::lookup_name_skel, 0},
      {"create_exception", &POA_CORBA::Repository::create_exception_skel, 0},
      {"create_local_interface", &POA_CORBA::Repository::create_local_interface_skel, 0},
      {"create_string", &POA_CORBA::Repository::create_string_skel, 0},
      {"create_wstring", &POA_CORBA::Repository::create_wstring_skel, 0},
      {"create_abstract_interface", &POA_CORBA::Repository::create_abstract_interface_skel, 0},
      {"create_enum", &POA_CORBA::Repository::create_enum_skel, 0},
      {"_component", &POA_CORBA::Repository::_component_skel, 0},
      {"contents", &POA_CORBA::Repository::contents_skel, 0},
      {"_non_existent", &POA_CORBA::Repository::_non_existent_skel, 0},
      {"create_value_box", &POA_CORBA::Repository::create_value_box_skel, 0},
      {"create_alias", &POA_CORBA::Repository::create_alias_skel, 0},
      {"get_primitive", &POA_CORBA::Repository::get_primitive_skel, 0},
      {"_get_def_kind", &POA_CORBA::Repository::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::Repository::_repository_id_skel, 0},
      {"_interface", &POA_CORBA::Repository::_interface_skel, 0},
      {"describe_contents", &POA_CORBA::Repository::describe_contents_skel, 0},
      {"get_canonical_typecode", &POA_CORBA::Repository::get_canonical_typecode_skel, 0},
      {"_is_a", &POA_CORBA::Repository::_is_a_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  11,  12,  13,
       14,  15,  16, -19,  -2, -22,  -2,  17,  18, -63,  -1,  21, -64,  24,
       -1,  25,  -1,  26,  27,  28,  29,  30,  31,  32,  33,  -1,  34,  35,
       36,  37,  38,  39,  -1,  40,  -1,  -1,  -1,  41,  42,  -1,  -1,  -1,
       -1,  43,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_Repository_Perfect_Hash_OpTable tao_CORBA_Repository_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA__TAO_Repository_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA__TAO_Repository_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_Repository_Proxy_Broker_Factory_function_pointer =
    CORBA__TAO_Repository_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA__TAO_Repository_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_Repository_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA__TAO_Repository_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::Repository::Repository (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_Repository_optable;
}

POA_CORBA::Repository::Repository (const Repository& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Container (rhs)
{
}

POA_CORBA::Repository::~Repository (void)
{
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class lookup_id_Repository
    : public TAO::Upcall_Command
  {
  public:
    inline lookup_id_Repository (
      POA_CORBA::Repository * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Contained>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Contained> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::RepositoryId> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_->lookup_id (
          arg_1);
    }

  private:
    POA_CORBA::Repository * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Repository::lookup_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Contained>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_val _tao_search_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_search_id
    };

  static size_t const nargs = 2;

  POA_CORBA::Repository * const impl =
    static_cast<POA_CORBA::Repository *> (servant);

  lookup_id_Repository command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class get_canonical_typecode_Repository
    : public TAO::Upcall_Command
  {
  public:
    inline get_canonical_typecode_Repository (
      POA_CORBA::Repository * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::TypeCode>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::TypeCode> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::TypeCode>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::TypeCode> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_->get_canonical_typecode (
          arg_1);
    }

  private:
    POA_CORBA::Repository * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Repository::get_canonical_typecode_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::TypeCode>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::TypeCode>::in_arg_val _tao_tc;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_tc
    };

  static size_t const nargs = 2;

  POA_CORBA::Repository * const impl =
    static_cast<POA_CORBA::Repository *> (servant);

  get_canonical_typecode_Repository command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class get_primitive_Repository
    : public TAO::Upcall_Command
  {
  public:
    inline get_primitive_Repository (
      POA_CORBA::Repository * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::PrimitiveDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::PrimitiveDef> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::PrimitiveKind>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::PrimitiveKind> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_->get_primitive (
          arg_1);
    }

  private:
    POA_CORBA::Repository * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Repository::get_primitive_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::PrimitiveDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::PrimitiveKind>::in_arg_val _tao_kind;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_kind
    };

  static size_t const nargs = 2;

  POA_CORBA::Repository * const impl =
    static_cast<POA_CORBA::Repository *> (servant);

  get_primitive_Repository command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class create_string_Repository
    : public TAO::Upcall_Command
  {
  public:
    inline create_string_Repository (
      POA_CORBA::Repository * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::StringDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::StringDef> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::ULong>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_->create_string (
          arg_1);
    }

  private:
    POA_CORBA::Repository * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Repository::create_string_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::StringDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ULong>::in_arg_val _tao_bound;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_bound
    };

  static size_t const nargs = 2;

  POA_CORBA::Repository * const impl =
    static_cast<POA_CORBA::Repository *> (servant);

  create_string_Repository command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class create_wstring_Repository
    : public TAO::Upcall_Command
  {
  public:
    inline create_wstring_Repository (
      POA_CORBA::Repository * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::WstringDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::WstringDef> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::ULong>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_->create_wstring (
          arg_1);
    }

  private:
    POA_CORBA::Repository * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Repository::create_wstring_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::WstringDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ULong>::in_arg_val _tao_bound;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_bound
    };

  static size_t const nargs = 2;

  POA_CORBA::Repository * const impl =
    static_cast<POA_CORBA::Repository *> (servant);

  create_wstring_Repository command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class create_sequence_Repository
    : public TAO::Upcall_Command
  {
  public:
    inline create_sequence_Repository (
      POA_CORBA::Repository * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::SequenceDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::SequenceDef> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::ULong>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_,
          1);

      TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          2);

      retval =
        this->servant_->create_sequence (
          arg_1
          , arg_2);
    }

  private:
    POA_CORBA::Repository * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Repository::create_sequence_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::SequenceDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ULong>::in_arg_val _tao_bound;
  TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_val _tao_element_type;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_bound,
      &_tao_element_type
    };

  static size_t const nargs = 3;

  POA_CORBA::Repository * const impl =
    static_cast<POA_CORBA::Repository *> (servant);

  create_sequence_Repository command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class create_array_Repository
    : public TAO::Upcall_Command
  {
  public:
    inline create_array_Repository (
      POA_CORBA::Repository * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ArrayDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ArrayDef> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::ULong>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_,
          1);

      TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          2);

      retval =
        this->servant_->create_array (
          arg_1
          , arg_2);
    }

  private:
    POA_CORBA::Repository * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Repository::create_array_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ArrayDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ULong>::in_arg_val _tao_length;
  TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_val _tao_element_type;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_length,
      &_tao_element_type
    };

  static size_t const nargs = 3;

  POA_CORBA::Repository * const impl =
    static_cast<POA_CORBA::Repository *> (servant);

  create_array_Repository command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class create_fixed_Repository
    : public TAO::Upcall_Command
  {
  public:
    inline create_fixed_Repository (
      POA_CORBA::Repository * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::FixedDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::FixedDef> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::UShort>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::UShort> (
          this->operation_details_,
          this->args_,
          1);

      TAO::SArg_Traits< ::CORBA::Short>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Short> (
          this->operation_details_,
          this->args_,
          2);

      retval =
        this->servant_->create_fixed (
          arg_1
          , arg_2);
    }

  private:
    POA_CORBA::Repository * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Repository::create_fixed_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::FixedDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::UShort>::in_arg_val _tao_digits;
  TAO::SArg_Traits< ::CORBA::Short>::in_arg_val _tao_scale;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_digits,
      &_tao_scale
    };

  static size_t const nargs = 3;

  POA_CORBA::Repository * const impl =
    static_cast<POA_CORBA::Repository *> (servant);

  create_fixed_Repository command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _is_a_Repository_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_Repository_Upcall_Command (
      POA_CORBA::Repository * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_-> _is_a (
          arg_1);
    }

  private:
    POA_CORBA::Repository * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::Repository::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::Repository * const impl =
    static_cast<POA_CORBA::Repository *> (servant);

  _is_a_Repository_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _non_existent_Repository_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_Repository_Upcall_Command (
      POA_CORBA::Repository * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _non_existent ();
    }

  private:
    POA_CORBA::Repository * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::Repository::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::Repository * const impl =
    static_cast<POA_CORBA::Repository *> (servant);

  _non_existent_Repository_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _repository_id_Repository_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_Repository_Upcall_Command (
      POA_CORBA::Repository * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _repository_id ();
    }

  private:
    POA_CORBA::Repository * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::Repository::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::Repository * const impl =
    static_cast<POA_CORBA::Repository *> (servant);

  _repository_id_Repository_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::Repository::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::Repository * const impl =
    static_cast<POA_CORBA::Repository *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_component_Repository_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_Repository_Upcall_Command (
      POA_CORBA::Repository * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _get_component ();
    }

  private:
    POA_CORBA::Repository * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::Repository::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::Repository * const impl =
    static_cast<POA_CORBA::Repository *> (servant);

  _get_component_Repository_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::Repository::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Repository:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::Repository::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/Repository:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::Repository::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::Repository *
POA_CORBA::Repository::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::Repository STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_Repository_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_ModuleDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ModuleDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ModuleDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 20,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 10,
     64,  0, 20,  0, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 20,  0,  5,
     64, 10, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 15, 30, 64, 64, 64, 10,  5, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64,
#else
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 20, 64, 10, 64,  0,
     20,  0, 64, 64, 64, 64, 64, 64, 20,  0,
      5, 64, 10, 64, 64, 15, 30, 64, 64, 64,
     10,  5, 64, 64, 64, 64, 64, 64,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_ModuleDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 36,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 63,
      HASH_VALUE_RANGE = 60,
      DUPLICATES = 6,
      WORDLIST_SIZE = 40
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::ModuleDef::move_skel, 0},
      {"create_enum", &POA_CORBA::ModuleDef::create_enum_skel, 0},
      {"create_value", &POA_CORBA::ModuleDef::create_value_skel, 0},
      {"create_module", &POA_CORBA::ModuleDef::create_module_skel, 0},
      {"create_native", &POA_CORBA::ModuleDef::create_native_skel, 0},
      {"create_interface", &POA_CORBA::ModuleDef::create_interface_skel, 0},
      {"create_ext_value", &POA_CORBA::ModuleDef::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::ModuleDef::create_union_skel, 0},
      {"create_exception", &POA_CORBA::ModuleDef::create_exception_skel, 0},
      {"create_local_interface", &POA_CORBA::ModuleDef::create_local_interface_skel, 0},
      {"contents", &POA_CORBA::ModuleDef::contents_skel, 0},
      {"create_abstract_interface", &POA_CORBA::ModuleDef::create_abstract_interface_skel, 0},
      {"create_value_box", &POA_CORBA::ModuleDef::create_value_box_skel, 0},
      {"create_alias", &POA_CORBA::ModuleDef::create_alias_skel, 0},
      {"describe", &POA_CORBA::ModuleDef::describe_skel, 0},
      {"_get_name", &POA_CORBA::ModuleDef::_get_name_skel, 0},
      {"_set_name", &POA_CORBA::ModuleDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::ModuleDef::_interface_skel, 0},
      {"lookup_name", &POA_CORBA::ModuleDef::lookup_name_skel, 0},
      {"destroy", &POA_CORBA::ModuleDef::destroy_skel, 0},
      {"_is_a", &POA_CORBA::ModuleDef::_is_a_skel, 0},
      {"lookup", &POA_CORBA::ModuleDef::lookup_skel, 0},
      {"_get_version", &POA_CORBA::ModuleDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::ModuleDef::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::ModuleDef::_get_absolute_name_skel, 0},
      {"_get_defined_in", &POA_CORBA::ModuleDef::_get_defined_in_skel, 0},
      {"create_struct", &POA_CORBA::ModuleDef::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::ModuleDef::create_constant_skel, 0},
      {"_get_id", &POA_CORBA::ModuleDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::ModuleDef::_set_id_skel, 0},
      {"_get_containing_repository", &POA_CORBA::ModuleDef::_get_containing_repository_skel, 0},
      {"describe_contents", &POA_CORBA::ModuleDef::describe_contents_skel, 0},
      {"_get_def_kind", &POA_CORBA::ModuleDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::ModuleDef::_repository_id_skel, 0},
      {"_component", &POA_CORBA::ModuleDef::_component_skel, 0},
      {"_non_existent", &POA_CORBA::ModuleDef::_non_existent_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,  -1,  -1,  -1,  -1,  -7,  -2,   5,   6, -67,
       -9,  -2, -65,  11,  -1, -19,  -2,  12,  13,  14,  -1,  15,  16,  17,
       18, -73,  21,  22,  23, -26,  -2,  24,  25, -67,  28,  -1,  29, -32,
       -2,  30,  -1,  31,  -1, -69,  -1,  -1,  -1,  34,  35,  36,  37,  -1,
       -1,  -1,  -1,  -1,  38,  -1,  -1,  39,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ModuleDef_Perfect_Hash_OpTable tao_CORBA_ModuleDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA__TAO_ModuleDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA__TAO_ModuleDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_ModuleDef_Proxy_Broker_Factory_function_pointer =
    CORBA__TAO_ModuleDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA__TAO_ModuleDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_ModuleDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA__TAO_ModuleDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::ModuleDef::ModuleDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ModuleDef_optable;
}

POA_CORBA::ModuleDef::ModuleDef (const ModuleDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Container (rhs),
    POA_CORBA::Contained (rhs)
{
}

POA_CORBA::ModuleDef::~ModuleDef (void)
{
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _is_a_ModuleDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_ModuleDef_Upcall_Command (
      POA_CORBA::ModuleDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_-> _is_a (
          arg_1);
    }

  private:
    POA_CORBA::ModuleDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ModuleDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::ModuleDef * const impl =
    static_cast<POA_CORBA::ModuleDef *> (servant);

  _is_a_ModuleDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _non_existent_ModuleDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_ModuleDef_Upcall_Command (
      POA_CORBA::ModuleDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _non_existent ();
    }

  private:
    POA_CORBA::ModuleDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ModuleDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ModuleDef * const impl =
    static_cast<POA_CORBA::ModuleDef *> (servant);

  _non_existent_ModuleDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _repository_id_ModuleDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_ModuleDef_Upcall_Command (
      POA_CORBA::ModuleDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _repository_id ();
    }

  private:
    POA_CORBA::ModuleDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ModuleDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ModuleDef * const impl =
    static_cast<POA_CORBA::ModuleDef *> (servant);

  _repository_id_ModuleDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::ModuleDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::ModuleDef * const impl =
    static_cast<POA_CORBA::ModuleDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_component_ModuleDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_ModuleDef_Upcall_Command (
      POA_CORBA::ModuleDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _get_component ();
    }

  private:
    POA_CORBA::ModuleDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ModuleDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ModuleDef * const impl =
    static_cast<POA_CORBA::ModuleDef *> (servant);

  _get_component_ModuleDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::ModuleDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ModuleDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ModuleDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ModuleDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::ModuleDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::ModuleDef *
POA_CORBA::ModuleDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::ModuleDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_ModuleDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_ConstantDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ConstantDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ConstantDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 15, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 15, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_ConstantDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 23,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 8,
      WORDLIST_SIZE = 27
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::ConstantDef::move_skel, 0},
      {"_is_a", &POA_CORBA::ConstantDef::_is_a_skel, 0},
      {"_get_id", &POA_CORBA::ConstantDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::ConstantDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::ConstantDef::describe_skel, 0},
      {"_get_name", &POA_CORBA::ConstantDef::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::ConstantDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::ConstantDef::_set_name_skel, 0},
      {"_get_value", &POA_CORBA::ConstantDef::_get_value_skel, 0},
      {"_interface", &POA_CORBA::ConstantDef::_interface_skel, 0},
      {"_set_value", &POA_CORBA::ConstantDef::_set_value_skel, 0},
      {"_get_version", &POA_CORBA::ConstantDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::ConstantDef::_set_version_skel, 0},
      {"_get_def_kind", &POA_CORBA::ConstantDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::ConstantDef::_repository_id_skel, 0},
      {"_get_defined_in", &POA_CORBA::ConstantDef::_get_defined_in_skel, 0},
      {"destroy", &POA_CORBA::ConstantDef::destroy_skel, 0},
      {"_get_absolute_name", &POA_CORBA::ConstantDef::_get_absolute_name_skel, 0},
      {"_component", &POA_CORBA::ConstantDef::_component_skel, 0},
      {"_non_existent", &POA_CORBA::ConstantDef::_non_existent_skel, 0},
      {"_get_type_def", &POA_CORBA::ConstantDef::_get_type_def_skel, 0},
      {"_set_type_def", &POA_CORBA::ConstantDef::_set_type_def_skel, 0},
      {"_get_containing_repository", &POA_CORBA::ConstantDef::_get_containing_repository_skel, 0},
    };

  static const signed char lookup[] =
    {
      -12,  -3, -15,  -2,   4,   5,  -1,  53,   8,  48, -46,  -1, -46,  17,
       18,  19,  -1,  20,  21,  -1,  22,  -9,  -3,  23,  -6,  -2, -24,  -2,
      -38,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  26,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ConstantDef_Perfect_Hash_OpTable tao_CORBA_ConstantDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA__TAO_ConstantDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA__TAO_ConstantDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_ConstantDef_Proxy_Broker_Factory_function_pointer =
    CORBA__TAO_ConstantDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA__TAO_ConstantDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_ConstantDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA__TAO_ConstantDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::ConstantDef::ConstantDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ConstantDef_optable;
}

POA_CORBA::ConstantDef::ConstantDef (const ConstantDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Contained (rhs)
{
}

POA_CORBA::ConstantDef::~ConstantDef (void)
{
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_type_ConstantDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_type_ConstantDef (
      POA_CORBA::ConstantDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::TypeCode>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::TypeCode> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->type ();
    }

  private:
    POA_CORBA::ConstantDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ConstantDef::_get_type_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::TypeCode>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ConstantDef * const impl =
    static_cast<POA_CORBA::ConstantDef *> (servant);

  _get_type_ConstantDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_type_def_ConstantDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_type_def_ConstantDef (
      POA_CORBA::ConstantDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::IDLType>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->type_def ();
    }

  private:
    POA_CORBA::ConstantDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ConstantDef::_get_type_def_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::IDLType>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ConstantDef * const impl =
    static_cast<POA_CORBA::ConstantDef *> (servant);

  _get_type_def_ConstantDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _set_type_def_ConstantDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_type_def_ConstantDef (
      POA_CORBA::ConstantDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          1);

      this->servant_->type_def (
        arg_1);
    }

  private:
    POA_CORBA::ConstantDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ConstantDef::_set_type_def_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_val _tao_type_def;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_type_def
    };

  static size_t const nargs = 2;

  POA_CORBA::ConstantDef * const impl =
    static_cast<POA_CORBA::ConstantDef *> (servant);

  _set_type_def_ConstantDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_value_ConstantDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_value_ConstantDef (
      POA_CORBA::ConstantDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Any>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Any> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->value ();
    }

  private:
    POA_CORBA::ConstantDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ConstantDef::_get_value_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Any>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ConstantDef * const impl =
    static_cast<POA_CORBA::ConstantDef *> (servant);

  _get_value_ConstantDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _set_value_ConstantDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_value_ConstantDef (
      POA_CORBA::ConstantDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Any>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Any> (
          this->operation_details_,
          this->args_,
          1);

      this->servant_->value (
        arg_1);
    }

  private:
    POA_CORBA::ConstantDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ConstantDef::_set_value_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Any>::in_arg_val _tao_value;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_value
    };

  static size_t const nargs = 2;

  POA_CORBA::ConstantDef * const impl =
    static_cast<POA_CORBA::ConstantDef *> (servant);

  _set_value_ConstantDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _is_a_ConstantDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_ConstantDef_Upcall_Command (
      POA_CORBA::ConstantDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_-> _is_a (
          arg_1);
    }

  private:
    POA_CORBA::ConstantDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ConstantDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::ConstantDef * const impl =
    static_cast<POA_CORBA::ConstantDef *> (servant);

  _is_a_ConstantDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _non_existent_ConstantDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_ConstantDef_Upcall_Command (
      POA_CORBA::ConstantDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _non_existent ();
    }

  private:
    POA_CORBA::ConstantDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ConstantDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ConstantDef * const impl =
    static_cast<POA_CORBA::ConstantDef *> (servant);

  _non_existent_ConstantDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _repository_id_ConstantDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_ConstantDef_Upcall_Command (
      POA_CORBA::ConstantDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _repository_id ();
    }

  private:
    POA_CORBA::ConstantDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ConstantDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ConstantDef * const impl =
    static_cast<POA_CORBA::ConstantDef *> (servant);

  _repository_id_ConstantDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::ConstantDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::ConstantDef * const impl =
    static_cast<POA_CORBA::ConstantDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_component_ConstantDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_ConstantDef_Upcall_Command (
      POA_CORBA::ConstantDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _get_component ();
    }

  private:
    POA_CORBA::ConstantDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ConstantDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ConstantDef * const impl =
    static_cast<POA_CORBA::ConstantDef *> (servant);

  _get_component_ConstantDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::ConstantDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ConstantDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ConstantDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ConstantDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::ConstantDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::ConstantDef *
POA_CORBA::ConstantDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::ConstantDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_ConstantDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_StructDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_StructDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_StructDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61,  0,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61,  0,
     61, 25,  8,  0, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61,  0, 15,  5,
     61,  0, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 20, 20, 61, 61, 61, 15, 10, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61,
#else
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61,  0, 61,  0, 61, 25,
      8,  0, 61, 61, 61, 61, 61, 61,  0, 15,
      5, 61,  0, 61, 61, 20, 20, 61, 61, 61,
     15, 10, 61, 61, 61, 61, 61, 61,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_StructDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 39,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 60,
      HASH_VALUE_RANGE = 56,
      DUPLICATES = 8,
      WORDLIST_SIZE = 44
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_CORBA::StructDef::_is_a_skel, 0},
      {"lookup", &POA_CORBA::StructDef::lookup_skel, 0},
      {"_get_name", &POA_CORBA::StructDef::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::StructDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::StructDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::StructDef::_interface_skel, 0},
      {"lookup_name", &POA_CORBA::StructDef::lookup_name_skel, 0},
      {"_get_id", &POA_CORBA::StructDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::StructDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::StructDef::describe_skel, 0},
      {"_get_version", &POA_CORBA::StructDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::StructDef::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::StructDef::_get_absolute_name_skel, 0},
      {"move", &POA_CORBA::StructDef::move_skel, 0},
      {"_get_defined_in", &POA_CORBA::StructDef::_get_defined_in_skel, 0},
      {"_get_def_kind", &POA_CORBA::StructDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::StructDef::_repository_id_skel, 0},
      {"destroy", &POA_CORBA::StructDef::destroy_skel, 0},
      {"_component", &POA_CORBA::StructDef::_component_skel, 0},
      {"_get_members", &POA_CORBA::StructDef::_get_members_skel, 0},
      {"_set_members", &POA_CORBA::StructDef::_set_members_skel, 0},
      {"_non_existent", &POA_CORBA::StructDef::_non_existent_skel, 0},
      {"_get_containing_repository", &POA_CORBA::StructDef::_get_containing_repository_skel, 0},
      {"create_value", &POA_CORBA::StructDef::create_value_skel, 0},
      {"create_module", &POA_CORBA::StructDef::create_module_skel, 0},
      {"create_native", &POA_CORBA::StructDef::create_native_skel, 0},
      {"create_interface", &POA_CORBA::StructDef::create_interface_skel, 0},
      {"create_ext_value", &POA_CORBA::StructDef::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::StructDef::create_union_skel, 0},
      {"describe_contents", &POA_CORBA::StructDef::describe_contents_skel, 0},
      {"create_exception", &POA_CORBA::StructDef::create_exception_skel, 0},
      {"create_local_interface", &POA_CORBA::StructDef::create_local_interface_skel, 0},
      {"create_abstract_interface", &POA_CORBA::StructDef::create_abstract_interface_skel, 0},
      {"create_enum", &POA_CORBA::StructDef::create_enum_skel, 0},
      {"contents", &POA_CORBA::StructDef::contents_skel, 0},
      {"create_value_box", &POA_CORBA::StructDef::create_value_box_skel, 0},
      {"create_alias", &POA_CORBA::StructDef::create_alias_skel, 0},
      {"create_struct", &POA_CORBA::StructDef::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::StructDef::create_constant_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -7,  -3,   5,   6, -12,  -2, -66,  10,  11,  -1, -15,
       -2, -68,  14, -64,  17,  18,  19,  20,  21,  -1,  -1,  22,  -1,  -1,
      -24,  -2,  23,  -1, -64,  26, -29,  -2,  27,  28, -64, -31,  -2, -62,
       33,  -1,  -1,  34,  35,  36,  -1,  -1,  37,  38,  -1,  39,  -1,  -1,
       40,  41,  42,  -1,  43,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_StructDef_Perfect_Hash_OpTable tao_CORBA_StructDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA__TAO_StructDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA__TAO_StructDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_StructDef_Proxy_Broker_Factory_function_pointer =
    CORBA__TAO_StructDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA__TAO_StructDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_StructDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA__TAO_StructDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::StructDef::StructDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_StructDef_optable;
}

POA_CORBA::StructDef::StructDef (const StructDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::IDLType (rhs),
    POA_CORBA::TypedefDef (rhs),
    POA_CORBA::Container (rhs)
{
}

POA_CORBA::StructDef::~StructDef (void)
{
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_members_StructDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_members_StructDef (
      POA_CORBA::StructDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::StructMemberSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::StructMemberSeq> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->members ();
    }

  private:
    POA_CORBA::StructDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::StructDef::_get_members_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::StructMemberSeq>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::StructDef * const impl =
    static_cast<POA_CORBA::StructDef *> (servant);

  _get_members_StructDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _set_members_StructDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_members_StructDef (
      POA_CORBA::StructDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::StructMemberSeq>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::StructMemberSeq> (
          this->operation_details_,
          this->args_,
          1);

      this->servant_->members (
        arg_1);
    }

  private:
    POA_CORBA::StructDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::StructDef::_set_members_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::StructMemberSeq>::in_arg_val _tao_members;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_members
    };

  static size_t const nargs = 2;

  POA_CORBA::StructDef * const impl =
    static_cast<POA_CORBA::StructDef *> (servant);

  _set_members_StructDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _is_a_StructDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_StructDef_Upcall_Command (
      POA_CORBA::StructDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_-> _is_a (
          arg_1);
    }

  private:
    POA_CORBA::StructDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::StructDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::StructDef * const impl =
    static_cast<POA_CORBA::StructDef *> (servant);

  _is_a_StructDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _non_existent_StructDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_StructDef_Upcall_Command (
      POA_CORBA::StructDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _non_existent ();
    }

  private:
    POA_CORBA::StructDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::StructDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::StructDef * const impl =
    static_cast<POA_CORBA::StructDef *> (servant);

  _non_existent_StructDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _repository_id_StructDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_StructDef_Upcall_Command (
      POA_CORBA::StructDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _repository_id ();
    }

  private:
    POA_CORBA::StructDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::StructDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::StructDef * const impl =
    static_cast<POA_CORBA::StructDef *> (servant);

  _repository_id_StructDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::StructDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::StructDef * const impl =
    static_cast<POA_CORBA::StructDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_component_StructDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_StructDef_Upcall_Command (
      POA_CORBA::StructDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _get_component ();
    }

  private:
    POA_CORBA::StructDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::StructDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::StructDef * const impl =
    static_cast<POA_CORBA::StructDef *> (servant);

  _get_component_StructDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::StructDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/TypedefDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/StructDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::StructDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/StructDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::StructDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::StructDef *
POA_CORBA::StructDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::StructDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_StructDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_UnionDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_UnionDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_UnionDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86,  0,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86,  0,
     86, 25, 35,  0, 35, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86,  0,  0, 15,
     86,  0, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 20, 45, 86, 86, 86,  5, 25, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86,
#else
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86,  0, 86,  0, 86, 25,
     35,  0, 35, 86, 86, 86, 86, 86,  0,  0,
     15, 86,  0, 86, 86, 20, 45, 86, 86, 86,
      5, 25, 86, 86, 86, 86, 86, 86,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_UnionDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 42,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 27,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 85,
      HASH_VALUE_RANGE = 82,
      DUPLICATES = 9,
      WORDLIST_SIZE = 46
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::UnionDef::move_skel, 0},
      {"_is_a", &POA_CORBA::UnionDef::_is_a_skel, 0},
      {"lookup", &POA_CORBA::UnionDef::lookup_skel, 0},
      {"_get_name", &POA_CORBA::UnionDef::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::UnionDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::UnionDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::UnionDef::_interface_skel, 0},
      {"lookup_name", &POA_CORBA::UnionDef::lookup_name_skel, 0},
      {"_get_absolute_name", &POA_CORBA::UnionDef::_get_absolute_name_skel, 0},
      {"_get_discriminator_type", &POA_CORBA::UnionDef::_get_discriminator_type_skel, 0},
      {"_get_version", &POA_CORBA::UnionDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::UnionDef::_set_version_skel, 0},
      {"_get_defined_in", &POA_CORBA::UnionDef::_get_defined_in_skel, 0},
      {"_get_members", &POA_CORBA::UnionDef::_get_members_skel, 0},
      {"_set_members", &POA_CORBA::UnionDef::_set_members_skel, 0},
      {"create_enum", &POA_CORBA::UnionDef::create_enum_skel, 0},
      {"create_value", &POA_CORBA::UnionDef::create_value_skel, 0},
      {"create_module", &POA_CORBA::UnionDef::create_module_skel, 0},
      {"create_native", &POA_CORBA::UnionDef::create_native_skel, 0},
      {"create_interface", &POA_CORBA::UnionDef::create_interface_skel, 0},
      {"create_ext_value", &POA_CORBA::UnionDef::create_ext_value_skel, 0},
      {"_get_id", &POA_CORBA::UnionDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::UnionDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::UnionDef::describe_skel, 0},
      {"create_value_box", &POA_CORBA::UnionDef::create_value_box_skel, 0},
      {"create_local_interface", &POA_CORBA::UnionDef::create_local_interface_skel, 0},
      {"_get_def_kind", &POA_CORBA::UnionDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::UnionDef::_repository_id_skel, 0},
      {"create_abstract_interface", &POA_CORBA::UnionDef::create_abstract_interface_skel, 0},
      {"_get_containing_repository", &POA_CORBA::UnionDef::_get_containing_repository_skel, 0},
      {"create_union", &POA_CORBA::UnionDef::create_union_skel, 0},
      {"contents", &POA_CORBA::UnionDef::contents_skel, 0},
      {"_component", &POA_CORBA::UnionDef::_component_skel, 0},
      {"create_exception", &POA_CORBA::UnionDef::create_exception_skel, 0},
      {"create_alias", &POA_CORBA::UnionDef::create_alias_skel, 0},
      {"_non_existent", &POA_CORBA::UnionDef::_non_existent_skel, 0},
      {"_get_discriminator_type_def", &POA_CORBA::UnionDef::_get_discriminator_type_def_skel, 0},
      {"_set_discriminator_type_def", &POA_CORBA::UnionDef::_set_discriminator_type_def_skel, 0},
      {"destroy", &POA_CORBA::UnionDef::destroy_skel, 0},
      {"describe_contents", &POA_CORBA::UnionDef::describe_contents_skel, 0},
      {"create_struct", &POA_CORBA::UnionDef::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::UnionDef::create_constant_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,   5,   6,  -7,  -3, -87,  10,  11,  -1,  -1,
       -1,  -1,  -1,  -1,  12,  -1,  -1, -14,  -2,  13,  -1, -17,  -2, -91,
      -21,  -2,  16,  -1, -92,  -1, -23,  -2,  19,  20, -95, -25,  -2, -92,
      -88,  27,  -1,  -1,  28,  29,  30,  31,  32,  33,  34,  35,  -1,  36,
       37,  38,  39,  -1, -40,  -2, -87,  -1,  -1,  -1,  -1,  42,  -1,  -1,
       -1,  -1,  43,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  44,
       -1,  45,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_UnionDef_Perfect_Hash_OpTable tao_CORBA_UnionDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA__TAO_UnionDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA__TAO_UnionDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_UnionDef_Proxy_Broker_Factory_function_pointer =
    CORBA__TAO_UnionDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA__TAO_UnionDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_UnionDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA__TAO_UnionDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::UnionDef::UnionDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_UnionDef_optable;
}

POA_CORBA::UnionDef::UnionDef (const UnionDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::IDLType (rhs),
    POA_CORBA::TypedefDef (rhs),
    POA_CORBA::Container (rhs)
{
}

POA_CORBA::UnionDef::~UnionDef (void)
{
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_discriminator_type_UnionDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_discriminator_type_UnionDef (
      POA_CORBA::UnionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::TypeCode>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::TypeCode> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->discriminator_type ();
    }

  private:
    POA_CORBA::UnionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::UnionDef::_get_discriminator_type_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::TypeCode>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::UnionDef * const impl =
    static_cast<POA_CORBA::UnionDef *> (servant);

  _get_discriminator_type_UnionDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_discriminator_type_def_UnionDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_discriminator_type_def_UnionDef (
      POA_CORBA::UnionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::IDLType>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->discriminator_type_def ();
    }

  private:
    POA_CORBA::UnionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::UnionDef::_get_discriminator_type_def_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::IDLType>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::UnionDef * const impl =
    static_cast<POA_CORBA::UnionDef *> (servant);

  _get_discriminator_type_def_UnionDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _set_discriminator_type_def_UnionDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_discriminator_type_def_UnionDef (
      POA_CORBA::UnionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          1);

      this->servant_->discriminator_type_def (
        arg_1);
    }

  private:
    POA_CORBA::UnionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::UnionDef::_set_discriminator_type_def_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_val _tao_discriminator_type_def;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_discriminator_type_def
    };

  static size_t const nargs = 2;

  POA_CORBA::UnionDef * const impl =
    static_cast<POA_CORBA::UnionDef *> (servant);

  _set_discriminator_type_def_UnionDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_members_UnionDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_members_UnionDef (
      POA_CORBA::UnionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::UnionMemberSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::UnionMemberSeq> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->members ();
    }

  private:
    POA_CORBA::UnionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::UnionDef::_get_members_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::UnionMemberSeq>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::UnionDef * const impl =
    static_cast<POA_CORBA::UnionDef *> (servant);

  _get_members_UnionDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _set_members_UnionDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_members_UnionDef (
      POA_CORBA::UnionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::UnionMemberSeq>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::UnionMemberSeq> (
          this->operation_details_,
          this->args_,
          1);

      this->servant_->members (
        arg_1);
    }

  private:
    POA_CORBA::UnionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::UnionDef::_set_members_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::UnionMemberSeq>::in_arg_val _tao_members;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_members
    };

  static size_t const nargs = 2;

  POA_CORBA::UnionDef * const impl =
    static_cast<POA_CORBA::UnionDef *> (servant);

  _set_members_UnionDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _is_a_UnionDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_UnionDef_Upcall_Command (
      POA_CORBA::UnionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_-> _is_a (
          arg_1);
    }

  private:
    POA_CORBA::UnionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::UnionDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::UnionDef * const impl =
    static_cast<POA_CORBA::UnionDef *> (servant);

  _is_a_UnionDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _non_existent_UnionDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_UnionDef_Upcall_Command (
      POA_CORBA::UnionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _non_existent ();
    }

  private:
    POA_CORBA::UnionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::UnionDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::UnionDef * const impl =
    static_cast<POA_CORBA::UnionDef *> (servant);

  _non_existent_UnionDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _repository_id_UnionDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_UnionDef_Upcall_Command (
      POA_CORBA::UnionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _repository_id ();
    }

  private:
    POA_CORBA::UnionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::UnionDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::UnionDef * const impl =
    static_cast<POA_CORBA::UnionDef *> (servant);

  _repository_id_UnionDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::UnionDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::UnionDef * const impl =
    static_cast<POA_CORBA::UnionDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_component_UnionDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_UnionDef_Upcall_Command (
      POA_CORBA::UnionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _get_component ();
    }

  private:
    POA_CORBA::UnionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::UnionDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::UnionDef * const impl =
    static_cast<POA_CORBA::UnionDef *> (servant);

  _get_component_UnionDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::UnionDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/TypedefDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/UnionDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::UnionDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/UnionDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::UnionDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::UnionDef *
POA_CORBA::UnionDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::UnionDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_UnionDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_EnumDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_EnumDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_EnumDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 10, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 10, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_EnumDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 21,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 6,
      WORDLIST_SIZE = 25
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::EnumDef::move_skel, 0},
      {"_is_a", &POA_CORBA::EnumDef::_is_a_skel, 0},
      {"_get_id", &POA_CORBA::EnumDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::EnumDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::EnumDef::describe_skel, 0},
      {"_get_name", &POA_CORBA::EnumDef::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::EnumDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::EnumDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::EnumDef::_interface_skel, 0},
      {"_get_version", &POA_CORBA::EnumDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::EnumDef::_set_version_skel, 0},
      {"_get_def_kind", &POA_CORBA::EnumDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::EnumDef::_repository_id_skel, 0},
      {"_get_defined_in", &POA_CORBA::EnumDef::_get_defined_in_skel, 0},
      {"destroy", &POA_CORBA::EnumDef::destroy_skel, 0},
      {"_get_absolute_name", &POA_CORBA::EnumDef::_get_absolute_name_skel, 0},
      {"_component", &POA_CORBA::EnumDef::_component_skel, 0},
      {"_get_members", &POA_CORBA::EnumDef::_get_members_skel, 0},
      {"_set_members", &POA_CORBA::EnumDef::_set_members_skel, 0},
      {"_non_existent", &POA_CORBA::EnumDef::_non_existent_skel, 0},
      {"_get_containing_repository", &POA_CORBA::EnumDef::_get_containing_repository_skel, 0},
    };

  static const signed char lookup[] =
    {
      -13,  -2, -21,  -2,   4,   5,  -1,  55,   8,  51,  12,  -1, -48,  15,
       16,  17,  -1,  18,  19,  -1,  20,  -1, -56,  23,  -9,  -3,  -6,  -2,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  24,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_EnumDef_Perfect_Hash_OpTable tao_CORBA_EnumDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA__TAO_EnumDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA__TAO_EnumDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_EnumDef_Proxy_Broker_Factory_function_pointer =
    CORBA__TAO_EnumDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA__TAO_EnumDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_EnumDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA__TAO_EnumDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::EnumDef::EnumDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_EnumDef_optable;
}

POA_CORBA::EnumDef::EnumDef (const EnumDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::IDLType (rhs),
    POA_CORBA::TypedefDef (rhs)
{
}

POA_CORBA::EnumDef::~EnumDef (void)
{
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_members_EnumDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_members_EnumDef (
      POA_CORBA::EnumDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::EnumMemberSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::EnumMemberSeq> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->members ();
    }

  private:
    POA_CORBA::EnumDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::EnumDef::_get_members_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::EnumMemberSeq>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::EnumDef * const impl =
    static_cast<POA_CORBA::EnumDef *> (servant);

  _get_members_EnumDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _set_members_EnumDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_members_EnumDef (
      POA_CORBA::EnumDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::EnumMemberSeq>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::EnumMemberSeq> (
          this->operation_details_,
          this->args_,
          1);

      this->servant_->members (
        arg_1);
    }

  private:
    POA_CORBA::EnumDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::EnumDef::_set_members_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::EnumMemberSeq>::in_arg_val _tao_members;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_members
    };

  static size_t const nargs = 2;

  POA_CORBA::EnumDef * const impl =
    static_cast<POA_CORBA::EnumDef *> (servant);

  _set_members_EnumDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _is_a_EnumDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_EnumDef_Upcall_Command (
      POA_CORBA::EnumDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_-> _is_a (
          arg_1);
    }

  private:
    POA_CORBA::EnumDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::EnumDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::EnumDef * const impl =
    static_cast<POA_CORBA::EnumDef *> (servant);

  _is_a_EnumDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _non_existent_EnumDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_EnumDef_Upcall_Command (
      POA_CORBA::EnumDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _non_existent ();
    }

  private:
    POA_CORBA::EnumDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::EnumDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::EnumDef * const impl =
    static_cast<POA_CORBA::EnumDef *> (servant);

  _non_existent_EnumDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _repository_id_EnumDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_EnumDef_Upcall_Command (
      POA_CORBA::EnumDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _repository_id ();
    }

  private:
    POA_CORBA::EnumDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::EnumDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::EnumDef * const impl =
    static_cast<POA_CORBA::EnumDef *> (servant);

  _repository_id_EnumDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::EnumDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::EnumDef * const impl =
    static_cast<POA_CORBA::EnumDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_component_EnumDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_EnumDef_Upcall_Command (
      POA_CORBA::EnumDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _get_component ();
    }

  private:
    POA_CORBA::EnumDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::EnumDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::EnumDef * const impl =
    static_cast<POA_CORBA::EnumDef *> (servant);

  _get_component_EnumDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::EnumDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/TypedefDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/EnumDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::EnumDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/EnumDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::EnumDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::EnumDef *
POA_CORBA::EnumDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::EnumDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_EnumDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_AliasDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_AliasDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_AliasDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0,  0, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0,  0, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_AliasDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 21,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 6,
      WORDLIST_SIZE = 25
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::AliasDef::move_skel, 0},
      {"_is_a", &POA_CORBA::AliasDef::_is_a_skel, 0},
      {"_get_id", &POA_CORBA::AliasDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::AliasDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::AliasDef::describe_skel, 0},
      {"_get_name", &POA_CORBA::AliasDef::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::AliasDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::AliasDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::AliasDef::_interface_skel, 0},
      {"_get_version", &POA_CORBA::AliasDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::AliasDef::_set_version_skel, 0},
      {"_get_def_kind", &POA_CORBA::AliasDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::AliasDef::_repository_id_skel, 0},
      {"_get_defined_in", &POA_CORBA::AliasDef::_get_defined_in_skel, 0},
      {"destroy", &POA_CORBA::AliasDef::destroy_skel, 0},
      {"_get_absolute_name", &POA_CORBA::AliasDef::_get_absolute_name_skel, 0},
      {"_component", &POA_CORBA::AliasDef::_component_skel, 0},
      {"_get_original_type_def", &POA_CORBA::AliasDef::_get_original_type_def_skel, 0},
      {"_set_original_type_def", &POA_CORBA::AliasDef::_set_original_type_def_skel, 0},
      {"_non_existent", &POA_CORBA::AliasDef::_non_existent_skel, 0},
      {"_get_containing_repository", &POA_CORBA::AliasDef::_get_containing_repository_skel, 0},
    };

  static const signed char lookup[] =
    {
      -13,  -2, -21,  -2,   4,   5,  -1,  55,   8,  51,  12,  -1, -48,  15,
       16,  17,  -1,  18,  19,  -1,  20,  -1, -56,  23,  -9,  -3,  -6,  -2,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  24,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_AliasDef_Perfect_Hash_OpTable tao_CORBA_AliasDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA__TAO_AliasDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA__TAO_AliasDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_AliasDef_Proxy_Broker_Factory_function_pointer =
    CORBA__TAO_AliasDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA__TAO_AliasDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_AliasDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA__TAO_AliasDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::AliasDef::AliasDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_AliasDef_optable;
}

POA_CORBA::AliasDef::AliasDef (const AliasDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::IDLType (rhs),
    POA_CORBA::TypedefDef (rhs)
{
}

POA_CORBA::AliasDef::~AliasDef (void)
{
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_original_type_def_AliasDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_original_type_def_AliasDef (
      POA_CORBA::AliasDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::IDLType>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->original_type_def ();
    }

  private:
    POA_CORBA::AliasDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::AliasDef::_get_original_type_def_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::IDLType>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::AliasDef * const impl =
    static_cast<POA_CORBA::AliasDef *> (servant);

  _get_original_type_def_AliasDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _set_original_type_def_AliasDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_original_type_def_AliasDef (
      POA_CORBA::AliasDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          1);

      this->servant_->original_type_def (
        arg_1);
    }

  private:
    POA_CORBA::AliasDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::AliasDef::_set_original_type_def_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_val _tao_original_type_def;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_original_type_def
    };

  static size_t const nargs = 2;

  POA_CORBA::AliasDef * const impl =
    static_cast<POA_CORBA::AliasDef *> (servant);

  _set_original_type_def_AliasDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _is_a_AliasDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_AliasDef_Upcall_Command (
      POA_CORBA::AliasDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_-> _is_a (
          arg_1);
    }

  private:
    POA_CORBA::AliasDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::AliasDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::AliasDef * const impl =
    static_cast<POA_CORBA::AliasDef *> (servant);

  _is_a_AliasDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _non_existent_AliasDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_AliasDef_Upcall_Command (
      POA_CORBA::AliasDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _non_existent ();
    }

  private:
    POA_CORBA::AliasDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::AliasDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::AliasDef * const impl =
    static_cast<POA_CORBA::AliasDef *> (servant);

  _non_existent_AliasDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _repository_id_AliasDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_AliasDef_Upcall_Command (
      POA_CORBA::AliasDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _repository_id ();
    }

  private:
    POA_CORBA::AliasDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::AliasDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::AliasDef * const impl =
    static_cast<POA_CORBA::AliasDef *> (servant);

  _repository_id_AliasDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::AliasDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::AliasDef * const impl =
    static_cast<POA_CORBA::AliasDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_component_AliasDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_AliasDef_Upcall_Command (
      POA_CORBA::AliasDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _get_component ();
    }

  private:
    POA_CORBA::AliasDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::AliasDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::AliasDef * const impl =
    static_cast<POA_CORBA::AliasDef *> (servant);

  _get_component_AliasDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::AliasDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/TypedefDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/AliasDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::AliasDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/AliasDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::AliasDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::AliasDef *
POA_CORBA::AliasDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::AliasDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_AliasDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_NativeDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_NativeDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_NativeDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_NativeDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 19,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 5,
      WORDLIST_SIZE = 23
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::NativeDef::move_skel, 0},
      {"_is_a", &POA_CORBA::NativeDef::_is_a_skel, 0},
      {"_get_id", &POA_CORBA::NativeDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::NativeDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::NativeDef::describe_skel, 0},
      {"_get_name", &POA_CORBA::NativeDef::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::NativeDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::NativeDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::NativeDef::_interface_skel, 0},
      {"_get_version", &POA_CORBA::NativeDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::NativeDef::_set_version_skel, 0},
      {"_get_def_kind", &POA_CORBA::NativeDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::NativeDef::_repository_id_skel, 0},
      {"_get_defined_in", &POA_CORBA::NativeDef::_get_defined_in_skel, 0},
      {"destroy", &POA_CORBA::NativeDef::destroy_skel, 0},
      {"_get_absolute_name", &POA_CORBA::NativeDef::_get_absolute_name_skel, 0},
      {"_component", &POA_CORBA::NativeDef::_component_skel, 0},
      {"_non_existent", &POA_CORBA::NativeDef::_non_existent_skel, 0},
      {"_get_containing_repository", &POA_CORBA::NativeDef::_get_containing_repository_skel, 0},
    };

  static const signed char lookup[] =
    {
       -9,  -3, -13,  -2,   4,   5,  -1,  50,   8, -45,  12,  -1, -46,  15,
       16,  17,  -1,  18,  19,  -1,  20,  -6,  -2,  21,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  22,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_NativeDef_Perfect_Hash_OpTable tao_CORBA_NativeDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA__TAO_NativeDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA__TAO_NativeDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_NativeDef_Proxy_Broker_Factory_function_pointer =
    CORBA__TAO_NativeDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA__TAO_NativeDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_NativeDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA__TAO_NativeDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::NativeDef::NativeDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_NativeDef_optable;
}

POA_CORBA::NativeDef::NativeDef (const NativeDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::IDLType (rhs),
    POA_CORBA::TypedefDef (rhs)
{
}

POA_CORBA::NativeDef::~NativeDef (void)
{
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _is_a_NativeDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_NativeDef_Upcall_Command (
      POA_CORBA::NativeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_-> _is_a (
          arg_1);
    }

  private:
    POA_CORBA::NativeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::NativeDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::NativeDef * const impl =
    static_cast<POA_CORBA::NativeDef *> (servant);

  _is_a_NativeDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _non_existent_NativeDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_NativeDef_Upcall_Command (
      POA_CORBA::NativeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _non_existent ();
    }

  private:
    POA_CORBA::NativeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::NativeDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::NativeDef * const impl =
    static_cast<POA_CORBA::NativeDef *> (servant);

  _non_existent_NativeDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _repository_id_NativeDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_NativeDef_Upcall_Command (
      POA_CORBA::NativeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _repository_id ();
    }

  private:
    POA_CORBA::NativeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::NativeDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::NativeDef * const impl =
    static_cast<POA_CORBA::NativeDef *> (servant);

  _repository_id_NativeDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::NativeDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::NativeDef * const impl =
    static_cast<POA_CORBA::NativeDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_component_NativeDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_NativeDef_Upcall_Command (
      POA_CORBA::NativeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _get_component ();
    }

  private:
    POA_CORBA::NativeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::NativeDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::NativeDef * const impl =
    static_cast<POA_CORBA::NativeDef *> (servant);

  _get_component_NativeDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::NativeDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/TypedefDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/NativeDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::NativeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/NativeDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::NativeDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::NativeDef *
POA_CORBA::NativeDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::NativeDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_NativeDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_PrimitiveDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_PrimitiveDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_PrimitiveDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21,  0,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21,  0,
     21, 21,  0, 10, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21,  5, 21, 21, 21, 21,  0, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21,
#else
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21,  0, 21,  0, 21, 21,
      0, 10, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21,  5, 21, 21, 21,
     21,  0, 21, 21, 21, 21, 21, 21,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_PrimitiveDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 9,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 14,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 20,
      HASH_VALUE_RANGE = 16,
      DUPLICATES = 0,
      WORDLIST_SIZE = 14
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_CORBA::PrimitiveDef::_is_a_skel, 0},
      {"",0,0},
      {"destroy", &POA_CORBA::PrimitiveDef::destroy_skel, 0},
      {"",0,0},
      {"_get_kind", &POA_CORBA::PrimitiveDef::_get_kind_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"_get_def_kind", &POA_CORBA::PrimitiveDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::PrimitiveDef::_repository_id_skel, 0},
      {"_component", &POA_CORBA::PrimitiveDef::_component_skel, 0},
      {"",0,0},{"",0,0},
      {"_non_existent", &POA_CORBA::PrimitiveDef::_non_existent_skel, 0},
      {"_get_type", &POA_CORBA::PrimitiveDef::_get_type_skel, 0},
      {"_interface", &POA_CORBA::PrimitiveDef::_interface_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_CORBA_PrimitiveDef_Perfect_Hash_OpTable tao_CORBA_PrimitiveDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA__TAO_PrimitiveDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA__TAO_PrimitiveDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_PrimitiveDef_Proxy_Broker_Factory_function_pointer =
    CORBA__TAO_PrimitiveDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA__TAO_PrimitiveDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_PrimitiveDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA__TAO_PrimitiveDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::PrimitiveDef::PrimitiveDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_PrimitiveDef_optable;
}

POA_CORBA::PrimitiveDef::PrimitiveDef (const PrimitiveDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::IDLType (rhs)
{
}

POA_CORBA::PrimitiveDef::~PrimitiveDef (void)
{
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_kind_PrimitiveDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_kind_PrimitiveDef (
      POA_CORBA::PrimitiveDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::PrimitiveKind>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::PrimitiveKind> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->kind ();
    }

  private:
    POA_CORBA::PrimitiveDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::PrimitiveDef::_get_kind_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::PrimitiveKind>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::PrimitiveDef * const impl =
    static_cast<POA_CORBA::PrimitiveDef *> (servant);

  _get_kind_PrimitiveDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _is_a_PrimitiveDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_PrimitiveDef_Upcall_Command (
      POA_CORBA::PrimitiveDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_-> _is_a (
          arg_1);
    }

  private:
    POA_CORBA::PrimitiveDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::PrimitiveDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::PrimitiveDef * const impl =
    static_cast<POA_CORBA::PrimitiveDef *> (servant);

  _is_a_PrimitiveDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _non_existent_PrimitiveDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_PrimitiveDef_Upcall_Command (
      POA_CORBA::PrimitiveDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _non_existent ();
    }

  private:
    POA_CORBA::PrimitiveDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::PrimitiveDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::PrimitiveDef * const impl =
    static_cast<POA_CORBA::PrimitiveDef *> (servant);

  _non_existent_PrimitiveDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _repository_id_PrimitiveDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_PrimitiveDef_Upcall_Command (
      POA_CORBA::PrimitiveDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _repository_id ();
    }

  private:
    POA_CORBA::PrimitiveDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::PrimitiveDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::PrimitiveDef * const impl =
    static_cast<POA_CORBA::PrimitiveDef *> (servant);

  _repository_id_PrimitiveDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::PrimitiveDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::PrimitiveDef * const impl =
    static_cast<POA_CORBA::PrimitiveDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_component_PrimitiveDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_PrimitiveDef_Upcall_Command (
      POA_CORBA::PrimitiveDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _get_component ();
    }

  private:
    POA_CORBA::PrimitiveDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::PrimitiveDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::PrimitiveDef * const impl =
    static_cast<POA_CORBA::PrimitiveDef *> (servant);

  _get_component_PrimitiveDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::PrimitiveDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/PrimitiveDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::PrimitiveDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/PrimitiveDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::PrimitiveDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::PrimitiveDef *
POA_CORBA::PrimitiveDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::PrimitiveDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_PrimitiveDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_StringDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_StringDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_StringDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21,  0,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21,  0,
     21, 21,  0, 10, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21,  5, 21, 21, 21, 21,  0, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21,
#else
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21,  0, 21,  0, 21, 21,
      0, 10, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21,  5, 21, 21, 21,
     21,  0, 21, 21, 21, 21, 21, 21,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_StringDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 10,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 14,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 20,
      HASH_VALUE_RANGE = 16,
      DUPLICATES = 2,
      WORDLIST_SIZE = 15
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_CORBA::StringDef::_is_a_skel, 0},
      {"destroy", &POA_CORBA::StringDef::destroy_skel, 0},
      {"_get_bound", &POA_CORBA::StringDef::_get_bound_skel, 0},
      {"_set_bound", &POA_CORBA::StringDef::_set_bound_skel, 0},
      {"_get_def_kind", &POA_CORBA::StringDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::StringDef::_repository_id_skel, 0},
      {"_component", &POA_CORBA::StringDef::_component_skel, 0},
      {"_non_existent", &POA_CORBA::StringDef::_non_existent_skel, 0},
      {"_get_type", &POA_CORBA::StringDef::_get_type_skel, 0},
      {"_interface", &POA_CORBA::StringDef::_interface_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,   5,  -1,   6,  -7,  -2, -22,  -1,  -1,   9,
       10,  11,  -1,  -1,  12,  13,  14,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_StringDef_Perfect_Hash_OpTable tao_CORBA_StringDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA__TAO_StringDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA__TAO_StringDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_StringDef_Proxy_Broker_Factory_function_pointer =
    CORBA__TAO_StringDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA__TAO_StringDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_StringDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA__TAO_StringDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::StringDef::StringDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_StringDef_optable;
}

POA_CORBA::StringDef::StringDef (const StringDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::IDLType (rhs)
{
}

POA_CORBA::StringDef::~StringDef (void)
{
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_bound_StringDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_bound_StringDef (
      POA_CORBA::StringDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ULong>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->bound ();
    }

  private:
    POA_CORBA::StringDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::StringDef::_get_bound_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ULong>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::StringDef * const impl =
    static_cast<POA_CORBA::StringDef *> (servant);

  _get_bound_StringDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _set_bound_StringDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_bound_StringDef (
      POA_CORBA::StringDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ULong>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_,
          1);

      this->servant_->bound (
        arg_1);
    }

  private:
    POA_CORBA::StringDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::StringDef::_set_bound_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ULong>::in_arg_val _tao_bound;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_bound
    };

  static size_t const nargs = 2;

  POA_CORBA::StringDef * const impl =
    static_cast<POA_CORBA::StringDef *> (servant);

  _set_bound_StringDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _is_a_StringDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_StringDef_Upcall_Command (
      POA_CORBA::StringDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_-> _is_a (
          arg_1);
    }

  private:
    POA_CORBA::StringDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::StringDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::StringDef * const impl =
    static_cast<POA_CORBA::StringDef *> (servant);

  _is_a_StringDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _non_existent_StringDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_StringDef_Upcall_Command (
      POA_CORBA::StringDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _non_existent ();
    }

  private:
    POA_CORBA::StringDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::StringDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::StringDef * const impl =
    static_cast<POA_CORBA::StringDef *> (servant);

  _non_existent_StringDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _repository_id_StringDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_StringDef_Upcall_Command (
      POA_CORBA::StringDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _repository_id ();
    }

  private:
    POA_CORBA::StringDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::StringDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::StringDef * const impl =
    static_cast<POA_CORBA::StringDef *> (servant);

  _repository_id_StringDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::StringDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::StringDef * const impl =
    static_cast<POA_CORBA::StringDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_component_StringDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_StringDef_Upcall_Command (
      POA_CORBA::StringDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _get_component ();
    }

  private:
    POA_CORBA::StringDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::StringDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::StringDef * const impl =
    static_cast<POA_CORBA::StringDef *> (servant);

  _get_component_StringDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::StringDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/StringDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::StringDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/StringDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::StringDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::StringDef *
POA_CORBA::StringDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::StringDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_StringDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_WstringDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_WstringDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_WstringDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21,  0,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21,  0,
     21, 21,  0, 10, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21,  5, 21, 21, 21, 21,  0, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21,
#else
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21,  0, 21,  0, 21, 21,
      0, 10, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21,  5, 21, 21, 21,
     21,  0, 21, 21, 21, 21, 21, 21,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_WstringDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 10,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 14,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 20,
      HASH_VALUE_RANGE = 16,
      DUPLICATES = 2,
      WORDLIST_SIZE = 15
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_CORBA::WstringDef::_is_a_skel, 0},
      {"destroy", &POA_CORBA::WstringDef::destroy_skel, 0},
      {"_get_bound", &POA_CORBA::WstringDef::_get_bound_skel, 0},
      {"_set_bound", &POA_CORBA::WstringDef::_set_bound_skel, 0},
      {"_get_def_kind", &POA_CORBA::WstringDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::WstringDef::_repository_id_skel, 0},
      {"_component", &POA_CORBA::WstringDef::_component_skel, 0},
      {"_non_existent", &POA_CORBA::WstringDef::_non_existent_skel, 0},
      {"_get_type", &POA_CORBA::WstringDef::_get_type_skel, 0},
      {"_interface", &POA_CORBA::WstringDef::_interface_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,   5,  -1,   6,  -7,  -2, -22,  -1,  -1,   9,
       10,  11,  -1,  -1,  12,  13,  14,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_WstringDef_Perfect_Hash_OpTable tao_CORBA_WstringDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA__TAO_WstringDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA__TAO_WstringDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_WstringDef_Proxy_Broker_Factory_function_pointer =
    CORBA__TAO_WstringDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA__TAO_WstringDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_WstringDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA__TAO_WstringDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::WstringDef::WstringDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_WstringDef_optable;
}

POA_CORBA::WstringDef::WstringDef (const WstringDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::IDLType (rhs)
{
}

POA_CORBA::WstringDef::~WstringDef (void)
{
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_bound_WstringDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_bound_WstringDef (
      POA_CORBA::WstringDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ULong>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->bound ();
    }

  private:
    POA_CORBA::WstringDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::WstringDef::_get_bound_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ULong>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::WstringDef * const impl =
    static_cast<POA_CORBA::WstringDef *> (servant);

  _get_bound_WstringDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _set_bound_WstringDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_bound_WstringDef (
      POA_CORBA::WstringDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ULong>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_,
          1);

      this->servant_->bound (
        arg_1);
    }

  private:
    POA_CORBA::WstringDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::WstringDef::_set_bound_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ULong>::in_arg_val _tao_bound;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_bound
    };

  static size_t const nargs = 2;

  POA_CORBA::WstringDef * const impl =
    static_cast<POA_CORBA::WstringDef *> (servant);

  _set_bound_WstringDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _is_a_WstringDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_WstringDef_Upcall_Command (
      POA_CORBA::WstringDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_-> _is_a (
          arg_1);
    }

  private:
    POA_CORBA::WstringDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::WstringDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::WstringDef * const impl =
    static_cast<POA_CORBA::WstringDef *> (servant);

  _is_a_WstringDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _non_existent_WstringDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_WstringDef_Upcall_Command (
      POA_CORBA::WstringDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _non_existent ();
    }

  private:
    POA_CORBA::WstringDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::WstringDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::WstringDef * const impl =
    static_cast<POA_CORBA::WstringDef *> (servant);

  _non_existent_WstringDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _repository_id_WstringDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_WstringDef_Upcall_Command (
      POA_CORBA::WstringDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _repository_id ();
    }

  private:
    POA_CORBA::WstringDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::WstringDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::WstringDef * const impl =
    static_cast<POA_CORBA::WstringDef *> (servant);

  _repository_id_WstringDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::WstringDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::WstringDef * const impl =
    static_cast<POA_CORBA::WstringDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_component_WstringDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_WstringDef_Upcall_Command (
      POA_CORBA::WstringDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _get_component ();
    }

  private:
    POA_CORBA::WstringDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::WstringDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::WstringDef * const impl =
    static_cast<POA_CORBA::WstringDef *> (servant);

  _get_component_WstringDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::WstringDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/WstringDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::WstringDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/WstringDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::WstringDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::WstringDef *
POA_CORBA::WstringDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::WstringDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_WstringDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_SequenceDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_SequenceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_SequenceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28,  0,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28,  0,
     28, 28,  0, 10,  0, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28,  5, 28, 28, 28, 28,  0, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28,
#else
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28,  0, 28,  0, 28, 28,
      0, 10,  0, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28,  5, 28, 28, 28,
     28,  0, 28, 28, 28, 28, 28, 28,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_SequenceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 13,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 21,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 27,
      HASH_VALUE_RANGE = 23,
      DUPLICATES = 3,
      WORDLIST_SIZE = 18
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_CORBA::SequenceDef::_is_a_skel, 0},
      {"destroy", &POA_CORBA::SequenceDef::destroy_skel, 0},
      {"_get_bound", &POA_CORBA::SequenceDef::_get_bound_skel, 0},
      {"_set_bound", &POA_CORBA::SequenceDef::_set_bound_skel, 0},
      {"_get_def_kind", &POA_CORBA::SequenceDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::SequenceDef::_repository_id_skel, 0},
      {"_component", &POA_CORBA::SequenceDef::_component_skel, 0},
      {"_non_existent", &POA_CORBA::SequenceDef::_non_existent_skel, 0},
      {"_get_type", &POA_CORBA::SequenceDef::_get_type_skel, 0},
      {"_interface", &POA_CORBA::SequenceDef::_interface_skel, 0},
      {"_get_element_type_def", &POA_CORBA::SequenceDef::_get_element_type_def_skel, 0},
      {"_set_element_type_def", &POA_CORBA::SequenceDef::_set_element_type_def_skel, 0},
      {"_get_element_type", &POA_CORBA::SequenceDef::_get_element_type_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,   5,  -1,   6,  -7,  -2, -29,  -1,  -1,   9,
       10,  11, -15,  -2,  12,  13,  14, -32,  -1,  -1,  -1,  -1,  -1,  17,

    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_SequenceDef_Perfect_Hash_OpTable tao_CORBA_SequenceDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA__TAO_SequenceDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA__TAO_SequenceDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_SequenceDef_Proxy_Broker_Factory_function_pointer =
    CORBA__TAO_SequenceDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA__TAO_SequenceDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_SequenceDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA__TAO_SequenceDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::SequenceDef::SequenceDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_SequenceDef_optable;
}

POA_CORBA::SequenceDef::SequenceDef (const SequenceDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::IDLType (rhs)
{
}

POA_CORBA::SequenceDef::~SequenceDef (void)
{
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_bound_SequenceDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_bound_SequenceDef (
      POA_CORBA::SequenceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ULong>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->bound ();
    }

  private:
    POA_CORBA::SequenceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::SequenceDef::_get_bound_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ULong>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::SequenceDef * const impl =
    static_cast<POA_CORBA::SequenceDef *> (servant);

  _get_bound_SequenceDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _set_bound_SequenceDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_bound_SequenceDef (
      POA_CORBA::SequenceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ULong>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_,
          1);

      this->servant_->bound (
        arg_1);
    }

  private:
    POA_CORBA::SequenceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::SequenceDef::_set_bound_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ULong>::in_arg_val _tao_bound;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_bound
    };

  static size_t const nargs = 2;

  POA_CORBA::SequenceDef * const impl =
    static_cast<POA_CORBA::SequenceDef *> (servant);

  _set_bound_SequenceDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_element_type_SequenceDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_element_type_SequenceDef (
      POA_CORBA::SequenceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::TypeCode>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::TypeCode> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->element_type ();
    }

  private:
    POA_CORBA::SequenceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::SequenceDef::_get_element_type_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::TypeCode>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::SequenceDef * const impl =
    static_cast<POA_CORBA::SequenceDef *> (servant);

  _get_element_type_SequenceDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_element_type_def_SequenceDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_element_type_def_SequenceDef (
      POA_CORBA::SequenceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::IDLType>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->element_type_def ();
    }

  private:
    POA_CORBA::SequenceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::SequenceDef::_get_element_type_def_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::IDLType>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::SequenceDef * const impl =
    static_cast<POA_CORBA::SequenceDef *> (servant);

  _get_element_type_def_SequenceDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _set_element_type_def_SequenceDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_element_type_def_SequenceDef (
      POA_CORBA::SequenceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          1);

      this->servant_->element_type_def (
        arg_1);
    }

  private:
    POA_CORBA::SequenceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::SequenceDef::_set_element_type_def_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_val _tao_element_type_def;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_element_type_def
    };

  static size_t const nargs = 2;

  POA_CORBA::SequenceDef * const impl =
    static_cast<POA_CORBA::SequenceDef *> (servant);

  _set_element_type_def_SequenceDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _is_a_SequenceDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_SequenceDef_Upcall_Command (
      POA_CORBA::SequenceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_-> _is_a (
          arg_1);
    }

  private:
    POA_CORBA::SequenceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::SequenceDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::SequenceDef * const impl =
    static_cast<POA_CORBA::SequenceDef *> (servant);

  _is_a_SequenceDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _non_existent_SequenceDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_SequenceDef_Upcall_Command (
      POA_CORBA::SequenceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _non_existent ();
    }

  private:
    POA_CORBA::SequenceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::SequenceDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::SequenceDef * const impl =
    static_cast<POA_CORBA::SequenceDef *> (servant);

  _non_existent_SequenceDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _repository_id_SequenceDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_SequenceDef_Upcall_Command (
      POA_CORBA::SequenceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _repository_id ();
    }

  private:
    POA_CORBA::SequenceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::SequenceDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::SequenceDef * const impl =
    static_cast<POA_CORBA::SequenceDef *> (servant);

  _repository_id_SequenceDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::SequenceDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::SequenceDef * const impl =
    static_cast<POA_CORBA::SequenceDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_component_SequenceDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_SequenceDef_Upcall_Command (
      POA_CORBA::SequenceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _get_component ();
    }

  private:
    POA_CORBA::SequenceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::SequenceDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::SequenceDef * const impl =
    static_cast<POA_CORBA::SequenceDef *> (servant);

  _get_component_SequenceDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::SequenceDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/SequenceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::SequenceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/SequenceDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::SequenceDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::SequenceDef *
POA_CORBA::SequenceDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::SequenceDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_SequenceDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_ArrayDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ArrayDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ArrayDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22,  0,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22,  0,
     22, 22,  0,  0,  0, 22,  0, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22,  5, 22, 22, 22, 22,  0, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22,
#else
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22,  0, 22,  0, 22, 22,
      0,  0,  0, 22,  0, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22,  5, 22, 22, 22,
     22,  0, 22, 22, 22, 22, 22, 22,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_ArrayDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 13,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 21,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 21,
      HASH_VALUE_RANGE = 17,
      DUPLICATES = 3,
      WORDLIST_SIZE = 18
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_CORBA::ArrayDef::_is_a_skel, 0},
      {"destroy", &POA_CORBA::ArrayDef::destroy_skel, 0},
      {"_get_type", &POA_CORBA::ArrayDef::_get_type_skel, 0},
      {"_interface", &POA_CORBA::ArrayDef::_interface_skel, 0},
      {"_get_length", &POA_CORBA::ArrayDef::_get_length_skel, 0},
      {"_set_length", &POA_CORBA::ArrayDef::_set_length_skel, 0},
      {"_get_def_kind", &POA_CORBA::ArrayDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::ArrayDef::_repository_id_skel, 0},
      {"_component", &POA_CORBA::ArrayDef::_component_skel, 0},
      {"_get_element_type", &POA_CORBA::ArrayDef::_get_element_type_skel, 0},
      {"_non_existent", &POA_CORBA::ArrayDef::_non_existent_skel, 0},
      {"_get_element_type_def", &POA_CORBA::ArrayDef::_get_element_type_def_skel, 0},
      {"_set_element_type_def", &POA_CORBA::ArrayDef::_set_element_type_def_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -9,  -2,   5,  -1,   6,  -1,   7,   8, -29,  -1,  11,
       12,  13,  -1,  14,  15, -16,  -2, -23,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ArrayDef_Perfect_Hash_OpTable tao_CORBA_ArrayDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA__TAO_ArrayDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA__TAO_ArrayDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_ArrayDef_Proxy_Broker_Factory_function_pointer =
    CORBA__TAO_ArrayDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA__TAO_ArrayDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_ArrayDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA__TAO_ArrayDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::ArrayDef::ArrayDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ArrayDef_optable;
}

POA_CORBA::ArrayDef::ArrayDef (const ArrayDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::IDLType (rhs)
{
}

POA_CORBA::ArrayDef::~ArrayDef (void)
{
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_length_ArrayDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_length_ArrayDef (
      POA_CORBA::ArrayDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ULong>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->length ();
    }

  private:
    POA_CORBA::ArrayDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ArrayDef::_get_length_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ULong>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ArrayDef * const impl =
    static_cast<POA_CORBA::ArrayDef *> (servant);

  _get_length_ArrayDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _set_length_ArrayDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_length_ArrayDef (
      POA_CORBA::ArrayDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ULong>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_,
          1);

      this->servant_->length (
        arg_1);
    }

  private:
    POA_CORBA::ArrayDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ArrayDef::_set_length_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ULong>::in_arg_val _tao_length;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_length
    };

  static size_t const nargs = 2;

  POA_CORBA::ArrayDef * const impl =
    static_cast<POA_CORBA::ArrayDef *> (servant);

  _set_length_ArrayDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_element_type_ArrayDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_element_type_ArrayDef (
      POA_CORBA::ArrayDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::TypeCode>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::TypeCode> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->element_type ();
    }

  private:
    POA_CORBA::ArrayDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ArrayDef::_get_element_type_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::TypeCode>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ArrayDef * const impl =
    static_cast<POA_CORBA::ArrayDef *> (servant);

  _get_element_type_ArrayDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_element_type_def_ArrayDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_element_type_def_ArrayDef (
      POA_CORBA::ArrayDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::IDLType>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->element_type_def ();
    }

  private:
    POA_CORBA::ArrayDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ArrayDef::_get_element_type_def_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::IDLType>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ArrayDef * const impl =
    static_cast<POA_CORBA::ArrayDef *> (servant);

  _get_element_type_def_ArrayDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _set_element_type_def_ArrayDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_element_type_def_ArrayDef (
      POA_CORBA::ArrayDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          1);

      this->servant_->element_type_def (
        arg_1);
    }

  private:
    POA_CORBA::ArrayDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ArrayDef::_set_element_type_def_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_val _tao_element_type_def;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_element_type_def
    };

  static size_t const nargs = 2;

  POA_CORBA::ArrayDef * const impl =
    static_cast<POA_CORBA::ArrayDef *> (servant);

  _set_element_type_def_ArrayDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _is_a_ArrayDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_ArrayDef_Upcall_Command (
      POA_CORBA::ArrayDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_-> _is_a (
          arg_1);
    }

  private:
    POA_CORBA::ArrayDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ArrayDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::ArrayDef * const impl =
    static_cast<POA_CORBA::ArrayDef *> (servant);

  _is_a_ArrayDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _non_existent_ArrayDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_ArrayDef_Upcall_Command (
      POA_CORBA::ArrayDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _non_existent ();
    }

  private:
    POA_CORBA::ArrayDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ArrayDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ArrayDef * const impl =
    static_cast<POA_CORBA::ArrayDef *> (servant);

  _non_existent_ArrayDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _repository_id_ArrayDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_ArrayDef_Upcall_Command (
      POA_CORBA::ArrayDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _repository_id ();
    }

  private:
    POA_CORBA::ArrayDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ArrayDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ArrayDef * const impl =
    static_cast<POA_CORBA::ArrayDef *> (servant);

  _repository_id_ArrayDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::ArrayDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::ArrayDef * const impl =
    static_cast<POA_CORBA::ArrayDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_component_ArrayDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_ArrayDef_Upcall_Command (
      POA_CORBA::ArrayDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _get_component ();
    }

  private:
    POA_CORBA::ArrayDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ArrayDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ArrayDef * const impl =
    static_cast<POA_CORBA::ArrayDef *> (servant);

  _get_component_ArrayDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::ArrayDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ArrayDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ArrayDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ArrayDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::ArrayDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::ArrayDef *
POA_CORBA::ArrayDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::ArrayDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_ArrayDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_ExceptionDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ExceptionDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ExceptionDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61,  0,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61,  0,
     61, 25,  8,  0, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61,  0, 15,  5,
     61,  0, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 20, 20, 61, 61, 61, 15, 10, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61,
#else
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61,  0, 61,  0, 61, 25,
      8,  0, 61, 61, 61, 61, 61, 61,  0, 15,
      5, 61,  0, 61, 61, 20, 20, 61, 61, 61,
     15, 10, 61, 61, 61, 61, 61, 61,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_ExceptionDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 39,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 60,
      HASH_VALUE_RANGE = 56,
      DUPLICATES = 8,
      WORDLIST_SIZE = 44
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_CORBA::ExceptionDef::_is_a_skel, 0},
      {"lookup", &POA_CORBA::ExceptionDef::lookup_skel, 0},
      {"_get_name", &POA_CORBA::ExceptionDef::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::ExceptionDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::ExceptionDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::ExceptionDef::_interface_skel, 0},
      {"lookup_name", &POA_CORBA::ExceptionDef::lookup_name_skel, 0},
      {"_get_id", &POA_CORBA::ExceptionDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::ExceptionDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::ExceptionDef::describe_skel, 0},
      {"_get_version", &POA_CORBA::ExceptionDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::ExceptionDef::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::ExceptionDef::_get_absolute_name_skel, 0},
      {"move", &POA_CORBA::ExceptionDef::move_skel, 0},
      {"_get_defined_in", &POA_CORBA::ExceptionDef::_get_defined_in_skel, 0},
      {"_get_def_kind", &POA_CORBA::ExceptionDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::ExceptionDef::_repository_id_skel, 0},
      {"destroy", &POA_CORBA::ExceptionDef::destroy_skel, 0},
      {"_component", &POA_CORBA::ExceptionDef::_component_skel, 0},
      {"_get_members", &POA_CORBA::ExceptionDef::_get_members_skel, 0},
      {"_set_members", &POA_CORBA::ExceptionDef::_set_members_skel, 0},
      {"_non_existent", &POA_CORBA::ExceptionDef::_non_existent_skel, 0},
      {"_get_containing_repository", &POA_CORBA::ExceptionDef::_get_containing_repository_skel, 0},
      {"create_value", &POA_CORBA::ExceptionDef::create_value_skel, 0},
      {"create_module", &POA_CORBA::ExceptionDef::create_module_skel, 0},
      {"create_native", &POA_CORBA::ExceptionDef::create_native_skel, 0},
      {"create_interface", &POA_CORBA::ExceptionDef::create_interface_skel, 0},
      {"create_ext_value", &POA_CORBA::ExceptionDef::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::ExceptionDef::create_union_skel, 0},
      {"describe_contents", &POA_CORBA::ExceptionDef::describe_contents_skel, 0},
      {"create_exception", &POA_CORBA::ExceptionDef::create_exception_skel, 0},
      {"create_local_interface", &POA_CORBA::ExceptionDef::create_local_interface_skel, 0},
      {"create_abstract_interface", &POA_CORBA::ExceptionDef::create_abstract_interface_skel, 0},
      {"create_enum", &POA_CORBA::ExceptionDef::create_enum_skel, 0},
      {"contents", &POA_CORBA::ExceptionDef::contents_skel, 0},
      {"create_value_box", &POA_CORBA::ExceptionDef::create_value_box_skel, 0},
      {"create_alias", &POA_CORBA::ExceptionDef::create_alias_skel, 0},
      {"create_struct", &POA_CORBA::ExceptionDef::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::ExceptionDef::create_constant_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -7,  -3,   5,   6, -12,  -2, -66,  10,  11,  -1, -15,
       -2, -68,  14, -64,  17,  18,  19,  20,  21,  -1,  -1,  22,  -1,  -1,
      -24,  -2,  23,  -1, -64,  26, -29,  -2,  27,  28, -64, -31,  -2, -62,
       33,  -1,  -1,  34,  35,  36,  -1,  -1,  37,  38,  -1,  39,  -1,  -1,
       40,  41,  42,  -1,  43,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ExceptionDef_Perfect_Hash_OpTable tao_CORBA_ExceptionDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA__TAO_ExceptionDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA__TAO_ExceptionDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_ExceptionDef_Proxy_Broker_Factory_function_pointer =
    CORBA__TAO_ExceptionDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA__TAO_ExceptionDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_ExceptionDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA__TAO_ExceptionDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::ExceptionDef::ExceptionDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ExceptionDef_optable;
}

POA_CORBA::ExceptionDef::ExceptionDef (const ExceptionDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::Container (rhs)
{
}

POA_CORBA::ExceptionDef::~ExceptionDef (void)
{
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_type_ExceptionDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_type_ExceptionDef (
      POA_CORBA::ExceptionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::TypeCode>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::TypeCode> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->type ();
    }

  private:
    POA_CORBA::ExceptionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ExceptionDef::_get_type_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::TypeCode>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ExceptionDef * const impl =
    static_cast<POA_CORBA::ExceptionDef *> (servant);

  _get_type_ExceptionDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_members_ExceptionDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_members_ExceptionDef (
      POA_CORBA::ExceptionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::StructMemberSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::StructMemberSeq> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->members ();
    }

  private:
    POA_CORBA::ExceptionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ExceptionDef::_get_members_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::StructMemberSeq>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ExceptionDef * const impl =
    static_cast<POA_CORBA::ExceptionDef *> (servant);

  _get_members_ExceptionDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _set_members_ExceptionDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_members_ExceptionDef (
      POA_CORBA::ExceptionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::StructMemberSeq>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::StructMemberSeq> (
          this->operation_details_,
          this->args_,
          1);

      this->servant_->members (
        arg_1);
    }

  private:
    POA_CORBA::ExceptionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ExceptionDef::_set_members_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::StructMemberSeq>::in_arg_val _tao_members;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_members
    };

  static size_t const nargs = 2;

  POA_CORBA::ExceptionDef * const impl =
    static_cast<POA_CORBA::ExceptionDef *> (servant);

  _set_members_ExceptionDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _is_a_ExceptionDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_ExceptionDef_Upcall_Command (
      POA_CORBA::ExceptionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_-> _is_a (
          arg_1);
    }

  private:
    POA_CORBA::ExceptionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ExceptionDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::ExceptionDef * const impl =
    static_cast<POA_CORBA::ExceptionDef *> (servant);

  _is_a_ExceptionDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _non_existent_ExceptionDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_ExceptionDef_Upcall_Command (
      POA_CORBA::ExceptionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _non_existent ();
    }

  private:
    POA_CORBA::ExceptionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ExceptionDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ExceptionDef * const impl =
    static_cast<POA_CORBA::ExceptionDef *> (servant);

  _non_existent_ExceptionDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _repository_id_ExceptionDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_ExceptionDef_Upcall_Command (
      POA_CORBA::ExceptionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _repository_id ();
    }

  private:
    POA_CORBA::ExceptionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ExceptionDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ExceptionDef * const impl =
    static_cast<POA_CORBA::ExceptionDef *> (servant);

  _repository_id_ExceptionDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::ExceptionDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::ExceptionDef * const impl =
    static_cast<POA_CORBA::ExceptionDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_component_ExceptionDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_ExceptionDef_Upcall_Command (
      POA_CORBA::ExceptionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _get_component ();
    }

  private:
    POA_CORBA::ExceptionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ExceptionDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ExceptionDef * const impl =
    static_cast<POA_CORBA::ExceptionDef *> (servant);

  _get_component_ExceptionDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::ExceptionDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ExceptionDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ExceptionDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ExceptionDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::ExceptionDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::ExceptionDef *
POA_CORBA::ExceptionDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::ExceptionDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_ExceptionDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_AttributeDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_AttributeDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_AttributeDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 15, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 15, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_AttributeDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 23,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 8,
      WORDLIST_SIZE = 27
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::AttributeDef::move_skel, 0},
      {"_is_a", &POA_CORBA::AttributeDef::_is_a_skel, 0},
      {"_get_id", &POA_CORBA::AttributeDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::AttributeDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::AttributeDef::describe_skel, 0},
      {"_get_name", &POA_CORBA::AttributeDef::_get_name_skel, 0},
      {"_set_mode", &POA_CORBA::AttributeDef::_set_mode_skel, 0},
      {"_get_mode", &POA_CORBA::AttributeDef::_get_mode_skel, 0},
      {"_get_type", &POA_CORBA::AttributeDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::AttributeDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::AttributeDef::_interface_skel, 0},
      {"_get_version", &POA_CORBA::AttributeDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::AttributeDef::_set_version_skel, 0},
      {"_get_def_kind", &POA_CORBA::AttributeDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::AttributeDef::_repository_id_skel, 0},
      {"_get_defined_in", &POA_CORBA::AttributeDef::_get_defined_in_skel, 0},
      {"destroy", &POA_CORBA::AttributeDef::destroy_skel, 0},
      {"_get_absolute_name", &POA_CORBA::AttributeDef::_get_absolute_name_skel, 0},
      {"_component", &POA_CORBA::AttributeDef::_component_skel, 0},
      {"_non_existent", &POA_CORBA::AttributeDef::_non_existent_skel, 0},
      {"_get_type_def", &POA_CORBA::AttributeDef::_get_type_def_skel, 0},
      {"_set_type_def", &POA_CORBA::AttributeDef::_set_type_def_skel, 0},
      {"_get_containing_repository", &POA_CORBA::AttributeDef::_get_containing_repository_skel, 0},
    };

  static const signed char lookup[] =
    {
       -9,  -5, -15,  -2,   4,   5,  -1,  50,   8, -45,  14,  -1, -46,  17,
       18,  19,  -1,  20,  21,  -1,  22,  -6,  -2,  23,  -1,  -1, -24,  -2,
      -38,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  26,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_AttributeDef_Perfect_Hash_OpTable tao_CORBA_AttributeDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA__TAO_AttributeDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA__TAO_AttributeDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_AttributeDef_Proxy_Broker_Factory_function_pointer =
    CORBA__TAO_AttributeDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA__TAO_AttributeDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_AttributeDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA__TAO_AttributeDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::AttributeDef::AttributeDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_AttributeDef_optable;
}

POA_CORBA::AttributeDef::AttributeDef (const AttributeDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Contained (rhs)
{
}

POA_CORBA::AttributeDef::~AttributeDef (void)
{
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_type_AttributeDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_type_AttributeDef (
      POA_CORBA::AttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::TypeCode>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::TypeCode> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->type ();
    }

  private:
    POA_CORBA::AttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::AttributeDef::_get_type_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::TypeCode>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::AttributeDef * const impl =
    static_cast<POA_CORBA::AttributeDef *> (servant);

  _get_type_AttributeDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_type_def_AttributeDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_type_def_AttributeDef (
      POA_CORBA::AttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::IDLType>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->type_def ();
    }

  private:
    POA_CORBA::AttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::AttributeDef::_get_type_def_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::IDLType>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::AttributeDef * const impl =
    static_cast<POA_CORBA::AttributeDef *> (servant);

  _get_type_def_AttributeDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _set_type_def_AttributeDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_type_def_AttributeDef (
      POA_CORBA::AttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          1);

      this->servant_->type_def (
        arg_1);
    }

  private:
    POA_CORBA::AttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::AttributeDef::_set_type_def_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_val _tao_type_def;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_type_def
    };

  static size_t const nargs = 2;

  POA_CORBA::AttributeDef * const impl =
    static_cast<POA_CORBA::AttributeDef *> (servant);

  _set_type_def_AttributeDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_mode_AttributeDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_mode_AttributeDef (
      POA_CORBA::AttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::AttributeMode>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::AttributeMode> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->mode ();
    }

  private:
    POA_CORBA::AttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::AttributeDef::_get_mode_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::AttributeMode>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::AttributeDef * const impl =
    static_cast<POA_CORBA::AttributeDef *> (servant);

  _get_mode_AttributeDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _set_mode_AttributeDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_mode_AttributeDef (
      POA_CORBA::AttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::AttributeMode>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::AttributeMode> (
          this->operation_details_,
          this->args_,
          1);

      this->servant_->mode (
        arg_1);
    }

  private:
    POA_CORBA::AttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::AttributeDef::_set_mode_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::AttributeMode>::in_arg_val _tao_mode;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_mode
    };

  static size_t const nargs = 2;

  POA_CORBA::AttributeDef * const impl =
    static_cast<POA_CORBA::AttributeDef *> (servant);

  _set_mode_AttributeDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _is_a_AttributeDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_AttributeDef_Upcall_Command (
      POA_CORBA::AttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_-> _is_a (
          arg_1);
    }

  private:
    POA_CORBA::AttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::AttributeDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::AttributeDef * const impl =
    static_cast<POA_CORBA::AttributeDef *> (servant);

  _is_a_AttributeDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _non_existent_AttributeDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_AttributeDef_Upcall_Command (
      POA_CORBA::AttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _non_existent ();
    }

  private:
    POA_CORBA::AttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::AttributeDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::AttributeDef * const impl =
    static_cast<POA_CORBA::AttributeDef *> (servant);

  _non_existent_AttributeDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _repository_id_AttributeDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_AttributeDef_Upcall_Command (
      POA_CORBA::AttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _repository_id ();
    }

  private:
    POA_CORBA::AttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::AttributeDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::AttributeDef * const impl =
    static_cast<POA_CORBA::AttributeDef *> (servant);

  _repository_id_AttributeDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::AttributeDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::AttributeDef * const impl =
    static_cast<POA_CORBA::AttributeDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_component_AttributeDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_AttributeDef_Upcall_Command (
      POA_CORBA::AttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _get_component ();
    }

  private:
    POA_CORBA::AttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::AttributeDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::AttributeDef * const impl =
    static_cast<POA_CORBA::AttributeDef *> (servant);

  _get_component_AttributeDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::AttributeDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/AttributeDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::AttributeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/AttributeDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::AttributeDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::AttributeDef *
POA_CORBA::AttributeDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::AttributeDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_AttributeDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_ExtAttributeDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ExtAttributeDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ExtAttributeDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44,  0,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44,  0,
     44, 44, 15,  0, 25, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44,  0,  0,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44,  0, 30, 44, 44, 44, 44,  5, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44,
#else
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44,  0, 44,  0, 44, 44,
     15,  0, 25, 44, 44, 44, 44, 44, 44,  0,
      0, 44, 44, 44, 44,  0, 30, 44, 44, 44,
     44,  5, 44, 44, 44, 44, 44, 44,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_ExtAttributeDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 28,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 43,
      HASH_VALUE_RANGE = 40,
      DUPLICATES = 11,
      WORDLIST_SIZE = 32
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::ExtAttributeDef::move_skel, 0},
      {"_is_a", &POA_CORBA::ExtAttributeDef::_is_a_skel, 0},
      {"_get_name", &POA_CORBA::ExtAttributeDef::_get_name_skel, 0},
      {"_set_mode", &POA_CORBA::ExtAttributeDef::_set_mode_skel, 0},
      {"_get_mode", &POA_CORBA::ExtAttributeDef::_get_mode_skel, 0},
      {"_get_type", &POA_CORBA::ExtAttributeDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::ExtAttributeDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::ExtAttributeDef::_interface_skel, 0},
      {"_get_version", &POA_CORBA::ExtAttributeDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::ExtAttributeDef::_set_version_skel, 0},
      {"_get_defined_in", &POA_CORBA::ExtAttributeDef::_get_defined_in_skel, 0},
      {"_get_absolute_name", &POA_CORBA::ExtAttributeDef::_get_absolute_name_skel, 0},
      {"_get_get_exceptions", &POA_CORBA::ExtAttributeDef::_get_get_exceptions_skel, 0},
      {"_set_set_exceptions", &POA_CORBA::ExtAttributeDef::_set_set_exceptions_skel, 0},
      {"_get_set_exceptions", &POA_CORBA::ExtAttributeDef::_get_set_exceptions_skel, 0},
      {"_set_get_exceptions", &POA_CORBA::ExtAttributeDef::_set_get_exceptions_skel, 0},
      {"_get_id", &POA_CORBA::ExtAttributeDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::ExtAttributeDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::ExtAttributeDef::describe_skel, 0},
      {"destroy", &POA_CORBA::ExtAttributeDef::destroy_skel, 0},
      {"_get_def_kind", &POA_CORBA::ExtAttributeDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::ExtAttributeDef::_repository_id_skel, 0},
      {"_get_containing_repository", &POA_CORBA::ExtAttributeDef::_get_containing_repository_skel, 0},
      {"describe_attribute", &POA_CORBA::ExtAttributeDef::describe_attribute_skel, 0},
      {"_get_type_def", &POA_CORBA::ExtAttributeDef::_get_type_def_skel, 0},
      {"_set_type_def", &POA_CORBA::ExtAttributeDef::_set_type_def_skel, 0},
      {"_component", &POA_CORBA::ExtAttributeDef::_component_skel, 0},
      {"_non_existent", &POA_CORBA::ExtAttributeDef::_non_existent_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -6,  -5,   4,   5,  -1, -12,  -2, -50,  11,  -1, -48,  -1,
       -1,  14, -16,  -4,  15, -46, -20,  -2, -45,  22,  -1,  -1,  -1,  23,
       24,  25,  -1,  26,  -1,  27,  -1,  -1, -28,  -2, -45,  -1,  30,  -1,
       -1,  31,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ExtAttributeDef_Perfect_Hash_OpTable tao_CORBA_ExtAttributeDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA__TAO_ExtAttributeDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA__TAO_ExtAttributeDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_ExtAttributeDef_Proxy_Broker_Factory_function_pointer =
    CORBA__TAO_ExtAttributeDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA__TAO_ExtAttributeDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_ExtAttributeDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA__TAO_ExtAttributeDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::ExtAttributeDef::ExtAttributeDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ExtAttributeDef_optable;
}

POA_CORBA::ExtAttributeDef::ExtAttributeDef (const ExtAttributeDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::AttributeDef (rhs)
{
}

POA_CORBA::ExtAttributeDef::~ExtAttributeDef (void)
{
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_get_exceptions_ExtAttributeDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_get_exceptions_ExtAttributeDef (
      POA_CORBA::ExtAttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ExcDescriptionSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ExcDescriptionSeq> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->get_exceptions ();
    }

  private:
    POA_CORBA::ExtAttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ExtAttributeDef::_get_get_exceptions_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ExcDescriptionSeq>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ExtAttributeDef * const impl =
    static_cast<POA_CORBA::ExtAttributeDef *> (servant);

  _get_get_exceptions_ExtAttributeDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _set_get_exceptions_ExtAttributeDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_get_exceptions_ExtAttributeDef (
      POA_CORBA::ExtAttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ExcDescriptionSeq>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ExcDescriptionSeq> (
          this->operation_details_,
          this->args_,
          1);

      this->servant_->get_exceptions (
        arg_1);
    }

  private:
    POA_CORBA::ExtAttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ExtAttributeDef::_set_get_exceptions_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ExcDescriptionSeq>::in_arg_val _tao_get_exceptions;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_get_exceptions
    };

  static size_t const nargs = 2;

  POA_CORBA::ExtAttributeDef * const impl =
    static_cast<POA_CORBA::ExtAttributeDef *> (servant);

  _set_get_exceptions_ExtAttributeDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_set_exceptions_ExtAttributeDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_set_exceptions_ExtAttributeDef (
      POA_CORBA::ExtAttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ExcDescriptionSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ExcDescriptionSeq> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->set_exceptions ();
    }

  private:
    POA_CORBA::ExtAttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ExtAttributeDef::_get_set_exceptions_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ExcDescriptionSeq>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ExtAttributeDef * const impl =
    static_cast<POA_CORBA::ExtAttributeDef *> (servant);

  _get_set_exceptions_ExtAttributeDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _set_set_exceptions_ExtAttributeDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_set_exceptions_ExtAttributeDef (
      POA_CORBA::ExtAttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ExcDescriptionSeq>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ExcDescriptionSeq> (
          this->operation_details_,
          this->args_,
          1);

      this->servant_->set_exceptions (
        arg_1);
    }

  private:
    POA_CORBA::ExtAttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ExtAttributeDef::_set_set_exceptions_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ExcDescriptionSeq>::in_arg_val _tao_set_exceptions;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_set_exceptions
    };

  static size_t const nargs = 2;

  POA_CORBA::ExtAttributeDef * const impl =
    static_cast<POA_CORBA::ExtAttributeDef *> (servant);

  _set_set_exceptions_ExtAttributeDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class describe_attribute_ExtAttributeDef
    : public TAO::Upcall_Command
  {
  public:
    inline describe_attribute_ExtAttributeDef (
      POA_CORBA::ExtAttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ExtAttributeDescription>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ExtAttributeDescription> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->describe_attribute ();
    }

  private:
    POA_CORBA::ExtAttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ExtAttributeDef::describe_attribute_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ExtAttributeDescription>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ExtAttributeDef * const impl =
    static_cast<POA_CORBA::ExtAttributeDef *> (servant);

  describe_attribute_ExtAttributeDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _is_a_ExtAttributeDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_ExtAttributeDef_Upcall_Command (
      POA_CORBA::ExtAttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_-> _is_a (
          arg_1);
    }

  private:
    POA_CORBA::ExtAttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ExtAttributeDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::ExtAttributeDef * const impl =
    static_cast<POA_CORBA::ExtAttributeDef *> (servant);

  _is_a_ExtAttributeDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _non_existent_ExtAttributeDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_ExtAttributeDef_Upcall_Command (
      POA_CORBA::ExtAttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _non_existent ();
    }

  private:
    POA_CORBA::ExtAttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ExtAttributeDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ExtAttributeDef * const impl =
    static_cast<POA_CORBA::ExtAttributeDef *> (servant);

  _non_existent_ExtAttributeDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _repository_id_ExtAttributeDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_ExtAttributeDef_Upcall_Command (
      POA_CORBA::ExtAttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _repository_id ();
    }

  private:
    POA_CORBA::ExtAttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ExtAttributeDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ExtAttributeDef * const impl =
    static_cast<POA_CORBA::ExtAttributeDef *> (servant);

  _repository_id_ExtAttributeDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::ExtAttributeDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::ExtAttributeDef * const impl =
    static_cast<POA_CORBA::ExtAttributeDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_component_ExtAttributeDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_ExtAttributeDef_Upcall_Command (
      POA_CORBA::ExtAttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _get_component ();
    }

  private:
    POA_CORBA::ExtAttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ExtAttributeDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ExtAttributeDef * const impl =
    static_cast<POA_CORBA::ExtAttributeDef *> (servant);

  _get_component_ExtAttributeDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::ExtAttributeDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/AttributeDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ExtAttributeDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ExtAttributeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ExtAttributeDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::ExtAttributeDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::ExtAttributeDef *
POA_CORBA::ExtAttributeDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::ExtAttributeDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_ExtAttributeDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_OperationDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_OperationDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_OperationDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 15,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  5,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37,  0, 20, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
     15,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      5, 37, 37, 37, 37,  0, 20, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_OperationDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 29,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 10,
      WORDLIST_SIZE = 33
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::OperationDef::move_skel, 0},
      {"_is_a", &POA_CORBA::OperationDef::_is_a_skel, 0},
      {"_get_name", &POA_CORBA::OperationDef::_get_name_skel, 0},
      {"_set_mode", &POA_CORBA::OperationDef::_set_mode_skel, 0},
      {"_get_mode", &POA_CORBA::OperationDef::_get_mode_skel, 0},
      {"_set_name", &POA_CORBA::OperationDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::OperationDef::_interface_skel, 0},
      {"_get_params", &POA_CORBA::OperationDef::_get_params_skel, 0},
      {"_set_params", &POA_CORBA::OperationDef::_set_params_skel, 0},
      {"_get_contexts", &POA_CORBA::OperationDef::_get_contexts_skel, 0},
      {"_set_contexts", &POA_CORBA::OperationDef::_set_contexts_skel, 0},
      {"_get_exceptions", &POA_CORBA::OperationDef::_get_exceptions_skel, 0},
      {"_set_exceptions", &POA_CORBA::OperationDef::_set_exceptions_skel, 0},
      {"_get_version", &POA_CORBA::OperationDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::OperationDef::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::OperationDef::_get_absolute_name_skel, 0},
      {"_get_defined_in", &POA_CORBA::OperationDef::_get_defined_in_skel, 0},
      {"_get_id", &POA_CORBA::OperationDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::OperationDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::OperationDef::describe_skel, 0},
      {"_get_result_def", &POA_CORBA::OperationDef::_get_result_def_skel, 0},
      {"_set_result_def", &POA_CORBA::OperationDef::_set_result_def_skel, 0},
      {"_get_def_kind", &POA_CORBA::OperationDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::OperationDef::_repository_id_skel, 0},
      {"_component", &POA_CORBA::OperationDef::_component_skel, 0},
      {"_get_result", &POA_CORBA::OperationDef::_get_result_skel, 0},
      {"destroy", &POA_CORBA::OperationDef::destroy_skel, 0},
      {"_non_existent", &POA_CORBA::OperationDef::_non_existent_skel, 0},
      {"_get_containing_repository", &POA_CORBA::OperationDef::_get_containing_repository_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
            {
              const TAO_operation_db_entry   *resword;

              switch (key)
                {
                case   4:
                  resword = &wordlist[4]; break;
                case   5:
                  resword = &wordlist[5]; break;
                case   9:
                  resword = &wordlist[6];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[7];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[8];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[9];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  10:
                  resword = &wordlist[10]; break;
                case  11:
                  resword = &wordlist[11];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[12];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  13:
                  resword = &wordlist[13];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[14];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  15:
                  resword = &wordlist[15];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[16];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  17:
                  resword = &wordlist[17];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[18];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  18:
                  resword = &wordlist[19]; break;
                case  20:
                  resword = &wordlist[20]; break;
                case  22:
                  resword = &wordlist[21];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[22];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  23:
                  resword = &wordlist[23]; break;
                case  25:
                  resword = &wordlist[24];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[25];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  28:
                  resword = &wordlist[26]; break;
                case  29:
                  resword = &wordlist[27]; break;
                case  30:
                  resword = &wordlist[28]; break;
                case  31:
                  resword = &wordlist[29]; break;
                case  32:
                  resword = &wordlist[30]; break;
                case  33:
                  resword = &wordlist[31]; break;
                case  36:
                  resword = &wordlist[32]; break;
                default: return 0;
                }
              if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1))
                return resword;
              return 0;
            }
        }
    }
  return 0;
}

static TAO_CORBA_OperationDef_Perfect_Hash_OpTable tao_CORBA_OperationDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA__TAO_OperationDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA__TAO_OperationDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_OperationDef_Proxy_Broker_Factory_function_pointer =
    CORBA__TAO_OperationDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA__TAO_OperationDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_OperationDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA__TAO_OperationDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::OperationDef::OperationDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_OperationDef_optable;
}

POA_CORBA::OperationDef::OperationDef (const OperationDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Contained (rhs)
{
}

POA_CORBA::OperationDef::~OperationDef (void)
{
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_result_OperationDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_result_OperationDef (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::TypeCode>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::TypeCode> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->result ();
    }

  private:
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::OperationDef::_get_result_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::TypeCode>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::OperationDef * const impl =
    static_cast<POA_CORBA::OperationDef *> (servant);

  _get_result_OperationDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_result_def_OperationDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_result_def_OperationDef (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::IDLType>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->result_def ();
    }

  private:
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::OperationDef::_get_result_def_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::IDLType>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::OperationDef * const impl =
    static_cast<POA_CORBA::OperationDef *> (servant);

  _get_result_def_OperationDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _set_result_def_OperationDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_result_def_OperationDef (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          1);

      this->servant_->result_def (
        arg_1);
    }

  private:
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::OperationDef::_set_result_def_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_val _tao_result_def;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_result_def
    };

  static size_t const nargs = 2;

  POA_CORBA::OperationDef * const impl =
    static_cast<POA_CORBA::OperationDef *> (servant);

  _set_result_def_OperationDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_params_OperationDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_params_OperationDef (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ParDescriptionSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ParDescriptionSeq> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->params ();
    }

  private:
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::OperationDef::_get_params_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ParDescriptionSeq>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::OperationDef * const impl =
    static_cast<POA_CORBA::OperationDef *> (servant);

  _get_params_OperationDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _set_params_OperationDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_params_OperationDef (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ParDescriptionSeq>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ParDescriptionSeq> (
          this->operation_details_,
          this->args_,
          1);

      this->servant_->params (
        arg_1);
    }

  private:
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::OperationDef::_set_params_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ParDescriptionSeq>::in_arg_val _tao_params;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_params
    };

  static size_t const nargs = 2;

  POA_CORBA::OperationDef * const impl =
    static_cast<POA_CORBA::OperationDef *> (servant);

  _set_params_OperationDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_mode_OperationDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_mode_OperationDef (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::OperationMode>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::OperationMode> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->mode ();
    }

  private:
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::OperationDef::_get_mode_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::OperationMode>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::OperationDef * const impl =
    static_cast<POA_CORBA::OperationDef *> (servant);

  _get_mode_OperationDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _set_mode_OperationDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_mode_OperationDef (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::OperationMode>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::OperationMode> (
          this->operation_details_,
          this->args_,
          1);

      this->servant_->mode (
        arg_1);
    }

  private:
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::OperationDef::_set_mode_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::OperationMode>::in_arg_val _tao_mode;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_mode
    };

  static size_t const nargs = 2;

  POA_CORBA::OperationDef * const impl =
    static_cast<POA_CORBA::OperationDef *> (servant);

  _set_mode_OperationDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_contexts_OperationDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_contexts_OperationDef (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ContextIdSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ContextIdSeq> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->contexts ();
    }

  private:
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::OperationDef::_get_contexts_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ContextIdSeq>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::OperationDef * const impl =
    static_cast<POA_CORBA::OperationDef *> (servant);

  _get_contexts_OperationDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _set_contexts_OperationDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_contexts_OperationDef (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ContextIdSeq>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ContextIdSeq> (
          this->operation_details_,
          this->args_,
          1);

      this->servant_->contexts (
        arg_1);
    }

  private:
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::OperationDef::_set_contexts_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ContextIdSeq>::in_arg_val _tao_contexts;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_contexts
    };

  static size_t const nargs = 2;

  POA_CORBA::OperationDef * const impl =
    static_cast<POA_CORBA::OperationDef *> (servant);

  _set_contexts_OperationDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_exceptions_OperationDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_exceptions_OperationDef (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ExceptionDefSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ExceptionDefSeq> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->exceptions ();
    }

  private:
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::OperationDef::_get_exceptions_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ExceptionDefSeq>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::OperationDef * const impl =
    static_cast<POA_CORBA::OperationDef *> (servant);

  _get_exceptions_OperationDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _set_exceptions_OperationDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_exceptions_OperationDef (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ExceptionDefSeq>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ExceptionDefSeq> (
          this->operation_details_,
          this->args_,
          1);

      this->servant_->exceptions (
        arg_1);
    }

  private:
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::OperationDef::_set_exceptions_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ExceptionDefSeq>::in_arg_val _tao_exceptions;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_exceptions
    };

  static size_t const nargs = 2;

  POA_CORBA::OperationDef * const impl =
    static_cast<POA_CORBA::OperationDef *> (servant);

  _set_exceptions_OperationDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _is_a_OperationDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_OperationDef_Upcall_Command (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_-> _is_a (
          arg_1);
    }

  private:
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::OperationDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::OperationDef * const impl =
    static_cast<POA_CORBA::OperationDef *> (servant);

  _is_a_OperationDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _non_existent_OperationDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_OperationDef_Upcall_Command (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _non_existent ();
    }

  private:
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::OperationDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::OperationDef * const impl =
    static_cast<POA_CORBA::OperationDef *> (servant);

  _non_existent_OperationDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _repository_id_OperationDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_OperationDef_Upcall_Command (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _repository_id ();
    }

  private:
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::OperationDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::OperationDef * const impl =
    static_cast<POA_CORBA::OperationDef *> (servant);

  _repository_id_OperationDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::OperationDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::OperationDef * const impl =
    static_cast<POA_CORBA::OperationDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_component_OperationDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_OperationDef_Upcall_Command (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _get_component ();
    }

  private:
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::OperationDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::OperationDef * const impl =
    static_cast<POA_CORBA::OperationDef *> (servant);

  _get_component_OperationDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::OperationDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/OperationDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::OperationDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/OperationDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::OperationDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::OperationDef *
POA_CORBA::OperationDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::OperationDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_OperationDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_InterfaceDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_InterfaceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_InterfaceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81,  0,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81,  0,
     81, 30, 20,  0, 81, 81, 81, 10, 81, 81,
     81, 81, 81, 81, 81, 81, 81,  0,  0,  5,
     81,  0, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 20, 35, 81, 81, 81, 10,  5, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81,
#else
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81,  0, 81,  0, 81, 30,
     20,  0, 81, 81, 81, 10, 81, 81,  0,  0,
      5, 81,  0, 81, 81, 20, 35, 81, 81, 81,
     10,  5, 81, 81, 81, 81, 81, 81,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_InterfaceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 43,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 80,
      HASH_VALUE_RANGE = 77,
      DUPLICATES = 10,
      WORDLIST_SIZE = 47
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::InterfaceDef::move_skel, 0},
      {"_is_a", &POA_CORBA::InterfaceDef::_is_a_skel, 0},
      {"lookup", &POA_CORBA::InterfaceDef::lookup_skel, 0},
      {"_get_name", &POA_CORBA::InterfaceDef::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::InterfaceDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::InterfaceDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::InterfaceDef::_interface_skel, 0},
      {"lookup_name", &POA_CORBA::InterfaceDef::lookup_name_skel, 0},
      {"is_a", &POA_CORBA::InterfaceDef::is_a_skel, 0},
      {"_get_version", &POA_CORBA::InterfaceDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::InterfaceDef::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::InterfaceDef::_get_absolute_name_skel, 0},
      {"_get_defined_in", &POA_CORBA::InterfaceDef::_get_defined_in_skel, 0},
      {"_get_id", &POA_CORBA::InterfaceDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::InterfaceDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::InterfaceDef::describe_skel, 0},
      {"_get_containing_repository", &POA_CORBA::InterfaceDef::_get_containing_repository_skel, 0},
      {"destroy", &POA_CORBA::InterfaceDef::destroy_skel, 0},
      {"_get_def_kind", &POA_CORBA::InterfaceDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::InterfaceDef::_repository_id_skel, 0},
      {"describe_interface", &POA_CORBA::InterfaceDef::describe_interface_skel, 0},
      {"_get_base_interfaces", &POA_CORBA::InterfaceDef::_get_base_interfaces_skel, 0},
      {"_set_base_interfaces", &POA_CORBA::InterfaceDef::_set_base_interfaces_skel, 0},
      {"create_enum", &POA_CORBA::InterfaceDef::create_enum_skel, 0},
      {"create_value", &POA_CORBA::InterfaceDef::create_value_skel, 0},
      {"create_module", &POA_CORBA::InterfaceDef::create_module_skel, 0},
      {"create_native", &POA_CORBA::InterfaceDef::create_native_skel, 0},
      {"_component", &POA_CORBA::InterfaceDef::_component_skel, 0},
      {"create_interface", &POA_CORBA::InterfaceDef::create_interface_skel, 0},
      {"create_attribute", &POA_CORBA::InterfaceDef::create_attribute_skel, 0},
      {"create_ext_value", &POA_CORBA::InterfaceDef::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::InterfaceDef::create_union_skel, 0},
      {"_non_existent", &POA_CORBA::InterfaceDef::_non_existent_skel, 0},
      {"create_exception", &POA_CORBA::InterfaceDef::create_exception_skel, 0},
      {"create_operation", &POA_CORBA::InterfaceDef::create_operation_skel, 0},
      {"create_local_interface", &POA_CORBA::InterfaceDef::create_local_interface_skel, 0},
      {"create_abstract_interface", &POA_CORBA::InterfaceDef::create_abstract_interface_skel, 0},
      {"create_value_box", &POA_CORBA::InterfaceDef::create_value_box_skel, 0},
      {"describe_contents", &POA_CORBA::InterfaceDef::describe_contents_skel, 0},
      {"contents", &POA_CORBA::InterfaceDef::contents_skel, 0},
      {"create_alias", &POA_CORBA::InterfaceDef::create_alias_skel, 0},
      {"create_struct", &POA_CORBA::InterfaceDef::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::InterfaceDef::create_constant_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,   5,   6,  -7,  -3, -82,  10,  11,  -1,  -1,
       12, -13,  -2, -82,  15,  -1,  16,  -1,  -1, -17,  -2, -25,  -2, -84,
       19, -29,  -2,  20,  21,  22,  23,  -1, -32,  -3,  24,  -1, -95,  27,
       28, -94,  -1,  31, -90,  35,  36, -37,  -2, -82,  39,  -1,  -1,  40,
       41,  42,  43,  -1,  -1,  -1,  44,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  45,  -1,  46,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_InterfaceDef_Perfect_Hash_OpTable tao_CORBA_InterfaceDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA__TAO_InterfaceDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA__TAO_InterfaceDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_InterfaceDef_Proxy_Broker_Factory_function_pointer =
    CORBA__TAO_InterfaceDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA__TAO_InterfaceDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_InterfaceDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA__TAO_InterfaceDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::InterfaceDef::InterfaceDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_InterfaceDef_optable;
}

POA_CORBA::InterfaceDef::InterfaceDef (const InterfaceDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Container (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::IDLType (rhs)
{
}

POA_CORBA::InterfaceDef::~InterfaceDef (void)
{
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_base_interfaces_InterfaceDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_base_interfaces_InterfaceDef (
      POA_CORBA::InterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::InterfaceDefSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::InterfaceDefSeq> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->base_interfaces ();
    }

  private:
    POA_CORBA::InterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::InterfaceDef::_get_base_interfaces_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::InterfaceDefSeq>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::InterfaceDef * const impl =
    static_cast<POA_CORBA::InterfaceDef *> (servant);

  _get_base_interfaces_InterfaceDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _set_base_interfaces_InterfaceDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_base_interfaces_InterfaceDef (
      POA_CORBA::InterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::InterfaceDefSeq>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::InterfaceDefSeq> (
          this->operation_details_,
          this->args_,
          1);

      this->servant_->base_interfaces (
        arg_1);
    }

  private:
    POA_CORBA::InterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::InterfaceDef::_set_base_interfaces_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::InterfaceDefSeq>::in_arg_val _tao_base_interfaces;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_base_interfaces
    };

  static size_t const nargs = 2;

  POA_CORBA::InterfaceDef * const impl =
    static_cast<POA_CORBA::InterfaceDef *> (servant);

  _set_base_interfaces_InterfaceDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class is_a_InterfaceDef
    : public TAO::Upcall_Command
  {
  public:
    inline is_a_InterfaceDef (
      POA_CORBA::InterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::RepositoryId> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_->is_a (
          arg_1);
    }

  private:
    POA_CORBA::InterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::InterfaceDef::is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_val _tao_interface_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_interface_id
    };

  static size_t const nargs = 2;

  POA_CORBA::InterfaceDef * const impl =
    static_cast<POA_CORBA::InterfaceDef *> (servant);

  is_a_InterfaceDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class describe_interface_InterfaceDef
    : public TAO::Upcall_Command
  {
  public:
    inline describe_interface_InterfaceDef (
      POA_CORBA::InterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::InterfaceDef::FullInterfaceDescription>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::InterfaceDef::FullInterfaceDescription> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->describe_interface ();
    }

  private:
    POA_CORBA::InterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::InterfaceDef::describe_interface_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::InterfaceDef::FullInterfaceDescription>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::InterfaceDef * const impl =
    static_cast<POA_CORBA::InterfaceDef *> (servant);

  describe_interface_InterfaceDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class create_attribute_InterfaceDef
    : public TAO::Upcall_Command
  {
  public:
    inline create_attribute_InterfaceDef (
      POA_CORBA::InterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::AttributeDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::AttributeDef> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::RepositoryId> (
          this->operation_details_,
          this->args_,
          1);

      TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Identifier> (
          this->operation_details_,
          this->args_,
          2);

      TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::VersionSpec> (
          this->operation_details_,
          this->args_,
          3);

      TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_type arg_4 =
        TAO::Portable_Server::get_in_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          4);

      TAO::SArg_Traits< ::CORBA::AttributeMode>::in_arg_type arg_5 =
        TAO::Portable_Server::get_in_arg< ::CORBA::AttributeMode> (
          this->operation_details_,
          this->args_,
          5);

      retval =
        this->servant_->create_attribute (
          arg_1
          , arg_2
          , arg_3
          , arg_4
          , arg_5);
    }

  private:
    POA_CORBA::InterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::InterfaceDef::create_attribute_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::AttributeDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_val _tao_id;
  TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_val _tao_name;
  TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_val _tao_version;
  TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_val _tao_type;
  TAO::SArg_Traits< ::CORBA::AttributeMode>::in_arg_val _tao_mode;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version,
      &_tao_type,
      &_tao_mode
    };

  static size_t const nargs = 6;

  POA_CORBA::InterfaceDef * const impl =
    static_cast<POA_CORBA::InterfaceDef *> (servant);

  create_attribute_InterfaceDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class create_operation_InterfaceDef
    : public TAO::Upcall_Command
  {
  public:
    inline create_operation_InterfaceDef (
      POA_CORBA::InterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::OperationDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::OperationDef> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::RepositoryId> (
          this->operation_details_,
          this->args_,
          1);

      TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Identifier> (
          this->operation_details_,
          this->args_,
          2);

      TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::VersionSpec> (
          this->operation_details_,
          this->args_,
          3);

      TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_type arg_4 =
        TAO::Portable_Server::get_in_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          4);

      TAO::SArg_Traits< ::CORBA::OperationMode>::in_arg_type arg_5 =
        TAO::Portable_Server::get_in_arg< ::CORBA::OperationMode> (
          this->operation_details_,
          this->args_,
          5);

      TAO::SArg_Traits< ::CORBA::ParDescriptionSeq>::in_arg_type arg_6 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ParDescriptionSeq> (
          this->operation_details_,
          this->args_,
          6);

      TAO::SArg_Traits< ::CORBA::ExceptionDefSeq>::in_arg_type arg_7 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ExceptionDefSeq> (
          this->operation_details_,
          this->args_,
          7);

      TAO::SArg_Traits< ::CORBA::ContextIdSeq>::in_arg_type arg_8 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ContextIdSeq> (
          this->operation_details_,
          this->args_,
          8);

      retval =
        this->servant_->create_operation (
          arg_1
          , arg_2
          , arg_3
          , arg_4
          , arg_5
          , arg_6
          , arg_7
          , arg_8);
    }

  private:
    POA_CORBA::InterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::InterfaceDef::create_operation_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::OperationDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_val _tao_id;
  TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_val _tao_name;
  TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_val _tao_version;
  TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_val _tao_result;
  TAO::SArg_Traits< ::CORBA::OperationMode>::in_arg_val _tao_mode;
  TAO::SArg_Traits< ::CORBA::ParDescriptionSeq>::in_arg_val _tao_params;
  TAO::SArg_Traits< ::CORBA::ExceptionDefSeq>::in_arg_val _tao_exceptions;
  TAO::SArg_Traits< ::CORBA::ContextIdSeq>::in_arg_val _tao_contexts;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version,
      &_tao_result,
      &_tao_mode,
      &_tao_params,
      &_tao_exceptions,
      &_tao_contexts
    };

  static size_t const nargs = 9;

  POA_CORBA::InterfaceDef * const impl =
    static_cast<POA_CORBA::InterfaceDef *> (servant);

  create_operation_InterfaceDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _is_a_InterfaceDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_InterfaceDef_Upcall_Command (
      POA_CORBA::InterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_-> _is_a (
          arg_1);
    }

  private:
    POA_CORBA::InterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::InterfaceDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::InterfaceDef * const impl =
    static_cast<POA_CORBA::InterfaceDef *> (servant);

  _is_a_InterfaceDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _non_existent_InterfaceDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_InterfaceDef_Upcall_Command (
      POA_CORBA::InterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _non_existent ();
    }

  private:
    POA_CORBA::InterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::InterfaceDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::InterfaceDef * const impl =
    static_cast<POA_CORBA::InterfaceDef *> (servant);

  _non_existent_InterfaceDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _repository_id_InterfaceDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_InterfaceDef_Upcall_Command (
      POA_CORBA::InterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _repository_id ();
    }

  private:
    POA_CORBA::InterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::InterfaceDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::InterfaceDef * const impl =
    static_cast<POA_CORBA::InterfaceDef *> (servant);

  _repository_id_InterfaceDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::InterfaceDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::InterfaceDef * const impl =
    static_cast<POA_CORBA::InterfaceDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_component_InterfaceDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_InterfaceDef_Upcall_Command (
      POA_CORBA::InterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _get_component ();
    }

  private:
    POA_CORBA::InterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::InterfaceDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::InterfaceDef * const impl =
    static_cast<POA_CORBA::InterfaceDef *> (servant);

  _get_component_InterfaceDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::InterfaceDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::InterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/InterfaceDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::InterfaceDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::InterfaceDef *
POA_CORBA::InterfaceDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::InterfaceDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_InterfaceDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_InterfaceAttrExtension_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_InterfaceAttrExtension_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_InterfaceAttrExtension_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23,  0,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23,  0,
     23,  0,  0,  0, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23,  5, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23,
#else
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23,  0, 23,  0, 23,  0,
      0,  0, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23,  5, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_InterfaceAttrExtension_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 7,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 22,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 22,
      HASH_VALUE_RANGE = 18,
      DUPLICATES = 0,
      WORDLIST_SIZE = 12
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_CORBA::InterfaceAttrExtension::_is_a_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_interface", &POA_CORBA::InterfaceAttrExtension::_interface_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"_repository_id", &POA_CORBA::InterfaceAttrExtension::_repository_id_skel, 0},
      {"_component", &POA_CORBA::InterfaceAttrExtension::_component_skel, 0},
      {"",0,0},{"",0,0},
      {"_non_existent", &POA_CORBA::InterfaceAttrExtension::_non_existent_skel, 0},
      {"",0,0},
      {"create_ext_attribute", &POA_CORBA::InterfaceAttrExtension::create_ext_attribute_skel, 0},
      {"",0,0},
      {"describe_ext_interface", &POA_CORBA::InterfaceAttrExtension::describe_ext_interface_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_CORBA_InterfaceAttrExtension_Perfect_Hash_OpTable tao_CORBA_InterfaceAttrExtension_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA__TAO_InterfaceAttrExtension_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA__TAO_InterfaceAttrExtension_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_InterfaceAttrExtension_Proxy_Broker_Factory_function_pointer =
    CORBA__TAO_InterfaceAttrExtension_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA__TAO_InterfaceAttrExtension_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_InterfaceAttrExtension_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA__TAO_InterfaceAttrExtension_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::InterfaceAttrExtension::InterfaceAttrExtension (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_InterfaceAttrExtension_optable;
}

POA_CORBA::InterfaceAttrExtension::InterfaceAttrExtension (const InterfaceAttrExtension& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs)
{
}

POA_CORBA::InterfaceAttrExtension::~InterfaceAttrExtension (void)
{
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class describe_ext_interface_InterfaceAttrExtension
    : public TAO::Upcall_Command
  {
  public:
    inline describe_ext_interface_InterfaceAttrExtension (
      POA_CORBA::InterfaceAttrExtension * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->describe_ext_interface ();
    }

  private:
    POA_CORBA::InterfaceAttrExtension * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::InterfaceAttrExtension::describe_ext_interface_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::InterfaceAttrExtension * const impl =
    static_cast<POA_CORBA::InterfaceAttrExtension *> (servant);

  describe_ext_interface_InterfaceAttrExtension command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class create_ext_attribute_InterfaceAttrExtension
    : public TAO::Upcall_Command
  {
  public:
    inline create_ext_attribute_InterfaceAttrExtension (
      POA_CORBA::InterfaceAttrExtension * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ExtAttributeDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ExtAttributeDef> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::RepositoryId> (
          this->operation_details_,
          this->args_,
          1);

      TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Identifier> (
          this->operation_details_,
          this->args_,
          2);

      TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::VersionSpec> (
          this->operation_details_,
          this->args_,
          3);

      TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_type arg_4 =
        TAO::Portable_Server::get_in_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          4);

      TAO::SArg_Traits< ::CORBA::AttributeMode>::in_arg_type arg_5 =
        TAO::Portable_Server::get_in_arg< ::CORBA::AttributeMode> (
          this->operation_details_,
          this->args_,
          5);

      TAO::SArg_Traits< ::CORBA::ExceptionDefSeq>::in_arg_type arg_6 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ExceptionDefSeq> (
          this->operation_details_,
          this->args_,
          6);

      TAO::SArg_Traits< ::CORBA::ExceptionDefSeq>::in_arg_type arg_7 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ExceptionDefSeq> (
          this->operation_details_,
          this->args_,
          7);

      retval =
        this->servant_->create_ext_attribute (
          arg_1
          , arg_2
          , arg_3
          , arg_4
          , arg_5
          , arg_6
          , arg_7);
    }

  private:
    POA_CORBA::InterfaceAttrExtension * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::InterfaceAttrExtension::create_ext_attribute_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ExtAttributeDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_val _tao_id;
  TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_val _tao_name;
  TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_val _tao_version;
  TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_val _tao_type;
  TAO::SArg_Traits< ::CORBA::AttributeMode>::in_arg_val _tao_mode;
  TAO::SArg_Traits< ::CORBA::ExceptionDefSeq>::in_arg_val _tao_get_exceptions;
  TAO::SArg_Traits< ::CORBA::ExceptionDefSeq>::in_arg_val _tao_set_exceptions;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version,
      &_tao_type,
      &_tao_mode,
      &_tao_get_exceptions,
      &_tao_set_exceptions
    };

  static size_t const nargs = 8;

  POA_CORBA::InterfaceAttrExtension * const impl =
    static_cast<POA_CORBA::InterfaceAttrExtension *> (servant);

  create_ext_attribute_InterfaceAttrExtension command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _is_a_InterfaceAttrExtension_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_InterfaceAttrExtension_Upcall_Command (
      POA_CORBA::InterfaceAttrExtension * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_-> _is_a (
          arg_1);
    }

  private:
    POA_CORBA::InterfaceAttrExtension * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::InterfaceAttrExtension::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::InterfaceAttrExtension * const impl =
    static_cast<POA_CORBA::InterfaceAttrExtension *> (servant);

  _is_a_InterfaceAttrExtension_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _non_existent_InterfaceAttrExtension_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_InterfaceAttrExtension_Upcall_Command (
      POA_CORBA::InterfaceAttrExtension * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _non_existent ();
    }

  private:
    POA_CORBA::InterfaceAttrExtension * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::InterfaceAttrExtension::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::InterfaceAttrExtension * const impl =
    static_cast<POA_CORBA::InterfaceAttrExtension *> (servant);

  _non_existent_InterfaceAttrExtension_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _repository_id_InterfaceAttrExtension_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_InterfaceAttrExtension_Upcall_Command (
      POA_CORBA::InterfaceAttrExtension * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _repository_id ();
    }

  private:
    POA_CORBA::InterfaceAttrExtension * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::InterfaceAttrExtension::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::InterfaceAttrExtension * const impl =
    static_cast<POA_CORBA::InterfaceAttrExtension *> (servant);

  _repository_id_InterfaceAttrExtension_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::InterfaceAttrExtension::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::InterfaceAttrExtension * const impl =
    static_cast<POA_CORBA::InterfaceAttrExtension *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_component_InterfaceAttrExtension_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_InterfaceAttrExtension_Upcall_Command (
      POA_CORBA::InterfaceAttrExtension * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _get_component ();
    }

  private:
    POA_CORBA::InterfaceAttrExtension * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::InterfaceAttrExtension::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::InterfaceAttrExtension * const impl =
    static_cast<POA_CORBA::InterfaceAttrExtension *> (servant);

  _get_component_InterfaceAttrExtension_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::InterfaceAttrExtension::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceAttrExtension:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::InterfaceAttrExtension::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/InterfaceAttrExtension:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::InterfaceAttrExtension::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::InterfaceAttrExtension *
POA_CORBA::InterfaceAttrExtension::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::InterfaceAttrExtension STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_InterfaceAttrExtension_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_ExtInterfaceDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ExtInterfaceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ExtInterfaceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 30,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74,  0,
     74,  0, 20,  0, 74, 74, 74,  5, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 15,  0,  5,
     74, 15, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 15, 30, 74, 74, 74, 15,  5, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74,
#else
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 30, 74,  0, 74,  0,
     20,  0, 74, 74, 74,  5, 74, 74, 15,  0,
      5, 74, 15, 74, 74, 15, 30, 74, 74, 74,
     15,  5, 74, 74, 74, 74, 74, 74,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_ExtInterfaceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 45,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 73,
      HASH_VALUE_RANGE = 70,
      DUPLICATES = 10,
      WORDLIST_SIZE = 49
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::ExtInterfaceDef::move_skel, 0},
      {"is_a", &POA_CORBA::ExtInterfaceDef::is_a_skel, 0},
      {"create_enum", &POA_CORBA::ExtInterfaceDef::create_enum_skel, 0},
      {"create_value", &POA_CORBA::ExtInterfaceDef::create_value_skel, 0},
      {"create_module", &POA_CORBA::ExtInterfaceDef::create_module_skel, 0},
      {"create_native", &POA_CORBA::ExtInterfaceDef::create_native_skel, 0},
      {"create_interface", &POA_CORBA::ExtInterfaceDef::create_interface_skel, 0},
      {"create_attribute", &POA_CORBA::ExtInterfaceDef::create_attribute_skel, 0},
      {"create_ext_value", &POA_CORBA::ExtInterfaceDef::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::ExtInterfaceDef::create_union_skel, 0},
      {"create_ext_attribute", &POA_CORBA::ExtInterfaceDef::create_ext_attribute_skel, 0},
      {"create_exception", &POA_CORBA::ExtInterfaceDef::create_exception_skel, 0},
      {"create_operation", &POA_CORBA::ExtInterfaceDef::create_operation_skel, 0},
      {"create_local_interface", &POA_CORBA::ExtInterfaceDef::create_local_interface_skel, 0},
      {"contents", &POA_CORBA::ExtInterfaceDef::contents_skel, 0},
      {"create_abstract_interface", &POA_CORBA::ExtInterfaceDef::create_abstract_interface_skel, 0},
      {"lookup_name", &POA_CORBA::ExtInterfaceDef::lookup_name_skel, 0},
      {"create_alias", &POA_CORBA::ExtInterfaceDef::create_alias_skel, 0},
      {"describe", &POA_CORBA::ExtInterfaceDef::describe_skel, 0},
      {"create_value_box", &POA_CORBA::ExtInterfaceDef::create_value_box_skel, 0},
      {"destroy", &POA_CORBA::ExtInterfaceDef::destroy_skel, 0},
      {"_is_a", &POA_CORBA::ExtInterfaceDef::_is_a_skel, 0},
      {"lookup", &POA_CORBA::ExtInterfaceDef::lookup_skel, 0},
      {"describe_interface", &POA_CORBA::ExtInterfaceDef::describe_interface_skel, 0},
      {"_get_name", &POA_CORBA::ExtInterfaceDef::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::ExtInterfaceDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::ExtInterfaceDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::ExtInterfaceDef::_interface_skel, 0},
      {"describe_ext_interface", &POA_CORBA::ExtInterfaceDef::describe_ext_interface_skel, 0},
      {"create_struct", &POA_CORBA::ExtInterfaceDef::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::ExtInterfaceDef::create_constant_skel, 0},
      {"_get_version", &POA_CORBA::ExtInterfaceDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::ExtInterfaceDef::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::ExtInterfaceDef::_get_absolute_name_skel, 0},
      {"_get_defined_in", &POA_CORBA::ExtInterfaceDef::_get_defined_in_skel, 0},
      {"describe_contents", &POA_CORBA::ExtInterfaceDef::describe_contents_skel, 0},
      {"_get_id", &POA_CORBA::ExtInterfaceDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::ExtInterfaceDef::_set_id_skel, 0},
      {"_get_containing_repository", &POA_CORBA::ExtInterfaceDef::_get_containing_repository_skel, 0},
      {"_get_def_kind", &POA_CORBA::ExtInterfaceDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::ExtInterfaceDef::_repository_id_skel, 0},
      {"_get_base_interfaces", &POA_CORBA::ExtInterfaceDef::_get_base_interfaces_skel, 0},
      {"_set_base_interfaces", &POA_CORBA::ExtInterfaceDef::_set_base_interfaces_skel, 0},
      {"_component", &POA_CORBA::ExtInterfaceDef::_component_skel, 0},
      {"_non_existent", &POA_CORBA::ExtInterfaceDef::_non_existent_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,  -1,  -1,  -8,  -2,   5,  -1,   6,   7, -79,
      -10,  -3, -75,  13, -15,  -2,  14, -76,  17,  18,  -1,  19,  20,  21,
       22, -28,  -3,  23,  24, -35,  -2,  25,  26,  -1,  27, -83,  31,  -1,
       32,  33,  -1,  34,  -1, -87,  37,  -1,  38,  -1,  39,  -1,  -1, -40,
       -2, -75,  -1, -45,  -2,  42,  -1,  43,  44, -79,  -1,  -1,  -1,  -1,
       47,  -1,  -1,  48,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ExtInterfaceDef_Perfect_Hash_OpTable tao_CORBA_ExtInterfaceDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA__TAO_ExtInterfaceDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA__TAO_ExtInterfaceDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_ExtInterfaceDef_Proxy_Broker_Factory_function_pointer =
    CORBA__TAO_ExtInterfaceDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA__TAO_ExtInterfaceDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_ExtInterfaceDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA__TAO_ExtInterfaceDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::ExtInterfaceDef::ExtInterfaceDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ExtInterfaceDef_optable;
}

POA_CORBA::ExtInterfaceDef::ExtInterfaceDef (const ExtInterfaceDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Container (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::IDLType (rhs),
    POA_CORBA::InterfaceDef (rhs),
    POA_CORBA::InterfaceAttrExtension (rhs)
{
}

POA_CORBA::ExtInterfaceDef::~ExtInterfaceDef (void)
{
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _is_a_ExtInterfaceDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_ExtInterfaceDef_Upcall_Command (
      POA_CORBA::ExtInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_-> _is_a (
          arg_1);
    }

  private:
    POA_CORBA::ExtInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ExtInterfaceDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::ExtInterfaceDef * const impl =
    static_cast<POA_CORBA::ExtInterfaceDef *> (servant);

  _is_a_ExtInterfaceDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _non_existent_ExtInterfaceDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_ExtInterfaceDef_Upcall_Command (
      POA_CORBA::ExtInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _non_existent ();
    }

  private:
    POA_CORBA::ExtInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ExtInterfaceDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ExtInterfaceDef * const impl =
    static_cast<POA_CORBA::ExtInterfaceDef *> (servant);

  _non_existent_ExtInterfaceDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _repository_id_ExtInterfaceDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_ExtInterfaceDef_Upcall_Command (
      POA_CORBA::ExtInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _repository_id ();
    }

  private:
    POA_CORBA::ExtInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ExtInterfaceDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ExtInterfaceDef * const impl =
    static_cast<POA_CORBA::ExtInterfaceDef *> (servant);

  _repository_id_ExtInterfaceDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::ExtInterfaceDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::ExtInterfaceDef * const impl =
    static_cast<POA_CORBA::ExtInterfaceDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_component_ExtInterfaceDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_ExtInterfaceDef_Upcall_Command (
      POA_CORBA::ExtInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _get_component ();
    }

  private:
    POA_CORBA::ExtInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ExtInterfaceDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ExtInterfaceDef * const impl =
    static_cast<POA_CORBA::ExtInterfaceDef *> (servant);

  _get_component_ExtInterfaceDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::ExtInterfaceDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceAttrExtension:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ExtInterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ExtInterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ExtInterfaceDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::ExtInterfaceDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::ExtInterfaceDef *
POA_CORBA::ExtInterfaceDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::ExtInterfaceDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_ExtInterfaceDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_AbstractInterfaceDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_AbstractInterfaceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_AbstractInterfaceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81,  0,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81,  0,
     81, 30, 20,  0, 81, 81, 81, 10, 81, 81,
     81, 81, 81, 81, 81, 81, 81,  0,  0,  5,
     81,  0, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 20, 35, 81, 81, 81, 10,  5, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81,
#else
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81,  0, 81,  0, 81, 30,
     20,  0, 81, 81, 81, 10, 81, 81,  0,  0,
      5, 81,  0, 81, 81, 20, 35, 81, 81, 81,
     10,  5, 81, 81, 81, 81, 81, 81,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_AbstractInterfaceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 43,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 80,
      HASH_VALUE_RANGE = 77,
      DUPLICATES = 10,
      WORDLIST_SIZE = 47
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::AbstractInterfaceDef::move_skel, 0},
      {"_is_a", &POA_CORBA::AbstractInterfaceDef::_is_a_skel, 0},
      {"lookup", &POA_CORBA::AbstractInterfaceDef::lookup_skel, 0},
      {"_get_name", &POA_CORBA::AbstractInterfaceDef::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::AbstractInterfaceDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::AbstractInterfaceDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::AbstractInterfaceDef::_interface_skel, 0},
      {"lookup_name", &POA_CORBA::AbstractInterfaceDef::lookup_name_skel, 0},
      {"is_a", &POA_CORBA::AbstractInterfaceDef::is_a_skel, 0},
      {"_get_version", &POA_CORBA::AbstractInterfaceDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::AbstractInterfaceDef::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::AbstractInterfaceDef::_get_absolute_name_skel, 0},
      {"_get_defined_in", &POA_CORBA::AbstractInterfaceDef::_get_defined_in_skel, 0},
      {"_get_id", &POA_CORBA::AbstractInterfaceDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::AbstractInterfaceDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::AbstractInterfaceDef::describe_skel, 0},
      {"_get_containing_repository", &POA_CORBA::AbstractInterfaceDef::_get_containing_repository_skel, 0},
      {"destroy", &POA_CORBA::AbstractInterfaceDef::destroy_skel, 0},
      {"_get_def_kind", &POA_CORBA::AbstractInterfaceDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::AbstractInterfaceDef::_repository_id_skel, 0},
      {"describe_interface", &POA_CORBA::AbstractInterfaceDef::describe_interface_skel, 0},
      {"_get_base_interfaces", &POA_CORBA::AbstractInterfaceDef::_get_base_interfaces_skel, 0},
      {"_set_base_interfaces", &POA_CORBA::AbstractInterfaceDef::_set_base_interfaces_skel, 0},
      {"create_enum", &POA_CORBA::AbstractInterfaceDef::create_enum_skel, 0},
      {"create_value", &POA_CORBA::AbstractInterfaceDef::create_value_skel, 0},
      {"create_module", &POA_CORBA::AbstractInterfaceDef::create_module_skel, 0},
      {"create_native", &POA_CORBA::AbstractInterfaceDef::create_native_skel, 0},
      {"_component", &POA_CORBA::AbstractInterfaceDef::_component_skel, 0},
      {"create_interface", &POA_CORBA::AbstractInterfaceDef::create_interface_skel, 0},
      {"create_attribute", &POA_CORBA::AbstractInterfaceDef::create_attribute_skel, 0},
      {"create_ext_value", &POA_CORBA::AbstractInterfaceDef::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::AbstractInterfaceDef::create_union_skel, 0},
      {"_non_existent", &POA_CORBA::AbstractInterfaceDef::_non_existent_skel, 0},
      {"create_exception", &POA_CORBA::AbstractInterfaceDef::create_exception_skel, 0},
      {"create_operation", &POA_CORBA::AbstractInterfaceDef::create_operation_skel, 0},
      {"create_local_interface", &POA_CORBA::AbstractInterfaceDef::create_local_interface_skel, 0},
      {"create_abstract_interface", &POA_CORBA::AbstractInterfaceDef::create_abstract_interface_skel, 0},
      {"create_value_box", &POA_CORBA::AbstractInterfaceDef::create_value_box_skel, 0},
      {"describe_contents", &POA_CORBA::AbstractInterfaceDef::describe_contents_skel, 0},
      {"contents", &POA_CORBA::AbstractInterfaceDef::contents_skel, 0},
      {"create_alias", &POA_CORBA::AbstractInterfaceDef::create_alias_skel, 0},
      {"create_struct", &POA_CORBA::AbstractInterfaceDef::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::AbstractInterfaceDef::create_constant_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,   5,   6,  -7,  -3, -82,  10,  11,  -1,  -1,
       12, -13,  -2, -82,  15,  -1,  16,  -1,  -1, -17,  -2, -25,  -2, -84,
       19, -29,  -2,  20,  21,  22,  23,  -1, -32,  -3,  24,  -1, -95,  27,
       28, -94,  -1,  31, -90,  35,  36, -37,  -2, -82,  39,  -1,  -1,  40,
       41,  42,  43,  -1,  -1,  -1,  44,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  45,  -1,  46,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_AbstractInterfaceDef_Perfect_Hash_OpTable tao_CORBA_AbstractInterfaceDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA__TAO_AbstractInterfaceDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA__TAO_AbstractInterfaceDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_AbstractInterfaceDef_Proxy_Broker_Factory_function_pointer =
    CORBA__TAO_AbstractInterfaceDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA__TAO_AbstractInterfaceDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_AbstractInterfaceDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA__TAO_AbstractInterfaceDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::AbstractInterfaceDef::AbstractInterfaceDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_AbstractInterfaceDef_optable;
}

POA_CORBA::AbstractInterfaceDef::AbstractInterfaceDef (const AbstractInterfaceDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Container (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::IDLType (rhs),
    POA_CORBA::InterfaceDef (rhs)
{
}

POA_CORBA::AbstractInterfaceDef::~AbstractInterfaceDef (void)
{
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _is_a_AbstractInterfaceDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_AbstractInterfaceDef_Upcall_Command (
      POA_CORBA::AbstractInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_-> _is_a (
          arg_1);
    }

  private:
    POA_CORBA::AbstractInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::AbstractInterfaceDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::AbstractInterfaceDef * const impl =
    static_cast<POA_CORBA::AbstractInterfaceDef *> (servant);

  _is_a_AbstractInterfaceDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _non_existent_AbstractInterfaceDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_AbstractInterfaceDef_Upcall_Command (
      POA_CORBA::AbstractInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _non_existent ();
    }

  private:
    POA_CORBA::AbstractInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::AbstractInterfaceDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::AbstractInterfaceDef * const impl =
    static_cast<POA_CORBA::AbstractInterfaceDef *> (servant);

  _non_existent_AbstractInterfaceDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _repository_id_AbstractInterfaceDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_AbstractInterfaceDef_Upcall_Command (
      POA_CORBA::AbstractInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _repository_id ();
    }

  private:
    POA_CORBA::AbstractInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::AbstractInterfaceDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::AbstractInterfaceDef * const impl =
    static_cast<POA_CORBA::AbstractInterfaceDef *> (servant);

  _repository_id_AbstractInterfaceDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::AbstractInterfaceDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::AbstractInterfaceDef * const impl =
    static_cast<POA_CORBA::AbstractInterfaceDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_component_AbstractInterfaceDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_AbstractInterfaceDef_Upcall_Command (
      POA_CORBA::AbstractInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _get_component ();
    }

  private:
    POA_CORBA::AbstractInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::AbstractInterfaceDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::AbstractInterfaceDef * const impl =
    static_cast<POA_CORBA::AbstractInterfaceDef *> (servant);

  _get_component_AbstractInterfaceDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::AbstractInterfaceDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/AbstractInterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::AbstractInterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/AbstractInterfaceDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::AbstractInterfaceDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::AbstractInterfaceDef *
POA_CORBA::AbstractInterfaceDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::AbstractInterfaceDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_AbstractInterfaceDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_ExtAbstractInterfaceDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ExtAbstractInterfaceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ExtAbstractInterfaceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 30,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74,  0,
     74,  0, 20,  0, 74, 74, 74,  5, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 15,  0,  5,
     74, 15, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 15, 30, 74, 74, 74, 15,  5, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74,
#else
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 30, 74,  0, 74,  0,
     20,  0, 74, 74, 74,  5, 74, 74, 15,  0,
      5, 74, 15, 74, 74, 15, 30, 74, 74, 74,
     15,  5, 74, 74, 74, 74, 74, 74,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_ExtAbstractInterfaceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 45,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 73,
      HASH_VALUE_RANGE = 70,
      DUPLICATES = 10,
      WORDLIST_SIZE = 49
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::ExtAbstractInterfaceDef::move_skel, 0},
      {"is_a", &POA_CORBA::ExtAbstractInterfaceDef::is_a_skel, 0},
      {"create_enum", &POA_CORBA::ExtAbstractInterfaceDef::create_enum_skel, 0},
      {"create_value", &POA_CORBA::ExtAbstractInterfaceDef::create_value_skel, 0},
      {"create_module", &POA_CORBA::ExtAbstractInterfaceDef::create_module_skel, 0},
      {"create_native", &POA_CORBA::ExtAbstractInterfaceDef::create_native_skel, 0},
      {"create_interface", &POA_CORBA::ExtAbstractInterfaceDef::create_interface_skel, 0},
      {"create_attribute", &POA_CORBA::ExtAbstractInterfaceDef::create_attribute_skel, 0},
      {"create_ext_value", &POA_CORBA::ExtAbstractInterfaceDef::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::ExtAbstractInterfaceDef::create_union_skel, 0},
      {"create_ext_attribute", &POA_CORBA::ExtAbstractInterfaceDef::create_ext_attribute_skel, 0},
      {"create_exception", &POA_CORBA::ExtAbstractInterfaceDef::create_exception_skel, 0},
      {"create_operation", &POA_CORBA::ExtAbstractInterfaceDef::create_operation_skel, 0},
      {"create_local_interface", &POA_CORBA::ExtAbstractInterfaceDef::create_local_interface_skel, 0},
      {"contents", &POA_CORBA::ExtAbstractInterfaceDef::contents_skel, 0},
      {"create_abstract_interface", &POA_CORBA::ExtAbstractInterfaceDef::create_abstract_interface_skel, 0},
      {"lookup_name", &POA_CORBA::ExtAbstractInterfaceDef::lookup_name_skel, 0},
      {"create_alias", &POA_CORBA::ExtAbstractInterfaceDef::create_alias_skel, 0},
      {"describe", &POA_CORBA::ExtAbstractInterfaceDef::describe_skel, 0},
      {"create_value_box", &POA_CORBA::ExtAbstractInterfaceDef::create_value_box_skel, 0},
      {"destroy", &POA_CORBA::ExtAbstractInterfaceDef::destroy_skel, 0},
      {"_is_a", &POA_CORBA::ExtAbstractInterfaceDef::_is_a_skel, 0},
      {"lookup", &POA_CORBA::ExtAbstractInterfaceDef::lookup_skel, 0},
      {"describe_interface", &POA_CORBA::ExtAbstractInterfaceDef::describe_interface_skel, 0},
      {"_get_name", &POA_CORBA::ExtAbstractInterfaceDef::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::ExtAbstractInterfaceDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::ExtAbstractInterfaceDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::ExtAbstractInterfaceDef::_interface_skel, 0},
      {"describe_ext_interface", &POA_CORBA::ExtAbstractInterfaceDef::describe_ext_interface_skel, 0},
      {"create_struct", &POA_CORBA::ExtAbstractInterfaceDef::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::ExtAbstractInterfaceDef::create_constant_skel, 0},
      {"_get_version", &POA_CORBA::ExtAbstractInterfaceDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::ExtAbstractInterfaceDef::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::ExtAbstractInterfaceDef::_get_absolute_name_skel, 0},
      {"_get_defined_in", &POA_CORBA::ExtAbstractInterfaceDef::_get_defined_in_skel, 0},
      {"describe_contents", &POA_CORBA::ExtAbstractInterfaceDef::describe_contents_skel, 0},
      {"_get_id", &POA_CORBA::ExtAbstractInterfaceDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::ExtAbstractInterfaceDef::_set_id_skel, 0},
      {"_get_containing_repository", &POA_CORBA::ExtAbstractInterfaceDef::_get_containing_repository_skel, 0},
      {"_get_def_kind", &POA_CORBA::ExtAbstractInterfaceDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::ExtAbstractInterfaceDef::_repository_id_skel, 0},
      {"_get_base_interfaces", &POA_CORBA::ExtAbstractInterfaceDef::_get_base_interfaces_skel, 0},
      {"_set_base_interfaces", &POA_CORBA::ExtAbstractInterfaceDef::_set_base_interfaces_skel, 0},
      {"_component", &POA_CORBA::ExtAbstractInterfaceDef::_component_skel, 0},
      {"_non_existent", &POA_CORBA::ExtAbstractInterfaceDef::_non_existent_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,  -1,  -1,  -8,  -2,   5,  -1,   6,   7, -79,
      -10,  -3, -75,  13, -15,  -2,  14, -76,  17,  18,  -1,  19,  20,  21,
       22, -28,  -3,  23,  24, -35,  -2,  25,  26,  -1,  27, -83,  31,  -1,
       32,  33,  -1,  34,  -1, -87,  37,  -1,  38,  -1,  39,  -1,  -1, -40,
       -2, -75,  -1, -45,  -2,  42,  -1,  43,  44, -79,  -1,  -1,  -1,  -1,
       47,  -1,  -1,  48,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ExtAbstractInterfaceDef_Perfect_Hash_OpTable tao_CORBA_ExtAbstractInterfaceDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA__TAO_ExtAbstractInterfaceDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA__TAO_ExtAbstractInterfaceDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_ExtAbstractInterfaceDef_Proxy_Broker_Factory_function_pointer =
    CORBA__TAO_ExtAbstractInterfaceDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA__TAO_ExtAbstractInterfaceDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_ExtAbstractInterfaceDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA__TAO_ExtAbstractInterfaceDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::ExtAbstractInterfaceDef::ExtAbstractInterfaceDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ExtAbstractInterfaceDef_optable;
}

POA_CORBA::ExtAbstractInterfaceDef::ExtAbstractInterfaceDef (const ExtAbstractInterfaceDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Container (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::IDLType (rhs),
    POA_CORBA::InterfaceDef (rhs),
    POA_CORBA::AbstractInterfaceDef (rhs),
    POA_CORBA::InterfaceAttrExtension (rhs)
{
}

POA_CORBA::ExtAbstractInterfaceDef::~ExtAbstractInterfaceDef (void)
{
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _is_a_ExtAbstractInterfaceDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_ExtAbstractInterfaceDef_Upcall_Command (
      POA_CORBA::ExtAbstractInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_-> _is_a (
          arg_1);
    }

  private:
    POA_CORBA::ExtAbstractInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ExtAbstractInterfaceDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::ExtAbstractInterfaceDef * const impl =
    static_cast<POA_CORBA::ExtAbstractInterfaceDef *> (servant);

  _is_a_ExtAbstractInterfaceDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _non_existent_ExtAbstractInterfaceDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_ExtAbstractInterfaceDef_Upcall_Command (
      POA_CORBA::ExtAbstractInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _non_existent ();
    }

  private:
    POA_CORBA::ExtAbstractInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ExtAbstractInterfaceDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ExtAbstractInterfaceDef * const impl =
    static_cast<POA_CORBA::ExtAbstractInterfaceDef *> (servant);

  _non_existent_ExtAbstractInterfaceDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _repository_id_ExtAbstractInterfaceDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_ExtAbstractInterfaceDef_Upcall_Command (
      POA_CORBA::ExtAbstractInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _repository_id ();
    }

  private:
    POA_CORBA::ExtAbstractInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ExtAbstractInterfaceDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ExtAbstractInterfaceDef * const impl =
    static_cast<POA_CORBA::ExtAbstractInterfaceDef *> (servant);

  _repository_id_ExtAbstractInterfaceDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::ExtAbstractInterfaceDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::ExtAbstractInterfaceDef * const impl =
    static_cast<POA_CORBA::ExtAbstractInterfaceDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_component_ExtAbstractInterfaceDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_ExtAbstractInterfaceDef_Upcall_Command (
      POA_CORBA::ExtAbstractInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _get_component ();
    }

  private:
    POA_CORBA::ExtAbstractInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ExtAbstractInterfaceDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ExtAbstractInterfaceDef * const impl =
    static_cast<POA_CORBA::ExtAbstractInterfaceDef *> (servant);

  _get_component_ExtAbstractInterfaceDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::ExtAbstractInterfaceDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/AbstractInterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceAttrExtension:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ExtAbstractInterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ExtAbstractInterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ExtAbstractInterfaceDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::ExtAbstractInterfaceDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::ExtAbstractInterfaceDef *
POA_CORBA::ExtAbstractInterfaceDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::ExtAbstractInterfaceDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_ExtAbstractInterfaceDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_LocalInterfaceDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_LocalInterfaceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_LocalInterfaceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81,  0,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81,  0,
     81, 30, 20,  0, 81, 81, 81, 10, 81, 81,
     81, 81, 81, 81, 81, 81, 81,  0,  0,  5,
     81,  0, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 20, 35, 81, 81, 81, 10,  5, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81,
#else
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81,  0, 81,  0, 81, 30,
     20,  0, 81, 81, 81, 10, 81, 81,  0,  0,
      5, 81,  0, 81, 81, 20, 35, 81, 81, 81,
     10,  5, 81, 81, 81, 81, 81, 81,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_LocalInterfaceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 43,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 80,
      HASH_VALUE_RANGE = 77,
      DUPLICATES = 10,
      WORDLIST_SIZE = 47
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::LocalInterfaceDef::move_skel, 0},
      {"_is_a", &POA_CORBA::LocalInterfaceDef::_is_a_skel, 0},
      {"lookup", &POA_CORBA::LocalInterfaceDef::lookup_skel, 0},
      {"_get_name", &POA_CORBA::LocalInterfaceDef::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::LocalInterfaceDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::LocalInterfaceDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::LocalInterfaceDef::_interface_skel, 0},
      {"lookup_name", &POA_CORBA::LocalInterfaceDef::lookup_name_skel, 0},
      {"is_a", &POA_CORBA::LocalInterfaceDef::is_a_skel, 0},
      {"_get_version", &POA_CORBA::LocalInterfaceDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::LocalInterfaceDef::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::LocalInterfaceDef::_get_absolute_name_skel, 0},
      {"_get_defined_in", &POA_CORBA::LocalInterfaceDef::_get_defined_in_skel, 0},
      {"_get_id", &POA_CORBA::LocalInterfaceDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::LocalInterfaceDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::LocalInterfaceDef::describe_skel, 0},
      {"_get_containing_repository", &POA_CORBA::LocalInterfaceDef::_get_containing_repository_skel, 0},
      {"destroy", &POA_CORBA::LocalInterfaceDef::destroy_skel, 0},
      {"_get_def_kind", &POA_CORBA::LocalInterfaceDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::LocalInterfaceDef::_repository_id_skel, 0},
      {"describe_interface", &POA_CORBA::LocalInterfaceDef::describe_interface_skel, 0},
      {"_get_base_interfaces", &POA_CORBA::LocalInterfaceDef::_get_base_interfaces_skel, 0},
      {"_set_base_interfaces", &POA_CORBA::LocalInterfaceDef::_set_base_interfaces_skel, 0},
      {"create_enum", &POA_CORBA::LocalInterfaceDef::create_enum_skel, 0},
      {"create_value", &POA_CORBA::LocalInterfaceDef::create_value_skel, 0},
      {"create_module", &POA_CORBA::LocalInterfaceDef::create_module_skel, 0},
      {"create_native", &POA_CORBA::LocalInterfaceDef::create_native_skel, 0},
      {"_component", &POA_CORBA::LocalInterfaceDef::_component_skel, 0},
      {"create_interface", &POA_CORBA::LocalInterfaceDef::create_interface_skel, 0},
      {"create_attribute", &POA_CORBA::LocalInterfaceDef::create_attribute_skel, 0},
      {"create_ext_value", &POA_CORBA::LocalInterfaceDef::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::LocalInterfaceDef::create_union_skel, 0},
      {"_non_existent", &POA_CORBA::LocalInterfaceDef::_non_existent_skel, 0},
      {"create_exception", &POA_CORBA::LocalInterfaceDef::create_exception_skel, 0},
      {"create_operation", &POA_CORBA::LocalInterfaceDef::create_operation_skel, 0},
      {"create_local_interface", &POA_CORBA::LocalInterfaceDef::create_local_interface_skel, 0},
      {"create_abstract_interface", &POA_CORBA::LocalInterfaceDef::create_abstract_interface_skel, 0},
      {"create_value_box", &POA_CORBA::LocalInterfaceDef::create_value_box_skel, 0},
      {"describe_contents", &POA_CORBA::LocalInterfaceDef::describe_contents_skel, 0},
      {"contents", &POA_CORBA::LocalInterfaceDef::contents_skel, 0},
      {"create_alias", &POA_CORBA::LocalInterfaceDef::create_alias_skel, 0},
      {"create_struct", &POA_CORBA::LocalInterfaceDef::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::LocalInterfaceDef::create_constant_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,   5,   6,  -7,  -3, -82,  10,  11,  -1,  -1,
       12, -13,  -2, -82,  15,  -1,  16,  -1,  -1, -17,  -2, -25,  -2, -84,
       19, -29,  -2,  20,  21,  22,  23,  -1, -32,  -3,  24,  -1, -95,  27,
       28, -94,  -1,  31, -90,  35,  36, -37,  -2, -82,  39,  -1,  -1,  40,
       41,  42,  43,  -1,  -1,  -1,  44,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  45,  -1,  46,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_LocalInterfaceDef_Perfect_Hash_OpTable tao_CORBA_LocalInterfaceDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA__TAO_LocalInterfaceDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA__TAO_LocalInterfaceDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_LocalInterfaceDef_Proxy_Broker_Factory_function_pointer =
    CORBA__TAO_LocalInterfaceDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA__TAO_LocalInterfaceDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_LocalInterfaceDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA__TAO_LocalInterfaceDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::LocalInterfaceDef::LocalInterfaceDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_LocalInterfaceDef_optable;
}

POA_CORBA::LocalInterfaceDef::LocalInterfaceDef (const LocalInterfaceDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Container (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::IDLType (rhs),
    POA_CORBA::InterfaceDef (rhs)
{
}

POA_CORBA::LocalInterfaceDef::~LocalInterfaceDef (void)
{
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _is_a_LocalInterfaceDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_LocalInterfaceDef_Upcall_Command (
      POA_CORBA::LocalInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_-> _is_a (
          arg_1);
    }

  private:
    POA_CORBA::LocalInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::LocalInterfaceDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::LocalInterfaceDef * const impl =
    static_cast<POA_CORBA::LocalInterfaceDef *> (servant);

  _is_a_LocalInterfaceDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _non_existent_LocalInterfaceDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_LocalInterfaceDef_Upcall_Command (
      POA_CORBA::LocalInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _non_existent ();
    }

  private:
    POA_CORBA::LocalInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::LocalInterfaceDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::LocalInterfaceDef * const impl =
    static_cast<POA_CORBA::LocalInterfaceDef *> (servant);

  _non_existent_LocalInterfaceDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _repository_id_LocalInterfaceDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_LocalInterfaceDef_Upcall_Command (
      POA_CORBA::LocalInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _repository_id ();
    }

  private:
    POA_CORBA::LocalInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::LocalInterfaceDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::LocalInterfaceDef * const impl =
    static_cast<POA_CORBA::LocalInterfaceDef *> (servant);

  _repository_id_LocalInterfaceDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::LocalInterfaceDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::LocalInterfaceDef * const impl =
    static_cast<POA_CORBA::LocalInterfaceDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_component_LocalInterfaceDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_LocalInterfaceDef_Upcall_Command (
      POA_CORBA::LocalInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _get_component ();
    }

  private:
    POA_CORBA::LocalInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::LocalInterfaceDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::LocalInterfaceDef * const impl =
    static_cast<POA_CORBA::LocalInterfaceDef *> (servant);

  _get_component_LocalInterfaceDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::LocalInterfaceDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalInterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::LocalInterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/LocalInterfaceDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::LocalInterfaceDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::LocalInterfaceDef *
POA_CORBA::LocalInterfaceDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::LocalInterfaceDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_LocalInterfaceDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_ExtLocalInterfaceDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ExtLocalInterfaceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ExtLocalInterfaceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 30,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74,  0,
     74,  0, 20,  0, 74, 74, 74,  5, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 15,  0,  5,
     74, 15, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 15, 30, 74, 74, 74, 15,  5, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74,
#else
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 30, 74,  0, 74,  0,
     20,  0, 74, 74, 74,  5, 74, 74, 15,  0,
      5, 74, 15, 74, 74, 15, 30, 74, 74, 74,
     15,  5, 74, 74, 74, 74, 74, 74,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_ExtLocalInterfaceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 45,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 73,
      HASH_VALUE_RANGE = 70,
      DUPLICATES = 10,
      WORDLIST_SIZE = 49
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::ExtLocalInterfaceDef::move_skel, 0},
      {"is_a", &POA_CORBA::ExtLocalInterfaceDef::is_a_skel, 0},
      {"create_enum", &POA_CORBA::ExtLocalInterfaceDef::create_enum_skel, 0},
      {"create_value", &POA_CORBA::ExtLocalInterfaceDef::create_value_skel, 0},
      {"create_module", &POA_CORBA::ExtLocalInterfaceDef::create_module_skel, 0},
      {"create_native", &POA_CORBA::ExtLocalInterfaceDef::create_native_skel, 0},
      {"create_interface", &POA_CORBA::ExtLocalInterfaceDef::create_interface_skel, 0},
      {"create_attribute", &POA_CORBA::ExtLocalInterfaceDef::create_attribute_skel, 0},
      {"create_ext_value", &POA_CORBA::ExtLocalInterfaceDef::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::ExtLocalInterfaceDef::create_union_skel, 0},
      {"create_ext_attribute", &POA_CORBA::ExtLocalInterfaceDef::create_ext_attribute_skel, 0},
      {"create_exception", &POA_CORBA::ExtLocalInterfaceDef::create_exception_skel, 0},
      {"create_operation", &POA_CORBA::ExtLocalInterfaceDef::create_operation_skel, 0},
      {"create_local_interface", &POA_CORBA::ExtLocalInterfaceDef::create_local_interface_skel, 0},
      {"contents", &POA_CORBA::ExtLocalInterfaceDef::contents_skel, 0},
      {"create_abstract_interface", &POA_CORBA::ExtLocalInterfaceDef::create_abstract_interface_skel, 0},
      {"lookup_name", &POA_CORBA::ExtLocalInterfaceDef::lookup_name_skel, 0},
      {"create_alias", &POA_CORBA::ExtLocalInterfaceDef::create_alias_skel, 0},
      {"describe", &POA_CORBA::ExtLocalInterfaceDef::describe_skel, 0},
      {"create_value_box", &POA_CORBA::ExtLocalInterfaceDef::create_value_box_skel, 0},
      {"destroy", &POA_CORBA::ExtLocalInterfaceDef::destroy_skel, 0},
      {"_is_a", &POA_CORBA::ExtLocalInterfaceDef::_is_a_skel, 0},
      {"lookup", &POA_CORBA::ExtLocalInterfaceDef::lookup_skel, 0},
      {"describe_interface", &POA_CORBA::ExtLocalInterfaceDef::describe_interface_skel, 0},
      {"_get_name", &POA_CORBA::ExtLocalInterfaceDef::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::ExtLocalInterfaceDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::ExtLocalInterfaceDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::ExtLocalInterfaceDef::_interface_skel, 0},
      {"describe_ext_interface", &POA_CORBA::ExtLocalInterfaceDef::describe_ext_interface_skel, 0},
      {"create_struct", &POA_CORBA::ExtLocalInterfaceDef::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::ExtLocalInterfaceDef::create_constant_skel, 0},
      {"_get_version", &POA_CORBA::ExtLocalInterfaceDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::ExtLocalInterfaceDef::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::ExtLocalInterfaceDef::_get_absolute_name_skel, 0},
      {"_get_defined_in", &POA_CORBA::ExtLocalInterfaceDef::_get_defined_in_skel, 0},
      {"describe_contents", &POA_CORBA::ExtLocalInterfaceDef::describe_contents_skel, 0},
      {"_get_id", &POA_CORBA::ExtLocalInterfaceDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::ExtLocalInterfaceDef::_set_id_skel, 0},
      {"_get_containing_repository", &POA_CORBA::ExtLocalInterfaceDef::_get_containing_repository_skel, 0},
      {"_get_def_kind", &POA_CORBA::ExtLocalInterfaceDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::ExtLocalInterfaceDef::_repository_id_skel, 0},
      {"_get_base_interfaces", &POA_CORBA::ExtLocalInterfaceDef::_get_base_interfaces_skel, 0},
      {"_set_base_interfaces", &POA_CORBA::ExtLocalInterfaceDef::_set_base_interfaces_skel, 0},
      {"_component", &POA_CORBA::ExtLocalInterfaceDef::_component_skel, 0},
      {"_non_existent", &POA_CORBA::ExtLocalInterfaceDef::_non_existent_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,  -1,  -1,  -8,  -2,   5,  -1,   6,   7, -79,
      -10,  -3, -75,  13, -15,  -2,  14, -76,  17,  18,  -1,  19,  20,  21,
       22, -28,  -3,  23,  24, -35,  -2,  25,  26,  -1,  27, -83,  31,  -1,
       32,  33,  -1,  34,  -1, -87,  37,  -1,  38,  -1,  39,  -1,  -1, -40,
       -2, -75,  -1, -45,  -2,  42,  -1,  43,  44, -79,  -1,  -1,  -1,  -1,
       47,  -1,  -1,  48,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ExtLocalInterfaceDef_Perfect_Hash_OpTable tao_CORBA_ExtLocalInterfaceDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA__TAO_ExtLocalInterfaceDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA__TAO_ExtLocalInterfaceDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_ExtLocalInterfaceDef_Proxy_Broker_Factory_function_pointer =
    CORBA__TAO_ExtLocalInterfaceDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA__TAO_ExtLocalInterfaceDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_ExtLocalInterfaceDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA__TAO_ExtLocalInterfaceDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::ExtLocalInterfaceDef::ExtLocalInterfaceDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ExtLocalInterfaceDef_optable;
}

POA_CORBA::ExtLocalInterfaceDef::ExtLocalInterfaceDef (const ExtLocalInterfaceDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Container (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::IDLType (rhs),
    POA_CORBA::InterfaceDef (rhs),
    POA_CORBA::LocalInterfaceDef (rhs),
    POA_CORBA::InterfaceAttrExtension (rhs)
{
}

POA_CORBA::ExtLocalInterfaceDef::~ExtLocalInterfaceDef (void)
{
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _is_a_ExtLocalInterfaceDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_ExtLocalInterfaceDef_Upcall_Command (
      POA_CORBA::ExtLocalInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_-> _is_a (
          arg_1);
    }

  private:
    POA_CORBA::ExtLocalInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ExtLocalInterfaceDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::ExtLocalInterfaceDef * const impl =
    static_cast<POA_CORBA::ExtLocalInterfaceDef *> (servant);

  _is_a_ExtLocalInterfaceDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _non_existent_ExtLocalInterfaceDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_ExtLocalInterfaceDef_Upcall_Command (
      POA_CORBA::ExtLocalInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _non_existent ();
    }

  private:
    POA_CORBA::ExtLocalInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ExtLocalInterfaceDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ExtLocalInterfaceDef * const impl =
    static_cast<POA_CORBA::ExtLocalInterfaceDef *> (servant);

  _non_existent_ExtLocalInterfaceDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _repository_id_ExtLocalInterfaceDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_ExtLocalInterfaceDef_Upcall_Command (
      POA_CORBA::ExtLocalInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _repository_id ();
    }

  private:
    POA_CORBA::ExtLocalInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ExtLocalInterfaceDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ExtLocalInterfaceDef * const impl =
    static_cast<POA_CORBA::ExtLocalInterfaceDef *> (servant);

  _repository_id_ExtLocalInterfaceDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::ExtLocalInterfaceDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::ExtLocalInterfaceDef * const impl =
    static_cast<POA_CORBA::ExtLocalInterfaceDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_component_ExtLocalInterfaceDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_ExtLocalInterfaceDef_Upcall_Command (
      POA_CORBA::ExtLocalInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _get_component ();
    }

  private:
    POA_CORBA::ExtLocalInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::ExtLocalInterfaceDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ExtLocalInterfaceDef * const impl =
    static_cast<POA_CORBA::ExtLocalInterfaceDef *> (servant);

  _get_component_ExtLocalInterfaceDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::ExtLocalInterfaceDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalInterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceAttrExtension:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ExtLocalInterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ExtLocalInterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ExtLocalInterfaceDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::ExtLocalInterfaceDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::ExtLocalInterfaceDef *
POA_CORBA::ExtLocalInterfaceDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::ExtLocalInterfaceDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_ExtLocalInterfaceDef_Proxy_Broker_Factory_function_pointer
      );
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* ifndef */

