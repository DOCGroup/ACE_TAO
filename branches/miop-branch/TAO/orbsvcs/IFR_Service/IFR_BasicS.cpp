// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#ifndef _TAO_IDL__________ORBSVCS_IFR_SERVICE_ORIG_IFR_BASICS_CPP_
#define _TAO_IDL__________ORBSVCS_IFR_SERVICE_ORIG_IFR_BASICS_CPP_

#include "IFR_BasicS.h"

#include "tao/PortableServer/Object_Adapter.h"
#include "tao/PortableServer/Operation_Table.h"
#include "tao/TAO_Server_Request.h"
#include "tao/ORB_Core.h"
#include "tao/Stub.h"
#include "tao/IFR_Client_Adapter.h"
#include "tao/PortableInterceptor.h"

#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#include "tao/PortableServer/ServerRequestInfo.h"
#include "tao/PortableServer/ServerInterceptorAdapter.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */

#include "ace/Dynamic_Service.h"
#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "IFR_BasicS.i"
#endif /* !defined INLINE */

class TAO_CORBA_Repository_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:45:25 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_Repository_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_Repository_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 30,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52,  5,
     52,  0,  4, 10, 52,  5, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52,  8, 25, 15,
     52,  0, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 30,  0, 52, 52, 52, 25,  0, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52,
#else
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 30, 52,  5, 52,  0,
      4, 10, 52,  5, 52, 52, 52, 52,  8, 25,
     15, 52,  0, 52, 52, 30,  0, 52, 52, 52,
     25,  0, 52, 52, 52, 52, 52, 52,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_Repository_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 30,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 25,
      MIN_HASH_VALUE = 11,
      MAX_HASH_VALUE = 51,
      HASH_VALUE_RANGE = 41,
      DUPLICATES = 2,
      WORDLIST_SIZE = 41
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},{"",0},{"",0},{"",0},{"",0},
      {"",0},{"",0},
      {"destroy",       &POA_CORBA_Repository::destroy_skel},
      {"create_array",  &POA_CORBA_Repository::create_array_skel},
      {"create_struct",         &POA_CORBA_Repository::create_struct_skel},
      {"lookup",        &POA_CORBA_Repository::lookup_skel},
      {"create_constant",       &POA_CORBA_Repository::create_constant_skel},
      {"create_fixed",  &POA_CORBA_Repository::create_fixed_skel},
      {"create_string",         &POA_CORBA_Repository::create_string_skel},
      {"create_wstring",        &POA_CORBA_Repository::create_wstring_skel},
      {"lookup_id",     &POA_CORBA_Repository::lookup_id_skel},
      {"create_value",  &POA_CORBA_Repository::create_value_skel},
      {"create_module",         &POA_CORBA_Repository::create_module_skel},
      {"create_native",         &POA_CORBA_Repository::create_native_skel},
      {"create_sequence",       &POA_CORBA_Repository::create_sequence_skel},
      {"create_interface",      &POA_CORBA_Repository::create_interface_skel},
      {"create_union",  &POA_CORBA_Repository::create_union_skel},
      {"get_primitive",         &POA_CORBA_Repository::get_primitive_skel},
      {"lookup_name",   &POA_CORBA_Repository::lookup_name_skel},
      {"create_exception",      &POA_CORBA_Repository::create_exception_skel},
      {"create_local_interface",        &POA_CORBA_Repository::create_local_interface_skel},
      {"create_abstract_interface",     &POA_CORBA_Repository::create_abstract_interface_skel},
      {"create_enum",   &POA_CORBA_Repository::create_enum_skel},
      {"get_canonical_typecode",        &POA_CORBA_Repository::get_canonical_typecode_skel},
      {"contents",      &POA_CORBA_Repository::contents_skel},
      {"_is_a",  &POA_CORBA_Repository::_is_a_skel},
      {"create_value_box",      &POA_CORBA_Repository::create_value_box_skel},
      {"create_alias",  &POA_CORBA_Repository::create_alias_skel},
      {"_non_existent",  &POA_CORBA_Repository::_non_existent_skel},
      {"_get_def_kind",         &POA_CORBA_Repository::_get_def_kind_skel},
      {"_interface",  &POA_CORBA_Repository::_interface_skel},
      {"describe_contents",     &POA_CORBA_Repository::describe_contents_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -21,  -2,  11,  12,  13,
       14,  15,  16,  -1,  17,  18,  -1,  19,  20, -65,  -1,  23,  24,  25,
       26,  27,  -1,  28,  29,  -1,  -1,  30,  31,  32,  33,  -1,  34,  35,
       36,  37,  -1,  -1,  -1,  38,  -1,  -1,  39,  40,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:45:25 */
static TAO_CORBA_Repository_Perfect_Hash_OpTable tao_CORBA_Repository_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_CORBA_Repository_lookup_id : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Repository_lookup_id (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Repository *tao_impl
    ,
    const char * search_id
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_Contained_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Repository_lookup_id (const TAO_ServerRequestInfo_CORBA_Repository_lookup_id &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Repository_lookup_id &);

private:
  POA_CORBA_Repository *_tao_impl;
  const char * search_id_;
  CORBA_Contained_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Repository_lookup_id::TAO_ServerRequestInfo_CORBA_Repository_lookup_id (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Repository *tao_impl,
    const char * search_id
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    search_id_ (search_id)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Repository_lookup_id::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= search_id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Repository_lookup_id::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Repository_lookup_id::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Repository_lookup_id::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Repository_lookup_id::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Repository_lookup_id::result (CORBA_Contained_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Repository_get_canonical_typecode : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Repository_get_canonical_typecode (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Repository *tao_impl
    ,
    CORBA::TypeCode_ptr tc
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::TypeCode_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Repository_get_canonical_typecode (const TAO_ServerRequestInfo_CORBA_Repository_get_canonical_typecode &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Repository_get_canonical_typecode &);

private:
  POA_CORBA_Repository *_tao_impl;
  CORBA::TypeCode_ptr tc_;
  CORBA::TypeCode_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Repository_get_canonical_typecode::TAO_ServerRequestInfo_CORBA_Repository_get_canonical_typecode (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Repository *tao_impl,
    CORBA::TypeCode_ptr tc
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    tc_ (tc)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Repository_get_canonical_typecode::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= tc_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Repository_get_canonical_typecode::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Repository_get_canonical_typecode::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Repository_get_canonical_typecode::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Repository_get_canonical_typecode::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Repository_get_canonical_typecode::result (CORBA::TypeCode_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Repository_get_primitive : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Repository_get_primitive (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Repository *tao_impl
    ,
    CORBA::PrimitiveKind & kind
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_PrimitiveDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Repository_get_primitive (const TAO_ServerRequestInfo_CORBA_Repository_get_primitive &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Repository_get_primitive &);

private:
  POA_CORBA_Repository *_tao_impl;
  const CORBA::PrimitiveKind & kind_;
  CORBA_PrimitiveDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Repository_get_primitive::TAO_ServerRequestInfo_CORBA_Repository_get_primitive (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Repository *tao_impl,
    CORBA::PrimitiveKind & kind
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    kind_ (kind)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Repository_get_primitive::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->kind_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Repository_get_primitive::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Repository_get_primitive::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Repository_get_primitive::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Repository_get_primitive::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Repository_get_primitive::result (CORBA_PrimitiveDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Repository_create_string : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Repository_create_string (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Repository *tao_impl
    ,
    const CORBA::ULong & bound
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_StringDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Repository_create_string (const TAO_ServerRequestInfo_CORBA_Repository_create_string &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Repository_create_string &);

private:
  POA_CORBA_Repository *_tao_impl;
  const CORBA::ULong & bound_;
  CORBA_StringDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Repository_create_string::TAO_ServerRequestInfo_CORBA_Repository_create_string (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Repository *tao_impl,
    const CORBA::ULong & bound
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    bound_ (bound)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Repository_create_string::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= bound_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Repository_create_string::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Repository_create_string::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Repository_create_string::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Repository_create_string::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Repository_create_string::result (CORBA_StringDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Repository_create_wstring : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Repository_create_wstring (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Repository *tao_impl
    ,
    const CORBA::ULong & bound
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_WstringDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Repository_create_wstring (const TAO_ServerRequestInfo_CORBA_Repository_create_wstring &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Repository_create_wstring &);

private:
  POA_CORBA_Repository *_tao_impl;
  const CORBA::ULong & bound_;
  CORBA_WstringDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Repository_create_wstring::TAO_ServerRequestInfo_CORBA_Repository_create_wstring (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Repository *tao_impl,
    const CORBA::ULong & bound
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    bound_ (bound)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Repository_create_wstring::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= bound_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Repository_create_wstring::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Repository_create_wstring::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Repository_create_wstring::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Repository_create_wstring::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Repository_create_wstring::result (CORBA_WstringDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Repository_create_sequence : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Repository_create_sequence (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Repository *tao_impl
    ,
    const CORBA::ULong & bound,
    CORBA_IDLType_ptr element_type
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_SequenceDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Repository_create_sequence (const TAO_ServerRequestInfo_CORBA_Repository_create_sequence &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Repository_create_sequence &);

private:
  POA_CORBA_Repository *_tao_impl;
  const CORBA::ULong & bound_;
  CORBA_IDLType_ptr element_type_;
  CORBA_SequenceDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Repository_create_sequence::TAO_ServerRequestInfo_CORBA_Repository_create_sequence (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Repository *tao_impl,
    const CORBA::ULong & bound,
    CORBA_IDLType_ptr element_type
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    bound_ (bound),
    element_type_ (element_type)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Repository_create_sequence::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (2);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= bound_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->element_type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Repository_create_sequence::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Repository_create_sequence::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Repository_create_sequence::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Repository_create_sequence::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Repository_create_sequence::result (CORBA_SequenceDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Repository_create_array : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Repository_create_array (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Repository *tao_impl
    ,
    const CORBA::ULong & length,
    CORBA_IDLType_ptr element_type
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_ArrayDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Repository_create_array (const TAO_ServerRequestInfo_CORBA_Repository_create_array &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Repository_create_array &);

private:
  POA_CORBA_Repository *_tao_impl;
  const CORBA::ULong & length_;
  CORBA_IDLType_ptr element_type_;
  CORBA_ArrayDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Repository_create_array::TAO_ServerRequestInfo_CORBA_Repository_create_array (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Repository *tao_impl,
    const CORBA::ULong & length,
    CORBA_IDLType_ptr element_type
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    length_ (length),
    element_type_ (element_type)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Repository_create_array::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (2);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= length_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->element_type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Repository_create_array::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Repository_create_array::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Repository_create_array::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Repository_create_array::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Repository_create_array::result (CORBA_ArrayDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Repository_create_fixed : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Repository_create_fixed (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Repository *tao_impl
    ,
    const CORBA::UShort & digits,
    const CORBA::Short & scale
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_FixedDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Repository_create_fixed (const TAO_ServerRequestInfo_CORBA_Repository_create_fixed &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Repository_create_fixed &);

private:
  POA_CORBA_Repository *_tao_impl;
  const CORBA::UShort & digits_;
  const CORBA::Short & scale_;
  CORBA_FixedDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Repository_create_fixed::TAO_ServerRequestInfo_CORBA_Repository_create_fixed (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Repository *tao_impl,
    const CORBA::UShort & digits,
    const CORBA::Short & scale
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    digits_ (digits),
    scale_ (scale)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Repository_create_fixed::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (2);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= digits_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= scale_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Repository_create_fixed::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Repository_create_fixed::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Repository_create_fixed::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Repository_create_fixed::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Repository_create_fixed::result (CORBA_FixedDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
_TAO_CORBA_Repository_Strategized_Proxy_Broker *_TAO_CORBA_Repository_Strategized_Proxy_Broker::the_TAO_CORBA_Repository_Strategized_Proxy_Broker (void)
{
  static _TAO_CORBA_Repository_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_CORBA_Repository_Strategized_Proxy_Broker::_TAO_CORBA_Repository_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

_TAO_CORBA_Repository_Strategized_Proxy_Broker::~_TAO_CORBA_Repository_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_CORBA_Repository_Proxy_Impl&
_TAO_CORBA_Repository_Strategized_Proxy_Broker::select_proxy (
    ::CORBA_Repository *object
    TAO_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
_TAO_CORBA_Repository_Strategized_Proxy_Broker::create_proxy (
    int strategy
    TAO_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_CORBA_Repository_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_CORBA_Repository_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_CORBA_Repository_Proxy_Broker *
_TAO_CORBA_Repository_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::_TAO_CORBA_Repository_Strategized_Proxy_Broker::the_TAO_CORBA_Repository_Strategized_Proxy_Broker();
}

int
_TAO_CORBA_Repository_Proxy_Broker_Factory_Initializer (long)
{
  _TAO_CORBA_Repository_Proxy_Broker_Factory_function_pointer =
    _TAO_CORBA_Repository_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_CORBA_Repository_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_CORBA_Repository_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_CORBA_Repository_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

_TAO_CORBA_Repository_ThruPOA_Proxy_Impl::_TAO_CORBA_Repository_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA_Contained_ptr _TAO_CORBA_Repository_ThruPOA_Proxy_Impl::lookup_id (
    CORBA_Object *_collocated_tao_target_,
    const char * search_id
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_Contained_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "lookup_id",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Repository:1.0"
        )
    )->lookup_id (
        search_id
        TAO_ENV_ARG_PARAMETER
      );
}

CORBA::TypeCode_ptr _TAO_CORBA_Repository_ThruPOA_Proxy_Impl::get_canonical_typecode (
    CORBA_Object *_collocated_tao_target_,
    CORBA::TypeCode_ptr tc
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "get_canonical_typecode",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Repository:1.0"
        )
    )->get_canonical_typecode (
        tc
        TAO_ENV_ARG_PARAMETER
      );
}

CORBA_PrimitiveDef_ptr _TAO_CORBA_Repository_ThruPOA_Proxy_Impl::get_primitive (
    CORBA_Object *_collocated_tao_target_,
    CORBA::PrimitiveKind kind
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_PrimitiveDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "get_primitive",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Repository:1.0"
        )
    )->get_primitive (
        kind
        TAO_ENV_ARG_PARAMETER
      );
}

CORBA_StringDef_ptr _TAO_CORBA_Repository_ThruPOA_Proxy_Impl::create_string (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong bound
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_StringDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_string",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Repository:1.0"
        )
    )->create_string (
        bound
        TAO_ENV_ARG_PARAMETER
      );
}

CORBA_WstringDef_ptr _TAO_CORBA_Repository_ThruPOA_Proxy_Impl::create_wstring (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong bound
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_WstringDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_wstring",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Repository:1.0"
        )
    )->create_wstring (
        bound
        TAO_ENV_ARG_PARAMETER
      );
}

CORBA_SequenceDef_ptr _TAO_CORBA_Repository_ThruPOA_Proxy_Impl::create_sequence (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong bound,
    CORBA_IDLType_ptr element_type
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_SequenceDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_sequence",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Repository:1.0"
        )
    )->create_sequence (
        bound,
        element_type
        TAO_ENV_ARG_PARAMETER
      );
}

CORBA_ArrayDef_ptr _TAO_CORBA_Repository_ThruPOA_Proxy_Impl::create_array (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong length,
    CORBA_IDLType_ptr element_type
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_ArrayDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_array",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Repository:1.0"
        )
    )->create_array (
        length,
        element_type
        TAO_ENV_ARG_PARAMETER
      );
}

CORBA_FixedDef_ptr _TAO_CORBA_Repository_ThruPOA_Proxy_Impl::create_fixed (
    CORBA_Object *_collocated_tao_target_,
    CORBA::UShort digits,
    CORBA::Short scale
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_FixedDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_fixed",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Repository:1.0"
        )
    )->create_fixed (
        digits,
        scale
        TAO_ENV_ARG_PARAMETER
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA_Repository::POA_CORBA_Repository (void)
{
  this->optable_ = &tao_CORBA_Repository_optable;
}

// copy ctor
POA_CORBA_Repository::POA_CORBA_Repository (const POA_CORBA_Repository& rhs)
  :   POA_CORBA_Container (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA_Repository::~POA_CORBA_Repository (void)
{
}

void POA_CORBA_Repository::lookup_id_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Repository *_tao_impl =
    ACE_static_cast (POA_CORBA_Repository *, _tao_object_reference);

    CORBA_Contained_var _tao_retval;
  CORBA::String_var search_id;
  if (!(
    (_tao_in >> search_id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Repository_lookup_id ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      search_id.in ()
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->lookup_id (
          search_id.in ()
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_Contained_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Repository::get_canonical_typecode_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Repository *_tao_impl =
    ACE_static_cast (POA_CORBA_Repository *, _tao_object_reference);

    CORBA::TypeCode_var _tao_retval;
  CORBA::TypeCode_var tc;
  if (!(
    (_tao_in >> tc.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Repository_get_canonical_typecode ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      tc.in ()
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->get_canonical_typecode (
          tc.in ()
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::TypeCode_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Repository::get_primitive_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Repository *_tao_impl =
    ACE_static_cast (POA_CORBA_Repository *, _tao_object_reference);

    CORBA_PrimitiveDef_var _tao_retval;
  CORBA::PrimitiveKind kind;
  if (!(
    (_tao_in >> kind)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Repository_get_primitive ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      kind
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->get_primitive (
          kind
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_PrimitiveDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Repository::create_string_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Repository *_tao_impl =
    ACE_static_cast (POA_CORBA_Repository *, _tao_object_reference);

    CORBA_StringDef_var _tao_retval;
  CORBA::ULong bound;
  if (!(
    (_tao_in >> bound)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Repository_create_string ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      bound
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_string (
          bound
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_StringDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Repository::create_wstring_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Repository *_tao_impl =
    ACE_static_cast (POA_CORBA_Repository *, _tao_object_reference);

    CORBA_WstringDef_var _tao_retval;
  CORBA::ULong bound;
  if (!(
    (_tao_in >> bound)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Repository_create_wstring ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      bound
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_wstring (
          bound
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_WstringDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Repository::create_sequence_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Repository *_tao_impl =
    ACE_static_cast (POA_CORBA_Repository *, _tao_object_reference);

    CORBA_SequenceDef_var _tao_retval;
  CORBA::ULong bound;
  CORBA_IDLType_var element_type;
  if (!(
    (_tao_in >> bound) &&
    (_tao_in >> element_type.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Repository_create_sequence ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      bound,
      element_type.in ()
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_sequence (
          bound,
          element_type.in ()
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_SequenceDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Repository::create_array_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Repository *_tao_impl =
    ACE_static_cast (POA_CORBA_Repository *, _tao_object_reference);

    CORBA_ArrayDef_var _tao_retval;
  CORBA::ULong length;
  CORBA_IDLType_var element_type;
  if (!(
    (_tao_in >> length) &&
    (_tao_in >> element_type.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Repository_create_array ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      length,
      element_type.in ()
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_array (
          length,
          element_type.in ()
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_ArrayDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Repository::create_fixed_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Repository *_tao_impl =
    ACE_static_cast (POA_CORBA_Repository *, _tao_object_reference);

    CORBA_FixedDef_var _tao_retval;
  CORBA::UShort digits;
  CORBA::Short scale;
  if (!(
    (_tao_in >> digits) &&
    (_tao_in >> scale)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Repository_create_fixed ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      digits,
      scale
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_fixed (
          digits,
          scale
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_FixedDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Repository::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Repository *_tao_impl = (POA_CORBA_Repository *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () TAO_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_Repository::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_Repository *_tao_impl = (POA_CORBA_Repository *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_Repository::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_Repository *_tao_impl = (POA_CORBA_Repository *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_CORBA_Repository::_is_a (
    const char* value
    TAO_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Repository:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA_Repository::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Repository:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Repository_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Container:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA_Repository::_dispatch (TAO_ServerRequest &req, void *servant_upcall TAO_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     TAO_ENV_ARG_PARAMETER);
}


const char* POA_CORBA_Repository::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/Repository:1.0";
}

CORBA_Repository*
POA_CORBA_Repository::_this (TAO_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::CORBA_Repository::_unchecked_narrow (obj.in ());
}


class TAO_CORBA_ModuleDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:45:26 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_ModuleDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ModuleDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 20,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 10,
     64,  0, 20,  0, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 20,  0,  5,
     64, 10, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 15, 30, 64, 64, 64, 10,  5, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64,
#else
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 20, 64, 10, 64,  0,
     20,  0, 64, 64, 64, 64, 64, 64, 20,  0,
      5, 64, 10, 64, 64, 15, 30, 64, 64, 64,
     10,  5, 64, 64, 64, 64, 64, 64,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_ModuleDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 33,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 63,
      HASH_VALUE_RANGE = 60,
      DUPLICATES = 5,
      WORDLIST_SIZE = 37
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_CORBA_ModuleDef::move_skel},
      {"create_enum",   &POA_CORBA_ModuleDef::create_enum_skel},
      {"create_value",  &POA_CORBA_ModuleDef::create_value_skel},
      {"create_module",         &POA_CORBA_ModuleDef::create_module_skel},
      {"create_native",         &POA_CORBA_ModuleDef::create_native_skel},
      {"create_interface",      &POA_CORBA_ModuleDef::create_interface_skel},
      {"create_union",  &POA_CORBA_ModuleDef::create_union_skel},
      {"create_exception",      &POA_CORBA_ModuleDef::create_exception_skel},
      {"create_local_interface",        &POA_CORBA_ModuleDef::create_local_interface_skel},
      {"contents",      &POA_CORBA_ModuleDef::contents_skel},
      {"create_abstract_interface",     &POA_CORBA_ModuleDef::create_abstract_interface_skel},
      {"create_value_box",      &POA_CORBA_ModuleDef::create_value_box_skel},
      {"create_alias",  &POA_CORBA_ModuleDef::create_alias_skel},
      {"describe",      &POA_CORBA_ModuleDef::describe_skel},
      {"_get_name",     &POA_CORBA_ModuleDef::_get_name_skel},
      {"_set_name",     &POA_CORBA_ModuleDef::_set_name_skel},
      {"_interface",  &POA_CORBA_ModuleDef::_interface_skel},
      {"lookup_name",   &POA_CORBA_ModuleDef::lookup_name_skel},
      {"destroy",       &POA_CORBA_ModuleDef::destroy_skel},
      {"_is_a",  &POA_CORBA_ModuleDef::_is_a_skel},
      {"lookup",        &POA_CORBA_ModuleDef::lookup_skel},
      {"_get_version",  &POA_CORBA_ModuleDef::_get_version_skel},
      {"_set_version",  &POA_CORBA_ModuleDef::_set_version_skel},
      {"_get_absolute_name",    &POA_CORBA_ModuleDef::_get_absolute_name_skel},
      {"_get_defined_in",       &POA_CORBA_ModuleDef::_get_defined_in_skel},
      {"create_struct",         &POA_CORBA_ModuleDef::create_struct_skel},
      {"create_constant",       &POA_CORBA_ModuleDef::create_constant_skel},
      {"_get_id",       &POA_CORBA_ModuleDef::_get_id_skel},
      {"_set_id",       &POA_CORBA_ModuleDef::_set_id_skel},
      {"_get_containing_repository",    &POA_CORBA_ModuleDef::_get_containing_repository_skel},
      {"describe_contents",     &POA_CORBA_ModuleDef::describe_contents_skel},
      {"_get_def_kind",         &POA_CORBA_ModuleDef::_get_def_kind_skel},
      {"_non_existent",  &POA_CORBA_ModuleDef::_non_existent_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,  -1,  -1,  -1,  -1,  -7,  -2,   5,   6, -67,
       -1,  -1,   9,  10,  -1, -18,  -2,  11,  12,  13,  -1,  14,  15,  16,
       17, -73,  20,  21,  22, -25,  -2,  23,  24, -67,  27,  -1,  28, -31,
       -2,  29,  -1,  30,  -1, -69,  -1,  -1,  -1,  33,  34,  35,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  36,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:45:26 */
static TAO_CORBA_ModuleDef_Perfect_Hash_OpTable tao_CORBA_ModuleDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
_TAO_CORBA_ModuleDef_Strategized_Proxy_Broker *_TAO_CORBA_ModuleDef_Strategized_Proxy_Broker::the_TAO_CORBA_ModuleDef_Strategized_Proxy_Broker (void)
{
  static _TAO_CORBA_ModuleDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_CORBA_ModuleDef_Strategized_Proxy_Broker::_TAO_CORBA_ModuleDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

_TAO_CORBA_ModuleDef_Strategized_Proxy_Broker::~_TAO_CORBA_ModuleDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_CORBA_ModuleDef_Proxy_Impl&
_TAO_CORBA_ModuleDef_Strategized_Proxy_Broker::select_proxy (
    ::CORBA_ModuleDef *object
    TAO_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
_TAO_CORBA_ModuleDef_Strategized_Proxy_Broker::create_proxy (
    int strategy
    TAO_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_CORBA_ModuleDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_CORBA_ModuleDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_CORBA_ModuleDef_Proxy_Broker *
_TAO_CORBA_ModuleDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::_TAO_CORBA_ModuleDef_Strategized_Proxy_Broker::the_TAO_CORBA_ModuleDef_Strategized_Proxy_Broker();
}

int
_TAO_CORBA_ModuleDef_Proxy_Broker_Factory_Initializer (long)
{
  _TAO_CORBA_ModuleDef_Proxy_Broker_Factory_function_pointer =
    _TAO_CORBA_ModuleDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_CORBA_ModuleDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_CORBA_ModuleDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_CORBA_ModuleDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

_TAO_CORBA_ModuleDef_ThruPOA_Proxy_Impl::_TAO_CORBA_ModuleDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA_ModuleDef::POA_CORBA_ModuleDef (void)
{
  this->optable_ = &tao_CORBA_ModuleDef_optable;
}

// copy ctor
POA_CORBA_ModuleDef::POA_CORBA_ModuleDef (const POA_CORBA_ModuleDef& rhs)
  :   POA_CORBA_Container (rhs),
    POA_CORBA_Contained (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA_ModuleDef::~POA_CORBA_ModuleDef (void)
{
}

void POA_CORBA_ModuleDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_ModuleDef *_tao_impl = (POA_CORBA_ModuleDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () TAO_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_ModuleDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_ModuleDef *_tao_impl = (POA_CORBA_ModuleDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_ModuleDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_ModuleDef *_tao_impl = (POA_CORBA_ModuleDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_CORBA_ModuleDef::_is_a (
    const char* value
    TAO_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ModuleDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA_ModuleDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/ModuleDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_ModuleDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Container:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA_ModuleDef::_dispatch (TAO_ServerRequest &req, void *servant_upcall TAO_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     TAO_ENV_ARG_PARAMETER);
}


const char* POA_CORBA_ModuleDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ModuleDef:1.0";
}

CORBA_ModuleDef*
POA_CORBA_ModuleDef::_this (TAO_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::CORBA_ModuleDef::_unchecked_narrow (obj.in ());
}


class TAO_CORBA_ConstantDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:45:27 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_ConstantDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ConstantDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 15, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 15, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_ConstantDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 21,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 8,
      WORDLIST_SIZE = 25
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_CORBA_ConstantDef::move_skel},
      {"_is_a",  &POA_CORBA_ConstantDef::_is_a_skel},
      {"_get_id",       &POA_CORBA_ConstantDef::_get_id_skel},
      {"_set_id",       &POA_CORBA_ConstantDef::_set_id_skel},
      {"describe",      &POA_CORBA_ConstantDef::describe_skel},
      {"_get_type",     &POA_CORBA_ConstantDef::_get_type_skel},
      {"_set_name",     &POA_CORBA_ConstantDef::_set_name_skel},
      {"_get_name",     &POA_CORBA_ConstantDef::_get_name_skel},
      {"_get_value",    &POA_CORBA_ConstantDef::_get_value_skel},
      {"_interface",  &POA_CORBA_ConstantDef::_interface_skel},
      {"_set_value",    &POA_CORBA_ConstantDef::_set_value_skel},
      {"_get_version",  &POA_CORBA_ConstantDef::_get_version_skel},
      {"_set_version",  &POA_CORBA_ConstantDef::_set_version_skel},
      {"_get_def_kind",         &POA_CORBA_ConstantDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_CORBA_ConstantDef::_get_defined_in_skel},
      {"destroy",       &POA_CORBA_ConstantDef::destroy_skel},
      {"_get_absolute_name",    &POA_CORBA_ConstantDef::_get_absolute_name_skel},
      {"_get_type_def",         &POA_CORBA_ConstantDef::_get_type_def_skel},
      {"_set_type_def",         &POA_CORBA_ConstantDef::_set_type_def_skel},
      {"_non_existent",  &POA_CORBA_ConstantDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_CORBA_ConstantDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
      -12,  -3, -15,  -2,   4,   5,  -1,  53,   8,  46, -46,  -1, -46,  17,
       -1,  18,  -1,  19,  20,  -9,  -3, -21,  -2, -38,  -6,  -2,  -1,  -1,
       23,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  24,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:45:27 */
static TAO_CORBA_ConstantDef_Perfect_Hash_OpTable tao_CORBA_ConstantDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_CORBA_ConstantDef_type_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ConstantDef_type_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_ConstantDef *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::TypeCode_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_ConstantDef_type_get (const TAO_ServerRequestInfo_CORBA_ConstantDef_type_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ConstantDef_type_get &);

private:
  POA_CORBA_ConstantDef *_tao_impl;
  CORBA::TypeCode_ptr _result;
};

TAO_ServerRequestInfo_CORBA_ConstantDef_type_get::TAO_ServerRequestInfo_CORBA_ConstantDef_type_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_ConstantDef *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ConstantDef_type_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ConstantDef_type_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_ConstantDef_type_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_ConstantDef_type_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ConstantDef_type_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_ConstantDef_type_get::result (CORBA::TypeCode_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_ConstantDef_type_def_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ConstantDef_type_def_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_ConstantDef *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_IDLType_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_ConstantDef_type_def_get (const TAO_ServerRequestInfo_CORBA_ConstantDef_type_def_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ConstantDef_type_def_get &);

private:
  POA_CORBA_ConstantDef *_tao_impl;
  CORBA_IDLType_ptr _result;
};

TAO_ServerRequestInfo_CORBA_ConstantDef_type_def_get::TAO_ServerRequestInfo_CORBA_ConstantDef_type_def_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_ConstantDef *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ConstantDef_type_def_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ConstantDef_type_def_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_ConstantDef_type_def_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_ConstantDef_type_def_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ConstantDef_type_def_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_ConstantDef_type_def_get::result (CORBA_IDLType_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_ConstantDef_type_def_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ConstantDef_type_def_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_ConstantDef *tao_impl
    ,
    CORBA_IDLType_ptr type_def
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));


private:
  TAO_ServerRequestInfo_CORBA_ConstantDef_type_def_set (const TAO_ServerRequestInfo_CORBA_ConstantDef_type_def_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ConstantDef_type_def_set &);

private:
  POA_CORBA_ConstantDef *_tao_impl;
  CORBA_IDLType_ptr type_def_;

};

TAO_ServerRequestInfo_CORBA_ConstantDef_type_def_set::TAO_ServerRequestInfo_CORBA_ConstantDef_type_def_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_ConstantDef *tao_impl,
    CORBA_IDLType_ptr type_def
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    type_def_ (type_def)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ConstantDef_type_def_set::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->type_def_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ConstantDef_type_def_set::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_ConstantDef_type_def_set::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_ConstantDef_type_def_set::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ConstantDef_type_def_set::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_CORBA_ConstantDef_value_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ConstantDef_value_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_ConstantDef *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Any * result);

private:
  TAO_ServerRequestInfo_CORBA_ConstantDef_value_get (const TAO_ServerRequestInfo_CORBA_ConstantDef_value_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ConstantDef_value_get &);

private:
  POA_CORBA_ConstantDef *_tao_impl;
  CORBA::Any * _result;
};

TAO_ServerRequestInfo_CORBA_ConstantDef_value_get::TAO_ServerRequestInfo_CORBA_ConstantDef_value_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_ConstantDef *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ConstantDef_value_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ConstantDef_value_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_ConstantDef_value_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_ConstantDef_value_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ConstantDef_value_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_ConstantDef_value_get::result (CORBA::Any * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_ConstantDef_value_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ConstantDef_value_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_ConstantDef *tao_impl
    ,
    const CORBA::Any & value
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));


private:
  TAO_ServerRequestInfo_CORBA_ConstantDef_value_set (const TAO_ServerRequestInfo_CORBA_ConstantDef_value_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ConstantDef_value_set &);

private:
  POA_CORBA_ConstantDef *_tao_impl;
  const CORBA::Any & value_;

};

TAO_ServerRequestInfo_CORBA_ConstantDef_value_set::TAO_ServerRequestInfo_CORBA_ConstantDef_value_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_ConstantDef *tao_impl,
    const CORBA::Any & value
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    value_ (value)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ConstantDef_value_set::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= value_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ConstantDef_value_set::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_ConstantDef_value_set::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_ConstantDef_value_set::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ConstantDef_value_set::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
_TAO_CORBA_ConstantDef_Strategized_Proxy_Broker *_TAO_CORBA_ConstantDef_Strategized_Proxy_Broker::the_TAO_CORBA_ConstantDef_Strategized_Proxy_Broker (void)
{
  static _TAO_CORBA_ConstantDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_CORBA_ConstantDef_Strategized_Proxy_Broker::_TAO_CORBA_ConstantDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

_TAO_CORBA_ConstantDef_Strategized_Proxy_Broker::~_TAO_CORBA_ConstantDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_CORBA_ConstantDef_Proxy_Impl&
_TAO_CORBA_ConstantDef_Strategized_Proxy_Broker::select_proxy (
    ::CORBA_ConstantDef *object
    TAO_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
_TAO_CORBA_ConstantDef_Strategized_Proxy_Broker::create_proxy (
    int strategy
    TAO_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_CORBA_ConstantDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_CORBA_ConstantDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_CORBA_ConstantDef_Proxy_Broker *
_TAO_CORBA_ConstantDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::_TAO_CORBA_ConstantDef_Strategized_Proxy_Broker::the_TAO_CORBA_ConstantDef_Strategized_Proxy_Broker();
}

int
_TAO_CORBA_ConstantDef_Proxy_Broker_Factory_Initializer (long)
{
  _TAO_CORBA_ConstantDef_Proxy_Broker_Factory_function_pointer =
    _TAO_CORBA_ConstantDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_CORBA_ConstantDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_CORBA_ConstantDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_CORBA_ConstantDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

_TAO_CORBA_ConstantDef_ThruPOA_Proxy_Impl::_TAO_CORBA_ConstantDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::TypeCode_ptr _TAO_CORBA_ConstantDef_ThruPOA_Proxy_Impl::type (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_ConstantDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ConstantDef:1.0"
        )
    )->type (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

CORBA_IDLType_ptr _TAO_CORBA_ConstantDef_ThruPOA_Proxy_Impl::type_def (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type_def",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_ConstantDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ConstantDef:1.0"
        )
    )->type_def (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

void _TAO_CORBA_ConstantDef_ThruPOA_Proxy_Impl::type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA_IDLType_ptr type_def
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type_def",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_ConstantDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ConstantDef:1.0"
        )
    )->type_def (
        type_def
        TAO_ENV_ARG_PARAMETER
      );
  return;
}

CORBA::Any * _TAO_CORBA_ConstantDef_ThruPOA_Proxy_Impl::value (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Any_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "value",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_ConstantDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ConstantDef:1.0"
        )
    )->value (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

void _TAO_CORBA_ConstantDef_ThruPOA_Proxy_Impl::value (
    CORBA_Object *_collocated_tao_target_,
    const CORBA::Any & value
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "value",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_ConstantDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ConstantDef:1.0"
        )
    )->value (
        value
        TAO_ENV_ARG_PARAMETER
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA_ConstantDef::POA_CORBA_ConstantDef (void)
{
  this->optable_ = &tao_CORBA_ConstantDef_optable;
}

// copy ctor
POA_CORBA_ConstantDef::POA_CORBA_ConstantDef (const POA_CORBA_ConstantDef& rhs)
  :   POA_CORBA_Contained (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA_ConstantDef::~POA_CORBA_ConstantDef (void)
{
}

void POA_CORBA_ConstantDef::_get_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_ConstantDef *_tao_impl =
    ACE_static_cast (POA_CORBA_ConstantDef *, _tao_object_reference);

    CORBA::TypeCode_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_ConstantDef_type_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->type (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::TypeCode_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_ConstantDef::_get_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_ConstantDef *_tao_impl =
    ACE_static_cast (POA_CORBA_ConstantDef *, _tao_object_reference);

    CORBA_IDLType_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_ConstantDef_type_def_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->type_def (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_IDLType_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_ConstantDef::_set_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_ConstantDef *_tao_impl =
    ACE_static_cast (POA_CORBA_ConstantDef *, _tao_object_reference);

  _tao_server_request.argument_flag (0);
    CORBA_IDLType_var type_def;
  if (!(
    (_tao_in >> type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_ConstantDef_type_def_set ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      type_def.in ()
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->type_def (
          type_def.in ()
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_ConstantDef::_get_value_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_ConstantDef *_tao_impl =
    ACE_static_cast (POA_CORBA_ConstantDef *, _tao_object_reference);

    CORBA::Any_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_ConstantDef_value_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->value (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Any * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_ConstantDef::_set_value_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_ConstantDef *_tao_impl =
    ACE_static_cast (POA_CORBA_ConstantDef *, _tao_object_reference);

  _tao_server_request.argument_flag (0);
    CORBA::Any value;
  if (!(
    (_tao_in >> value)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_ConstantDef_value_set ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      value
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->value (
          value
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_ConstantDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_ConstantDef *_tao_impl = (POA_CORBA_ConstantDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () TAO_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_ConstantDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_ConstantDef *_tao_impl = (POA_CORBA_ConstantDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_ConstantDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_ConstantDef *_tao_impl = (POA_CORBA_ConstantDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_CORBA_ConstantDef::_is_a (
    const char* value
    TAO_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ConstantDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA_ConstantDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/ConstantDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_ConstantDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA_ConstantDef::_dispatch (TAO_ServerRequest &req, void *servant_upcall TAO_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     TAO_ENV_ARG_PARAMETER);
}


const char* POA_CORBA_ConstantDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ConstantDef:1.0";
}

CORBA_ConstantDef*
POA_CORBA_ConstantDef::_this (TAO_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::CORBA_ConstantDef::_unchecked_narrow (obj.in ());
}


class TAO_CORBA_StructDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:45:28 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_StructDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_StructDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61,  0,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61,  0,
     61, 25,  8,  0, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61,  0, 15,  5,
     61,  0, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 20, 20, 61, 61, 61, 15, 10, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61,
#else
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61,  0, 61,  0, 61, 25,
      8,  0, 61, 61, 61, 61, 61, 61,  0, 15,
      5, 61,  0, 61, 61, 20, 20, 61, 61, 61,
     15, 10, 61, 61, 61, 61, 61, 61,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_StructDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 36,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 60,
      HASH_VALUE_RANGE = 56,
      DUPLICATES = 7,
      WORDLIST_SIZE = 41
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_CORBA_StructDef::_is_a_skel},
      {"lookup",        &POA_CORBA_StructDef::lookup_skel},
      {"_get_name",     &POA_CORBA_StructDef::_get_name_skel},
      {"_get_type",     &POA_CORBA_StructDef::_get_type_skel},
      {"_set_name",     &POA_CORBA_StructDef::_set_name_skel},
      {"_interface",  &POA_CORBA_StructDef::_interface_skel},
      {"lookup_name",   &POA_CORBA_StructDef::lookup_name_skel},
      {"_get_id",       &POA_CORBA_StructDef::_get_id_skel},
      {"_set_id",       &POA_CORBA_StructDef::_set_id_skel},
      {"describe",      &POA_CORBA_StructDef::describe_skel},
      {"_get_version",  &POA_CORBA_StructDef::_get_version_skel},
      {"_set_version",  &POA_CORBA_StructDef::_set_version_skel},
      {"_get_absolute_name",    &POA_CORBA_StructDef::_get_absolute_name_skel},
      {"move",  &POA_CORBA_StructDef::move_skel},
      {"_get_defined_in",       &POA_CORBA_StructDef::_get_defined_in_skel},
      {"_get_def_kind",         &POA_CORBA_StructDef::_get_def_kind_skel},
      {"destroy",       &POA_CORBA_StructDef::destroy_skel},
      {"_get_members",  &POA_CORBA_StructDef::_get_members_skel},
      {"_set_members",  &POA_CORBA_StructDef::_set_members_skel},
      {"_non_existent",  &POA_CORBA_StructDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_CORBA_StructDef::_get_containing_repository_skel},
      {"create_value",  &POA_CORBA_StructDef::create_value_skel},
      {"create_module",         &POA_CORBA_StructDef::create_module_skel},
      {"create_native",         &POA_CORBA_StructDef::create_native_skel},
      {"create_interface",      &POA_CORBA_StructDef::create_interface_skel},
      {"create_union",  &POA_CORBA_StructDef::create_union_skel},
      {"describe_contents",     &POA_CORBA_StructDef::describe_contents_skel},
      {"create_exception",      &POA_CORBA_StructDef::create_exception_skel},
      {"create_local_interface",        &POA_CORBA_StructDef::create_local_interface_skel},
      {"create_abstract_interface",     &POA_CORBA_StructDef::create_abstract_interface_skel},
      {"create_enum",   &POA_CORBA_StructDef::create_enum_skel},
      {"contents",      &POA_CORBA_StructDef::contents_skel},
      {"create_value_box",      &POA_CORBA_StructDef::create_value_box_skel},
      {"create_alias",  &POA_CORBA_StructDef::create_alias_skel},
      {"create_struct",         &POA_CORBA_StructDef::create_struct_skel},
      {"create_constant",       &POA_CORBA_StructDef::create_constant_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -7,  -3,   5,   6, -12,  -2, -66,  10,  11,  -1, -15,
       -2, -68,  14, -64,  17,  18,  19,  20,  -1,  -1,  -1,  21,  -1,  -1,
       -1,  -1, -22,  -2, -62,  24, -27,  -2,  25,  26, -64,  -1,  -1,  29,
       30,  -1,  -1,  31,  32,  33,  -1,  -1,  34,  35,  -1,  36,  -1,  -1,
       37,  38,  39,  -1,  40,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:45:28 */
static TAO_CORBA_StructDef_Perfect_Hash_OpTable tao_CORBA_StructDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_CORBA_StructDef_members_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_StructDef_members_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_StructDef *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_StructMemberSeq * result);

private:
  TAO_ServerRequestInfo_CORBA_StructDef_members_get (const TAO_ServerRequestInfo_CORBA_StructDef_members_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_StructDef_members_get &);

private:
  POA_CORBA_StructDef *_tao_impl;
  CORBA_StructMemberSeq * _result;
};

TAO_ServerRequestInfo_CORBA_StructDef_members_get::TAO_ServerRequestInfo_CORBA_StructDef_members_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_StructDef *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_StructDef_members_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_StructDef_members_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_StructDef_members_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_StructDef_members_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_StructDef_members_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_StructDef_members_get::result (CORBA_StructMemberSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_StructDef_members_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_StructDef_members_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_StructDef *tao_impl
    ,
    const CORBA_StructMemberSeq & members
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));


private:
  TAO_ServerRequestInfo_CORBA_StructDef_members_set (const TAO_ServerRequestInfo_CORBA_StructDef_members_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_StructDef_members_set &);

private:
  POA_CORBA_StructDef *_tao_impl;
  const CORBA_StructMemberSeq & members_;

};

TAO_ServerRequestInfo_CORBA_StructDef_members_set::TAO_ServerRequestInfo_CORBA_StructDef_members_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_StructDef *tao_impl,
    const CORBA_StructMemberSeq & members
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    members_ (members)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_StructDef_members_set::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->members_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_StructDef_members_set::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_StructDef_members_set::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_StructDef_members_set::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_StructDef_members_set::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
_TAO_CORBA_StructDef_Strategized_Proxy_Broker *_TAO_CORBA_StructDef_Strategized_Proxy_Broker::the_TAO_CORBA_StructDef_Strategized_Proxy_Broker (void)
{
  static _TAO_CORBA_StructDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_CORBA_StructDef_Strategized_Proxy_Broker::_TAO_CORBA_StructDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

_TAO_CORBA_StructDef_Strategized_Proxy_Broker::~_TAO_CORBA_StructDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_CORBA_StructDef_Proxy_Impl&
_TAO_CORBA_StructDef_Strategized_Proxy_Broker::select_proxy (
    ::CORBA_StructDef *object
    TAO_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
_TAO_CORBA_StructDef_Strategized_Proxy_Broker::create_proxy (
    int strategy
    TAO_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_CORBA_StructDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_CORBA_StructDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_CORBA_StructDef_Proxy_Broker *
_TAO_CORBA_StructDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::_TAO_CORBA_StructDef_Strategized_Proxy_Broker::the_TAO_CORBA_StructDef_Strategized_Proxy_Broker();
}

int
_TAO_CORBA_StructDef_Proxy_Broker_Factory_Initializer (long)
{
  _TAO_CORBA_StructDef_Proxy_Broker_Factory_function_pointer =
    _TAO_CORBA_StructDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_CORBA_StructDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_CORBA_StructDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_CORBA_StructDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

_TAO_CORBA_StructDef_ThruPOA_Proxy_Impl::_TAO_CORBA_StructDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA_StructMemberSeq * _TAO_CORBA_StructDef_ThruPOA_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_StructMemberSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "members",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_StructDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/StructDef:1.0"
        )
    )->members (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

void _TAO_CORBA_StructDef_ThruPOA_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    const CORBA_StructMemberSeq & members
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "members",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_StructDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/StructDef:1.0"
        )
    )->members (
        members
        TAO_ENV_ARG_PARAMETER
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA_StructDef::POA_CORBA_StructDef (void)
{
  this->optable_ = &tao_CORBA_StructDef_optable;
}

// copy ctor
POA_CORBA_StructDef::POA_CORBA_StructDef (const POA_CORBA_StructDef& rhs)
  :   POA_CORBA_TypedefDef (rhs),
    POA_CORBA_Container (rhs),
    POA_CORBA_Contained (rhs),
    POA_CORBA_IDLType (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA_StructDef::~POA_CORBA_StructDef (void)
{
}

void POA_CORBA_StructDef::_get_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_StructDef *_tao_impl =
    ACE_static_cast (POA_CORBA_StructDef *, _tao_object_reference);

    CORBA_StructMemberSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_StructDef_members_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->members (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_StructMemberSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_StructDef::_set_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_StructDef *_tao_impl =
    ACE_static_cast (POA_CORBA_StructDef *, _tao_object_reference);

  _tao_server_request.argument_flag (0);
    CORBA_StructMemberSeq members;
  if (!(
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_StructDef_members_set ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      members
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->members (
          members
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_StructDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_StructDef *_tao_impl = (POA_CORBA_StructDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () TAO_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_StructDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_StructDef *_tao_impl = (POA_CORBA_StructDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_StructDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_StructDef *_tao_impl = (POA_CORBA_StructDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_CORBA_StructDef::_is_a (
    const char* value
    TAO_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/StructDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA_StructDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/StructDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_StructDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Container:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA_StructDef::_dispatch (TAO_ServerRequest &req, void *servant_upcall TAO_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     TAO_ENV_ARG_PARAMETER);
}


const char* POA_CORBA_StructDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/StructDef:1.0";
}

CORBA_StructDef*
POA_CORBA_StructDef::_this (TAO_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::CORBA_StructDef::_unchecked_narrow (obj.in ());
}


class TAO_CORBA_UnionDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:45:29 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_UnionDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_UnionDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61,  0,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61,  0,
     61, 25,  8,  0,  0, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61,  0, 15,  5,
     61,  0, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 20, 20, 61, 61, 61, 15, 10, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61,
#else
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61,  0, 61,  0, 61, 25,
      8,  0,  0, 61, 61, 61, 61, 61,  0, 15,
      5, 61,  0, 61, 61, 20, 20, 61, 61, 61,
     15, 10, 61, 61, 61, 61, 61, 61,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_UnionDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 39,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 27,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 60,
      HASH_VALUE_RANGE = 56,
      DUPLICATES = 8,
      WORDLIST_SIZE = 44
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_CORBA_UnionDef::_is_a_skel},
      {"lookup",        &POA_CORBA_UnionDef::lookup_skel},
      {"_get_name",     &POA_CORBA_UnionDef::_get_name_skel},
      {"_get_type",     &POA_CORBA_UnionDef::_get_type_skel},
      {"_set_name",     &POA_CORBA_UnionDef::_set_name_skel},
      {"_interface",  &POA_CORBA_UnionDef::_interface_skel},
      {"lookup_name",   &POA_CORBA_UnionDef::lookup_name_skel},
      {"_get_id",       &POA_CORBA_UnionDef::_get_id_skel},
      {"_set_id",       &POA_CORBA_UnionDef::_set_id_skel},
      {"describe",      &POA_CORBA_UnionDef::describe_skel},
      {"_get_version",  &POA_CORBA_UnionDef::_get_version_skel},
      {"_set_version",  &POA_CORBA_UnionDef::_set_version_skel},
      {"_get_absolute_name",    &POA_CORBA_UnionDef::_get_absolute_name_skel},
      {"move",  &POA_CORBA_UnionDef::move_skel},
      {"_get_defined_in",       &POA_CORBA_UnionDef::_get_defined_in_skel},
      {"_get_def_kind",         &POA_CORBA_UnionDef::_get_def_kind_skel},
      {"_get_discriminator_type",       &POA_CORBA_UnionDef::_get_discriminator_type_skel},
      {"destroy",       &POA_CORBA_UnionDef::destroy_skel},
      {"_get_discriminator_type_def",   &POA_CORBA_UnionDef::_get_discriminator_type_def_skel},
      {"_set_discriminator_type_def",   &POA_CORBA_UnionDef::_set_discriminator_type_def_skel},
      {"_get_members",  &POA_CORBA_UnionDef::_get_members_skel},
      {"_set_members",  &POA_CORBA_UnionDef::_set_members_skel},
      {"_non_existent",  &POA_CORBA_UnionDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_CORBA_UnionDef::_get_containing_repository_skel},
      {"create_value",  &POA_CORBA_UnionDef::create_value_skel},
      {"create_module",         &POA_CORBA_UnionDef::create_module_skel},
      {"create_native",         &POA_CORBA_UnionDef::create_native_skel},
      {"create_interface",      &POA_CORBA_UnionDef::create_interface_skel},
      {"create_union",  &POA_CORBA_UnionDef::create_union_skel},
      {"describe_contents",     &POA_CORBA_UnionDef::describe_contents_skel},
      {"create_exception",      &POA_CORBA_UnionDef::create_exception_skel},
      {"create_local_interface",        &POA_CORBA_UnionDef::create_local_interface_skel},
      {"create_abstract_interface",     &POA_CORBA_UnionDef::create_abstract_interface_skel},
      {"create_enum",   &POA_CORBA_UnionDef::create_enum_skel},
      {"contents",      &POA_CORBA_UnionDef::contents_skel},
      {"create_value_box",      &POA_CORBA_UnionDef::create_value_box_skel},
      {"create_alias",  &POA_CORBA_UnionDef::create_alias_skel},
      {"create_struct",         &POA_CORBA_UnionDef::create_struct_skel},
      {"create_constant",       &POA_CORBA_UnionDef::create_constant_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -7,  -3, -12,  -2,   5,   6, -15,  -2, -68,  10,  11,  -1, -23,
       -2, -72,  14, -70,  17,  18,  19,  20,  -1,  21,  -1,  22,  -1, -74,
       -1,  -1, -25,  -2, -62,  27, -30,  -2,  28,  29, -64,  -1,  -1,  32,
       33,  -1,  -1,  34,  35,  36,  -1,  -1,  37,  38,  -1,  39,  -1,  -1,
       40,  41,  42,  -1,  43,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:45:29 */
static TAO_CORBA_UnionDef_Perfect_Hash_OpTable tao_CORBA_UnionDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_UnionDef *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::TypeCode_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_get (const TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_get &);

private:
  POA_CORBA_UnionDef *_tao_impl;
  CORBA::TypeCode_ptr _result;
};

TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_get::TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_UnionDef *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_get::result (CORBA::TypeCode_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_def_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_def_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_UnionDef *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_IDLType_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_def_get (const TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_def_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_def_get &);

private:
  POA_CORBA_UnionDef *_tao_impl;
  CORBA_IDLType_ptr _result;
};

TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_def_get::TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_def_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_UnionDef *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_def_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_def_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_def_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_def_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_def_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_def_get::result (CORBA_IDLType_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_def_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_def_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_UnionDef *tao_impl
    ,
    CORBA_IDLType_ptr discriminator_type_def
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));


private:
  TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_def_set (const TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_def_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_def_set &);

private:
  POA_CORBA_UnionDef *_tao_impl;
  CORBA_IDLType_ptr discriminator_type_def_;

};

TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_def_set::TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_def_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_UnionDef *tao_impl,
    CORBA_IDLType_ptr discriminator_type_def
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    discriminator_type_def_ (discriminator_type_def)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_def_set::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->discriminator_type_def_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_def_set::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_def_set::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_def_set::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_def_set::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_CORBA_UnionDef_members_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_UnionDef_members_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_UnionDef *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_UnionMemberSeq * result);

private:
  TAO_ServerRequestInfo_CORBA_UnionDef_members_get (const TAO_ServerRequestInfo_CORBA_UnionDef_members_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_UnionDef_members_get &);

private:
  POA_CORBA_UnionDef *_tao_impl;
  CORBA_UnionMemberSeq * _result;
};

TAO_ServerRequestInfo_CORBA_UnionDef_members_get::TAO_ServerRequestInfo_CORBA_UnionDef_members_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_UnionDef *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_UnionDef_members_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_UnionDef_members_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_UnionDef_members_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_UnionDef_members_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_UnionDef_members_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_UnionDef_members_get::result (CORBA_UnionMemberSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_UnionDef_members_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_UnionDef_members_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_UnionDef *tao_impl
    ,
    const CORBA_UnionMemberSeq & members
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));


private:
  TAO_ServerRequestInfo_CORBA_UnionDef_members_set (const TAO_ServerRequestInfo_CORBA_UnionDef_members_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_UnionDef_members_set &);

private:
  POA_CORBA_UnionDef *_tao_impl;
  const CORBA_UnionMemberSeq & members_;

};

TAO_ServerRequestInfo_CORBA_UnionDef_members_set::TAO_ServerRequestInfo_CORBA_UnionDef_members_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_UnionDef *tao_impl,
    const CORBA_UnionMemberSeq & members
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    members_ (members)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_UnionDef_members_set::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->members_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_UnionDef_members_set::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_UnionDef_members_set::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_UnionDef_members_set::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_UnionDef_members_set::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
_TAO_CORBA_UnionDef_Strategized_Proxy_Broker *_TAO_CORBA_UnionDef_Strategized_Proxy_Broker::the_TAO_CORBA_UnionDef_Strategized_Proxy_Broker (void)
{
  static _TAO_CORBA_UnionDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_CORBA_UnionDef_Strategized_Proxy_Broker::_TAO_CORBA_UnionDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

_TAO_CORBA_UnionDef_Strategized_Proxy_Broker::~_TAO_CORBA_UnionDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_CORBA_UnionDef_Proxy_Impl&
_TAO_CORBA_UnionDef_Strategized_Proxy_Broker::select_proxy (
    ::CORBA_UnionDef *object
    TAO_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
_TAO_CORBA_UnionDef_Strategized_Proxy_Broker::create_proxy (
    int strategy
    TAO_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_CORBA_UnionDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_CORBA_UnionDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_CORBA_UnionDef_Proxy_Broker *
_TAO_CORBA_UnionDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::_TAO_CORBA_UnionDef_Strategized_Proxy_Broker::the_TAO_CORBA_UnionDef_Strategized_Proxy_Broker();
}

int
_TAO_CORBA_UnionDef_Proxy_Broker_Factory_Initializer (long)
{
  _TAO_CORBA_UnionDef_Proxy_Broker_Factory_function_pointer =
    _TAO_CORBA_UnionDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_CORBA_UnionDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_CORBA_UnionDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_CORBA_UnionDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

_TAO_CORBA_UnionDef_ThruPOA_Proxy_Impl::_TAO_CORBA_UnionDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::TypeCode_ptr _TAO_CORBA_UnionDef_ThruPOA_Proxy_Impl::discriminator_type (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "discriminator_type",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_UnionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/UnionDef:1.0"
        )
    )->discriminator_type (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

CORBA_IDLType_ptr _TAO_CORBA_UnionDef_ThruPOA_Proxy_Impl::discriminator_type_def (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "discriminator_type_def",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_UnionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/UnionDef:1.0"
        )
    )->discriminator_type_def (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

void _TAO_CORBA_UnionDef_ThruPOA_Proxy_Impl::discriminator_type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA_IDLType_ptr discriminator_type_def
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "discriminator_type_def",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_UnionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/UnionDef:1.0"
        )
    )->discriminator_type_def (
        discriminator_type_def
        TAO_ENV_ARG_PARAMETER
      );
  return;
}

CORBA_UnionMemberSeq * _TAO_CORBA_UnionDef_ThruPOA_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_UnionMemberSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "members",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_UnionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/UnionDef:1.0"
        )
    )->members (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

void _TAO_CORBA_UnionDef_ThruPOA_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    const CORBA_UnionMemberSeq & members
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "members",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_UnionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/UnionDef:1.0"
        )
    )->members (
        members
        TAO_ENV_ARG_PARAMETER
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA_UnionDef::POA_CORBA_UnionDef (void)
{
  this->optable_ = &tao_CORBA_UnionDef_optable;
}

// copy ctor
POA_CORBA_UnionDef::POA_CORBA_UnionDef (const POA_CORBA_UnionDef& rhs)
  :   POA_CORBA_TypedefDef (rhs),
    POA_CORBA_Container (rhs),
    POA_CORBA_Contained (rhs),
    POA_CORBA_IDLType (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA_UnionDef::~POA_CORBA_UnionDef (void)
{
}

void POA_CORBA_UnionDef::_get_discriminator_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_UnionDef *_tao_impl =
    ACE_static_cast (POA_CORBA_UnionDef *, _tao_object_reference);

    CORBA::TypeCode_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->discriminator_type (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::TypeCode_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_UnionDef::_get_discriminator_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_UnionDef *_tao_impl =
    ACE_static_cast (POA_CORBA_UnionDef *, _tao_object_reference);

    CORBA_IDLType_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_def_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->discriminator_type_def (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_IDLType_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_UnionDef::_set_discriminator_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_UnionDef *_tao_impl =
    ACE_static_cast (POA_CORBA_UnionDef *, _tao_object_reference);

  _tao_server_request.argument_flag (0);
    CORBA_IDLType_var discriminator_type_def;
  if (!(
    (_tao_in >> discriminator_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_UnionDef_discriminator_type_def_set ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      discriminator_type_def.in ()
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->discriminator_type_def (
          discriminator_type_def.in ()
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_UnionDef::_get_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_UnionDef *_tao_impl =
    ACE_static_cast (POA_CORBA_UnionDef *, _tao_object_reference);

    CORBA_UnionMemberSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_UnionDef_members_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->members (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_UnionMemberSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_UnionDef::_set_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_UnionDef *_tao_impl =
    ACE_static_cast (POA_CORBA_UnionDef *, _tao_object_reference);

  _tao_server_request.argument_flag (0);
    CORBA_UnionMemberSeq members;
  if (!(
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_UnionDef_members_set ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      members
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->members (
          members
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_UnionDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_UnionDef *_tao_impl = (POA_CORBA_UnionDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () TAO_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_UnionDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_UnionDef *_tao_impl = (POA_CORBA_UnionDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_UnionDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_UnionDef *_tao_impl = (POA_CORBA_UnionDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_CORBA_UnionDef::_is_a (
    const char* value
    TAO_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/UnionDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA_UnionDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/UnionDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_UnionDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Container:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA_UnionDef::_dispatch (TAO_ServerRequest &req, void *servant_upcall TAO_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     TAO_ENV_ARG_PARAMETER);
}


const char* POA_CORBA_UnionDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/UnionDef:1.0";
}

CORBA_UnionDef*
POA_CORBA_UnionDef::_this (TAO_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::CORBA_UnionDef::_unchecked_narrow (obj.in ());
}


class TAO_CORBA_EnumDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:45:30 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_EnumDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_EnumDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 10, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 10, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_EnumDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 19,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 6,
      WORDLIST_SIZE = 23
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_CORBA_EnumDef::move_skel},
      {"_is_a",  &POA_CORBA_EnumDef::_is_a_skel},
      {"_get_id",       &POA_CORBA_EnumDef::_get_id_skel},
      {"_set_id",       &POA_CORBA_EnumDef::_set_id_skel},
      {"describe",      &POA_CORBA_EnumDef::describe_skel},
      {"_get_name",     &POA_CORBA_EnumDef::_get_name_skel},
      {"_get_type",     &POA_CORBA_EnumDef::_get_type_skel},
      {"_set_name",     &POA_CORBA_EnumDef::_set_name_skel},
      {"_interface",  &POA_CORBA_EnumDef::_interface_skel},
      {"_get_version",  &POA_CORBA_EnumDef::_get_version_skel},
      {"_set_version",  &POA_CORBA_EnumDef::_set_version_skel},
      {"_get_def_kind",         &POA_CORBA_EnumDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_CORBA_EnumDef::_get_defined_in_skel},
      {"destroy",       &POA_CORBA_EnumDef::destroy_skel},
      {"_get_absolute_name",    &POA_CORBA_EnumDef::_get_absolute_name_skel},
      {"_get_members",  &POA_CORBA_EnumDef::_get_members_skel},
      {"_set_members",  &POA_CORBA_EnumDef::_set_members_skel},
      {"_non_existent",  &POA_CORBA_EnumDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_CORBA_EnumDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -9,  -3, -13,  -2,   4,   5,  -1,  53,   8, -45,  12,  -1, -46,  15,
       -1,  16,  -1,  17,  18,  -1, -19,  -2, -38,  21,  -6,  -2,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  22,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:45:30 */
static TAO_CORBA_EnumDef_Perfect_Hash_OpTable tao_CORBA_EnumDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_CORBA_EnumDef_members_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_EnumDef_members_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_EnumDef *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_EnumMemberSeq * result);

private:
  TAO_ServerRequestInfo_CORBA_EnumDef_members_get (const TAO_ServerRequestInfo_CORBA_EnumDef_members_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_EnumDef_members_get &);

private:
  POA_CORBA_EnumDef *_tao_impl;
  CORBA_EnumMemberSeq * _result;
};

TAO_ServerRequestInfo_CORBA_EnumDef_members_get::TAO_ServerRequestInfo_CORBA_EnumDef_members_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_EnumDef *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_EnumDef_members_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_EnumDef_members_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_EnumDef_members_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_EnumDef_members_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_EnumDef_members_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_EnumDef_members_get::result (CORBA_EnumMemberSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_EnumDef_members_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_EnumDef_members_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_EnumDef *tao_impl
    ,
    const CORBA_EnumMemberSeq & members
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));


private:
  TAO_ServerRequestInfo_CORBA_EnumDef_members_set (const TAO_ServerRequestInfo_CORBA_EnumDef_members_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_EnumDef_members_set &);

private:
  POA_CORBA_EnumDef *_tao_impl;
  const CORBA_EnumMemberSeq & members_;

};

TAO_ServerRequestInfo_CORBA_EnumDef_members_set::TAO_ServerRequestInfo_CORBA_EnumDef_members_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_EnumDef *tao_impl,
    const CORBA_EnumMemberSeq & members
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    members_ (members)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_EnumDef_members_set::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->members_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_EnumDef_members_set::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_EnumDef_members_set::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_EnumDef_members_set::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_EnumDef_members_set::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
_TAO_CORBA_EnumDef_Strategized_Proxy_Broker *_TAO_CORBA_EnumDef_Strategized_Proxy_Broker::the_TAO_CORBA_EnumDef_Strategized_Proxy_Broker (void)
{
  static _TAO_CORBA_EnumDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_CORBA_EnumDef_Strategized_Proxy_Broker::_TAO_CORBA_EnumDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

_TAO_CORBA_EnumDef_Strategized_Proxy_Broker::~_TAO_CORBA_EnumDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_CORBA_EnumDef_Proxy_Impl&
_TAO_CORBA_EnumDef_Strategized_Proxy_Broker::select_proxy (
    ::CORBA_EnumDef *object
    TAO_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
_TAO_CORBA_EnumDef_Strategized_Proxy_Broker::create_proxy (
    int strategy
    TAO_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_CORBA_EnumDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_CORBA_EnumDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_CORBA_EnumDef_Proxy_Broker *
_TAO_CORBA_EnumDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::_TAO_CORBA_EnumDef_Strategized_Proxy_Broker::the_TAO_CORBA_EnumDef_Strategized_Proxy_Broker();
}

int
_TAO_CORBA_EnumDef_Proxy_Broker_Factory_Initializer (long)
{
  _TAO_CORBA_EnumDef_Proxy_Broker_Factory_function_pointer =
    _TAO_CORBA_EnumDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_CORBA_EnumDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_CORBA_EnumDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_CORBA_EnumDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

_TAO_CORBA_EnumDef_ThruPOA_Proxy_Impl::_TAO_CORBA_EnumDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA_EnumMemberSeq * _TAO_CORBA_EnumDef_ThruPOA_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_EnumMemberSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "members",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_EnumDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/EnumDef:1.0"
        )
    )->members (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

void _TAO_CORBA_EnumDef_ThruPOA_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    const CORBA_EnumMemberSeq & members
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "members",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_EnumDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/EnumDef:1.0"
        )
    )->members (
        members
        TAO_ENV_ARG_PARAMETER
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA_EnumDef::POA_CORBA_EnumDef (void)
{
  this->optable_ = &tao_CORBA_EnumDef_optable;
}

// copy ctor
POA_CORBA_EnumDef::POA_CORBA_EnumDef (const POA_CORBA_EnumDef& rhs)
  :   POA_CORBA_TypedefDef (rhs),
    POA_CORBA_Contained (rhs),
    POA_CORBA_IDLType (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA_EnumDef::~POA_CORBA_EnumDef (void)
{
}

void POA_CORBA_EnumDef::_get_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_EnumDef *_tao_impl =
    ACE_static_cast (POA_CORBA_EnumDef *, _tao_object_reference);

    CORBA_EnumMemberSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_EnumDef_members_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->members (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_EnumMemberSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_EnumDef::_set_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_EnumDef *_tao_impl =
    ACE_static_cast (POA_CORBA_EnumDef *, _tao_object_reference);

  _tao_server_request.argument_flag (0);
    CORBA_EnumMemberSeq members;
  if (!(
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_EnumDef_members_set ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      members
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->members (
          members
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_EnumDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_EnumDef *_tao_impl = (POA_CORBA_EnumDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () TAO_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_EnumDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_EnumDef *_tao_impl = (POA_CORBA_EnumDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_EnumDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_EnumDef *_tao_impl = (POA_CORBA_EnumDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_CORBA_EnumDef::_is_a (
    const char* value
    TAO_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/EnumDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA_EnumDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/EnumDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_EnumDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA_EnumDef::_dispatch (TAO_ServerRequest &req, void *servant_upcall TAO_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     TAO_ENV_ARG_PARAMETER);
}


const char* POA_CORBA_EnumDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/EnumDef:1.0";
}

CORBA_EnumDef*
POA_CORBA_EnumDef::_this (TAO_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::CORBA_EnumDef::_unchecked_narrow (obj.in ());
}


class TAO_CORBA_AliasDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:45:30 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_AliasDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_AliasDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0,  0, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0,  0, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_AliasDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 19,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 6,
      WORDLIST_SIZE = 23
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_CORBA_AliasDef::move_skel},
      {"_is_a",  &POA_CORBA_AliasDef::_is_a_skel},
      {"_get_id",       &POA_CORBA_AliasDef::_get_id_skel},
      {"_set_id",       &POA_CORBA_AliasDef::_set_id_skel},
      {"describe",      &POA_CORBA_AliasDef::describe_skel},
      {"_get_name",     &POA_CORBA_AliasDef::_get_name_skel},
      {"_get_type",     &POA_CORBA_AliasDef::_get_type_skel},
      {"_set_name",     &POA_CORBA_AliasDef::_set_name_skel},
      {"_interface",  &POA_CORBA_AliasDef::_interface_skel},
      {"_get_version",  &POA_CORBA_AliasDef::_get_version_skel},
      {"_set_version",  &POA_CORBA_AliasDef::_set_version_skel},
      {"_get_def_kind",         &POA_CORBA_AliasDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_CORBA_AliasDef::_get_defined_in_skel},
      {"destroy",       &POA_CORBA_AliasDef::destroy_skel},
      {"_get_absolute_name",    &POA_CORBA_AliasDef::_get_absolute_name_skel},
      {"_get_original_type_def",        &POA_CORBA_AliasDef::_get_original_type_def_skel},
      {"_set_original_type_def",        &POA_CORBA_AliasDef::_set_original_type_def_skel},
      {"_non_existent",  &POA_CORBA_AliasDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_CORBA_AliasDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -9,  -3, -13,  -2,   4,   5,  -1,  53,   8, -45,  12,  -1, -46,  15,
       -1,  16,  -1,  17,  18,  -1, -19,  -2, -38,  21,  -6,  -2,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  22,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:45:30 */
static TAO_CORBA_AliasDef_Perfect_Hash_OpTable tao_CORBA_AliasDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_CORBA_AliasDef_original_type_def_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_AliasDef_original_type_def_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_AliasDef *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_IDLType_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_AliasDef_original_type_def_get (const TAO_ServerRequestInfo_CORBA_AliasDef_original_type_def_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_AliasDef_original_type_def_get &);

private:
  POA_CORBA_AliasDef *_tao_impl;
  CORBA_IDLType_ptr _result;
};

TAO_ServerRequestInfo_CORBA_AliasDef_original_type_def_get::TAO_ServerRequestInfo_CORBA_AliasDef_original_type_def_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_AliasDef *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_AliasDef_original_type_def_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_AliasDef_original_type_def_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_AliasDef_original_type_def_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_AliasDef_original_type_def_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_AliasDef_original_type_def_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_AliasDef_original_type_def_get::result (CORBA_IDLType_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_AliasDef_original_type_def_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_AliasDef_original_type_def_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_AliasDef *tao_impl
    ,
    CORBA_IDLType_ptr original_type_def
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));


private:
  TAO_ServerRequestInfo_CORBA_AliasDef_original_type_def_set (const TAO_ServerRequestInfo_CORBA_AliasDef_original_type_def_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_AliasDef_original_type_def_set &);

private:
  POA_CORBA_AliasDef *_tao_impl;
  CORBA_IDLType_ptr original_type_def_;

};

TAO_ServerRequestInfo_CORBA_AliasDef_original_type_def_set::TAO_ServerRequestInfo_CORBA_AliasDef_original_type_def_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_AliasDef *tao_impl,
    CORBA_IDLType_ptr original_type_def
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    original_type_def_ (original_type_def)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_AliasDef_original_type_def_set::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->original_type_def_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_AliasDef_original_type_def_set::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_AliasDef_original_type_def_set::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_AliasDef_original_type_def_set::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_AliasDef_original_type_def_set::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
_TAO_CORBA_AliasDef_Strategized_Proxy_Broker *_TAO_CORBA_AliasDef_Strategized_Proxy_Broker::the_TAO_CORBA_AliasDef_Strategized_Proxy_Broker (void)
{
  static _TAO_CORBA_AliasDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_CORBA_AliasDef_Strategized_Proxy_Broker::_TAO_CORBA_AliasDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

_TAO_CORBA_AliasDef_Strategized_Proxy_Broker::~_TAO_CORBA_AliasDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_CORBA_AliasDef_Proxy_Impl&
_TAO_CORBA_AliasDef_Strategized_Proxy_Broker::select_proxy (
    ::CORBA_AliasDef *object
    TAO_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
_TAO_CORBA_AliasDef_Strategized_Proxy_Broker::create_proxy (
    int strategy
    TAO_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_CORBA_AliasDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_CORBA_AliasDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_CORBA_AliasDef_Proxy_Broker *
_TAO_CORBA_AliasDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::_TAO_CORBA_AliasDef_Strategized_Proxy_Broker::the_TAO_CORBA_AliasDef_Strategized_Proxy_Broker();
}

int
_TAO_CORBA_AliasDef_Proxy_Broker_Factory_Initializer (long)
{
  _TAO_CORBA_AliasDef_Proxy_Broker_Factory_function_pointer =
    _TAO_CORBA_AliasDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_CORBA_AliasDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_CORBA_AliasDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_CORBA_AliasDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

_TAO_CORBA_AliasDef_ThruPOA_Proxy_Impl::_TAO_CORBA_AliasDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA_IDLType_ptr _TAO_CORBA_AliasDef_ThruPOA_Proxy_Impl::original_type_def (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "original_type_def",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_AliasDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/AliasDef:1.0"
        )
    )->original_type_def (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

void _TAO_CORBA_AliasDef_ThruPOA_Proxy_Impl::original_type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA_IDLType_ptr original_type_def
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "original_type_def",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_AliasDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/AliasDef:1.0"
        )
    )->original_type_def (
        original_type_def
        TAO_ENV_ARG_PARAMETER
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA_AliasDef::POA_CORBA_AliasDef (void)
{
  this->optable_ = &tao_CORBA_AliasDef_optable;
}

// copy ctor
POA_CORBA_AliasDef::POA_CORBA_AliasDef (const POA_CORBA_AliasDef& rhs)
  :   POA_CORBA_TypedefDef (rhs),
    POA_CORBA_Contained (rhs),
    POA_CORBA_IDLType (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA_AliasDef::~POA_CORBA_AliasDef (void)
{
}

void POA_CORBA_AliasDef::_get_original_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_AliasDef *_tao_impl =
    ACE_static_cast (POA_CORBA_AliasDef *, _tao_object_reference);

    CORBA_IDLType_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_AliasDef_original_type_def_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->original_type_def (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_IDLType_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_AliasDef::_set_original_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_AliasDef *_tao_impl =
    ACE_static_cast (POA_CORBA_AliasDef *, _tao_object_reference);

  _tao_server_request.argument_flag (0);
    CORBA_IDLType_var original_type_def;
  if (!(
    (_tao_in >> original_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_AliasDef_original_type_def_set ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      original_type_def.in ()
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->original_type_def (
          original_type_def.in ()
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_AliasDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_AliasDef *_tao_impl = (POA_CORBA_AliasDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () TAO_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_AliasDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_AliasDef *_tao_impl = (POA_CORBA_AliasDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_AliasDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_AliasDef *_tao_impl = (POA_CORBA_AliasDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_CORBA_AliasDef::_is_a (
    const char* value
    TAO_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/AliasDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA_AliasDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/AliasDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_AliasDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA_AliasDef::_dispatch (TAO_ServerRequest &req, void *servant_upcall TAO_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     TAO_ENV_ARG_PARAMETER);
}


const char* POA_CORBA_AliasDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/AliasDef:1.0";
}

CORBA_AliasDef*
POA_CORBA_AliasDef::_this (TAO_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::CORBA_AliasDef::_unchecked_narrow (obj.in ());
}


class TAO_CORBA_NativeDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:45:31 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_NativeDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_NativeDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_NativeDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 17,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 5,
      WORDLIST_SIZE = 21
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_CORBA_NativeDef::move_skel},
      {"_is_a",  &POA_CORBA_NativeDef::_is_a_skel},
      {"_get_id",       &POA_CORBA_NativeDef::_get_id_skel},
      {"_set_id",       &POA_CORBA_NativeDef::_set_id_skel},
      {"describe",      &POA_CORBA_NativeDef::describe_skel},
      {"_get_name",     &POA_CORBA_NativeDef::_get_name_skel},
      {"_get_type",     &POA_CORBA_NativeDef::_get_type_skel},
      {"_set_name",     &POA_CORBA_NativeDef::_set_name_skel},
      {"_interface",  &POA_CORBA_NativeDef::_interface_skel},
      {"_get_version",  &POA_CORBA_NativeDef::_get_version_skel},
      {"_set_version",  &POA_CORBA_NativeDef::_set_version_skel},
      {"_get_def_kind",         &POA_CORBA_NativeDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_CORBA_NativeDef::_get_defined_in_skel},
      {"destroy",       &POA_CORBA_NativeDef::destroy_skel},
      {"_get_absolute_name",    &POA_CORBA_NativeDef::_get_absolute_name_skel},
      {"_non_existent",  &POA_CORBA_NativeDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_CORBA_NativeDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -9,  -3, -13,  -2,   4,   5,  -1,  48,   8, -45,  12,  -1, -46,  15,
       -1,  16,  -1,  17,  18,  -6,  -2,  -1,  -1,  19,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  20,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:45:31 */
static TAO_CORBA_NativeDef_Perfect_Hash_OpTable tao_CORBA_NativeDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
_TAO_CORBA_NativeDef_Strategized_Proxy_Broker *_TAO_CORBA_NativeDef_Strategized_Proxy_Broker::the_TAO_CORBA_NativeDef_Strategized_Proxy_Broker (void)
{
  static _TAO_CORBA_NativeDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_CORBA_NativeDef_Strategized_Proxy_Broker::_TAO_CORBA_NativeDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

_TAO_CORBA_NativeDef_Strategized_Proxy_Broker::~_TAO_CORBA_NativeDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_CORBA_NativeDef_Proxy_Impl&
_TAO_CORBA_NativeDef_Strategized_Proxy_Broker::select_proxy (
    ::CORBA_NativeDef *object
    TAO_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
_TAO_CORBA_NativeDef_Strategized_Proxy_Broker::create_proxy (
    int strategy
    TAO_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_CORBA_NativeDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_CORBA_NativeDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_CORBA_NativeDef_Proxy_Broker *
_TAO_CORBA_NativeDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::_TAO_CORBA_NativeDef_Strategized_Proxy_Broker::the_TAO_CORBA_NativeDef_Strategized_Proxy_Broker();
}

int
_TAO_CORBA_NativeDef_Proxy_Broker_Factory_Initializer (long)
{
  _TAO_CORBA_NativeDef_Proxy_Broker_Factory_function_pointer =
    _TAO_CORBA_NativeDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_CORBA_NativeDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_CORBA_NativeDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_CORBA_NativeDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

_TAO_CORBA_NativeDef_ThruPOA_Proxy_Impl::_TAO_CORBA_NativeDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA_NativeDef::POA_CORBA_NativeDef (void)
{
  this->optable_ = &tao_CORBA_NativeDef_optable;
}

// copy ctor
POA_CORBA_NativeDef::POA_CORBA_NativeDef (const POA_CORBA_NativeDef& rhs)
  :   POA_CORBA_TypedefDef (rhs),
    POA_CORBA_Contained (rhs),
    POA_CORBA_IDLType (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA_NativeDef::~POA_CORBA_NativeDef (void)
{
}

void POA_CORBA_NativeDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_NativeDef *_tao_impl = (POA_CORBA_NativeDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () TAO_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_NativeDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_NativeDef *_tao_impl = (POA_CORBA_NativeDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_NativeDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_NativeDef *_tao_impl = (POA_CORBA_NativeDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_CORBA_NativeDef::_is_a (
    const char* value
    TAO_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/NativeDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA_NativeDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/NativeDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_NativeDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA_NativeDef::_dispatch (TAO_ServerRequest &req, void *servant_upcall TAO_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     TAO_ENV_ARG_PARAMETER);
}


const char* POA_CORBA_NativeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/NativeDef:1.0";
}

CORBA_NativeDef*
POA_CORBA_NativeDef::_this (TAO_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::CORBA_NativeDef::_unchecked_narrow (obj.in ());
}


class TAO_CORBA_PrimitiveDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:45:31 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_PrimitiveDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_PrimitiveDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  5, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  5, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_PrimitiveDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 7,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 0,
      WORDLIST_SIZE = 12
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_CORBA_PrimitiveDef::_is_a_skel},
      {"",0},
      {"destroy",       &POA_CORBA_PrimitiveDef::destroy_skel},
      {"",0},
      {"_get_kind",     &POA_CORBA_PrimitiveDef::_get_kind_skel},
      {"",0},{"",0},{"",0},
      {"_get_def_kind",         &POA_CORBA_PrimitiveDef::_get_def_kind_skel},
      {"_get_type",     &POA_CORBA_PrimitiveDef::_get_type_skel},
      {"_interface",  &POA_CORBA_PrimitiveDef::_interface_skel},
      {"",0},{"",0},
      {"_non_existent",  &POA_CORBA_PrimitiveDef::_non_existent_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 22:45:31 */
static TAO_CORBA_PrimitiveDef_Perfect_Hash_OpTable tao_CORBA_PrimitiveDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_CORBA_PrimitiveDef_kind_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_PrimitiveDef_kind_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_PrimitiveDef *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::PrimitiveKind result);

private:
  TAO_ServerRequestInfo_CORBA_PrimitiveDef_kind_get (const TAO_ServerRequestInfo_CORBA_PrimitiveDef_kind_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_PrimitiveDef_kind_get &);

private:
  POA_CORBA_PrimitiveDef *_tao_impl;
  CORBA::PrimitiveKind _result;
};

TAO_ServerRequestInfo_CORBA_PrimitiveDef_kind_get::TAO_ServerRequestInfo_CORBA_PrimitiveDef_kind_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_PrimitiveDef *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_PrimitiveDef_kind_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_PrimitiveDef_kind_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_PrimitiveDef_kind_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_PrimitiveDef_kind_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_PrimitiveDef_kind_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_PrimitiveDef_kind_get::result (CORBA::PrimitiveKind result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
_TAO_CORBA_PrimitiveDef_Strategized_Proxy_Broker *_TAO_CORBA_PrimitiveDef_Strategized_Proxy_Broker::the_TAO_CORBA_PrimitiveDef_Strategized_Proxy_Broker (void)
{
  static _TAO_CORBA_PrimitiveDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_CORBA_PrimitiveDef_Strategized_Proxy_Broker::_TAO_CORBA_PrimitiveDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

_TAO_CORBA_PrimitiveDef_Strategized_Proxy_Broker::~_TAO_CORBA_PrimitiveDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_CORBA_PrimitiveDef_Proxy_Impl&
_TAO_CORBA_PrimitiveDef_Strategized_Proxy_Broker::select_proxy (
    ::CORBA_PrimitiveDef *object
    TAO_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
_TAO_CORBA_PrimitiveDef_Strategized_Proxy_Broker::create_proxy (
    int strategy
    TAO_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_CORBA_PrimitiveDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_CORBA_PrimitiveDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_CORBA_PrimitiveDef_Proxy_Broker *
_TAO_CORBA_PrimitiveDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::_TAO_CORBA_PrimitiveDef_Strategized_Proxy_Broker::the_TAO_CORBA_PrimitiveDef_Strategized_Proxy_Broker();
}

int
_TAO_CORBA_PrimitiveDef_Proxy_Broker_Factory_Initializer (long)
{
  _TAO_CORBA_PrimitiveDef_Proxy_Broker_Factory_function_pointer =
    _TAO_CORBA_PrimitiveDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_CORBA_PrimitiveDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_CORBA_PrimitiveDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_CORBA_PrimitiveDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

_TAO_CORBA_PrimitiveDef_ThruPOA_Proxy_Impl::_TAO_CORBA_PrimitiveDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::PrimitiveKind _TAO_CORBA_PrimitiveDef_ThruPOA_Proxy_Impl::kind (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::PrimitiveKind _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "kind",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_CORBA_PrimitiveDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/PrimitiveDef:1.0"
        )
    )->kind (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA_PrimitiveDef::POA_CORBA_PrimitiveDef (void)
{
  this->optable_ = &tao_CORBA_PrimitiveDef_optable;
}

// copy ctor
POA_CORBA_PrimitiveDef::POA_CORBA_PrimitiveDef (const POA_CORBA_PrimitiveDef& rhs)
  :   POA_CORBA_IDLType (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA_PrimitiveDef::~POA_CORBA_PrimitiveDef (void)
{
}

void POA_CORBA_PrimitiveDef::_get_kind_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_PrimitiveDef *_tao_impl =
    ACE_static_cast (POA_CORBA_PrimitiveDef *, _tao_object_reference);

    CORBA::PrimitiveKind _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_PrimitiveDef_kind_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->kind (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::PrimitiveKind _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval)
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_PrimitiveDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_PrimitiveDef *_tao_impl = (POA_CORBA_PrimitiveDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () TAO_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_PrimitiveDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_PrimitiveDef *_tao_impl = (POA_CORBA_PrimitiveDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_PrimitiveDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_PrimitiveDef *_tao_impl = (POA_CORBA_PrimitiveDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_CORBA_PrimitiveDef::_is_a (
    const char* value
    TAO_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/PrimitiveDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA_PrimitiveDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/PrimitiveDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_PrimitiveDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA_PrimitiveDef::_dispatch (TAO_ServerRequest &req, void *servant_upcall TAO_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     TAO_ENV_ARG_PARAMETER);
}


const char* POA_CORBA_PrimitiveDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/PrimitiveDef:1.0";
}

CORBA_PrimitiveDef*
POA_CORBA_PrimitiveDef::_this (TAO_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::CORBA_PrimitiveDef::_unchecked_narrow (obj.in ());
}


class TAO_CORBA_StringDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:45:32 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_StringDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_StringDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  5, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  5, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_StringDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 8,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 2,
      WORDLIST_SIZE = 13
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_CORBA_StringDef::_is_a_skel},
      {"destroy",       &POA_CORBA_StringDef::destroy_skel},
      {"_get_bound",    &POA_CORBA_StringDef::_get_bound_skel},
      {"_set_bound",    &POA_CORBA_StringDef::_set_bound_skel},
      {"_get_def_kind",         &POA_CORBA_StringDef::_get_def_kind_skel},
      {"_get_type",     &POA_CORBA_StringDef::_get_type_skel},
      {"_interface",  &POA_CORBA_StringDef::_interface_skel},
      {"_non_existent",  &POA_CORBA_StringDef::_non_existent_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,   5,  -1,   6,  -7,  -2, -20,  -1,  -1,   9,
       10,  11,  -1,  -1,  12,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:45:32 */
static TAO_CORBA_StringDef_Perfect_Hash_OpTable tao_CORBA_StringDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_CORBA_StringDef_bound_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_StringDef_bound_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_StringDef *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::ULong result);

private:
  TAO_ServerRequestInfo_CORBA_StringDef_bound_get (const TAO_ServerRequestInfo_CORBA_StringDef_bound_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_StringDef_bound_get &);

private:
  POA_CORBA_StringDef *_tao_impl;
  CORBA::ULong _result;
};

TAO_ServerRequestInfo_CORBA_StringDef_bound_get::TAO_ServerRequestInfo_CORBA_StringDef_bound_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_StringDef *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_StringDef_bound_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_StringDef_bound_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_StringDef_bound_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_StringDef_bound_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_StringDef_bound_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_StringDef_bound_get::result (CORBA::ULong result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_StringDef_bound_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_StringDef_bound_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_StringDef *tao_impl
    ,
    const CORBA::ULong & bound
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));


private:
  TAO_ServerRequestInfo_CORBA_StringDef_bound_set (const TAO_ServerRequestInfo_CORBA_StringDef_bound_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_StringDef_bound_set &);

private:
  POA_CORBA_StringDef *_tao_impl;
  const CORBA::ULong & bound_;

};

TAO_ServerRequestInfo_CORBA_StringDef_bound_set::TAO_ServerRequestInfo_CORBA_StringDef_bound_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_StringDef *tao_impl,
    const CORBA::ULong & bound
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    bound_ (bound)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_StringDef_bound_set::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= bound_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_StringDef_bound_set::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_StringDef_bound_set::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_StringDef_bound_set::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_StringDef_bound_set::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
_TAO_CORBA_StringDef_Strategized_Proxy_Broker *_TAO_CORBA_StringDef_Strategized_Proxy_Broker::the_TAO_CORBA_StringDef_Strategized_Proxy_Broker (void)
{
  static _TAO_CORBA_StringDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_CORBA_StringDef_Strategized_Proxy_Broker::_TAO_CORBA_StringDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

_TAO_CORBA_StringDef_Strategized_Proxy_Broker::~_TAO_CORBA_StringDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_CORBA_StringDef_Proxy_Impl&
_TAO_CORBA_StringDef_Strategized_Proxy_Broker::select_proxy (
    ::CORBA_StringDef *object
    TAO_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
_TAO_CORBA_StringDef_Strategized_Proxy_Broker::create_proxy (
    int strategy
    TAO_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_CORBA_StringDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_CORBA_StringDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_CORBA_StringDef_Proxy_Broker *
_TAO_CORBA_StringDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::_TAO_CORBA_StringDef_Strategized_Proxy_Broker::the_TAO_CORBA_StringDef_Strategized_Proxy_Broker();
}

int
_TAO_CORBA_StringDef_Proxy_Broker_Factory_Initializer (long)
{
  _TAO_CORBA_StringDef_Proxy_Broker_Factory_function_pointer =
    _TAO_CORBA_StringDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_CORBA_StringDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_CORBA_StringDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_CORBA_StringDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

_TAO_CORBA_StringDef_ThruPOA_Proxy_Impl::_TAO_CORBA_StringDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::ULong _TAO_CORBA_StringDef_ThruPOA_Proxy_Impl::bound (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::ULong _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "bound",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_CORBA_StringDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/StringDef:1.0"
        )
    )->bound (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

void _TAO_CORBA_StringDef_ThruPOA_Proxy_Impl::bound (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong bound
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "bound",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_StringDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/StringDef:1.0"
        )
    )->bound (
        bound
        TAO_ENV_ARG_PARAMETER
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA_StringDef::POA_CORBA_StringDef (void)
{
  this->optable_ = &tao_CORBA_StringDef_optable;
}

// copy ctor
POA_CORBA_StringDef::POA_CORBA_StringDef (const POA_CORBA_StringDef& rhs)
  :   POA_CORBA_IDLType (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA_StringDef::~POA_CORBA_StringDef (void)
{
}

void POA_CORBA_StringDef::_get_bound_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_StringDef *_tao_impl =
    ACE_static_cast (POA_CORBA_StringDef *, _tao_object_reference);

    CORBA::ULong _tao_retval = 0;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_StringDef_bound_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->bound (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::ULong _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval)
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_StringDef::_set_bound_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_StringDef *_tao_impl =
    ACE_static_cast (POA_CORBA_StringDef *, _tao_object_reference);

  _tao_server_request.argument_flag (0);
    CORBA::ULong bound;
  if (!(
    (_tao_in >> bound)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_StringDef_bound_set ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      bound
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->bound (
          bound
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_StringDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_StringDef *_tao_impl = (POA_CORBA_StringDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () TAO_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_StringDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_StringDef *_tao_impl = (POA_CORBA_StringDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_StringDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_StringDef *_tao_impl = (POA_CORBA_StringDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_CORBA_StringDef::_is_a (
    const char* value
    TAO_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/StringDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA_StringDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/StringDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_StringDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA_StringDef::_dispatch (TAO_ServerRequest &req, void *servant_upcall TAO_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     TAO_ENV_ARG_PARAMETER);
}


const char* POA_CORBA_StringDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/StringDef:1.0";
}

CORBA_StringDef*
POA_CORBA_StringDef::_this (TAO_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::CORBA_StringDef::_unchecked_narrow (obj.in ());
}


class TAO_CORBA_WstringDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:45:32 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_WstringDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_WstringDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  5, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  5, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_WstringDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 8,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 2,
      WORDLIST_SIZE = 13
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_CORBA_WstringDef::_is_a_skel},
      {"destroy",       &POA_CORBA_WstringDef::destroy_skel},
      {"_get_bound",    &POA_CORBA_WstringDef::_get_bound_skel},
      {"_set_bound",    &POA_CORBA_WstringDef::_set_bound_skel},
      {"_get_def_kind",         &POA_CORBA_WstringDef::_get_def_kind_skel},
      {"_get_type",     &POA_CORBA_WstringDef::_get_type_skel},
      {"_interface",  &POA_CORBA_WstringDef::_interface_skel},
      {"_non_existent",  &POA_CORBA_WstringDef::_non_existent_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,   5,  -1,   6,  -7,  -2, -20,  -1,  -1,   9,
       10,  11,  -1,  -1,  12,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:45:33 */
static TAO_CORBA_WstringDef_Perfect_Hash_OpTable tao_CORBA_WstringDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_CORBA_WstringDef_bound_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_WstringDef_bound_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_WstringDef *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::ULong result);

private:
  TAO_ServerRequestInfo_CORBA_WstringDef_bound_get (const TAO_ServerRequestInfo_CORBA_WstringDef_bound_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_WstringDef_bound_get &);

private:
  POA_CORBA_WstringDef *_tao_impl;
  CORBA::ULong _result;
};

TAO_ServerRequestInfo_CORBA_WstringDef_bound_get::TAO_ServerRequestInfo_CORBA_WstringDef_bound_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_WstringDef *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_WstringDef_bound_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_WstringDef_bound_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_WstringDef_bound_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_WstringDef_bound_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_WstringDef_bound_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_WstringDef_bound_get::result (CORBA::ULong result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_WstringDef_bound_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_WstringDef_bound_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_WstringDef *tao_impl
    ,
    const CORBA::ULong & bound
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));


private:
  TAO_ServerRequestInfo_CORBA_WstringDef_bound_set (const TAO_ServerRequestInfo_CORBA_WstringDef_bound_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_WstringDef_bound_set &);

private:
  POA_CORBA_WstringDef *_tao_impl;
  const CORBA::ULong & bound_;

};

TAO_ServerRequestInfo_CORBA_WstringDef_bound_set::TAO_ServerRequestInfo_CORBA_WstringDef_bound_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_WstringDef *tao_impl,
    const CORBA::ULong & bound
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    bound_ (bound)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_WstringDef_bound_set::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= bound_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_WstringDef_bound_set::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_WstringDef_bound_set::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_WstringDef_bound_set::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_WstringDef_bound_set::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
_TAO_CORBA_WstringDef_Strategized_Proxy_Broker *_TAO_CORBA_WstringDef_Strategized_Proxy_Broker::the_TAO_CORBA_WstringDef_Strategized_Proxy_Broker (void)
{
  static _TAO_CORBA_WstringDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_CORBA_WstringDef_Strategized_Proxy_Broker::_TAO_CORBA_WstringDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

_TAO_CORBA_WstringDef_Strategized_Proxy_Broker::~_TAO_CORBA_WstringDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_CORBA_WstringDef_Proxy_Impl&
_TAO_CORBA_WstringDef_Strategized_Proxy_Broker::select_proxy (
    ::CORBA_WstringDef *object
    TAO_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
_TAO_CORBA_WstringDef_Strategized_Proxy_Broker::create_proxy (
    int strategy
    TAO_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_CORBA_WstringDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_CORBA_WstringDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_CORBA_WstringDef_Proxy_Broker *
_TAO_CORBA_WstringDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::_TAO_CORBA_WstringDef_Strategized_Proxy_Broker::the_TAO_CORBA_WstringDef_Strategized_Proxy_Broker();
}

int
_TAO_CORBA_WstringDef_Proxy_Broker_Factory_Initializer (long)
{
  _TAO_CORBA_WstringDef_Proxy_Broker_Factory_function_pointer =
    _TAO_CORBA_WstringDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_CORBA_WstringDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_CORBA_WstringDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_CORBA_WstringDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

_TAO_CORBA_WstringDef_ThruPOA_Proxy_Impl::_TAO_CORBA_WstringDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::ULong _TAO_CORBA_WstringDef_ThruPOA_Proxy_Impl::bound (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::ULong _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "bound",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_CORBA_WstringDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/WstringDef:1.0"
        )
    )->bound (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

void _TAO_CORBA_WstringDef_ThruPOA_Proxy_Impl::bound (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong bound
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "bound",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_WstringDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/WstringDef:1.0"
        )
    )->bound (
        bound
        TAO_ENV_ARG_PARAMETER
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA_WstringDef::POA_CORBA_WstringDef (void)
{
  this->optable_ = &tao_CORBA_WstringDef_optable;
}

// copy ctor
POA_CORBA_WstringDef::POA_CORBA_WstringDef (const POA_CORBA_WstringDef& rhs)
  :   POA_CORBA_IDLType (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA_WstringDef::~POA_CORBA_WstringDef (void)
{
}

void POA_CORBA_WstringDef::_get_bound_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_WstringDef *_tao_impl =
    ACE_static_cast (POA_CORBA_WstringDef *, _tao_object_reference);

    CORBA::ULong _tao_retval = 0;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_WstringDef_bound_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->bound (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::ULong _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval)
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_WstringDef::_set_bound_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_WstringDef *_tao_impl =
    ACE_static_cast (POA_CORBA_WstringDef *, _tao_object_reference);

  _tao_server_request.argument_flag (0);
    CORBA::ULong bound;
  if (!(
    (_tao_in >> bound)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_WstringDef_bound_set ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      bound
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->bound (
          bound
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_WstringDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_WstringDef *_tao_impl = (POA_CORBA_WstringDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () TAO_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_WstringDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_WstringDef *_tao_impl = (POA_CORBA_WstringDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_WstringDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_WstringDef *_tao_impl = (POA_CORBA_WstringDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_CORBA_WstringDef::_is_a (
    const char* value
    TAO_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/WstringDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA_WstringDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/WstringDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_WstringDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA_WstringDef::_dispatch (TAO_ServerRequest &req, void *servant_upcall TAO_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     TAO_ENV_ARG_PARAMETER);
}


const char* POA_CORBA_WstringDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/WstringDef:1.0";
}

CORBA_WstringDef*
POA_CORBA_WstringDef::_this (TAO_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::CORBA_WstringDef::_unchecked_narrow (obj.in ());
}


class TAO_CORBA_SequenceDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:45:34 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_SequenceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_SequenceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23,  0,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23,  0,
     23, 23,  0,  5,  0, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23,  5, 23, 23, 23, 23,  0, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23,
#else
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23,  0, 23,  0, 23, 23,
      0,  5,  0, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23,  5, 23, 23, 23,
     23,  0, 23, 23, 23, 23, 23, 23,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_SequenceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 11,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 21,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 22,
      HASH_VALUE_RANGE = 18,
      DUPLICATES = 3,
      WORDLIST_SIZE = 16
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_CORBA_SequenceDef::_is_a_skel},
      {"destroy",       &POA_CORBA_SequenceDef::destroy_skel},
      {"_get_bound",    &POA_CORBA_SequenceDef::_get_bound_skel},
      {"_set_bound",    &POA_CORBA_SequenceDef::_set_bound_skel},
      {"_get_def_kind",         &POA_CORBA_SequenceDef::_get_def_kind_skel},
      {"_get_type",     &POA_CORBA_SequenceDef::_get_type_skel},
      {"_interface",  &POA_CORBA_SequenceDef::_interface_skel},
      {"_non_existent",  &POA_CORBA_SequenceDef::_non_existent_skel},
      {"_get_element_type_def",         &POA_CORBA_SequenceDef::_get_element_type_def_skel},
      {"_set_element_type_def",         &POA_CORBA_SequenceDef::_set_element_type_def_skel},
      {"_get_element_type",     &POA_CORBA_SequenceDef::_get_element_type_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,   5,  -1,   6,  -7,  -2, -24,  -1,  -1,   9,
       10,  11,  -1,  -1,  12, -13,  -2, -24,  15,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:45:34 */
static TAO_CORBA_SequenceDef_Perfect_Hash_OpTable tao_CORBA_SequenceDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_CORBA_SequenceDef_bound_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_SequenceDef_bound_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_SequenceDef *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::ULong result);

private:
  TAO_ServerRequestInfo_CORBA_SequenceDef_bound_get (const TAO_ServerRequestInfo_CORBA_SequenceDef_bound_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_SequenceDef_bound_get &);

private:
  POA_CORBA_SequenceDef *_tao_impl;
  CORBA::ULong _result;
};

TAO_ServerRequestInfo_CORBA_SequenceDef_bound_get::TAO_ServerRequestInfo_CORBA_SequenceDef_bound_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_SequenceDef *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_SequenceDef_bound_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_SequenceDef_bound_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_SequenceDef_bound_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_SequenceDef_bound_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_SequenceDef_bound_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_SequenceDef_bound_get::result (CORBA::ULong result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_SequenceDef_bound_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_SequenceDef_bound_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_SequenceDef *tao_impl
    ,
    const CORBA::ULong & bound
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));


private:
  TAO_ServerRequestInfo_CORBA_SequenceDef_bound_set (const TAO_ServerRequestInfo_CORBA_SequenceDef_bound_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_SequenceDef_bound_set &);

private:
  POA_CORBA_SequenceDef *_tao_impl;
  const CORBA::ULong & bound_;

};

TAO_ServerRequestInfo_CORBA_SequenceDef_bound_set::TAO_ServerRequestInfo_CORBA_SequenceDef_bound_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_SequenceDef *tao_impl,
    const CORBA::ULong & bound
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    bound_ (bound)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_SequenceDef_bound_set::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= bound_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_SequenceDef_bound_set::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_SequenceDef_bound_set::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_SequenceDef_bound_set::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_SequenceDef_bound_set::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_SequenceDef *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::TypeCode_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_get (const TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_get &);

private:
  POA_CORBA_SequenceDef *_tao_impl;
  CORBA::TypeCode_ptr _result;
};

TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_get::TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_SequenceDef *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_get::result (CORBA::TypeCode_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_def_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_def_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_SequenceDef *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_IDLType_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_def_get (const TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_def_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_def_get &);

private:
  POA_CORBA_SequenceDef *_tao_impl;
  CORBA_IDLType_ptr _result;
};

TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_def_get::TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_def_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_SequenceDef *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_def_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_def_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_def_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_def_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_def_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_def_get::result (CORBA_IDLType_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_def_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_def_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_SequenceDef *tao_impl
    ,
    CORBA_IDLType_ptr element_type_def
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));


private:
  TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_def_set (const TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_def_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_def_set &);

private:
  POA_CORBA_SequenceDef *_tao_impl;
  CORBA_IDLType_ptr element_type_def_;

};

TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_def_set::TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_def_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_SequenceDef *tao_impl,
    CORBA_IDLType_ptr element_type_def
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    element_type_def_ (element_type_def)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_def_set::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->element_type_def_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_def_set::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_def_set::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_def_set::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_def_set::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
_TAO_CORBA_SequenceDef_Strategized_Proxy_Broker *_TAO_CORBA_SequenceDef_Strategized_Proxy_Broker::the_TAO_CORBA_SequenceDef_Strategized_Proxy_Broker (void)
{
  static _TAO_CORBA_SequenceDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_CORBA_SequenceDef_Strategized_Proxy_Broker::_TAO_CORBA_SequenceDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

_TAO_CORBA_SequenceDef_Strategized_Proxy_Broker::~_TAO_CORBA_SequenceDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_CORBA_SequenceDef_Proxy_Impl&
_TAO_CORBA_SequenceDef_Strategized_Proxy_Broker::select_proxy (
    ::CORBA_SequenceDef *object
    TAO_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
_TAO_CORBA_SequenceDef_Strategized_Proxy_Broker::create_proxy (
    int strategy
    TAO_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_CORBA_SequenceDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_CORBA_SequenceDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_CORBA_SequenceDef_Proxy_Broker *
_TAO_CORBA_SequenceDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::_TAO_CORBA_SequenceDef_Strategized_Proxy_Broker::the_TAO_CORBA_SequenceDef_Strategized_Proxy_Broker();
}

int
_TAO_CORBA_SequenceDef_Proxy_Broker_Factory_Initializer (long)
{
  _TAO_CORBA_SequenceDef_Proxy_Broker_Factory_function_pointer =
    _TAO_CORBA_SequenceDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_CORBA_SequenceDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_CORBA_SequenceDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_CORBA_SequenceDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

_TAO_CORBA_SequenceDef_ThruPOA_Proxy_Impl::_TAO_CORBA_SequenceDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::ULong _TAO_CORBA_SequenceDef_ThruPOA_Proxy_Impl::bound (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::ULong _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "bound",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_CORBA_SequenceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/SequenceDef:1.0"
        )
    )->bound (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

void _TAO_CORBA_SequenceDef_ThruPOA_Proxy_Impl::bound (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong bound
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "bound",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_SequenceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/SequenceDef:1.0"
        )
    )->bound (
        bound
        TAO_ENV_ARG_PARAMETER
      );
  return;
}

CORBA::TypeCode_ptr _TAO_CORBA_SequenceDef_ThruPOA_Proxy_Impl::element_type (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "element_type",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_SequenceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/SequenceDef:1.0"
        )
    )->element_type (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

CORBA_IDLType_ptr _TAO_CORBA_SequenceDef_ThruPOA_Proxy_Impl::element_type_def (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "element_type_def",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_SequenceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/SequenceDef:1.0"
        )
    )->element_type_def (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

void _TAO_CORBA_SequenceDef_ThruPOA_Proxy_Impl::element_type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA_IDLType_ptr element_type_def
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "element_type_def",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_SequenceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/SequenceDef:1.0"
        )
    )->element_type_def (
        element_type_def
        TAO_ENV_ARG_PARAMETER
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA_SequenceDef::POA_CORBA_SequenceDef (void)
{
  this->optable_ = &tao_CORBA_SequenceDef_optable;
}

// copy ctor
POA_CORBA_SequenceDef::POA_CORBA_SequenceDef (const POA_CORBA_SequenceDef& rhs)
  :   POA_CORBA_IDLType (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA_SequenceDef::~POA_CORBA_SequenceDef (void)
{
}

void POA_CORBA_SequenceDef::_get_bound_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_SequenceDef *_tao_impl =
    ACE_static_cast (POA_CORBA_SequenceDef *, _tao_object_reference);

    CORBA::ULong _tao_retval = 0;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_SequenceDef_bound_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->bound (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::ULong _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval)
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_SequenceDef::_set_bound_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_SequenceDef *_tao_impl =
    ACE_static_cast (POA_CORBA_SequenceDef *, _tao_object_reference);

  _tao_server_request.argument_flag (0);
    CORBA::ULong bound;
  if (!(
    (_tao_in >> bound)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_SequenceDef_bound_set ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      bound
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->bound (
          bound
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_SequenceDef::_get_element_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_SequenceDef *_tao_impl =
    ACE_static_cast (POA_CORBA_SequenceDef *, _tao_object_reference);

    CORBA::TypeCode_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->element_type (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::TypeCode_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_SequenceDef::_get_element_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_SequenceDef *_tao_impl =
    ACE_static_cast (POA_CORBA_SequenceDef *, _tao_object_reference);

    CORBA_IDLType_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_def_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->element_type_def (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_IDLType_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_SequenceDef::_set_element_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_SequenceDef *_tao_impl =
    ACE_static_cast (POA_CORBA_SequenceDef *, _tao_object_reference);

  _tao_server_request.argument_flag (0);
    CORBA_IDLType_var element_type_def;
  if (!(
    (_tao_in >> element_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_SequenceDef_element_type_def_set ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      element_type_def.in ()
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->element_type_def (
          element_type_def.in ()
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_SequenceDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_SequenceDef *_tao_impl = (POA_CORBA_SequenceDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () TAO_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_SequenceDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_SequenceDef *_tao_impl = (POA_CORBA_SequenceDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_SequenceDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_SequenceDef *_tao_impl = (POA_CORBA_SequenceDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_CORBA_SequenceDef::_is_a (
    const char* value
    TAO_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/SequenceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA_SequenceDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/SequenceDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_SequenceDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA_SequenceDef::_dispatch (TAO_ServerRequest &req, void *servant_upcall TAO_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     TAO_ENV_ARG_PARAMETER);
}


const char* POA_CORBA_SequenceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/SequenceDef:1.0";
}

CORBA_SequenceDef*
POA_CORBA_SequenceDef::_this (TAO_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::CORBA_SequenceDef::_unchecked_narrow (obj.in ());
}


class TAO_CORBA_ArrayDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:45:35 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_ArrayDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ArrayDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22,  0,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22,  0,
     22, 22,  0,  0,  0, 22,  0, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22,  5, 22, 22, 22, 22,  0, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22,
#else
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22,  0, 22,  0, 22, 22,
      0,  0,  0, 22,  0, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22,  5, 22, 22, 22,
     22,  0, 22, 22, 22, 22, 22, 22,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_ArrayDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 11,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 21,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 21,
      HASH_VALUE_RANGE = 17,
      DUPLICATES = 3,
      WORDLIST_SIZE = 16
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_CORBA_ArrayDef::_is_a_skel},
      {"destroy",       &POA_CORBA_ArrayDef::destroy_skel},
      {"_get_type",     &POA_CORBA_ArrayDef::_get_type_skel},
      {"_interface",  &POA_CORBA_ArrayDef::_interface_skel},
      {"_get_length",   &POA_CORBA_ArrayDef::_get_length_skel},
      {"_set_length",   &POA_CORBA_ArrayDef::_set_length_skel},
      {"_get_def_kind",         &POA_CORBA_ArrayDef::_get_def_kind_skel},
      {"_get_element_type",     &POA_CORBA_ArrayDef::_get_element_type_skel},
      {"_non_existent",  &POA_CORBA_ArrayDef::_non_existent_skel},
      {"_get_element_type_def",         &POA_CORBA_ArrayDef::_get_element_type_def_skel},
      {"_set_element_type_def",         &POA_CORBA_ArrayDef::_set_element_type_def_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -9,  -2,   5,  -1,   6,  -1,   7,   8, -29,  -1,  11,
       -1,  -1,  -1,  12,  13, -14,  -2, -23,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:45:35 */
static TAO_CORBA_ArrayDef_Perfect_Hash_OpTable tao_CORBA_ArrayDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_CORBA_ArrayDef_length_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ArrayDef_length_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_ArrayDef *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::ULong result);

private:
  TAO_ServerRequestInfo_CORBA_ArrayDef_length_get (const TAO_ServerRequestInfo_CORBA_ArrayDef_length_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ArrayDef_length_get &);

private:
  POA_CORBA_ArrayDef *_tao_impl;
  CORBA::ULong _result;
};

TAO_ServerRequestInfo_CORBA_ArrayDef_length_get::TAO_ServerRequestInfo_CORBA_ArrayDef_length_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_ArrayDef *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ArrayDef_length_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ArrayDef_length_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_ArrayDef_length_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_ArrayDef_length_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ArrayDef_length_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_ArrayDef_length_get::result (CORBA::ULong result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_ArrayDef_length_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ArrayDef_length_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_ArrayDef *tao_impl
    ,
    const CORBA::ULong & length
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));


private:
  TAO_ServerRequestInfo_CORBA_ArrayDef_length_set (const TAO_ServerRequestInfo_CORBA_ArrayDef_length_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ArrayDef_length_set &);

private:
  POA_CORBA_ArrayDef *_tao_impl;
  const CORBA::ULong & length_;

};

TAO_ServerRequestInfo_CORBA_ArrayDef_length_set::TAO_ServerRequestInfo_CORBA_ArrayDef_length_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_ArrayDef *tao_impl,
    const CORBA::ULong & length
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    length_ (length)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ArrayDef_length_set::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= length_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ArrayDef_length_set::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_ArrayDef_length_set::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_ArrayDef_length_set::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ArrayDef_length_set::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_ArrayDef *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::TypeCode_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_get (const TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_get &);

private:
  POA_CORBA_ArrayDef *_tao_impl;
  CORBA::TypeCode_ptr _result;
};

TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_get::TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_ArrayDef *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_get::result (CORBA::TypeCode_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_def_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_def_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_ArrayDef *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_IDLType_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_def_get (const TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_def_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_def_get &);

private:
  POA_CORBA_ArrayDef *_tao_impl;
  CORBA_IDLType_ptr _result;
};

TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_def_get::TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_def_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_ArrayDef *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_def_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_def_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_def_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_def_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_def_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_def_get::result (CORBA_IDLType_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_def_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_def_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_ArrayDef *tao_impl
    ,
    CORBA_IDLType_ptr element_type_def
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));


private:
  TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_def_set (const TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_def_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_def_set &);

private:
  POA_CORBA_ArrayDef *_tao_impl;
  CORBA_IDLType_ptr element_type_def_;

};

TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_def_set::TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_def_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_ArrayDef *tao_impl,
    CORBA_IDLType_ptr element_type_def
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    element_type_def_ (element_type_def)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_def_set::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->element_type_def_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_def_set::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_def_set::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_def_set::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_def_set::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
_TAO_CORBA_ArrayDef_Strategized_Proxy_Broker *_TAO_CORBA_ArrayDef_Strategized_Proxy_Broker::the_TAO_CORBA_ArrayDef_Strategized_Proxy_Broker (void)
{
  static _TAO_CORBA_ArrayDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_CORBA_ArrayDef_Strategized_Proxy_Broker::_TAO_CORBA_ArrayDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

_TAO_CORBA_ArrayDef_Strategized_Proxy_Broker::~_TAO_CORBA_ArrayDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_CORBA_ArrayDef_Proxy_Impl&
_TAO_CORBA_ArrayDef_Strategized_Proxy_Broker::select_proxy (
    ::CORBA_ArrayDef *object
    TAO_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
_TAO_CORBA_ArrayDef_Strategized_Proxy_Broker::create_proxy (
    int strategy
    TAO_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_CORBA_ArrayDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_CORBA_ArrayDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_CORBA_ArrayDef_Proxy_Broker *
_TAO_CORBA_ArrayDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::_TAO_CORBA_ArrayDef_Strategized_Proxy_Broker::the_TAO_CORBA_ArrayDef_Strategized_Proxy_Broker();
}

int
_TAO_CORBA_ArrayDef_Proxy_Broker_Factory_Initializer (long)
{
  _TAO_CORBA_ArrayDef_Proxy_Broker_Factory_function_pointer =
    _TAO_CORBA_ArrayDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_CORBA_ArrayDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_CORBA_ArrayDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_CORBA_ArrayDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

_TAO_CORBA_ArrayDef_ThruPOA_Proxy_Impl::_TAO_CORBA_ArrayDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::ULong _TAO_CORBA_ArrayDef_ThruPOA_Proxy_Impl::length (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::ULong _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "length",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_CORBA_ArrayDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ArrayDef:1.0"
        )
    )->length (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

void _TAO_CORBA_ArrayDef_ThruPOA_Proxy_Impl::length (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong length
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "length",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_ArrayDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ArrayDef:1.0"
        )
    )->length (
        length
        TAO_ENV_ARG_PARAMETER
      );
  return;
}

CORBA::TypeCode_ptr _TAO_CORBA_ArrayDef_ThruPOA_Proxy_Impl::element_type (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "element_type",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_ArrayDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ArrayDef:1.0"
        )
    )->element_type (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

CORBA_IDLType_ptr _TAO_CORBA_ArrayDef_ThruPOA_Proxy_Impl::element_type_def (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "element_type_def",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_ArrayDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ArrayDef:1.0"
        )
    )->element_type_def (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

void _TAO_CORBA_ArrayDef_ThruPOA_Proxy_Impl::element_type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA_IDLType_ptr element_type_def
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "element_type_def",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_ArrayDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ArrayDef:1.0"
        )
    )->element_type_def (
        element_type_def
        TAO_ENV_ARG_PARAMETER
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA_ArrayDef::POA_CORBA_ArrayDef (void)
{
  this->optable_ = &tao_CORBA_ArrayDef_optable;
}

// copy ctor
POA_CORBA_ArrayDef::POA_CORBA_ArrayDef (const POA_CORBA_ArrayDef& rhs)
  :   POA_CORBA_IDLType (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA_ArrayDef::~POA_CORBA_ArrayDef (void)
{
}

void POA_CORBA_ArrayDef::_get_length_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_ArrayDef *_tao_impl =
    ACE_static_cast (POA_CORBA_ArrayDef *, _tao_object_reference);

    CORBA::ULong _tao_retval = 0;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_ArrayDef_length_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->length (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::ULong _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval)
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_ArrayDef::_set_length_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_ArrayDef *_tao_impl =
    ACE_static_cast (POA_CORBA_ArrayDef *, _tao_object_reference);

  _tao_server_request.argument_flag (0);
    CORBA::ULong length;
  if (!(
    (_tao_in >> length)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_ArrayDef_length_set ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      length
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->length (
          length
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_ArrayDef::_get_element_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_ArrayDef *_tao_impl =
    ACE_static_cast (POA_CORBA_ArrayDef *, _tao_object_reference);

    CORBA::TypeCode_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->element_type (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::TypeCode_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_ArrayDef::_get_element_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_ArrayDef *_tao_impl =
    ACE_static_cast (POA_CORBA_ArrayDef *, _tao_object_reference);

    CORBA_IDLType_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_def_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->element_type_def (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_IDLType_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_ArrayDef::_set_element_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_ArrayDef *_tao_impl =
    ACE_static_cast (POA_CORBA_ArrayDef *, _tao_object_reference);

  _tao_server_request.argument_flag (0);
    CORBA_IDLType_var element_type_def;
  if (!(
    (_tao_in >> element_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_ArrayDef_element_type_def_set ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      element_type_def.in ()
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->element_type_def (
          element_type_def.in ()
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_ArrayDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_ArrayDef *_tao_impl = (POA_CORBA_ArrayDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () TAO_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_ArrayDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_ArrayDef *_tao_impl = (POA_CORBA_ArrayDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_ArrayDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_ArrayDef *_tao_impl = (POA_CORBA_ArrayDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_CORBA_ArrayDef::_is_a (
    const char* value
    TAO_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ArrayDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA_ArrayDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/ArrayDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_ArrayDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA_ArrayDef::_dispatch (TAO_ServerRequest &req, void *servant_upcall TAO_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     TAO_ENV_ARG_PARAMETER);
}


const char* POA_CORBA_ArrayDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ArrayDef:1.0";
}

CORBA_ArrayDef*
POA_CORBA_ArrayDef::_this (TAO_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::CORBA_ArrayDef::_unchecked_narrow (obj.in ());
}


class TAO_CORBA_ExceptionDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:45:36 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_ExceptionDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ExceptionDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61,  0,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61,  0,
     61, 25,  8,  0, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61,  0, 15,  5,
     61,  0, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 20, 20, 61, 61, 61, 15, 10, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61,
#else
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61,  0, 61,  0, 61, 25,
      8,  0, 61, 61, 61, 61, 61, 61,  0, 15,
      5, 61,  0, 61, 61, 20, 20, 61, 61, 61,
     15, 10, 61, 61, 61, 61, 61, 61,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_ExceptionDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 36,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 60,
      HASH_VALUE_RANGE = 56,
      DUPLICATES = 7,
      WORDLIST_SIZE = 41
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_CORBA_ExceptionDef::_is_a_skel},
      {"lookup",        &POA_CORBA_ExceptionDef::lookup_skel},
      {"_get_type",     &POA_CORBA_ExceptionDef::_get_type_skel},
      {"_set_name",     &POA_CORBA_ExceptionDef::_set_name_skel},
      {"_get_name",     &POA_CORBA_ExceptionDef::_get_name_skel},
      {"_interface",  &POA_CORBA_ExceptionDef::_interface_skel},
      {"lookup_name",   &POA_CORBA_ExceptionDef::lookup_name_skel},
      {"_get_id",       &POA_CORBA_ExceptionDef::_get_id_skel},
      {"_set_id",       &POA_CORBA_ExceptionDef::_set_id_skel},
      {"describe",      &POA_CORBA_ExceptionDef::describe_skel},
      {"_get_version",  &POA_CORBA_ExceptionDef::_get_version_skel},
      {"_set_version",  &POA_CORBA_ExceptionDef::_set_version_skel},
      {"_get_absolute_name",    &POA_CORBA_ExceptionDef::_get_absolute_name_skel},
      {"move",  &POA_CORBA_ExceptionDef::move_skel},
      {"_get_defined_in",       &POA_CORBA_ExceptionDef::_get_defined_in_skel},
      {"_get_def_kind",         &POA_CORBA_ExceptionDef::_get_def_kind_skel},
      {"destroy",       &POA_CORBA_ExceptionDef::destroy_skel},
      {"_get_members",  &POA_CORBA_ExceptionDef::_get_members_skel},
      {"_set_members",  &POA_CORBA_ExceptionDef::_set_members_skel},
      {"_non_existent",  &POA_CORBA_ExceptionDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_CORBA_ExceptionDef::_get_containing_repository_skel},
      {"create_value",  &POA_CORBA_ExceptionDef::create_value_skel},
      {"create_module",         &POA_CORBA_ExceptionDef::create_module_skel},
      {"create_native",         &POA_CORBA_ExceptionDef::create_native_skel},
      {"create_interface",      &POA_CORBA_ExceptionDef::create_interface_skel},
      {"create_union",  &POA_CORBA_ExceptionDef::create_union_skel},
      {"describe_contents",     &POA_CORBA_ExceptionDef::describe_contents_skel},
      {"create_exception",      &POA_CORBA_ExceptionDef::create_exception_skel},
      {"create_local_interface",        &POA_CORBA_ExceptionDef::create_local_interface_skel},
      {"create_abstract_interface",     &POA_CORBA_ExceptionDef::create_abstract_interface_skel},
      {"create_enum",   &POA_CORBA_ExceptionDef::create_enum_skel},
      {"contents",      &POA_CORBA_ExceptionDef::contents_skel},
      {"create_value_box",      &POA_CORBA_ExceptionDef::create_value_box_skel},
      {"create_alias",  &POA_CORBA_ExceptionDef::create_alias_skel},
      {"create_struct",         &POA_CORBA_ExceptionDef::create_struct_skel},
      {"create_constant",       &POA_CORBA_ExceptionDef::create_constant_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -7,  -3,   5,   6, -12,  -2, -66,  10,  11,  -1, -15,
       -2, -68,  14, -64,  17,  18,  19,  20,  -1,  -1,  -1,  21,  -1,  -1,
       -1,  -1, -22,  -2, -62,  24, -27,  -2,  25,  26, -64,  -1,  -1,  29,
       30,  -1,  -1,  31,  32,  33,  -1,  -1,  34,  35,  -1,  36,  -1,  -1,
       37,  38,  39,  -1,  40,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:45:36 */
static TAO_CORBA_ExceptionDef_Perfect_Hash_OpTable tao_CORBA_ExceptionDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_CORBA_ExceptionDef_type_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ExceptionDef_type_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_ExceptionDef *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::TypeCode_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_ExceptionDef_type_get (const TAO_ServerRequestInfo_CORBA_ExceptionDef_type_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ExceptionDef_type_get &);

private:
  POA_CORBA_ExceptionDef *_tao_impl;
  CORBA::TypeCode_ptr _result;
};

TAO_ServerRequestInfo_CORBA_ExceptionDef_type_get::TAO_ServerRequestInfo_CORBA_ExceptionDef_type_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_ExceptionDef *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ExceptionDef_type_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ExceptionDef_type_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_ExceptionDef_type_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_ExceptionDef_type_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ExceptionDef_type_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_ExceptionDef_type_get::result (CORBA::TypeCode_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_ExceptionDef_members_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ExceptionDef_members_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_ExceptionDef *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_StructMemberSeq * result);

private:
  TAO_ServerRequestInfo_CORBA_ExceptionDef_members_get (const TAO_ServerRequestInfo_CORBA_ExceptionDef_members_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ExceptionDef_members_get &);

private:
  POA_CORBA_ExceptionDef *_tao_impl;
  CORBA_StructMemberSeq * _result;
};

TAO_ServerRequestInfo_CORBA_ExceptionDef_members_get::TAO_ServerRequestInfo_CORBA_ExceptionDef_members_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_ExceptionDef *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ExceptionDef_members_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ExceptionDef_members_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_ExceptionDef_members_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_ExceptionDef_members_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ExceptionDef_members_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_ExceptionDef_members_get::result (CORBA_StructMemberSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_ExceptionDef_members_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ExceptionDef_members_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_ExceptionDef *tao_impl
    ,
    const CORBA_StructMemberSeq & members
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));


private:
  TAO_ServerRequestInfo_CORBA_ExceptionDef_members_set (const TAO_ServerRequestInfo_CORBA_ExceptionDef_members_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ExceptionDef_members_set &);

private:
  POA_CORBA_ExceptionDef *_tao_impl;
  const CORBA_StructMemberSeq & members_;

};

TAO_ServerRequestInfo_CORBA_ExceptionDef_members_set::TAO_ServerRequestInfo_CORBA_ExceptionDef_members_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_ExceptionDef *tao_impl,
    const CORBA_StructMemberSeq & members
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    members_ (members)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ExceptionDef_members_set::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->members_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ExceptionDef_members_set::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_ExceptionDef_members_set::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_ExceptionDef_members_set::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ExceptionDef_members_set::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
_TAO_CORBA_ExceptionDef_Strategized_Proxy_Broker *_TAO_CORBA_ExceptionDef_Strategized_Proxy_Broker::the_TAO_CORBA_ExceptionDef_Strategized_Proxy_Broker (void)
{
  static _TAO_CORBA_ExceptionDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_CORBA_ExceptionDef_Strategized_Proxy_Broker::_TAO_CORBA_ExceptionDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

_TAO_CORBA_ExceptionDef_Strategized_Proxy_Broker::~_TAO_CORBA_ExceptionDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_CORBA_ExceptionDef_Proxy_Impl&
_TAO_CORBA_ExceptionDef_Strategized_Proxy_Broker::select_proxy (
    ::CORBA_ExceptionDef *object
    TAO_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
_TAO_CORBA_ExceptionDef_Strategized_Proxy_Broker::create_proxy (
    int strategy
    TAO_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_CORBA_ExceptionDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_CORBA_ExceptionDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_CORBA_ExceptionDef_Proxy_Broker *
_TAO_CORBA_ExceptionDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::_TAO_CORBA_ExceptionDef_Strategized_Proxy_Broker::the_TAO_CORBA_ExceptionDef_Strategized_Proxy_Broker();
}

int
_TAO_CORBA_ExceptionDef_Proxy_Broker_Factory_Initializer (long)
{
  _TAO_CORBA_ExceptionDef_Proxy_Broker_Factory_function_pointer =
    _TAO_CORBA_ExceptionDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_CORBA_ExceptionDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_CORBA_ExceptionDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_CORBA_ExceptionDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

_TAO_CORBA_ExceptionDef_ThruPOA_Proxy_Impl::_TAO_CORBA_ExceptionDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::TypeCode_ptr _TAO_CORBA_ExceptionDef_ThruPOA_Proxy_Impl::type (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_ExceptionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ExceptionDef:1.0"
        )
    )->type (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

CORBA_StructMemberSeq * _TAO_CORBA_ExceptionDef_ThruPOA_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_StructMemberSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "members",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_ExceptionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ExceptionDef:1.0"
        )
    )->members (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

void _TAO_CORBA_ExceptionDef_ThruPOA_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    const CORBA_StructMemberSeq & members
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "members",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_ExceptionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ExceptionDef:1.0"
        )
    )->members (
        members
        TAO_ENV_ARG_PARAMETER
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA_ExceptionDef::POA_CORBA_ExceptionDef (void)
{
  this->optable_ = &tao_CORBA_ExceptionDef_optable;
}

// copy ctor
POA_CORBA_ExceptionDef::POA_CORBA_ExceptionDef (const POA_CORBA_ExceptionDef& rhs)
  :   POA_CORBA_Contained (rhs),
    POA_CORBA_Container (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA_ExceptionDef::~POA_CORBA_ExceptionDef (void)
{
}

void POA_CORBA_ExceptionDef::_get_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_ExceptionDef *_tao_impl =
    ACE_static_cast (POA_CORBA_ExceptionDef *, _tao_object_reference);

    CORBA::TypeCode_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_ExceptionDef_type_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->type (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::TypeCode_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_ExceptionDef::_get_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_ExceptionDef *_tao_impl =
    ACE_static_cast (POA_CORBA_ExceptionDef *, _tao_object_reference);

    CORBA_StructMemberSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_ExceptionDef_members_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->members (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_StructMemberSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_ExceptionDef::_set_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_ExceptionDef *_tao_impl =
    ACE_static_cast (POA_CORBA_ExceptionDef *, _tao_object_reference);

  _tao_server_request.argument_flag (0);
    CORBA_StructMemberSeq members;
  if (!(
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_ExceptionDef_members_set ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      members
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->members (
          members
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_ExceptionDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_ExceptionDef *_tao_impl = (POA_CORBA_ExceptionDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () TAO_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_ExceptionDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_ExceptionDef *_tao_impl = (POA_CORBA_ExceptionDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_ExceptionDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_ExceptionDef *_tao_impl = (POA_CORBA_ExceptionDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_CORBA_ExceptionDef::_is_a (
    const char* value
    TAO_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ExceptionDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA_ExceptionDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/ExceptionDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_ExceptionDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Container:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA_ExceptionDef::_dispatch (TAO_ServerRequest &req, void *servant_upcall TAO_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     TAO_ENV_ARG_PARAMETER);
}


const char* POA_CORBA_ExceptionDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ExceptionDef:1.0";
}

CORBA_ExceptionDef*
POA_CORBA_ExceptionDef::_this (TAO_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::CORBA_ExceptionDef::_unchecked_narrow (obj.in ());
}


class TAO_CORBA_AttributeDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:45:38 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_AttributeDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_AttributeDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 15, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 15, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_AttributeDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 21,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 8,
      WORDLIST_SIZE = 25
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_CORBA_AttributeDef::move_skel},
      {"_is_a",  &POA_CORBA_AttributeDef::_is_a_skel},
      {"_get_id",       &POA_CORBA_AttributeDef::_get_id_skel},
      {"_set_id",       &POA_CORBA_AttributeDef::_set_id_skel},
      {"describe",      &POA_CORBA_AttributeDef::describe_skel},
      {"_get_type",     &POA_CORBA_AttributeDef::_get_type_skel},
      {"_set_name",     &POA_CORBA_AttributeDef::_set_name_skel},
      {"_get_name",     &POA_CORBA_AttributeDef::_get_name_skel},
      {"_set_mode",     &POA_CORBA_AttributeDef::_set_mode_skel},
      {"_get_mode",     &POA_CORBA_AttributeDef::_get_mode_skel},
      {"_interface",  &POA_CORBA_AttributeDef::_interface_skel},
      {"_get_version",  &POA_CORBA_AttributeDef::_get_version_skel},
      {"_set_version",  &POA_CORBA_AttributeDef::_set_version_skel},
      {"_get_def_kind",         &POA_CORBA_AttributeDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_CORBA_AttributeDef::_get_defined_in_skel},
      {"destroy",       &POA_CORBA_AttributeDef::destroy_skel},
      {"_get_absolute_name",    &POA_CORBA_AttributeDef::_get_absolute_name_skel},
      {"_get_type_def",         &POA_CORBA_AttributeDef::_get_type_def_skel},
      {"_set_type_def",         &POA_CORBA_AttributeDef::_set_type_def_skel},
      {"_non_existent",  &POA_CORBA_AttributeDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_CORBA_AttributeDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -9,  -5, -15,  -2,   4,   5,  -1,  48,   8, -45,  14,  -1, -46,  17,
       -1,  18,  -1,  19,  20,  -6,  -2, -21,  -2, -38,  -1,  -1,  -1,  -1,
       23,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  24,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:45:38 */
static TAO_CORBA_AttributeDef_Perfect_Hash_OpTable tao_CORBA_AttributeDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_CORBA_AttributeDef_type_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_AttributeDef_type_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_AttributeDef *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::TypeCode_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_AttributeDef_type_get (const TAO_ServerRequestInfo_CORBA_AttributeDef_type_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_AttributeDef_type_get &);

private:
  POA_CORBA_AttributeDef *_tao_impl;
  CORBA::TypeCode_ptr _result;
};

TAO_ServerRequestInfo_CORBA_AttributeDef_type_get::TAO_ServerRequestInfo_CORBA_AttributeDef_type_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_AttributeDef *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_AttributeDef_type_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_AttributeDef_type_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_AttributeDef_type_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_AttributeDef_type_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_AttributeDef_type_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_AttributeDef_type_get::result (CORBA::TypeCode_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_AttributeDef_type_def_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_AttributeDef_type_def_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_AttributeDef *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_IDLType_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_AttributeDef_type_def_get (const TAO_ServerRequestInfo_CORBA_AttributeDef_type_def_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_AttributeDef_type_def_get &);

private:
  POA_CORBA_AttributeDef *_tao_impl;
  CORBA_IDLType_ptr _result;
};

TAO_ServerRequestInfo_CORBA_AttributeDef_type_def_get::TAO_ServerRequestInfo_CORBA_AttributeDef_type_def_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_AttributeDef *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_AttributeDef_type_def_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_AttributeDef_type_def_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_AttributeDef_type_def_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_AttributeDef_type_def_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_AttributeDef_type_def_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_AttributeDef_type_def_get::result (CORBA_IDLType_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_AttributeDef_type_def_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_AttributeDef_type_def_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_AttributeDef *tao_impl
    ,
    CORBA_IDLType_ptr type_def
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));


private:
  TAO_ServerRequestInfo_CORBA_AttributeDef_type_def_set (const TAO_ServerRequestInfo_CORBA_AttributeDef_type_def_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_AttributeDef_type_def_set &);

private:
  POA_CORBA_AttributeDef *_tao_impl;
  CORBA_IDLType_ptr type_def_;

};

TAO_ServerRequestInfo_CORBA_AttributeDef_type_def_set::TAO_ServerRequestInfo_CORBA_AttributeDef_type_def_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_AttributeDef *tao_impl,
    CORBA_IDLType_ptr type_def
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    type_def_ (type_def)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_AttributeDef_type_def_set::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->type_def_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_AttributeDef_type_def_set::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_AttributeDef_type_def_set::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_AttributeDef_type_def_set::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_AttributeDef_type_def_set::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_CORBA_AttributeDef_mode_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_AttributeDef_mode_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_AttributeDef *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::AttributeMode result);

private:
  TAO_ServerRequestInfo_CORBA_AttributeDef_mode_get (const TAO_ServerRequestInfo_CORBA_AttributeDef_mode_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_AttributeDef_mode_get &);

private:
  POA_CORBA_AttributeDef *_tao_impl;
  CORBA::AttributeMode _result;
};

TAO_ServerRequestInfo_CORBA_AttributeDef_mode_get::TAO_ServerRequestInfo_CORBA_AttributeDef_mode_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_AttributeDef *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_AttributeDef_mode_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_AttributeDef_mode_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_AttributeDef_mode_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_AttributeDef_mode_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_AttributeDef_mode_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_AttributeDef_mode_get::result (CORBA::AttributeMode result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_AttributeDef_mode_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_AttributeDef_mode_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_AttributeDef *tao_impl
    ,
    CORBA::AttributeMode & mode
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));


private:
  TAO_ServerRequestInfo_CORBA_AttributeDef_mode_set (const TAO_ServerRequestInfo_CORBA_AttributeDef_mode_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_AttributeDef_mode_set &);

private:
  POA_CORBA_AttributeDef *_tao_impl;
  const CORBA::AttributeMode & mode_;

};

TAO_ServerRequestInfo_CORBA_AttributeDef_mode_set::TAO_ServerRequestInfo_CORBA_AttributeDef_mode_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_AttributeDef *tao_impl,
    CORBA::AttributeMode & mode
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    mode_ (mode)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_AttributeDef_mode_set::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->mode_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_AttributeDef_mode_set::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_AttributeDef_mode_set::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_AttributeDef_mode_set::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_AttributeDef_mode_set::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
_TAO_CORBA_AttributeDef_Strategized_Proxy_Broker *_TAO_CORBA_AttributeDef_Strategized_Proxy_Broker::the_TAO_CORBA_AttributeDef_Strategized_Proxy_Broker (void)
{
  static _TAO_CORBA_AttributeDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_CORBA_AttributeDef_Strategized_Proxy_Broker::_TAO_CORBA_AttributeDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

_TAO_CORBA_AttributeDef_Strategized_Proxy_Broker::~_TAO_CORBA_AttributeDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_CORBA_AttributeDef_Proxy_Impl&
_TAO_CORBA_AttributeDef_Strategized_Proxy_Broker::select_proxy (
    ::CORBA_AttributeDef *object
    TAO_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
_TAO_CORBA_AttributeDef_Strategized_Proxy_Broker::create_proxy (
    int strategy
    TAO_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_CORBA_AttributeDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_CORBA_AttributeDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_CORBA_AttributeDef_Proxy_Broker *
_TAO_CORBA_AttributeDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::_TAO_CORBA_AttributeDef_Strategized_Proxy_Broker::the_TAO_CORBA_AttributeDef_Strategized_Proxy_Broker();
}

int
_TAO_CORBA_AttributeDef_Proxy_Broker_Factory_Initializer (long)
{
  _TAO_CORBA_AttributeDef_Proxy_Broker_Factory_function_pointer =
    _TAO_CORBA_AttributeDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_CORBA_AttributeDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_CORBA_AttributeDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_CORBA_AttributeDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

_TAO_CORBA_AttributeDef_ThruPOA_Proxy_Impl::_TAO_CORBA_AttributeDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::TypeCode_ptr _TAO_CORBA_AttributeDef_ThruPOA_Proxy_Impl::type (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_AttributeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/AttributeDef:1.0"
        )
    )->type (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

CORBA_IDLType_ptr _TAO_CORBA_AttributeDef_ThruPOA_Proxy_Impl::type_def (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type_def",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_AttributeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/AttributeDef:1.0"
        )
    )->type_def (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

void _TAO_CORBA_AttributeDef_ThruPOA_Proxy_Impl::type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA_IDLType_ptr type_def
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type_def",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_AttributeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/AttributeDef:1.0"
        )
    )->type_def (
        type_def
        TAO_ENV_ARG_PARAMETER
      );
  return;
}

CORBA::AttributeMode _TAO_CORBA_AttributeDef_ThruPOA_Proxy_Impl::mode (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::AttributeMode _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "mode",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_CORBA_AttributeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/AttributeDef:1.0"
        )
    )->mode (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

void _TAO_CORBA_AttributeDef_ThruPOA_Proxy_Impl::mode (
    CORBA_Object *_collocated_tao_target_,
    CORBA::AttributeMode mode
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "mode",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_AttributeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/AttributeDef:1.0"
        )
    )->mode (
        mode
        TAO_ENV_ARG_PARAMETER
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA_AttributeDef::POA_CORBA_AttributeDef (void)
{
  this->optable_ = &tao_CORBA_AttributeDef_optable;
}

// copy ctor
POA_CORBA_AttributeDef::POA_CORBA_AttributeDef (const POA_CORBA_AttributeDef& rhs)
  :   POA_CORBA_Contained (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA_AttributeDef::~POA_CORBA_AttributeDef (void)
{
}

void POA_CORBA_AttributeDef::_get_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_AttributeDef *_tao_impl =
    ACE_static_cast (POA_CORBA_AttributeDef *, _tao_object_reference);

    CORBA::TypeCode_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_AttributeDef_type_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->type (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::TypeCode_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_AttributeDef::_get_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_AttributeDef *_tao_impl =
    ACE_static_cast (POA_CORBA_AttributeDef *, _tao_object_reference);

    CORBA_IDLType_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_AttributeDef_type_def_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->type_def (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_IDLType_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_AttributeDef::_set_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_AttributeDef *_tao_impl =
    ACE_static_cast (POA_CORBA_AttributeDef *, _tao_object_reference);

  _tao_server_request.argument_flag (0);
    CORBA_IDLType_var type_def;
  if (!(
    (_tao_in >> type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_AttributeDef_type_def_set ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      type_def.in ()
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->type_def (
          type_def.in ()
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_AttributeDef::_get_mode_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_AttributeDef *_tao_impl =
    ACE_static_cast (POA_CORBA_AttributeDef *, _tao_object_reference);

    CORBA::AttributeMode _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_AttributeDef_mode_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->mode (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::AttributeMode _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval)
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_AttributeDef::_set_mode_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_AttributeDef *_tao_impl =
    ACE_static_cast (POA_CORBA_AttributeDef *, _tao_object_reference);

  _tao_server_request.argument_flag (0);
    CORBA::AttributeMode mode;
  if (!(
    (_tao_in >> mode)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_AttributeDef_mode_set ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      mode
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->mode (
          mode
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_AttributeDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_AttributeDef *_tao_impl = (POA_CORBA_AttributeDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () TAO_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_AttributeDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_AttributeDef *_tao_impl = (POA_CORBA_AttributeDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_AttributeDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_AttributeDef *_tao_impl = (POA_CORBA_AttributeDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_CORBA_AttributeDef::_is_a (
    const char* value
    TAO_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/AttributeDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA_AttributeDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/AttributeDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_AttributeDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA_AttributeDef::_dispatch (TAO_ServerRequest &req, void *servant_upcall TAO_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     TAO_ENV_ARG_PARAMETER);
}


const char* POA_CORBA_AttributeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/AttributeDef:1.0";
}

CORBA_AttributeDef*
POA_CORBA_AttributeDef::_this (TAO_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::CORBA_AttributeDef::_unchecked_narrow (obj.in ());
}


class TAO_CORBA_OperationDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:45:39 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_OperationDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_OperationDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 15,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  5,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37,  0, 20, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
     15,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      5, 37, 37, 37, 37,  0, 20, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_OperationDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 27,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 10,
      WORDLIST_SIZE = 31
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_CORBA_OperationDef::move_skel},
      {"_is_a",  &POA_CORBA_OperationDef::_is_a_skel},
      {"_get_mode",     &POA_CORBA_OperationDef::_get_mode_skel},
      {"_set_name",     &POA_CORBA_OperationDef::_set_name_skel},
      {"_get_name",     &POA_CORBA_OperationDef::_get_name_skel},
      {"_set_mode",     &POA_CORBA_OperationDef::_set_mode_skel},
      {"_interface",  &POA_CORBA_OperationDef::_interface_skel},
      {"_get_params",   &POA_CORBA_OperationDef::_get_params_skel},
      {"_set_params",   &POA_CORBA_OperationDef::_set_params_skel},
      {"_get_contexts",         &POA_CORBA_OperationDef::_get_contexts_skel},
      {"_set_contexts",         &POA_CORBA_OperationDef::_set_contexts_skel},
      {"_get_exceptions",       &POA_CORBA_OperationDef::_get_exceptions_skel},
      {"_set_exceptions",       &POA_CORBA_OperationDef::_set_exceptions_skel},
      {"_get_version",  &POA_CORBA_OperationDef::_get_version_skel},
      {"_set_version",  &POA_CORBA_OperationDef::_set_version_skel},
      {"_get_absolute_name",    &POA_CORBA_OperationDef::_get_absolute_name_skel},
      {"_get_defined_in",       &POA_CORBA_OperationDef::_get_defined_in_skel},
      {"_get_id",       &POA_CORBA_OperationDef::_get_id_skel},
      {"_set_id",       &POA_CORBA_OperationDef::_set_id_skel},
      {"describe",      &POA_CORBA_OperationDef::describe_skel},
      {"_get_result_def",       &POA_CORBA_OperationDef::_get_result_def_skel},
      {"_set_result_def",       &POA_CORBA_OperationDef::_set_result_def_skel},
      {"_get_def_kind",         &POA_CORBA_OperationDef::_get_def_kind_skel},
      {"_get_result",   &POA_CORBA_OperationDef::_get_result_skel},
      {"destroy",       &POA_CORBA_OperationDef::destroy_skel},
      {"_non_existent",  &POA_CORBA_OperationDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_CORBA_OperationDef::_get_containing_repository_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
            {
              const class TAO_operation_db_entry   *resword;

              switch (key)
                {
                case   4:
                  resword = &wordlist[4]; break;
                case   5:
                  resword = &wordlist[5]; break;
                case   9:
                  resword = &wordlist[6];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[7];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[8];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[9];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  10:
                  resword = &wordlist[10]; break;
                case  11:
                  resword = &wordlist[11];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[12];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  13:
                  resword = &wordlist[13];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[14];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  15:
                  resword = &wordlist[15];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[16];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  17:
                  resword = &wordlist[17];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[18];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  18:
                  resword = &wordlist[19]; break;
                case  20:
                  resword = &wordlist[20]; break;
                case  22:
                  resword = &wordlist[21];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[22];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  23:
                  resword = &wordlist[23]; break;
                case  25:
                  resword = &wordlist[24];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[25];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  28:
                  resword = &wordlist[26]; break;
                case  31:
                  resword = &wordlist[27]; break;
                case  32:
                  resword = &wordlist[28]; break;
                case  33:
                  resword = &wordlist[29]; break;
                case  36:
                  resword = &wordlist[30]; break;
                default: return 0;
                }
              if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1))
                return resword;
              return 0;
            }
        }
    }
  return 0;
}
/* ending time is 22:45:39 */
static TAO_CORBA_OperationDef_Perfect_Hash_OpTable tao_CORBA_OperationDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_CORBA_OperationDef_result_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_OperationDef_result_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_OperationDef *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::TypeCode_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_OperationDef_result_get (const TAO_ServerRequestInfo_CORBA_OperationDef_result_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_OperationDef_result_get &);

private:
  POA_CORBA_OperationDef *_tao_impl;
  CORBA::TypeCode_ptr _result;
};

TAO_ServerRequestInfo_CORBA_OperationDef_result_get::TAO_ServerRequestInfo_CORBA_OperationDef_result_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_OperationDef *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_OperationDef_result_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_OperationDef_result_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_OperationDef_result_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_OperationDef_result_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_OperationDef_result_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_OperationDef_result_get::result (CORBA::TypeCode_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_OperationDef_result_def_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_OperationDef_result_def_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_OperationDef *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_IDLType_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_OperationDef_result_def_get (const TAO_ServerRequestInfo_CORBA_OperationDef_result_def_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_OperationDef_result_def_get &);

private:
  POA_CORBA_OperationDef *_tao_impl;
  CORBA_IDLType_ptr _result;
};

TAO_ServerRequestInfo_CORBA_OperationDef_result_def_get::TAO_ServerRequestInfo_CORBA_OperationDef_result_def_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_OperationDef *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_OperationDef_result_def_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_OperationDef_result_def_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_OperationDef_result_def_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_OperationDef_result_def_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_OperationDef_result_def_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_OperationDef_result_def_get::result (CORBA_IDLType_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_OperationDef_result_def_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_OperationDef_result_def_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_OperationDef *tao_impl
    ,
    CORBA_IDLType_ptr result_def
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));


private:
  TAO_ServerRequestInfo_CORBA_OperationDef_result_def_set (const TAO_ServerRequestInfo_CORBA_OperationDef_result_def_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_OperationDef_result_def_set &);

private:
  POA_CORBA_OperationDef *_tao_impl;
  CORBA_IDLType_ptr result_def_;

};

TAO_ServerRequestInfo_CORBA_OperationDef_result_def_set::TAO_ServerRequestInfo_CORBA_OperationDef_result_def_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_OperationDef *tao_impl,
    CORBA_IDLType_ptr result_def
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    result_def_ (result_def)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_OperationDef_result_def_set::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->result_def_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_OperationDef_result_def_set::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_OperationDef_result_def_set::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_OperationDef_result_def_set::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_OperationDef_result_def_set::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_CORBA_OperationDef_params_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_OperationDef_params_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_OperationDef *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_ParDescriptionSeq * result);

private:
  TAO_ServerRequestInfo_CORBA_OperationDef_params_get (const TAO_ServerRequestInfo_CORBA_OperationDef_params_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_OperationDef_params_get &);

private:
  POA_CORBA_OperationDef *_tao_impl;
  CORBA_ParDescriptionSeq * _result;
};

TAO_ServerRequestInfo_CORBA_OperationDef_params_get::TAO_ServerRequestInfo_CORBA_OperationDef_params_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_OperationDef *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_OperationDef_params_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_OperationDef_params_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_OperationDef_params_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_OperationDef_params_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_OperationDef_params_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_OperationDef_params_get::result (CORBA_ParDescriptionSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_OperationDef_params_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_OperationDef_params_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_OperationDef *tao_impl
    ,
    const CORBA_ParDescriptionSeq & params
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));


private:
  TAO_ServerRequestInfo_CORBA_OperationDef_params_set (const TAO_ServerRequestInfo_CORBA_OperationDef_params_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_OperationDef_params_set &);

private:
  POA_CORBA_OperationDef *_tao_impl;
  const CORBA_ParDescriptionSeq & params_;

};

TAO_ServerRequestInfo_CORBA_OperationDef_params_set::TAO_ServerRequestInfo_CORBA_OperationDef_params_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_OperationDef *tao_impl,
    const CORBA_ParDescriptionSeq & params
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    params_ (params)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_OperationDef_params_set::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->params_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_OperationDef_params_set::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_OperationDef_params_set::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_OperationDef_params_set::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_OperationDef_params_set::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_CORBA_OperationDef_mode_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_OperationDef_mode_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_OperationDef *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::OperationMode result);

private:
  TAO_ServerRequestInfo_CORBA_OperationDef_mode_get (const TAO_ServerRequestInfo_CORBA_OperationDef_mode_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_OperationDef_mode_get &);

private:
  POA_CORBA_OperationDef *_tao_impl;
  CORBA::OperationMode _result;
};

TAO_ServerRequestInfo_CORBA_OperationDef_mode_get::TAO_ServerRequestInfo_CORBA_OperationDef_mode_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_OperationDef *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_OperationDef_mode_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_OperationDef_mode_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_OperationDef_mode_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_OperationDef_mode_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_OperationDef_mode_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_OperationDef_mode_get::result (CORBA::OperationMode result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_OperationDef_mode_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_OperationDef_mode_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_OperationDef *tao_impl
    ,
    CORBA::OperationMode & mode
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));


private:
  TAO_ServerRequestInfo_CORBA_OperationDef_mode_set (const TAO_ServerRequestInfo_CORBA_OperationDef_mode_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_OperationDef_mode_set &);

private:
  POA_CORBA_OperationDef *_tao_impl;
  const CORBA::OperationMode & mode_;

};

TAO_ServerRequestInfo_CORBA_OperationDef_mode_set::TAO_ServerRequestInfo_CORBA_OperationDef_mode_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_OperationDef *tao_impl,
    CORBA::OperationMode & mode
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    mode_ (mode)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_OperationDef_mode_set::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->mode_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_OperationDef_mode_set::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_OperationDef_mode_set::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_OperationDef_mode_set::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_OperationDef_mode_set::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_CORBA_OperationDef_contexts_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_OperationDef_contexts_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_OperationDef *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_ContextIdSeq * result);

private:
  TAO_ServerRequestInfo_CORBA_OperationDef_contexts_get (const TAO_ServerRequestInfo_CORBA_OperationDef_contexts_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_OperationDef_contexts_get &);

private:
  POA_CORBA_OperationDef *_tao_impl;
  CORBA_ContextIdSeq * _result;
};

TAO_ServerRequestInfo_CORBA_OperationDef_contexts_get::TAO_ServerRequestInfo_CORBA_OperationDef_contexts_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_OperationDef *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_OperationDef_contexts_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_OperationDef_contexts_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_OperationDef_contexts_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_OperationDef_contexts_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_OperationDef_contexts_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_OperationDef_contexts_get::result (CORBA_ContextIdSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_OperationDef_contexts_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_OperationDef_contexts_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_OperationDef *tao_impl
    ,
    const CORBA_ContextIdSeq & contexts
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));


private:
  TAO_ServerRequestInfo_CORBA_OperationDef_contexts_set (const TAO_ServerRequestInfo_CORBA_OperationDef_contexts_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_OperationDef_contexts_set &);

private:
  POA_CORBA_OperationDef *_tao_impl;
  const CORBA_ContextIdSeq & contexts_;

};

TAO_ServerRequestInfo_CORBA_OperationDef_contexts_set::TAO_ServerRequestInfo_CORBA_OperationDef_contexts_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_OperationDef *tao_impl,
    const CORBA_ContextIdSeq & contexts
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    contexts_ (contexts)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_OperationDef_contexts_set::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->contexts_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_OperationDef_contexts_set::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_OperationDef_contexts_set::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_OperationDef_contexts_set::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_OperationDef_contexts_set::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_CORBA_OperationDef_exceptions_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_OperationDef_exceptions_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_OperationDef *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_ExceptionDefSeq * result);

private:
  TAO_ServerRequestInfo_CORBA_OperationDef_exceptions_get (const TAO_ServerRequestInfo_CORBA_OperationDef_exceptions_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_OperationDef_exceptions_get &);

private:
  POA_CORBA_OperationDef *_tao_impl;
  CORBA_ExceptionDefSeq * _result;
};

TAO_ServerRequestInfo_CORBA_OperationDef_exceptions_get::TAO_ServerRequestInfo_CORBA_OperationDef_exceptions_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_OperationDef *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_OperationDef_exceptions_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_OperationDef_exceptions_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_OperationDef_exceptions_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_OperationDef_exceptions_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_OperationDef_exceptions_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_OperationDef_exceptions_get::result (CORBA_ExceptionDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_OperationDef_exceptions_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_OperationDef_exceptions_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_OperationDef *tao_impl
    ,
    const CORBA_ExceptionDefSeq & exceptions
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));


private:
  TAO_ServerRequestInfo_CORBA_OperationDef_exceptions_set (const TAO_ServerRequestInfo_CORBA_OperationDef_exceptions_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_OperationDef_exceptions_set &);

private:
  POA_CORBA_OperationDef *_tao_impl;
  const CORBA_ExceptionDefSeq & exceptions_;

};

TAO_ServerRequestInfo_CORBA_OperationDef_exceptions_set::TAO_ServerRequestInfo_CORBA_OperationDef_exceptions_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_OperationDef *tao_impl,
    const CORBA_ExceptionDefSeq & exceptions
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    exceptions_ (exceptions)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_OperationDef_exceptions_set::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->exceptions_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_OperationDef_exceptions_set::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_OperationDef_exceptions_set::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_OperationDef_exceptions_set::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_OperationDef_exceptions_set::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
_TAO_CORBA_OperationDef_Strategized_Proxy_Broker *_TAO_CORBA_OperationDef_Strategized_Proxy_Broker::the_TAO_CORBA_OperationDef_Strategized_Proxy_Broker (void)
{
  static _TAO_CORBA_OperationDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_CORBA_OperationDef_Strategized_Proxy_Broker::_TAO_CORBA_OperationDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

_TAO_CORBA_OperationDef_Strategized_Proxy_Broker::~_TAO_CORBA_OperationDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_CORBA_OperationDef_Proxy_Impl&
_TAO_CORBA_OperationDef_Strategized_Proxy_Broker::select_proxy (
    ::CORBA_OperationDef *object
    TAO_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
_TAO_CORBA_OperationDef_Strategized_Proxy_Broker::create_proxy (
    int strategy
    TAO_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_CORBA_OperationDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_CORBA_OperationDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_CORBA_OperationDef_Proxy_Broker *
_TAO_CORBA_OperationDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::_TAO_CORBA_OperationDef_Strategized_Proxy_Broker::the_TAO_CORBA_OperationDef_Strategized_Proxy_Broker();
}

int
_TAO_CORBA_OperationDef_Proxy_Broker_Factory_Initializer (long)
{
  _TAO_CORBA_OperationDef_Proxy_Broker_Factory_function_pointer =
    _TAO_CORBA_OperationDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_CORBA_OperationDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_CORBA_OperationDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_CORBA_OperationDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

_TAO_CORBA_OperationDef_ThruPOA_Proxy_Impl::_TAO_CORBA_OperationDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::TypeCode_ptr _TAO_CORBA_OperationDef_ThruPOA_Proxy_Impl::result (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "result",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/OperationDef:1.0"
        )
    )->result (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

CORBA_IDLType_ptr _TAO_CORBA_OperationDef_ThruPOA_Proxy_Impl::result_def (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "result_def",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/OperationDef:1.0"
        )
    )->result_def (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

void _TAO_CORBA_OperationDef_ThruPOA_Proxy_Impl::result_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA_IDLType_ptr result_def
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "result_def",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/OperationDef:1.0"
        )
    )->result_def (
        result_def
        TAO_ENV_ARG_PARAMETER
      );
  return;
}

CORBA_ParDescriptionSeq * _TAO_CORBA_OperationDef_ThruPOA_Proxy_Impl::params (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_ParDescriptionSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "params",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/OperationDef:1.0"
        )
    )->params (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

void _TAO_CORBA_OperationDef_ThruPOA_Proxy_Impl::params (
    CORBA_Object *_collocated_tao_target_,
    const CORBA_ParDescriptionSeq & params
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "params",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/OperationDef:1.0"
        )
    )->params (
        params
        TAO_ENV_ARG_PARAMETER
      );
  return;
}

CORBA::OperationMode _TAO_CORBA_OperationDef_ThruPOA_Proxy_Impl::mode (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::OperationMode _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "mode",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_CORBA_OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/OperationDef:1.0"
        )
    )->mode (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

void _TAO_CORBA_OperationDef_ThruPOA_Proxy_Impl::mode (
    CORBA_Object *_collocated_tao_target_,
    CORBA::OperationMode mode
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "mode",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/OperationDef:1.0"
        )
    )->mode (
        mode
        TAO_ENV_ARG_PARAMETER
      );
  return;
}

CORBA_ContextIdSeq * _TAO_CORBA_OperationDef_ThruPOA_Proxy_Impl::contexts (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_ContextIdSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "contexts",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/OperationDef:1.0"
        )
    )->contexts (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

void _TAO_CORBA_OperationDef_ThruPOA_Proxy_Impl::contexts (
    CORBA_Object *_collocated_tao_target_,
    const CORBA_ContextIdSeq & contexts
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "contexts",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/OperationDef:1.0"
        )
    )->contexts (
        contexts
        TAO_ENV_ARG_PARAMETER
      );
  return;
}

CORBA_ExceptionDefSeq * _TAO_CORBA_OperationDef_ThruPOA_Proxy_Impl::exceptions (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_ExceptionDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "exceptions",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/OperationDef:1.0"
        )
    )->exceptions (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

void _TAO_CORBA_OperationDef_ThruPOA_Proxy_Impl::exceptions (
    CORBA_Object *_collocated_tao_target_,
    const CORBA_ExceptionDefSeq & exceptions
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "exceptions",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/OperationDef:1.0"
        )
    )->exceptions (
        exceptions
        TAO_ENV_ARG_PARAMETER
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA_OperationDef::POA_CORBA_OperationDef (void)
{
  this->optable_ = &tao_CORBA_OperationDef_optable;
}

// copy ctor
POA_CORBA_OperationDef::POA_CORBA_OperationDef (const POA_CORBA_OperationDef& rhs)
  :   POA_CORBA_Contained (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA_OperationDef::~POA_CORBA_OperationDef (void)
{
}

void POA_CORBA_OperationDef::_get_result_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_OperationDef *_tao_impl =
    ACE_static_cast (POA_CORBA_OperationDef *, _tao_object_reference);

    CORBA::TypeCode_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_OperationDef_result_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->result (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::TypeCode_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_OperationDef::_get_result_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_OperationDef *_tao_impl =
    ACE_static_cast (POA_CORBA_OperationDef *, _tao_object_reference);

    CORBA_IDLType_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_OperationDef_result_def_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->result_def (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_IDLType_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_OperationDef::_set_result_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_OperationDef *_tao_impl =
    ACE_static_cast (POA_CORBA_OperationDef *, _tao_object_reference);

  _tao_server_request.argument_flag (0);
    CORBA_IDLType_var result_def;
  if (!(
    (_tao_in >> result_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_OperationDef_result_def_set ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      result_def.in ()
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->result_def (
          result_def.in ()
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_OperationDef::_get_params_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_OperationDef *_tao_impl =
    ACE_static_cast (POA_CORBA_OperationDef *, _tao_object_reference);

    CORBA_ParDescriptionSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_OperationDef_params_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->params (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_ParDescriptionSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_OperationDef::_set_params_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_OperationDef *_tao_impl =
    ACE_static_cast (POA_CORBA_OperationDef *, _tao_object_reference);

  _tao_server_request.argument_flag (0);
    CORBA_ParDescriptionSeq params;
  if (!(
    (_tao_in >> params)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_OperationDef_params_set ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      params
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->params (
          params
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_OperationDef::_get_mode_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_OperationDef *_tao_impl =
    ACE_static_cast (POA_CORBA_OperationDef *, _tao_object_reference);

    CORBA::OperationMode _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_OperationDef_mode_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->mode (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::OperationMode _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval)
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_OperationDef::_set_mode_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_OperationDef *_tao_impl =
    ACE_static_cast (POA_CORBA_OperationDef *, _tao_object_reference);

  _tao_server_request.argument_flag (0);
    CORBA::OperationMode mode;
  if (!(
    (_tao_in >> mode)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_OperationDef_mode_set ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      mode
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->mode (
          mode
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_OperationDef::_get_contexts_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_OperationDef *_tao_impl =
    ACE_static_cast (POA_CORBA_OperationDef *, _tao_object_reference);

    CORBA_ContextIdSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_OperationDef_contexts_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->contexts (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_ContextIdSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_OperationDef::_set_contexts_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_OperationDef *_tao_impl =
    ACE_static_cast (POA_CORBA_OperationDef *, _tao_object_reference);

  _tao_server_request.argument_flag (0);
    CORBA_ContextIdSeq contexts;
  if (!(
    (_tao_in >> contexts)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_OperationDef_contexts_set ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      contexts
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->contexts (
          contexts
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_OperationDef::_get_exceptions_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_OperationDef *_tao_impl =
    ACE_static_cast (POA_CORBA_OperationDef *, _tao_object_reference);

    CORBA_ExceptionDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_OperationDef_exceptions_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->exceptions (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_ExceptionDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_OperationDef::_set_exceptions_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_OperationDef *_tao_impl =
    ACE_static_cast (POA_CORBA_OperationDef *, _tao_object_reference);

  _tao_server_request.argument_flag (0);
    CORBA_ExceptionDefSeq exceptions;
  if (!(
    (_tao_in >> exceptions)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_OperationDef_exceptions_set ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      exceptions
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->exceptions (
          exceptions
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_OperationDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_OperationDef *_tao_impl = (POA_CORBA_OperationDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () TAO_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_OperationDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_OperationDef *_tao_impl = (POA_CORBA_OperationDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_OperationDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_OperationDef *_tao_impl = (POA_CORBA_OperationDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_CORBA_OperationDef::_is_a (
    const char* value
    TAO_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/OperationDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA_OperationDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/OperationDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_OperationDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA_OperationDef::_dispatch (TAO_ServerRequest &req, void *servant_upcall TAO_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     TAO_ENV_ARG_PARAMETER);
}


const char* POA_CORBA_OperationDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/OperationDef:1.0";
}

CORBA_OperationDef*
POA_CORBA_OperationDef::_this (TAO_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::CORBA_OperationDef::_unchecked_narrow (obj.in ());
}


class TAO_CORBA_InterfaceDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:45:40 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_InterfaceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_InterfaceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 25,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71,  0,
     71,  0, 20,  0, 71, 71, 71,  5, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 20,  0,  5,
     71, 15, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 25, 11, 71, 71, 71, 20,  0, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71,
#else
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 25, 71,  0, 71,  0,
     20,  0, 71, 71, 71,  5, 71, 71, 20,  0,
      5, 71, 15, 71, 71, 25, 11, 71, 71, 71,
     20,  0, 71, 71, 71, 71, 71, 71,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_InterfaceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 40,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 70,
      HASH_VALUE_RANGE = 67,
      DUPLICATES = 9,
      WORDLIST_SIZE = 44
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_CORBA_InterfaceDef::move_skel},
      {"is_a",  &POA_CORBA_InterfaceDef::is_a_skel},
      {"create_enum",   &POA_CORBA_InterfaceDef::create_enum_skel},
      {"create_value",  &POA_CORBA_InterfaceDef::create_value_skel},
      {"create_module",         &POA_CORBA_InterfaceDef::create_module_skel},
      {"create_native",         &POA_CORBA_InterfaceDef::create_native_skel},
      {"create_attribute",      &POA_CORBA_InterfaceDef::create_attribute_skel},
      {"create_interface",      &POA_CORBA_InterfaceDef::create_interface_skel},
      {"create_union",  &POA_CORBA_InterfaceDef::create_union_skel},
      {"create_operation",      &POA_CORBA_InterfaceDef::create_operation_skel},
      {"create_exception",      &POA_CORBA_InterfaceDef::create_exception_skel},
      {"create_local_interface",        &POA_CORBA_InterfaceDef::create_local_interface_skel},
      {"create_struct",         &POA_CORBA_InterfaceDef::create_struct_skel},
      {"create_abstract_interface",     &POA_CORBA_InterfaceDef::create_abstract_interface_skel},
      {"create_constant",       &POA_CORBA_InterfaceDef::create_constant_skel},
      {"destroy",       &POA_CORBA_InterfaceDef::destroy_skel},
      {"describe",      &POA_CORBA_InterfaceDef::describe_skel},
      {"_is_a",  &POA_CORBA_InterfaceDef::_is_a_skel},
      {"lookup_name",   &POA_CORBA_InterfaceDef::lookup_name_skel},
      {"contents",      &POA_CORBA_InterfaceDef::contents_skel},
      {"_get_name",     &POA_CORBA_InterfaceDef::_get_name_skel},
      {"_get_type",     &POA_CORBA_InterfaceDef::_get_type_skel},
      {"_set_name",     &POA_CORBA_InterfaceDef::_set_name_skel},
      {"_interface",  &POA_CORBA_InterfaceDef::_interface_skel},
      {"create_value_box",      &POA_CORBA_InterfaceDef::create_value_box_skel},
      {"create_alias",  &POA_CORBA_InterfaceDef::create_alias_skel},
      {"describe_interface",    &POA_CORBA_InterfaceDef::describe_interface_skel},
      {"lookup",        &POA_CORBA_InterfaceDef::lookup_skel},
      {"_get_version",  &POA_CORBA_InterfaceDef::_get_version_skel},
      {"_set_version",  &POA_CORBA_InterfaceDef::_set_version_skel},
      {"_get_absolute_name",    &POA_CORBA_InterfaceDef::_get_absolute_name_skel},
      {"_get_defined_in",       &POA_CORBA_InterfaceDef::_get_defined_in_skel},
      {"_non_existent",  &POA_CORBA_InterfaceDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_CORBA_InterfaceDef::_get_containing_repository_skel},
      {"_get_id",       &POA_CORBA_InterfaceDef::_get_id_skel},
      {"_set_id",       &POA_CORBA_InterfaceDef::_set_id_skel},
      {"_get_def_kind",         &POA_CORBA_InterfaceDef::_get_def_kind_skel},
      {"describe_contents",     &POA_CORBA_InterfaceDef::describe_contents_skel},
      {"_get_base_interfaces",  &POA_CORBA_InterfaceDef::_get_base_interfaces_skel},
      {"_set_base_interfaces",  &POA_CORBA_InterfaceDef::_set_base_interfaces_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,  -8,  -2, -10,  -2,   5,  -1,   6,   7, -78,
      -13,  -2, -79,  12,  -1, -24,  -3, -77,  15,  -1,  16,  17,  18,  19,
       20,  -1,  21,  22,  -1,  23, -85,  27,  28,  29,  30, -32,  -2,  31,
      -73,  34,  -1,  35,  -1, -38,  -2,  36,  -1,  37, -75,  -1,  -1,  -1,
       -1,  -1,  40,  -1,  -1,  -1,  41,  -1,  -1,  -1,  -1,  -1, -42,  -2,
      -72,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:45:41 */
static TAO_CORBA_InterfaceDef_Perfect_Hash_OpTable tao_CORBA_InterfaceDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_CORBA_InterfaceDef_base_interfaces_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_InterfaceDef_base_interfaces_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_InterfaceDef *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_InterfaceDefSeq * result);

private:
  TAO_ServerRequestInfo_CORBA_InterfaceDef_base_interfaces_get (const TAO_ServerRequestInfo_CORBA_InterfaceDef_base_interfaces_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_InterfaceDef_base_interfaces_get &);

private:
  POA_CORBA_InterfaceDef *_tao_impl;
  CORBA_InterfaceDefSeq * _result;
};

TAO_ServerRequestInfo_CORBA_InterfaceDef_base_interfaces_get::TAO_ServerRequestInfo_CORBA_InterfaceDef_base_interfaces_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_InterfaceDef *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_InterfaceDef_base_interfaces_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_InterfaceDef_base_interfaces_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_InterfaceDef_base_interfaces_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_InterfaceDef_base_interfaces_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_InterfaceDef_base_interfaces_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_InterfaceDef_base_interfaces_get::result (CORBA_InterfaceDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_InterfaceDef_base_interfaces_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_InterfaceDef_base_interfaces_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_InterfaceDef *tao_impl
    ,
    const CORBA_InterfaceDefSeq & base_interfaces
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));


private:
  TAO_ServerRequestInfo_CORBA_InterfaceDef_base_interfaces_set (const TAO_ServerRequestInfo_CORBA_InterfaceDef_base_interfaces_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_InterfaceDef_base_interfaces_set &);

private:
  POA_CORBA_InterfaceDef *_tao_impl;
  const CORBA_InterfaceDefSeq & base_interfaces_;

};

TAO_ServerRequestInfo_CORBA_InterfaceDef_base_interfaces_set::TAO_ServerRequestInfo_CORBA_InterfaceDef_base_interfaces_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_InterfaceDef *tao_impl,
    const CORBA_InterfaceDefSeq & base_interfaces
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    base_interfaces_ (base_interfaces)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_InterfaceDef_base_interfaces_set::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->base_interfaces_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_InterfaceDef_base_interfaces_set::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_InterfaceDef_base_interfaces_set::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_InterfaceDef_base_interfaces_set::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_InterfaceDef_base_interfaces_set::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_CORBA_InterfaceDef_is_a : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_InterfaceDef_is_a (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_InterfaceDef *tao_impl
    ,
    const char * interface_id
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Boolean result);

private:
  TAO_ServerRequestInfo_CORBA_InterfaceDef_is_a (const TAO_ServerRequestInfo_CORBA_InterfaceDef_is_a &);
  void operator= (const TAO_ServerRequestInfo_CORBA_InterfaceDef_is_a &);

private:
  POA_CORBA_InterfaceDef *_tao_impl;
  const char * interface_id_;
  CORBA::Boolean _result;
};

TAO_ServerRequestInfo_CORBA_InterfaceDef_is_a::TAO_ServerRequestInfo_CORBA_InterfaceDef_is_a (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_InterfaceDef *tao_impl,
    const char * interface_id
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    interface_id_ (interface_id)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_InterfaceDef_is_a::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= interface_id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_InterfaceDef_is_a::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_InterfaceDef_is_a::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= CORBA::Any::from_boolean (this->_result);

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_InterfaceDef_is_a::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_InterfaceDef_is_a::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_InterfaceDef_is_a::result (CORBA::Boolean result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_InterfaceDef_describe_interface : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_InterfaceDef_describe_interface (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_InterfaceDef *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_InterfaceDef::FullInterfaceDescription * result);

private:
  TAO_ServerRequestInfo_CORBA_InterfaceDef_describe_interface (const TAO_ServerRequestInfo_CORBA_InterfaceDef_describe_interface &);
  void operator= (const TAO_ServerRequestInfo_CORBA_InterfaceDef_describe_interface &);

private:
  POA_CORBA_InterfaceDef *_tao_impl;
  CORBA_InterfaceDef::FullInterfaceDescription * _result;
};

TAO_ServerRequestInfo_CORBA_InterfaceDef_describe_interface::TAO_ServerRequestInfo_CORBA_InterfaceDef_describe_interface (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_InterfaceDef *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_InterfaceDef_describe_interface::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_InterfaceDef_describe_interface::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_InterfaceDef_describe_interface::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_InterfaceDef_describe_interface::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_InterfaceDef_describe_interface::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_InterfaceDef_describe_interface::result (CORBA_InterfaceDef::FullInterfaceDescription * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_InterfaceDef_create_attribute : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_InterfaceDef_create_attribute (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_InterfaceDef *tao_impl
    ,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr type,
    CORBA::AttributeMode & mode
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_AttributeDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_InterfaceDef_create_attribute (const TAO_ServerRequestInfo_CORBA_InterfaceDef_create_attribute &);
  void operator= (const TAO_ServerRequestInfo_CORBA_InterfaceDef_create_attribute &);

private:
  POA_CORBA_InterfaceDef *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_IDLType_ptr type_;
  const CORBA::AttributeMode & mode_;
  CORBA_AttributeDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_InterfaceDef_create_attribute::TAO_ServerRequestInfo_CORBA_InterfaceDef_create_attribute (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_InterfaceDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr type,
    CORBA::AttributeMode & mode
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    type_ (type),
    mode_ (mode)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_InterfaceDef_create_attribute::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (5);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->mode_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_InterfaceDef_create_attribute::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_InterfaceDef_create_attribute::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_InterfaceDef_create_attribute::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_InterfaceDef_create_attribute::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_InterfaceDef_create_attribute::result (CORBA_AttributeDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_InterfaceDef_create_operation : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_InterfaceDef_create_operation (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_InterfaceDef *tao_impl
    ,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr result,
    CORBA::OperationMode & mode,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions,
    const CORBA_ContextIdSeq & contexts
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_OperationDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_InterfaceDef_create_operation (const TAO_ServerRequestInfo_CORBA_InterfaceDef_create_operation &);
  void operator= (const TAO_ServerRequestInfo_CORBA_InterfaceDef_create_operation &);

private:
  POA_CORBA_InterfaceDef *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_IDLType_ptr result_;
  const CORBA::OperationMode & mode_;
  const CORBA_ParDescriptionSeq & params_;
  const CORBA_ExceptionDefSeq & exceptions_;
  const CORBA_ContextIdSeq & contexts_;
  CORBA_OperationDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_InterfaceDef_create_operation::TAO_ServerRequestInfo_CORBA_InterfaceDef_create_operation (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_InterfaceDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr result,
    CORBA::OperationMode & mode,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions,
    const CORBA_ContextIdSeq & contexts
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    result_ (result),
    mode_ (mode),
    params_ (params),
    exceptions_ (exceptions),
    contexts_ (contexts)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_InterfaceDef_create_operation::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (8);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->result_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->mode_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->params_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->exceptions_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->contexts_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_InterfaceDef_create_operation::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_InterfaceDef_create_operation::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_InterfaceDef_create_operation::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_InterfaceDef_create_operation::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_InterfaceDef_create_operation::result (CORBA_OperationDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
_TAO_CORBA_InterfaceDef_Strategized_Proxy_Broker *_TAO_CORBA_InterfaceDef_Strategized_Proxy_Broker::the_TAO_CORBA_InterfaceDef_Strategized_Proxy_Broker (void)
{
  static _TAO_CORBA_InterfaceDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_CORBA_InterfaceDef_Strategized_Proxy_Broker::_TAO_CORBA_InterfaceDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

_TAO_CORBA_InterfaceDef_Strategized_Proxy_Broker::~_TAO_CORBA_InterfaceDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_CORBA_InterfaceDef_Proxy_Impl&
_TAO_CORBA_InterfaceDef_Strategized_Proxy_Broker::select_proxy (
    ::CORBA_InterfaceDef *object
    TAO_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
_TAO_CORBA_InterfaceDef_Strategized_Proxy_Broker::create_proxy (
    int strategy
    TAO_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_CORBA_InterfaceDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_CORBA_InterfaceDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_CORBA_InterfaceDef_Proxy_Broker *
_TAO_CORBA_InterfaceDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::_TAO_CORBA_InterfaceDef_Strategized_Proxy_Broker::the_TAO_CORBA_InterfaceDef_Strategized_Proxy_Broker();
}

int
_TAO_CORBA_InterfaceDef_Proxy_Broker_Factory_Initializer (long)
{
  _TAO_CORBA_InterfaceDef_Proxy_Broker_Factory_function_pointer =
    _TAO_CORBA_InterfaceDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_CORBA_InterfaceDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_CORBA_InterfaceDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_CORBA_InterfaceDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

_TAO_CORBA_InterfaceDef_ThruPOA_Proxy_Impl::_TAO_CORBA_InterfaceDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA_InterfaceDefSeq * _TAO_CORBA_InterfaceDef_ThruPOA_Proxy_Impl::base_interfaces (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_InterfaceDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "base_interfaces",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        )
    )->base_interfaces (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

void _TAO_CORBA_InterfaceDef_ThruPOA_Proxy_Impl::base_interfaces (
    CORBA_Object *_collocated_tao_target_,
    const CORBA_InterfaceDefSeq & base_interfaces
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "base_interfaces",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        )
    )->base_interfaces (
        base_interfaces
        TAO_ENV_ARG_PARAMETER
      );
  return;
}

CORBA::Boolean _TAO_CORBA_InterfaceDef_ThruPOA_Proxy_Impl::is_a (
    CORBA_Object *_collocated_tao_target_,
    const char * interface_id
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_a",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_CORBA_InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        )
    )->is_a (
        interface_id
        TAO_ENV_ARG_PARAMETER
      );
}

CORBA_InterfaceDef::FullInterfaceDescription * _TAO_CORBA_InterfaceDef_ThruPOA_Proxy_Impl::describe_interface (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_InterfaceDef::FullInterfaceDescription_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "describe_interface",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        )
    )->describe_interface (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

CORBA_AttributeDef_ptr _TAO_CORBA_InterfaceDef_ThruPOA_Proxy_Impl::create_attribute (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr type,
    CORBA::AttributeMode mode
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_AttributeDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_attribute",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        )
    )->create_attribute (
        id,
        name,
        version,
        type,
        mode
        TAO_ENV_ARG_PARAMETER
      );
}

CORBA_OperationDef_ptr _TAO_CORBA_InterfaceDef_ThruPOA_Proxy_Impl::create_operation (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr result,
    CORBA::OperationMode mode,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions,
    const CORBA_ContextIdSeq & contexts
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_OperationDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_operation",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        )
    )->create_operation (
        id,
        name,
        version,
        result,
        mode,
        params,
        exceptions,
        contexts
        TAO_ENV_ARG_PARAMETER
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA_InterfaceDef::POA_CORBA_InterfaceDef (void)
{
  this->optable_ = &tao_CORBA_InterfaceDef_optable;
}

// copy ctor
POA_CORBA_InterfaceDef::POA_CORBA_InterfaceDef (const POA_CORBA_InterfaceDef& rhs)
  :   POA_CORBA_Container (rhs),
    POA_CORBA_Contained (rhs),
    POA_CORBA_IDLType (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA_InterfaceDef::~POA_CORBA_InterfaceDef (void)
{
}

void POA_CORBA_InterfaceDef::_get_base_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_InterfaceDef *_tao_impl =
    ACE_static_cast (POA_CORBA_InterfaceDef *, _tao_object_reference);

    CORBA_InterfaceDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_InterfaceDef_base_interfaces_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->base_interfaces (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_InterfaceDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_InterfaceDef::_set_base_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_InterfaceDef *_tao_impl =
    ACE_static_cast (POA_CORBA_InterfaceDef *, _tao_object_reference);

  _tao_server_request.argument_flag (0);
    CORBA_InterfaceDefSeq base_interfaces;
  if (!(
    (_tao_in >> base_interfaces)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_InterfaceDef_base_interfaces_set ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      base_interfaces
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->base_interfaces (
          base_interfaces
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_InterfaceDef::is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_InterfaceDef *_tao_impl =
    ACE_static_cast (POA_CORBA_InterfaceDef *, _tao_object_reference);

    CORBA::Boolean _tao_retval = 0;
  CORBA::String_var interface_id;
  if (!(
    (_tao_in >> interface_id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_InterfaceDef_is_a ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      interface_id.in ()
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->is_a (
          interface_id.in ()
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Boolean _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << CORBA::Any::from_boolean (_tao_retval))
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_InterfaceDef::describe_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_InterfaceDef *_tao_impl =
    ACE_static_cast (POA_CORBA_InterfaceDef *, _tao_object_reference);

    CORBA_InterfaceDef::FullInterfaceDescription_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_InterfaceDef_describe_interface ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->describe_interface (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_InterfaceDef::FullInterfaceDescription * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_InterfaceDef::create_attribute_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_InterfaceDef *_tao_impl =
    ACE_static_cast (POA_CORBA_InterfaceDef *, _tao_object_reference);

    CORBA_AttributeDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_IDLType_var type;
  CORBA::AttributeMode mode;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> type.out ()) &&
    (_tao_in >> mode)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_InterfaceDef_create_attribute ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      type.in (),
      mode
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_attribute (
          id.in (),
          name.in (),
          version.in (),
          type.in (),
          mode
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_AttributeDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_InterfaceDef::create_operation_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_InterfaceDef *_tao_impl =
    ACE_static_cast (POA_CORBA_InterfaceDef *, _tao_object_reference);

    CORBA_OperationDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_IDLType_var result;
  CORBA::OperationMode mode;
  CORBA_ParDescriptionSeq params;
  CORBA_ExceptionDefSeq exceptions;
  CORBA_ContextIdSeq contexts;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> result.out ()) &&
    (_tao_in >> mode) &&
    (_tao_in >> params) &&
    (_tao_in >> exceptions) &&
    (_tao_in >> contexts)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_InterfaceDef_create_operation ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      result.in (),
      mode,
      params,
      exceptions,
      contexts
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_operation (
          id.in (),
          name.in (),
          version.in (),
          result.in (),
          mode,
          params,
          exceptions,
          contexts
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_OperationDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_InterfaceDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_InterfaceDef *_tao_impl = (POA_CORBA_InterfaceDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () TAO_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_InterfaceDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_InterfaceDef *_tao_impl = (POA_CORBA_InterfaceDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_InterfaceDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_InterfaceDef *_tao_impl = (POA_CORBA_InterfaceDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_CORBA_InterfaceDef::_is_a (
    const char* value
    TAO_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA_InterfaceDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/InterfaceDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_InterfaceDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Container:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA_InterfaceDef::_dispatch (TAO_ServerRequest &req, void *servant_upcall TAO_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     TAO_ENV_ARG_PARAMETER);
}


const char* POA_CORBA_InterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/InterfaceDef:1.0";
}

CORBA_InterfaceDef*
POA_CORBA_InterfaceDef::_this (TAO_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::CORBA_InterfaceDef::_unchecked_narrow (obj.in ());
}


class TAO_CORBA_AbstractInterfaceDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:45:42 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_AbstractInterfaceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_AbstractInterfaceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 25,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71,  0,
     71,  0, 20,  0, 71, 71, 71,  5, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 20,  0,  5,
     71, 15, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 25, 11, 71, 71, 71, 20,  0, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71,
#else
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 25, 71,  0, 71,  0,
     20,  0, 71, 71, 71,  5, 71, 71, 20,  0,
      5, 71, 15, 71, 71, 25, 11, 71, 71, 71,
     20,  0, 71, 71, 71, 71, 71, 71,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_AbstractInterfaceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 40,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 70,
      HASH_VALUE_RANGE = 67,
      DUPLICATES = 9,
      WORDLIST_SIZE = 44
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_CORBA_AbstractInterfaceDef::move_skel},
      {"is_a",  &POA_CORBA_AbstractInterfaceDef::is_a_skel},
      {"create_enum",   &POA_CORBA_AbstractInterfaceDef::create_enum_skel},
      {"create_value",  &POA_CORBA_AbstractInterfaceDef::create_value_skel},
      {"create_module",         &POA_CORBA_AbstractInterfaceDef::create_module_skel},
      {"create_native",         &POA_CORBA_AbstractInterfaceDef::create_native_skel},
      {"create_attribute",      &POA_CORBA_AbstractInterfaceDef::create_attribute_skel},
      {"create_interface",      &POA_CORBA_AbstractInterfaceDef::create_interface_skel},
      {"create_union",  &POA_CORBA_AbstractInterfaceDef::create_union_skel},
      {"create_operation",      &POA_CORBA_AbstractInterfaceDef::create_operation_skel},
      {"create_exception",      &POA_CORBA_AbstractInterfaceDef::create_exception_skel},
      {"create_local_interface",        &POA_CORBA_AbstractInterfaceDef::create_local_interface_skel},
      {"create_struct",         &POA_CORBA_AbstractInterfaceDef::create_struct_skel},
      {"create_abstract_interface",     &POA_CORBA_AbstractInterfaceDef::create_abstract_interface_skel},
      {"create_constant",       &POA_CORBA_AbstractInterfaceDef::create_constant_skel},
      {"destroy",       &POA_CORBA_AbstractInterfaceDef::destroy_skel},
      {"describe",      &POA_CORBA_AbstractInterfaceDef::describe_skel},
      {"_is_a",  &POA_CORBA_AbstractInterfaceDef::_is_a_skel},
      {"lookup_name",   &POA_CORBA_AbstractInterfaceDef::lookup_name_skel},
      {"contents",      &POA_CORBA_AbstractInterfaceDef::contents_skel},
      {"_get_name",     &POA_CORBA_AbstractInterfaceDef::_get_name_skel},
      {"_get_type",     &POA_CORBA_AbstractInterfaceDef::_get_type_skel},
      {"_set_name",     &POA_CORBA_AbstractInterfaceDef::_set_name_skel},
      {"_interface",  &POA_CORBA_AbstractInterfaceDef::_interface_skel},
      {"create_value_box",      &POA_CORBA_AbstractInterfaceDef::create_value_box_skel},
      {"create_alias",  &POA_CORBA_AbstractInterfaceDef::create_alias_skel},
      {"describe_interface",    &POA_CORBA_AbstractInterfaceDef::describe_interface_skel},
      {"lookup",        &POA_CORBA_AbstractInterfaceDef::lookup_skel},
      {"_get_version",  &POA_CORBA_AbstractInterfaceDef::_get_version_skel},
      {"_set_version",  &POA_CORBA_AbstractInterfaceDef::_set_version_skel},
      {"_get_absolute_name",    &POA_CORBA_AbstractInterfaceDef::_get_absolute_name_skel},
      {"_get_defined_in",       &POA_CORBA_AbstractInterfaceDef::_get_defined_in_skel},
      {"_non_existent",  &POA_CORBA_AbstractInterfaceDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_CORBA_AbstractInterfaceDef::_get_containing_repository_skel},
      {"_get_id",       &POA_CORBA_AbstractInterfaceDef::_get_id_skel},
      {"_set_id",       &POA_CORBA_AbstractInterfaceDef::_set_id_skel},
      {"_get_def_kind",         &POA_CORBA_AbstractInterfaceDef::_get_def_kind_skel},
      {"describe_contents",     &POA_CORBA_AbstractInterfaceDef::describe_contents_skel},
      {"_get_base_interfaces",  &POA_CORBA_AbstractInterfaceDef::_get_base_interfaces_skel},
      {"_set_base_interfaces",  &POA_CORBA_AbstractInterfaceDef::_set_base_interfaces_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,  -8,  -2, -10,  -2,   5,  -1,   6,   7, -78,
      -13,  -2, -79,  12,  -1, -24,  -3, -77,  15,  -1,  16,  17,  18,  19,
       20,  -1,  21,  22,  -1,  23, -85,  27,  28,  29,  30, -32,  -2,  31,
      -73,  34,  -1,  35,  -1, -38,  -2,  36,  -1,  37, -75,  -1,  -1,  -1,
       -1,  -1,  40,  -1,  -1,  -1,  41,  -1,  -1,  -1,  -1,  -1, -42,  -2,
      -72,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:45:42 */
static TAO_CORBA_AbstractInterfaceDef_Perfect_Hash_OpTable tao_CORBA_AbstractInterfaceDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
_TAO_CORBA_AbstractInterfaceDef_Strategized_Proxy_Broker *_TAO_CORBA_AbstractInterfaceDef_Strategized_Proxy_Broker::the_TAO_CORBA_AbstractInterfaceDef_Strategized_Proxy_Broker (void)
{
  static _TAO_CORBA_AbstractInterfaceDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_CORBA_AbstractInterfaceDef_Strategized_Proxy_Broker::_TAO_CORBA_AbstractInterfaceDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

_TAO_CORBA_AbstractInterfaceDef_Strategized_Proxy_Broker::~_TAO_CORBA_AbstractInterfaceDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_CORBA_AbstractInterfaceDef_Proxy_Impl&
_TAO_CORBA_AbstractInterfaceDef_Strategized_Proxy_Broker::select_proxy (
    ::CORBA_AbstractInterfaceDef *object
    TAO_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
_TAO_CORBA_AbstractInterfaceDef_Strategized_Proxy_Broker::create_proxy (
    int strategy
    TAO_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_CORBA_AbstractInterfaceDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_CORBA_AbstractInterfaceDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_CORBA_AbstractInterfaceDef_Proxy_Broker *
_TAO_CORBA_AbstractInterfaceDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::_TAO_CORBA_AbstractInterfaceDef_Strategized_Proxy_Broker::the_TAO_CORBA_AbstractInterfaceDef_Strategized_Proxy_Broker();
}

int
_TAO_CORBA_AbstractInterfaceDef_Proxy_Broker_Factory_Initializer (long)
{
  _TAO_CORBA_AbstractInterfaceDef_Proxy_Broker_Factory_function_pointer =
    _TAO_CORBA_AbstractInterfaceDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_CORBA_AbstractInterfaceDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_CORBA_AbstractInterfaceDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_CORBA_AbstractInterfaceDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

_TAO_CORBA_AbstractInterfaceDef_ThruPOA_Proxy_Impl::_TAO_CORBA_AbstractInterfaceDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA_AbstractInterfaceDef::POA_CORBA_AbstractInterfaceDef (void)
{
  this->optable_ = &tao_CORBA_AbstractInterfaceDef_optable;
}

// copy ctor
POA_CORBA_AbstractInterfaceDef::POA_CORBA_AbstractInterfaceDef (const POA_CORBA_AbstractInterfaceDef& rhs)
  :   POA_CORBA_InterfaceDef (rhs),
    POA_CORBA_Container (rhs),
    POA_CORBA_Contained (rhs),
    POA_CORBA_IDLType (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA_AbstractInterfaceDef::~POA_CORBA_AbstractInterfaceDef (void)
{
}

void POA_CORBA_AbstractInterfaceDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_AbstractInterfaceDef *_tao_impl = (POA_CORBA_AbstractInterfaceDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () TAO_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_AbstractInterfaceDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_AbstractInterfaceDef *_tao_impl = (POA_CORBA_AbstractInterfaceDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_AbstractInterfaceDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_AbstractInterfaceDef *_tao_impl = (POA_CORBA_AbstractInterfaceDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_CORBA_AbstractInterfaceDef::_is_a (
    const char* value
    TAO_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/AbstractInterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA_AbstractInterfaceDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/AbstractInterfaceDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_AbstractInterfaceDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/InterfaceDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_InterfaceDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Container:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA_AbstractInterfaceDef::_dispatch (TAO_ServerRequest &req, void *servant_upcall TAO_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     TAO_ENV_ARG_PARAMETER);
}


const char* POA_CORBA_AbstractInterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/AbstractInterfaceDef:1.0";
}

CORBA_AbstractInterfaceDef*
POA_CORBA_AbstractInterfaceDef::_this (TAO_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::CORBA_AbstractInterfaceDef::_unchecked_narrow (obj.in ());
}


class TAO_CORBA_LocalInterfaceDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:45:43 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_LocalInterfaceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_LocalInterfaceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 25,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71,  0,
     71,  0, 20,  0, 71, 71, 71,  5, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 20,  0,  5,
     71, 15, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 25, 11, 71, 71, 71, 20,  0, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71,
#else
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 25, 71,  0, 71,  0,
     20,  0, 71, 71, 71,  5, 71, 71, 20,  0,
      5, 71, 15, 71, 71, 25, 11, 71, 71, 71,
     20,  0, 71, 71, 71, 71, 71, 71,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_LocalInterfaceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 40,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 70,
      HASH_VALUE_RANGE = 67,
      DUPLICATES = 9,
      WORDLIST_SIZE = 44
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_CORBA_LocalInterfaceDef::move_skel},
      {"is_a",  &POA_CORBA_LocalInterfaceDef::is_a_skel},
      {"create_enum",   &POA_CORBA_LocalInterfaceDef::create_enum_skel},
      {"create_value",  &POA_CORBA_LocalInterfaceDef::create_value_skel},
      {"create_module",         &POA_CORBA_LocalInterfaceDef::create_module_skel},
      {"create_native",         &POA_CORBA_LocalInterfaceDef::create_native_skel},
      {"create_attribute",      &POA_CORBA_LocalInterfaceDef::create_attribute_skel},
      {"create_interface",      &POA_CORBA_LocalInterfaceDef::create_interface_skel},
      {"create_union",  &POA_CORBA_LocalInterfaceDef::create_union_skel},
      {"create_operation",      &POA_CORBA_LocalInterfaceDef::create_operation_skel},
      {"create_exception",      &POA_CORBA_LocalInterfaceDef::create_exception_skel},
      {"create_local_interface",        &POA_CORBA_LocalInterfaceDef::create_local_interface_skel},
      {"create_struct",         &POA_CORBA_LocalInterfaceDef::create_struct_skel},
      {"create_abstract_interface",     &POA_CORBA_LocalInterfaceDef::create_abstract_interface_skel},
      {"create_constant",       &POA_CORBA_LocalInterfaceDef::create_constant_skel},
      {"destroy",       &POA_CORBA_LocalInterfaceDef::destroy_skel},
      {"describe",      &POA_CORBA_LocalInterfaceDef::describe_skel},
      {"_is_a",  &POA_CORBA_LocalInterfaceDef::_is_a_skel},
      {"lookup_name",   &POA_CORBA_LocalInterfaceDef::lookup_name_skel},
      {"contents",      &POA_CORBA_LocalInterfaceDef::contents_skel},
      {"_get_name",     &POA_CORBA_LocalInterfaceDef::_get_name_skel},
      {"_get_type",     &POA_CORBA_LocalInterfaceDef::_get_type_skel},
      {"_set_name",     &POA_CORBA_LocalInterfaceDef::_set_name_skel},
      {"_interface",  &POA_CORBA_LocalInterfaceDef::_interface_skel},
      {"create_value_box",      &POA_CORBA_LocalInterfaceDef::create_value_box_skel},
      {"create_alias",  &POA_CORBA_LocalInterfaceDef::create_alias_skel},
      {"describe_interface",    &POA_CORBA_LocalInterfaceDef::describe_interface_skel},
      {"lookup",        &POA_CORBA_LocalInterfaceDef::lookup_skel},
      {"_get_version",  &POA_CORBA_LocalInterfaceDef::_get_version_skel},
      {"_set_version",  &POA_CORBA_LocalInterfaceDef::_set_version_skel},
      {"_get_absolute_name",    &POA_CORBA_LocalInterfaceDef::_get_absolute_name_skel},
      {"_get_defined_in",       &POA_CORBA_LocalInterfaceDef::_get_defined_in_skel},
      {"_non_existent",  &POA_CORBA_LocalInterfaceDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_CORBA_LocalInterfaceDef::_get_containing_repository_skel},
      {"_get_id",       &POA_CORBA_LocalInterfaceDef::_get_id_skel},
      {"_set_id",       &POA_CORBA_LocalInterfaceDef::_set_id_skel},
      {"_get_def_kind",         &POA_CORBA_LocalInterfaceDef::_get_def_kind_skel},
      {"describe_contents",     &POA_CORBA_LocalInterfaceDef::describe_contents_skel},
      {"_get_base_interfaces",  &POA_CORBA_LocalInterfaceDef::_get_base_interfaces_skel},
      {"_set_base_interfaces",  &POA_CORBA_LocalInterfaceDef::_set_base_interfaces_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,  -8,  -2, -10,  -2,   5,  -1,   6,   7, -78,
      -13,  -2, -79,  12,  -1, -24,  -3, -77,  15,  -1,  16,  17,  18,  19,
       20,  -1,  21,  22,  -1,  23, -85,  27,  28,  29,  30, -32,  -2,  31,
      -73,  34,  -1,  35,  -1, -38,  -2,  36,  -1,  37, -75,  -1,  -1,  -1,
       -1,  -1,  40,  -1,  -1,  -1,  41,  -1,  -1,  -1,  -1,  -1, -42,  -2,
      -72,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:45:43 */
static TAO_CORBA_LocalInterfaceDef_Perfect_Hash_OpTable tao_CORBA_LocalInterfaceDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
_TAO_CORBA_LocalInterfaceDef_Strategized_Proxy_Broker *_TAO_CORBA_LocalInterfaceDef_Strategized_Proxy_Broker::the_TAO_CORBA_LocalInterfaceDef_Strategized_Proxy_Broker (void)
{
  static _TAO_CORBA_LocalInterfaceDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_CORBA_LocalInterfaceDef_Strategized_Proxy_Broker::_TAO_CORBA_LocalInterfaceDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

_TAO_CORBA_LocalInterfaceDef_Strategized_Proxy_Broker::~_TAO_CORBA_LocalInterfaceDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_CORBA_LocalInterfaceDef_Proxy_Impl&
_TAO_CORBA_LocalInterfaceDef_Strategized_Proxy_Broker::select_proxy (
    ::CORBA_LocalInterfaceDef *object
    TAO_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
_TAO_CORBA_LocalInterfaceDef_Strategized_Proxy_Broker::create_proxy (
    int strategy
    TAO_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_CORBA_LocalInterfaceDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_CORBA_LocalInterfaceDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_CORBA_LocalInterfaceDef_Proxy_Broker *
_TAO_CORBA_LocalInterfaceDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::_TAO_CORBA_LocalInterfaceDef_Strategized_Proxy_Broker::the_TAO_CORBA_LocalInterfaceDef_Strategized_Proxy_Broker();
}

int
_TAO_CORBA_LocalInterfaceDef_Proxy_Broker_Factory_Initializer (long)
{
  _TAO_CORBA_LocalInterfaceDef_Proxy_Broker_Factory_function_pointer =
    _TAO_CORBA_LocalInterfaceDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_CORBA_LocalInterfaceDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_CORBA_LocalInterfaceDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_CORBA_LocalInterfaceDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

_TAO_CORBA_LocalInterfaceDef_ThruPOA_Proxy_Impl::_TAO_CORBA_LocalInterfaceDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA_LocalInterfaceDef::POA_CORBA_LocalInterfaceDef (void)
{
  this->optable_ = &tao_CORBA_LocalInterfaceDef_optable;
}

// copy ctor
POA_CORBA_LocalInterfaceDef::POA_CORBA_LocalInterfaceDef (const POA_CORBA_LocalInterfaceDef& rhs)
  :   POA_CORBA_InterfaceDef (rhs),
    POA_CORBA_Container (rhs),
    POA_CORBA_Contained (rhs),
    POA_CORBA_IDLType (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA_LocalInterfaceDef::~POA_CORBA_LocalInterfaceDef (void)
{
}

void POA_CORBA_LocalInterfaceDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_LocalInterfaceDef *_tao_impl = (POA_CORBA_LocalInterfaceDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () TAO_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_LocalInterfaceDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_LocalInterfaceDef *_tao_impl = (POA_CORBA_LocalInterfaceDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_LocalInterfaceDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_LocalInterfaceDef *_tao_impl = (POA_CORBA_LocalInterfaceDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_CORBA_LocalInterfaceDef::_is_a (
    const char* value
    TAO_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/LocalInterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA_LocalInterfaceDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/LocalInterfaceDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_LocalInterfaceDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/InterfaceDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_InterfaceDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Container:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA_LocalInterfaceDef::_dispatch (TAO_ServerRequest &req, void *servant_upcall TAO_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     TAO_ENV_ARG_PARAMETER);
}


const char* POA_CORBA_LocalInterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/LocalInterfaceDef:1.0";
}

CORBA_LocalInterfaceDef*
POA_CORBA_LocalInterfaceDef::_this (TAO_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::CORBA_LocalInterfaceDef::_unchecked_narrow (obj.in ());
}



#endif /* ifndef */
