// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#ifndef _TAO_IDL_IFR_EXTENDEDC_H_
#define _TAO_IDL_IFR_EXTENDEDC_H_

#include "ace/pre.h"
#include "IFR_BasicC.h"

#if !defined (ACE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */

#if defined (TAO_EXPORT_MACRO)
#undef TAO_EXPORT_MACRO
#endif
#define TAO_EXPORT_MACRO TAO_IFR_Client_Export

#if defined (TAO_EXPORT_NESTED_CLASSES)
#  if defined (TAO_EXPORT_NESTED_MACRO)
#    undef TAO_EXPORT_NESTED_MACRO
#  endif /* defined (TAO_EXPORT_NESTED_MACRO) */
#  define TAO_EXPORT_NESTED_MACRO TAO_IFR_Client_Export
#endif /* TAO_EXPORT_NESTED_CLASSES */

#if defined(_MSC_VER)
#if (_MSC_VER >= 1200)
#pragma warning(push)
#endif /* _MSC_VER >= 1200 */
#pragma warning(disable:4250)
#endif /* _MSC_VER */

#if defined (__BORLANDC__)
#pragma option push -w-rvl -w-rch -w-ccc -w-inl
#endif /* __BORLANDC__ */


#if !defined (_CORBA_FIXEDDEF___PTR_CH_)
#define _CORBA_FIXEDDEF___PTR_CH_

class CORBA_FixedDef;
typedef CORBA_FixedDef *CORBA_FixedDef_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_FIXEDDEF___VAR_CH_)
#define _CORBA_FIXEDDEF___VAR_CH_

class TAO_IFR_Client_Export CORBA_FixedDef_var : public TAO_Base_var
{
public:
  CORBA_FixedDef_var (void); // default constructor
  CORBA_FixedDef_var (CORBA_FixedDef_ptr p) : ptr_ (p) {}
  CORBA_FixedDef_var (const CORBA_FixedDef_var &); // copy constructor
  ~CORBA_FixedDef_var (void); // destructor

  CORBA_FixedDef_var &operator= (CORBA_FixedDef_ptr);
  CORBA_FixedDef_var &operator= (const CORBA_FixedDef_var &);
  CORBA_FixedDef_ptr operator-> (void) const;

  operator const CORBA_FixedDef_ptr &() const;
  operator CORBA_FixedDef_ptr &();
  // in, inout, out, _retn
  CORBA_FixedDef_ptr in (void) const;
  CORBA_FixedDef_ptr &inout (void);
  CORBA_FixedDef_ptr &out (void);
  CORBA_FixedDef_ptr _retn (void);
  CORBA_FixedDef_ptr ptr (void) const;

  // Hooks used by template sequence and object manager classes
  // for non-defined forward declared interfaces.
  static CORBA_FixedDef_ptr tao_duplicate (CORBA_FixedDef_ptr);
  static void tao_release (CORBA_FixedDef_ptr);
  static CORBA_FixedDef_ptr tao_nil (void);
  static CORBA_FixedDef_ptr tao_narrow (
      CORBA::Object *
      TAO_ENV_ARG_DECL_NOT_USED
    );
  static CORBA::Object * tao_upcast (void *);

private:
  CORBA_FixedDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  CORBA_FixedDef_var (const TAO_Base_var &rhs);
  CORBA_FixedDef_var &operator= (const TAO_Base_var &rhs);
};


#endif /* end #if !defined */


#if !defined (_CORBA_FIXEDDEF___OUT_CH_)
#define _CORBA_FIXEDDEF___OUT_CH_

class TAO_IFR_Client_Export CORBA_FixedDef_out
{
public:
  CORBA_FixedDef_out (CORBA_FixedDef_ptr &);
  CORBA_FixedDef_out (CORBA_FixedDef_var &);
  CORBA_FixedDef_out (const CORBA_FixedDef_out &);
  CORBA_FixedDef_out &operator= (const CORBA_FixedDef_out &);
  CORBA_FixedDef_out &operator= (const CORBA_FixedDef_var &);
  CORBA_FixedDef_out &operator= (CORBA_FixedDef_ptr);
  operator CORBA_FixedDef_ptr &();
  CORBA_FixedDef_ptr &ptr (void);
  CORBA_FixedDef_ptr operator-> (void);

private:
  CORBA_FixedDef_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_FIXEDDEF_CH_)
#define _CORBA_FIXEDDEF_CH_

// Forward Classes Declaration
class _TAO_CORBA_FixedDef_Proxy_Impl;
class _TAO_CORBA_FixedDef_Remote_Proxy_Impl;
class _TAO_CORBA_FixedDef_Proxy_Broker;
class _TAO_CORBA_FixedDef_Remote_Proxy_Broker;

class TAO_IFR_Client_Export CORBA_FixedDef
  : public virtual CORBA_IDLType
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_FixedDef_ptr _ptr_type;
  typedef CORBA_FixedDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

  // the static operations
  static CORBA_FixedDef_ptr _duplicate (CORBA_FixedDef_ptr obj);

  static CORBA_FixedDef_ptr _narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  static CORBA_FixedDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  static CORBA_FixedDef_ptr _nil (void)
    {
      return (CORBA_FixedDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::UShort digits (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void digits (
      CORBA::UShort digits
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Short scale (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void scale (
      CORBA::Short scale
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_CORBA_FixedDef_Proxy_Broker *the_TAO_CORBA_FixedDef_Proxy_Broker_;

protected:
  CORBA_FixedDef (int collocated = 0);

  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void CORBA_FixedDef_setup_collocation (int collocated);

  CORBA_FixedDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_CORBA_FixedDef_Remote_Proxy_Impl;
  friend class _TAO_CORBA_FixedDef_ThruPOA_Proxy_Impl;
  friend class _TAO_CORBA_FixedDef_Direct_Proxy_Impl;

  virtual ~CORBA_FixedDef (void);

private:
  CORBA_FixedDef (const CORBA_FixedDef &);
  void operator= (const CORBA_FixedDef &);
};

// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base Proxy Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_CORBA_FixedDef_Proxy_Impl
  : public virtual _TAO_CORBA_IDLType_Proxy_Impl
{
public:
  virtual ~_TAO_CORBA_FixedDef_Proxy_Impl (void) { }
  virtual CORBA::UShort digits (
      CORBA_Object *_collocated_tao_target_
      TAO_ENV_ARG_DECL
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void digits (
      CORBA_Object *_collocated_tao_target_,
      CORBA::UShort digits
      TAO_ENV_ARG_DECL
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::Short scale (
      CORBA_Object *_collocated_tao_target_
      TAO_ENV_ARG_DECL
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void scale (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Short scale
      TAO_ENV_ARG_DECL
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;


protected:
  _TAO_CORBA_FixedDef_Proxy_Impl (void);
};

//
//               End Base Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                Remote Proxy Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_CORBA_FixedDef_Remote_Proxy_Impl
  : public virtual _TAO_CORBA_FixedDef_Proxy_Impl,
    public virtual TAO_Remote_Object_Proxy_Impl,
    public virtual _TAO_CORBA_IDLType_Remote_Proxy_Impl
{
public:
  _TAO_CORBA_FixedDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_CORBA_FixedDef_Remote_Proxy_Impl (void) { }
  virtual CORBA::UShort digits (
      CORBA_Object *_collocated_tao_target_
      TAO_ENV_ARG_DECL
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void digits (
      CORBA_Object *_collocated_tao_target_,
      CORBA::UShort digits
      TAO_ENV_ARG_DECL
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Short scale (
      CORBA_Object *_collocated_tao_target_
      TAO_ENV_ARG_DECL
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void scale (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Short scale
      TAO_ENV_ARG_DECL
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));


};

//
//             End Remote Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////

// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.


///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_IFR_Client_Export _TAO_CORBA_FixedDef_Proxy_Broker
{
public:
  virtual ~_TAO_CORBA_FixedDef_Proxy_Broker (void);
  virtual _TAO_CORBA_FixedDef_Proxy_Impl &select_proxy (
      CORBA_FixedDef *object
      TAO_ENV_ARG_DECL_WITH_DEFAULTS
    ) = 0;

protected:
  _TAO_CORBA_FixedDef_Proxy_Broker (void);

};

//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_IFR_Client_Export _TAO_CORBA_FixedDef_Remote_Proxy_Broker
  : public virtual _TAO_CORBA_FixedDef_Proxy_Broker
{
public:
  _TAO_CORBA_FixedDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_CORBA_FixedDef_Remote_Proxy_Broker (void);

  virtual _TAO_CORBA_FixedDef_Proxy_Impl &select_proxy (
      CORBA_FixedDef *object
      TAO_ENV_ARG_DECL
    );

  private:
    _TAO_CORBA_FixedDef_Remote_Proxy_Impl remote_proxy_impl_;

  public:
    // This member function is used to get an handle to the unique instance
    // of the Remote Proxy Broker that is available for a given
    // interface.
    static _TAO_CORBA_FixedDef_Remote_Proxy_Broker *the_TAO_CORBA_FixedDef_Remote_Proxy_Broker (void);
  };

  //
  //              End Remote Proxy Broker Declaration
  ///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */

  struct CORBA_ValueMember;
  class CORBA_ValueMember_var;

  struct TAO_IFR_Client_Export CORBA_ValueMember
  {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef CORBA_ValueMember_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

    static void _tao_any_destructor (void*);

    TAO_String_Manager name;
    TAO_String_Manager id;
    TAO_String_Manager defined_in;
    TAO_String_Manager version;
    CORBA::TypeCode_var type;
    CORBA_IDLType_var type_def;
    CORBA::Visibility access;

  };

  class TAO_IFR_Client_Export CORBA_ValueMember_var
  {
  public:
    CORBA_ValueMember_var (void);
    CORBA_ValueMember_var (CORBA_ValueMember *);
    CORBA_ValueMember_var (const CORBA_ValueMember_var &);
    ~CORBA_ValueMember_var (void);

    CORBA_ValueMember_var &operator= (CORBA_ValueMember *);
    CORBA_ValueMember_var &operator= (const CORBA_ValueMember_var &);
    CORBA_ValueMember *operator-> (void);
    const CORBA_ValueMember *operator-> (void) const;

    operator const CORBA_ValueMember &() const;
    operator CORBA_ValueMember &();
    operator CORBA_ValueMember &() const;
    // Variable-size types only.
    operator CORBA_ValueMember *&();

    // in, inout, out, _retn
    const CORBA_ValueMember &in (void) const;
    CORBA_ValueMember &inout (void);
    CORBA_ValueMember *&out (void);
    CORBA_ValueMember *_retn (void);
    CORBA_ValueMember *ptr (void) const;

  private:
    CORBA_ValueMember *ptr_;
  };

  class TAO_IFR_Client_Export CORBA_ValueMember_out
  {
  public:
    CORBA_ValueMember_out (CORBA_ValueMember *&);
    CORBA_ValueMember_out (CORBA_ValueMember_var &);
    CORBA_ValueMember_out (const CORBA_ValueMember_out &);
    CORBA_ValueMember_out &operator= (const CORBA_ValueMember_out &);
    CORBA_ValueMember_out &operator= (CORBA_ValueMember *);
    operator CORBA_ValueMember *&();
    CORBA_ValueMember *&ptr (void);
    CORBA_ValueMember *operator-> (void);

  private:
    CORBA_ValueMember *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const CORBA_ValueMember_var &);
  };


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_VALUEMEMBERSEQ_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_VALUEMEMBERSEQ_CH_

  class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq
    : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.
    _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq (void);
    _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq (
        CORBA::ULong maximum,
        CORBA::ULong length,
        CORBA_ValueMember *data,
        CORBA::Boolean release = 0
      );
    _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq (
        const _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq &rhs
      );
    _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq &operator= (
        const _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq &rhs
      );
    virtual ~_TAO_Unbounded_Sequence_CORBA_ValueMemberSeq (void);

    // = Accessors.
    CORBA_ValueMember &operator[] (CORBA::ULong i);
    const CORBA_ValueMember &operator[] (CORBA::ULong i) const;

    // = Static operations.
    static CORBA_ValueMember *allocbuf (CORBA::ULong size);
    static void freebuf (CORBA_ValueMember *buffer);

    // Implement the TAO_Base_Sequence methods (see Sequence.h)
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    CORBA_ValueMember *get_buffer (CORBA::Boolean orphan = 0);
    const CORBA_ValueMember *get_buffer (void) const;
    void replace (
        CORBA::ULong max,
        CORBA::ULong length,
        CORBA_ValueMember *data,
        CORBA::Boolean release
      );
  };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_VALUEMEMBERSEQ_CH_)
#define _CORBA_VALUEMEMBERSEQ_CH_

  class CORBA_ValueMemberSeq;
  class CORBA_ValueMemberSeq_var;

  // *************************************************************
  // CORBA_ValueMemberSeq
  // *************************************************************

  class TAO_IFR_Client_Export CORBA_ValueMemberSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_ValueMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    CORBA_ValueMemberSeq (void); // default ctor
    CORBA_ValueMemberSeq (CORBA::ULong max); // uses max size
    CORBA_ValueMemberSeq (
        CORBA::ULong max,
        CORBA::ULong length,
        CORBA_ValueMember *buffer,
        CORBA::Boolean release = 0
      );
    CORBA_ValueMemberSeq (const CORBA_ValueMemberSeq &); // copy ctor
    ~CORBA_ValueMemberSeq (void);
    static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef CORBA_ValueMemberSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */


  };

#endif /* end #if !defined */


#if !defined (_CORBA_VALUEMEMBERSEQ___VAR_CH_)
#define _CORBA_VALUEMEMBERSEQ___VAR_CH_

  // *************************************************************
  // class CORBA_ValueMemberSeq_var
  // *************************************************************

  class TAO_IFR_Client_Export CORBA_ValueMemberSeq_var
  {
  public:
    CORBA_ValueMemberSeq_var (void);
    CORBA_ValueMemberSeq_var (CORBA_ValueMemberSeq *);
    CORBA_ValueMemberSeq_var (const CORBA_ValueMemberSeq_var &);
    ~CORBA_ValueMemberSeq_var (void);

    CORBA_ValueMemberSeq_var &operator= (CORBA_ValueMemberSeq *);
    CORBA_ValueMemberSeq_var &operator= (const CORBA_ValueMemberSeq_var &);
    CORBA_ValueMemberSeq *operator-> (void);
    const CORBA_ValueMemberSeq *operator-> (void) const;

    operator const CORBA_ValueMemberSeq &() const;
    operator CORBA_ValueMemberSeq &();
    operator CORBA_ValueMemberSeq &() const;
    operator CORBA_ValueMemberSeq *&(); // variable-size base types only

    CORBA_ValueMember & operator[] (CORBA::ULong index);
    const CORBA_ValueMember & operator[] (CORBA::ULong index) const;

    // in, inout, out, _retn
    const CORBA_ValueMemberSeq &in (void) const;
    CORBA_ValueMemberSeq &inout (void);
    CORBA_ValueMemberSeq *&out (void);
    CORBA_ValueMemberSeq *_retn (void);
    CORBA_ValueMemberSeq *ptr (void) const;

  private:
    CORBA_ValueMemberSeq *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEMEMBERSEQ___OUT_CH_)
#define _CORBA_VALUEMEMBERSEQ___OUT_CH_

  class TAO_IFR_Client_Export CORBA_ValueMemberSeq_out
  {
  public:
    CORBA_ValueMemberSeq_out (CORBA_ValueMemberSeq *&);
    CORBA_ValueMemberSeq_out (CORBA_ValueMemberSeq_var &);
    CORBA_ValueMemberSeq_out (const CORBA_ValueMemberSeq_out &);
    CORBA_ValueMemberSeq_out &operator= (const CORBA_ValueMemberSeq_out &);
    CORBA_ValueMemberSeq_out &operator= (CORBA_ValueMemberSeq *);
    operator CORBA_ValueMemberSeq *&();
    CORBA_ValueMemberSeq *&ptr (void);
    CORBA_ValueMemberSeq *operator-> (void);
    CORBA_ValueMember & operator[] (CORBA::ULong index);

  private:
    CORBA_ValueMemberSeq *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const CORBA_ValueMemberSeq_var &);
  };


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEMEMBERDEF___PTR_CH_)
#define _CORBA_VALUEMEMBERDEF___PTR_CH_

  class CORBA_ValueMemberDef;
  typedef CORBA_ValueMemberDef *CORBA_ValueMemberDef_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_VALUEMEMBERDEF___VAR_CH_)
#define _CORBA_VALUEMEMBERDEF___VAR_CH_

  class TAO_IFR_Client_Export CORBA_ValueMemberDef_var : public TAO_Base_var
  {
  public:
    CORBA_ValueMemberDef_var (void); // default constructor
    CORBA_ValueMemberDef_var (CORBA_ValueMemberDef_ptr p) : ptr_ (p) {}
    CORBA_ValueMemberDef_var (const CORBA_ValueMemberDef_var &); // copy constructor
    ~CORBA_ValueMemberDef_var (void); // destructor

    CORBA_ValueMemberDef_var &operator= (CORBA_ValueMemberDef_ptr);
    CORBA_ValueMemberDef_var &operator= (const CORBA_ValueMemberDef_var &);
    CORBA_ValueMemberDef_ptr operator-> (void) const;

    operator const CORBA_ValueMemberDef_ptr &() const;
    operator CORBA_ValueMemberDef_ptr &();
    // in, inout, out, _retn
    CORBA_ValueMemberDef_ptr in (void) const;
    CORBA_ValueMemberDef_ptr &inout (void);
    CORBA_ValueMemberDef_ptr &out (void);
    CORBA_ValueMemberDef_ptr _retn (void);
    CORBA_ValueMemberDef_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static CORBA_ValueMemberDef_ptr tao_duplicate (CORBA_ValueMemberDef_ptr);
    static void tao_release (CORBA_ValueMemberDef_ptr);
    static CORBA_ValueMemberDef_ptr tao_nil (void);
    static CORBA_ValueMemberDef_ptr tao_narrow (
        CORBA::Object *
        TAO_ENV_ARG_DECL_NOT_USED
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    CORBA_ValueMemberDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    CORBA_ValueMemberDef_var (const TAO_Base_var &rhs);
    CORBA_ValueMemberDef_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEMEMBERDEF___OUT_CH_)
#define _CORBA_VALUEMEMBERDEF___OUT_CH_

  class TAO_IFR_Client_Export CORBA_ValueMemberDef_out
  {
  public:
    CORBA_ValueMemberDef_out (CORBA_ValueMemberDef_ptr &);
    CORBA_ValueMemberDef_out (CORBA_ValueMemberDef_var &);
    CORBA_ValueMemberDef_out (const CORBA_ValueMemberDef_out &);
    CORBA_ValueMemberDef_out &operator= (const CORBA_ValueMemberDef_out &);
    CORBA_ValueMemberDef_out &operator= (const CORBA_ValueMemberDef_var &);
    CORBA_ValueMemberDef_out &operator= (CORBA_ValueMemberDef_ptr);
    operator CORBA_ValueMemberDef_ptr &();
    CORBA_ValueMemberDef_ptr &ptr (void);
    CORBA_ValueMemberDef_ptr operator-> (void);

  private:
    CORBA_ValueMemberDef_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEMEMBERDEF_CH_)
#define _CORBA_VALUEMEMBERDEF_CH_

  // Forward Classes Declaration
  class _TAO_CORBA_ValueMemberDef_Proxy_Impl;
  class _TAO_CORBA_ValueMemberDef_Remote_Proxy_Impl;
  class _TAO_CORBA_ValueMemberDef_Proxy_Broker;
  class _TAO_CORBA_ValueMemberDef_Remote_Proxy_Broker;

  class TAO_IFR_Client_Export CORBA_ValueMemberDef
    : public virtual CORBA_Contained
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef CORBA_ValueMemberDef_ptr _ptr_type;
    typedef CORBA_ValueMemberDef_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

    // the static operations
    static CORBA_ValueMemberDef_ptr _duplicate (CORBA_ValueMemberDef_ptr obj);

    static CORBA_ValueMemberDef_ptr _narrow (
        CORBA::Object_ptr obj
        TAO_ENV_ARG_DECL_WITH_DEFAULTS);


    static CORBA_ValueMemberDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        TAO_ENV_ARG_DECL_WITH_DEFAULTS);


    static CORBA_ValueMemberDef_ptr _nil (void)
      {
        return (CORBA_ValueMemberDef_ptr)0;
      }

    static void _tao_any_destructor (void*);

    virtual CORBA::TypeCode_ptr type (
        TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_IDLType_ptr type_def (
        TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void type_def (
        CORBA_IDLType_ptr type_def
        TAO_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Visibility access (
        TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void access (
        CORBA::Visibility access
        TAO_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id
        TAO_ENV_ARG_DECL_WITH_DEFAULTS);


    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  private:
    _TAO_CORBA_ValueMemberDef_Proxy_Broker *the_TAO_CORBA_ValueMemberDef_Proxy_Broker_;

  protected:
    CORBA_ValueMemberDef (int collocated = 0);

    // This methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode
    virtual void CORBA_ValueMemberDef_setup_collocation (int collocated);

    CORBA_ValueMemberDef (
        TAO_Stub *objref,
        CORBA::Boolean _tao_collocated = 0,
        TAO_Abstract_ServantBase *servant = 0
      );

    friend class _TAO_CORBA_ValueMemberDef_Remote_Proxy_Impl;
    friend class _TAO_CORBA_ValueMemberDef_ThruPOA_Proxy_Impl;
    friend class _TAO_CORBA_ValueMemberDef_Direct_Proxy_Impl;

    virtual ~CORBA_ValueMemberDef (void);

  private:
    CORBA_ValueMemberDef (const CORBA_ValueMemberDef &);
    void operator= (const CORBA_ValueMemberDef &);
  };

  // The Proxy Implementations are used by each interface to
  // perform a call. Each different implementation encapsulate
  // an invocation logics.


  ///////////////////////////////////////////////////////////////////////
  //                    Base Proxy Impl. Declaration
  //

  class TAO_IFR_Client_Export _TAO_CORBA_ValueMemberDef_Proxy_Impl
    : public virtual _TAO_CORBA_Contained_Proxy_Impl
  {
  public:
    virtual ~_TAO_CORBA_ValueMemberDef_Proxy_Impl (void) { }
    virtual CORBA::TypeCode_ptr type (
        CORBA_Object *_collocated_tao_target_
        TAO_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual CORBA_IDLType_ptr type_def (
        CORBA_Object *_collocated_tao_target_
        TAO_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void type_def (
        CORBA_Object *_collocated_tao_target_,
        CORBA_IDLType_ptr type_def
        TAO_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual CORBA::Visibility access (
        CORBA_Object *_collocated_tao_target_
        TAO_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void access (
        CORBA_Object *_collocated_tao_target_,
        CORBA::Visibility access
        TAO_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;


  protected:
    _TAO_CORBA_ValueMemberDef_Proxy_Impl (void);
  };

  //
  //               End Base Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////
  //                Remote Proxy Impl. Declaration
  //

  class TAO_IFR_Client_Export _TAO_CORBA_ValueMemberDef_Remote_Proxy_Impl
    : public virtual _TAO_CORBA_ValueMemberDef_Proxy_Impl,
      public virtual TAO_Remote_Object_Proxy_Impl,
      public virtual _TAO_CORBA_Contained_Remote_Proxy_Impl
  {
  public:
    _TAO_CORBA_ValueMemberDef_Remote_Proxy_Impl (void);

    virtual ~_TAO_CORBA_ValueMemberDef_Remote_Proxy_Impl (void) { }
    virtual CORBA::TypeCode_ptr type (
        CORBA_Object *_collocated_tao_target_
        TAO_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_IDLType_ptr type_def (
        CORBA_Object *_collocated_tao_target_
        TAO_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void type_def (
        CORBA_Object *_collocated_tao_target_,
        CORBA_IDLType_ptr type_def
        TAO_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Visibility access (
        CORBA_Object *_collocated_tao_target_
        TAO_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void access (
        CORBA_Object *_collocated_tao_target_,
        CORBA::Visibility access
        TAO_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));


  };

  //
  //             End Remote Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////

  // The Proxy Brokers are used by each interface to get
  // the right proxy for performing a call. In the new
  // collocation scheme, the proxy to be used can vary on
  // a call by call basis.


  ///////////////////////////////////////////////////////////////////////
  //                 Base Proxy Broker Declaration
  //

    class TAO_IFR_Client_Export _TAO_CORBA_ValueMemberDef_Proxy_Broker
  {
  public:
    virtual ~_TAO_CORBA_ValueMemberDef_Proxy_Broker (void);
    virtual _TAO_CORBA_ValueMemberDef_Proxy_Impl &select_proxy (
        CORBA_ValueMemberDef *object
        TAO_ENV_ARG_DECL_WITH_DEFAULTS
      ) = 0;

  protected:
    _TAO_CORBA_ValueMemberDef_Proxy_Broker (void);

  };

  //
  //              End Base Proxy Broker Declaration
  ///////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////
  //                 Remote Proxy Broker Declaration
  //

  class TAO_IFR_Client_Export _TAO_CORBA_ValueMemberDef_Remote_Proxy_Broker
    : public virtual _TAO_CORBA_ValueMemberDef_Proxy_Broker
  {
  public:
    _TAO_CORBA_ValueMemberDef_Remote_Proxy_Broker (void);

    virtual ~_TAO_CORBA_ValueMemberDef_Remote_Proxy_Broker (void);

    virtual _TAO_CORBA_ValueMemberDef_Proxy_Impl &select_proxy (
        CORBA_ValueMemberDef *object
        TAO_ENV_ARG_DECL
      );

    private:
      _TAO_CORBA_ValueMemberDef_Remote_Proxy_Impl remote_proxy_impl_;

    public:
      // This member function is used to get an handle to the unique instance
      // of the Remote Proxy Broker that is available for a given
      // interface.
      static _TAO_CORBA_ValueMemberDef_Remote_Proxy_Broker *the_TAO_CORBA_ValueMemberDef_Remote_Proxy_Broker (void);
    };

    //
    //              End Remote Proxy Broker Declaration
    ///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEDEF___PTR_CH_)
#define _CORBA_VALUEDEF___PTR_CH_

    class CORBA_ValueDef;
    typedef CORBA_ValueDef *CORBA_ValueDef_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_VALUEDEF___VAR_CH_)
#define _CORBA_VALUEDEF___VAR_CH_

    class TAO_IFR_Client_Export CORBA_ValueDef_var : public TAO_Base_var
    {
    public:
      CORBA_ValueDef_var (void); // default constructor
      CORBA_ValueDef_var (CORBA_ValueDef_ptr p) : ptr_ (p) {}
      CORBA_ValueDef_var (const CORBA_ValueDef_var &); // copy constructor
      ~CORBA_ValueDef_var (void); // destructor

      CORBA_ValueDef_var &operator= (CORBA_ValueDef_ptr);
      CORBA_ValueDef_var &operator= (const CORBA_ValueDef_var &);
      CORBA_ValueDef_ptr operator-> (void) const;

      operator const CORBA_ValueDef_ptr &() const;
      operator CORBA_ValueDef_ptr &();
      // in, inout, out, _retn
      CORBA_ValueDef_ptr in (void) const;
      CORBA_ValueDef_ptr &inout (void);
      CORBA_ValueDef_ptr &out (void);
      CORBA_ValueDef_ptr _retn (void);
      CORBA_ValueDef_ptr ptr (void) const;

      // Hooks used by template sequence and object manager classes
      // for non-defined forward declared interfaces.
      static CORBA_ValueDef_ptr tao_duplicate (CORBA_ValueDef_ptr);
      static void tao_release (CORBA_ValueDef_ptr);
      static CORBA_ValueDef_ptr tao_nil (void);
      static CORBA_ValueDef_ptr tao_narrow (
          CORBA::Object *
          TAO_ENV_ARG_DECL_NOT_USED
        );
      static CORBA::Object * tao_upcast (void *);

    private:
      CORBA_ValueDef_ptr ptr_;
      // Unimplemented - prevents widening assignment.
      CORBA_ValueDef_var (const TAO_Base_var &rhs);
      CORBA_ValueDef_var &operator= (const TAO_Base_var &rhs);
    };


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEDEF___OUT_CH_)
#define _CORBA_VALUEDEF___OUT_CH_

    class TAO_IFR_Client_Export CORBA_ValueDef_out
    {
    public:
      CORBA_ValueDef_out (CORBA_ValueDef_ptr &);
      CORBA_ValueDef_out (CORBA_ValueDef_var &);
      CORBA_ValueDef_out (const CORBA_ValueDef_out &);
      CORBA_ValueDef_out &operator= (const CORBA_ValueDef_out &);
      CORBA_ValueDef_out &operator= (const CORBA_ValueDef_var &);
      CORBA_ValueDef_out &operator= (CORBA_ValueDef_ptr);
      operator CORBA_ValueDef_ptr &();
      CORBA_ValueDef_ptr &ptr (void);
      CORBA_ValueDef_ptr operator-> (void);

    private:
      CORBA_ValueDef_ptr &ptr_;
    };


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEDEF_CH_)
#define _CORBA_VALUEDEF_CH_

    // Forward Classes Declaration
    class _TAO_CORBA_ValueDef_Proxy_Impl;
    class _TAO_CORBA_ValueDef_Remote_Proxy_Impl;
    class _TAO_CORBA_ValueDef_Proxy_Broker;
    class _TAO_CORBA_ValueDef_Remote_Proxy_Broker;

    class TAO_IFR_Client_Export CORBA_ValueDef
      : public virtual CORBA_Container,
        public virtual CORBA_Contained,
        public virtual CORBA_IDLType
    {
    public:
    #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
      typedef CORBA_ValueDef_ptr _ptr_type;
      typedef CORBA_ValueDef_var _var_type;
    #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

      // the static operations
      static CORBA_ValueDef_ptr _duplicate (CORBA_ValueDef_ptr obj);

      static CORBA_ValueDef_ptr _narrow (
          CORBA::Object_ptr obj
          TAO_ENV_ARG_DECL_WITH_DEFAULTS);


      static CORBA_ValueDef_ptr _unchecked_narrow (
          CORBA::Object_ptr obj
          TAO_ENV_ARG_DECL_WITH_DEFAULTS);


      static CORBA_ValueDef_ptr _nil (void)
        {
          return (CORBA_ValueDef_ptr)0;
        }

      static void _tao_any_destructor (void*);

      virtual CORBA_InterfaceDefSeq * supported_interfaces (
          TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual void supported_interfaces (
          const CORBA_InterfaceDefSeq & supported_interfaces
          TAO_ENV_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_InitializerSeq * initializers (
          TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual void initializers (
          const CORBA_InitializerSeq & initializers
          TAO_ENV_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_ValueDef_ptr base_value (
          TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual void base_value (
          CORBA_ValueDef_ptr base_value
          TAO_ENV_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_ValueDefSeq * abstract_base_values (
          TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual void abstract_base_values (
          const CORBA_ValueDefSeq & abstract_base_values
          TAO_ENV_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA::Boolean is_abstract (
          TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual void is_abstract (
          CORBA::Boolean is_abstract
          TAO_ENV_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA::Boolean is_custom (
          TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual void is_custom (
          CORBA::Boolean is_custom
          TAO_ENV_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA::Boolean is_truncatable (
          TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual void is_truncatable (
          CORBA::Boolean is_truncatable
          TAO_ENV_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA::Boolean is_a (
          const char * id
          TAO_ENV_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      struct FullValueDescription;
      class FullValueDescription_var;

      struct TAO_IFR_Client_Export FullValueDescription
      {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
        typedef FullValueDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

        static void _tao_any_destructor (void*);

        TAO_String_Manager name;
        TAO_String_Manager id;
        CORBA::Boolean is_abstract;
        CORBA::Boolean is_custom;
        TAO_String_Manager defined_in;
        TAO_String_Manager version;
        CORBA_OpDescriptionSeq operations;
        CORBA_AttrDescriptionSeq attributes;
        CORBA_ValueMemberSeq members;
        CORBA_InitializerSeq initializers;
        CORBA_RepositoryIdSeq supported_interfaces;
        CORBA_RepositoryIdSeq abstract_base_values;
        CORBA::Boolean is_truncatable;
        TAO_String_Manager base_value;
        CORBA::TypeCode_var type;

      };

      class TAO_IFR_Client_Export FullValueDescription_var
      {
      public:
        FullValueDescription_var (void);
        FullValueDescription_var (FullValueDescription *);
        FullValueDescription_var (const FullValueDescription_var &);
        ~FullValueDescription_var (void);

        FullValueDescription_var &operator= (FullValueDescription *);
        FullValueDescription_var &operator= (const FullValueDescription_var &);
        FullValueDescription *operator-> (void);
        const FullValueDescription *operator-> (void) const;

        operator const FullValueDescription &() const;
        operator FullValueDescription &();
        operator FullValueDescription &() const;
        // Variable-size types only.
        operator FullValueDescription *&();

        // in, inout, out, _retn
        const FullValueDescription &in (void) const;
        FullValueDescription &inout (void);
        FullValueDescription *&out (void);
        FullValueDescription *_retn (void);
        FullValueDescription *ptr (void) const;

      private:
        FullValueDescription *ptr_;
      };

      class TAO_IFR_Client_Export FullValueDescription_out
      {
      public:
        FullValueDescription_out (FullValueDescription *&);
        FullValueDescription_out (FullValueDescription_var &);
        FullValueDescription_out (const FullValueDescription_out &);
        FullValueDescription_out &operator= (const FullValueDescription_out &);
        FullValueDescription_out &operator= (FullValueDescription *);
        operator FullValueDescription *&();
        FullValueDescription *&ptr (void);
        FullValueDescription *operator-> (void);

      private:
        FullValueDescription *&ptr_;
        // Assignment from T_var not allowed.
        void operator= (const FullValueDescription_var &);
      };

      static CORBA::TypeCode_ptr _tc_FullValueDescription;

      virtual CORBA_ValueDef::FullValueDescription * describe_value (
          TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_ValueMemberDef_ptr create_value_member (
          const char * id,
          const char * name,
          const char * version,
          CORBA_IDLType_ptr type,
          CORBA::Visibility access
          TAO_ENV_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_AttributeDef_ptr create_attribute (
          const char * id,
          const char * name,
          const char * version,
          CORBA_IDLType_ptr type,
          CORBA::AttributeMode mode
          TAO_ENV_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_OperationDef_ptr create_operation (
          const char * id,
          const char * name,
          const char * version,
          CORBA_IDLType_ptr result,
          CORBA::OperationMode mode,
          const CORBA_ParDescriptionSeq & params,
          const CORBA_ExceptionDefSeq & exceptions,
          const CORBA_ContextIdSeq & contexts
          TAO_ENV_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA::Boolean _is_a (
          const CORBA::Char *type_id
          TAO_ENV_ARG_DECL_WITH_DEFAULTS);


      virtual void *_tao_QueryInterface (ptr_arith_t type);

      virtual const char* _interface_repository_id (void) const;

    private:
      _TAO_CORBA_ValueDef_Proxy_Broker *the_TAO_CORBA_ValueDef_Proxy_Broker_;

    protected:
      CORBA_ValueDef (int collocated = 0);

      // This methods travese the inheritance tree and set the
      // parents piece of the given class in the right mode
      virtual void CORBA_ValueDef_setup_collocation (int collocated);

      CORBA_ValueDef (
          TAO_Stub *objref,
          CORBA::Boolean _tao_collocated = 0,
          TAO_Abstract_ServantBase *servant = 0
        );

      friend class _TAO_CORBA_ValueDef_Remote_Proxy_Impl;
      friend class _TAO_CORBA_ValueDef_ThruPOA_Proxy_Impl;
      friend class _TAO_CORBA_ValueDef_Direct_Proxy_Impl;

      virtual ~CORBA_ValueDef (void);

    private:
      CORBA_ValueDef (const CORBA_ValueDef &);
      void operator= (const CORBA_ValueDef &);
    };

    // The Proxy Implementations are used by each interface to
    // perform a call. Each different implementation encapsulate
    // an invocation logics.


    ///////////////////////////////////////////////////////////////////////
    //                    Base Proxy Impl. Declaration
    //

    class TAO_IFR_Client_Export _TAO_CORBA_ValueDef_Proxy_Impl
      : public virtual _TAO_CORBA_Container_Proxy_Impl,
        public virtual _TAO_CORBA_Contained_Proxy_Impl,
        public virtual _TAO_CORBA_IDLType_Proxy_Impl
    {
    public:
      virtual ~_TAO_CORBA_ValueDef_Proxy_Impl (void) { }
      virtual CORBA_InterfaceDefSeq * supported_interfaces (
          CORBA_Object *_collocated_tao_target_
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual void supported_interfaces (
          CORBA_Object *_collocated_tao_target_,
          const CORBA_InterfaceDefSeq & supported_interfaces
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual CORBA_InitializerSeq * initializers (
          CORBA_Object *_collocated_tao_target_
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual void initializers (
          CORBA_Object *_collocated_tao_target_,
          const CORBA_InitializerSeq & initializers
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual CORBA_ValueDef_ptr base_value (
          CORBA_Object *_collocated_tao_target_
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual void base_value (
          CORBA_Object *_collocated_tao_target_,
          CORBA_ValueDef_ptr base_value
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual CORBA_ValueDefSeq * abstract_base_values (
          CORBA_Object *_collocated_tao_target_
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual void abstract_base_values (
          CORBA_Object *_collocated_tao_target_,
          const CORBA_ValueDefSeq & abstract_base_values
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual CORBA::Boolean is_abstract (
          CORBA_Object *_collocated_tao_target_
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual void is_abstract (
          CORBA_Object *_collocated_tao_target_,
          CORBA::Boolean is_abstract
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual CORBA::Boolean is_custom (
          CORBA_Object *_collocated_tao_target_
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual void is_custom (
          CORBA_Object *_collocated_tao_target_,
          CORBA::Boolean is_custom
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual CORBA::Boolean is_truncatable (
          CORBA_Object *_collocated_tao_target_
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual void is_truncatable (
          CORBA_Object *_collocated_tao_target_,
          CORBA::Boolean is_truncatable
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual CORBA::Boolean is_a (
          CORBA_Object *_collocated_tao_target_,
          const char * id
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual CORBA_ValueDef::FullValueDescription * describe_value (
          CORBA_Object *_collocated_tao_target_
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual CORBA_ValueMemberDef_ptr create_value_member (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version,
          CORBA_IDLType_ptr type,
          CORBA::Visibility access
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual CORBA_AttributeDef_ptr create_attribute (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version,
          CORBA_IDLType_ptr type,
          CORBA::AttributeMode mode
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual CORBA_OperationDef_ptr create_operation (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version,
          CORBA_IDLType_ptr result,
          CORBA::OperationMode mode,
          const CORBA_ParDescriptionSeq & params,
          const CORBA_ExceptionDefSeq & exceptions,
          const CORBA_ContextIdSeq & contexts
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;


    protected:
      _TAO_CORBA_ValueDef_Proxy_Impl (void);
    };

    //
    //               End Base Proxy Impl. Declaration
    ///////////////////////////////////////////////////////////////////////


    ///////////////////////////////////////////////////////////////////////
    //                Remote Proxy Impl. Declaration
    //

    class TAO_IFR_Client_Export _TAO_CORBA_ValueDef_Remote_Proxy_Impl
      : public virtual _TAO_CORBA_ValueDef_Proxy_Impl,
        public virtual TAO_Remote_Object_Proxy_Impl,
        public virtual _TAO_CORBA_Container_Remote_Proxy_Impl,
        public virtual _TAO_CORBA_Contained_Remote_Proxy_Impl,
        public virtual _TAO_CORBA_IDLType_Remote_Proxy_Impl
    {
    public:
      _TAO_CORBA_ValueDef_Remote_Proxy_Impl (void);

      virtual ~_TAO_CORBA_ValueDef_Remote_Proxy_Impl (void) { }
      virtual CORBA_InterfaceDefSeq * supported_interfaces (
          CORBA_Object *_collocated_tao_target_
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual void supported_interfaces (
          CORBA_Object *_collocated_tao_target_,
          const CORBA_InterfaceDefSeq & supported_interfaces
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_InitializerSeq * initializers (
          CORBA_Object *_collocated_tao_target_
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual void initializers (
          CORBA_Object *_collocated_tao_target_,
          const CORBA_InitializerSeq & initializers
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_ValueDef_ptr base_value (
          CORBA_Object *_collocated_tao_target_
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual void base_value (
          CORBA_Object *_collocated_tao_target_,
          CORBA_ValueDef_ptr base_value
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_ValueDefSeq * abstract_base_values (
          CORBA_Object *_collocated_tao_target_
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual void abstract_base_values (
          CORBA_Object *_collocated_tao_target_,
          const CORBA_ValueDefSeq & abstract_base_values
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA::Boolean is_abstract (
          CORBA_Object *_collocated_tao_target_
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual void is_abstract (
          CORBA_Object *_collocated_tao_target_,
          CORBA::Boolean is_abstract
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA::Boolean is_custom (
          CORBA_Object *_collocated_tao_target_
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual void is_custom (
          CORBA_Object *_collocated_tao_target_,
          CORBA::Boolean is_custom
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA::Boolean is_truncatable (
          CORBA_Object *_collocated_tao_target_
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual void is_truncatable (
          CORBA_Object *_collocated_tao_target_,
          CORBA::Boolean is_truncatable
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA::Boolean is_a (
          CORBA_Object *_collocated_tao_target_,
          const char * id
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_ValueDef::FullValueDescription * describe_value (
          CORBA_Object *_collocated_tao_target_
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_ValueMemberDef_ptr create_value_member (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version,
          CORBA_IDLType_ptr type,
          CORBA::Visibility access
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_AttributeDef_ptr create_attribute (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version,
          CORBA_IDLType_ptr type,
          CORBA::AttributeMode mode
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_OperationDef_ptr create_operation (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version,
          CORBA_IDLType_ptr result,
          CORBA::OperationMode mode,
          const CORBA_ParDescriptionSeq & params,
          const CORBA_ExceptionDefSeq & exceptions,
          const CORBA_ContextIdSeq & contexts
          TAO_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));


    };

    //
    //             End Remote Proxy Impl. Declaration
    ///////////////////////////////////////////////////////////////////////

    // The Proxy Brokers are used by each interface to get
    // the right proxy for performing a call. In the new
    // collocation scheme, the proxy to be used can vary on
    // a call by call basis.


    ///////////////////////////////////////////////////////////////////////
    //                 Base Proxy Broker Declaration
    //

        class TAO_IFR_Client_Export _TAO_CORBA_ValueDef_Proxy_Broker
    {
    public:
      virtual ~_TAO_CORBA_ValueDef_Proxy_Broker (void);
      virtual _TAO_CORBA_ValueDef_Proxy_Impl &select_proxy (
          CORBA_ValueDef *object
          TAO_ENV_ARG_DECL_WITH_DEFAULTS
        ) = 0;

    protected:
      _TAO_CORBA_ValueDef_Proxy_Broker (void);

    };

    //
    //              End Base Proxy Broker Declaration
    ///////////////////////////////////////////////////////////////////////


    ///////////////////////////////////////////////////////////////////////
    //                 Remote Proxy Broker Declaration
    //

    class TAO_IFR_Client_Export _TAO_CORBA_ValueDef_Remote_Proxy_Broker
      : public virtual _TAO_CORBA_ValueDef_Proxy_Broker
    {
    public:
      _TAO_CORBA_ValueDef_Remote_Proxy_Broker (void);

      virtual ~_TAO_CORBA_ValueDef_Remote_Proxy_Broker (void);

      virtual _TAO_CORBA_ValueDef_Proxy_Impl &select_proxy (
          CORBA_ValueDef *object
          TAO_ENV_ARG_DECL
        );

      private:
        _TAO_CORBA_ValueDef_Remote_Proxy_Impl remote_proxy_impl_;

      public:
        // This member function is used to get an handle to the unique instance
        // of the Remote Proxy Broker that is available for a given
        // interface.
        static _TAO_CORBA_ValueDef_Remote_Proxy_Broker *the_TAO_CORBA_ValueDef_Remote_Proxy_Broker (void);
      };

      //
      //              End Remote Proxy Broker Declaration
      ///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */

      struct CORBA_ValueDescription;
      class CORBA_ValueDescription_var;

      struct TAO_IFR_Client_Export CORBA_ValueDescription
      {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
        typedef CORBA_ValueDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

        static void _tao_any_destructor (void*);

        TAO_String_Manager name;
        TAO_String_Manager id;
        CORBA::Boolean is_abstract;
        CORBA::Boolean is_custom;
        TAO_String_Manager defined_in;
        TAO_String_Manager version;
        CORBA_RepositoryIdSeq supported_interfaces;
        CORBA_RepositoryIdSeq abstract_base_values;
        CORBA::Boolean is_truncatable;
        TAO_String_Manager base_value;

      };

      class TAO_IFR_Client_Export CORBA_ValueDescription_var
      {
      public:
        CORBA_ValueDescription_var (void);
        CORBA_ValueDescription_var (CORBA_ValueDescription *);
        CORBA_ValueDescription_var (const CORBA_ValueDescription_var &);
        ~CORBA_ValueDescription_var (void);

        CORBA_ValueDescription_var &operator= (CORBA_ValueDescription *);
        CORBA_ValueDescription_var &operator= (const CORBA_ValueDescription_var &);
        CORBA_ValueDescription *operator-> (void);
        const CORBA_ValueDescription *operator-> (void) const;

        operator const CORBA_ValueDescription &() const;
        operator CORBA_ValueDescription &();
        operator CORBA_ValueDescription &() const;
        // Variable-size types only.
        operator CORBA_ValueDescription *&();

        // in, inout, out, _retn
        const CORBA_ValueDescription &in (void) const;
        CORBA_ValueDescription &inout (void);
        CORBA_ValueDescription *&out (void);
        CORBA_ValueDescription *_retn (void);
        CORBA_ValueDescription *ptr (void) const;

      private:
        CORBA_ValueDescription *ptr_;
      };

      class TAO_IFR_Client_Export CORBA_ValueDescription_out
      {
      public:
        CORBA_ValueDescription_out (CORBA_ValueDescription *&);
        CORBA_ValueDescription_out (CORBA_ValueDescription_var &);
        CORBA_ValueDescription_out (const CORBA_ValueDescription_out &);
        CORBA_ValueDescription_out &operator= (const CORBA_ValueDescription_out &);
        CORBA_ValueDescription_out &operator= (CORBA_ValueDescription *);
        operator CORBA_ValueDescription *&();
        CORBA_ValueDescription *&ptr (void);
        CORBA_ValueDescription *operator-> (void);

      private:
        CORBA_ValueDescription *&ptr_;
        // Assignment from T_var not allowed.
        void operator= (const CORBA_ValueDescription_var &);
      };


#if !defined (_CORBA_VALUEBOXDEF___PTR_CH_)
#define _CORBA_VALUEBOXDEF___PTR_CH_

      class CORBA_ValueBoxDef;
      typedef CORBA_ValueBoxDef *CORBA_ValueBoxDef_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_VALUEBOXDEF___VAR_CH_)
#define _CORBA_VALUEBOXDEF___VAR_CH_

      class TAO_IFR_Client_Export CORBA_ValueBoxDef_var : public TAO_Base_var
      {
      public:
        CORBA_ValueBoxDef_var (void); // default constructor
        CORBA_ValueBoxDef_var (CORBA_ValueBoxDef_ptr p) : ptr_ (p) {}
        CORBA_ValueBoxDef_var (const CORBA_ValueBoxDef_var &); // copy constructor
        ~CORBA_ValueBoxDef_var (void); // destructor

        CORBA_ValueBoxDef_var &operator= (CORBA_ValueBoxDef_ptr);
        CORBA_ValueBoxDef_var &operator= (const CORBA_ValueBoxDef_var &);
        CORBA_ValueBoxDef_ptr operator-> (void) const;

        operator const CORBA_ValueBoxDef_ptr &() const;
        operator CORBA_ValueBoxDef_ptr &();
        // in, inout, out, _retn
        CORBA_ValueBoxDef_ptr in (void) const;
        CORBA_ValueBoxDef_ptr &inout (void);
        CORBA_ValueBoxDef_ptr &out (void);
        CORBA_ValueBoxDef_ptr _retn (void);
        CORBA_ValueBoxDef_ptr ptr (void) const;

        // Hooks used by template sequence and object manager classes
        // for non-defined forward declared interfaces.
        static CORBA_ValueBoxDef_ptr tao_duplicate (CORBA_ValueBoxDef_ptr);
        static void tao_release (CORBA_ValueBoxDef_ptr);
        static CORBA_ValueBoxDef_ptr tao_nil (void);
        static CORBA_ValueBoxDef_ptr tao_narrow (
            CORBA::Object *
            TAO_ENV_ARG_DECL_NOT_USED
          );
        static CORBA::Object * tao_upcast (void *);

      private:
        CORBA_ValueBoxDef_ptr ptr_;
        // Unimplemented - prevents widening assignment.
        CORBA_ValueBoxDef_var (const TAO_Base_var &rhs);
        CORBA_ValueBoxDef_var &operator= (const TAO_Base_var &rhs);
      };


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEBOXDEF___OUT_CH_)
#define _CORBA_VALUEBOXDEF___OUT_CH_

      class TAO_IFR_Client_Export CORBA_ValueBoxDef_out
      {
      public:
        CORBA_ValueBoxDef_out (CORBA_ValueBoxDef_ptr &);
        CORBA_ValueBoxDef_out (CORBA_ValueBoxDef_var &);
        CORBA_ValueBoxDef_out (const CORBA_ValueBoxDef_out &);
        CORBA_ValueBoxDef_out &operator= (const CORBA_ValueBoxDef_out &);
        CORBA_ValueBoxDef_out &operator= (const CORBA_ValueBoxDef_var &);
        CORBA_ValueBoxDef_out &operator= (CORBA_ValueBoxDef_ptr);
        operator CORBA_ValueBoxDef_ptr &();
        CORBA_ValueBoxDef_ptr &ptr (void);
        CORBA_ValueBoxDef_ptr operator-> (void);

      private:
        CORBA_ValueBoxDef_ptr &ptr_;
      };


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEBOXDEF_CH_)
#define _CORBA_VALUEBOXDEF_CH_

      // Forward Classes Declaration
      class _TAO_CORBA_ValueBoxDef_Proxy_Impl;
      class _TAO_CORBA_ValueBoxDef_Remote_Proxy_Impl;
      class _TAO_CORBA_ValueBoxDef_Proxy_Broker;
      class _TAO_CORBA_ValueBoxDef_Remote_Proxy_Broker;

      class TAO_IFR_Client_Export CORBA_ValueBoxDef
        : public virtual CORBA_TypedefDef
      {
      public:
      #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
        typedef CORBA_ValueBoxDef_ptr _ptr_type;
        typedef CORBA_ValueBoxDef_var _var_type;
      #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

        // the static operations
        static CORBA_ValueBoxDef_ptr _duplicate (CORBA_ValueBoxDef_ptr obj);

        static CORBA_ValueBoxDef_ptr _narrow (
            CORBA::Object_ptr obj
            TAO_ENV_ARG_DECL_WITH_DEFAULTS);


        static CORBA_ValueBoxDef_ptr _unchecked_narrow (
            CORBA::Object_ptr obj
            TAO_ENV_ARG_DECL_WITH_DEFAULTS);


        static CORBA_ValueBoxDef_ptr _nil (void)
          {
            return (CORBA_ValueBoxDef_ptr)0;
          }

        static void _tao_any_destructor (void*);

        virtual CORBA_IDLType_ptr original_type_def (
            TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));

        virtual void original_type_def (
            CORBA_IDLType_ptr original_type_def
            TAO_ENV_ARG_DECL_WITH_DEFAULTS)

          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));

        virtual CORBA::Boolean _is_a (
            const CORBA::Char *type_id
            TAO_ENV_ARG_DECL_WITH_DEFAULTS);


        virtual void *_tao_QueryInterface (ptr_arith_t type);

        virtual const char* _interface_repository_id (void) const;

      private:
        _TAO_CORBA_ValueBoxDef_Proxy_Broker *the_TAO_CORBA_ValueBoxDef_Proxy_Broker_;

      protected:
        CORBA_ValueBoxDef (int collocated = 0);

        // This methods travese the inheritance tree and set the
        // parents piece of the given class in the right mode
        virtual void CORBA_ValueBoxDef_setup_collocation (int collocated);

        CORBA_ValueBoxDef (
            TAO_Stub *objref,
            CORBA::Boolean _tao_collocated = 0,
            TAO_Abstract_ServantBase *servant = 0
          );

        friend class _TAO_CORBA_ValueBoxDef_Remote_Proxy_Impl;
        friend class _TAO_CORBA_ValueBoxDef_ThruPOA_Proxy_Impl;
        friend class _TAO_CORBA_ValueBoxDef_Direct_Proxy_Impl;

        virtual ~CORBA_ValueBoxDef (void);

      private:
        CORBA_ValueBoxDef (const CORBA_ValueBoxDef &);
        void operator= (const CORBA_ValueBoxDef &);
      };

      // The Proxy Implementations are used by each interface to
      // perform a call. Each different implementation encapsulate
      // an invocation logics.


      ///////////////////////////////////////////////////////////////////////
      //                    Base Proxy Impl. Declaration
      //

      class TAO_IFR_Client_Export _TAO_CORBA_ValueBoxDef_Proxy_Impl
        : public virtual _TAO_CORBA_TypedefDef_Proxy_Impl
      {
      public:
        virtual ~_TAO_CORBA_ValueBoxDef_Proxy_Impl (void) { }
        virtual CORBA_IDLType_ptr original_type_def (
            CORBA_Object *_collocated_tao_target_
            TAO_ENV_ARG_DECL
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          )) = 0;

        virtual void original_type_def (
            CORBA_Object *_collocated_tao_target_,
            CORBA_IDLType_ptr original_type_def
            TAO_ENV_ARG_DECL
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          )) = 0;


      protected:
        _TAO_CORBA_ValueBoxDef_Proxy_Impl (void);
      };

      //
      //               End Base Proxy Impl. Declaration
      ///////////////////////////////////////////////////////////////////////


      ///////////////////////////////////////////////////////////////////////
      //                Remote Proxy Impl. Declaration
      //

      class TAO_IFR_Client_Export _TAO_CORBA_ValueBoxDef_Remote_Proxy_Impl
        : public virtual _TAO_CORBA_ValueBoxDef_Proxy_Impl,
          public virtual TAO_Remote_Object_Proxy_Impl,
          public virtual _TAO_CORBA_TypedefDef_Remote_Proxy_Impl
      {
      public:
        _TAO_CORBA_ValueBoxDef_Remote_Proxy_Impl (void);

        virtual ~_TAO_CORBA_ValueBoxDef_Remote_Proxy_Impl (void) { }
        virtual CORBA_IDLType_ptr original_type_def (
            CORBA_Object *_collocated_tao_target_
            TAO_ENV_ARG_DECL
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));

        virtual void original_type_def (
            CORBA_Object *_collocated_tao_target_,
            CORBA_IDLType_ptr original_type_def
            TAO_ENV_ARG_DECL
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));


      };

      //
      //             End Remote Proxy Impl. Declaration
      ///////////////////////////////////////////////////////////////////////

      // The Proxy Brokers are used by each interface to get
      // the right proxy for performing a call. In the new
      // collocation scheme, the proxy to be used can vary on
      // a call by call basis.


      ///////////////////////////////////////////////////////////////////////
      //                 Base Proxy Broker Declaration
      //

            class TAO_IFR_Client_Export _TAO_CORBA_ValueBoxDef_Proxy_Broker
      {
      public:
        virtual ~_TAO_CORBA_ValueBoxDef_Proxy_Broker (void);
        virtual _TAO_CORBA_ValueBoxDef_Proxy_Impl &select_proxy (
            CORBA_ValueBoxDef *object
            TAO_ENV_ARG_DECL_WITH_DEFAULTS
          ) = 0;

      protected:
        _TAO_CORBA_ValueBoxDef_Proxy_Broker (void);

      };

      //
      //              End Base Proxy Broker Declaration
      ///////////////////////////////////////////////////////////////////////


      ///////////////////////////////////////////////////////////////////////
      //                 Remote Proxy Broker Declaration
      //

      class TAO_IFR_Client_Export _TAO_CORBA_ValueBoxDef_Remote_Proxy_Broker
        : public virtual _TAO_CORBA_ValueBoxDef_Proxy_Broker
      {
      public:
        _TAO_CORBA_ValueBoxDef_Remote_Proxy_Broker (void);

        virtual ~_TAO_CORBA_ValueBoxDef_Remote_Proxy_Broker (void);

        virtual _TAO_CORBA_ValueBoxDef_Proxy_Impl &select_proxy (
            CORBA_ValueBoxDef *object
            TAO_ENV_ARG_DECL
          );

        private:
          _TAO_CORBA_ValueBoxDef_Remote_Proxy_Impl remote_proxy_impl_;

        public:
          // This member function is used to get an handle to the unique instance
          // of the Remote Proxy Broker that is available for a given
          // interface.
          static _TAO_CORBA_ValueBoxDef_Remote_Proxy_Broker *the_TAO_CORBA_ValueBoxDef_Remote_Proxy_Broker (void);
        };

        //
        //              End Remote Proxy Broker Declaration
        ///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */

        // Proxy Broker Factory function pointer declarations.

        extern TAO_IFR_Client_Export
        _TAO_CORBA_FixedDef_Proxy_Broker *
        (*_TAO_CORBA_FixedDef_Proxy_Broker_Factory_function_pointer) (
            CORBA::Object_ptr obj
          );

        extern TAO_IFR_Client_Export
        _TAO_CORBA_ValueMemberDef_Proxy_Broker *
        (*_TAO_CORBA_ValueMemberDef_Proxy_Broker_Factory_function_pointer) (
            CORBA::Object_ptr obj
          );

        extern TAO_IFR_Client_Export
        _TAO_CORBA_ValueDef_Proxy_Broker *
        (*_TAO_CORBA_ValueDef_Proxy_Broker_Factory_function_pointer) (
            CORBA::Object_ptr obj
          );

        extern TAO_IFR_Client_Export
        _TAO_CORBA_ValueBoxDef_Proxy_Broker *
        (*_TAO_CORBA_ValueBoxDef_Proxy_Broker_Factory_function_pointer) (
            CORBA::Object_ptr obj
          );

                        // Any operators for interface CORBA_FixedDef
        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_FixedDef_ptr);
        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_FixedDef *&);
        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA_ValueMember &); // copying version
        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_ValueMember*); // noncopying version
        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_ValueMember *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA_ValueMember *&);
                TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA_ValueMemberSeq &); // copying version
        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_ValueMemberSeq*); // noncopying version
        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_ValueMemberSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA_ValueMemberSeq *&);
        // Any operators for interface CORBA_ValueMemberDef
        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_ValueMemberDef_ptr);
        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_ValueMemberDef *&);
        // Any operators for interface CORBA_ValueDef
        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_ValueDef_ptr);
        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_ValueDef *&);
        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA_ValueDef::FullValueDescription &); // copying version
        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_ValueDef::FullValueDescription*); // noncopying version
        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_ValueDef::FullValueDescription *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA_ValueDef::FullValueDescription *&);
        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA_ValueDescription &); // copying version
        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_ValueDescription*); // noncopying version
        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_ValueDescription *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA_ValueDescription *&);
        // Any operators for interface CORBA_ValueBoxDef
        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_ValueBoxDef_ptr);
        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_ValueBoxDef *&);

        #ifndef __ACE_INLINE__

                TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_FixedDef_ptr );
        TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_FixedDef_ptr &);
        TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_ValueMember &);
        TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_ValueMember &);

#if !defined _TAO_CDR_OP_CORBA_ValueMemberSeq_H_
        #define _TAO_CDR_OP_CORBA_ValueMemberSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
            TAO_OutputCDR &,
            const CORBA_ValueMemberSeq &
          );
        TAO_IFR_Client_Export CORBA::Boolean operator>> (
            TAO_InputCDR &,
            CORBA_ValueMemberSeq &
          );

#endif /* _TAO_CDR_OP_CORBA_ValueMemberSeq_H_ */

        TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_ValueMemberDef_ptr );
        TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_ValueMemberDef_ptr &);
        TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_ValueDef_ptr );
        TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_ValueDef_ptr &);
        TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_ValueDef::FullValueDescription &);
        TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_ValueDef::FullValueDescription &);
        TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_ValueDescription &);
        TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_ValueDescription &);
        TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_ValueBoxDef_ptr );
        TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_ValueBoxDef_ptr &);

        #endif /* __ACE_INLINE__ */


#if defined (__ACE_INLINE__)
#include "IFR_ExtendedC.i"
#endif /* defined INLINE */

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(pop)
#endif /* _MSC_VER */

#if defined (__BORLANDC__)
#pragma option pop
#endif /* __BORLANDC__ */

#include "ace/post.h"
#endif /* ifndef */
