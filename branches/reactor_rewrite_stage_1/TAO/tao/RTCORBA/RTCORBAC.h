// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#ifndef _TAO_IDL_ORIG_RTCORBAC_H_
#define _TAO_IDL_ORIG_RTCORBAC_H_

#include "ace/pre.h"
#include "tao/orbconf.h"

#if !defined (ACE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */

#include "rtcorba_export.h"
#include "tao/IOPC.h"
#include "tao/TimeBaseC.h"
#include "tao/PolicyC.h"
#include "tao/Encodable.h"

// Forward references.
class TAO_Priority_Mapping_Manager;
class TAO_Priority_Mapping_Manager_var;
class TAO_Priority_Mapping_Manager_out;
class TAO_Priority_Mapping;

#ifndef TAO_RTCORBA_SAFE_INCLUDE
#error "You should not include RTCORBAC.h directly, use RTCORBA.h"
#endif /* !TAO_RTCORBA_SAFE_INCLUDE */


#if defined (TAO_EXPORT_MACRO)
#undef TAO_EXPORT_MACRO
#endif
#define TAO_EXPORT_MACRO TAO_RTCORBA_Export

#if defined (TAO_EXPORT_NESTED_CLASSES)
#  if defined (TAO_EXPORT_NESTED_MACRO)
#    undef TAO_EXPORT_NESTED_MACRO
#  endif /* defined (TAO_EXPORT_NESTED_MACRO) */
#  define TAO_EXPORT_NESTED_MACRO TAO_RTCORBA_Export
#endif /* TAO_EXPORT_NESTED_CLASSES */

#if defined(_MSC_VER)
#if (_MSC_VER >= 1200)
#pragma warning(push)
#endif /* _MSC_VER >= 1200 */
#pragma warning(disable:4250)
#endif /* _MSC_VER */

#if defined (__BORLANDC__)
#pragma option push -w-rvl -w-rch -w-ccc -w-inl
#endif /* __BORLANDC__ */

TAO_NAMESPACE  RTCORBA
{
  // TAO-specific
  typedef TAO_Priority_Mapping_Manager PriorityMappingManager;
  typedef TAO_Priority_Mapping_Manager *PriorityMappingManager_ptr;
  typedef TAO_Priority_Mapping_Manager_var PriorityMappingManager_var;
  typedef TAO_Priority_Mapping_Manager_out PriorityMappingManager_out;
  // End TAO-specific

  typedef CORBA::Short NativePriority;
  typedef CORBA::Short_out NativePriority_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_NativePriority;

  typedef CORBA::Short Priority;
  typedef CORBA::Short_out Priority_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Priority;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short minPriority;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short maxPriority;

  typedef TAO_Priority_Mapping PriorityMapping;
  typedef CORBA::ULong ThreadpoolId;
  typedef CORBA::ULong_out ThreadpoolId_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ThreadpoolId;

  struct ThreadpoolLane;
  class ThreadpoolLane_var;

  struct TAO_RTCORBA_Export ThreadpoolLane
  {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef ThreadpoolLane_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

    static void _tao_any_destructor (void*);

    ACE_NESTED_CLASS (RTCORBA, Priority) lane_priority;
    CORBA::ULong static_threads;
    CORBA::ULong dynamic_threads;

  };

  class TAO_RTCORBA_Export ThreadpoolLane_var
  {
  public:
    ThreadpoolLane_var (void);
    ThreadpoolLane_var (ThreadpoolLane *);
    ThreadpoolLane_var (const ThreadpoolLane_var &);
    // Fixed-size types only.
    ThreadpoolLane_var (const ThreadpoolLane &);
    ~ThreadpoolLane_var (void);

    ThreadpoolLane_var &operator= (ThreadpoolLane *);
    ThreadpoolLane_var &operator= (const ThreadpoolLane_var &);
    // Fixed-size types only.
    ThreadpoolLane_var &operator= (const ThreadpoolLane &);
    ThreadpoolLane *operator-> (void);
    const ThreadpoolLane *operator-> (void) const;

    operator const ThreadpoolLane &() const;
    operator ThreadpoolLane &();
    operator ThreadpoolLane &() const;

    // in, inout, out, _retn
    const ThreadpoolLane &in (void) const;
    ThreadpoolLane &inout (void);
    ThreadpoolLane &out (void);
    ThreadpoolLane _retn (void);
    ThreadpoolLane *ptr (void) const;

  private:
    ThreadpoolLane *ptr_;
  };

  typedef ThreadpoolLane &ThreadpoolLane_out;

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ThreadpoolLane;


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_RTCORBA_THREADPOOLLANES_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_RTCORBA_THREADPOOLLANES_CH_

  class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_RTCORBA_ThreadpoolLanes
    : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.
    _TAO_Unbounded_Sequence_RTCORBA_ThreadpoolLanes (void);
      _TAO_Unbounded_Sequence_RTCORBA_ThreadpoolLanes (CORBA::ULong maximum);
    _TAO_Unbounded_Sequence_RTCORBA_ThreadpoolLanes (
        CORBA::ULong maximum,
        CORBA::ULong length,
        ThreadpoolLane *data,
        CORBA::Boolean release = 0
      );
    _TAO_Unbounded_Sequence_RTCORBA_ThreadpoolLanes (
        const _TAO_Unbounded_Sequence_RTCORBA_ThreadpoolLanes &rhs
      );
    _TAO_Unbounded_Sequence_RTCORBA_ThreadpoolLanes &operator= (
        const _TAO_Unbounded_Sequence_RTCORBA_ThreadpoolLanes &rhs
      );
    virtual ~_TAO_Unbounded_Sequence_RTCORBA_ThreadpoolLanes (void);

      // = Accessors.
      ThreadpoolLane &operator[] (CORBA::ULong i);
      const ThreadpoolLane &operator[] (CORBA::ULong i) const;

      // = Static operations.
      static ThreadpoolLane *allocbuf (CORBA::ULong size);
      static void freebuf (ThreadpoolLane *buffer);

    // Implement the TAO_Base_Sequence methods (see Sequence.h)
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      ThreadpoolLane *get_buffer (CORBA::Boolean orphan = 0);
      const ThreadpoolLane *get_buffer (void) const;
    void replace (
        CORBA::ULong max,
        CORBA::ULong length,
        ThreadpoolLane *data,
        CORBA::Boolean release
      );
    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_RTCORBA_THREADPOOLLANES_CH_)
#define _RTCORBA_THREADPOOLLANES_CH_

  class ThreadpoolLanes;
  class ThreadpoolLanes_var;

  // *************************************************************
  // ThreadpoolLanes
  // *************************************************************

  class TAO_RTCORBA_Export ThreadpoolLanes : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Sequence_RTCORBA_ThreadpoolLanes
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Sequence<ThreadpoolLane>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    ThreadpoolLanes (void); // default ctor
    ThreadpoolLanes (CORBA::ULong max); // uses max size
    ThreadpoolLanes (
      CORBA::ULong max,
      CORBA::ULong length,
      ThreadpoolLane *buffer,
      CORBA::Boolean release = 0
    );
    ThreadpoolLanes (const ThreadpoolLanes &); // copy ctor
    ~ThreadpoolLanes (void);
    static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef ThreadpoolLanes_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */


  };

#endif /* end #if !defined */


#if !defined (_RTCORBA_THREADPOOLLANES___VAR_CH_)
#define _RTCORBA_THREADPOOLLANES___VAR_CH_

  // *************************************************************
  // class RTCORBA::ThreadpoolLanes_var
  // *************************************************************

  class TAO_RTCORBA_Export ThreadpoolLanes_var
  {
  public:
    ThreadpoolLanes_var (void);
    ThreadpoolLanes_var (ThreadpoolLanes *);
    ThreadpoolLanes_var (const ThreadpoolLanes_var &);
    // Fixed-size base types only.
    ThreadpoolLanes_var (const ThreadpoolLanes &);
    ~ThreadpoolLanes_var (void);

    ThreadpoolLanes_var &operator= (ThreadpoolLanes *);
    ThreadpoolLanes_var &operator= (const ThreadpoolLanes_var &);
    // Fixed-size base types only.
    ThreadpoolLanes_var &operator= (const ThreadpoolLanes &);
    ThreadpoolLanes *operator-> (void);
    const ThreadpoolLanes *operator-> (void) const;

    operator const ThreadpoolLanes &() const;
    operator ThreadpoolLanes &();
    operator ThreadpoolLanes &() const;

    ThreadpoolLane & operator[] (CORBA::ULong index);
    const ThreadpoolLane & operator[] (CORBA::ULong index) const;

    // in, inout, out, _retn
    const ThreadpoolLanes &in (void) const;
    ThreadpoolLanes &inout (void);
    ThreadpoolLanes *&out (void);
    ThreadpoolLanes *_retn (void);
    ThreadpoolLanes *ptr (void) const;

  private:
    ThreadpoolLanes *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_THREADPOOLLANES___OUT_CH_)
#define _RTCORBA_THREADPOOLLANES___OUT_CH_

  class TAO_RTCORBA_Export ThreadpoolLanes_out
  {
  public:
    ThreadpoolLanes_out (ThreadpoolLanes *&);
    ThreadpoolLanes_out (ThreadpoolLanes_var &);
    ThreadpoolLanes_out (const ThreadpoolLanes_out &);
    ThreadpoolLanes_out &operator= (const ThreadpoolLanes_out &);
    ThreadpoolLanes_out &operator= (ThreadpoolLanes *);
    operator ThreadpoolLanes *&();
    ThreadpoolLanes *&ptr (void);
    ThreadpoolLanes *operator-> (void);
    ThreadpoolLane & operator[] (CORBA::ULong index);

  private:
    ThreadpoolLanes *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const ThreadpoolLanes_var &);
  };


#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ThreadpoolLanes;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong PRIORITY_MODEL_POLICY_TYPE;

  enum PriorityModel
  {
        CLIENT_PROPAGATED,
        SERVER_DECLARED
  };

  typedef PriorityModel &PriorityModel_out;
  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_PriorityModel;


#if !defined (_RTCORBA_PRIORITYMODELPOLICY___PTR_CH_)
#define _RTCORBA_PRIORITYMODELPOLICY___PTR_CH_

  class PriorityModelPolicy;
  typedef PriorityModelPolicy *PriorityModelPolicy_ptr;

#endif /* end #if !defined */


#if !defined (_RTCORBA_PRIORITYMODELPOLICY___VAR_CH_)
#define _RTCORBA_PRIORITYMODELPOLICY___VAR_CH_

  class TAO_RTCORBA_Export PriorityModelPolicy_var : public TAO_Base_var
  {
  public:
    PriorityModelPolicy_var (void); // default constructor
    PriorityModelPolicy_var (PriorityModelPolicy_ptr p) : ptr_ (p) {}
    PriorityModelPolicy_var (const PriorityModelPolicy_var &); // copy constructor
    ~PriorityModelPolicy_var (void); // destructor

    PriorityModelPolicy_var &operator= (PriorityModelPolicy_ptr);
    PriorityModelPolicy_var &operator= (const PriorityModelPolicy_var &);
    PriorityModelPolicy_ptr operator-> (void) const;

    operator const PriorityModelPolicy_ptr &() const;
    operator PriorityModelPolicy_ptr &();
    // in, inout, out, _retn
    PriorityModelPolicy_ptr in (void) const;
    PriorityModelPolicy_ptr &inout (void);
    PriorityModelPolicy_ptr &out (void);
    PriorityModelPolicy_ptr _retn (void);
    PriorityModelPolicy_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static PriorityModelPolicy_ptr tao_duplicate (PriorityModelPolicy_ptr);
    static void tao_release (PriorityModelPolicy_ptr);
    static PriorityModelPolicy_ptr tao_nil (void);
    static PriorityModelPolicy_ptr tao_narrow (
        CORBA::Object *
        TAO_ENV_ARG_DECL_NOT_USED
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    PriorityModelPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    PriorityModelPolicy_var (const TAO_Base_var &rhs);
    PriorityModelPolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_PRIORITYMODELPOLICY___OUT_CH_)
#define _RTCORBA_PRIORITYMODELPOLICY___OUT_CH_

  class TAO_RTCORBA_Export PriorityModelPolicy_out
  {
  public:
    PriorityModelPolicy_out (PriorityModelPolicy_ptr &);
    PriorityModelPolicy_out (PriorityModelPolicy_var &);
    PriorityModelPolicy_out (const PriorityModelPolicy_out &);
    PriorityModelPolicy_out &operator= (const PriorityModelPolicy_out &);
    PriorityModelPolicy_out &operator= (const PriorityModelPolicy_var &);
    PriorityModelPolicy_out &operator= (PriorityModelPolicy_ptr);
    operator PriorityModelPolicy_ptr &();
    PriorityModelPolicy_ptr &ptr (void);
    PriorityModelPolicy_ptr operator-> (void);

  private:
    PriorityModelPolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_PRIORITYMODELPOLICY_CH_)
#define _RTCORBA_PRIORITYMODELPOLICY_CH_

  class TAO_RTCORBA_Export PriorityModelPolicy
    : public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef PriorityModelPolicy_ptr _ptr_type;
    typedef PriorityModelPolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

    // the static operations
    static PriorityModelPolicy_ptr _duplicate (PriorityModelPolicy_ptr obj);

    static PriorityModelPolicy_ptr _narrow (
        CORBA::Object_ptr obj
        TAO_ENV_ARG_DECL_WITH_DEFAULTS);


    static PriorityModelPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        TAO_ENV_ARG_DECL_WITH_DEFAULTS);


    static PriorityModelPolicy_ptr _nil (void)
      {
        return (PriorityModelPolicy_ptr)0;
      }

    virtual RTCORBA::PriorityModel priority_model (
        TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual RTCORBA::Priority server_priority (
        TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    PriorityModelPolicy ();

    virtual ~PriorityModelPolicy (void);

  private:
    PriorityModelPolicy (const PriorityModelPolicy &);
    void operator= (const PriorityModelPolicy &);
  };


#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong THREADPOOL_POLICY_TYPE;


#if !defined (_RTCORBA_THREADPOOLPOLICY___PTR_CH_)
#define _RTCORBA_THREADPOOLPOLICY___PTR_CH_

  class ThreadpoolPolicy;
  typedef ThreadpoolPolicy *ThreadpoolPolicy_ptr;

#endif /* end #if !defined */


#if !defined (_RTCORBA_THREADPOOLPOLICY___VAR_CH_)
#define _RTCORBA_THREADPOOLPOLICY___VAR_CH_

  class TAO_RTCORBA_Export ThreadpoolPolicy_var : public TAO_Base_var
  {
  public:
    ThreadpoolPolicy_var (void); // default constructor
    ThreadpoolPolicy_var (ThreadpoolPolicy_ptr p) : ptr_ (p) {}
    ThreadpoolPolicy_var (const ThreadpoolPolicy_var &); // copy constructor
    ~ThreadpoolPolicy_var (void); // destructor

    ThreadpoolPolicy_var &operator= (ThreadpoolPolicy_ptr);
    ThreadpoolPolicy_var &operator= (const ThreadpoolPolicy_var &);
    ThreadpoolPolicy_ptr operator-> (void) const;

    operator const ThreadpoolPolicy_ptr &() const;
    operator ThreadpoolPolicy_ptr &();
    // in, inout, out, _retn
    ThreadpoolPolicy_ptr in (void) const;
    ThreadpoolPolicy_ptr &inout (void);
    ThreadpoolPolicy_ptr &out (void);
    ThreadpoolPolicy_ptr _retn (void);
    ThreadpoolPolicy_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static ThreadpoolPolicy_ptr tao_duplicate (ThreadpoolPolicy_ptr);
    static void tao_release (ThreadpoolPolicy_ptr);
    static ThreadpoolPolicy_ptr tao_nil (void);
    static ThreadpoolPolicy_ptr tao_narrow (
        CORBA::Object *
        TAO_ENV_ARG_DECL_NOT_USED
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    ThreadpoolPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    ThreadpoolPolicy_var (const TAO_Base_var &rhs);
    ThreadpoolPolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_THREADPOOLPOLICY___OUT_CH_)
#define _RTCORBA_THREADPOOLPOLICY___OUT_CH_

  class TAO_RTCORBA_Export ThreadpoolPolicy_out
  {
  public:
    ThreadpoolPolicy_out (ThreadpoolPolicy_ptr &);
    ThreadpoolPolicy_out (ThreadpoolPolicy_var &);
    ThreadpoolPolicy_out (const ThreadpoolPolicy_out &);
    ThreadpoolPolicy_out &operator= (const ThreadpoolPolicy_out &);
    ThreadpoolPolicy_out &operator= (const ThreadpoolPolicy_var &);
    ThreadpoolPolicy_out &operator= (ThreadpoolPolicy_ptr);
    operator ThreadpoolPolicy_ptr &();
    ThreadpoolPolicy_ptr &ptr (void);
    ThreadpoolPolicy_ptr operator-> (void);

  private:
    ThreadpoolPolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_THREADPOOLPOLICY_CH_)
#define _RTCORBA_THREADPOOLPOLICY_CH_

  class TAO_RTCORBA_Export ThreadpoolPolicy
    : public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef ThreadpoolPolicy_ptr _ptr_type;
    typedef ThreadpoolPolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

    // the static operations
    static ThreadpoolPolicy_ptr _duplicate (ThreadpoolPolicy_ptr obj);

    static ThreadpoolPolicy_ptr _narrow (
        CORBA::Object_ptr obj
        TAO_ENV_ARG_DECL_WITH_DEFAULTS);


    static ThreadpoolPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        TAO_ENV_ARG_DECL_WITH_DEFAULTS);


    static ThreadpoolPolicy_ptr _nil (void)
      {
        return (ThreadpoolPolicy_ptr)0;
      }

    virtual RTCORBA::ThreadpoolId threadpool (
        TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    ThreadpoolPolicy ();

    virtual ~ThreadpoolPolicy (void);

  private:
    ThreadpoolPolicy (const ThreadpoolPolicy &);
    void operator= (const ThreadpoolPolicy &);
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_PROTOCOLPROPERTIES___PTR_CH_)
#define _RTCORBA_PROTOCOLPROPERTIES___PTR_CH_

  class ProtocolProperties;
  typedef ProtocolProperties *ProtocolProperties_ptr;

#endif /* end #if !defined */


#if !defined (_RTCORBA_PROTOCOLPROPERTIES___VAR_CH_)
#define _RTCORBA_PROTOCOLPROPERTIES___VAR_CH_

  class TAO_RTCORBA_Export ProtocolProperties_var : public TAO_Base_var
  {
  public:
    ProtocolProperties_var (void); // default constructor
    ProtocolProperties_var (ProtocolProperties_ptr p) : ptr_ (p) {}
    ProtocolProperties_var (const ProtocolProperties_var &); // copy constructor
    ~ProtocolProperties_var (void); // destructor

    ProtocolProperties_var &operator= (ProtocolProperties_ptr);
    ProtocolProperties_var &operator= (const ProtocolProperties_var &);
    ProtocolProperties_ptr operator-> (void) const;

    operator const ProtocolProperties_ptr &() const;
    operator ProtocolProperties_ptr &();
    // in, inout, out, _retn
    ProtocolProperties_ptr in (void) const;
    ProtocolProperties_ptr &inout (void);
    ProtocolProperties_ptr &out (void);
    ProtocolProperties_ptr _retn (void);
    ProtocolProperties_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static ProtocolProperties_ptr tao_duplicate (ProtocolProperties_ptr);
    static void tao_release (ProtocolProperties_ptr);
    static ProtocolProperties_ptr tao_nil (void);
    static ProtocolProperties_ptr tao_narrow (
        CORBA::Object *
        TAO_ENV_ARG_DECL_NOT_USED
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    ProtocolProperties_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    ProtocolProperties_var (const TAO_Base_var &rhs);
    ProtocolProperties_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_PROTOCOLPROPERTIES___OUT_CH_)
#define _RTCORBA_PROTOCOLPROPERTIES___OUT_CH_

  class TAO_RTCORBA_Export ProtocolProperties_out
  {
  public:
    ProtocolProperties_out (ProtocolProperties_ptr &);
    ProtocolProperties_out (ProtocolProperties_var &);
    ProtocolProperties_out (const ProtocolProperties_out &);
    ProtocolProperties_out &operator= (const ProtocolProperties_out &);
    ProtocolProperties_out &operator= (const ProtocolProperties_var &);
    ProtocolProperties_out &operator= (ProtocolProperties_ptr);
    operator ProtocolProperties_ptr &();
    ProtocolProperties_ptr &ptr (void);
    ProtocolProperties_ptr operator-> (void);

  private:
    ProtocolProperties_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_PROTOCOLPROPERTIES_CH_)
#define _RTCORBA_PROTOCOLPROPERTIES_CH_

class TAO_RTCORBA_Export ProtocolProperties
  : public virtual CORBA_Object,
    public TAO_Encodable
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef ProtocolProperties_ptr _ptr_type;
    typedef ProtocolProperties_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

    // the static operations
    static ProtocolProperties_ptr _duplicate (ProtocolProperties_ptr obj);

    static ProtocolProperties_ptr _narrow (
        CORBA::Object_ptr obj
        TAO_ENV_ARG_DECL_WITH_DEFAULTS);


    static ProtocolProperties_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        TAO_ENV_ARG_DECL_WITH_DEFAULTS);


    static ProtocolProperties_ptr _nil (void)
      {
        return (ProtocolProperties_ptr)0;
      }

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

    // CDR Encoder/Decoder methods.

    virtual CORBA::Boolean _tao_encode (TAO_OutputCDR &out_cdr);
    virtual CORBA::Boolean _tao_decode (TAO_InputCDR &in_cdr);

  protected:
    ProtocolProperties ();

    virtual ~ProtocolProperties (void);

  private:
    ProtocolProperties (const ProtocolProperties &);
    void operator= (const ProtocolProperties &);
  };


#endif /* end #if !defined */

  struct Protocol;
  class Protocol_var;

  struct TAO_RTCORBA_Export Protocol
  {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef Protocol_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

        IOP::ProfileId protocol_type;
    ACE_NESTED_CLASS (RTCORBA, ProtocolProperties_var) orb_protocol_properties;
    ACE_NESTED_CLASS (RTCORBA, ProtocolProperties_var) transport_protocol_properties;

  };

  class TAO_RTCORBA_Export Protocol_var
  {
  public:
    Protocol_var (void);
    Protocol_var (Protocol *);
    Protocol_var (const Protocol_var &);
    ~Protocol_var (void);

    Protocol_var &operator= (Protocol *);
    Protocol_var &operator= (const Protocol_var &);
    Protocol *operator-> (void);
    const Protocol *operator-> (void) const;

    operator const Protocol &() const;
    operator Protocol &();
    operator Protocol &() const;
    // Variable-size types only.
    operator Protocol *&();

    // in, inout, out, _retn
    const Protocol &in (void) const;
    Protocol &inout (void);
    Protocol *&out (void);
    Protocol *_retn (void);
    Protocol *ptr (void) const;

  private:
    Protocol *ptr_;
  };

  class TAO_RTCORBA_Export Protocol_out
  {
  public:
    Protocol_out (Protocol *&);
    Protocol_out (Protocol_var &);
    Protocol_out (const Protocol_out &);
    Protocol_out &operator= (const Protocol_out &);
    Protocol_out &operator= (Protocol *);
    operator Protocol *&();
    Protocol *&ptr (void);
    Protocol *operator-> (void);

  private:
    Protocol *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const Protocol_var &);
  };


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_RTCORBA_PROTOCOLLIST_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_RTCORBA_PROTOCOLLIST_CH_

  class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_RTCORBA_ProtocolList
    : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.
    _TAO_Unbounded_Sequence_RTCORBA_ProtocolList (void);
      _TAO_Unbounded_Sequence_RTCORBA_ProtocolList (CORBA::ULong maximum);
    _TAO_Unbounded_Sequence_RTCORBA_ProtocolList (
        CORBA::ULong maximum,
        CORBA::ULong length,
        Protocol *data,
        CORBA::Boolean release = 0
      );
    _TAO_Unbounded_Sequence_RTCORBA_ProtocolList (
        const _TAO_Unbounded_Sequence_RTCORBA_ProtocolList &rhs
      );
    _TAO_Unbounded_Sequence_RTCORBA_ProtocolList &operator= (
        const _TAO_Unbounded_Sequence_RTCORBA_ProtocolList &rhs
      );
    virtual ~_TAO_Unbounded_Sequence_RTCORBA_ProtocolList (void);

      // = Accessors.
      Protocol &operator[] (CORBA::ULong i);
      const Protocol &operator[] (CORBA::ULong i) const;

      // = Static operations.
      static Protocol *allocbuf (CORBA::ULong size);
      static void freebuf (Protocol *buffer);

    // Implement the TAO_Base_Sequence methods (see Sequence.h)
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      Protocol *get_buffer (CORBA::Boolean orphan = 0);
      const Protocol *get_buffer (void) const;
    void replace (
        CORBA::ULong max,
        CORBA::ULong length,
        Protocol *data,
        CORBA::Boolean release
      );
    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_RTCORBA_PROTOCOLLIST_CH_)
#define _RTCORBA_PROTOCOLLIST_CH_

  class ProtocolList;
  class ProtocolList_var;

  // *************************************************************
  // ProtocolList
  // *************************************************************

  class TAO_RTCORBA_Export ProtocolList : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Sequence_RTCORBA_ProtocolList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Sequence<Protocol>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    ProtocolList (void); // default ctor
    ProtocolList (CORBA::ULong max); // uses max size
    ProtocolList (
      CORBA::ULong max,
      CORBA::ULong length,
      Protocol *buffer,
      CORBA::Boolean release = 0
    );
    ProtocolList (const ProtocolList &); // copy ctor
    ~ProtocolList (void);
    static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef ProtocolList_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */


  };

#endif /* end #if !defined */


#if !defined (_RTCORBA_PROTOCOLLIST___VAR_CH_)
#define _RTCORBA_PROTOCOLLIST___VAR_CH_

  // *************************************************************
  // class RTCORBA::ProtocolList_var
  // *************************************************************

  class TAO_RTCORBA_Export ProtocolList_var
  {
  public:
    ProtocolList_var (void);
    ProtocolList_var (ProtocolList *);
    ProtocolList_var (const ProtocolList_var &);
    ~ProtocolList_var (void);

    ProtocolList_var &operator= (ProtocolList *);
    ProtocolList_var &operator= (const ProtocolList_var &);
    ProtocolList *operator-> (void);
    const ProtocolList *operator-> (void) const;

    operator const ProtocolList &() const;
    operator ProtocolList &();
    operator ProtocolList &() const;
    operator ProtocolList *&(); // variable-size base types only

    Protocol & operator[] (CORBA::ULong index);
    const Protocol & operator[] (CORBA::ULong index) const;

    // in, inout, out, _retn
    const ProtocolList &in (void) const;
    ProtocolList &inout (void);
    ProtocolList *&out (void);
    ProtocolList *_retn (void);
    ProtocolList *ptr (void) const;

  private:
    ProtocolList *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_PROTOCOLLIST___OUT_CH_)
#define _RTCORBA_PROTOCOLLIST___OUT_CH_

  class TAO_RTCORBA_Export ProtocolList_out
  {
  public:
    ProtocolList_out (ProtocolList *&);
    ProtocolList_out (ProtocolList_var &);
    ProtocolList_out (const ProtocolList_out &);
    ProtocolList_out &operator= (const ProtocolList_out &);
    ProtocolList_out &operator= (ProtocolList *);
    operator ProtocolList *&();
    ProtocolList *&ptr (void);
    ProtocolList *operator-> (void);
    Protocol & operator[] (CORBA::ULong index);

  private:
    ProtocolList *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const ProtocolList_var &);
  };


#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong SERVER_PROTOCOL_POLICY_TYPE;


#if !defined (_RTCORBA_SERVERPROTOCOLPOLICY___PTR_CH_)
#define _RTCORBA_SERVERPROTOCOLPOLICY___PTR_CH_

  class ServerProtocolPolicy;
  typedef ServerProtocolPolicy *ServerProtocolPolicy_ptr;

#endif /* end #if !defined */


#if !defined (_RTCORBA_SERVERPROTOCOLPOLICY___VAR_CH_)
#define _RTCORBA_SERVERPROTOCOLPOLICY___VAR_CH_

  class TAO_RTCORBA_Export ServerProtocolPolicy_var : public TAO_Base_var
  {
  public:
    ServerProtocolPolicy_var (void); // default constructor
    ServerProtocolPolicy_var (ServerProtocolPolicy_ptr p) : ptr_ (p) {}
    ServerProtocolPolicy_var (const ServerProtocolPolicy_var &); // copy constructor
    ~ServerProtocolPolicy_var (void); // destructor

    ServerProtocolPolicy_var &operator= (ServerProtocolPolicy_ptr);
    ServerProtocolPolicy_var &operator= (const ServerProtocolPolicy_var &);
    ServerProtocolPolicy_ptr operator-> (void) const;

    operator const ServerProtocolPolicy_ptr &() const;
    operator ServerProtocolPolicy_ptr &();
    // in, inout, out, _retn
    ServerProtocolPolicy_ptr in (void) const;
    ServerProtocolPolicy_ptr &inout (void);
    ServerProtocolPolicy_ptr &out (void);
    ServerProtocolPolicy_ptr _retn (void);
    ServerProtocolPolicy_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static ServerProtocolPolicy_ptr tao_duplicate (ServerProtocolPolicy_ptr);
    static void tao_release (ServerProtocolPolicy_ptr);
    static ServerProtocolPolicy_ptr tao_nil (void);
    static ServerProtocolPolicy_ptr tao_narrow (
        CORBA::Object *
        TAO_ENV_ARG_DECL_NOT_USED
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    ServerProtocolPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    ServerProtocolPolicy_var (const TAO_Base_var &rhs);
    ServerProtocolPolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_SERVERPROTOCOLPOLICY___OUT_CH_)
#define _RTCORBA_SERVERPROTOCOLPOLICY___OUT_CH_

  class TAO_RTCORBA_Export ServerProtocolPolicy_out
  {
  public:
    ServerProtocolPolicy_out (ServerProtocolPolicy_ptr &);
    ServerProtocolPolicy_out (ServerProtocolPolicy_var &);
    ServerProtocolPolicy_out (const ServerProtocolPolicy_out &);
    ServerProtocolPolicy_out &operator= (const ServerProtocolPolicy_out &);
    ServerProtocolPolicy_out &operator= (const ServerProtocolPolicy_var &);
    ServerProtocolPolicy_out &operator= (ServerProtocolPolicy_ptr);
    operator ServerProtocolPolicy_ptr &();
    ServerProtocolPolicy_ptr &ptr (void);
    ServerProtocolPolicy_ptr operator-> (void);

  private:
    ServerProtocolPolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_SERVERPROTOCOLPOLICY_CH_)
#define _RTCORBA_SERVERPROTOCOLPOLICY_CH_

  class TAO_RTCORBA_Export ServerProtocolPolicy
    : public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef ServerProtocolPolicy_ptr _ptr_type;
    typedef ServerProtocolPolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

    // the static operations
    static ServerProtocolPolicy_ptr _duplicate (ServerProtocolPolicy_ptr obj);

    static ServerProtocolPolicy_ptr _narrow (
        CORBA::Object_ptr obj
        TAO_ENV_ARG_DECL_WITH_DEFAULTS);


    static ServerProtocolPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        TAO_ENV_ARG_DECL_WITH_DEFAULTS);


    static ServerProtocolPolicy_ptr _nil (void)
      {
        return (ServerProtocolPolicy_ptr)0;
      }

    virtual RTCORBA::ProtocolList * protocols (
        TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    ServerProtocolPolicy ();

    virtual ~ServerProtocolPolicy (void);

  private:
    ServerProtocolPolicy (const ServerProtocolPolicy &);
    void operator= (const ServerProtocolPolicy &);
  };


#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong CLIENT_PROTOCOL_POLICY_TYPE;


#if !defined (_RTCORBA_CLIENTPROTOCOLPOLICY___PTR_CH_)
#define _RTCORBA_CLIENTPROTOCOLPOLICY___PTR_CH_

  class ClientProtocolPolicy;
  typedef ClientProtocolPolicy *ClientProtocolPolicy_ptr;

#endif /* end #if !defined */


#if !defined (_RTCORBA_CLIENTPROTOCOLPOLICY___VAR_CH_)
#define _RTCORBA_CLIENTPROTOCOLPOLICY___VAR_CH_

  class TAO_RTCORBA_Export ClientProtocolPolicy_var : public TAO_Base_var
  {
  public:
    ClientProtocolPolicy_var (void); // default constructor
    ClientProtocolPolicy_var (ClientProtocolPolicy_ptr p) : ptr_ (p) {}
    ClientProtocolPolicy_var (const ClientProtocolPolicy_var &); // copy constructor
    ~ClientProtocolPolicy_var (void); // destructor

    ClientProtocolPolicy_var &operator= (ClientProtocolPolicy_ptr);
    ClientProtocolPolicy_var &operator= (const ClientProtocolPolicy_var &);
    ClientProtocolPolicy_ptr operator-> (void) const;

    operator const ClientProtocolPolicy_ptr &() const;
    operator ClientProtocolPolicy_ptr &();
    // in, inout, out, _retn
    ClientProtocolPolicy_ptr in (void) const;
    ClientProtocolPolicy_ptr &inout (void);
    ClientProtocolPolicy_ptr &out (void);
    ClientProtocolPolicy_ptr _retn (void);
    ClientProtocolPolicy_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static ClientProtocolPolicy_ptr tao_duplicate (ClientProtocolPolicy_ptr);
    static void tao_release (ClientProtocolPolicy_ptr);
    static ClientProtocolPolicy_ptr tao_nil (void);
    static ClientProtocolPolicy_ptr tao_narrow (
        CORBA::Object *
        TAO_ENV_ARG_DECL_NOT_USED
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    ClientProtocolPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    ClientProtocolPolicy_var (const TAO_Base_var &rhs);
    ClientProtocolPolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_CLIENTPROTOCOLPOLICY___OUT_CH_)
#define _RTCORBA_CLIENTPROTOCOLPOLICY___OUT_CH_

  class TAO_RTCORBA_Export ClientProtocolPolicy_out
  {
  public:
    ClientProtocolPolicy_out (ClientProtocolPolicy_ptr &);
    ClientProtocolPolicy_out (ClientProtocolPolicy_var &);
    ClientProtocolPolicy_out (const ClientProtocolPolicy_out &);
    ClientProtocolPolicy_out &operator= (const ClientProtocolPolicy_out &);
    ClientProtocolPolicy_out &operator= (const ClientProtocolPolicy_var &);
    ClientProtocolPolicy_out &operator= (ClientProtocolPolicy_ptr);
    operator ClientProtocolPolicy_ptr &();
    ClientProtocolPolicy_ptr &ptr (void);
    ClientProtocolPolicy_ptr operator-> (void);

  private:
    ClientProtocolPolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_CLIENTPROTOCOLPOLICY_CH_)
#define _RTCORBA_CLIENTPROTOCOLPOLICY_CH_

  class TAO_RTCORBA_Export ClientProtocolPolicy
    : public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef ClientProtocolPolicy_ptr _ptr_type;
    typedef ClientProtocolPolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

    // the static operations
    static ClientProtocolPolicy_ptr _duplicate (ClientProtocolPolicy_ptr obj);

    static ClientProtocolPolicy_ptr _narrow (
        CORBA::Object_ptr obj
        TAO_ENV_ARG_DECL_WITH_DEFAULTS);


    static ClientProtocolPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        TAO_ENV_ARG_DECL_WITH_DEFAULTS);


    static ClientProtocolPolicy_ptr _nil (void)
      {
        return (ClientProtocolPolicy_ptr)0;
      }

    virtual RTCORBA::ProtocolList * protocols (
        TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    ClientProtocolPolicy ();

    virtual ~ClientProtocolPolicy (void);

  private:
    ClientProtocolPolicy (const ClientProtocolPolicy &);
    void operator= (const ClientProtocolPolicy &);
  };


#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong PRIVATE_CONNECTION_POLICY_TYPE;


#if !defined (_RTCORBA_PRIVATECONNECTIONPOLICY___PTR_CH_)
#define _RTCORBA_PRIVATECONNECTIONPOLICY___PTR_CH_

  class PrivateConnectionPolicy;
  typedef PrivateConnectionPolicy *PrivateConnectionPolicy_ptr;

#endif /* end #if !defined */


#if !defined (_RTCORBA_PRIVATECONNECTIONPOLICY___VAR_CH_)
#define _RTCORBA_PRIVATECONNECTIONPOLICY___VAR_CH_

  class TAO_RTCORBA_Export PrivateConnectionPolicy_var : public TAO_Base_var
  {
  public:
    PrivateConnectionPolicy_var (void); // default constructor
    PrivateConnectionPolicy_var (PrivateConnectionPolicy_ptr p) : ptr_ (p) {}
    PrivateConnectionPolicy_var (const PrivateConnectionPolicy_var &); // copy constructor
    ~PrivateConnectionPolicy_var (void); // destructor

    PrivateConnectionPolicy_var &operator= (PrivateConnectionPolicy_ptr);
    PrivateConnectionPolicy_var &operator= (const PrivateConnectionPolicy_var &);
    PrivateConnectionPolicy_ptr operator-> (void) const;

    operator const PrivateConnectionPolicy_ptr &() const;
    operator PrivateConnectionPolicy_ptr &();
    // in, inout, out, _retn
    PrivateConnectionPolicy_ptr in (void) const;
    PrivateConnectionPolicy_ptr &inout (void);
    PrivateConnectionPolicy_ptr &out (void);
    PrivateConnectionPolicy_ptr _retn (void);
    PrivateConnectionPolicy_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static PrivateConnectionPolicy_ptr tao_duplicate (PrivateConnectionPolicy_ptr);
    static void tao_release (PrivateConnectionPolicy_ptr);
    static PrivateConnectionPolicy_ptr tao_nil (void);
    static PrivateConnectionPolicy_ptr tao_narrow (
        CORBA::Object *
        TAO_ENV_ARG_DECL_NOT_USED
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    PrivateConnectionPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    PrivateConnectionPolicy_var (const TAO_Base_var &rhs);
    PrivateConnectionPolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_PRIVATECONNECTIONPOLICY___OUT_CH_)
#define _RTCORBA_PRIVATECONNECTIONPOLICY___OUT_CH_

  class TAO_RTCORBA_Export PrivateConnectionPolicy_out
  {
  public:
    PrivateConnectionPolicy_out (PrivateConnectionPolicy_ptr &);
    PrivateConnectionPolicy_out (PrivateConnectionPolicy_var &);
    PrivateConnectionPolicy_out (const PrivateConnectionPolicy_out &);
    PrivateConnectionPolicy_out &operator= (const PrivateConnectionPolicy_out &);
    PrivateConnectionPolicy_out &operator= (const PrivateConnectionPolicy_var &);
    PrivateConnectionPolicy_out &operator= (PrivateConnectionPolicy_ptr);
    operator PrivateConnectionPolicy_ptr &();
    PrivateConnectionPolicy_ptr &ptr (void);
    PrivateConnectionPolicy_ptr operator-> (void);

  private:
    PrivateConnectionPolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_PRIVATECONNECTIONPOLICY_CH_)
#define _RTCORBA_PRIVATECONNECTIONPOLICY_CH_

  class TAO_RTCORBA_Export PrivateConnectionPolicy
    : public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef PrivateConnectionPolicy_ptr _ptr_type;
    typedef PrivateConnectionPolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

    // the static operations
    static PrivateConnectionPolicy_ptr _duplicate (PrivateConnectionPolicy_ptr obj);

    static PrivateConnectionPolicy_ptr _narrow (
        CORBA::Object_ptr obj
        TAO_ENV_ARG_DECL_WITH_DEFAULTS);


    static PrivateConnectionPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        TAO_ENV_ARG_DECL_WITH_DEFAULTS);


    static PrivateConnectionPolicy_ptr _nil (void)
      {
        return (PrivateConnectionPolicy_ptr)0;
      }

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    PrivateConnectionPolicy ();

    virtual ~PrivateConnectionPolicy (void);

  private:
    PrivateConnectionPolicy (const PrivateConnectionPolicy &);
    void operator= (const PrivateConnectionPolicy &);
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_TCPPROTOCOLPROPERTIES___PTR_CH_)
#define _RTCORBA_TCPPROTOCOLPROPERTIES___PTR_CH_

  class TCPProtocolProperties;
  typedef TCPProtocolProperties *TCPProtocolProperties_ptr;

#endif /* end #if !defined */


#if !defined (_RTCORBA_TCPPROTOCOLPROPERTIES___VAR_CH_)
#define _RTCORBA_TCPPROTOCOLPROPERTIES___VAR_CH_

  class TAO_RTCORBA_Export TCPProtocolProperties_var : public TAO_Base_var
  {
  public:
    TCPProtocolProperties_var (void); // default constructor
    TCPProtocolProperties_var (TCPProtocolProperties_ptr p) : ptr_ (p) {}
    TCPProtocolProperties_var (const TCPProtocolProperties_var &); // copy constructor
    ~TCPProtocolProperties_var (void); // destructor

    TCPProtocolProperties_var &operator= (TCPProtocolProperties_ptr);
    TCPProtocolProperties_var &operator= (const TCPProtocolProperties_var &);
    TCPProtocolProperties_ptr operator-> (void) const;

    operator const TCPProtocolProperties_ptr &() const;
    operator TCPProtocolProperties_ptr &();
    // in, inout, out, _retn
    TCPProtocolProperties_ptr in (void) const;
    TCPProtocolProperties_ptr &inout (void);
    TCPProtocolProperties_ptr &out (void);
    TCPProtocolProperties_ptr _retn (void);
    TCPProtocolProperties_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static TCPProtocolProperties_ptr tao_duplicate (TCPProtocolProperties_ptr);
    static void tao_release (TCPProtocolProperties_ptr);
    static TCPProtocolProperties_ptr tao_nil (void);
    static TCPProtocolProperties_ptr tao_narrow (
        CORBA::Object *
        TAO_ENV_ARG_DECL_NOT_USED
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    TCPProtocolProperties_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    TCPProtocolProperties_var (const TAO_Base_var &rhs);
    TCPProtocolProperties_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_TCPPROTOCOLPROPERTIES___OUT_CH_)
#define _RTCORBA_TCPPROTOCOLPROPERTIES___OUT_CH_

  class TAO_RTCORBA_Export TCPProtocolProperties_out
  {
  public:
    TCPProtocolProperties_out (TCPProtocolProperties_ptr &);
    TCPProtocolProperties_out (TCPProtocolProperties_var &);
    TCPProtocolProperties_out (const TCPProtocolProperties_out &);
    TCPProtocolProperties_out &operator= (const TCPProtocolProperties_out &);
    TCPProtocolProperties_out &operator= (const TCPProtocolProperties_var &);
    TCPProtocolProperties_out &operator= (TCPProtocolProperties_ptr);
    operator TCPProtocolProperties_ptr &();
    TCPProtocolProperties_ptr &ptr (void);
    TCPProtocolProperties_ptr operator-> (void);

  private:
    TCPProtocolProperties_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_TCPPROTOCOLPROPERTIES_CH_)
#define _RTCORBA_TCPPROTOCOLPROPERTIES_CH_

  class TAO_RTCORBA_Export TCPProtocolProperties
    : public virtual ProtocolProperties
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef TCPProtocolProperties_ptr _ptr_type;
    typedef TCPProtocolProperties_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

    // the static operations
    static TCPProtocolProperties_ptr _duplicate (TCPProtocolProperties_ptr obj);

    static TCPProtocolProperties_ptr _narrow (
        CORBA::Object_ptr obj
        TAO_ENV_ARG_DECL_WITH_DEFAULTS);


    static TCPProtocolProperties_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        TAO_ENV_ARG_DECL_WITH_DEFAULTS);


    static TCPProtocolProperties_ptr _nil (void)
      {
        return (TCPProtocolProperties_ptr)0;
      }

    virtual CORBA::Long send_buffer_size (
        TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void send_buffer_size (
        CORBA::Long send_buffer_size
        TAO_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual CORBA::Long recv_buffer_size (
        TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void recv_buffer_size (
        CORBA::Long recv_buffer_size
        TAO_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual CORBA::Boolean keep_alive (
        TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void keep_alive (
        CORBA::Boolean keep_alive
        TAO_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual CORBA::Boolean dont_route (
        TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void dont_route (
        CORBA::Boolean dont_route
        TAO_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual CORBA::Boolean no_delay (
        TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void no_delay (
        CORBA::Boolean no_delay
        TAO_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    TCPProtocolProperties ();

    virtual ~TCPProtocolProperties (void);

  private:
    TCPProtocolProperties (const TCPProtocolProperties &);
    void operator= (const TCPProtocolProperties &);
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_GIOPPROTOCOLPROPERTIES___PTR_CH_)
#define _RTCORBA_GIOPPROTOCOLPROPERTIES___PTR_CH_

  class GIOPProtocolProperties;
  typedef GIOPProtocolProperties *GIOPProtocolProperties_ptr;

#endif /* end #if !defined */


#if !defined (_RTCORBA_GIOPPROTOCOLPROPERTIES___VAR_CH_)
#define _RTCORBA_GIOPPROTOCOLPROPERTIES___VAR_CH_

  class TAO_RTCORBA_Export GIOPProtocolProperties_var : public TAO_Base_var
  {
  public:
    GIOPProtocolProperties_var (void); // default constructor
    GIOPProtocolProperties_var (GIOPProtocolProperties_ptr p) : ptr_ (p) {}
    GIOPProtocolProperties_var (const GIOPProtocolProperties_var &); // copy constructor
    ~GIOPProtocolProperties_var (void); // destructor

    GIOPProtocolProperties_var &operator= (GIOPProtocolProperties_ptr);
    GIOPProtocolProperties_var &operator= (const GIOPProtocolProperties_var &);
    GIOPProtocolProperties_ptr operator-> (void) const;

    operator const GIOPProtocolProperties_ptr &() const;
    operator GIOPProtocolProperties_ptr &();
    // in, inout, out, _retn
    GIOPProtocolProperties_ptr in (void) const;
    GIOPProtocolProperties_ptr &inout (void);
    GIOPProtocolProperties_ptr &out (void);
    GIOPProtocolProperties_ptr _retn (void);
    GIOPProtocolProperties_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static GIOPProtocolProperties_ptr tao_duplicate (GIOPProtocolProperties_ptr);
    static void tao_release (GIOPProtocolProperties_ptr);
    static GIOPProtocolProperties_ptr tao_nil (void);
    static GIOPProtocolProperties_ptr tao_narrow (
        CORBA::Object *
        TAO_ENV_ARG_DECL_NOT_USED
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    GIOPProtocolProperties_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    GIOPProtocolProperties_var (const TAO_Base_var &rhs);
    GIOPProtocolProperties_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_GIOPPROTOCOLPROPERTIES___OUT_CH_)
#define _RTCORBA_GIOPPROTOCOLPROPERTIES___OUT_CH_

  class TAO_RTCORBA_Export GIOPProtocolProperties_out
  {
  public:
    GIOPProtocolProperties_out (GIOPProtocolProperties_ptr &);
    GIOPProtocolProperties_out (GIOPProtocolProperties_var &);
    GIOPProtocolProperties_out (const GIOPProtocolProperties_out &);
    GIOPProtocolProperties_out &operator= (const GIOPProtocolProperties_out &);
    GIOPProtocolProperties_out &operator= (const GIOPProtocolProperties_var &);
    GIOPProtocolProperties_out &operator= (GIOPProtocolProperties_ptr);
    operator GIOPProtocolProperties_ptr &();
    GIOPProtocolProperties_ptr &ptr (void);
    GIOPProtocolProperties_ptr operator-> (void);

  private:
    GIOPProtocolProperties_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_GIOPPROTOCOLPROPERTIES_CH_)
#define _RTCORBA_GIOPPROTOCOLPROPERTIES_CH_

  class TAO_RTCORBA_Export GIOPProtocolProperties
    : public virtual ProtocolProperties
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef GIOPProtocolProperties_ptr _ptr_type;
    typedef GIOPProtocolProperties_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

    // the static operations
    static GIOPProtocolProperties_ptr _duplicate (GIOPProtocolProperties_ptr obj);

    static GIOPProtocolProperties_ptr _narrow (
        CORBA::Object_ptr obj
        TAO_ENV_ARG_DECL_WITH_DEFAULTS);


    static GIOPProtocolProperties_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        TAO_ENV_ARG_DECL_WITH_DEFAULTS);


    static GIOPProtocolProperties_ptr _nil (void)
      {
        return (GIOPProtocolProperties_ptr)0;
      }

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    GIOPProtocolProperties ();

    virtual ~GIOPProtocolProperties (void);

  private:
    GIOPProtocolProperties (const GIOPProtocolProperties &);
    void operator= (const GIOPProtocolProperties &);
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_UNIXDOMAINPROTOCOLPROPERTIES___PTR_CH_)
#define _RTCORBA_UNIXDOMAINPROTOCOLPROPERTIES___PTR_CH_

  class UnixDomainProtocolProperties;
  typedef UnixDomainProtocolProperties *UnixDomainProtocolProperties_ptr;

#endif /* end #if !defined */


#if !defined (_RTCORBA_UNIXDOMAINPROTOCOLPROPERTIES___VAR_CH_)
#define _RTCORBA_UNIXDOMAINPROTOCOLPROPERTIES___VAR_CH_

  class TAO_RTCORBA_Export UnixDomainProtocolProperties_var : public TAO_Base_var
  {
  public:
    UnixDomainProtocolProperties_var (void); // default constructor
    UnixDomainProtocolProperties_var (UnixDomainProtocolProperties_ptr p) : ptr_ (p) {}
    UnixDomainProtocolProperties_var (const UnixDomainProtocolProperties_var &); // copy constructor
    ~UnixDomainProtocolProperties_var (void); // destructor

    UnixDomainProtocolProperties_var &operator= (UnixDomainProtocolProperties_ptr);
    UnixDomainProtocolProperties_var &operator= (const UnixDomainProtocolProperties_var &);
    UnixDomainProtocolProperties_ptr operator-> (void) const;

    operator const UnixDomainProtocolProperties_ptr &() const;
    operator UnixDomainProtocolProperties_ptr &();
    // in, inout, out, _retn
    UnixDomainProtocolProperties_ptr in (void) const;
    UnixDomainProtocolProperties_ptr &inout (void);
    UnixDomainProtocolProperties_ptr &out (void);
    UnixDomainProtocolProperties_ptr _retn (void);
    UnixDomainProtocolProperties_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static UnixDomainProtocolProperties_ptr tao_duplicate (UnixDomainProtocolProperties_ptr);
    static void tao_release (UnixDomainProtocolProperties_ptr);
    static UnixDomainProtocolProperties_ptr tao_nil (void);
    static UnixDomainProtocolProperties_ptr tao_narrow (
        CORBA::Object *
        TAO_ENV_ARG_DECL_NOT_USED
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    UnixDomainProtocolProperties_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    UnixDomainProtocolProperties_var (const TAO_Base_var &rhs);
    UnixDomainProtocolProperties_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_UNIXDOMAINPROTOCOLPROPERTIES___OUT_CH_)
#define _RTCORBA_UNIXDOMAINPROTOCOLPROPERTIES___OUT_CH_

  class TAO_RTCORBA_Export UnixDomainProtocolProperties_out
  {
  public:
    UnixDomainProtocolProperties_out (UnixDomainProtocolProperties_ptr &);
    UnixDomainProtocolProperties_out (UnixDomainProtocolProperties_var &);
    UnixDomainProtocolProperties_out (const UnixDomainProtocolProperties_out &);
    UnixDomainProtocolProperties_out &operator= (const UnixDomainProtocolProperties_out &);
    UnixDomainProtocolProperties_out &operator= (const UnixDomainProtocolProperties_var &);
    UnixDomainProtocolProperties_out &operator= (UnixDomainProtocolProperties_ptr);
    operator UnixDomainProtocolProperties_ptr &();
    UnixDomainProtocolProperties_ptr &ptr (void);
    UnixDomainProtocolProperties_ptr operator-> (void);

  private:
    UnixDomainProtocolProperties_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_UNIXDOMAINPROTOCOLPROPERTIES_CH_)
#define _RTCORBA_UNIXDOMAINPROTOCOLPROPERTIES_CH_

  class TAO_RTCORBA_Export UnixDomainProtocolProperties
    : public virtual ProtocolProperties
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef UnixDomainProtocolProperties_ptr _ptr_type;
    typedef UnixDomainProtocolProperties_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

    // the static operations
    static UnixDomainProtocolProperties_ptr _duplicate (UnixDomainProtocolProperties_ptr obj);

    static UnixDomainProtocolProperties_ptr _narrow (
        CORBA::Object_ptr obj
        TAO_ENV_ARG_DECL_WITH_DEFAULTS);


    static UnixDomainProtocolProperties_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        TAO_ENV_ARG_DECL_WITH_DEFAULTS);


    static UnixDomainProtocolProperties_ptr _nil (void)
      {
        return (UnixDomainProtocolProperties_ptr)0;
      }

    virtual CORBA::Long send_buffer_size (
        TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void send_buffer_size (
        CORBA::Long send_buffer_size
        TAO_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual CORBA::Long recv_buffer_size (
        TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void recv_buffer_size (
        CORBA::Long recv_buffer_size
        TAO_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    UnixDomainProtocolProperties ();

    virtual ~UnixDomainProtocolProperties (void);

  private:
    UnixDomainProtocolProperties (const UnixDomainProtocolProperties &);
    void operator= (const UnixDomainProtocolProperties &);
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_SHAREDMEMORYPROTOCOLPROPERTIES___PTR_CH_)
#define _RTCORBA_SHAREDMEMORYPROTOCOLPROPERTIES___PTR_CH_

  class SharedMemoryProtocolProperties;
  typedef SharedMemoryProtocolProperties *SharedMemoryProtocolProperties_ptr;

#endif /* end #if !defined */


#if !defined (_RTCORBA_SHAREDMEMORYPROTOCOLPROPERTIES___VAR_CH_)
#define _RTCORBA_SHAREDMEMORYPROTOCOLPROPERTIES___VAR_CH_

  class TAO_RTCORBA_Export SharedMemoryProtocolProperties_var : public TAO_Base_var
  {
  public:
    SharedMemoryProtocolProperties_var (void); // default constructor
    SharedMemoryProtocolProperties_var (SharedMemoryProtocolProperties_ptr p) : ptr_ (p) {}
    SharedMemoryProtocolProperties_var (const SharedMemoryProtocolProperties_var &); // copy constructor
    ~SharedMemoryProtocolProperties_var (void); // destructor

    SharedMemoryProtocolProperties_var &operator= (SharedMemoryProtocolProperties_ptr);
    SharedMemoryProtocolProperties_var &operator= (const SharedMemoryProtocolProperties_var &);
    SharedMemoryProtocolProperties_ptr operator-> (void) const;

    operator const SharedMemoryProtocolProperties_ptr &() const;
    operator SharedMemoryProtocolProperties_ptr &();
    // in, inout, out, _retn
    SharedMemoryProtocolProperties_ptr in (void) const;
    SharedMemoryProtocolProperties_ptr &inout (void);
    SharedMemoryProtocolProperties_ptr &out (void);
    SharedMemoryProtocolProperties_ptr _retn (void);
    SharedMemoryProtocolProperties_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static SharedMemoryProtocolProperties_ptr tao_duplicate (SharedMemoryProtocolProperties_ptr);
    static void tao_release (SharedMemoryProtocolProperties_ptr);
    static SharedMemoryProtocolProperties_ptr tao_nil (void);
    static SharedMemoryProtocolProperties_ptr tao_narrow (
        CORBA::Object *
        TAO_ENV_ARG_DECL_NOT_USED
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    SharedMemoryProtocolProperties_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    SharedMemoryProtocolProperties_var (const TAO_Base_var &rhs);
    SharedMemoryProtocolProperties_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_SHAREDMEMORYPROTOCOLPROPERTIES___OUT_CH_)
#define _RTCORBA_SHAREDMEMORYPROTOCOLPROPERTIES___OUT_CH_

  class TAO_RTCORBA_Export SharedMemoryProtocolProperties_out
  {
  public:
    SharedMemoryProtocolProperties_out (SharedMemoryProtocolProperties_ptr &);
    SharedMemoryProtocolProperties_out (SharedMemoryProtocolProperties_var &);
    SharedMemoryProtocolProperties_out (const SharedMemoryProtocolProperties_out &);
    SharedMemoryProtocolProperties_out &operator= (const SharedMemoryProtocolProperties_out &);
    SharedMemoryProtocolProperties_out &operator= (const SharedMemoryProtocolProperties_var &);
    SharedMemoryProtocolProperties_out &operator= (SharedMemoryProtocolProperties_ptr);
    operator SharedMemoryProtocolProperties_ptr &();
    SharedMemoryProtocolProperties_ptr &ptr (void);
    SharedMemoryProtocolProperties_ptr operator-> (void);

  private:
    SharedMemoryProtocolProperties_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_SHAREDMEMORYPROTOCOLPROPERTIES_CH_)
#define _RTCORBA_SHAREDMEMORYPROTOCOLPROPERTIES_CH_

  class TAO_RTCORBA_Export SharedMemoryProtocolProperties
    : public virtual ProtocolProperties
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef SharedMemoryProtocolProperties_ptr _ptr_type;
    typedef SharedMemoryProtocolProperties_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

    // the static operations
    static SharedMemoryProtocolProperties_ptr _duplicate (SharedMemoryProtocolProperties_ptr obj);

    static SharedMemoryProtocolProperties_ptr _narrow (
        CORBA::Object_ptr obj
        TAO_ENV_ARG_DECL_WITH_DEFAULTS);


    static SharedMemoryProtocolProperties_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        TAO_ENV_ARG_DECL_WITH_DEFAULTS);


    static SharedMemoryProtocolProperties_ptr _nil (void)
      {
        return (SharedMemoryProtocolProperties_ptr)0;
      }

    virtual CORBA::Long preallocate_buffer_size (
        TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void preallocate_buffer_size (
        CORBA::Long preallocate_buffer_size
        TAO_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual char * mmap_filename (
        TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void mmap_filename (
        const char * mmap_filename
        TAO_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual char * mmap_lockname (
        TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void mmap_lockname (
        const char * mmap_lockname
        TAO_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    SharedMemoryProtocolProperties ();

    virtual ~SharedMemoryProtocolProperties (void);

  private:
    SharedMemoryProtocolProperties (const SharedMemoryProtocolProperties &);
    void operator= (const SharedMemoryProtocolProperties &);
  };


#endif /* end #if !defined */

  struct PriorityBand;
  class PriorityBand_var;

  struct TAO_RTCORBA_Export PriorityBand
  {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef PriorityBand_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

    static void _tao_any_destructor (void*);

    ACE_NESTED_CLASS (RTCORBA, Priority) low;
    ACE_NESTED_CLASS (RTCORBA, Priority) high;

  };

  class TAO_RTCORBA_Export PriorityBand_var
  {
  public:
    PriorityBand_var (void);
    PriorityBand_var (PriorityBand *);
    PriorityBand_var (const PriorityBand_var &);
    // Fixed-size types only.
    PriorityBand_var (const PriorityBand &);
    ~PriorityBand_var (void);

    PriorityBand_var &operator= (PriorityBand *);
    PriorityBand_var &operator= (const PriorityBand_var &);
    // Fixed-size types only.
    PriorityBand_var &operator= (const PriorityBand &);
    PriorityBand *operator-> (void);
    const PriorityBand *operator-> (void) const;

    operator const PriorityBand &() const;
    operator PriorityBand &();
    operator PriorityBand &() const;

    // in, inout, out, _retn
    const PriorityBand &in (void) const;
    PriorityBand &inout (void);
    PriorityBand &out (void);
    PriorityBand _retn (void);
    PriorityBand *ptr (void) const;

  private:
    PriorityBand *ptr_;
  };

  typedef PriorityBand &PriorityBand_out;

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_PriorityBand;


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_RTCORBA_PRIORITYBANDS_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_RTCORBA_PRIORITYBANDS_CH_

  class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_RTCORBA_PriorityBands
    : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.
    _TAO_Unbounded_Sequence_RTCORBA_PriorityBands (void);
      _TAO_Unbounded_Sequence_RTCORBA_PriorityBands (CORBA::ULong maximum);
    _TAO_Unbounded_Sequence_RTCORBA_PriorityBands (
        CORBA::ULong maximum,
        CORBA::ULong length,
        PriorityBand *data,
        CORBA::Boolean release = 0
      );
    _TAO_Unbounded_Sequence_RTCORBA_PriorityBands (
        const _TAO_Unbounded_Sequence_RTCORBA_PriorityBands &rhs
      );
    _TAO_Unbounded_Sequence_RTCORBA_PriorityBands &operator= (
        const _TAO_Unbounded_Sequence_RTCORBA_PriorityBands &rhs
      );
    virtual ~_TAO_Unbounded_Sequence_RTCORBA_PriorityBands (void);

      // = Accessors.
      PriorityBand &operator[] (CORBA::ULong i);
      const PriorityBand &operator[] (CORBA::ULong i) const;

      // = Static operations.
      static PriorityBand *allocbuf (CORBA::ULong size);
      static void freebuf (PriorityBand *buffer);

    // Implement the TAO_Base_Sequence methods (see Sequence.h)
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      PriorityBand *get_buffer (CORBA::Boolean orphan = 0);
      const PriorityBand *get_buffer (void) const;
    void replace (
        CORBA::ULong max,
        CORBA::ULong length,
        PriorityBand *data,
        CORBA::Boolean release
      );
    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_RTCORBA_PRIORITYBANDS_CH_)
#define _RTCORBA_PRIORITYBANDS_CH_

  class PriorityBands;
  class PriorityBands_var;

  // *************************************************************
  // PriorityBands
  // *************************************************************

  class TAO_RTCORBA_Export PriorityBands : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Sequence_RTCORBA_PriorityBands
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Sequence<PriorityBand>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    PriorityBands (void); // default ctor
    PriorityBands (CORBA::ULong max); // uses max size
    PriorityBands (
      CORBA::ULong max,
      CORBA::ULong length,
      PriorityBand *buffer,
      CORBA::Boolean release = 0
    );
    PriorityBands (const PriorityBands &); // copy ctor
    ~PriorityBands (void);
    static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef PriorityBands_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */


  };

#endif /* end #if !defined */


#if !defined (_RTCORBA_PRIORITYBANDS___VAR_CH_)
#define _RTCORBA_PRIORITYBANDS___VAR_CH_

  // *************************************************************
  // class RTCORBA::PriorityBands_var
  // *************************************************************

  class TAO_RTCORBA_Export PriorityBands_var
  {
  public:
    PriorityBands_var (void);
    PriorityBands_var (PriorityBands *);
    PriorityBands_var (const PriorityBands_var &);
    // Fixed-size base types only.
    PriorityBands_var (const PriorityBands &);
    ~PriorityBands_var (void);

    PriorityBands_var &operator= (PriorityBands *);
    PriorityBands_var &operator= (const PriorityBands_var &);
    // Fixed-size base types only.
    PriorityBands_var &operator= (const PriorityBands &);
    PriorityBands *operator-> (void);
    const PriorityBands *operator-> (void) const;

    operator const PriorityBands &() const;
    operator PriorityBands &();
    operator PriorityBands &() const;

    PriorityBand & operator[] (CORBA::ULong index);
    const PriorityBand & operator[] (CORBA::ULong index) const;

    // in, inout, out, _retn
    const PriorityBands &in (void) const;
    PriorityBands &inout (void);
    PriorityBands *&out (void);
    PriorityBands *_retn (void);
    PriorityBands *ptr (void) const;

  private:
    PriorityBands *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_PRIORITYBANDS___OUT_CH_)
#define _RTCORBA_PRIORITYBANDS___OUT_CH_

  class TAO_RTCORBA_Export PriorityBands_out
  {
  public:
    PriorityBands_out (PriorityBands *&);
    PriorityBands_out (PriorityBands_var &);
    PriorityBands_out (const PriorityBands_out &);
    PriorityBands_out &operator= (const PriorityBands_out &);
    PriorityBands_out &operator= (PriorityBands *);
    operator PriorityBands *&();
    PriorityBands *&ptr (void);
    PriorityBands *operator-> (void);
    PriorityBand & operator[] (CORBA::ULong index);

  private:
    PriorityBands *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const PriorityBands_var &);
  };


#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_PriorityBands;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong PRIORITY_BANDED_CONNECTION_POLICY_TYPE;


#if !defined (_RTCORBA_PRIORITYBANDEDCONNECTIONPOLICY___PTR_CH_)
#define _RTCORBA_PRIORITYBANDEDCONNECTIONPOLICY___PTR_CH_

  class PriorityBandedConnectionPolicy;
  typedef PriorityBandedConnectionPolicy *PriorityBandedConnectionPolicy_ptr;

#endif /* end #if !defined */


#if !defined (_RTCORBA_PRIORITYBANDEDCONNECTIONPOLICY___VAR_CH_)
#define _RTCORBA_PRIORITYBANDEDCONNECTIONPOLICY___VAR_CH_

  class TAO_RTCORBA_Export PriorityBandedConnectionPolicy_var : public TAO_Base_var
  {
  public:
    PriorityBandedConnectionPolicy_var (void); // default constructor
    PriorityBandedConnectionPolicy_var (PriorityBandedConnectionPolicy_ptr p) : ptr_ (p) {}
    PriorityBandedConnectionPolicy_var (const PriorityBandedConnectionPolicy_var &); // copy constructor
    ~PriorityBandedConnectionPolicy_var (void); // destructor

    PriorityBandedConnectionPolicy_var &operator= (PriorityBandedConnectionPolicy_ptr);
    PriorityBandedConnectionPolicy_var &operator= (const PriorityBandedConnectionPolicy_var &);
    PriorityBandedConnectionPolicy_ptr operator-> (void) const;

    operator const PriorityBandedConnectionPolicy_ptr &() const;
    operator PriorityBandedConnectionPolicy_ptr &();
    // in, inout, out, _retn
    PriorityBandedConnectionPolicy_ptr in (void) const;
    PriorityBandedConnectionPolicy_ptr &inout (void);
    PriorityBandedConnectionPolicy_ptr &out (void);
    PriorityBandedConnectionPolicy_ptr _retn (void);
    PriorityBandedConnectionPolicy_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static PriorityBandedConnectionPolicy_ptr tao_duplicate (PriorityBandedConnectionPolicy_ptr);
    static void tao_release (PriorityBandedConnectionPolicy_ptr);
    static PriorityBandedConnectionPolicy_ptr tao_nil (void);
    static PriorityBandedConnectionPolicy_ptr tao_narrow (
        CORBA::Object *
        TAO_ENV_ARG_DECL_NOT_USED
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    PriorityBandedConnectionPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    PriorityBandedConnectionPolicy_var (const TAO_Base_var &rhs);
    PriorityBandedConnectionPolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_PRIORITYBANDEDCONNECTIONPOLICY___OUT_CH_)
#define _RTCORBA_PRIORITYBANDEDCONNECTIONPOLICY___OUT_CH_

  class TAO_RTCORBA_Export PriorityBandedConnectionPolicy_out
  {
  public:
    PriorityBandedConnectionPolicy_out (PriorityBandedConnectionPolicy_ptr &);
    PriorityBandedConnectionPolicy_out (PriorityBandedConnectionPolicy_var &);
    PriorityBandedConnectionPolicy_out (const PriorityBandedConnectionPolicy_out &);
    PriorityBandedConnectionPolicy_out &operator= (const PriorityBandedConnectionPolicy_out &);
    PriorityBandedConnectionPolicy_out &operator= (const PriorityBandedConnectionPolicy_var &);
    PriorityBandedConnectionPolicy_out &operator= (PriorityBandedConnectionPolicy_ptr);
    operator PriorityBandedConnectionPolicy_ptr &();
    PriorityBandedConnectionPolicy_ptr &ptr (void);
    PriorityBandedConnectionPolicy_ptr operator-> (void);

  private:
    PriorityBandedConnectionPolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_PRIORITYBANDEDCONNECTIONPOLICY_CH_)
#define _RTCORBA_PRIORITYBANDEDCONNECTIONPOLICY_CH_

  class TAO_RTCORBA_Export PriorityBandedConnectionPolicy
    : public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef PriorityBandedConnectionPolicy_ptr _ptr_type;
    typedef PriorityBandedConnectionPolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

    // the static operations
    static PriorityBandedConnectionPolicy_ptr _duplicate (PriorityBandedConnectionPolicy_ptr obj);

    static PriorityBandedConnectionPolicy_ptr _narrow (
        CORBA::Object_ptr obj
        TAO_ENV_ARG_DECL_WITH_DEFAULTS);


    static PriorityBandedConnectionPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        TAO_ENV_ARG_DECL_WITH_DEFAULTS);


    static PriorityBandedConnectionPolicy_ptr _nil (void)
      {
        return (PriorityBandedConnectionPolicy_ptr)0;
      }

    virtual RTCORBA::PriorityBands * priority_bands (
        TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    PriorityBandedConnectionPolicy ();

    virtual ~PriorityBandedConnectionPolicy (void);

  private:
    PriorityBandedConnectionPolicy (const PriorityBandedConnectionPolicy &);
    void operator= (const PriorityBandedConnectionPolicy &);
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_CURRENT___PTR_CH_)
#define _RTCORBA_CURRENT___PTR_CH_

  class Current;
  typedef Current *Current_ptr;

#endif /* end #if !defined */


#if !defined (_RTCORBA_CURRENT___VAR_CH_)
#define _RTCORBA_CURRENT___VAR_CH_

  class TAO_RTCORBA_Export Current_var : public TAO_Base_var
  {
  public:
    Current_var (void); // default constructor
    Current_var (Current_ptr p) : ptr_ (p) {}
    Current_var (const Current_var &); // copy constructor
    ~Current_var (void); // destructor

    Current_var &operator= (Current_ptr);
    Current_var &operator= (const Current_var &);
    Current_ptr operator-> (void) const;

    operator const Current_ptr &() const;
    operator Current_ptr &();
    // in, inout, out, _retn
    Current_ptr in (void) const;
    Current_ptr &inout (void);
    Current_ptr &out (void);
    Current_ptr _retn (void);
    Current_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static Current_ptr tao_duplicate (Current_ptr);
    static void tao_release (Current_ptr);
    static Current_ptr tao_nil (void);
    static Current_ptr tao_narrow (
        CORBA::Object *
        TAO_ENV_ARG_DECL_NOT_USED
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    Current_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    Current_var (const TAO_Base_var &rhs);
    Current_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_CURRENT___OUT_CH_)
#define _RTCORBA_CURRENT___OUT_CH_

  class TAO_RTCORBA_Export Current_out
  {
  public:
    Current_out (Current_ptr &);
    Current_out (Current_var &);
    Current_out (const Current_out &);
    Current_out &operator= (const Current_out &);
    Current_out &operator= (const Current_var &);
    Current_out &operator= (Current_ptr);
    operator Current_ptr &();
    Current_ptr &ptr (void);
    Current_ptr operator-> (void);

  private:
    Current_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_CURRENT_CH_)
#define _RTCORBA_CURRENT_CH_

  class TAO_RTCORBA_Export Current
    : public virtual CORBA::Current
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef Current_ptr _ptr_type;
    typedef Current_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

    // the static operations
    static Current_ptr _duplicate (Current_ptr obj);

    static Current_ptr _narrow (
        CORBA::Object_ptr obj
        TAO_ENV_ARG_DECL_WITH_DEFAULTS);


    static Current_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        TAO_ENV_ARG_DECL_WITH_DEFAULTS);


    static Current_ptr _nil (void)
      {
        return (Current_ptr)0;
      }

    virtual RTCORBA::Priority the_priority (
        TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void the_priority (
        RTCORBA::Priority the_priority
        TAO_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    Current ();

    virtual ~Current (void);

  private:
    Current (const Current &);
    void operator= (const Current &);
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_MUTEX___PTR_CH_)
#define _RTCORBA_MUTEX___PTR_CH_

  class Mutex;
  typedef Mutex *Mutex_ptr;

#endif /* end #if !defined */


#if !defined (_RTCORBA_MUTEX___VAR_CH_)
#define _RTCORBA_MUTEX___VAR_CH_

  class TAO_RTCORBA_Export Mutex_var : public TAO_Base_var
  {
  public:
    Mutex_var (void); // default constructor
    Mutex_var (Mutex_ptr p) : ptr_ (p) {}
    Mutex_var (const Mutex_var &); // copy constructor
    ~Mutex_var (void); // destructor

    Mutex_var &operator= (Mutex_ptr);
    Mutex_var &operator= (const Mutex_var &);
    Mutex_ptr operator-> (void) const;

    operator const Mutex_ptr &() const;
    operator Mutex_ptr &();
    // in, inout, out, _retn
    Mutex_ptr in (void) const;
    Mutex_ptr &inout (void);
    Mutex_ptr &out (void);
    Mutex_ptr _retn (void);
    Mutex_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static Mutex_ptr tao_duplicate (Mutex_ptr);
    static void tao_release (Mutex_ptr);
    static Mutex_ptr tao_nil (void);
    static Mutex_ptr tao_narrow (
        CORBA::Object *
        TAO_ENV_ARG_DECL_NOT_USED
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    Mutex_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    Mutex_var (const TAO_Base_var &rhs);
    Mutex_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_MUTEX___OUT_CH_)
#define _RTCORBA_MUTEX___OUT_CH_

  class TAO_RTCORBA_Export Mutex_out
  {
  public:
    Mutex_out (Mutex_ptr &);
    Mutex_out (Mutex_var &);
    Mutex_out (const Mutex_out &);
    Mutex_out &operator= (const Mutex_out &);
    Mutex_out &operator= (const Mutex_var &);
    Mutex_out &operator= (Mutex_ptr);
    operator Mutex_ptr &();
    Mutex_ptr &ptr (void);
    Mutex_ptr operator-> (void);

  private:
    Mutex_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_MUTEX_CH_)
#define _RTCORBA_MUTEX_CH_

  class TAO_RTCORBA_Export Mutex
    : public virtual CORBA_Object
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef Mutex_ptr _ptr_type;
    typedef Mutex_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

    // the static operations
    static Mutex_ptr _duplicate (Mutex_ptr obj);

    static Mutex_ptr _narrow (
        CORBA::Object_ptr obj
        TAO_ENV_ARG_DECL_WITH_DEFAULTS);


    static Mutex_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        TAO_ENV_ARG_DECL_WITH_DEFAULTS);


    static Mutex_ptr _nil (void)
      {
        return (Mutex_ptr)0;
      }

    virtual void lock (
        TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void unlock (
        TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual CORBA::Boolean try_lock (
        TimeBase::TimeT max_wait
        TAO_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    Mutex ();

    virtual ~Mutex (void);

  private:
    Mutex (const Mutex &);
    void operator= (const Mutex &);
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_RTORB___PTR_CH_)
#define _RTCORBA_RTORB___PTR_CH_

  class RTORB;
  typedef RTORB *RTORB_ptr;

#endif /* end #if !defined */


#if !defined (_RTCORBA_RTORB___VAR_CH_)
#define _RTCORBA_RTORB___VAR_CH_

  class TAO_RTCORBA_Export RTORB_var : public TAO_Base_var
  {
  public:
    RTORB_var (void); // default constructor
    RTORB_var (RTORB_ptr p) : ptr_ (p) {}
    RTORB_var (const RTORB_var &); // copy constructor
    ~RTORB_var (void); // destructor

    RTORB_var &operator= (RTORB_ptr);
    RTORB_var &operator= (const RTORB_var &);
    RTORB_ptr operator-> (void) const;

    operator const RTORB_ptr &() const;
    operator RTORB_ptr &();
    // in, inout, out, _retn
    RTORB_ptr in (void) const;
    RTORB_ptr &inout (void);
    RTORB_ptr &out (void);
    RTORB_ptr _retn (void);
    RTORB_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static RTORB_ptr tao_duplicate (RTORB_ptr);
    static void tao_release (RTORB_ptr);
    static RTORB_ptr tao_nil (void);
    static RTORB_ptr tao_narrow (
        CORBA::Object *
        TAO_ENV_ARG_DECL_NOT_USED
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    RTORB_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    RTORB_var (const TAO_Base_var &rhs);
    RTORB_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_RTORB___OUT_CH_)
#define _RTCORBA_RTORB___OUT_CH_

  class TAO_RTCORBA_Export RTORB_out
  {
  public:
    RTORB_out (RTORB_ptr &);
    RTORB_out (RTORB_var &);
    RTORB_out (const RTORB_out &);
    RTORB_out &operator= (const RTORB_out &);
    RTORB_out &operator= (const RTORB_var &);
    RTORB_out &operator= (RTORB_ptr);
    operator RTORB_ptr &();
    RTORB_ptr &ptr (void);
    RTORB_ptr operator-> (void);

  private:
    RTORB_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_RTCORBA_RTORB_CH_)
#define _RTCORBA_RTORB_CH_

  class TAO_RTCORBA_Export RTORB
    : public virtual CORBA_Object
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef RTORB_ptr _ptr_type;
    typedef RTORB_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

    // the static operations
    static RTORB_ptr _duplicate (RTORB_ptr obj);

    static RTORB_ptr _narrow (
        CORBA::Object_ptr obj
        TAO_ENV_ARG_DECL_WITH_DEFAULTS);


    static RTORB_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        TAO_ENV_ARG_DECL_WITH_DEFAULTS);


    static RTORB_ptr _nil (void)
      {
        return (RTORB_ptr)0;
      }

    virtual RTCORBA::Mutex_ptr create_mutex (
        TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void destroy_mutex (
        RTCORBA::Mutex_ptr the_mutex
        TAO_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;


#if !defined (_RTCORBA_RTORB_MUTEXNOTFOUND_CH_)
#define _RTCORBA_RTORB_MUTEXNOTFOUND_CH_

    class TAO_RTCORBA_Export MutexNotFound : public CORBA::UserException
    {
    public:

      MutexNotFound (void);
      // Default constructor.

      MutexNotFound (const MutexNotFound &);
      // Copy constructor.

      ~MutexNotFound (void);
      // Destructor.

      MutexNotFound &operator= (const MutexNotFound &);

      virtual void _raise (void);

      virtual void _tao_encode (
          TAO_OutputCDR &
          TAO_ENV_ARG_DECL_NOT_USED
        ) const;

      virtual void _tao_decode (
          TAO_InputCDR &
          TAO_ENV_ARG_DECL_NOT_USED
        );

      static MutexNotFound *_downcast (CORBA::Exception *);


      // = TAO extension.
      static CORBA::Exception *_alloc (void);
    }; // Exception RTCORBA::RTORB::MutexNotFound.


#endif /* end #if !defined */

    virtual RTCORBA::Mutex_ptr create_named_mutex (
        const char * name,
        CORBA::Boolean_out created_flag
        TAO_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual RTCORBA::Mutex_ptr open_named_mutex (
        const char * name
        TAO_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException,
        RTCORBA::RTORB::MutexNotFound
      )) = 0;

    virtual RTCORBA::TCPProtocolProperties_ptr create_tcp_protocol_properties (
        CORBA::Long send_buffer_size,
        CORBA::Long recv_buffer_size,
        CORBA::Boolean keep_alive,
        CORBA::Boolean dont_route,
        CORBA::Boolean no_delay
        TAO_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;


#if !defined (_RTCORBA_RTORB_INVALIDTHREADPOOL_CH_)
#define _RTCORBA_RTORB_INVALIDTHREADPOOL_CH_

    class TAO_RTCORBA_Export InvalidThreadpool : public CORBA::UserException
    {
    public:

      InvalidThreadpool (void);
      // Default constructor.

      InvalidThreadpool (const InvalidThreadpool &);
      // Copy constructor.

      ~InvalidThreadpool (void);
      // Destructor.

      InvalidThreadpool &operator= (const InvalidThreadpool &);

      virtual void _raise (void);

      virtual void _tao_encode (
          TAO_OutputCDR &
          TAO_ENV_ARG_DECL_NOT_USED
        ) const;

      virtual void _tao_decode (
          TAO_InputCDR &
          TAO_ENV_ARG_DECL_NOT_USED
        );

      static InvalidThreadpool *_narrow (CORBA::Exception *);


      // = TAO extension.
      static CORBA::Exception *_alloc (void);
    }; // Exception RTCORBA::RTORB::InvalidThreadpool.


#endif /* end #if !defined */

    virtual RTCORBA::ThreadpoolId create_threadpool (
        CORBA::ULong stacksize,
        CORBA::ULong static_threads,
        CORBA::ULong dynamic_threads,
        RTCORBA::Priority default_priority,
        CORBA::Boolean allow_request_buffering,
        CORBA::ULong max_buffered_requests,
        CORBA::ULong max_request_buffer_size
        TAO_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual RTCORBA::ThreadpoolId create_threadpool_with_lanes (
        CORBA::ULong stacksize,
        const RTCORBA::ThreadpoolLanes & lanes,
        CORBA::Boolean allow_borrowing,
        CORBA::Boolean allow_request_buffering,
        CORBA::ULong max_buffered_requests,
        CORBA::ULong max_request_buffer_size
        TAO_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void destroy_threadpool (
        RTCORBA::ThreadpoolId threadpool
        TAO_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException,
        RTCORBA::RTORB::InvalidThreadpool
      )) = 0;

    virtual RTCORBA::PriorityModelPolicy_ptr create_priority_model_policy (
        RTCORBA::PriorityModel priority_model,
        RTCORBA::Priority server_priority
        TAO_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual RTCORBA::ThreadpoolPolicy_ptr create_threadpool_policy (
        RTCORBA::ThreadpoolId threadpool
        TAO_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual RTCORBA::PriorityBandedConnectionPolicy_ptr create_priority_banded_connection_policy (
        const RTCORBA::PriorityBands & priority_bands
        TAO_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual RTCORBA::ServerProtocolPolicy_ptr create_server_protocol_policy (
        const RTCORBA::ProtocolList & protocols
        TAO_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual RTCORBA::ClientProtocolPolicy_ptr create_client_protocol_policy (
        const RTCORBA::ProtocolList & protocols
        TAO_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual RTCORBA::PrivateConnectionPolicy_ptr create_private_connection_policy (
        TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    RTORB ();

    virtual ~RTORB (void);

  private:
    RTORB (const RTORB &);
    void operator= (const RTORB &);
  };


#endif /* end #if !defined */


}
TAO_NAMESPACE_CLOSE // module RTCORBA

TAO_RTCORBA_Export void operator<<= (CORBA::Any &, const RTCORBA::ThreadpoolLane &); // copying version
TAO_RTCORBA_Export void operator<<= (CORBA::Any &, RTCORBA::ThreadpoolLane*); // noncopying version
TAO_RTCORBA_Export CORBA::Boolean operator>>= (const CORBA::Any &, RTCORBA::ThreadpoolLane *&); // deprecated
TAO_RTCORBA_Export CORBA::Boolean operator>>= (const CORBA::Any &, const RTCORBA::ThreadpoolLane *&);
TAO_RTCORBA_Export void operator<<= (CORBA::Any &, const RTCORBA::ThreadpoolLanes &); // copying version
TAO_RTCORBA_Export void operator<<= (CORBA::Any &, RTCORBA::ThreadpoolLanes*); // noncopying version
TAO_RTCORBA_Export CORBA::Boolean operator>>= (const CORBA::Any &, RTCORBA::ThreadpoolLanes *&); // deprecated
TAO_RTCORBA_Export CORBA::Boolean operator>>= (const CORBA::Any &, const RTCORBA::ThreadpoolLanes *&);
TAO_RTCORBA_Export void operator<<= (CORBA::Any &, RTCORBA::PriorityModel);
TAO_RTCORBA_Export CORBA::Boolean operator>>= (const CORBA::Any &, RTCORBA::PriorityModel &);
TAO_RTCORBA_Export void operator<<= (CORBA::Any &, const RTCORBA::PriorityBand &); // copying version
TAO_RTCORBA_Export void operator<<= (CORBA::Any &, RTCORBA::PriorityBand*); // noncopying version
TAO_RTCORBA_Export CORBA::Boolean operator>>= (const CORBA::Any &, RTCORBA::PriorityBand *&); // deprecated
TAO_RTCORBA_Export CORBA::Boolean operator>>= (const CORBA::Any &, const RTCORBA::PriorityBand *&);
TAO_RTCORBA_Export void operator<<= (CORBA::Any &, const RTCORBA::PriorityBands &); // copying version
TAO_RTCORBA_Export void operator<<= (CORBA::Any &, RTCORBA::PriorityBands*); // noncopying version
TAO_RTCORBA_Export CORBA::Boolean operator>>= (const CORBA::Any &, RTCORBA::PriorityBands *&); // deprecated
TAO_RTCORBA_Export CORBA::Boolean operator>>= (const CORBA::Any &, const RTCORBA::PriorityBands *&);

#ifndef __ACE_INLINE__

TAO_RTCORBA_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const RTCORBA::ThreadpoolLane &);
TAO_RTCORBA_Export CORBA::Boolean operator>> (TAO_InputCDR &, RTCORBA::ThreadpoolLane &);

#if !defined _TAO_CDR_OP_RTCORBA_ThreadpoolLanes_H_
#define _TAO_CDR_OP_RTCORBA_ThreadpoolLanes_H_

TAO_RTCORBA_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const RTCORBA::ThreadpoolLanes &
  );
TAO_RTCORBA_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    RTCORBA::ThreadpoolLanes &
  );

#endif /* _TAO_CDR_OP_RTCORBA_ThreadpoolLanes_H_ */

TAO_RTCORBA_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const RTCORBA::PriorityModel &); //
TAO_RTCORBA_Export CORBA::Boolean operator>> (TAO_InputCDR &, RTCORBA::PriorityModel &);
TAO_RTCORBA_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const RTCORBA::PriorityBand &);
TAO_RTCORBA_Export CORBA::Boolean operator>> (TAO_InputCDR &, RTCORBA::PriorityBand &);

#if !defined _TAO_CDR_OP_RTCORBA_PriorityBands_H_
#define _TAO_CDR_OP_RTCORBA_PriorityBands_H_

TAO_RTCORBA_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const RTCORBA::PriorityBands &
  );
TAO_RTCORBA_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    RTCORBA::PriorityBands &
  );

#endif /* _TAO_CDR_OP_RTCORBA_PriorityBands_H_ */


#endif /* __ACE_INLINE__ */


#if defined (__ACE_INLINE__)
#include "RTCORBAC.i"
#endif /* defined INLINE */

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(pop)
#endif /* _MSC_VER */

#if defined (__BORLANDC__)
#pragma option pop
#endif /* __BORLANDC__ */

#include "ace/post.h"
#endif /* ifndef */
