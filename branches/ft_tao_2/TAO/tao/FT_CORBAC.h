/* -*- C++ -*- $Id$ */

// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO and the TAO IDL Compiler have been developed by the Center for
// Distributed Object Computing at Washington University, St. Louis.
//
// Information about TAO is available at:
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

#ifndef _TAO_IDL_FT_CORBAC_H_
#define _TAO_IDL_FT_CORBAC_H_

#include "tao/TimeBaseC.h"

#if defined (ACE_HAS_MINIMUM_IOSTREAMH_INCLUSION)
#include "ace/streams.h"
#endif /* ACE_HAS_MINIMUM_IOSTREAMH_INCLUSION */

#if !defined (ACE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */

//#include "tao/IOPC.h"
#include "tao/PolicyC.h"
#include "tao/GIOPC.h"

#if defined (TAO_EXPORT_MACRO)
#undef TAO_EXPORT_MACRO
#endif
#define TAO_EXPORT_MACRO TAO_Export

#if defined (TAO_EXPORT_NESTED_CLASSES)
#  if defined (TAO_EXPORT_NESTED_MACRO)
#    undef TAO_EXPORT_NESTED_MACRO
#  endif /* defined (TAO_EXPORT_NESTED_MACRO) */
#  define TAO_EXPORT_NESTED_MACRO TAO_Export
#endif /* TAO_EXPORT_NESTED_CLASSES */

#if defined(_MSC_VER)
#if (_MSC_VER >= 1200)
#pragma warning(push)
#endif /* _MSC_VER >= 1200 */
#pragma warning(disable:4250)
#endif /* _MSC_VER */

TAO_NAMESPACE  FT
{
  typedef char * FTDomainId;
  typedef CORBA::String_var FTDomainId_var;
  typedef CORBA::String_out FTDomainId_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_FTDomainId;

  typedef CORBA::ULongLong ObjectGroupId;
  typedef CORBA::ULongLong_out ObjectGroupId_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ObjectGroupId;

  typedef CORBA::ULong ObjectGroupRefVersion;
  typedef CORBA::ULong_out ObjectGroupRefVersion_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ObjectGroupRefVersion;

  struct TagFTGroupTaggedComponent;
  class TagFTGroupTaggedComponent_var;

  struct TAO_Export TagFTGroupTaggedComponent
  {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef TagFTGroupTaggedComponent_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

    static void _tao_any_destructor (void*);

    GIOP::Version version;
    TAO_String_Manager ft_domain_id;
    ACE_NESTED_CLASS (FT, ObjectGroupId) object_group_id;
    ACE_NESTED_CLASS (FT, ObjectGroupRefVersion) object_group_ref_version;
  };

  class TAO_Export TagFTGroupTaggedComponent_var
  {
  public:
    TagFTGroupTaggedComponent_var (void); // default constructor
    TagFTGroupTaggedComponent_var (TagFTGroupTaggedComponent *);
    TagFTGroupTaggedComponent_var (const TagFTGroupTaggedComponent_var &); // copy constructor
    ~TagFTGroupTaggedComponent_var (void); // destructor

    TagFTGroupTaggedComponent_var &operator= (TagFTGroupTaggedComponent *);
    TagFTGroupTaggedComponent_var &operator= (const TagFTGroupTaggedComponent_var &);
    TagFTGroupTaggedComponent *operator-> (void);
    const TagFTGroupTaggedComponent *operator-> (void) const;

    operator const TagFTGroupTaggedComponent &() const;
    operator TagFTGroupTaggedComponent &();
    operator TagFTGroupTaggedComponent &() const;
    operator TagFTGroupTaggedComponent *&(); // variable-size types only

    // in, inout, out, _retn
    const TagFTGroupTaggedComponent &in (void) const;
    TagFTGroupTaggedComponent &inout (void);
    TagFTGroupTaggedComponent *&out (void);
    TagFTGroupTaggedComponent *_retn (void);
    TagFTGroupTaggedComponent *ptr (void) const;

  private:
    TagFTGroupTaggedComponent *ptr_;
  };

  class TAO_Export TagFTGroupTaggedComponent_out
  {
  public:
    TagFTGroupTaggedComponent_out (TagFTGroupTaggedComponent *&);
    TagFTGroupTaggedComponent_out (TagFTGroupTaggedComponent_var &);
    TagFTGroupTaggedComponent_out (const TagFTGroupTaggedComponent_out &);
    TagFTGroupTaggedComponent_out &operator= (const TagFTGroupTaggedComponent_out &);
    TagFTGroupTaggedComponent_out &operator= (TagFTGroupTaggedComponent *);
    operator TagFTGroupTaggedComponent *&();
    TagFTGroupTaggedComponent *&ptr (void);
    TagFTGroupTaggedComponent *operator-> (void);

  private:
    TagFTGroupTaggedComponent *&ptr_;
    // assignment from T_var not allowed
    void operator= (const TagFTGroupTaggedComponent_var &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_TagFTGroupTaggedComponent;

  struct TagFTPrimaryTaggedComponent;
  class TagFTPrimaryTaggedComponent_var;

  struct TAO_Export TagFTPrimaryTaggedComponent
  {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef TagFTPrimaryTaggedComponent_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

    static void _tao_any_destructor (void*);

    CORBA::Boolean primary;
  };

  class TAO_Export TagFTPrimaryTaggedComponent_var
  {
  public:
    TagFTPrimaryTaggedComponent_var (void); // default constructor
    TagFTPrimaryTaggedComponent_var (TagFTPrimaryTaggedComponent *);
    TagFTPrimaryTaggedComponent_var (const TagFTPrimaryTaggedComponent_var &); // copy constructor
    TagFTPrimaryTaggedComponent_var (const TagFTPrimaryTaggedComponent &); // fixed-size types only
    ~TagFTPrimaryTaggedComponent_var (void); // destructor

    TagFTPrimaryTaggedComponent_var &operator= (TagFTPrimaryTaggedComponent *);
    TagFTPrimaryTaggedComponent_var &operator= (const TagFTPrimaryTaggedComponent_var &);
    TagFTPrimaryTaggedComponent_var &operator= (const TagFTPrimaryTaggedComponent &); // fixed-size types only
    TagFTPrimaryTaggedComponent *operator-> (void);
    const TagFTPrimaryTaggedComponent *operator-> (void) const;

    operator const TagFTPrimaryTaggedComponent &() const;
    operator TagFTPrimaryTaggedComponent &();
    operator TagFTPrimaryTaggedComponent &() const;

    // in, inout, out, _retn
    const TagFTPrimaryTaggedComponent &in (void) const;
    TagFTPrimaryTaggedComponent &inout (void);
    TagFTPrimaryTaggedComponent &out (void);
    TagFTPrimaryTaggedComponent _retn (void);
    TagFTPrimaryTaggedComponent *ptr (void) const;

  private:
    TagFTPrimaryTaggedComponent *ptr_;
  };

  typedef TagFTPrimaryTaggedComponent &TagFTPrimaryTaggedComponent_out;

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_TagFTPrimaryTaggedComponent;

  struct FTGroupVersionServiceContext;
  class FTGroupVersionServiceContext_var;

  struct TAO_Export FTGroupVersionServiceContext
  {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef FTGroupVersionServiceContext_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

    static void _tao_any_destructor (void*);

    ACE_NESTED_CLASS (FT, ObjectGroupRefVersion) object_group_ref_version;
  };

  class TAO_Export FTGroupVersionServiceContext_var
  {
  public:
    FTGroupVersionServiceContext_var (void); // default constructor
    FTGroupVersionServiceContext_var (FTGroupVersionServiceContext *);
    FTGroupVersionServiceContext_var (const FTGroupVersionServiceContext_var &); // copy constructor
    FTGroupVersionServiceContext_var (const FTGroupVersionServiceContext &); // fixed-size types only
    ~FTGroupVersionServiceContext_var (void); // destructor

    FTGroupVersionServiceContext_var &operator= (FTGroupVersionServiceContext *);
    FTGroupVersionServiceContext_var &operator= (const FTGroupVersionServiceContext_var &);
    FTGroupVersionServiceContext_var &operator= (const FTGroupVersionServiceContext &); // fixed-size types only
    FTGroupVersionServiceContext *operator-> (void);
    const FTGroupVersionServiceContext *operator-> (void) const;

    operator const FTGroupVersionServiceContext &() const;
    operator FTGroupVersionServiceContext &();
    operator FTGroupVersionServiceContext &() const;

    // in, inout, out, _retn
    const FTGroupVersionServiceContext &in (void) const;
    FTGroupVersionServiceContext &inout (void);
    FTGroupVersionServiceContext &out (void);
    FTGroupVersionServiceContext _retn (void);
    FTGroupVersionServiceContext *ptr (void) const;

  private:
    FTGroupVersionServiceContext *ptr_;
  };

  typedef FTGroupVersionServiceContext &FTGroupVersionServiceContext_out;

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_FTGroupVersionServiceContext;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong REQUEST_DURATION_POLICY;

  struct FTRequestServiceContext;
  class FTRequestServiceContext_var;

  struct TAO_Export FTRequestServiceContext
  {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef FTRequestServiceContext_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

    static void _tao_any_destructor (void*);

    TAO_String_Manager client_id;
    CORBA::Long retention_id;
    TimeBase::TimeT expiration_time;
  };

  class TAO_Export FTRequestServiceContext_var
  {
  public:
    FTRequestServiceContext_var (void); // default constructor
    FTRequestServiceContext_var (FTRequestServiceContext *);
    FTRequestServiceContext_var (const FTRequestServiceContext_var &); // copy constructor
    ~FTRequestServiceContext_var (void); // destructor

    FTRequestServiceContext_var &operator= (FTRequestServiceContext *);
    FTRequestServiceContext_var &operator= (const FTRequestServiceContext_var &);
    FTRequestServiceContext *operator-> (void);
    const FTRequestServiceContext *operator-> (void) const;

    operator const FTRequestServiceContext &() const;
    operator FTRequestServiceContext &();
    operator FTRequestServiceContext &() const;
    operator FTRequestServiceContext *&(); // variable-size types only

    // in, inout, out, _retn
    const FTRequestServiceContext &in (void) const;
    FTRequestServiceContext &inout (void);
    FTRequestServiceContext *&out (void);
    FTRequestServiceContext *_retn (void);
    FTRequestServiceContext *ptr (void) const;

  private:
    FTRequestServiceContext *ptr_;
  };

  class TAO_Export FTRequestServiceContext_out
  {
  public:
    FTRequestServiceContext_out (FTRequestServiceContext *&);
    FTRequestServiceContext_out (FTRequestServiceContext_var &);
    FTRequestServiceContext_out (const FTRequestServiceContext_out &);
    FTRequestServiceContext_out &operator= (const FTRequestServiceContext_out &);
    FTRequestServiceContext_out &operator= (FTRequestServiceContext *);
    operator FTRequestServiceContext *&();
    FTRequestServiceContext *&ptr (void);
    FTRequestServiceContext *operator-> (void);

  private:
    FTRequestServiceContext *&ptr_;
    // assignment from T_var not allowed
    void operator= (const FTRequestServiceContext_var &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_FTRequestServiceContext;


#if !defined (_FT_REQUESTDURATIONPOLICY___PTR_CH_)
#define _FT_REQUESTDURATIONPOLICY___PTR_CH_

  class RequestDurationPolicy;
  typedef RequestDurationPolicy *RequestDurationPolicy_ptr;

#endif /* end #if !defined */


#if !defined (_FT_REQUESTDURATIONPOLICY___VAR_CH_)
#define _FT_REQUESTDURATIONPOLICY___VAR_CH_

  class TAO_Export RequestDurationPolicy_var : public TAO_Base_var
  {
  public:
    RequestDurationPolicy_var (void); // default constructor
    RequestDurationPolicy_var (RequestDurationPolicy_ptr);
    RequestDurationPolicy_var (const RequestDurationPolicy_var &); // copy constructor
    ~RequestDurationPolicy_var (void); // destructor

    RequestDurationPolicy_var &operator= (RequestDurationPolicy_ptr);
    RequestDurationPolicy_var &operator= (const RequestDurationPolicy_var &);
    RequestDurationPolicy_ptr operator-> (void) const;

    operator const RequestDurationPolicy_ptr &() const;
    operator RequestDurationPolicy_ptr &();
    // in, inout, out, _retn
    RequestDurationPolicy_ptr in (void) const;
    RequestDurationPolicy_ptr &inout (void);
    RequestDurationPolicy_ptr &out (void);
    RequestDurationPolicy_ptr _retn (void);
    RequestDurationPolicy_ptr ptr (void) const;

  private:
    RequestDurationPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    RequestDurationPolicy_var (const TAO_Base_var &rhs);
    RequestDurationPolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_FT_REQUESTDURATIONPOLICY___OUT_CH_)
#define _FT_REQUESTDURATIONPOLICY___OUT_CH_

  class TAO_Export RequestDurationPolicy_out
  {
  public:
    RequestDurationPolicy_out (RequestDurationPolicy_ptr &);
    RequestDurationPolicy_out (RequestDurationPolicy_var &);
    RequestDurationPolicy_out (const RequestDurationPolicy_out &);
    RequestDurationPolicy_out &operator= (const RequestDurationPolicy_out &);
    RequestDurationPolicy_out &operator= (const RequestDurationPolicy_var &);
    RequestDurationPolicy_out &operator= (RequestDurationPolicy_ptr);
    operator RequestDurationPolicy_ptr &();
    RequestDurationPolicy_ptr &ptr (void);
    RequestDurationPolicy_ptr operator-> (void);

  private:
    RequestDurationPolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_FT_REQUESTDURATIONPOLICY_CH_)
#define _FT_REQUESTDURATIONPOLICY_CH_

class TAO_Export RequestDurationPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef RequestDurationPolicy_ptr _ptr_type;
    typedef RequestDurationPolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

    // the static operations
    static RequestDurationPolicy_ptr _duplicate (RequestDurationPolicy_ptr obj);
    static RequestDurationPolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static RequestDurationPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static RequestDurationPolicy_ptr _nil (void)
      {
        return (RequestDurationPolicy_ptr)0;
      }

    static void _tao_any_destructor (void*);

    virtual TimeBase::TimeT request_duration_value (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    RequestDurationPolicy (void);
    RequestDurationPolicy (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~RequestDurationPolicy (void);
  private:
    RequestDurationPolicy (const RequestDurationPolicy &);
    void operator= (const RequestDurationPolicy &);
  };


#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_RequestDurationPolicy;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong HEARTBEAT_POLICY;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong HEARTBEAT_ENABLED_POLICY;

  struct TagFTHeartbeatEnabledTaggedComponent;
  class TagFTHeartbeatEnabledTaggedComponent_var;

  struct TAO_Export TagFTHeartbeatEnabledTaggedComponent
  {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef TagFTHeartbeatEnabledTaggedComponent_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

    static void _tao_any_destructor (void*);

    CORBA::Boolean heartbeat_enabled;
  };

  class TAO_Export TagFTHeartbeatEnabledTaggedComponent_var
  {
  public:
    TagFTHeartbeatEnabledTaggedComponent_var (void); // default constructor
    TagFTHeartbeatEnabledTaggedComponent_var (TagFTHeartbeatEnabledTaggedComponent *);
    TagFTHeartbeatEnabledTaggedComponent_var (const TagFTHeartbeatEnabledTaggedComponent_var &); // copy constructor
    TagFTHeartbeatEnabledTaggedComponent_var (const TagFTHeartbeatEnabledTaggedComponent &); // fixed-size types only
    ~TagFTHeartbeatEnabledTaggedComponent_var (void); // destructor

    TagFTHeartbeatEnabledTaggedComponent_var &operator= (TagFTHeartbeatEnabledTaggedComponent *);
    TagFTHeartbeatEnabledTaggedComponent_var &operator= (const TagFTHeartbeatEnabledTaggedComponent_var &);
    TagFTHeartbeatEnabledTaggedComponent_var &operator= (const TagFTHeartbeatEnabledTaggedComponent &); // fixed-size types only
    TagFTHeartbeatEnabledTaggedComponent *operator-> (void);
    const TagFTHeartbeatEnabledTaggedComponent *operator-> (void) const;

    operator const TagFTHeartbeatEnabledTaggedComponent &() const;
    operator TagFTHeartbeatEnabledTaggedComponent &();
    operator TagFTHeartbeatEnabledTaggedComponent &() const;

    // in, inout, out, _retn
    const TagFTHeartbeatEnabledTaggedComponent &in (void) const;
    TagFTHeartbeatEnabledTaggedComponent &inout (void);
    TagFTHeartbeatEnabledTaggedComponent &out (void);
    TagFTHeartbeatEnabledTaggedComponent _retn (void);
    TagFTHeartbeatEnabledTaggedComponent *ptr (void) const;

  private:
    TagFTHeartbeatEnabledTaggedComponent *ptr_;
  };

  typedef TagFTHeartbeatEnabledTaggedComponent &TagFTHeartbeatEnabledTaggedComponent_out;

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_TagFTHeartbeatEnabledTaggedComponent;

  struct HeartbeatPolicyValue;
  class HeartbeatPolicyValue_var;

  struct TAO_Export HeartbeatPolicyValue
  {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef HeartbeatPolicyValue_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

    static void _tao_any_destructor (void*);

    CORBA::Boolean heartbeat;
    TimeBase::TimeT heartbeat_interval;
    TimeBase::TimeT heartbeat_timeout;
  };

  class TAO_Export HeartbeatPolicyValue_var
  {
  public:
    HeartbeatPolicyValue_var (void); // default constructor
    HeartbeatPolicyValue_var (HeartbeatPolicyValue *);
    HeartbeatPolicyValue_var (const HeartbeatPolicyValue_var &); // copy constructor
    HeartbeatPolicyValue_var (const HeartbeatPolicyValue &); // fixed-size types only
    ~HeartbeatPolicyValue_var (void); // destructor

    HeartbeatPolicyValue_var &operator= (HeartbeatPolicyValue *);
    HeartbeatPolicyValue_var &operator= (const HeartbeatPolicyValue_var &);
    HeartbeatPolicyValue_var &operator= (const HeartbeatPolicyValue &); // fixed-size types only
    HeartbeatPolicyValue *operator-> (void);
    const HeartbeatPolicyValue *operator-> (void) const;

    operator const HeartbeatPolicyValue &() const;
    operator HeartbeatPolicyValue &();
    operator HeartbeatPolicyValue &() const;

    // in, inout, out, _retn
    const HeartbeatPolicyValue &in (void) const;
    HeartbeatPolicyValue &inout (void);
    HeartbeatPolicyValue &out (void);
    HeartbeatPolicyValue _retn (void);
    HeartbeatPolicyValue *ptr (void) const;

  private:
    HeartbeatPolicyValue *ptr_;
  };

  typedef HeartbeatPolicyValue &HeartbeatPolicyValue_out;

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_HeartbeatPolicyValue;


#if !defined (_FT_HEARTBEATPOLICY___PTR_CH_)
#define _FT_HEARTBEATPOLICY___PTR_CH_

  class HeartbeatPolicy;
  typedef HeartbeatPolicy *HeartbeatPolicy_ptr;

#endif /* end #if !defined */


#if !defined (_FT_HEARTBEATPOLICY___VAR_CH_)
#define _FT_HEARTBEATPOLICY___VAR_CH_

  class TAO_Export HeartbeatPolicy_var : public TAO_Base_var
  {
  public:
    HeartbeatPolicy_var (void); // default constructor
    HeartbeatPolicy_var (HeartbeatPolicy_ptr);
    HeartbeatPolicy_var (const HeartbeatPolicy_var &); // copy constructor
    ~HeartbeatPolicy_var (void); // destructor

    HeartbeatPolicy_var &operator= (HeartbeatPolicy_ptr);
    HeartbeatPolicy_var &operator= (const HeartbeatPolicy_var &);
    HeartbeatPolicy_ptr operator-> (void) const;

    operator const HeartbeatPolicy_ptr &() const;
    operator HeartbeatPolicy_ptr &();
    // in, inout, out, _retn
    HeartbeatPolicy_ptr in (void) const;
    HeartbeatPolicy_ptr &inout (void);
    HeartbeatPolicy_ptr &out (void);
    HeartbeatPolicy_ptr _retn (void);
    HeartbeatPolicy_ptr ptr (void) const;

  private:
    HeartbeatPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    HeartbeatPolicy_var (const TAO_Base_var &rhs);
    HeartbeatPolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_FT_HEARTBEATPOLICY___OUT_CH_)
#define _FT_HEARTBEATPOLICY___OUT_CH_

  class TAO_Export HeartbeatPolicy_out
  {
  public:
    HeartbeatPolicy_out (HeartbeatPolicy_ptr &);
    HeartbeatPolicy_out (HeartbeatPolicy_var &);
    HeartbeatPolicy_out (const HeartbeatPolicy_out &);
    HeartbeatPolicy_out &operator= (const HeartbeatPolicy_out &);
    HeartbeatPolicy_out &operator= (const HeartbeatPolicy_var &);
    HeartbeatPolicy_out &operator= (HeartbeatPolicy_ptr);
    operator HeartbeatPolicy_ptr &();
    HeartbeatPolicy_ptr &ptr (void);
    HeartbeatPolicy_ptr operator-> (void);

  private:
    HeartbeatPolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_FT_HEARTBEATPOLICY_CH_)
#define _FT_HEARTBEATPOLICY_CH_

class TAO_Export HeartbeatPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef HeartbeatPolicy_ptr _ptr_type;
    typedef HeartbeatPolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

    // the static operations
    static HeartbeatPolicy_ptr _duplicate (HeartbeatPolicy_ptr obj);
    static HeartbeatPolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static HeartbeatPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static HeartbeatPolicy_ptr _nil (void)
      {
        return (HeartbeatPolicy_ptr)0;
      }

    static void _tao_any_destructor (void*);

    virtual FT::HeartbeatPolicyValue heartbeat_policy_value (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    HeartbeatPolicy (void);
    HeartbeatPolicy (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~HeartbeatPolicy (void);
  private:
    HeartbeatPolicy (const HeartbeatPolicy &);
    void operator= (const HeartbeatPolicy &);
  };


#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_HeartbeatPolicy;


#if !defined (_FT_HEARTBEATENABLEDPOLICY___PTR_CH_)
#define _FT_HEARTBEATENABLEDPOLICY___PTR_CH_

  class HeartbeatEnabledPolicy;
  typedef HeartbeatEnabledPolicy *HeartbeatEnabledPolicy_ptr;

#endif /* end #if !defined */


#if !defined (_FT_HEARTBEATENABLEDPOLICY___VAR_CH_)
#define _FT_HEARTBEATENABLEDPOLICY___VAR_CH_

  class TAO_Export HeartbeatEnabledPolicy_var : public TAO_Base_var
  {
  public:
    HeartbeatEnabledPolicy_var (void); // default constructor
    HeartbeatEnabledPolicy_var (HeartbeatEnabledPolicy_ptr);
    HeartbeatEnabledPolicy_var (const HeartbeatEnabledPolicy_var &); // copy constructor
    ~HeartbeatEnabledPolicy_var (void); // destructor

    HeartbeatEnabledPolicy_var &operator= (HeartbeatEnabledPolicy_ptr);
    HeartbeatEnabledPolicy_var &operator= (const HeartbeatEnabledPolicy_var &);
    HeartbeatEnabledPolicy_ptr operator-> (void) const;

    operator const HeartbeatEnabledPolicy_ptr &() const;
    operator HeartbeatEnabledPolicy_ptr &();
    // in, inout, out, _retn
    HeartbeatEnabledPolicy_ptr in (void) const;
    HeartbeatEnabledPolicy_ptr &inout (void);
    HeartbeatEnabledPolicy_ptr &out (void);
    HeartbeatEnabledPolicy_ptr _retn (void);
    HeartbeatEnabledPolicy_ptr ptr (void) const;

  private:
    HeartbeatEnabledPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    HeartbeatEnabledPolicy_var (const TAO_Base_var &rhs);
    HeartbeatEnabledPolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_FT_HEARTBEATENABLEDPOLICY___OUT_CH_)
#define _FT_HEARTBEATENABLEDPOLICY___OUT_CH_

  class TAO_Export HeartbeatEnabledPolicy_out
  {
  public:
    HeartbeatEnabledPolicy_out (HeartbeatEnabledPolicy_ptr &);
    HeartbeatEnabledPolicy_out (HeartbeatEnabledPolicy_var &);
    HeartbeatEnabledPolicy_out (const HeartbeatEnabledPolicy_out &);
    HeartbeatEnabledPolicy_out &operator= (const HeartbeatEnabledPolicy_out &);
    HeartbeatEnabledPolicy_out &operator= (const HeartbeatEnabledPolicy_var &);
    HeartbeatEnabledPolicy_out &operator= (HeartbeatEnabledPolicy_ptr);
    operator HeartbeatEnabledPolicy_ptr &();
    HeartbeatEnabledPolicy_ptr &ptr (void);
    HeartbeatEnabledPolicy_ptr operator-> (void);

  private:
    HeartbeatEnabledPolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_FT_HEARTBEATENABLEDPOLICY_CH_)
#define _FT_HEARTBEATENABLEDPOLICY_CH_

class TAO_Export HeartbeatEnabledPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef HeartbeatEnabledPolicy_ptr _ptr_type;
    typedef HeartbeatEnabledPolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

    // the static operations
    static HeartbeatEnabledPolicy_ptr _duplicate (HeartbeatEnabledPolicy_ptr obj);
    static HeartbeatEnabledPolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static HeartbeatEnabledPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static HeartbeatEnabledPolicy_ptr _nil (void)
      {
        return (HeartbeatEnabledPolicy_ptr)0;
      }

    static void _tao_any_destructor (void*);

    virtual CORBA::Boolean heartbeat_enabled_policy_value (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    HeartbeatEnabledPolicy (void);
    HeartbeatEnabledPolicy (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~HeartbeatEnabledPolicy (void);
  private:
    HeartbeatEnabledPolicy (const HeartbeatEnabledPolicy &);
    void operator= (const HeartbeatEnabledPolicy &);
  };


#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_HeartbeatEnabledPolicy;

  class GenericFactory;

#if !defined (_FT_GENERICFACTORY___PTR_CH_)
#define _FT_GENERICFACTORY___PTR_CH_

typedef GenericFactory *GenericFactory_ptr;

#endif /* end #if !defined */


#if !defined (_FT_GENERICFACTORY___VAR_CH_)
#define _FT_GENERICFACTORY___VAR_CH_

  class TAO_Export GenericFactory_var : public TAO_Base_var
  {
  public:
    GenericFactory_var (void); // default constructor
    GenericFactory_var (GenericFactory_ptr);
    GenericFactory_var (const GenericFactory_var &); // copy constructor
    ~GenericFactory_var (void); // destructor

    GenericFactory_var &operator= (GenericFactory_ptr);
    GenericFactory_var &operator= (const GenericFactory_var &);
    GenericFactory_ptr operator-> (void) const;

    operator const GenericFactory_ptr &() const;
    operator GenericFactory_ptr &();
    // in, inout, out, _retn
    GenericFactory_ptr in (void) const;
    GenericFactory_ptr &inout (void);
    GenericFactory_ptr &out (void);
    GenericFactory_ptr _retn (void);
    GenericFactory_ptr ptr (void) const;

  private:
    GenericFactory_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    GenericFactory_var (const TAO_Base_var &rhs);
    GenericFactory_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_FT_GENERICFACTORY___OUT_CH_)
#define _FT_GENERICFACTORY___OUT_CH_

  class TAO_Export GenericFactory_out
  {
  public:
    GenericFactory_out (GenericFactory_ptr &);
    GenericFactory_out (GenericFactory_var &);
    GenericFactory_out (const GenericFactory_out &);
    GenericFactory_out &operator= (const GenericFactory_out &);
    GenericFactory_out &operator= (const GenericFactory_var &);
    GenericFactory_out &operator= (GenericFactory_ptr);
    operator GenericFactory_ptr &();
    GenericFactory_ptr &ptr (void);
    GenericFactory_ptr operator-> (void);

  private:
    GenericFactory_ptr &ptr_;
  };


#endif /* end #if !defined */

  class FaultNotifier;

#if !defined (_FT_FAULTNOTIFIER___PTR_CH_)
#define _FT_FAULTNOTIFIER___PTR_CH_

typedef FaultNotifier *FaultNotifier_ptr;

#endif /* end #if !defined */


#if !defined (_FT_FAULTNOTIFIER___VAR_CH_)
#define _FT_FAULTNOTIFIER___VAR_CH_

  class TAO_Export FaultNotifier_var : public TAO_Base_var
  {
  public:
    FaultNotifier_var (void); // default constructor
    FaultNotifier_var (FaultNotifier_ptr);
    FaultNotifier_var (const FaultNotifier_var &); // copy constructor
    ~FaultNotifier_var (void); // destructor

    FaultNotifier_var &operator= (FaultNotifier_ptr);
    FaultNotifier_var &operator= (const FaultNotifier_var &);
    FaultNotifier_ptr operator-> (void) const;

    operator const FaultNotifier_ptr &() const;
    operator FaultNotifier_ptr &();
    // in, inout, out, _retn
    FaultNotifier_ptr in (void) const;
    FaultNotifier_ptr &inout (void);
    FaultNotifier_ptr &out (void);
    FaultNotifier_ptr _retn (void);
    FaultNotifier_ptr ptr (void) const;

  private:
    FaultNotifier_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    FaultNotifier_var (const TAO_Base_var &rhs);
    FaultNotifier_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_FT_FAULTNOTIFIER___OUT_CH_)
#define _FT_FAULTNOTIFIER___OUT_CH_

  class TAO_Export FaultNotifier_out
  {
  public:
    FaultNotifier_out (FaultNotifier_ptr &);
    FaultNotifier_out (FaultNotifier_var &);
    FaultNotifier_out (const FaultNotifier_out &);
    FaultNotifier_out &operator= (const FaultNotifier_out &);
    FaultNotifier_out &operator= (const FaultNotifier_var &);
    FaultNotifier_out &operator= (FaultNotifier_ptr);
    operator FaultNotifier_ptr &();
    FaultNotifier_ptr &ptr (void);
    FaultNotifier_ptr operator-> (void);

  private:
    FaultNotifier_ptr &ptr_;
  };


#endif /* end #if !defined */

  typedef char * TypeId;
  typedef CORBA::String_var TypeId_var;
  typedef CORBA::String_out TypeId_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_TypeId;

  typedef CORBA::Object ObjectGroup;
  typedef CORBA::Object_ptr ObjectGroup_ptr;
  typedef CORBA::Object_var ObjectGroup_var;
  typedef CORBA::Object_out ObjectGroup_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ObjectGroup;

  typedef CORBA::Long ReplicationStyleValue;
  typedef CORBA::Long_out ReplicationStyleValue_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ReplicationStyleValue;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Long STATELESS;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Long COLD_PASSIVE;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Long WARM_PASSIVE;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Long ACTIVE;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Long ACTIVE_WITH_VOTING;

  typedef CORBA::Long MembershipStyleValue;
  typedef CORBA::Long_out MembershipStyleValue_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_MembershipStyleValue;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Long MEMB_APP_CTRL;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Long MEMB_INF_CTRL;

  typedef CORBA::Long ConsistencyStyleValue;
  typedef CORBA::Long_out ConsistencyStyleValue_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ConsistencyStyleValue;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Long CONS_APP_CTRL;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Long CONS_INF_CTRL;

  typedef CORBA::Long FaultMonitoringStyleValue;
  typedef CORBA::Long_out FaultMonitoringStyleValue_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_FaultMonitoringStyleValue;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Long PULL;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Long PUSH;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Long NOT_MONITORED;

  typedef CORBA::Long FaultMonitoringGranularityValue;
  typedef CORBA::Long_out FaultMonitoringGranularityValue_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_FaultMonitoringGranularityValue;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Long MEMB;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Long LOC;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Long LOC_AND_TYPE;

  typedef CORBA::UShort InitialNumberReplicasValue;
  typedef CORBA::UShort_out InitialNumberReplicasValue_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_InitialNumberReplicasValue;

  typedef CORBA::UShort MinimumNumberReplicasValue;
  typedef CORBA::UShort_out MinimumNumberReplicasValue_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_MinimumNumberReplicasValue;

  struct FaultMonitoringIntervalAndTimeoutValue;
  class FaultMonitoringIntervalAndTimeoutValue_var;

  struct TAO_Export FaultMonitoringIntervalAndTimeoutValue
  {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef FaultMonitoringIntervalAndTimeoutValue_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

    static void _tao_any_destructor (void*);

    TimeBase::TimeT monitoring_interval;
    TimeBase::TimeT timeout;
  };

  class TAO_Export FaultMonitoringIntervalAndTimeoutValue_var
  {
  public:
    FaultMonitoringIntervalAndTimeoutValue_var (void); // default constructor
    FaultMonitoringIntervalAndTimeoutValue_var (FaultMonitoringIntervalAndTimeoutValue *);
    FaultMonitoringIntervalAndTimeoutValue_var (const FaultMonitoringIntervalAndTimeoutValue_var &); // copy constructor
    FaultMonitoringIntervalAndTimeoutValue_var (const FaultMonitoringIntervalAndTimeoutValue &); // fixed-size types only
    ~FaultMonitoringIntervalAndTimeoutValue_var (void); // destructor

    FaultMonitoringIntervalAndTimeoutValue_var &operator= (FaultMonitoringIntervalAndTimeoutValue *);
    FaultMonitoringIntervalAndTimeoutValue_var &operator= (const FaultMonitoringIntervalAndTimeoutValue_var &);
    FaultMonitoringIntervalAndTimeoutValue_var &operator= (const FaultMonitoringIntervalAndTimeoutValue &); // fixed-size types only
    FaultMonitoringIntervalAndTimeoutValue *operator-> (void);
    const FaultMonitoringIntervalAndTimeoutValue *operator-> (void) const;

    operator const FaultMonitoringIntervalAndTimeoutValue &() const;
    operator FaultMonitoringIntervalAndTimeoutValue &();
    operator FaultMonitoringIntervalAndTimeoutValue &() const;

    // in, inout, out, _retn
    const FaultMonitoringIntervalAndTimeoutValue &in (void) const;
    FaultMonitoringIntervalAndTimeoutValue &inout (void);
    FaultMonitoringIntervalAndTimeoutValue &out (void);
    FaultMonitoringIntervalAndTimeoutValue _retn (void);
    FaultMonitoringIntervalAndTimeoutValue *ptr (void) const;

  private:
    FaultMonitoringIntervalAndTimeoutValue *ptr_;
  };

  typedef FaultMonitoringIntervalAndTimeoutValue &FaultMonitoringIntervalAndTimeoutValue_out;

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_FaultMonitoringIntervalAndTimeoutValue;

  typedef TimeBase::TimeT CheckpointIntervalValue;
  typedef TimeBase::TimeT_out CheckpointIntervalValue_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_CheckpointIntervalValue;


#if !defined (_FT_STATE_CH_)
#define _FT_STATE_CH_

  class State;
  class State_var;

  // *************************************************************
  // State
  // *************************************************************

  class TAO_Export State : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Sequence<CORBA::Octet>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    State (void); // default ctor
    State (CORBA::ULong max); // uses max size
    State (
      CORBA::ULong max,
      CORBA::ULong length,
      CORBA::Octet *buffer,
      CORBA::Boolean release=0
    );
    State (const State &); // copy ctor
    ~State (void);
    static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef State_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */


#if defined(TAO_NO_COPY_OCTET_SEQUENCES)
    State (
        CORBA::ULong length,
        const ACE_Message_Block* mb
      )
      : TAO_Unbounded_Sequence<CORBA::Octet> (length, mb) {}
#endif /* TAO_NO_COPY_OCTET_SEQUENCE */

  };

#endif /* end #if !defined */


#if !defined (_FT_STATE___VAR_CH_)
#define _FT_STATE___VAR_CH_

  // *************************************************************
  // class FT::State_var
  // *************************************************************

  class TAO_Export State_var
  {
  public:
    State_var (void); // default constructor
    State_var (State *);
    State_var (const State_var &); // copy constructor
    State_var (const State &); // fixed-size base types only
    ~State_var (void); // destructor

    State_var &operator= (State *);
    State_var &operator= (const State_var &);
    State_var &operator= (const State &); // fixed-size base types only
    State *operator-> (void);
    const State *operator-> (void) const;

    operator const State &() const;
    operator State &();
    operator State &() const;

    CORBA::Octet &operator[] (CORBA::ULong index);
    // in, inout, out, _retn
    const State &in (void) const;
    State &inout (void);
    State *&out (void);
    State *_retn (void);
    State *ptr (void) const;

  private:
    State *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_FT_STATE___OUT_CH_)
#define _FT_STATE___OUT_CH_

  class TAO_Export State_out
  {
  public:
    State_out (State *&);
    State_out (State_var &);
    State_out (const State_out &);
    State_out &operator= (const State_out &);
    State_out &operator= (State *);
    operator State *&();
    State *&ptr (void);
    State *operator-> (void);
    CORBA::Octet &operator[] (CORBA::ULong index);

  private:
    State *&ptr_;
    // assignment from T_var not allowed
    void operator= (const State_var &);
  };


#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_State;


#if !defined (_FT_NOSTATEAVAILABLE_CH_)
#define _FT_NOSTATEAVAILABLE_CH_

  class TAO_Export NoStateAvailable : public CORBA::UserException
  {
  public:


  NoStateAvailable (void); // default ctor
  NoStateAvailable (const NoStateAvailable &); // copy ctor
  ~NoStateAvailable (void);
  static void _tao_any_destructor (void*);
  NoStateAvailable &operator= (const NoStateAvailable &);


  virtual void _raise (void);

  virtual void _tao_encode (
      TAO_OutputCDR &,
      CORBA::Environment &) const;
  virtual void _tao_decode (
      TAO_InputCDR &,
      CORBA::Environment &);

  static NoStateAvailable *_downcast (CORBA::Exception *);


  // = TAO extension
  static CORBA::Exception *_alloc (void);

}; // exception FT::NoStateAvailable

TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_NoStateAvailable;


#endif /* end #if !defined */


#if !defined (_FT_INVALIDSTATE_CH_)
#define _FT_INVALIDSTATE_CH_

class TAO_Export InvalidState : public CORBA::UserException
{
public:


InvalidState (void); // default ctor
InvalidState (const InvalidState &); // copy ctor
~InvalidState (void);
static void _tao_any_destructor (void*);
InvalidState &operator= (const InvalidState &);


virtual void _raise (void);

virtual void _tao_encode (
    TAO_OutputCDR &,
    CORBA::Environment &) const;
virtual void _tao_decode (
    TAO_InputCDR &,
    CORBA::Environment &);

static InvalidState *_downcast (CORBA::Exception *);


// = TAO extension
static CORBA::Exception *_alloc (void);

}; // exception FT::InvalidState

TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_InvalidState;


#endif /* end #if !defined */


#if !defined (_FT_NOUPDATEAVAILABLE_CH_)
#define _FT_NOUPDATEAVAILABLE_CH_

class TAO_Export NoUpdateAvailable : public CORBA::UserException
{
public:


NoUpdateAvailable (void); // default ctor
NoUpdateAvailable (const NoUpdateAvailable &); // copy ctor
~NoUpdateAvailable (void);
static void _tao_any_destructor (void*);
NoUpdateAvailable &operator= (const NoUpdateAvailable &);


virtual void _raise (void);

virtual void _tao_encode (
    TAO_OutputCDR &,
    CORBA::Environment &) const;
virtual void _tao_decode (
    TAO_InputCDR &,
    CORBA::Environment &);

static NoUpdateAvailable *_downcast (CORBA::Exception *);


// = TAO extension
static CORBA::Exception *_alloc (void);

}; // exception FT::NoUpdateAvailable

TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_NoUpdateAvailable;


#endif /* end #if !defined */


#if !defined (_FT_INVALIDUPDATE_CH_)
#define _FT_INVALIDUPDATE_CH_

class TAO_Export InvalidUpdate : public CORBA::UserException
{
public:


InvalidUpdate (void); // default ctor
InvalidUpdate (const InvalidUpdate &); // copy ctor
~InvalidUpdate (void);
static void _tao_any_destructor (void*);
InvalidUpdate &operator= (const InvalidUpdate &);


virtual void _raise (void);

virtual void _tao_encode (
    TAO_OutputCDR &,
    CORBA::Environment &) const;
virtual void _tao_decode (
    TAO_InputCDR &,
    CORBA::Environment &);

static InvalidUpdate *_downcast (CORBA::Exception *);


// = TAO extension
static CORBA::Exception *_alloc (void);

}; // exception FT::InvalidUpdate

TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_InvalidUpdate;


#endif /* end #if !defined */


#if !defined (_FT_CHECKPOINTABLE___PTR_CH_)
#define _FT_CHECKPOINTABLE___PTR_CH_

class Checkpointable;
typedef Checkpointable *Checkpointable_ptr;

#endif /* end #if !defined */


#if !defined (_FT_CHECKPOINTABLE___VAR_CH_)
#define _FT_CHECKPOINTABLE___VAR_CH_

class TAO_Export Checkpointable_var : public TAO_Base_var
{
public:
  Checkpointable_var (void); // default constructor
  Checkpointable_var (Checkpointable_ptr);
  Checkpointable_var (const Checkpointable_var &); // copy constructor
  ~Checkpointable_var (void); // destructor

  Checkpointable_var &operator= (Checkpointable_ptr);
  Checkpointable_var &operator= (const Checkpointable_var &);
  Checkpointable_ptr operator-> (void) const;

  operator const Checkpointable_ptr &() const;
  operator Checkpointable_ptr &();
  // in, inout, out, _retn
  Checkpointable_ptr in (void) const;
  Checkpointable_ptr &inout (void);
  Checkpointable_ptr &out (void);
  Checkpointable_ptr _retn (void);
  Checkpointable_ptr ptr (void) const;

private:
  Checkpointable_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  Checkpointable_var (const TAO_Base_var &rhs);
  Checkpointable_var &operator= (const TAO_Base_var &rhs);
};


#endif /* end #if !defined */


#if !defined (_FT_CHECKPOINTABLE___OUT_CH_)
#define _FT_CHECKPOINTABLE___OUT_CH_

class TAO_Export Checkpointable_out
{
public:
  Checkpointable_out (Checkpointable_ptr &);
  Checkpointable_out (Checkpointable_var &);
  Checkpointable_out (const Checkpointable_out &);
  Checkpointable_out &operator= (const Checkpointable_out &);
  Checkpointable_out &operator= (const Checkpointable_var &);
  Checkpointable_out &operator= (Checkpointable_ptr);
  operator Checkpointable_ptr &();
  Checkpointable_ptr &ptr (void);
  Checkpointable_ptr operator-> (void);

private:
  Checkpointable_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_FT_CHECKPOINTABLE_CH_)
#define _FT_CHECKPOINTABLE_CH_

class TAO_Export Checkpointable : public virtual CORBA_Object
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef Checkpointable_ptr _ptr_type;
  typedef Checkpointable_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static Checkpointable_ptr _duplicate (Checkpointable_ptr obj);
  static Checkpointable_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static Checkpointable_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static Checkpointable_ptr _nil (void)
    {
      return (Checkpointable_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual FT::State * get_state (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException,
      FT::NoStateAvailable
    ));

  virtual void set_state (
      const FT::State & s,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException,
      FT::InvalidState
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

protected:
  Checkpointable (void);
  Checkpointable (TAO_Stub *objref,
      TAO_ServantBase *_tao_servant = 0,
      CORBA::Boolean _tao_collocated = 0
    );
  virtual ~Checkpointable (void);
private:
  Checkpointable (const Checkpointable &);
  void operator= (const Checkpointable &);
};


#endif /* end #if !defined */

TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Checkpointable;


#if !defined (_FT_UPDATEABLE___PTR_CH_)
#define _FT_UPDATEABLE___PTR_CH_

class Updateable;
typedef Updateable *Updateable_ptr;

#endif /* end #if !defined */


#if !defined (_FT_UPDATEABLE___VAR_CH_)
#define _FT_UPDATEABLE___VAR_CH_

class TAO_Export Updateable_var : public TAO_Base_var
{
public:
  Updateable_var (void); // default constructor
  Updateable_var (Updateable_ptr);
  Updateable_var (const Updateable_var &); // copy constructor
  ~Updateable_var (void); // destructor

  Updateable_var &operator= (Updateable_ptr);
  Updateable_var &operator= (const Updateable_var &);
  Updateable_ptr operator-> (void) const;

  operator const Updateable_ptr &() const;
  operator Updateable_ptr &();
  // in, inout, out, _retn
  Updateable_ptr in (void) const;
  Updateable_ptr &inout (void);
  Updateable_ptr &out (void);
  Updateable_ptr _retn (void);
  Updateable_ptr ptr (void) const;

private:
  Updateable_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  Updateable_var (const TAO_Base_var &rhs);
  Updateable_var &operator= (const TAO_Base_var &rhs);
};


#endif /* end #if !defined */


#if !defined (_FT_UPDATEABLE___OUT_CH_)
#define _FT_UPDATEABLE___OUT_CH_

class TAO_Export Updateable_out
{
public:
  Updateable_out (Updateable_ptr &);
  Updateable_out (Updateable_var &);
  Updateable_out (const Updateable_out &);
  Updateable_out &operator= (const Updateable_out &);
  Updateable_out &operator= (const Updateable_var &);
  Updateable_out &operator= (Updateable_ptr);
  operator Updateable_ptr &();
  Updateable_ptr &ptr (void);
  Updateable_ptr operator-> (void);

private:
  Updateable_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_FT_UPDATEABLE_CH_)
#define _FT_UPDATEABLE_CH_

class TAO_Export Updateable: public virtual Checkpointable
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef Updateable_ptr _ptr_type;
  typedef Updateable_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static Updateable_ptr _duplicate (Updateable_ptr obj);
  static Updateable_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static Updateable_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static Updateable_ptr _nil (void)
    {
      return (Updateable_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual FT::State * get_update (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException,
      FT::NoUpdateAvailable
    ));

  virtual void set_update (
      const FT::State & s,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException,
      FT::InvalidUpdate
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

protected:
  Updateable (void);
  Updateable (TAO_Stub *objref,
      TAO_ServantBase *_tao_servant = 0,
      CORBA::Boolean _tao_collocated = 0
    );
  virtual ~Updateable (void);
private:
  Updateable (const Updateable &);
  void operator= (const Updateable &);
};


#endif /* end #if !defined */

TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Updateable;


}
TAO_NAMESPACE_CLOSE // module FT

TAO_Export void operator<<= (CORBA::Any &, const FT::TagFTGroupTaggedComponent &); // copying version
TAO_Export void operator<<= (CORBA::Any &, FT::TagFTGroupTaggedComponent*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, FT::TagFTGroupTaggedComponent *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const FT::TagFTGroupTaggedComponent *&);
TAO_Export void operator<<= (CORBA::Any &, const FT::TagFTPrimaryTaggedComponent &); // copying version
TAO_Export void operator<<= (CORBA::Any &, FT::TagFTPrimaryTaggedComponent*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, FT::TagFTPrimaryTaggedComponent *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const FT::TagFTPrimaryTaggedComponent *&);
TAO_Export void operator<<= (CORBA::Any &, const FT::FTGroupVersionServiceContext &); // copying version
TAO_Export void operator<<= (CORBA::Any &, FT::FTGroupVersionServiceContext*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, FT::FTGroupVersionServiceContext *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const FT::FTGroupVersionServiceContext *&);
TAO_Export void operator<<= (CORBA::Any &, const FT::FTRequestServiceContext &); // copying version
TAO_Export void operator<<= (CORBA::Any &, FT::FTRequestServiceContext*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, FT::FTRequestServiceContext *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const FT::FTRequestServiceContext *&);
extern TAO_Export FT::RequestDurationPolicy_ptr (*_TAO_collocation_FT_RequestDurationPolicy_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface FT::RequestDurationPolicy
TAO_Export void operator<<= (CORBA::Any &, FT::RequestDurationPolicy_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, FT::RequestDurationPolicy *&);
TAO_Export void operator<<= (CORBA::Any &, const FT::TagFTHeartbeatEnabledTaggedComponent &); // copying version
TAO_Export void operator<<= (CORBA::Any &, FT::TagFTHeartbeatEnabledTaggedComponent*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, FT::TagFTHeartbeatEnabledTaggedComponent *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const FT::TagFTHeartbeatEnabledTaggedComponent *&);
TAO_Export void operator<<= (CORBA::Any &, const FT::HeartbeatPolicyValue &); // copying version
TAO_Export void operator<<= (CORBA::Any &, FT::HeartbeatPolicyValue*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, FT::HeartbeatPolicyValue *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const FT::HeartbeatPolicyValue *&);
extern TAO_Export FT::HeartbeatPolicy_ptr (*_TAO_collocation_FT_HeartbeatPolicy_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface FT::HeartbeatPolicy
TAO_Export void operator<<= (CORBA::Any &, FT::HeartbeatPolicy_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, FT::HeartbeatPolicy *&);
extern TAO_Export FT::HeartbeatEnabledPolicy_ptr (*_TAO_collocation_FT_HeartbeatEnabledPolicy_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface FT::HeartbeatEnabledPolicy
TAO_Export void operator<<= (CORBA::Any &, FT::HeartbeatEnabledPolicy_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, FT::HeartbeatEnabledPolicy *&);
TAO_Export void operator<<= (CORBA::Any &, const FT::FaultMonitoringIntervalAndTimeoutValue &); // copying version
TAO_Export void operator<<= (CORBA::Any &, FT::FaultMonitoringIntervalAndTimeoutValue*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, FT::FaultMonitoringIntervalAndTimeoutValue *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const FT::FaultMonitoringIntervalAndTimeoutValue *&);
TAO_Export void operator<<= (CORBA::Any &, const FT::State &); // copying version
TAO_Export void operator<<= (CORBA::Any &, FT::State*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, FT::State *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const FT::State *&);
TAO_Export void operator<<= (CORBA::Any &, const FT::NoStateAvailable &); // copying version
TAO_Export void operator<<= (CORBA::Any &, FT::NoStateAvailable*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, FT::NoStateAvailable *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const FT::NoStateAvailable *&);
TAO_Export void operator<<= (CORBA::Any &, const FT::InvalidState &); // copying version
TAO_Export void operator<<= (CORBA::Any &, FT::InvalidState*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, FT::InvalidState *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const FT::InvalidState *&);
TAO_Export void operator<<= (CORBA::Any &, const FT::NoUpdateAvailable &); // copying version
TAO_Export void operator<<= (CORBA::Any &, FT::NoUpdateAvailable*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, FT::NoUpdateAvailable *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const FT::NoUpdateAvailable *&);
TAO_Export void operator<<= (CORBA::Any &, const FT::InvalidUpdate &); // copying version
TAO_Export void operator<<= (CORBA::Any &, FT::InvalidUpdate*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, FT::InvalidUpdate *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const FT::InvalidUpdate *&);
extern TAO_Export FT::Checkpointable_ptr (*_TAO_collocation_FT_Checkpointable_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface FT::Checkpointable
TAO_Export void operator<<= (CORBA::Any &, FT::Checkpointable_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, FT::Checkpointable *&);
extern TAO_Export FT::Updateable_ptr (*_TAO_collocation_FT_Updateable_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface FT::Updateable
TAO_Export void operator<<= (CORBA::Any &, FT::Updateable_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, FT::Updateable *&);

#ifndef __ACE_INLINE__

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const FT::TagFTGroupTaggedComponent &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, FT::TagFTGroupTaggedComponent &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const FT::TagFTPrimaryTaggedComponent &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, FT::TagFTPrimaryTaggedComponent &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const FT::FTGroupVersionServiceContext &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, FT::FTGroupVersionServiceContext &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const FT::FTRequestServiceContext &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, FT::FTRequestServiceContext &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const FT::RequestDurationPolicy_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, FT::RequestDurationPolicy_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const FT::TagFTHeartbeatEnabledTaggedComponent &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, FT::TagFTHeartbeatEnabledTaggedComponent &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const FT::HeartbeatPolicyValue &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, FT::HeartbeatPolicyValue &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const FT::HeartbeatPolicy_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, FT::HeartbeatPolicy_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const FT::HeartbeatEnabledPolicy_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, FT::HeartbeatEnabledPolicy_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const FT::FaultMonitoringIntervalAndTimeoutValue &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, FT::FaultMonitoringIntervalAndTimeoutValue &);

#if !defined _TAO_CDR_OP_FT_State_H_
#define _TAO_CDR_OP_FT_State_H_

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const FT::State &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    FT::State &
  );

#endif /* _TAO_CDR_OP_FT_State_H_ */

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const FT::NoStateAvailable &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, FT::NoStateAvailable &);

# if !defined (ACE_LACKS_IOSTREAM_TOTALLY)

TAO_Export ostream& operator<< (ostream &, const FT::NoStateAvailable &);

# endif /* ACE_LACKS_IOSTREAM_TOTALLY */
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const FT::InvalidState &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, FT::InvalidState &);

# if !defined (ACE_LACKS_IOSTREAM_TOTALLY)

TAO_Export ostream& operator<< (ostream &, const FT::InvalidState &);

# endif /* ACE_LACKS_IOSTREAM_TOTALLY */
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const FT::NoUpdateAvailable &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, FT::NoUpdateAvailable &);

# if !defined (ACE_LACKS_IOSTREAM_TOTALLY)

TAO_Export ostream& operator<< (ostream &, const FT::NoUpdateAvailable &);

# endif /* ACE_LACKS_IOSTREAM_TOTALLY */
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const FT::InvalidUpdate &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, FT::InvalidUpdate &);

# if !defined (ACE_LACKS_IOSTREAM_TOTALLY)

TAO_Export ostream& operator<< (ostream &, const FT::InvalidUpdate &);

# endif /* ACE_LACKS_IOSTREAM_TOTALLY */
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const FT::Checkpointable_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, FT::Checkpointable_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const FT::Updateable_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, FT::Updateable_ptr &);

#endif /* __ACE_INLINE__ */


#if defined (__ACE_INLINE__)
#include "FT_CORBAC.i"
#endif /* defined INLINE */

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(pop)
#endif /* _MSC_VER */

#endif /* ifndef */
