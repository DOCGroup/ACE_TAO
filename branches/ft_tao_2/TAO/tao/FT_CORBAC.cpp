/* -*- C++ -*- $Id$ */

// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO and the TAO IDL Compiler have been developed by the Center for
// Distributed Object Computing at Washington University, St. Louis.
//
// Information about TAO is available at:
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

#include "FT_CORBAC.h"

#if !defined (__ACE_INLINE__)
#include "FT_CORBAC.i"
#endif /* !defined INLINE */

static const CORBA::Long _oc_FT_FTDomainId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f46), ACE_NTOHL (0x54446f6d), ACE_NTOHL (0x61696e49), ACE_NTOHL (0x643a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/FT/FTDomainId:1.0
  11, ACE_NTOHL (0x4654446f), ACE_NTOHL (0x6d61696e), ACE_NTOHL (0x49640000),  // name = FTDomainId
  CORBA::tk_string, 
  0U, // string length
};
static CORBA::TypeCode _tc_TAO_tc_FT_FTDomainId (CORBA::tk_alias, sizeof (_oc_FT_FTDomainId), (char *) &_oc_FT_FTDomainId, 0, sizeof (FT::FTDomainId));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FTDomainId, &_tc_TAO_tc_FT_FTDomainId)
TAO_NAMESPACE_END
static const CORBA::Long _oc_FT_ObjectGroupId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f4f), ACE_NTOHL (0x626a6563), ACE_NTOHL (0x7447726f), ACE_NTOHL (0x75704964), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/FT/ObjectGroupId:1.0
  14, ACE_NTOHL (0x4f626a65), ACE_NTOHL (0x63744772), ACE_NTOHL (0x6f757049), ACE_NTOHL (0x64000000),  // name = ObjectGroupId
  CORBA::tk_ulonglong,

};
static CORBA::TypeCode _tc_TAO_tc_FT_ObjectGroupId (CORBA::tk_alias, sizeof (_oc_FT_ObjectGroupId), (char *) &_oc_FT_ObjectGroupId, 0, sizeof (FT::ObjectGroupId));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ObjectGroupId, &_tc_TAO_tc_FT_ObjectGroupId)
TAO_NAMESPACE_END
static const CORBA::Long _oc_FT_ObjectGroupRefVersion[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  41, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f4f), ACE_NTOHL (0x626a6563), ACE_NTOHL (0x7447726f), ACE_NTOHL (0x75705265), ACE_NTOHL (0x66566572), ACE_NTOHL (0x73696f6e), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/FT/ObjectGroupRefVersion:1.0
  22, ACE_NTOHL (0x4f626a65), ACE_NTOHL (0x63744772), ACE_NTOHL (0x6f757052), ACE_NTOHL (0x65665665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e000000),  // name = ObjectGroupRefVersion
  CORBA::tk_ulong,

};
static CORBA::TypeCode _tc_TAO_tc_FT_ObjectGroupRefVersion (CORBA::tk_alias, sizeof (_oc_FT_ObjectGroupRefVersion), (char *) &_oc_FT_ObjectGroupRefVersion, 0, sizeof (FT::ObjectGroupRefVersion));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ObjectGroupRefVersion, &_tc_TAO_tc_FT_ObjectGroupRefVersion)
TAO_NAMESPACE_END
static const CORBA::Long _oc_FT_TagFTGroupTaggedComponent[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  45, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f54), ACE_NTOHL (0x61674654), ACE_NTOHL (0x47726f75), ACE_NTOHL (0x70546167), ACE_NTOHL (0x67656443), ACE_NTOHL (0x6f6d706f), ACE_NTOHL (0x6e656e74), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/FT/TagFTGroupTaggedComponent:1.0
  26, ACE_NTOHL (0x54616746), ACE_NTOHL (0x5447726f), ACE_NTOHL (0x75705461), ACE_NTOHL (0x67676564), ACE_NTOHL (0x436f6d70), ACE_NTOHL (0x6f6e656e), ACE_NTOHL (0x74000000),  // name = TagFTGroupTaggedComponent
  4, // member count
  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_struct, // typecode kind
  88, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x47494f50), ACE_NTOHL (0x2f566572), ACE_NTOHL (0x73696f6e), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/GIOP/Version:1.0
    8, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e00),  // name = Version
    2, // member count
    6, ACE_NTOHL (0x6d616a6f), ACE_NTOHL (0x72000000),  // name = major
    CORBA::tk_octet,

    6, ACE_NTOHL (0x6d696e6f), ACE_NTOHL (0x72000000),  // name = minor
    CORBA::tk_octet,


  13, ACE_NTOHL (0x66745f64), ACE_NTOHL (0x6f6d6169), ACE_NTOHL (0x6e5f6964), ACE_NTOHL (0x0),  // name = ft_domain_id
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f46), ACE_NTOHL (0x54446f6d), ACE_NTOHL (0x61696e49), ACE_NTOHL (0x643a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/FT/FTDomainId:1.0
    11, ACE_NTOHL (0x4654446f), ACE_NTOHL (0x6d61696e), ACE_NTOHL (0x49640000),  // name = FTDomainId
    CORBA::tk_string, 
    0U, // string length

  16, ACE_NTOHL (0x6f626a65), ACE_NTOHL (0x63745f67), ACE_NTOHL (0x726f7570), ACE_NTOHL (0x5f696400),  // name = object_group_id
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f4f), ACE_NTOHL (0x626a6563), ACE_NTOHL (0x7447726f), ACE_NTOHL (0x75704964), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/FT/ObjectGroupId:1.0
    14, ACE_NTOHL (0x4f626a65), ACE_NTOHL (0x63744772), ACE_NTOHL (0x6f757049), ACE_NTOHL (0x64000000),  // name = ObjectGroupId
    CORBA::tk_ulonglong,


  25, ACE_NTOHL (0x6f626a65), ACE_NTOHL (0x63745f67), ACE_NTOHL (0x726f7570), ACE_NTOHL (0x5f726566), ACE_NTOHL (0x5f766572), ACE_NTOHL (0x73696f6e), ACE_NTOHL (0x0),  // name = object_group_ref_version
  CORBA::tk_alias, // typecode kind for typedefs
  84, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    41, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f4f), ACE_NTOHL (0x626a6563), ACE_NTOHL (0x7447726f), ACE_NTOHL (0x75705265), ACE_NTOHL (0x66566572), ACE_NTOHL (0x73696f6e), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/FT/ObjectGroupRefVersion:1.0
    22, ACE_NTOHL (0x4f626a65), ACE_NTOHL (0x63744772), ACE_NTOHL (0x6f757052), ACE_NTOHL (0x65665665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e000000),  // name = ObjectGroupRefVersion
    CORBA::tk_ulong,


};
static CORBA::TypeCode _tc_TAO_tc_FT_TagFTGroupTaggedComponent (CORBA::tk_struct, sizeof (_oc_FT_TagFTGroupTaggedComponent), (char *) &_oc_FT_TagFTGroupTaggedComponent, 0, sizeof (FT::TagFTGroupTaggedComponent));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_TagFTGroupTaggedComponent, &_tc_TAO_tc_FT_TagFTGroupTaggedComponent)
TAO_NAMESPACE_END
void FT::TagFTGroupTaggedComponent::_tao_any_destructor (void *x)
{
  TagFTGroupTaggedComponent *tmp = ACE_static_cast (TagFTGroupTaggedComponent*,x);
  delete tmp;
}

static const CORBA::Long _oc_FT_TagFTPrimaryTaggedComponent[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  47, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f54), ACE_NTOHL (0x61674654), ACE_NTOHL (0x5072696d), ACE_NTOHL (0x61727954), ACE_NTOHL (0x61676765), ACE_NTOHL (0x64436f6d), ACE_NTOHL (0x706f6e65), ACE_NTOHL (0x6e743a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/FT/TagFTPrimaryTaggedComponent:1.0
  28, ACE_NTOHL (0x54616746), ACE_NTOHL (0x54507269), ACE_NTOHL (0x6d617279), ACE_NTOHL (0x54616767), ACE_NTOHL (0x6564436f), ACE_NTOHL (0x6d706f6e), ACE_NTOHL (0x656e7400),  // name = TagFTPrimaryTaggedComponent
  1, // member count
  8, ACE_NTOHL (0x7072696d), ACE_NTOHL (0x61727900),  // name = primary
  CORBA::tk_boolean,

};
static CORBA::TypeCode _tc_TAO_tc_FT_TagFTPrimaryTaggedComponent (CORBA::tk_struct, sizeof (_oc_FT_TagFTPrimaryTaggedComponent), (char *) &_oc_FT_TagFTPrimaryTaggedComponent, 0, sizeof (FT::TagFTPrimaryTaggedComponent));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_TagFTPrimaryTaggedComponent, &_tc_TAO_tc_FT_TagFTPrimaryTaggedComponent)
TAO_NAMESPACE_END
void FT::TagFTPrimaryTaggedComponent::_tao_any_destructor (void *x)
{
  TagFTPrimaryTaggedComponent *tmp = ACE_static_cast (TagFTPrimaryTaggedComponent*,x);
  delete tmp;
}

static const CORBA::Long _oc_FT_FTGroupVersionServiceContext[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  48, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f46), ACE_NTOHL (0x5447726f), ACE_NTOHL (0x75705665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e536572), ACE_NTOHL (0x76696365), ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x6578743a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/FT/FTGroupVersionServiceContext:1.0
  29, ACE_NTOHL (0x46544772), ACE_NTOHL (0x6f757056), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x72766963), ACE_NTOHL (0x65436f6e), ACE_NTOHL (0x74657874), ACE_NTOHL (0x0),  // name = FTGroupVersionServiceContext
  1, // member count
  25, ACE_NTOHL (0x6f626a65), ACE_NTOHL (0x63745f67), ACE_NTOHL (0x726f7570), ACE_NTOHL (0x5f726566), ACE_NTOHL (0x5f766572), ACE_NTOHL (0x73696f6e), ACE_NTOHL (0x0),  // name = object_group_ref_version
  CORBA::tk_alias, // typecode kind for typedefs
  84, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    41, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f4f), ACE_NTOHL (0x626a6563), ACE_NTOHL (0x7447726f), ACE_NTOHL (0x75705265), ACE_NTOHL (0x66566572), ACE_NTOHL (0x73696f6e), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/FT/ObjectGroupRefVersion:1.0
    22, ACE_NTOHL (0x4f626a65), ACE_NTOHL (0x63744772), ACE_NTOHL (0x6f757052), ACE_NTOHL (0x65665665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e000000),  // name = ObjectGroupRefVersion
    CORBA::tk_ulong,


};
static CORBA::TypeCode _tc_TAO_tc_FT_FTGroupVersionServiceContext (CORBA::tk_struct, sizeof (_oc_FT_FTGroupVersionServiceContext), (char *) &_oc_FT_FTGroupVersionServiceContext, 0, sizeof (FT::FTGroupVersionServiceContext));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FTGroupVersionServiceContext, &_tc_TAO_tc_FT_FTGroupVersionServiceContext)
TAO_NAMESPACE_END
void FT::FTGroupVersionServiceContext::_tao_any_destructor (void *x)
{
  FTGroupVersionServiceContext *tmp = ACE_static_cast (FTGroupVersionServiceContext*,x);
  delete tmp;
}

TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, REQUEST_DURATION_POLICY, 47U)
TAO_NAMESPACE_END
static const CORBA::Long _oc_FT_FTRequestServiceContext[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f46), ACE_NTOHL (0x54526571), ACE_NTOHL (0x75657374), ACE_NTOHL (0x53657276), ACE_NTOHL (0x69636543), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78743a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/FT/FTRequestServiceContext:1.0
  24, ACE_NTOHL (0x46545265), ACE_NTOHL (0x71756573), ACE_NTOHL (0x74536572), ACE_NTOHL (0x76696365), ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787400),  // name = FTRequestServiceContext
  3, // member count
  10, ACE_NTOHL (0x636c6965), ACE_NTOHL (0x6e745f69), ACE_NTOHL (0x64000000),  // name = client_id
  CORBA::tk_string, 
  0U, // string length
  13, ACE_NTOHL (0x72657465), ACE_NTOHL (0x6e74696f), ACE_NTOHL (0x6e5f6964), ACE_NTOHL (0x0),  // name = retention_id
  CORBA::tk_long,

  16, ACE_NTOHL (0x65787069), ACE_NTOHL (0x72617469), ACE_NTOHL (0x6f6e5f74), ACE_NTOHL (0x696d6500),  // name = expiration_time
  CORBA::tk_alias, // typecode kind for typedefs
  56, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x54696d65), ACE_NTOHL (0x42617365), ACE_NTOHL (0x2f54696d), ACE_NTOHL (0x65543a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/TimeBase/TimeT:1.0
    6, ACE_NTOHL (0x54696d65), ACE_NTOHL (0x54000000),  // name = TimeT
    CORBA::tk_ulonglong,


};
static CORBA::TypeCode _tc_TAO_tc_FT_FTRequestServiceContext (CORBA::tk_struct, sizeof (_oc_FT_FTRequestServiceContext), (char *) &_oc_FT_FTRequestServiceContext, 0, sizeof (FT::FTRequestServiceContext));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FTRequestServiceContext, &_tc_TAO_tc_FT_FTRequestServiceContext)
TAO_NAMESPACE_END
void FT::FTRequestServiceContext::_tao_any_destructor (void *x)
{
  FTRequestServiceContext *tmp = ACE_static_cast (FTRequestServiceContext*,x);
  delete tmp;
}


// default constructor
FT::RequestDurationPolicy::RequestDurationPolicy (void)
{}

// destructor
FT::RequestDurationPolicy::~RequestDurationPolicy (void)
{}

void FT::RequestDurationPolicy::_tao_any_destructor (void *x)
{
  RequestDurationPolicy *tmp = ACE_static_cast (RequestDurationPolicy*,x);
  CORBA::release (tmp);
}

FT::RequestDurationPolicy_ptr FT::RequestDurationPolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return RequestDurationPolicy::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/FT/RequestDurationPolicy:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (RequestDurationPolicy::_nil ());
      if (is_a == 0)
        return RequestDurationPolicy::_nil ();
    }
  return RequestDurationPolicy::_unchecked_narrow (obj, ACE_TRY_ENV);
}

FT::RequestDurationPolicy_ptr FT::RequestDurationPolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return RequestDurationPolicy::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      RequestDurationPolicy_ptr default_proxy = RequestDurationPolicy::_nil ();

      if (obj->_is_collocated () && _TAO_collocation_FT_RequestDurationPolicy_Stub_Factory_function_pointer != 0)
        {
          default_proxy = _TAO_collocation_FT_RequestDurationPolicy_Stub_Factory_function_pointer (obj);
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, RequestDurationPolicy (stub), RequestDurationPolicy::_nil ());
      #if (TAO_HAS_SMART_PROXIES == 1)
        return TAO_FT_RequestDurationPolicy_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
      #else 
        return default_proxy;
      #endif /*TAO_HAS_SMART_PROXIES == 1*/
    }
  else 
    return
      ACE_reinterpret_cast
        (
          RequestDurationPolicy_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &RequestDurationPolicy::_narrow
                  )
              )
        );
}

FT::RequestDurationPolicy_ptr
FT::RequestDurationPolicy::_duplicate (RequestDurationPolicy_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

TimeBase::TimeT FT::RequestDurationPolicy::request_duration_value (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  TimeBase::TimeT _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_request_duration_value",
      27,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN  (_tao_retval);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN  (_tao_retval);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_request_duration_value",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        CORBA::Short flag = TAO_TWOWAY_RESPONSE_FLAG;
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_retval)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_request_duration_value",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        break;
        
      }
#if (TAO_HAS_INTERCEPTORS == 1)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_request_duration_value",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN  (_tao_retval);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_retval;
}

CORBA::Boolean FT::RequestDurationPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/FT/RequestDurationPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *FT::RequestDurationPolicy::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::FT, RequestDurationPolicy)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &::CORBA::Policy::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA::Policy_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* FT::RequestDurationPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/FT/RequestDurationPolicy:1.0";
}

static const CORBA::Long _oc_FT_RequestDurationPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  41, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f52), ACE_NTOHL (0x65717565), ACE_NTOHL (0x73744475), ACE_NTOHL (0x72617469), ACE_NTOHL (0x6f6e506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/FT/RequestDurationPolicy:1.0
  22, ACE_NTOHL (0x52657175), ACE_NTOHL (0x65737444), ACE_NTOHL (0x75726174), ACE_NTOHL (0x696f6e50), ACE_NTOHL (0x6f6c6963), ACE_NTOHL (0x79000000),  // name = RequestDurationPolicy
};
static CORBA::TypeCode _tc_TAO_tc_FT_RequestDurationPolicy (CORBA::tk_objref, sizeof (_oc_FT_RequestDurationPolicy), (char *) &_oc_FT_RequestDurationPolicy, 0, sizeof (FT::RequestDurationPolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RequestDurationPolicy, &_tc_TAO_tc_FT_RequestDurationPolicy)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, HEARTBEAT_POLICY, 48U)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, HEARTBEAT_ENABLED_POLICY, 49U)
TAO_NAMESPACE_END
static const CORBA::Long _oc_FT_TagFTHeartbeatEnabledTaggedComponent[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  56, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f54), ACE_NTOHL (0x61674654), ACE_NTOHL (0x48656172), ACE_NTOHL (0x74626561), ACE_NTOHL (0x74456e61), ACE_NTOHL (0x626c6564), ACE_NTOHL (0x54616767), ACE_NTOHL (0x6564436f), ACE_NTOHL (0x6d706f6e), ACE_NTOHL (0x656e743a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/FT/TagFTHeartbeatEnabledTaggedComponent:1.0
  37, ACE_NTOHL (0x54616746), ACE_NTOHL (0x54486561), ACE_NTOHL (0x72746265), ACE_NTOHL (0x6174456e), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x64546167), ACE_NTOHL (0x67656443), ACE_NTOHL (0x6f6d706f), ACE_NTOHL (0x6e656e74), ACE_NTOHL (0x0),  // name = TagFTHeartbeatEnabledTaggedComponent
  1, // member count
  18, ACE_NTOHL (0x68656172), ACE_NTOHL (0x74626561), ACE_NTOHL (0x745f656e), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x64000000),  // name = heartbeat_enabled
  CORBA::tk_boolean,

};
static CORBA::TypeCode _tc_TAO_tc_FT_TagFTHeartbeatEnabledTaggedComponent (CORBA::tk_struct, sizeof (_oc_FT_TagFTHeartbeatEnabledTaggedComponent), (char *) &_oc_FT_TagFTHeartbeatEnabledTaggedComponent, 0, sizeof (FT::TagFTHeartbeatEnabledTaggedComponent));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_TagFTHeartbeatEnabledTaggedComponent, &_tc_TAO_tc_FT_TagFTHeartbeatEnabledTaggedComponent)
TAO_NAMESPACE_END
void FT::TagFTHeartbeatEnabledTaggedComponent::_tao_any_destructor (void *x)
{
  TagFTHeartbeatEnabledTaggedComponent *tmp = ACE_static_cast (TagFTHeartbeatEnabledTaggedComponent*,x);
  delete tmp;
}

static const CORBA::Long _oc_FT_HeartbeatPolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f48), ACE_NTOHL (0x65617274), ACE_NTOHL (0x62656174), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63795661), ACE_NTOHL (0x6c75653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/FT/HeartbeatPolicyValue:1.0
  21, ACE_NTOHL (0x48656172), ACE_NTOHL (0x74626561), ACE_NTOHL (0x74506f6c), ACE_NTOHL (0x69637956), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x0),  // name = HeartbeatPolicyValue
  3, // member count
  10, ACE_NTOHL (0x68656172), ACE_NTOHL (0x74626561), ACE_NTOHL (0x74000000),  // name = heartbeat
  CORBA::tk_boolean,

  19, ACE_NTOHL (0x68656172), ACE_NTOHL (0x74626561), ACE_NTOHL (0x745f696e), ACE_NTOHL (0x74657276), ACE_NTOHL (0x616c0000),  // name = heartbeat_interval
  CORBA::tk_alias, // typecode kind for typedefs
  56, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x54696d65), ACE_NTOHL (0x42617365), ACE_NTOHL (0x2f54696d), ACE_NTOHL (0x65543a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/TimeBase/TimeT:1.0
    6, ACE_NTOHL (0x54696d65), ACE_NTOHL (0x54000000),  // name = TimeT
    CORBA::tk_ulonglong,


  18, ACE_NTOHL (0x68656172), ACE_NTOHL (0x74626561), ACE_NTOHL (0x745f7469), ACE_NTOHL (0x6d656f75), ACE_NTOHL (0x74000000),  // name = heartbeat_timeout
  CORBA::tk_alias, // typecode kind for typedefs
  56, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x54696d65), ACE_NTOHL (0x42617365), ACE_NTOHL (0x2f54696d), ACE_NTOHL (0x65543a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/TimeBase/TimeT:1.0
    6, ACE_NTOHL (0x54696d65), ACE_NTOHL (0x54000000),  // name = TimeT
    CORBA::tk_ulonglong,


};
static CORBA::TypeCode _tc_TAO_tc_FT_HeartbeatPolicyValue (CORBA::tk_struct, sizeof (_oc_FT_HeartbeatPolicyValue), (char *) &_oc_FT_HeartbeatPolicyValue, 0, sizeof (FT::HeartbeatPolicyValue));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_HeartbeatPolicyValue, &_tc_TAO_tc_FT_HeartbeatPolicyValue)
TAO_NAMESPACE_END
void FT::HeartbeatPolicyValue::_tao_any_destructor (void *x)
{
  HeartbeatPolicyValue *tmp = ACE_static_cast (HeartbeatPolicyValue*,x);
  delete tmp;
}


// default constructor
FT::HeartbeatPolicy::HeartbeatPolicy (void)
{}

// destructor
FT::HeartbeatPolicy::~HeartbeatPolicy (void)
{}

void FT::HeartbeatPolicy::_tao_any_destructor (void *x)
{
  HeartbeatPolicy *tmp = ACE_static_cast (HeartbeatPolicy*,x);
  CORBA::release (tmp);
}

FT::HeartbeatPolicy_ptr FT::HeartbeatPolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return HeartbeatPolicy::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/FT/HeartbeatPolicy:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (HeartbeatPolicy::_nil ());
      if (is_a == 0)
        return HeartbeatPolicy::_nil ();
    }
  return HeartbeatPolicy::_unchecked_narrow (obj, ACE_TRY_ENV);
}

FT::HeartbeatPolicy_ptr FT::HeartbeatPolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return HeartbeatPolicy::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      HeartbeatPolicy_ptr default_proxy = HeartbeatPolicy::_nil ();

      if (obj->_is_collocated () && _TAO_collocation_FT_HeartbeatPolicy_Stub_Factory_function_pointer != 0)
        {
          default_proxy = _TAO_collocation_FT_HeartbeatPolicy_Stub_Factory_function_pointer (obj);
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, HeartbeatPolicy (stub), HeartbeatPolicy::_nil ());
      #if (TAO_HAS_SMART_PROXIES == 1)
        return TAO_FT_HeartbeatPolicy_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
      #else 
        return default_proxy;
      #endif /*TAO_HAS_SMART_PROXIES == 1*/
    }
  else 
    return
      ACE_reinterpret_cast
        (
          HeartbeatPolicy_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &HeartbeatPolicy::_narrow
                  )
              )
        );
}

FT::HeartbeatPolicy_ptr
FT::HeartbeatPolicy::_duplicate (HeartbeatPolicy_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

FT::HeartbeatPolicyValue FT::HeartbeatPolicy::heartbeat_policy_value (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  FT::HeartbeatPolicyValue _tao_retval;
  ACE_OS::memset (&_tao_retval, 0, sizeof (FT::HeartbeatPolicyValue));
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_heartbeat_policy_value",
      27,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN  (_tao_retval);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN  (_tao_retval);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_heartbeat_policy_value",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        CORBA::Short flag = TAO_TWOWAY_RESPONSE_FLAG;
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_retval)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_heartbeat_policy_value",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        break;
        
      }
#if (TAO_HAS_INTERCEPTORS == 1)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_heartbeat_policy_value",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN  (_tao_retval);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_retval;
}

CORBA::Boolean FT::HeartbeatPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/FT/HeartbeatPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *FT::HeartbeatPolicy::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::FT, HeartbeatPolicy)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &::CORBA::Policy::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA::Policy_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* FT::HeartbeatPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/FT/HeartbeatPolicy:1.0";
}

static const CORBA::Long _oc_FT_HeartbeatPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f48), ACE_NTOHL (0x65617274), ACE_NTOHL (0x62656174), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63793a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/FT/HeartbeatPolicy:1.0
  16, ACE_NTOHL (0x48656172), ACE_NTOHL (0x74626561), ACE_NTOHL (0x74506f6c), ACE_NTOHL (0x69637900),  // name = HeartbeatPolicy
};
static CORBA::TypeCode _tc_TAO_tc_FT_HeartbeatPolicy (CORBA::tk_objref, sizeof (_oc_FT_HeartbeatPolicy), (char *) &_oc_FT_HeartbeatPolicy, 0, sizeof (FT::HeartbeatPolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_HeartbeatPolicy, &_tc_TAO_tc_FT_HeartbeatPolicy)
TAO_NAMESPACE_END

// default constructor
FT::HeartbeatEnabledPolicy::HeartbeatEnabledPolicy (void)
{}

// destructor
FT::HeartbeatEnabledPolicy::~HeartbeatEnabledPolicy (void)
{}

void FT::HeartbeatEnabledPolicy::_tao_any_destructor (void *x)
{
  HeartbeatEnabledPolicy *tmp = ACE_static_cast (HeartbeatEnabledPolicy*,x);
  CORBA::release (tmp);
}

FT::HeartbeatEnabledPolicy_ptr FT::HeartbeatEnabledPolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return HeartbeatEnabledPolicy::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/FT/HeartbeatEnabledPolicy:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (HeartbeatEnabledPolicy::_nil ());
      if (is_a == 0)
        return HeartbeatEnabledPolicy::_nil ();
    }
  return HeartbeatEnabledPolicy::_unchecked_narrow (obj, ACE_TRY_ENV);
}

FT::HeartbeatEnabledPolicy_ptr FT::HeartbeatEnabledPolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return HeartbeatEnabledPolicy::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      HeartbeatEnabledPolicy_ptr default_proxy = HeartbeatEnabledPolicy::_nil ();

      if (obj->_is_collocated () && _TAO_collocation_FT_HeartbeatEnabledPolicy_Stub_Factory_function_pointer != 0)
        {
          default_proxy = _TAO_collocation_FT_HeartbeatEnabledPolicy_Stub_Factory_function_pointer (obj);
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, HeartbeatEnabledPolicy (stub), HeartbeatEnabledPolicy::_nil ());
      #if (TAO_HAS_SMART_PROXIES == 1)
        return TAO_FT_HeartbeatEnabledPolicy_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
      #else 
        return default_proxy;
      #endif /*TAO_HAS_SMART_PROXIES == 1*/
    }
  else 
    return
      ACE_reinterpret_cast
        (
          HeartbeatEnabledPolicy_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &HeartbeatEnabledPolicy::_narrow
                  )
              )
        );
}

FT::HeartbeatEnabledPolicy_ptr
FT::HeartbeatEnabledPolicy::_duplicate (HeartbeatEnabledPolicy_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean FT::HeartbeatEnabledPolicy::heartbeat_enabled_policy_value (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_heartbeat_enabled_policy_value",
      35,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN  (_tao_retval);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN  (_tao_retval);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_heartbeat_enabled_policy_value",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        CORBA::Short flag = TAO_TWOWAY_RESPONSE_FLAG;
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_heartbeat_enabled_policy_value",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        break;
        
      }
#if (TAO_HAS_INTERCEPTORS == 1)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_heartbeat_enabled_policy_value",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN  (_tao_retval);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_retval;
}

CORBA::Boolean FT::HeartbeatEnabledPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/FT/HeartbeatEnabledPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *FT::HeartbeatEnabledPolicy::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::FT, HeartbeatEnabledPolicy)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &::CORBA::Policy::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA::Policy_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* FT::HeartbeatEnabledPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/FT/HeartbeatEnabledPolicy:1.0";
}

static const CORBA::Long _oc_FT_HeartbeatEnabledPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  42, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f48), ACE_NTOHL (0x65617274), ACE_NTOHL (0x62656174), ACE_NTOHL (0x456e6162), ACE_NTOHL (0x6c656450), ACE_NTOHL (0x6f6c6963), ACE_NTOHL (0x793a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/FT/HeartbeatEnabledPolicy:1.0
  23, ACE_NTOHL (0x48656172), ACE_NTOHL (0x74626561), ACE_NTOHL (0x74456e61), ACE_NTOHL (0x626c6564), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63790000),  // name = HeartbeatEnabledPolicy
};
static CORBA::TypeCode _tc_TAO_tc_FT_HeartbeatEnabledPolicy (CORBA::tk_objref, sizeof (_oc_FT_HeartbeatEnabledPolicy), (char *) &_oc_FT_HeartbeatEnabledPolicy, 0, sizeof (FT::HeartbeatEnabledPolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_HeartbeatEnabledPolicy, &_tc_TAO_tc_FT_HeartbeatEnabledPolicy)
TAO_NAMESPACE_END
static const CORBA::Long _oc_FT_TypeId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  26, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f54), ACE_NTOHL (0x79706549), ACE_NTOHL (0x643a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/FT/TypeId:1.0
  7, ACE_NTOHL (0x54797065), ACE_NTOHL (0x49640000),  // name = TypeId
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

};
static CORBA::TypeCode _tc_TAO_tc_FT_TypeId (CORBA::tk_alias, sizeof (_oc_FT_TypeId), (char *) &_oc_FT_TypeId, 0, sizeof (FT::TypeId));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_TypeId, &_tc_TAO_tc_FT_TypeId)
TAO_NAMESPACE_END
static const CORBA::Long _oc_FT_ObjectGroup[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f4f), ACE_NTOHL (0x626a6563), ACE_NTOHL (0x7447726f), ACE_NTOHL (0x75703a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/FT/ObjectGroup:1.0
  12, ACE_NTOHL (0x4f626a65), ACE_NTOHL (0x63744772), ACE_NTOHL (0x6f757000),  // name = ObjectGroup
  CORBA::tk_objref,
  52, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f62), ACE_NTOHL (0x6a656374), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Object:1.0
    7, ACE_NTOHL (0x4f626a65), ACE_NTOHL (0x63740000),  // name = Object

};
static CORBA::TypeCode _tc_TAO_tc_FT_ObjectGroup (CORBA::tk_alias, sizeof (_oc_FT_ObjectGroup), (char *) &_oc_FT_ObjectGroup, 0, sizeof (FT::ObjectGroup));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ObjectGroup, &_tc_TAO_tc_FT_ObjectGroup)
TAO_NAMESPACE_END
static const CORBA::Long _oc_FT_ReplicationStyleValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  41, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f52), ACE_NTOHL (0x65706c69), ACE_NTOHL (0x63617469), ACE_NTOHL (0x6f6e5374), ACE_NTOHL (0x796c6556), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/FT/ReplicationStyleValue:1.0
  22, ACE_NTOHL (0x5265706c), ACE_NTOHL (0x69636174), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x74796c65), ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65000000),  // name = ReplicationStyleValue
  CORBA::tk_long,

};
static CORBA::TypeCode _tc_TAO_tc_FT_ReplicationStyleValue (CORBA::tk_alias, sizeof (_oc_FT_ReplicationStyleValue), (char *) &_oc_FT_ReplicationStyleValue, 0, sizeof (FT::ReplicationStyleValue));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ReplicationStyleValue, &_tc_TAO_tc_FT_ReplicationStyleValue)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Long)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (const CORBA::Long, STATELESS, 0)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Long)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (const CORBA::Long, COLD_PASSIVE, 1)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Long)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (const CORBA::Long, WARM_PASSIVE, 2)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Long)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (const CORBA::Long, ACTIVE, 3)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Long)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (const CORBA::Long, ACTIVE_WITH_VOTING, 4)
TAO_NAMESPACE_END
static const CORBA::Long _oc_FT_MembershipStyleValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f4d), ACE_NTOHL (0x656d6265), ACE_NTOHL (0x72736869), ACE_NTOHL (0x70537479), ACE_NTOHL (0x6c655661), ACE_NTOHL (0x6c75653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/FT/MembershipStyleValue:1.0
  21, ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65727368), ACE_NTOHL (0x69705374), ACE_NTOHL (0x796c6556), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x0),  // name = MembershipStyleValue
  CORBA::tk_long,

};
static CORBA::TypeCode _tc_TAO_tc_FT_MembershipStyleValue (CORBA::tk_alias, sizeof (_oc_FT_MembershipStyleValue), (char *) &_oc_FT_MembershipStyleValue, 0, sizeof (FT::MembershipStyleValue));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_MembershipStyleValue, &_tc_TAO_tc_FT_MembershipStyleValue)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Long)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (const CORBA::Long, MEMB_APP_CTRL, 0)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Long)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (const CORBA::Long, MEMB_INF_CTRL, 1)
TAO_NAMESPACE_END
static const CORBA::Long _oc_FT_ConsistencyStyleValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  41, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f43), ACE_NTOHL (0x6f6e7369), ACE_NTOHL (0x7374656e), ACE_NTOHL (0x63795374), ACE_NTOHL (0x796c6556), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/FT/ConsistencyStyleValue:1.0
  22, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x69737465), ACE_NTOHL (0x6e637953), ACE_NTOHL (0x74796c65), ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65000000),  // name = ConsistencyStyleValue
  CORBA::tk_long,

};
static CORBA::TypeCode _tc_TAO_tc_FT_ConsistencyStyleValue (CORBA::tk_alias, sizeof (_oc_FT_ConsistencyStyleValue), (char *) &_oc_FT_ConsistencyStyleValue, 0, sizeof (FT::ConsistencyStyleValue));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ConsistencyStyleValue, &_tc_TAO_tc_FT_ConsistencyStyleValue)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Long)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (const CORBA::Long, CONS_APP_CTRL, 0)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Long)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (const CORBA::Long, CONS_INF_CTRL, 1)
TAO_NAMESPACE_END
static const CORBA::Long _oc_FT_FaultMonitoringStyleValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  45, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f46), ACE_NTOHL (0x61756c74), ACE_NTOHL (0x4d6f6e69), ACE_NTOHL (0x746f7269), ACE_NTOHL (0x6e675374), ACE_NTOHL (0x796c6556), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/FT/FaultMonitoringStyleValue:1.0
  26, ACE_NTOHL (0x4661756c), ACE_NTOHL (0x744d6f6e), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x696e6753), ACE_NTOHL (0x74796c65), ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65000000),  // name = FaultMonitoringStyleValue
  CORBA::tk_long,

};
static CORBA::TypeCode _tc_TAO_tc_FT_FaultMonitoringStyleValue (CORBA::tk_alias, sizeof (_oc_FT_FaultMonitoringStyleValue), (char *) &_oc_FT_FaultMonitoringStyleValue, 0, sizeof (FT::FaultMonitoringStyleValue));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FaultMonitoringStyleValue, &_tc_TAO_tc_FT_FaultMonitoringStyleValue)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Long)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (const CORBA::Long, PULL, 0)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Long)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (const CORBA::Long, PUSH, 1)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Long)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (const CORBA::Long, NOT_MONITORED, 2)
TAO_NAMESPACE_END
static const CORBA::Long _oc_FT_FaultMonitoringGranularityValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  51, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f46), ACE_NTOHL (0x61756c74), ACE_NTOHL (0x4d6f6e69), ACE_NTOHL (0x746f7269), ACE_NTOHL (0x6e674772), ACE_NTOHL (0x616e756c), ACE_NTOHL (0x61726974), ACE_NTOHL (0x7956616c), ACE_NTOHL (0x75653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/FT/FaultMonitoringGranularityValue:1.0
  32, ACE_NTOHL (0x4661756c), ACE_NTOHL (0x744d6f6e), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x696e6747), ACE_NTOHL (0x72616e75), ACE_NTOHL (0x6c617269), ACE_NTOHL (0x74795661), ACE_NTOHL (0x6c756500),  // name = FaultMonitoringGranularityValue
  CORBA::tk_long,

};
static CORBA::TypeCode _tc_TAO_tc_FT_FaultMonitoringGranularityValue (CORBA::tk_alias, sizeof (_oc_FT_FaultMonitoringGranularityValue), (char *) &_oc_FT_FaultMonitoringGranularityValue, 0, sizeof (FT::FaultMonitoringGranularityValue));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FaultMonitoringGranularityValue, &_tc_TAO_tc_FT_FaultMonitoringGranularityValue)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Long)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (const CORBA::Long, MEMB, 0)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Long)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (const CORBA::Long, LOC, 1)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Long)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (const CORBA::Long, LOC_AND_TYPE, 2)
TAO_NAMESPACE_END
static const CORBA::Long _oc_FT_InitialNumberReplicasValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  46, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f49), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x616c4e75), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x5265706c), ACE_NTOHL (0x69636173), ACE_NTOHL (0x56616c75), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/FT/InitialNumberReplicasValue:1.0
  27, ACE_NTOHL (0x496e6974), ACE_NTOHL (0x69616c4e), ACE_NTOHL (0x756d6265), ACE_NTOHL (0x72526570), ACE_NTOHL (0x6c696361), ACE_NTOHL (0x7356616c), ACE_NTOHL (0x75650000),  // name = InitialNumberReplicasValue
  CORBA::tk_ushort,

};
static CORBA::TypeCode _tc_TAO_tc_FT_InitialNumberReplicasValue (CORBA::tk_alias, sizeof (_oc_FT_InitialNumberReplicasValue), (char *) &_oc_FT_InitialNumberReplicasValue, 0, sizeof (FT::InitialNumberReplicasValue));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_InitialNumberReplicasValue, &_tc_TAO_tc_FT_InitialNumberReplicasValue)
TAO_NAMESPACE_END
static const CORBA::Long _oc_FT_MinimumNumberReplicasValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  46, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f4d), ACE_NTOHL (0x696e696d), ACE_NTOHL (0x756d4e75), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x5265706c), ACE_NTOHL (0x69636173), ACE_NTOHL (0x56616c75), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/FT/MinimumNumberReplicasValue:1.0
  27, ACE_NTOHL (0x4d696e69), ACE_NTOHL (0x6d756d4e), ACE_NTOHL (0x756d6265), ACE_NTOHL (0x72526570), ACE_NTOHL (0x6c696361), ACE_NTOHL (0x7356616c), ACE_NTOHL (0x75650000),  // name = MinimumNumberReplicasValue
  CORBA::tk_ushort,

};
static CORBA::TypeCode _tc_TAO_tc_FT_MinimumNumberReplicasValue (CORBA::tk_alias, sizeof (_oc_FT_MinimumNumberReplicasValue), (char *) &_oc_FT_MinimumNumberReplicasValue, 0, sizeof (FT::MinimumNumberReplicasValue));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_MinimumNumberReplicasValue, &_tc_TAO_tc_FT_MinimumNumberReplicasValue)
TAO_NAMESPACE_END
static const CORBA::Long _oc_FT_FaultMonitoringIntervalAndTimeoutValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  58, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f46), ACE_NTOHL (0x61756c74), ACE_NTOHL (0x4d6f6e69), ACE_NTOHL (0x746f7269), ACE_NTOHL (0x6e67496e), ACE_NTOHL (0x74657276), ACE_NTOHL (0x616c416e), ACE_NTOHL (0x6454696d), ACE_NTOHL (0x656f7574), ACE_NTOHL (0x56616c75), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/FT/FaultMonitoringIntervalAndTimeoutValue:1.0
  39, ACE_NTOHL (0x4661756c), ACE_NTOHL (0x744d6f6e), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x696e6749), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x76616c41), ACE_NTOHL (0x6e645469), ACE_NTOHL (0x6d656f75), ACE_NTOHL (0x7456616c), ACE_NTOHL (0x75650000),  // name = FaultMonitoringIntervalAndTimeoutValue
  2, // member count
  20, ACE_NTOHL (0x6d6f6e69), ACE_NTOHL (0x746f7269), ACE_NTOHL (0x6e675f69), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x76616c00),  // name = monitoring_interval
  CORBA::tk_alias, // typecode kind for typedefs
  56, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x54696d65), ACE_NTOHL (0x42617365), ACE_NTOHL (0x2f54696d), ACE_NTOHL (0x65543a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/TimeBase/TimeT:1.0
    6, ACE_NTOHL (0x54696d65), ACE_NTOHL (0x54000000),  // name = TimeT
    CORBA::tk_ulonglong,


  8, ACE_NTOHL (0x74696d65), ACE_NTOHL (0x6f757400),  // name = timeout
  CORBA::tk_alias, // typecode kind for typedefs
  56, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x54696d65), ACE_NTOHL (0x42617365), ACE_NTOHL (0x2f54696d), ACE_NTOHL (0x65543a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/TimeBase/TimeT:1.0
    6, ACE_NTOHL (0x54696d65), ACE_NTOHL (0x54000000),  // name = TimeT
    CORBA::tk_ulonglong,


};
static CORBA::TypeCode _tc_TAO_tc_FT_FaultMonitoringIntervalAndTimeoutValue (CORBA::tk_struct, sizeof (_oc_FT_FaultMonitoringIntervalAndTimeoutValue), (char *) &_oc_FT_FaultMonitoringIntervalAndTimeoutValue, 0, sizeof (FT::FaultMonitoringIntervalAndTimeoutValue));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FaultMonitoringIntervalAndTimeoutValue, &_tc_TAO_tc_FT_FaultMonitoringIntervalAndTimeoutValue)
TAO_NAMESPACE_END
void FT::FaultMonitoringIntervalAndTimeoutValue::_tao_any_destructor (void *x)
{
  FaultMonitoringIntervalAndTimeoutValue *tmp = ACE_static_cast (FaultMonitoringIntervalAndTimeoutValue*,x);
  delete tmp;
}

static const CORBA::Long _oc_FT_CheckpointIntervalValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f43), ACE_NTOHL (0x6865636b), ACE_NTOHL (0x706f696e), ACE_NTOHL (0x74496e74), ACE_NTOHL (0x65727661), ACE_NTOHL (0x6c56616c), ACE_NTOHL (0x75653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/FT/CheckpointIntervalValue:1.0
  24, ACE_NTOHL (0x43686563), ACE_NTOHL (0x6b706f69), ACE_NTOHL (0x6e74496e), ACE_NTOHL (0x74657276), ACE_NTOHL (0x616c5661), ACE_NTOHL (0x6c756500),  // name = CheckpointIntervalValue
  CORBA::tk_alias, // typecode kind for typedefs
  56, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x54696d65), ACE_NTOHL (0x42617365), ACE_NTOHL (0x2f54696d), ACE_NTOHL (0x65543a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/TimeBase/TimeT:1.0
    6, ACE_NTOHL (0x54696d65), ACE_NTOHL (0x54000000),  // name = TimeT
    CORBA::tk_ulonglong,


};
static CORBA::TypeCode _tc_TAO_tc_FT_CheckpointIntervalValue (CORBA::tk_alias, sizeof (_oc_FT_CheckpointIntervalValue), (char *) &_oc_FT_CheckpointIntervalValue, 0, sizeof (FT::CheckpointIntervalValue));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_CheckpointIntervalValue, &_tc_TAO_tc_FT_CheckpointIntervalValue)
TAO_NAMESPACE_END

#if !defined (_FT_STATE_CS_)
#define _FT_STATE_CS_

// *************************************************************
// FT::State
// *************************************************************

FT::State::State (void)
{}
FT::State::State (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::Octet>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
FT::State::State (CORBA::ULong max, CORBA::ULong length, CORBA::Octet *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::Octet>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
FT::State::State (const State &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::Octet>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
FT::State::~State (void) // dtor
{}
void FT::State::_tao_any_destructor (void *x)
{
  State *tmp = ACE_static_cast (State*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_FT_State[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  25, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f53), ACE_NTOHL (0x74617465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/FT/State:1.0
  6, ACE_NTOHL (0x53746174), ACE_NTOHL (0x65000000),  // name = State
  CORBA::tk_sequence, // typecode kind
  12, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_octet,

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_FT_State (CORBA::tk_alias, sizeof (_oc_FT_State), (char *) &_oc_FT_State, 0, sizeof (FT::State));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_State, &_tc_TAO_tc_FT_State)
TAO_NAMESPACE_END
// default constructor
FT::NoStateAvailable::NoStateAvailable (void)
  : CORBA_UserException (::FT::_tc_NoStateAvailable)
{
}

// destructor - all members are of self managing types
FT::NoStateAvailable::~NoStateAvailable (void)
{
}

void FT::NoStateAvailable::_tao_any_destructor (void *x)
{
  NoStateAvailable *tmp = ACE_static_cast (NoStateAvailable*,x);
  delete tmp;
}

// copy constructor
FT::NoStateAvailable::NoStateAvailable (const ::FT::NoStateAvailable &_tao_excp)
  : CORBA_UserException (_tao_excp._type ())
{
  }

// assignment operator
FT::NoStateAvailable&
FT::NoStateAvailable::operator= (const ::FT::NoStateAvailable &_tao_excp)
{

  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// narrow
FT::NoStateAvailable *
FT::NoStateAvailable::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/FT/NoStateAvailable:1.0", exc->_id ())) // same type
    return ACE_dynamic_cast (NoStateAvailable *, exc);
  else
    return 0;
}


void FT::NoStateAvailable::_raise ()
{
  TAO_RAISE(*this);
}


void FT::NoStateAvailable::_tao_encode (
    TAO_OutputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV) const
{
  if (cdr << *this)
    return;
  ACE_THROW (CORBA::MARSHAL ());
}


void FT::NoStateAvailable::_tao_decode (
    TAO_InputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV)
{
  if (cdr >> *this)
    return;
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method
CORBA::Exception *FT::NoStateAvailable::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::FT::NoStateAvailable, 0);
  return retval;
}

static const CORBA::Long _oc_FT_NoStateAvailable[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f4e), ACE_NTOHL (0x6f537461), ACE_NTOHL (0x74654176), ACE_NTOHL (0x61696c61), ACE_NTOHL (0x626c653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/FT/NoStateAvailable:1.0
  17, ACE_NTOHL (0x4e6f5374), ACE_NTOHL (0x61746541), ACE_NTOHL (0x7661696c), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x0),  // name = NoStateAvailable
  0, // member count
};
static CORBA::TypeCode _tc_TAO_tc_FT_NoStateAvailable (CORBA::tk_except, sizeof (_oc_FT_NoStateAvailable), (char *) &_oc_FT_NoStateAvailable, 0, sizeof (FT::NoStateAvailable));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_NoStateAvailable, &_tc_TAO_tc_FT_NoStateAvailable)
TAO_NAMESPACE_END
// default constructor
FT::InvalidState::InvalidState (void)
  : CORBA_UserException (::FT::_tc_InvalidState)
{
}

// destructor - all members are of self managing types
FT::InvalidState::~InvalidState (void)
{
}

void FT::InvalidState::_tao_any_destructor (void *x)
{
  InvalidState *tmp = ACE_static_cast (InvalidState*,x);
  delete tmp;
}

// copy constructor
FT::InvalidState::InvalidState (const ::FT::InvalidState &_tao_excp)
  : CORBA_UserException (_tao_excp._type ())
{
  }

// assignment operator
FT::InvalidState&
FT::InvalidState::operator= (const ::FT::InvalidState &_tao_excp)
{

  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// narrow
FT::InvalidState *
FT::InvalidState::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/FT/InvalidState:1.0", exc->_id ())) // same type
    return ACE_dynamic_cast (InvalidState *, exc);
  else
    return 0;
}


void FT::InvalidState::_raise ()
{
  TAO_RAISE(*this);
}


void FT::InvalidState::_tao_encode (
    TAO_OutputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV) const
{
  if (cdr << *this)
    return;
  ACE_THROW (CORBA::MARSHAL ());
}


void FT::InvalidState::_tao_decode (
    TAO_InputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV)
{
  if (cdr >> *this)
    return;
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method
CORBA::Exception *FT::InvalidState::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::FT::InvalidState, 0);
  return retval;
}

static const CORBA::Long _oc_FT_InvalidState[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f49), ACE_NTOHL (0x6e76616c), ACE_NTOHL (0x69645374), ACE_NTOHL (0x6174653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/FT/InvalidState:1.0
  13, ACE_NTOHL (0x496e7661), ACE_NTOHL (0x6c696453), ACE_NTOHL (0x74617465), ACE_NTOHL (0x0),  // name = InvalidState
  0, // member count
};
static CORBA::TypeCode _tc_TAO_tc_FT_InvalidState (CORBA::tk_except, sizeof (_oc_FT_InvalidState), (char *) &_oc_FT_InvalidState, 0, sizeof (FT::InvalidState));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_InvalidState, &_tc_TAO_tc_FT_InvalidState)
TAO_NAMESPACE_END
// default constructor
FT::NoUpdateAvailable::NoUpdateAvailable (void)
  : CORBA_UserException (::FT::_tc_NoUpdateAvailable)
{
}

// destructor - all members are of self managing types
FT::NoUpdateAvailable::~NoUpdateAvailable (void)
{
}

void FT::NoUpdateAvailable::_tao_any_destructor (void *x)
{
  NoUpdateAvailable *tmp = ACE_static_cast (NoUpdateAvailable*,x);
  delete tmp;
}

// copy constructor
FT::NoUpdateAvailable::NoUpdateAvailable (const ::FT::NoUpdateAvailable &_tao_excp)
  : CORBA_UserException (_tao_excp._type ())
{
  }

// assignment operator
FT::NoUpdateAvailable&
FT::NoUpdateAvailable::operator= (const ::FT::NoUpdateAvailable &_tao_excp)
{

  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// narrow
FT::NoUpdateAvailable *
FT::NoUpdateAvailable::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/FT/NoUpdateAvailable:1.0", exc->_id ())) // same type
    return ACE_dynamic_cast (NoUpdateAvailable *, exc);
  else
    return 0;
}


void FT::NoUpdateAvailable::_raise ()
{
  TAO_RAISE(*this);
}


void FT::NoUpdateAvailable::_tao_encode (
    TAO_OutputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV) const
{
  if (cdr << *this)
    return;
  ACE_THROW (CORBA::MARSHAL ());
}


void FT::NoUpdateAvailable::_tao_decode (
    TAO_InputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV)
{
  if (cdr >> *this)
    return;
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method
CORBA::Exception *FT::NoUpdateAvailable::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::FT::NoUpdateAvailable, 0);
  return retval;
}

static const CORBA::Long _oc_FT_NoUpdateAvailable[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f4e), ACE_NTOHL (0x6f557064), ACE_NTOHL (0x61746541), ACE_NTOHL (0x7661696c), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/FT/NoUpdateAvailable:1.0
  18, ACE_NTOHL (0x4e6f5570), ACE_NTOHL (0x64617465), ACE_NTOHL (0x41766169), ACE_NTOHL (0x6c61626c), ACE_NTOHL (0x65000000),  // name = NoUpdateAvailable
  0, // member count
};
static CORBA::TypeCode _tc_TAO_tc_FT_NoUpdateAvailable (CORBA::tk_except, sizeof (_oc_FT_NoUpdateAvailable), (char *) &_oc_FT_NoUpdateAvailable, 0, sizeof (FT::NoUpdateAvailable));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_NoUpdateAvailable, &_tc_TAO_tc_FT_NoUpdateAvailable)
TAO_NAMESPACE_END
// default constructor
FT::InvalidUpdate::InvalidUpdate (void)
  : CORBA_UserException (::FT::_tc_InvalidUpdate)
{
}

// destructor - all members are of self managing types
FT::InvalidUpdate::~InvalidUpdate (void)
{
}

void FT::InvalidUpdate::_tao_any_destructor (void *x)
{
  InvalidUpdate *tmp = ACE_static_cast (InvalidUpdate*,x);
  delete tmp;
}

// copy constructor
FT::InvalidUpdate::InvalidUpdate (const ::FT::InvalidUpdate &_tao_excp)
  : CORBA_UserException (_tao_excp._type ())
{
  }

// assignment operator
FT::InvalidUpdate&
FT::InvalidUpdate::operator= (const ::FT::InvalidUpdate &_tao_excp)
{

  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// narrow
FT::InvalidUpdate *
FT::InvalidUpdate::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/FT/InvalidUpdate:1.0", exc->_id ())) // same type
    return ACE_dynamic_cast (InvalidUpdate *, exc);
  else
    return 0;
}


void FT::InvalidUpdate::_raise ()
{
  TAO_RAISE(*this);
}


void FT::InvalidUpdate::_tao_encode (
    TAO_OutputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV) const
{
  if (cdr << *this)
    return;
  ACE_THROW (CORBA::MARSHAL ());
}


void FT::InvalidUpdate::_tao_decode (
    TAO_InputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV)
{
  if (cdr >> *this)
    return;
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method
CORBA::Exception *FT::InvalidUpdate::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::FT::InvalidUpdate, 0);
  return retval;
}

static const CORBA::Long _oc_FT_InvalidUpdate[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f49), ACE_NTOHL (0x6e76616c), ACE_NTOHL (0x69645570), ACE_NTOHL (0x64617465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/FT/InvalidUpdate:1.0
  14, ACE_NTOHL (0x496e7661), ACE_NTOHL (0x6c696455), ACE_NTOHL (0x70646174), ACE_NTOHL (0x65000000),  // name = InvalidUpdate
  0, // member count
};
static CORBA::TypeCode _tc_TAO_tc_FT_InvalidUpdate (CORBA::tk_except, sizeof (_oc_FT_InvalidUpdate), (char *) &_oc_FT_InvalidUpdate, 0, sizeof (FT::InvalidUpdate));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_InvalidUpdate, &_tc_TAO_tc_FT_InvalidUpdate)
TAO_NAMESPACE_END

// default constructor
FT::Checkpointable::Checkpointable (void)
{}

// destructor
FT::Checkpointable::~Checkpointable (void)
{}

void FT::Checkpointable::_tao_any_destructor (void *x)
{
  Checkpointable *tmp = ACE_static_cast (Checkpointable*,x);
  CORBA::release (tmp);
}

FT::Checkpointable_ptr FT::Checkpointable::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return Checkpointable::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/FT/Checkpointable:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (Checkpointable::_nil ());
      if (is_a == 0)
        return Checkpointable::_nil ();
    }
  return Checkpointable::_unchecked_narrow (obj, ACE_TRY_ENV);
}

FT::Checkpointable_ptr FT::Checkpointable::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return Checkpointable::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      Checkpointable_ptr default_proxy = Checkpointable::_nil ();

      if (obj->_is_collocated () && _TAO_collocation_FT_Checkpointable_Stub_Factory_function_pointer != 0)
        {
          default_proxy = _TAO_collocation_FT_Checkpointable_Stub_Factory_function_pointer (obj);
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, Checkpointable (stub), Checkpointable::_nil ());
      #if (TAO_HAS_SMART_PROXIES == 1)
        return TAO_FT_Checkpointable_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
      #else 
        return default_proxy;
      #endif /*TAO_HAS_SMART_PROXIES == 1*/
    }
  else 
    return
      ACE_reinterpret_cast
        (
          Checkpointable_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &Checkpointable::_narrow
                  )
              )
        );
}

FT::Checkpointable_ptr
FT::Checkpointable::_duplicate (Checkpointable_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

FT::State * FT::Checkpointable::get_state (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    FT::NoStateAvailable
  ))
{
  
  static TAO_Exception_Data _tao_FT_Checkpointable_get_state_exceptiondata [] = 
  {
    {FT::_tc_NoStateAvailable, FT::NoStateAvailable::_alloc}
  };

  FT::State *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, FT::State, _tao_retval);
  FT::State_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_state",
      9,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "get_state",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = TAO_TWOWAY_RESPONSE_FLAG;
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (_tao_FT_Checkpointable_get_state_exceptiondata, 1, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "get_state",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if (TAO_HAS_INTERCEPTORS == 1)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "get_state",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

void FT::Checkpointable::set_state (
    const FT::State & s,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    FT::InvalidState
  ))
{
  
  static TAO_Exception_Data _tao_FT_Checkpointable_set_state_exceptiondata [] = 
  {
    {FT::_tc_InvalidState, FT::InvalidState::_alloc}
  };


  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "set_state",
      9,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "set_state",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = TAO_TWOWAY_RESPONSE_FLAG;
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << s)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (_tao_FT_Checkpointable_set_state_exceptiondata, 1, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "set_state",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if (TAO_HAS_INTERCEPTORS == 1)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "set_state",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::Boolean FT::Checkpointable::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/FT/Checkpointable:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *FT::Checkpointable::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::FT, Checkpointable)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* FT::Checkpointable::_interface_repository_id (void) const
{
  return "IDL:omg.org/FT/Checkpointable:1.0";
}

static const CORBA::Long _oc_FT_Checkpointable[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f43), ACE_NTOHL (0x6865636b), ACE_NTOHL (0x706f696e), ACE_NTOHL (0x7461626c), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/FT/Checkpointable:1.0
  15, ACE_NTOHL (0x43686563), ACE_NTOHL (0x6b706f69), ACE_NTOHL (0x6e746162), ACE_NTOHL (0x6c650000),  // name = Checkpointable
};
static CORBA::TypeCode _tc_TAO_tc_FT_Checkpointable (CORBA::tk_objref, sizeof (_oc_FT_Checkpointable), (char *) &_oc_FT_Checkpointable, 0, sizeof (FT::Checkpointable));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Checkpointable, &_tc_TAO_tc_FT_Checkpointable)
TAO_NAMESPACE_END

// default constructor
FT::Updateable::Updateable (void)
{}

// destructor
FT::Updateable::~Updateable (void)
{}

void FT::Updateable::_tao_any_destructor (void *x)
{
  Updateable *tmp = ACE_static_cast (Updateable*,x);
  CORBA::release (tmp);
}

FT::Updateable_ptr FT::Updateable::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return Updateable::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/FT/Updateable:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (Updateable::_nil ());
      if (is_a == 0)
        return Updateable::_nil ();
    }
  return Updateable::_unchecked_narrow (obj, ACE_TRY_ENV);
}

FT::Updateable_ptr FT::Updateable::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return Updateable::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      Updateable_ptr default_proxy = Updateable::_nil ();

      if (obj->_is_collocated () && _TAO_collocation_FT_Updateable_Stub_Factory_function_pointer != 0)
        {
          default_proxy = _TAO_collocation_FT_Updateable_Stub_Factory_function_pointer (obj);
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, Updateable (stub), Updateable::_nil ());
      #if (TAO_HAS_SMART_PROXIES == 1)
        return TAO_FT_Updateable_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
      #else 
        return default_proxy;
      #endif /*TAO_HAS_SMART_PROXIES == 1*/
    }
  else 
    return
      ACE_reinterpret_cast
        (
          Updateable_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &Updateable::_narrow
                  )
              )
        );
}

FT::Updateable_ptr
FT::Updateable::_duplicate (Updateable_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

FT::State * FT::Updateable::get_update (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    FT::NoUpdateAvailable
  ))
{
  
  static TAO_Exception_Data _tao_FT_Updateable_get_update_exceptiondata [] = 
  {
    {FT::_tc_NoUpdateAvailable, FT::NoUpdateAvailable::_alloc}
  };

  FT::State *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, FT::State, _tao_retval);
  FT::State_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_update",
      10,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "get_update",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = TAO_TWOWAY_RESPONSE_FLAG;
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (_tao_FT_Updateable_get_update_exceptiondata, 1, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "get_update",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if (TAO_HAS_INTERCEPTORS == 1)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "get_update",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

void FT::Updateable::set_update (
    const FT::State & s,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    FT::InvalidUpdate
  ))
{
  
  static TAO_Exception_Data _tao_FT_Updateable_set_update_exceptiondata [] = 
  {
    {FT::_tc_InvalidUpdate, FT::InvalidUpdate::_alloc}
  };


  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "set_update",
      10,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "set_update",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = TAO_TWOWAY_RESPONSE_FLAG;
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << s)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (_tao_FT_Updateable_set_update_exceptiondata, 1, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "set_update",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if (TAO_HAS_INTERCEPTORS == 1)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "set_update",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::Boolean FT::Updateable::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/FT/Updateable:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/FT/Checkpointable:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *FT::Updateable::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::FT, Updateable)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::FT, Checkpointable)::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            FT::Checkpointable_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* FT::Updateable::_interface_repository_id (void) const
{
  return "IDL:omg.org/FT/Updateable:1.0";
}

static const CORBA::Long _oc_FT_Updateable[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f55), ACE_NTOHL (0x70646174), ACE_NTOHL (0x6561626c), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/FT/Updateable:1.0
  11, ACE_NTOHL (0x55706461), ACE_NTOHL (0x74656162), ACE_NTOHL (0x6c650000),  // name = Updateable
};
static CORBA::TypeCode _tc_TAO_tc_FT_Updateable (CORBA::tk_objref, sizeof (_oc_FT_Updateable), (char *) &_oc_FT_Updateable, 0, sizeof (FT::Updateable));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Updateable, &_tc_TAO_tc_FT_Updateable)
TAO_NAMESPACE_END
void operator<<= (CORBA::Any &_tao_any, const FT::TagFTGroupTaggedComponent &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      FT::_tc_TagFTGroupTaggedComponent,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, FT::TagFTGroupTaggedComponent *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      FT::_tc_TagFTGroupTaggedComponent,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      FT::TagFTGroupTaggedComponent::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, FT::TagFTGroupTaggedComponent *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const FT::TagFTGroupTaggedComponent*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const FT::TagFTGroupTaggedComponent *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (FT::_tc_TagFTGroupTaggedComponent, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const FT::TagFTGroupTaggedComponent*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      FT::TagFTGroupTaggedComponent *tmp;
      ACE_NEW_RETURN (tmp, FT::TagFTGroupTaggedComponent, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            FT::_tc_TagFTGroupTaggedComponent,
            1,
            ACE_static_cast (void *, tmp),
            FT::TagFTGroupTaggedComponent::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const FT::TagFTPrimaryTaggedComponent &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      FT::_tc_TagFTPrimaryTaggedComponent,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, FT::TagFTPrimaryTaggedComponent *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      FT::_tc_TagFTPrimaryTaggedComponent,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      FT::TagFTPrimaryTaggedComponent::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, FT::TagFTPrimaryTaggedComponent *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const FT::TagFTPrimaryTaggedComponent*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const FT::TagFTPrimaryTaggedComponent *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (FT::_tc_TagFTPrimaryTaggedComponent, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const FT::TagFTPrimaryTaggedComponent*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      FT::TagFTPrimaryTaggedComponent *tmp;
      ACE_NEW_RETURN (tmp, FT::TagFTPrimaryTaggedComponent, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            FT::_tc_TagFTPrimaryTaggedComponent,
            1,
            ACE_static_cast (void *, tmp),
            FT::TagFTPrimaryTaggedComponent::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const FT::FTGroupVersionServiceContext &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      FT::_tc_FTGroupVersionServiceContext,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, FT::FTGroupVersionServiceContext *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      FT::_tc_FTGroupVersionServiceContext,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      FT::FTGroupVersionServiceContext::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, FT::FTGroupVersionServiceContext *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const FT::FTGroupVersionServiceContext*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const FT::FTGroupVersionServiceContext *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (FT::_tc_FTGroupVersionServiceContext, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const FT::FTGroupVersionServiceContext*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      FT::FTGroupVersionServiceContext *tmp;
      ACE_NEW_RETURN (tmp, FT::FTGroupVersionServiceContext, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            FT::_tc_FTGroupVersionServiceContext,
            1,
            ACE_static_cast (void *, tmp),
            FT::FTGroupVersionServiceContext::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const FT::FTRequestServiceContext &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      FT::_tc_FTRequestServiceContext,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, FT::FTRequestServiceContext *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      FT::_tc_FTRequestServiceContext,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      FT::FTRequestServiceContext::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, FT::FTRequestServiceContext *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const FT::FTRequestServiceContext*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const FT::FTRequestServiceContext *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (FT::_tc_FTRequestServiceContext, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const FT::FTRequestServiceContext*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      FT::FTRequestServiceContext *tmp;
      ACE_NEW_RETURN (tmp, FT::FTRequestServiceContext, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            FT::_tc_FTRequestServiceContext,
            1,
            ACE_static_cast (void *, tmp),
            FT::FTRequestServiceContext::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

FT::RequestDurationPolicy_ptr (*_TAO_collocation_FT_RequestDurationPolicy_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, FT::RequestDurationPolicy_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        FT::_tc_RequestDurationPolicy, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        FT::RequestDurationPolicy::_duplicate (_tao_elem),
        FT::RequestDurationPolicy::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, FT::RequestDurationPolicy_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = FT::RequestDurationPolicy::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (FT::_tc_RequestDurationPolicy, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          FT::_tc_RequestDurationPolicy,
          1,
          _tao_elem,
          FT::RequestDurationPolicy::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = FT::RequestDurationPolicy::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = FT::RequestDurationPolicy::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<FT::RequestDurationPolicy,FT::RequestDurationPolicy_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<FT::RequestDurationPolicy,FT::RequestDurationPolicy_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const FT::TagFTHeartbeatEnabledTaggedComponent &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      FT::_tc_TagFTHeartbeatEnabledTaggedComponent,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, FT::TagFTHeartbeatEnabledTaggedComponent *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      FT::_tc_TagFTHeartbeatEnabledTaggedComponent,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      FT::TagFTHeartbeatEnabledTaggedComponent::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, FT::TagFTHeartbeatEnabledTaggedComponent *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const FT::TagFTHeartbeatEnabledTaggedComponent*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const FT::TagFTHeartbeatEnabledTaggedComponent *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (FT::_tc_TagFTHeartbeatEnabledTaggedComponent, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const FT::TagFTHeartbeatEnabledTaggedComponent*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      FT::TagFTHeartbeatEnabledTaggedComponent *tmp;
      ACE_NEW_RETURN (tmp, FT::TagFTHeartbeatEnabledTaggedComponent, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            FT::_tc_TagFTHeartbeatEnabledTaggedComponent,
            1,
            ACE_static_cast (void *, tmp),
            FT::TagFTHeartbeatEnabledTaggedComponent::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const FT::HeartbeatPolicyValue &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      FT::_tc_HeartbeatPolicyValue,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, FT::HeartbeatPolicyValue *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      FT::_tc_HeartbeatPolicyValue,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      FT::HeartbeatPolicyValue::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, FT::HeartbeatPolicyValue *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const FT::HeartbeatPolicyValue*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const FT::HeartbeatPolicyValue *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (FT::_tc_HeartbeatPolicyValue, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const FT::HeartbeatPolicyValue*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      FT::HeartbeatPolicyValue *tmp;
      ACE_NEW_RETURN (tmp, FT::HeartbeatPolicyValue, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            FT::_tc_HeartbeatPolicyValue,
            1,
            ACE_static_cast (void *, tmp),
            FT::HeartbeatPolicyValue::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

FT::HeartbeatPolicy_ptr (*_TAO_collocation_FT_HeartbeatPolicy_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, FT::HeartbeatPolicy_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        FT::_tc_HeartbeatPolicy, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        FT::HeartbeatPolicy::_duplicate (_tao_elem),
        FT::HeartbeatPolicy::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, FT::HeartbeatPolicy_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = FT::HeartbeatPolicy::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (FT::_tc_HeartbeatPolicy, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          FT::_tc_HeartbeatPolicy,
          1,
          _tao_elem,
          FT::HeartbeatPolicy::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = FT::HeartbeatPolicy::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = FT::HeartbeatPolicy::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<FT::HeartbeatPolicy,FT::HeartbeatPolicy_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<FT::HeartbeatPolicy,FT::HeartbeatPolicy_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

FT::HeartbeatEnabledPolicy_ptr (*_TAO_collocation_FT_HeartbeatEnabledPolicy_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, FT::HeartbeatEnabledPolicy_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        FT::_tc_HeartbeatEnabledPolicy, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        FT::HeartbeatEnabledPolicy::_duplicate (_tao_elem),
        FT::HeartbeatEnabledPolicy::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, FT::HeartbeatEnabledPolicy_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = FT::HeartbeatEnabledPolicy::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (FT::_tc_HeartbeatEnabledPolicy, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          FT::_tc_HeartbeatEnabledPolicy,
          1,
          _tao_elem,
          FT::HeartbeatEnabledPolicy::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = FT::HeartbeatEnabledPolicy::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = FT::HeartbeatEnabledPolicy::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<FT::HeartbeatEnabledPolicy,FT::HeartbeatEnabledPolicy_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<FT::HeartbeatEnabledPolicy,FT::HeartbeatEnabledPolicy_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const FT::FaultMonitoringIntervalAndTimeoutValue &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      FT::_tc_FaultMonitoringIntervalAndTimeoutValue,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, FT::FaultMonitoringIntervalAndTimeoutValue *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      FT::_tc_FaultMonitoringIntervalAndTimeoutValue,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      FT::FaultMonitoringIntervalAndTimeoutValue::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, FT::FaultMonitoringIntervalAndTimeoutValue *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const FT::FaultMonitoringIntervalAndTimeoutValue*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const FT::FaultMonitoringIntervalAndTimeoutValue *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (FT::_tc_FaultMonitoringIntervalAndTimeoutValue, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const FT::FaultMonitoringIntervalAndTimeoutValue*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      FT::FaultMonitoringIntervalAndTimeoutValue *tmp;
      ACE_NEW_RETURN (tmp, FT::FaultMonitoringIntervalAndTimeoutValue, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            FT::_tc_FaultMonitoringIntervalAndTimeoutValue,
            1,
            ACE_static_cast (void *, tmp),
            FT::FaultMonitoringIntervalAndTimeoutValue::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const FT::State &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        FT::_tc_State,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, FT::State *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      FT::_tc_State,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      FT::State::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, FT::State *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const FT::State*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const FT::State *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (FT::_tc_State, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const FT::State*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      FT::State *tmp;
      ACE_NEW_RETURN (tmp, FT::State, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            FT::_tc_State,
            1,
            ACE_static_cast (void *, tmp),
            FT::State::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const FT::NoStateAvailable &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      FT::_tc_NoStateAvailable,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, FT::NoStateAvailable *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      FT::_tc_NoStateAvailable,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      FT::NoStateAvailable::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, FT::NoStateAvailable *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const FT::NoStateAvailable*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const FT::NoStateAvailable *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (FT::_tc_NoStateAvailable, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (FT::NoStateAvailable *)_tao_any.value ();
      return 1;
    }
    else
    {
      FT::NoStateAvailable *tmp;
      ACE_NEW_RETURN (tmp, FT::NoStateAvailable, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      CORBA::String_var interface_repository_id;
      if (!(stream >> interface_repository_id.out ()))
        return 0;
      if (ACE_OS::strcmp (
          interface_repository_id.in (),
          "IDL:omg.org/FT/NoStateAvailable:1.0"))
        return 0;
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            FT::_tc_NoStateAvailable,
            1,
            tmp,
            FT::NoStateAvailable::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const FT::InvalidState &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      FT::_tc_InvalidState,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, FT::InvalidState *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      FT::_tc_InvalidState,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      FT::InvalidState::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, FT::InvalidState *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const FT::InvalidState*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const FT::InvalidState *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (FT::_tc_InvalidState, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (FT::InvalidState *)_tao_any.value ();
      return 1;
    }
    else
    {
      FT::InvalidState *tmp;
      ACE_NEW_RETURN (tmp, FT::InvalidState, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      CORBA::String_var interface_repository_id;
      if (!(stream >> interface_repository_id.out ()))
        return 0;
      if (ACE_OS::strcmp (
          interface_repository_id.in (),
          "IDL:omg.org/FT/InvalidState:1.0"))
        return 0;
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            FT::_tc_InvalidState,
            1,
            tmp,
            FT::InvalidState::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const FT::NoUpdateAvailable &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      FT::_tc_NoUpdateAvailable,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, FT::NoUpdateAvailable *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      FT::_tc_NoUpdateAvailable,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      FT::NoUpdateAvailable::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, FT::NoUpdateAvailable *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const FT::NoUpdateAvailable*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const FT::NoUpdateAvailable *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (FT::_tc_NoUpdateAvailable, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (FT::NoUpdateAvailable *)_tao_any.value ();
      return 1;
    }
    else
    {
      FT::NoUpdateAvailable *tmp;
      ACE_NEW_RETURN (tmp, FT::NoUpdateAvailable, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      CORBA::String_var interface_repository_id;
      if (!(stream >> interface_repository_id.out ()))
        return 0;
      if (ACE_OS::strcmp (
          interface_repository_id.in (),
          "IDL:omg.org/FT/NoUpdateAvailable:1.0"))
        return 0;
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            FT::_tc_NoUpdateAvailable,
            1,
            tmp,
            FT::NoUpdateAvailable::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const FT::InvalidUpdate &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      FT::_tc_InvalidUpdate,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, FT::InvalidUpdate *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      FT::_tc_InvalidUpdate,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      FT::InvalidUpdate::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, FT::InvalidUpdate *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const FT::InvalidUpdate*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const FT::InvalidUpdate *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (FT::_tc_InvalidUpdate, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (FT::InvalidUpdate *)_tao_any.value ();
      return 1;
    }
    else
    {
      FT::InvalidUpdate *tmp;
      ACE_NEW_RETURN (tmp, FT::InvalidUpdate, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      CORBA::String_var interface_repository_id;
      if (!(stream >> interface_repository_id.out ()))
        return 0;
      if (ACE_OS::strcmp (
          interface_repository_id.in (),
          "IDL:omg.org/FT/InvalidUpdate:1.0"))
        return 0;
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            FT::_tc_InvalidUpdate,
            1,
            tmp,
            FT::InvalidUpdate::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

FT::Checkpointable_ptr (*_TAO_collocation_FT_Checkpointable_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, FT::Checkpointable_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        FT::_tc_Checkpointable, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        FT::Checkpointable::_duplicate (_tao_elem),
        FT::Checkpointable::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, FT::Checkpointable_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = FT::Checkpointable::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (FT::_tc_Checkpointable, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          FT::_tc_Checkpointable,
          1,
          _tao_elem,
          FT::Checkpointable::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = FT::Checkpointable::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = FT::Checkpointable::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<FT::Checkpointable,FT::Checkpointable_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<FT::Checkpointable,FT::Checkpointable_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

FT::Updateable_ptr (*_TAO_collocation_FT_Updateable_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, FT::Updateable_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        FT::_tc_Updateable, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        FT::Updateable::_duplicate (_tao_elem),
        FT::Updateable::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, FT::Updateable_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = FT::Updateable::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (FT::_tc_Updateable, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          FT::_tc_Updateable,
          1,
          _tao_elem,
          FT::Updateable::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = FT::Updateable::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = FT::Updateable::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<FT::Updateable,FT::Updateable_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<FT::Updateable,FT::Updateable_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const FT::State &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    
#if defined (TAO_NO_COPY_OCTET_SEQUENCES)
    {
      TAO_Unbounded_Sequence<CORBA::Octet> *oseq = 
        ACE_static_cast (TAO_Unbounded_Sequence<CORBA::Octet>*, (FT::State *)&_tao_sequence);
      if (oseq->mb ())
        return strm.write_octet_array_mb (oseq->mb ());
      else
        return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
    }
    
#else /* TAO_NO_COPY_OCTET_SEQUENCES */
    return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
  
#endif /* TAO_NO_COPY_OCTET_SEQUENCES */
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    FT::State &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    
#if defined (TAO_NO_COPY_OCTET_SEQUENCES)
    if (ACE_BIT_DISABLED (strm.start ()->flags (),ACE_Message_Block::DONT_DELETE))
    {
      TAO_Unbounded_Sequence<CORBA::Octet> *oseq = 
        ACE_static_cast(TAO_Unbounded_Sequence<CORBA::Octet>*, &_tao_sequence);
      oseq->replace (_tao_seq_len, strm.start ());
      oseq->mb ()->wr_ptr (oseq->mb()->rd_ptr () + _tao_seq_len);
      strm.skip_bytes (_tao_seq_len);
      return 1;
    }
    else
      return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_seq_len);
    
#else /* TAO_NO_COPY_OCTET_SEQUENCES */
    return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
  
#endif /* TAO_NO_COPY_OCTET_SEQUENCES */
  }
  return 0; // error
}

