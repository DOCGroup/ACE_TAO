/* -*- C++ -*- $Id$ */

// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO and the TAO IDL Compiler have been developed by the Center for
// Distributed Object Computing at Washington University, St. Louis.
//
// Information about TAO is available at:
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

#include "FT_CORBAC.h"

#if (TAO_HAS_FT_CORBA == 1)

#include "tao/Stub.h"
#include "tao/Invocation.h"
#include "tao/InterceptorC.h"
#include "tao/NVList.h"

#if !defined (__ACE_INLINE__)
#include "FT_CORBAC.i"
#endif /* !defined INLINE */

static const CORBA::Long _oc_FT_FTDomainId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f46), ACE_NTOHL (0x54446f6d), ACE_NTOHL (0x61696e49), ACE_NTOHL (0x643a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/FT/FTDomainId:1.0
  11, ACE_NTOHL (0x4654446f), ACE_NTOHL (0x6d61696e), ACE_NTOHL (0x49640000),  // name = FTDomainId
  CORBA::tk_string,
  0U, // string length
};
static CORBA::TypeCode _tc_TAO_tc_FT_FTDomainId (CORBA::tk_alias, sizeof (_oc_FT_FTDomainId), (char *) &_oc_FT_FTDomainId, 0, sizeof (FT::FTDomainId));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FTDomainId, &_tc_TAO_tc_FT_FTDomainId)
TAO_NAMESPACE_END
static const CORBA::Long _oc_FT_ObjectGroupId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f4f), ACE_NTOHL (0x626a6563), ACE_NTOHL (0x7447726f), ACE_NTOHL (0x75704964), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/FT/ObjectGroupId:1.0
  14, ACE_NTOHL (0x4f626a65), ACE_NTOHL (0x63744772), ACE_NTOHL (0x6f757049), ACE_NTOHL (0x64000000),  // name = ObjectGroupId
  CORBA::tk_ulonglong,

};
static CORBA::TypeCode _tc_TAO_tc_FT_ObjectGroupId (CORBA::tk_alias, sizeof (_oc_FT_ObjectGroupId), (char *) &_oc_FT_ObjectGroupId, 0, sizeof (FT::ObjectGroupId));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ObjectGroupId, &_tc_TAO_tc_FT_ObjectGroupId)
TAO_NAMESPACE_END
static const CORBA::Long _oc_FT_ObjectGroupRefVersion[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  41, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f4f), ACE_NTOHL (0x626a6563), ACE_NTOHL (0x7447726f), ACE_NTOHL (0x75705265), ACE_NTOHL (0x66566572), ACE_NTOHL (0x73696f6e), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/FT/ObjectGroupRefVersion:1.0
  22, ACE_NTOHL (0x4f626a65), ACE_NTOHL (0x63744772), ACE_NTOHL (0x6f757052), ACE_NTOHL (0x65665665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e000000),  // name = ObjectGroupRefVersion
  CORBA::tk_ulong,

};
static CORBA::TypeCode _tc_TAO_tc_FT_ObjectGroupRefVersion (CORBA::tk_alias, sizeof (_oc_FT_ObjectGroupRefVersion), (char *) &_oc_FT_ObjectGroupRefVersion, 0, sizeof (FT::ObjectGroupRefVersion));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ObjectGroupRefVersion, &_tc_TAO_tc_FT_ObjectGroupRefVersion)
TAO_NAMESPACE_END
static const CORBA::Long _oc_FT_TagFTGroupTaggedComponent[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  45, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f54), ACE_NTOHL (0x61674654), ACE_NTOHL (0x47726f75), ACE_NTOHL (0x70546167), ACE_NTOHL (0x67656443), ACE_NTOHL (0x6f6d706f), ACE_NTOHL (0x6e656e74), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/FT/TagFTGroupTaggedComponent:1.0
  26, ACE_NTOHL (0x54616746), ACE_NTOHL (0x5447726f), ACE_NTOHL (0x75705461), ACE_NTOHL (0x67676564), ACE_NTOHL (0x436f6d70), ACE_NTOHL (0x6f6e656e), ACE_NTOHL (0x74000000),  // name = TagFTGroupTaggedComponent
  4, // member count
  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_struct, // typecode kind
  88, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x47494f50), ACE_NTOHL (0x2f566572), ACE_NTOHL (0x73696f6e), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/GIOP/Version:1.0
    8, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e00),  // name = Version
    2, // member count
    6, ACE_NTOHL (0x6d616a6f), ACE_NTOHL (0x72000000),  // name = major
    CORBA::tk_octet,

    6, ACE_NTOHL (0x6d696e6f), ACE_NTOHL (0x72000000),  // name = minor
    CORBA::tk_octet,


  13, ACE_NTOHL (0x66745f64), ACE_NTOHL (0x6f6d6169), ACE_NTOHL (0x6e5f6964), ACE_NTOHL (0x0),  // name = ft_domain_id
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f46), ACE_NTOHL (0x54446f6d), ACE_NTOHL (0x61696e49), ACE_NTOHL (0x643a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/FT/FTDomainId:1.0
    11, ACE_NTOHL (0x4654446f), ACE_NTOHL (0x6d61696e), ACE_NTOHL (0x49640000),  // name = FTDomainId
    CORBA::tk_string,
    0U, // string length

  16, ACE_NTOHL (0x6f626a65), ACE_NTOHL (0x63745f67), ACE_NTOHL (0x726f7570), ACE_NTOHL (0x5f696400),  // name = object_group_id
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f4f), ACE_NTOHL (0x626a6563), ACE_NTOHL (0x7447726f), ACE_NTOHL (0x75704964), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/FT/ObjectGroupId:1.0
    14, ACE_NTOHL (0x4f626a65), ACE_NTOHL (0x63744772), ACE_NTOHL (0x6f757049), ACE_NTOHL (0x64000000),  // name = ObjectGroupId
    CORBA::tk_ulonglong,


  25, ACE_NTOHL (0x6f626a65), ACE_NTOHL (0x63745f67), ACE_NTOHL (0x726f7570), ACE_NTOHL (0x5f726566), ACE_NTOHL (0x5f766572), ACE_NTOHL (0x73696f6e), ACE_NTOHL (0x0),  // name = object_group_ref_version
  CORBA::tk_alias, // typecode kind for typedefs
  84, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    41, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f4f), ACE_NTOHL (0x626a6563), ACE_NTOHL (0x7447726f), ACE_NTOHL (0x75705265), ACE_NTOHL (0x66566572), ACE_NTOHL (0x73696f6e), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/FT/ObjectGroupRefVersion:1.0
    22, ACE_NTOHL (0x4f626a65), ACE_NTOHL (0x63744772), ACE_NTOHL (0x6f757052), ACE_NTOHL (0x65665665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e000000),  // name = ObjectGroupRefVersion
    CORBA::tk_ulong,


};
static CORBA::TypeCode _tc_TAO_tc_FT_TagFTGroupTaggedComponent (CORBA::tk_struct, sizeof (_oc_FT_TagFTGroupTaggedComponent), (char *) &_oc_FT_TagFTGroupTaggedComponent, 0, sizeof (FT::TagFTGroupTaggedComponent));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_TagFTGroupTaggedComponent, &_tc_TAO_tc_FT_TagFTGroupTaggedComponent)
TAO_NAMESPACE_END
void FT::TagFTGroupTaggedComponent::_tao_any_destructor (void *x)
{
  FT_TagFTGroupTaggedComponent *tmp = ACE_static_cast (FT_TagFTGroupTaggedComponent*,x);
  delete tmp;
}

static const CORBA::Long _oc_FT_TagFTPrimaryTaggedComponent[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  47, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f54), ACE_NTOHL (0x61674654), ACE_NTOHL (0x5072696d), ACE_NTOHL (0x61727954), ACE_NTOHL (0x61676765), ACE_NTOHL (0x64436f6d), ACE_NTOHL (0x706f6e65), ACE_NTOHL (0x6e743a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/FT/TagFTPrimaryTaggedComponent:1.0
  28, ACE_NTOHL (0x54616746), ACE_NTOHL (0x54507269), ACE_NTOHL (0x6d617279), ACE_NTOHL (0x54616767), ACE_NTOHL (0x6564436f), ACE_NTOHL (0x6d706f6e), ACE_NTOHL (0x656e7400),  // name = TagFTPrimaryTaggedComponent
  1, // member count
  8, ACE_NTOHL (0x7072696d), ACE_NTOHL (0x61727900),  // name = primary
  CORBA::tk_boolean,

};
static CORBA::TypeCode _tc_TAO_tc_FT_TagFTPrimaryTaggedComponent (CORBA::tk_struct, sizeof (_oc_FT_TagFTPrimaryTaggedComponent), (char *) &_oc_FT_TagFTPrimaryTaggedComponent, 0, sizeof (FT::TagFTPrimaryTaggedComponent));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_TagFTPrimaryTaggedComponent, &_tc_TAO_tc_FT_TagFTPrimaryTaggedComponent)
TAO_NAMESPACE_END
void FT::TagFTPrimaryTaggedComponent::_tao_any_destructor (void *x)
{
  FT_TagFTPrimaryTaggedComponent *tmp = ACE_static_cast (FT_TagFTPrimaryTaggedComponent*,x);
  delete tmp;
}

static const CORBA::Long _oc_FT_FTGroupVersionServiceContext[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  48, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f46), ACE_NTOHL (0x5447726f), ACE_NTOHL (0x75705665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e536572), ACE_NTOHL (0x76696365), ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x6578743a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/FT/FTGroupVersionServiceContext:1.0
  29, ACE_NTOHL (0x46544772), ACE_NTOHL (0x6f757056), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x72766963), ACE_NTOHL (0x65436f6e), ACE_NTOHL (0x74657874), ACE_NTOHL (0x0),  // name = FTGroupVersionServiceContext
  1, // member count
  25, ACE_NTOHL (0x6f626a65), ACE_NTOHL (0x63745f67), ACE_NTOHL (0x726f7570), ACE_NTOHL (0x5f726566), ACE_NTOHL (0x5f766572), ACE_NTOHL (0x73696f6e), ACE_NTOHL (0x0),  // name = object_group_ref_version
  CORBA::tk_alias, // typecode kind for typedefs
  84, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    41, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f4f), ACE_NTOHL (0x626a6563), ACE_NTOHL (0x7447726f), ACE_NTOHL (0x75705265), ACE_NTOHL (0x66566572), ACE_NTOHL (0x73696f6e), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/FT/ObjectGroupRefVersion:1.0
    22, ACE_NTOHL (0x4f626a65), ACE_NTOHL (0x63744772), ACE_NTOHL (0x6f757052), ACE_NTOHL (0x65665665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e000000),  // name = ObjectGroupRefVersion
    CORBA::tk_ulong,


};
static CORBA::TypeCode _tc_TAO_tc_FT_FTGroupVersionServiceContext (CORBA::tk_struct, sizeof (_oc_FT_FTGroupVersionServiceContext), (char *) &_oc_FT_FTGroupVersionServiceContext, 0, sizeof (FT::FTGroupVersionServiceContext));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FTGroupVersionServiceContext, &_tc_TAO_tc_FT_FTGroupVersionServiceContext)
TAO_NAMESPACE_END
void FT::FTGroupVersionServiceContext::_tao_any_destructor (void *x)
{
  FT_FTGroupVersionServiceContext *tmp = ACE_static_cast (FT_FTGroupVersionServiceContext*,x);
  delete tmp;
}

TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, REQUEST_DURATION_POLICY, 47U)
TAO_NAMESPACE_END
static const CORBA::Long _oc_FT_FTRequestServiceContext[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f46), ACE_NTOHL (0x54526571), ACE_NTOHL (0x75657374), ACE_NTOHL (0x53657276), ACE_NTOHL (0x69636543), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78743a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/FT/FTRequestServiceContext:1.0
  24, ACE_NTOHL (0x46545265), ACE_NTOHL (0x71756573), ACE_NTOHL (0x74536572), ACE_NTOHL (0x76696365), ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787400),  // name = FTRequestServiceContext
  3, // member count
  10, ACE_NTOHL (0x636c6965), ACE_NTOHL (0x6e745f69), ACE_NTOHL (0x64000000),  // name = client_id
  CORBA::tk_string,
  0U, // string length
  13, ACE_NTOHL (0x72657465), ACE_NTOHL (0x6e74696f), ACE_NTOHL (0x6e5f6964), ACE_NTOHL (0x0),  // name = retention_id
  CORBA::tk_long,

  16, ACE_NTOHL (0x65787069), ACE_NTOHL (0x72617469), ACE_NTOHL (0x6f6e5f74), ACE_NTOHL (0x696d6500),  // name = expiration_time
  CORBA::tk_alias, // typecode kind for typedefs
  56, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x54696d65), ACE_NTOHL (0x42617365), ACE_NTOHL (0x2f54696d), ACE_NTOHL (0x65543a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/TimeBase/TimeT:1.0
    6, ACE_NTOHL (0x54696d65), ACE_NTOHL (0x54000000),  // name = TimeT
    CORBA::tk_ulonglong,


};
static CORBA::TypeCode _tc_TAO_tc_FT_FTRequestServiceContext (CORBA::tk_struct, sizeof (_oc_FT_FTRequestServiceContext), (char *) &_oc_FT_FTRequestServiceContext, 0, sizeof (FT::FTRequestServiceContext));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FTRequestServiceContext, &_tc_TAO_tc_FT_FTRequestServiceContext)
TAO_NAMESPACE_END
void FT::FTRequestServiceContext::_tao_any_destructor (void *x)
{
  FT_FTRequestServiceContext *tmp = ACE_static_cast (FT_FTRequestServiceContext*,x);
  delete tmp;
}


// default constructor
FT_RequestDurationPolicy::FT_RequestDurationPolicy (void)
{}

// destructor
FT_RequestDurationPolicy::~FT_RequestDurationPolicy (void)
{}

void FT_RequestDurationPolicy::_tao_any_destructor (void *x)
{
  FT_RequestDurationPolicy *tmp = ACE_static_cast (FT_RequestDurationPolicy*,x);
  CORBA::release (tmp);
}

FT_RequestDurationPolicy_ptr FT_RequestDurationPolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return FT_RequestDurationPolicy::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/FT/RequestDurationPolicy:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (FT_RequestDurationPolicy::_nil ());
      if (is_a == 0)
        return FT_RequestDurationPolicy::_nil ();
    }
  return FT_RequestDurationPolicy::_unchecked_narrow (obj, ACE_TRY_ENV);
}

FT_RequestDurationPolicy_ptr FT_RequestDurationPolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return FT_RequestDurationPolicy::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      FT_RequestDurationPolicy_ptr default_proxy = FT_RequestDurationPolicy::_nil ();

      if (obj->_is_collocated () && _TAO_collocation_FT_RequestDurationPolicy_Stub_Factory_function_pointer != 0)
        {
          default_proxy = _TAO_collocation_FT_RequestDurationPolicy_Stub_Factory_function_pointer (obj);
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::FT::RequestDurationPolicy (stub), FT_RequestDurationPolicy::_nil ());
      #if (TAO_HAS_SMART_PROXIES == 1)
        return TAO_FT_RequestDurationPolicy_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
      #else
        return default_proxy;
      #endif /*TAO_HAS_SMART_PROXIES == 1*/
    }
  else
    return
      ACE_reinterpret_cast
        (
          FT_RequestDurationPolicy_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &FT_RequestDurationPolicy::_narrow
                  )
              )
        );
}

FT_RequestDurationPolicy_ptr
FT_RequestDurationPolicy::_duplicate (FT_RequestDurationPolicy_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

TimeBase::TimeT FT_RequestDurationPolicy::request_duration_value (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  TimeBase::TimeT _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_request_duration_value",
      27,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN  (_tao_retval);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN  (_tao_retval);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_request_duration_value",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        CORBA::Short flag = TAO_TWOWAY_RESPONSE_FLAG;

        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_retval)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_request_duration_value",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        break;

      }
#if (TAO_HAS_INTERCEPTORS == 1)

    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_request_duration_value",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN  (_tao_retval);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_retval;
}

CORBA::Boolean FT_RequestDurationPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/FT/RequestDurationPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *FT_RequestDurationPolicy::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      & FT_RequestDurationPolicy::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &::CORBA::Policy::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA::Policy_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* FT_RequestDurationPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/FT/RequestDurationPolicy:1.0";
}

static const CORBA::Long _oc_FT_RequestDurationPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  41, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f52), ACE_NTOHL (0x65717565), ACE_NTOHL (0x73744475), ACE_NTOHL (0x72617469), ACE_NTOHL (0x6f6e506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/FT/RequestDurationPolicy:1.0
  22, ACE_NTOHL (0x52657175), ACE_NTOHL (0x65737444), ACE_NTOHL (0x75726174), ACE_NTOHL (0x696f6e50), ACE_NTOHL (0x6f6c6963), ACE_NTOHL (0x79000000),  // name = RequestDurationPolicy
};
static CORBA::TypeCode _tc_TAO_tc_FT_RequestDurationPolicy (CORBA::tk_objref, sizeof (_oc_FT_RequestDurationPolicy), (char *) &_oc_FT_RequestDurationPolicy, 0, sizeof (FT::RequestDurationPolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RequestDurationPolicy, &_tc_TAO_tc_FT_RequestDurationPolicy)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, HEARTBEAT_POLICY, 48U)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, HEARTBEAT_ENABLED_POLICY, 49U)
TAO_NAMESPACE_END
static const CORBA::Long _oc_FT_TagFTHeartbeatEnabledTaggedComponent[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  56, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f54), ACE_NTOHL (0x61674654), ACE_NTOHL (0x48656172), ACE_NTOHL (0x74626561), ACE_NTOHL (0x74456e61), ACE_NTOHL (0x626c6564), ACE_NTOHL (0x54616767), ACE_NTOHL (0x6564436f), ACE_NTOHL (0x6d706f6e), ACE_NTOHL (0x656e743a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/FT/TagFTHeartbeatEnabledTaggedComponent:1.0
  37, ACE_NTOHL (0x54616746), ACE_NTOHL (0x54486561), ACE_NTOHL (0x72746265), ACE_NTOHL (0x6174456e), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x64546167), ACE_NTOHL (0x67656443), ACE_NTOHL (0x6f6d706f), ACE_NTOHL (0x6e656e74), ACE_NTOHL (0x0),  // name = TagFTHeartbeatEnabledTaggedComponent
  1, // member count
  18, ACE_NTOHL (0x68656172), ACE_NTOHL (0x74626561), ACE_NTOHL (0x745f656e), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x64000000),  // name = heartbeat_enabled
  CORBA::tk_boolean,

};
static CORBA::TypeCode _tc_TAO_tc_FT_TagFTHeartbeatEnabledTaggedComponent (CORBA::tk_struct, sizeof (_oc_FT_TagFTHeartbeatEnabledTaggedComponent), (char *) &_oc_FT_TagFTHeartbeatEnabledTaggedComponent, 0, sizeof (FT::TagFTHeartbeatEnabledTaggedComponent));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_TagFTHeartbeatEnabledTaggedComponent, &_tc_TAO_tc_FT_TagFTHeartbeatEnabledTaggedComponent)
TAO_NAMESPACE_END
void FT::TagFTHeartbeatEnabledTaggedComponent::_tao_any_destructor (void *x)
{
  FT_TagFTHeartbeatEnabledTaggedComponent *tmp = ACE_static_cast (FT_TagFTHeartbeatEnabledTaggedComponent*,x);
  delete tmp;
}

static const CORBA::Long _oc_FT_HeartbeatPolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f48), ACE_NTOHL (0x65617274), ACE_NTOHL (0x62656174), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63795661), ACE_NTOHL (0x6c75653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/FT/HeartbeatPolicyValue:1.0
  21, ACE_NTOHL (0x48656172), ACE_NTOHL (0x74626561), ACE_NTOHL (0x74506f6c), ACE_NTOHL (0x69637956), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x0),  // name = HeartbeatPolicyValue
  3, // member count
  10, ACE_NTOHL (0x68656172), ACE_NTOHL (0x74626561), ACE_NTOHL (0x74000000),  // name = heartbeat
  CORBA::tk_boolean,

  19, ACE_NTOHL (0x68656172), ACE_NTOHL (0x74626561), ACE_NTOHL (0x745f696e), ACE_NTOHL (0x74657276), ACE_NTOHL (0x616c0000),  // name = heartbeat_interval
  CORBA::tk_alias, // typecode kind for typedefs
  56, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x54696d65), ACE_NTOHL (0x42617365), ACE_NTOHL (0x2f54696d), ACE_NTOHL (0x65543a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/TimeBase/TimeT:1.0
    6, ACE_NTOHL (0x54696d65), ACE_NTOHL (0x54000000),  // name = TimeT
    CORBA::tk_ulonglong,


  18, ACE_NTOHL (0x68656172), ACE_NTOHL (0x74626561), ACE_NTOHL (0x745f7469), ACE_NTOHL (0x6d656f75), ACE_NTOHL (0x74000000),  // name = heartbeat_timeout
  CORBA::tk_alias, // typecode kind for typedefs
  56, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x54696d65), ACE_NTOHL (0x42617365), ACE_NTOHL (0x2f54696d), ACE_NTOHL (0x65543a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/TimeBase/TimeT:1.0
    6, ACE_NTOHL (0x54696d65), ACE_NTOHL (0x54000000),  // name = TimeT
    CORBA::tk_ulonglong,


};
static CORBA::TypeCode _tc_TAO_tc_FT_HeartbeatPolicyValue (CORBA::tk_struct, sizeof (_oc_FT_HeartbeatPolicyValue), (char *) &_oc_FT_HeartbeatPolicyValue, 0, sizeof (FT::HeartbeatPolicyValue));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_HeartbeatPolicyValue, &_tc_TAO_tc_FT_HeartbeatPolicyValue)
TAO_NAMESPACE_END
void FT_HeartbeatPolicyValue::_tao_any_destructor (void *x)
{
  FT_HeartbeatPolicyValue *tmp = ACE_static_cast (FT_HeartbeatPolicyValue*,x);
  delete tmp;
}


// default constructor
FT_HeartbeatPolicy::FT_HeartbeatPolicy (void)
{}

// destructor
FT_HeartbeatPolicy::~FT_HeartbeatPolicy (void)
{}

void FT_HeartbeatPolicy::_tao_any_destructor (void *x)
{
  FT_HeartbeatPolicy *tmp = ACE_static_cast (FT_HeartbeatPolicy*,x);
  CORBA::release (tmp);
}

FT_HeartbeatPolicy_ptr FT_HeartbeatPolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return FT_HeartbeatPolicy::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/FT/HeartbeatPolicy:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (FT_HeartbeatPolicy::_nil ());
      if (is_a == 0)
        return FT_HeartbeatPolicy::_nil ();
    }
  return FT_HeartbeatPolicy::_unchecked_narrow (obj, ACE_TRY_ENV);
}

FT_HeartbeatPolicy_ptr FT_HeartbeatPolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return FT_HeartbeatPolicy::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      FT_HeartbeatPolicy_ptr default_proxy = FT_HeartbeatPolicy::_nil ();

      if (obj->_is_collocated () && _TAO_collocation_FT_HeartbeatPolicy_Stub_Factory_function_pointer != 0)
        {
          default_proxy = _TAO_collocation_FT_HeartbeatPolicy_Stub_Factory_function_pointer (obj);
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::FT::HeartbeatPolicy (stub), FT_HeartbeatPolicy::_nil ());
      #if (TAO_HAS_SMART_PROXIES == 1)
        return TAO_FT_HeartbeatPolicy_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
      #else
        return default_proxy;
      #endif /*TAO_HAS_SMART_PROXIES == 1*/
    }
  else
    return
      ACE_reinterpret_cast
        (
          FT_HeartbeatPolicy_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &FT_HeartbeatPolicy::_narrow
                  )
              )
        );
}

FT_HeartbeatPolicy_ptr
FT_HeartbeatPolicy::_duplicate (FT_HeartbeatPolicy_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

FT_HeartbeatPolicyValue FT_HeartbeatPolicy::heartbeat_policy_value (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  FT_HeartbeatPolicyValue _tao_retval;
  ACE_OS::memset (&_tao_retval, 0, sizeof (FT_HeartbeatPolicyValue));

  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_heartbeat_policy_value",
      27,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN  (_tao_retval);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN  (_tao_retval);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_heartbeat_policy_value",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        CORBA::Short flag = TAO_TWOWAY_RESPONSE_FLAG;

        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_retval)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_heartbeat_policy_value",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        break;

      }
#if (TAO_HAS_INTERCEPTORS == 1)

    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_heartbeat_policy_value",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN  (_tao_retval);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_retval;
}

CORBA::Boolean FT_HeartbeatPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/FT/HeartbeatPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *FT_HeartbeatPolicy::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &::FT::HeartbeatPolicy::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &::CORBA::Policy::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA::Policy_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* FT_HeartbeatPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/FT/HeartbeatPolicy:1.0";
}

static const CORBA::Long _oc_FT_HeartbeatPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f48), ACE_NTOHL (0x65617274), ACE_NTOHL (0x62656174), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63793a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/FT/HeartbeatPolicy:1.0
  16, ACE_NTOHL (0x48656172), ACE_NTOHL (0x74626561), ACE_NTOHL (0x74506f6c), ACE_NTOHL (0x69637900),  // name = HeartbeatPolicy
};
static CORBA::TypeCode _tc_TAO_tc_FT_HeartbeatPolicy (CORBA::tk_objref, sizeof (_oc_FT_HeartbeatPolicy), (char *) &_oc_FT_HeartbeatPolicy, 0, sizeof (FT_HeartbeatPolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_HeartbeatPolicy, &_tc_TAO_tc_FT_HeartbeatPolicy)
TAO_NAMESPACE_END

// default constructor
FT_HeartbeatEnabledPolicy::FT_HeartbeatEnabledPolicy (void)
{}

// destructor
FT_HeartbeatEnabledPolicy::~FT_HeartbeatEnabledPolicy (void)
{}

void FT_HeartbeatEnabledPolicy::_tao_any_destructor (void *x)
{
  FT_HeartbeatEnabledPolicy *tmp = ACE_static_cast (FT_HeartbeatEnabledPolicy*,x);
  CORBA::release (tmp);
}

FT_HeartbeatEnabledPolicy_ptr FT_HeartbeatEnabledPolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return FT_HeartbeatEnabledPolicy::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/FT/HeartbeatEnabledPolicy:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (FT_HeartbeatEnabledPolicy::_nil ());
      if (is_a == 0)
        return FT_HeartbeatEnabledPolicy::_nil ();
    }
  return FT_HeartbeatEnabledPolicy::_unchecked_narrow (obj, ACE_TRY_ENV);
}

FT_HeartbeatEnabledPolicy_ptr FT_HeartbeatEnabledPolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return FT_HeartbeatEnabledPolicy::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      FT_HeartbeatEnabledPolicy_ptr default_proxy = FT_HeartbeatEnabledPolicy::_nil ();

      if (obj->_is_collocated () && _TAO_collocation_FT_HeartbeatEnabledPolicy_Stub_Factory_function_pointer != 0)
        {
          default_proxy = _TAO_collocation_FT_HeartbeatEnabledPolicy_Stub_Factory_function_pointer (obj);
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::FT::HeartbeatEnabledPolicy (stub), FT_HeartbeatEnabledPolicy::_nil ());
      #if (TAO_HAS_SMART_PROXIES == 1)
        return TAO_FT_HeartbeatEnabledPolicy_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
      #else
        return default_proxy;
      #endif /*TAO_HAS_SMART_PROXIES == 1*/
    }
  else
    return
      ACE_reinterpret_cast
        (
          FT_HeartbeatEnabledPolicy_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &FT_HeartbeatEnabledPolicy::_narrow
                  )
              )
        );
}

FT_HeartbeatEnabledPolicy_ptr
FT_HeartbeatEnabledPolicy::_duplicate (FT_HeartbeatEnabledPolicy_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean FT_HeartbeatEnabledPolicy::heartbeat_enabled_policy_value (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::Boolean _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_heartbeat_enabled_policy_value",
      35,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN  (_tao_retval);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN  (_tao_retval);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_heartbeat_enabled_policy_value",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        CORBA::Short flag = TAO_TWOWAY_RESPONSE_FLAG;

        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_heartbeat_enabled_policy_value",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        break;

      }
#if (TAO_HAS_INTERCEPTORS == 1)

    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_heartbeat_enabled_policy_value",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN  (_tao_retval);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_retval;
}

CORBA::Boolean FT_HeartbeatEnabledPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/FT/HeartbeatEnabledPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *FT_HeartbeatEnabledPolicy::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &::FT::HeartbeatEnabledPolicy::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &::CORBA::Policy::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA::Policy_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* FT_HeartbeatEnabledPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/FT/HeartbeatEnabledPolicy:1.0";
}

static const CORBA::Long _oc_FT_HeartbeatEnabledPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  42, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f48), ACE_NTOHL (0x65617274), ACE_NTOHL (0x62656174), ACE_NTOHL (0x456e6162), ACE_NTOHL (0x6c656450), ACE_NTOHL (0x6f6c6963), ACE_NTOHL (0x793a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/FT/HeartbeatEnabledPolicy:1.0
  23, ACE_NTOHL (0x48656172), ACE_NTOHL (0x74626561), ACE_NTOHL (0x74456e61), ACE_NTOHL (0x626c6564), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63790000),  // name = HeartbeatEnabledPolicy
};
static CORBA::TypeCode _tc_TAO_tc_FT_HeartbeatEnabledPolicy (CORBA::tk_objref, sizeof (_oc_FT_HeartbeatEnabledPolicy), (char *) &_oc_FT_HeartbeatEnabledPolicy, 0, sizeof (FT::HeartbeatEnabledPolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_HeartbeatEnabledPolicy, &_tc_TAO_tc_FT_HeartbeatEnabledPolicy)
TAO_NAMESPACE_END
static const CORBA::Long _oc_FT_TypeId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  26, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f54), ACE_NTOHL (0x79706549), ACE_NTOHL (0x643a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/FT/TypeId:1.0
  7, ACE_NTOHL (0x54797065), ACE_NTOHL (0x49640000),  // name = TypeId
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

};
static CORBA::TypeCode _tc_TAO_tc_FT_TypeId (CORBA::tk_alias, sizeof (_oc_FT_TypeId), (char *) &_oc_FT_TypeId, 0, sizeof (FT::TypeId));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_TypeId, &_tc_TAO_tc_FT_TypeId)
TAO_NAMESPACE_END
static const CORBA::Long _oc_FT_ObjectGroup[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f4f), ACE_NTOHL (0x626a6563), ACE_NTOHL (0x7447726f), ACE_NTOHL (0x75703a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/FT/ObjectGroup:1.0
  12, ACE_NTOHL (0x4f626a65), ACE_NTOHL (0x63744772), ACE_NTOHL (0x6f757000),  // name = ObjectGroup
  CORBA::tk_objref,
  52, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f62), ACE_NTOHL (0x6a656374), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Object:1.0
    7, ACE_NTOHL (0x4f626a65), ACE_NTOHL (0x63740000),  // name = Object

};
static CORBA::TypeCode _tc_TAO_tc_FT_ObjectGroup (CORBA::tk_alias, sizeof (_oc_FT_ObjectGroup), (char *) &_oc_FT_ObjectGroup, 0, sizeof (FT::ObjectGroup));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ObjectGroup, &_tc_TAO_tc_FT_ObjectGroup)
TAO_NAMESPACE_END

static const CORBA::Long _oc_FT_Value[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  25, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x46542f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/FT/Value:1.0
  6, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65000000),  // name = Value
  CORBA::tk_any,

};

static CORBA::TypeCode _tc_TAO_tc_FT_Value (CORBA::tk_alias, sizeof (_oc_FT_Value), (char *) &_oc_FT_Value, 0, sizeof (FT::Value));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (FT)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Value, &_tc_TAO_tc_FT_Value)
TAO_NAMESPACE_END


void operator<<= (CORBA::Any &_tao_any, const FT::TagFTGroupTaggedComponent &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      FT::_tc_TagFTGroupTaggedComponent,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, FT::TagFTGroupTaggedComponent *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      FT::_tc_TagFTGroupTaggedComponent,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      FT::TagFTGroupTaggedComponent::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, FT::TagFTGroupTaggedComponent *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const FT::TagFTGroupTaggedComponent*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const FT::TagFTGroupTaggedComponent *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (FT::_tc_TagFTGroupTaggedComponent, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const FT::TagFTGroupTaggedComponent*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      FT::TagFTGroupTaggedComponent *tmp;
      ACE_NEW_RETURN (tmp, FT::TagFTGroupTaggedComponent, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            FT::_tc_TagFTGroupTaggedComponent,
            1,
            ACE_static_cast (void *, tmp),
            FT::TagFTGroupTaggedComponent::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const FT::TagFTPrimaryTaggedComponent &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      FT::_tc_TagFTPrimaryTaggedComponent,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, FT::TagFTPrimaryTaggedComponent *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      FT::_tc_TagFTPrimaryTaggedComponent,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      FT::TagFTPrimaryTaggedComponent::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, FT::TagFTPrimaryTaggedComponent *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const FT::TagFTPrimaryTaggedComponent*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const FT::TagFTPrimaryTaggedComponent *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (FT::_tc_TagFTPrimaryTaggedComponent, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const FT::TagFTPrimaryTaggedComponent*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      FT::TagFTPrimaryTaggedComponent *tmp;
      ACE_NEW_RETURN (tmp, FT::TagFTPrimaryTaggedComponent, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            FT::_tc_TagFTPrimaryTaggedComponent,
            1,
            ACE_static_cast (void *, tmp),
            FT::TagFTPrimaryTaggedComponent::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const FT::FTGroupVersionServiceContext &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      FT::_tc_FTGroupVersionServiceContext,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, FT::FTGroupVersionServiceContext *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      FT::_tc_FTGroupVersionServiceContext,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      FT::FTGroupVersionServiceContext::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, FT::FTGroupVersionServiceContext *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const FT::FTGroupVersionServiceContext*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const FT::FTGroupVersionServiceContext *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (FT::_tc_FTGroupVersionServiceContext, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const FT::FTGroupVersionServiceContext*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      FT::FTGroupVersionServiceContext *tmp;
      ACE_NEW_RETURN (tmp, FT::FTGroupVersionServiceContext, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            FT::_tc_FTGroupVersionServiceContext,
            1,
            ACE_static_cast (void *, tmp),
            FT::FTGroupVersionServiceContext::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const FT::FTRequestServiceContext &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      FT::_tc_FTRequestServiceContext,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, FT::FTRequestServiceContext *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      FT::_tc_FTRequestServiceContext,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      FT::FTRequestServiceContext::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, FT::FTRequestServiceContext *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const FT::FTRequestServiceContext*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const FT::FTRequestServiceContext *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (FT::_tc_FTRequestServiceContext, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const FT::FTRequestServiceContext*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      FT::FTRequestServiceContext *tmp;
      ACE_NEW_RETURN (tmp, FT::FTRequestServiceContext, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            FT::_tc_FTRequestServiceContext,
            1,
            ACE_static_cast (void *, tmp),
            FT::FTRequestServiceContext::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

FT::RequestDurationPolicy_ptr (*_TAO_collocation_FT_RequestDurationPolicy_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, FT::RequestDurationPolicy_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        FT::_tc_RequestDurationPolicy,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        FT::RequestDurationPolicy::_duplicate (_tao_elem),
        FT::RequestDurationPolicy::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, FT::RequestDurationPolicy_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = FT::RequestDurationPolicy::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (FT::_tc_RequestDurationPolicy, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          FT::_tc_RequestDurationPolicy,
          1,
          _tao_elem,
          FT::RequestDurationPolicy::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = FT::RequestDurationPolicy::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = FT::RequestDurationPolicy::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<FT::RequestDurationPolicy,FT::RequestDurationPolicy_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<FT::RequestDurationPolicy,FT::RequestDurationPolicy_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const FT::TagFTHeartbeatEnabledTaggedComponent &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      FT::_tc_TagFTHeartbeatEnabledTaggedComponent,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, FT::TagFTHeartbeatEnabledTaggedComponent *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      FT::_tc_TagFTHeartbeatEnabledTaggedComponent,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      FT::TagFTHeartbeatEnabledTaggedComponent::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, FT::TagFTHeartbeatEnabledTaggedComponent *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const FT::TagFTHeartbeatEnabledTaggedComponent*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const FT::TagFTHeartbeatEnabledTaggedComponent *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (FT::_tc_TagFTHeartbeatEnabledTaggedComponent, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const FT::TagFTHeartbeatEnabledTaggedComponent*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      FT::TagFTHeartbeatEnabledTaggedComponent *tmp;
      ACE_NEW_RETURN (tmp, FT::TagFTHeartbeatEnabledTaggedComponent, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            FT::_tc_TagFTHeartbeatEnabledTaggedComponent,
            1,
            ACE_static_cast (void *, tmp),
            FT::TagFTHeartbeatEnabledTaggedComponent::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const FT::HeartbeatPolicyValue &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      FT::_tc_HeartbeatPolicyValue,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, FT::HeartbeatPolicyValue *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      FT::_tc_HeartbeatPolicyValue,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      FT::HeartbeatPolicyValue::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, FT::HeartbeatPolicyValue *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const FT::HeartbeatPolicyValue*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const FT::HeartbeatPolicyValue *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (FT::_tc_HeartbeatPolicyValue, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const FT::HeartbeatPolicyValue*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      FT::HeartbeatPolicyValue *tmp;
      ACE_NEW_RETURN (tmp, FT::HeartbeatPolicyValue, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            FT::_tc_HeartbeatPolicyValue,
            1,
            ACE_static_cast (void *, tmp),
            FT::HeartbeatPolicyValue::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

FT::HeartbeatPolicy_ptr (*_TAO_collocation_FT_HeartbeatPolicy_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, FT::HeartbeatPolicy_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        FT::_tc_HeartbeatPolicy,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        FT::HeartbeatPolicy::_duplicate (_tao_elem),
        FT::HeartbeatPolicy::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, FT::HeartbeatPolicy_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = FT::HeartbeatPolicy::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (FT::_tc_HeartbeatPolicy, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          FT::_tc_HeartbeatPolicy,
          1,
          _tao_elem,
          FT::HeartbeatPolicy::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = FT::HeartbeatPolicy::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = FT::HeartbeatPolicy::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<FT::HeartbeatPolicy,FT::HeartbeatPolicy_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<FT::HeartbeatPolicy,FT::HeartbeatPolicy_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

FT::HeartbeatEnabledPolicy_ptr (*_TAO_collocation_FT_HeartbeatEnabledPolicy_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, FT::HeartbeatEnabledPolicy_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        FT::_tc_HeartbeatEnabledPolicy,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        FT::HeartbeatEnabledPolicy::_duplicate (_tao_elem),
        FT::HeartbeatEnabledPolicy::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, FT::HeartbeatEnabledPolicy_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = FT::HeartbeatEnabledPolicy::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (FT::_tc_HeartbeatEnabledPolicy, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          FT::_tc_HeartbeatEnabledPolicy,
          1,
          _tao_elem,
          FT::HeartbeatEnabledPolicy::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = FT::HeartbeatEnabledPolicy::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = FT::HeartbeatEnabledPolicy::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<FT::HeartbeatEnabledPolicy,FT::HeartbeatEnabledPolicy_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<FT::HeartbeatEnabledPolicy,FT::HeartbeatEnabledPolicy_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

#endif /*TAO_HAS_FT_CORBA == 1 */
