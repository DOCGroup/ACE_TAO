$Id$

This is a simple application intended to test Fault Tolerant Corba.

The server implements the IDL in FT_TestReplica.idl which defines 
the interface FT_TEST::TestReplica  .

FT_TEST::TestReplica inherits from PullMonitorable and Checkpointable
to provide access needed by FT Corba's FaultDetector and Orb.

An FT_TEST::TestReplica contains a long counter.  Methods are defined 
to set, increment, and get the value of the counter.  The counter 
is also exposed as an attribute named counter.  (i.e. set(x) is 
exactly equivalent to counter(x), and get() is exactly equivalent 
to counter())

In addition there is a method named die that lets the client request
a server "failure" at a variety of interesting times.  See the "die"
command described below or the FT_TEST::TestReplica::Bane enum in the IDL 
to find out when death can be scheduled.

The client provides a command interface to operate on the server.
Tests may be run manually by typing commands, or may be automated by
reading the commands from a file.

Commands consist of a single character followed by an optional number
(with no space between).  For example: =10 sets the value of the counter
to 10.  +5 increments the counter by 5 (thereby setting the value to 15).

Each command must be at the beginning of a separate line.
Everything after the command (and operand if any) is ignored.
Valid commands are:
  Access via method call:
    =N    set counter to N
    cN    get counter and compare to N (c stands for "check"
    +N    increment counter by N
    -N    decrement counter by N
  Access as attribute:
    >N    set attribute to N
    <     get attribite
  Try methods to be used by fault tolerant infrastructure:
    !     is_alive
    s     get_state
    S     set_state
    u     get_update
    U     set_update
  Simulate failure:
    dN    die on condition:
 Logistics commands:
   #    ignore this line (comment).
   vN    set verbosity:
   q    quit (end the client, not the replica(s).)
   q1   quit (end the client, and shutdown the currently active replica.)
   ?    help (this message)


The conditions recognized on the 'd' command are:
      0 don't die
      1 immediately
      2 during next get
      3 before next set
      4 after next set
      5 before next increment
      6 after next increment
      7 during next attribute get
      8 before next attribute set
      9 after next attribute set
      10 during get update
      11 before set update
      12 after set update
      13 during get state
      14 before set state
      15 after set state
      16 during is alive
      17 is_alive returns false

The verbosity levels:
     0 silent  -- Do not check the counter value.
     1 quiet   -- Check the counter value after every command.  
                  On mismatch generate an error report to cout.
     2 normal  -- Display the counter value to cout after every command 
                  (default.)
     3 noisy   -- Echo commmands to cout.
     4 loud    -- Echo all CORBA calls to cout immediately before calling 
                  the method.

To run:
Start one or more FT_Replicas.  Use a -o <filename> to tell the replica
where to write its ior..

Start the FT_Client with -f file1<,filen>...  (i.e. a comma separated list
of replica IOR files.  To read commands from a file, use -c <command file>

The counter is persistent and will survive server failures.  It's 
stored in a file named persistent.dat.  

Replicas of the server may be run in separate directories to simulate 
replicated stateful objects (i.e. mirrored databases) , or multiple 
replicas can be run in the same directory to simulate a server with a 
"real-world" domain action  (i.e. "fire the retro rockets" 
or "expose the patient to theraputic radiation.")
