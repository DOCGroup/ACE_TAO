// $Id$

// ============================================================================
//
// = LIBRARY
//    TAO/tests/IDL_Test
//
// = FILENAME
//    reopened_modules.idl
//
// = DESCRIPTION
//    This file contains examples of IDL code that has 
//    caused problems in the past for the TAO IDL
//    compiler. This test is to make sure the problems
//    stay fixed.
//
// = AUTHORS
//    Jeff Parsons <parsons@cs.wustl.edu> and TAO users.
//
// ============================================================================

// These examples test the lookup abilities of the
// TAO IDL compiler, with reopened modules.

// Tests lookup function when modules are reopened by
// a chain of inclusions
#include "reopen_include2.idl"

module A 
{
  module B 
  {
    interface x1 {};
  };
};

module A 
{
  module B
  {
    module C 
    {
      interface x2 
      {
        // 'A::B::' should be implicit
        void op1 (in x1 obj);
        // 'A::' should be implicit
        void op2 (in B::x1 obj);
        // Just for reference
        void op3 (in A::B::x1 obj);
      };
    };
  };
};

// Each occurrence of Party and Person should be
// recognized as being in the same scope as the
// previous occurrence(s).

module dot 
{ 
  interface Party;

  interface Person 
    {
      attribute Party someParty;
    };
};

module dot 
{ 
  interface Party 
    {
      attribute Person somePerson;
    };
};

// Should be no problem in lookup of all the
// arguments in Operation.
module Outside
{
  module Reopened
    {
      typedef short Tricky;
    };

  typedef long Tricky;

  module Reopened
    {
      typedef float Newdef;
    };
};

interface OpHolder
  {

    void  Operation (in ::Outside::Tricky p1,
                     out ::Outside::Reopened::Tricky p2,
                     inout ::Outside::Reopened::Newdef p3);
  };

// This particular combination used to cause IDL compiler
// to go into an infinite loop looking for return type to
// getInfo(). Partial solution got rid of infinite loop, 
// but erroneously returned ::com from lookup.
module com {};

module com 
{
  module mr 
    {
      typedef short info;
    };
};

module com 
{
  interface IFace
    {
      com::mr::info getInfo ();
    };
};

// Modules X and Y are also included from reopene_include2.idl.
// There were problems with the lookup of Y::Z and X::Ex.
module Y 
{
   interface Z {};
};

module X
{
   exception Ex {};

   interface BI : Y::Z 
   {
     void method () raises (X::Ex);
   };
};

// Reopened from reopen_include2.idl inclusion. There
// was a problem with the inheritance lookup.
module XX 
{
  interface blah_intfc;

  interface blah_intfc 
  {
    void op1();
  };

  interface blah0 : blah_intfc 
  {
    void op0();
  };
};

// Had lookup problems with the operation args and
// return type.
module frag
{
  interface frag_iface {};
};

module frag
{
  typedef long ret_long;
};

interface gather
{
  frag::ret_long op (in frag::dub_seq inarg,
                     inout frag::pug inoutarg,
                     out frag::frag_iface outarg);
};

// Had problems with second opening of module using
// types declared between the openings.
module foo
{
  typedef long longdef;
};

typedef long longdef2;

struct bar {short s;};

module foo
{
  struct foo_struct
  {
    longdef longval;
    longdef2 longval2;
  };

  interface obj
  {
    void op (in bar inarg);
  };
};

