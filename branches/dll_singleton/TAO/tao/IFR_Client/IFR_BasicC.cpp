// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#include "IFR_BasicC.h"

#include "tao/Stub.h"
#include "tao/Invocation.h"
#include "tao/PortableInterceptor.h"

#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#include "tao/ClientRequestInfo_i.h"
#include "tao/ClientInterceptorAdapter.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */

#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "IFR_BasicC.i"
#endif /* !defined INLINE */


CORBA_Repository_ptr
tao_CORBA_Repository_duplicate (
    CORBA_Repository_ptr p
  )
{
  return CORBA_Repository::_duplicate (p);
}

void
tao_CORBA_Repository_release (
    CORBA_Repository_ptr p
  )
{
  CORBA::release (p);
}

CORBA_Repository_ptr
tao_CORBA_Repository_nil (
    void
  )
{
  return CORBA_Repository::_nil ();
}

CORBA_Repository_ptr
tao_CORBA_Repository_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA_Repository::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_Repository_upcast (
    void *src
  )
{
  CORBA_Repository **tmp =
    ACE_static_cast (CORBA_Repository **, src);
  return *tmp;
}

int CORBA_Repository::_tao_class_id = 0;

// *************************************************************
// Operations for class CORBA_Repository_var
// *************************************************************

CORBA_Repository_var::CORBA_Repository_var (void) // default constructor
  : ptr_ (CORBA_Repository::_nil ())
{}

::CORBA_Repository_ptr
CORBA_Repository_var::ptr (void) const
{
  return this->ptr_;
}

CORBA_Repository_var::CORBA_Repository_var (const ::CORBA_Repository_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (CORBA_Repository::_duplicate (p.ptr ()))
{}

CORBA_Repository_var::~CORBA_Repository_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

CORBA_Repository_var &
CORBA_Repository_var::operator= (CORBA_Repository_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA_Repository_var &
CORBA_Repository_var::operator= (const ::CORBA_Repository_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA_Repository::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA_Repository_var::operator const ::CORBA_Repository_ptr &() const // cast
{
  return this->ptr_;
}

CORBA_Repository_var::operator ::CORBA_Repository_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_Repository_ptr
CORBA_Repository_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA_Repository_ptr
CORBA_Repository_var::in (void) const
{
  return this->ptr_;
}

::CORBA_Repository_ptr &
CORBA_Repository_var::inout (void)
{
  return this->ptr_;
}

::CORBA_Repository_ptr &
CORBA_Repository_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_Repository::_nil ();
  return this->ptr_;
}

::CORBA_Repository_ptr
CORBA_Repository_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA_Repository_ptr val = this->ptr_;
  this->ptr_ = ::CORBA_Repository::_nil ();
  return val;
}

::CORBA_Repository_ptr
CORBA_Repository_var::tao_duplicate (CORBA_Repository_ptr p)
{
  return ::CORBA_Repository::_duplicate (p);
}

void
CORBA_Repository_var::tao_release (CORBA_Repository_ptr p)
{
  CORBA::release (p);
}

::CORBA_Repository_ptr
CORBA_Repository_var::tao_nil (void)
{
  return ::CORBA_Repository::_nil ();
}

::CORBA_Repository_ptr
CORBA_Repository_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA_Repository::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA_Repository_var::tao_upcast (void *src)
{
  CORBA_Repository **tmp =
    ACE_static_cast (CORBA_Repository **, src);
  return *tmp;
}

// *************************************************************
// Operations for class CORBA_Repository_out
// *************************************************************

CORBA_Repository_out::CORBA_Repository_out (CORBA_Repository_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA_Repository::_nil ();
}

CORBA_Repository_out::CORBA_Repository_out (CORBA_Repository_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_Repository::_nil ();
}

CORBA_Repository_out::CORBA_Repository_out (const ::CORBA_Repository_out &p) // copy constructor
  : ptr_ (ACE_const_cast (CORBA_Repository_out &, p).ptr_)
{}

::CORBA_Repository_out &
CORBA_Repository_out::operator= (const ::CORBA_Repository_out &p)
{
  this->ptr_ = ACE_const_cast (CORBA_Repository_out&, p).ptr_;
  return *this;
}

CORBA_Repository_out &
CORBA_Repository_out::operator= (const ::CORBA_Repository_var &p)
{
  this->ptr_ = ::CORBA_Repository::_duplicate (p.ptr ());
  return *this;
}

CORBA_Repository_out &
CORBA_Repository_out::operator= (CORBA_Repository_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA_Repository_out::operator ::CORBA_Repository_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_Repository_ptr &
CORBA_Repository_out::ptr (void) // ptr
{
  return this->ptr_;
}

::CORBA_Repository_ptr
CORBA_Repository_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_CORBA_Repository_lookup_id : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Repository_lookup_id (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * search_id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_Contained_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_Repository_lookup_id (const TAO_ClientRequestInfo_CORBA_Repository_lookup_id &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Repository_lookup_id &);

  const char * search_id_;
  CORBA_Contained_ptr _result;
};

TAO_ClientRequestInfo_CORBA_Repository_lookup_id::TAO_ClientRequestInfo_CORBA_Repository_lookup_id (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * search_id
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    search_id_ (search_id)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Repository_lookup_id::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= search_id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Repository_lookup_id::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_Repository_lookup_id::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_Repository_lookup_id::result (CORBA_Contained_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_Repository_get_canonical_typecode : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Repository_get_canonical_typecode (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::TypeCode_ptr tc
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::TypeCode_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_Repository_get_canonical_typecode (const TAO_ClientRequestInfo_CORBA_Repository_get_canonical_typecode &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Repository_get_canonical_typecode &);

  CORBA::TypeCode_ptr tc_;
  CORBA::TypeCode_ptr _result;
};

TAO_ClientRequestInfo_CORBA_Repository_get_canonical_typecode::TAO_ClientRequestInfo_CORBA_Repository_get_canonical_typecode (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::TypeCode_ptr tc
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    tc_ (tc)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Repository_get_canonical_typecode::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= tc_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Repository_get_canonical_typecode::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_Repository_get_canonical_typecode::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_Repository_get_canonical_typecode::result (CORBA::TypeCode_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_Repository_get_primitive : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Repository_get_primitive (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::PrimitiveKind & kind
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_PrimitiveDef_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_Repository_get_primitive (const TAO_ClientRequestInfo_CORBA_Repository_get_primitive &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Repository_get_primitive &);

  const CORBA::PrimitiveKind & kind_;
  CORBA_PrimitiveDef_ptr _result;
};

TAO_ClientRequestInfo_CORBA_Repository_get_primitive::TAO_ClientRequestInfo_CORBA_Repository_get_primitive (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::PrimitiveKind & kind
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    kind_ (kind)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Repository_get_primitive::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->kind_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Repository_get_primitive::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_Repository_get_primitive::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_Repository_get_primitive::result (CORBA_PrimitiveDef_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_Repository_create_string : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Repository_create_string (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ULong & bound
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_StringDef_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_Repository_create_string (const TAO_ClientRequestInfo_CORBA_Repository_create_string &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Repository_create_string &);

  const CORBA::ULong & bound_;
  CORBA_StringDef_ptr _result;
};

TAO_ClientRequestInfo_CORBA_Repository_create_string::TAO_ClientRequestInfo_CORBA_Repository_create_string (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA::ULong & bound
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    bound_ (bound)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Repository_create_string::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= bound_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Repository_create_string::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_Repository_create_string::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_Repository_create_string::result (CORBA_StringDef_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_Repository_create_wstring : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Repository_create_wstring (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ULong & bound
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_WstringDef_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_Repository_create_wstring (const TAO_ClientRequestInfo_CORBA_Repository_create_wstring &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Repository_create_wstring &);

  const CORBA::ULong & bound_;
  CORBA_WstringDef_ptr _result;
};

TAO_ClientRequestInfo_CORBA_Repository_create_wstring::TAO_ClientRequestInfo_CORBA_Repository_create_wstring (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA::ULong & bound
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    bound_ (bound)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Repository_create_wstring::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= bound_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Repository_create_wstring::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_Repository_create_wstring::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_Repository_create_wstring::result (CORBA_WstringDef_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_Repository_create_sequence : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Repository_create_sequence (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ULong & bound,
      CORBA_IDLType_ptr element_type
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_SequenceDef_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_Repository_create_sequence (const TAO_ClientRequestInfo_CORBA_Repository_create_sequence &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Repository_create_sequence &);

  const CORBA::ULong & bound_;
  CORBA_IDLType_ptr element_type_;
  CORBA_SequenceDef_ptr _result;
};

TAO_ClientRequestInfo_CORBA_Repository_create_sequence::TAO_ClientRequestInfo_CORBA_Repository_create_sequence (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA::ULong & bound,
    CORBA_IDLType_ptr element_type
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    bound_ (bound),
    element_type_ (element_type)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Repository_create_sequence::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (2);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= bound_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->element_type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Repository_create_sequence::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_Repository_create_sequence::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_Repository_create_sequence::result (CORBA_SequenceDef_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_Repository_create_array : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Repository_create_array (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ULong & length,
      CORBA_IDLType_ptr element_type
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_ArrayDef_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_Repository_create_array (const TAO_ClientRequestInfo_CORBA_Repository_create_array &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Repository_create_array &);

  const CORBA::ULong & length_;
  CORBA_IDLType_ptr element_type_;
  CORBA_ArrayDef_ptr _result;
};

TAO_ClientRequestInfo_CORBA_Repository_create_array::TAO_ClientRequestInfo_CORBA_Repository_create_array (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA::ULong & length,
    CORBA_IDLType_ptr element_type
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    length_ (length),
    element_type_ (element_type)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Repository_create_array::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (2);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= length_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->element_type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Repository_create_array::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_Repository_create_array::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_Repository_create_array::result (CORBA_ArrayDef_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_Repository_create_fixed : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Repository_create_fixed (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::UShort & digits,
      const CORBA::Short & scale
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_FixedDef_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_Repository_create_fixed (const TAO_ClientRequestInfo_CORBA_Repository_create_fixed &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Repository_create_fixed &);

  const CORBA::UShort & digits_;
  const CORBA::Short & scale_;
  CORBA_FixedDef_ptr _result;
};

TAO_ClientRequestInfo_CORBA_Repository_create_fixed::TAO_ClientRequestInfo_CORBA_Repository_create_fixed (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA::UShort & digits,
    const CORBA::Short & scale
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    digits_ (digits),
    scale_ (scale)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Repository_create_fixed::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (2);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= digits_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= scale_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Repository_create_fixed::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_Repository_create_fixed::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_Repository_create_fixed::result (CORBA_FixedDef_ptr result)
{
  // update the result
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation.
//

_TAO_CORBA_Repository_Proxy_Impl::_TAO_CORBA_Repository_Proxy_Impl (void)
{}

_TAO_CORBA_Repository_Remote_Proxy_Impl::_TAO_CORBA_Repository_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA_Contained_ptr _TAO_CORBA_Repository_Remote_Proxy_Impl::lookup_id (
    CORBA_Object *_collocated_tao_target_,
    const char * search_id
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_Contained_ptr _tao_retval = CORBA_Contained::_nil ();
  CORBA_Contained_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "lookup_id",
      9,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Repository_lookup_id ri (
        &_tao_call,
        _collocated_tao_target_,
        search_id
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << search_id)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA_Contained_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

CORBA::TypeCode_ptr _TAO_CORBA_Repository_Remote_Proxy_Impl::get_canonical_typecode (
    CORBA_Object *_collocated_tao_target_,
    CORBA::TypeCode_ptr tc
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_canonical_typecode",
      22,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Repository_get_canonical_typecode ri (
        &_tao_call,
        _collocated_tao_target_,
        tc
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << tc)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA::TypeCode_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

CORBA_PrimitiveDef_ptr _TAO_CORBA_Repository_Remote_Proxy_Impl::get_primitive (
    CORBA_Object *_collocated_tao_target_,
    CORBA::PrimitiveKind kind
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_PrimitiveDef_ptr _tao_retval = CORBA_PrimitiveDef::_nil ();
  CORBA_PrimitiveDef_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_primitive",
      13,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Repository_get_primitive ri (
        &_tao_call,
        _collocated_tao_target_,
        kind
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << kind)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA_PrimitiveDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

CORBA_StringDef_ptr _TAO_CORBA_Repository_Remote_Proxy_Impl::create_string (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong bound
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_StringDef_ptr _tao_retval = CORBA_StringDef::_nil ();
  CORBA_StringDef_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_string",
      13,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Repository_create_string ri (
        &_tao_call,
        _collocated_tao_target_,
        bound
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << bound)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA_StringDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

CORBA_WstringDef_ptr _TAO_CORBA_Repository_Remote_Proxy_Impl::create_wstring (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong bound
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_WstringDef_ptr _tao_retval = CORBA_WstringDef::_nil ();
  CORBA_WstringDef_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_wstring",
      14,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Repository_create_wstring ri (
        &_tao_call,
        _collocated_tao_target_,
        bound
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << bound)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA_WstringDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

CORBA_SequenceDef_ptr _TAO_CORBA_Repository_Remote_Proxy_Impl::create_sequence (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong bound,
    CORBA_IDLType_ptr element_type
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_SequenceDef_ptr _tao_retval = CORBA_SequenceDef::_nil ();
  CORBA_SequenceDef_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_sequence",
      15,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Repository_create_sequence ri (
        &_tao_call,
        _collocated_tao_target_,
        bound,
        element_type
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << bound) &&
              (_tao_out << element_type)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA_SequenceDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

CORBA_ArrayDef_ptr _TAO_CORBA_Repository_Remote_Proxy_Impl::create_array (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong length,
    CORBA_IDLType_ptr element_type
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_ArrayDef_ptr _tao_retval = CORBA_ArrayDef::_nil ();
  CORBA_ArrayDef_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_array",
      12,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Repository_create_array ri (
        &_tao_call,
        _collocated_tao_target_,
        length,
        element_type
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << length) &&
              (_tao_out << element_type)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA_ArrayDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

CORBA_FixedDef_ptr _TAO_CORBA_Repository_Remote_Proxy_Impl::create_fixed (
    CORBA_Object *_collocated_tao_target_,
    CORBA::UShort digits,
    CORBA::Short scale
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_FixedDef_ptr _tao_retval = tao_CORBA_FixedDef_nil ();
  CORBA_FixedDef_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_fixed",
      12,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Repository_create_fixed ri (
        &_tao_call,
        _collocated_tao_target_,
        digits,
        scale
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << digits) &&
              (_tao_out << scale)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA_FixedDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation.
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_CORBA_Repository_Proxy_Broker::_TAO_CORBA_Repository_Proxy_Broker (void)
{
}

_TAO_CORBA_Repository_Proxy_Broker::~_TAO_CORBA_Repository_Proxy_Broker (void)
{
}

_TAO_CORBA_Repository_Proxy_Broker * (*_TAO_CORBA_Repository_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_CORBA_Repository_Remote_Proxy_Broker *
_TAO_CORBA_Repository_Remote_Proxy_Broker::the_TAO_CORBA_Repository_Remote_Proxy_Broker (void)
{
  static ::_TAO_CORBA_Repository_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_CORBA_Repository_Remote_Proxy_Broker::_TAO_CORBA_Repository_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_Repository_Remote_Proxy_Broker::~_TAO_CORBA_Repository_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_Repository_Proxy_Impl&
_TAO_CORBA_Repository_Remote_Proxy_Broker::select_proxy (
  ::CORBA_Repository *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
CORBA_Repository::CORBA_Repository (int collocated)
{
  this->CORBA_Repository_setup_collocation (collocated);
}

// destructor
CORBA_Repository::~CORBA_Repository (void)
{}

void
CORBA_Repository::CORBA_Repository_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_CORBA_Repository_Proxy_Broker_ =
      ::_TAO_CORBA_Repository_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_CORBA_Repository_Proxy_Broker_ =
      ::_TAO_CORBA_Repository_Remote_Proxy_Broker::the_TAO_CORBA_Repository_Remote_Proxy_Broker ();

  this->CORBA_Container_setup_collocation (collocated);
}

void CORBA_Repository::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_Repository *tmp = ACE_static_cast (CORBA_Repository*, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA_Repository_ptr CORBA_Repository::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_Repository::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/Repository:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (CORBA_Repository::_nil ());
      if (is_a == 0)
        return CORBA_Repository::_nil ();
    }
  return CORBA_Repository::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA_Repository_ptr CORBA_Repository::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_Repository::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      CORBA_Repository_ptr default_proxy = CORBA_Repository::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_CORBA_Repository_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::CORBA_Repository (
            stub,
            1,
            obj->_servant ()),

          CORBA_Repository::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::CORBA_Repository (stub, 0, obj->_servant ()), CORBA_Repository::_nil ());
        return default_proxy;
      }
    else
      return
        ACE_reinterpret_cast
          (
            CORBA_Repository_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &CORBA_Repository::_tao_class_id
                    )
                )
          );
}

CORBA_Repository_ptr
CORBA_Repository::_duplicate (CORBA_Repository_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean CORBA_Repository::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Repository:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *CORBA_Repository::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Repository::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Container::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Container_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* CORBA_Repository::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/Repository:1.0";
}

CORBA_Contained_ptr CORBA_Repository::lookup_id (
    const char * search_id
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_Repository_Proxy_Impl &proxy =
    this->the_TAO_CORBA_Repository_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.lookup_id (
      this,
      search_id
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA::TypeCode_ptr CORBA_Repository::get_canonical_typecode (
    CORBA::TypeCode_ptr tc
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_Repository_Proxy_Impl &proxy =
    this->the_TAO_CORBA_Repository_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.get_canonical_typecode (
      this,
      tc
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA_PrimitiveDef_ptr CORBA_Repository::get_primitive (
    CORBA::PrimitiveKind kind
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_Repository_Proxy_Impl &proxy =
    this->the_TAO_CORBA_Repository_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.get_primitive (
      this,
      kind
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA_StringDef_ptr CORBA_Repository::create_string (
    CORBA::ULong bound
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_Repository_Proxy_Impl &proxy =
    this->the_TAO_CORBA_Repository_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.create_string (
      this,
      bound
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA_WstringDef_ptr CORBA_Repository::create_wstring (
    CORBA::ULong bound
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_Repository_Proxy_Impl &proxy =
    this->the_TAO_CORBA_Repository_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.create_wstring (
      this,
      bound
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA_SequenceDef_ptr CORBA_Repository::create_sequence (
    CORBA::ULong bound,
    CORBA_IDLType_ptr element_type
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_Repository_Proxy_Impl &proxy =
    this->the_TAO_CORBA_Repository_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.create_sequence (
      this,
      bound,
      element_type
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA_ArrayDef_ptr CORBA_Repository::create_array (
    CORBA::ULong length,
    CORBA_IDLType_ptr element_type
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_Repository_Proxy_Impl &proxy =
    this->the_TAO_CORBA_Repository_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.create_array (
      this,
      length,
      element_type
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA_FixedDef_ptr CORBA_Repository::create_fixed (
    CORBA::UShort digits,
    CORBA::Short scale
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_Repository_Proxy_Impl &proxy =
    this->the_TAO_CORBA_Repository_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.create_fixed (
      this,
      digits,
      scale
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA_ModuleDef_ptr
tao_CORBA_ModuleDef_duplicate (
    CORBA_ModuleDef_ptr p
  )
{
  return CORBA_ModuleDef::_duplicate (p);
}

void
tao_CORBA_ModuleDef_release (
    CORBA_ModuleDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA_ModuleDef_ptr
tao_CORBA_ModuleDef_nil (
    void
  )
{
  return CORBA_ModuleDef::_nil ();
}

CORBA_ModuleDef_ptr
tao_CORBA_ModuleDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA_ModuleDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_ModuleDef_upcast (
    void *src
  )
{
  CORBA_ModuleDef **tmp =
    ACE_static_cast (CORBA_ModuleDef **, src);
  return *tmp;
}

int CORBA_ModuleDef::_tao_class_id = 0;

// *************************************************************
// Operations for class CORBA_ModuleDef_var
// *************************************************************

CORBA_ModuleDef_var::CORBA_ModuleDef_var (void) // default constructor
  : ptr_ (CORBA_ModuleDef::_nil ())
{}

::CORBA_ModuleDef_ptr
CORBA_ModuleDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA_ModuleDef_var::CORBA_ModuleDef_var (const ::CORBA_ModuleDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (CORBA_ModuleDef::_duplicate (p.ptr ()))
{}

CORBA_ModuleDef_var::~CORBA_ModuleDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

CORBA_ModuleDef_var &
CORBA_ModuleDef_var::operator= (CORBA_ModuleDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA_ModuleDef_var &
CORBA_ModuleDef_var::operator= (const ::CORBA_ModuleDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA_ModuleDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA_ModuleDef_var::operator const ::CORBA_ModuleDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA_ModuleDef_var::operator ::CORBA_ModuleDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_ModuleDef_ptr
CORBA_ModuleDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA_ModuleDef_ptr
CORBA_ModuleDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA_ModuleDef_ptr &
CORBA_ModuleDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA_ModuleDef_ptr &
CORBA_ModuleDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_ModuleDef::_nil ();
  return this->ptr_;
}

::CORBA_ModuleDef_ptr
CORBA_ModuleDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA_ModuleDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA_ModuleDef::_nil ();
  return val;
}

::CORBA_ModuleDef_ptr
CORBA_ModuleDef_var::tao_duplicate (CORBA_ModuleDef_ptr p)
{
  return ::CORBA_ModuleDef::_duplicate (p);
}

void
CORBA_ModuleDef_var::tao_release (CORBA_ModuleDef_ptr p)
{
  CORBA::release (p);
}

::CORBA_ModuleDef_ptr
CORBA_ModuleDef_var::tao_nil (void)
{
  return ::CORBA_ModuleDef::_nil ();
}

::CORBA_ModuleDef_ptr
CORBA_ModuleDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA_ModuleDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA_ModuleDef_var::tao_upcast (void *src)
{
  CORBA_ModuleDef **tmp =
    ACE_static_cast (CORBA_ModuleDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class CORBA_ModuleDef_out
// *************************************************************

CORBA_ModuleDef_out::CORBA_ModuleDef_out (CORBA_ModuleDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA_ModuleDef::_nil ();
}

CORBA_ModuleDef_out::CORBA_ModuleDef_out (CORBA_ModuleDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_ModuleDef::_nil ();
}

CORBA_ModuleDef_out::CORBA_ModuleDef_out (const ::CORBA_ModuleDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (CORBA_ModuleDef_out &, p).ptr_)
{}

::CORBA_ModuleDef_out &
CORBA_ModuleDef_out::operator= (const ::CORBA_ModuleDef_out &p)
{
  this->ptr_ = ACE_const_cast (CORBA_ModuleDef_out&, p).ptr_;
  return *this;
}

CORBA_ModuleDef_out &
CORBA_ModuleDef_out::operator= (const ::CORBA_ModuleDef_var &p)
{
  this->ptr_ = ::CORBA_ModuleDef::_duplicate (p.ptr ());
  return *this;
}

CORBA_ModuleDef_out &
CORBA_ModuleDef_out::operator= (CORBA_ModuleDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA_ModuleDef_out::operator ::CORBA_ModuleDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_ModuleDef_ptr &
CORBA_ModuleDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::CORBA_ModuleDef_ptr
CORBA_ModuleDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation.
//

_TAO_CORBA_ModuleDef_Proxy_Impl::_TAO_CORBA_ModuleDef_Proxy_Impl (void)
{}

_TAO_CORBA_ModuleDef_Remote_Proxy_Impl::_TAO_CORBA_ModuleDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods


//
//            End  Base & Remote  Proxy Implemeentation.
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_CORBA_ModuleDef_Proxy_Broker::_TAO_CORBA_ModuleDef_Proxy_Broker (void)
{
}

_TAO_CORBA_ModuleDef_Proxy_Broker::~_TAO_CORBA_ModuleDef_Proxy_Broker (void)
{
}

_TAO_CORBA_ModuleDef_Proxy_Broker * (*_TAO_CORBA_ModuleDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_CORBA_ModuleDef_Remote_Proxy_Broker *
_TAO_CORBA_ModuleDef_Remote_Proxy_Broker::the_TAO_CORBA_ModuleDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_CORBA_ModuleDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_CORBA_ModuleDef_Remote_Proxy_Broker::_TAO_CORBA_ModuleDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_ModuleDef_Remote_Proxy_Broker::~_TAO_CORBA_ModuleDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_ModuleDef_Proxy_Impl&
_TAO_CORBA_ModuleDef_Remote_Proxy_Broker::select_proxy (
  ::CORBA_ModuleDef *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
CORBA_ModuleDef::CORBA_ModuleDef (int collocated)
{
  this->CORBA_ModuleDef_setup_collocation (collocated);
}

// destructor
CORBA_ModuleDef::~CORBA_ModuleDef (void)
{}

void
CORBA_ModuleDef::CORBA_ModuleDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_CORBA_ModuleDef_Proxy_Broker_ =
      ::_TAO_CORBA_ModuleDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_CORBA_ModuleDef_Proxy_Broker_ =
      ::_TAO_CORBA_ModuleDef_Remote_Proxy_Broker::the_TAO_CORBA_ModuleDef_Remote_Proxy_Broker ();

  this->CORBA_Container_setup_collocation (collocated);

  this->CORBA_Contained_setup_collocation (collocated);
}

void CORBA_ModuleDef::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_ModuleDef *tmp = ACE_static_cast (CORBA_ModuleDef*, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA_ModuleDef_ptr CORBA_ModuleDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_ModuleDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/ModuleDef:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (CORBA_ModuleDef::_nil ());
      if (is_a == 0)
        return CORBA_ModuleDef::_nil ();
    }
  return CORBA_ModuleDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA_ModuleDef_ptr CORBA_ModuleDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_ModuleDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      CORBA_ModuleDef_ptr default_proxy = CORBA_ModuleDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_CORBA_ModuleDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::CORBA_ModuleDef (
            stub,
            1,
            obj->_servant ()),

          CORBA_ModuleDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::CORBA_ModuleDef (stub, 0, obj->_servant ()), CORBA_ModuleDef::_nil ());
        return default_proxy;
      }
    else
      return
        ACE_reinterpret_cast
          (
            CORBA_ModuleDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &CORBA_ModuleDef::_tao_class_id
                    )
                )
          );
}

CORBA_ModuleDef_ptr
CORBA_ModuleDef::_duplicate (CORBA_ModuleDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean CORBA_ModuleDef::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ModuleDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *CORBA_ModuleDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_ModuleDef::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Container::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Container_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* CORBA_ModuleDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ModuleDef:1.0";
}

void CORBA_ModuleDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_ModuleDescription *tmp = ACE_static_cast (CORBA_ModuleDescription*, _tao_void_pointer);
  delete tmp;
}

CORBA_ConstantDef_ptr
tao_CORBA_ConstantDef_duplicate (
    CORBA_ConstantDef_ptr p
  )
{
  return CORBA_ConstantDef::_duplicate (p);
}

void
tao_CORBA_ConstantDef_release (
    CORBA_ConstantDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA_ConstantDef_ptr
tao_CORBA_ConstantDef_nil (
    void
  )
{
  return CORBA_ConstantDef::_nil ();
}

CORBA_ConstantDef_ptr
tao_CORBA_ConstantDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA_ConstantDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_ConstantDef_upcast (
    void *src
  )
{
  CORBA_ConstantDef **tmp =
    ACE_static_cast (CORBA_ConstantDef **, src);
  return *tmp;
}

int CORBA_ConstantDef::_tao_class_id = 0;

// *************************************************************
// Operations for class CORBA_ConstantDef_var
// *************************************************************

CORBA_ConstantDef_var::CORBA_ConstantDef_var (void) // default constructor
  : ptr_ (CORBA_ConstantDef::_nil ())
{}

::CORBA_ConstantDef_ptr
CORBA_ConstantDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA_ConstantDef_var::CORBA_ConstantDef_var (const ::CORBA_ConstantDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (CORBA_ConstantDef::_duplicate (p.ptr ()))
{}

CORBA_ConstantDef_var::~CORBA_ConstantDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

CORBA_ConstantDef_var &
CORBA_ConstantDef_var::operator= (CORBA_ConstantDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA_ConstantDef_var &
CORBA_ConstantDef_var::operator= (const ::CORBA_ConstantDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA_ConstantDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA_ConstantDef_var::operator const ::CORBA_ConstantDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA_ConstantDef_var::operator ::CORBA_ConstantDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_ConstantDef_ptr
CORBA_ConstantDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA_ConstantDef_ptr
CORBA_ConstantDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA_ConstantDef_ptr &
CORBA_ConstantDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA_ConstantDef_ptr &
CORBA_ConstantDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_ConstantDef::_nil ();
  return this->ptr_;
}

::CORBA_ConstantDef_ptr
CORBA_ConstantDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA_ConstantDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA_ConstantDef::_nil ();
  return val;
}

::CORBA_ConstantDef_ptr
CORBA_ConstantDef_var::tao_duplicate (CORBA_ConstantDef_ptr p)
{
  return ::CORBA_ConstantDef::_duplicate (p);
}

void
CORBA_ConstantDef_var::tao_release (CORBA_ConstantDef_ptr p)
{
  CORBA::release (p);
}

::CORBA_ConstantDef_ptr
CORBA_ConstantDef_var::tao_nil (void)
{
  return ::CORBA_ConstantDef::_nil ();
}

::CORBA_ConstantDef_ptr
CORBA_ConstantDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA_ConstantDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA_ConstantDef_var::tao_upcast (void *src)
{
  CORBA_ConstantDef **tmp =
    ACE_static_cast (CORBA_ConstantDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class CORBA_ConstantDef_out
// *************************************************************

CORBA_ConstantDef_out::CORBA_ConstantDef_out (CORBA_ConstantDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA_ConstantDef::_nil ();
}

CORBA_ConstantDef_out::CORBA_ConstantDef_out (CORBA_ConstantDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_ConstantDef::_nil ();
}

CORBA_ConstantDef_out::CORBA_ConstantDef_out (const ::CORBA_ConstantDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (CORBA_ConstantDef_out &, p).ptr_)
{}

::CORBA_ConstantDef_out &
CORBA_ConstantDef_out::operator= (const ::CORBA_ConstantDef_out &p)
{
  this->ptr_ = ACE_const_cast (CORBA_ConstantDef_out&, p).ptr_;
  return *this;
}

CORBA_ConstantDef_out &
CORBA_ConstantDef_out::operator= (const ::CORBA_ConstantDef_var &p)
{
  this->ptr_ = ::CORBA_ConstantDef::_duplicate (p.ptr ());
  return *this;
}

CORBA_ConstantDef_out &
CORBA_ConstantDef_out::operator= (CORBA_ConstantDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA_ConstantDef_out::operator ::CORBA_ConstantDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_ConstantDef_ptr &
CORBA_ConstantDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::CORBA_ConstantDef_ptr
CORBA_ConstantDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_CORBA_ConstantDef_type_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ConstantDef_type_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::TypeCode_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_ConstantDef_type_get (const TAO_ClientRequestInfo_CORBA_ConstantDef_type_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_ConstantDef_type_get &);

  CORBA::TypeCode_ptr _result;
};

TAO_ClientRequestInfo_CORBA_ConstantDef_type_get::TAO_ClientRequestInfo_CORBA_ConstantDef_type_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ConstantDef_type_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ConstantDef_type_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_ConstantDef_type_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_ConstantDef_type_get::result (CORBA::TypeCode_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_IDLType_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_get (const TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_get &);

  CORBA_IDLType_ptr _result;
};

TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_get::TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_get::result (CORBA_IDLType_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA_IDLType_ptr type_def
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_set (const TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_set &);
  void operator= (const TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_set &);

  CORBA_IDLType_ptr type_def_;

};

TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_set::TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA_IDLType_ptr type_def
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    type_def_ (type_def)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->type_def_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

class TAO_ClientRequestInfo_CORBA_ConstantDef_value_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ConstantDef_value_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Any * result);

private:
  TAO_ClientRequestInfo_CORBA_ConstantDef_value_get (const TAO_ClientRequestInfo_CORBA_ConstantDef_value_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_ConstantDef_value_get &);

  CORBA::Any * _result;
};

TAO_ClientRequestInfo_CORBA_ConstantDef_value_get::TAO_ClientRequestInfo_CORBA_ConstantDef_value_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ConstantDef_value_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ConstantDef_value_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_ConstantDef_value_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_ConstantDef_value_get::result (CORBA::Any * result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_ConstantDef_value_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ConstantDef_value_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::Any & value
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_CORBA_ConstantDef_value_set (const TAO_ClientRequestInfo_CORBA_ConstantDef_value_set &);
  void operator= (const TAO_ClientRequestInfo_CORBA_ConstantDef_value_set &);

  const CORBA::Any & value_;

};

TAO_ClientRequestInfo_CORBA_ConstantDef_value_set::TAO_ClientRequestInfo_CORBA_ConstantDef_value_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA::Any & value
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    value_ (value)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ConstantDef_value_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= value_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ConstantDef_value_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_ConstantDef_value_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation.
//

_TAO_CORBA_ConstantDef_Proxy_Impl::_TAO_CORBA_ConstantDef_Proxy_Impl (void)
{}

_TAO_CORBA_ConstantDef_Remote_Proxy_Impl::_TAO_CORBA_ConstantDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::TypeCode_ptr _TAO_CORBA_ConstantDef_Remote_Proxy_Impl::type (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_type",
      9,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ConstantDef_type_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA::TypeCode_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

CORBA_IDLType_ptr _TAO_CORBA_ConstantDef_Remote_Proxy_Impl::type_def (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_IDLType_ptr _tao_retval = CORBA_IDLType::_nil ();
  CORBA_IDLType_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_type_def",
      13,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA_IDLType_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

void _TAO_CORBA_ConstantDef_Remote_Proxy_Impl::type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA_IDLType_ptr type_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_type_def",
      13,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_set ri (
        &_tao_call,
        _collocated_tao_target_,
        type_def
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << type_def)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }


#if TAO_HAS_INTERCEPTORS == 1

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }

}

CORBA::Any * _TAO_CORBA_ConstantDef_Remote_Proxy_Impl::value (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::Any *_tao_retval = 0;


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  ACE_NEW_RETURN (_tao_retval, CORBA::Any, _tao_retval);
  CORBA::Any_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_value",
      10,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ConstantDef_value_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA::Any * _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

void _TAO_CORBA_ConstantDef_Remote_Proxy_Impl::value (
    CORBA_Object *_collocated_tao_target_,
    const CORBA::Any & value
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_value",
      10,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ConstantDef_value_set ri (
        &_tao_call,
        _collocated_tao_target_,
        value
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << value)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }


#if TAO_HAS_INTERCEPTORS == 1

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }

}


//
//            End  Base & Remote  Proxy Implemeentation.
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_CORBA_ConstantDef_Proxy_Broker::_TAO_CORBA_ConstantDef_Proxy_Broker (void)
{
}

_TAO_CORBA_ConstantDef_Proxy_Broker::~_TAO_CORBA_ConstantDef_Proxy_Broker (void)
{
}

_TAO_CORBA_ConstantDef_Proxy_Broker * (*_TAO_CORBA_ConstantDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_CORBA_ConstantDef_Remote_Proxy_Broker *
_TAO_CORBA_ConstantDef_Remote_Proxy_Broker::the_TAO_CORBA_ConstantDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_CORBA_ConstantDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_CORBA_ConstantDef_Remote_Proxy_Broker::_TAO_CORBA_ConstantDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_ConstantDef_Remote_Proxy_Broker::~_TAO_CORBA_ConstantDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_ConstantDef_Proxy_Impl&
_TAO_CORBA_ConstantDef_Remote_Proxy_Broker::select_proxy (
  ::CORBA_ConstantDef *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
CORBA_ConstantDef::CORBA_ConstantDef (int collocated)
{
  this->CORBA_ConstantDef_setup_collocation (collocated);
}

// destructor
CORBA_ConstantDef::~CORBA_ConstantDef (void)
{}

void
CORBA_ConstantDef::CORBA_ConstantDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_CORBA_ConstantDef_Proxy_Broker_ =
      ::_TAO_CORBA_ConstantDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_CORBA_ConstantDef_Proxy_Broker_ =
      ::_TAO_CORBA_ConstantDef_Remote_Proxy_Broker::the_TAO_CORBA_ConstantDef_Remote_Proxy_Broker ();

  this->CORBA_Contained_setup_collocation (collocated);
}

void CORBA_ConstantDef::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_ConstantDef *tmp = ACE_static_cast (CORBA_ConstantDef*, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA_ConstantDef_ptr CORBA_ConstantDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_ConstantDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/ConstantDef:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (CORBA_ConstantDef::_nil ());
      if (is_a == 0)
        return CORBA_ConstantDef::_nil ();
    }
  return CORBA_ConstantDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA_ConstantDef_ptr CORBA_ConstantDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_ConstantDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      CORBA_ConstantDef_ptr default_proxy = CORBA_ConstantDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_CORBA_ConstantDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::CORBA_ConstantDef (
            stub,
            1,
            obj->_servant ()),

          CORBA_ConstantDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::CORBA_ConstantDef (stub, 0, obj->_servant ()), CORBA_ConstantDef::_nil ());
        return default_proxy;
      }
    else
      return
        ACE_reinterpret_cast
          (
            CORBA_ConstantDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &CORBA_ConstantDef::_tao_class_id
                    )
                )
          );
}

CORBA_ConstantDef_ptr
CORBA_ConstantDef::_duplicate (CORBA_ConstantDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean CORBA_ConstantDef::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ConstantDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *CORBA_ConstantDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_ConstantDef::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* CORBA_ConstantDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ConstantDef:1.0";
}

CORBA::TypeCode_ptr CORBA_ConstantDef::type (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_ConstantDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_ConstantDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.type (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA_IDLType_ptr CORBA_ConstantDef::type_def (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_ConstantDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_ConstantDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.type_def (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

void CORBA_ConstantDef::type_def (
    CORBA_IDLType_ptr type_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_ConstantDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_ConstantDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  proxy.type_def (
      this,
      type_def
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA::Any * CORBA_ConstantDef::value (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_ConstantDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_ConstantDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.value (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

void CORBA_ConstantDef::value (
    const CORBA::Any & value
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_ConstantDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_ConstantDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  proxy.value (
      this,
      value
      ACE_ENV_ARG_PARAMETER
    );
}

void CORBA_ConstantDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_ConstantDescription *tmp = ACE_static_cast (CORBA_ConstantDescription*, _tao_void_pointer);
  delete tmp;
}

CORBA_StructDef_ptr
tao_CORBA_StructDef_duplicate (
    CORBA_StructDef_ptr p
  )
{
  return CORBA_StructDef::_duplicate (p);
}

void
tao_CORBA_StructDef_release (
    CORBA_StructDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA_StructDef_ptr
tao_CORBA_StructDef_nil (
    void
  )
{
  return CORBA_StructDef::_nil ();
}

CORBA_StructDef_ptr
tao_CORBA_StructDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA_StructDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_StructDef_upcast (
    void *src
  )
{
  CORBA_StructDef **tmp =
    ACE_static_cast (CORBA_StructDef **, src);
  return *tmp;
}

int CORBA_StructDef::_tao_class_id = 0;

// *************************************************************
// Operations for class CORBA_StructDef_var
// *************************************************************

CORBA_StructDef_var::CORBA_StructDef_var (void) // default constructor
  : ptr_ (CORBA_StructDef::_nil ())
{}

::CORBA_StructDef_ptr
CORBA_StructDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA_StructDef_var::CORBA_StructDef_var (const ::CORBA_StructDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (CORBA_StructDef::_duplicate (p.ptr ()))
{}

CORBA_StructDef_var::~CORBA_StructDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

CORBA_StructDef_var &
CORBA_StructDef_var::operator= (CORBA_StructDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA_StructDef_var &
CORBA_StructDef_var::operator= (const ::CORBA_StructDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA_StructDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA_StructDef_var::operator const ::CORBA_StructDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA_StructDef_var::operator ::CORBA_StructDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_StructDef_ptr
CORBA_StructDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA_StructDef_ptr
CORBA_StructDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA_StructDef_ptr &
CORBA_StructDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA_StructDef_ptr &
CORBA_StructDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_StructDef::_nil ();
  return this->ptr_;
}

::CORBA_StructDef_ptr
CORBA_StructDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA_StructDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA_StructDef::_nil ();
  return val;
}

::CORBA_StructDef_ptr
CORBA_StructDef_var::tao_duplicate (CORBA_StructDef_ptr p)
{
  return ::CORBA_StructDef::_duplicate (p);
}

void
CORBA_StructDef_var::tao_release (CORBA_StructDef_ptr p)
{
  CORBA::release (p);
}

::CORBA_StructDef_ptr
CORBA_StructDef_var::tao_nil (void)
{
  return ::CORBA_StructDef::_nil ();
}

::CORBA_StructDef_ptr
CORBA_StructDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA_StructDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA_StructDef_var::tao_upcast (void *src)
{
  CORBA_StructDef **tmp =
    ACE_static_cast (CORBA_StructDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class CORBA_StructDef_out
// *************************************************************

CORBA_StructDef_out::CORBA_StructDef_out (CORBA_StructDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA_StructDef::_nil ();
}

CORBA_StructDef_out::CORBA_StructDef_out (CORBA_StructDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_StructDef::_nil ();
}

CORBA_StructDef_out::CORBA_StructDef_out (const ::CORBA_StructDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (CORBA_StructDef_out &, p).ptr_)
{}

::CORBA_StructDef_out &
CORBA_StructDef_out::operator= (const ::CORBA_StructDef_out &p)
{
  this->ptr_ = ACE_const_cast (CORBA_StructDef_out&, p).ptr_;
  return *this;
}

CORBA_StructDef_out &
CORBA_StructDef_out::operator= (const ::CORBA_StructDef_var &p)
{
  this->ptr_ = ::CORBA_StructDef::_duplicate (p.ptr ());
  return *this;
}

CORBA_StructDef_out &
CORBA_StructDef_out::operator= (CORBA_StructDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA_StructDef_out::operator ::CORBA_StructDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_StructDef_ptr &
CORBA_StructDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::CORBA_StructDef_ptr
CORBA_StructDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_CORBA_StructDef_members_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_StructDef_members_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_StructMemberSeq * result);

private:
  TAO_ClientRequestInfo_CORBA_StructDef_members_get (const TAO_ClientRequestInfo_CORBA_StructDef_members_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_StructDef_members_get &);

  CORBA_StructMemberSeq * _result;
};

TAO_ClientRequestInfo_CORBA_StructDef_members_get::TAO_ClientRequestInfo_CORBA_StructDef_members_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_StructDef_members_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_StructDef_members_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_StructDef_members_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_StructDef_members_get::result (CORBA_StructMemberSeq * result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_StructDef_members_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_StructDef_members_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA_StructMemberSeq & members
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_CORBA_StructDef_members_set (const TAO_ClientRequestInfo_CORBA_StructDef_members_set &);
  void operator= (const TAO_ClientRequestInfo_CORBA_StructDef_members_set &);

  const CORBA_StructMemberSeq & members_;

};

TAO_ClientRequestInfo_CORBA_StructDef_members_set::TAO_ClientRequestInfo_CORBA_StructDef_members_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA_StructMemberSeq & members
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    members_ (members)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_StructDef_members_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->members_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_StructDef_members_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_StructDef_members_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation.
//

_TAO_CORBA_StructDef_Proxy_Impl::_TAO_CORBA_StructDef_Proxy_Impl (void)
{}

_TAO_CORBA_StructDef_Remote_Proxy_Impl::_TAO_CORBA_StructDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA_StructMemberSeq * _TAO_CORBA_StructDef_Remote_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_StructMemberSeq *_tao_retval = 0;


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  ACE_NEW_RETURN (_tao_retval, CORBA_StructMemberSeq, _tao_retval);
  CORBA_StructMemberSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_members",
      12,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_StructDef_members_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA_StructMemberSeq * _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

void _TAO_CORBA_StructDef_Remote_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    const CORBA_StructMemberSeq & members
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_members",
      12,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_StructDef_members_set ri (
        &_tao_call,
        _collocated_tao_target_,
        members
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << members)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }


#if TAO_HAS_INTERCEPTORS == 1

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }

}


//
//            End  Base & Remote  Proxy Implemeentation.
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_CORBA_StructDef_Proxy_Broker::_TAO_CORBA_StructDef_Proxy_Broker (void)
{
}

_TAO_CORBA_StructDef_Proxy_Broker::~_TAO_CORBA_StructDef_Proxy_Broker (void)
{
}

_TAO_CORBA_StructDef_Proxy_Broker * (*_TAO_CORBA_StructDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_CORBA_StructDef_Remote_Proxy_Broker *
_TAO_CORBA_StructDef_Remote_Proxy_Broker::the_TAO_CORBA_StructDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_CORBA_StructDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_CORBA_StructDef_Remote_Proxy_Broker::_TAO_CORBA_StructDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_StructDef_Remote_Proxy_Broker::~_TAO_CORBA_StructDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_StructDef_Proxy_Impl&
_TAO_CORBA_StructDef_Remote_Proxy_Broker::select_proxy (
  ::CORBA_StructDef *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
CORBA_StructDef::CORBA_StructDef (int collocated)
{
  this->CORBA_StructDef_setup_collocation (collocated);
}

// destructor
CORBA_StructDef::~CORBA_StructDef (void)
{}

void
CORBA_StructDef::CORBA_StructDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_CORBA_StructDef_Proxy_Broker_ =
      ::_TAO_CORBA_StructDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_CORBA_StructDef_Proxy_Broker_ =
      ::_TAO_CORBA_StructDef_Remote_Proxy_Broker::the_TAO_CORBA_StructDef_Remote_Proxy_Broker ();

  this->CORBA_TypedefDef_setup_collocation (collocated);

  this->CORBA_Container_setup_collocation (collocated);
}

void CORBA_StructDef::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_StructDef *tmp = ACE_static_cast (CORBA_StructDef*, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA_StructDef_ptr CORBA_StructDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_StructDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/StructDef:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (CORBA_StructDef::_nil ());
      if (is_a == 0)
        return CORBA_StructDef::_nil ();
    }
  return CORBA_StructDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA_StructDef_ptr CORBA_StructDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_StructDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      CORBA_StructDef_ptr default_proxy = CORBA_StructDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_CORBA_StructDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::CORBA_StructDef (
            stub,
            1,
            obj->_servant ()),

          CORBA_StructDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::CORBA_StructDef (stub, 0, obj->_servant ()), CORBA_StructDef::_nil ());
        return default_proxy;
      }
    else
      return
        ACE_reinterpret_cast
          (
            CORBA_StructDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &CORBA_StructDef::_tao_class_id
                    )
                )
          );
}

CORBA_StructDef_ptr
CORBA_StructDef::_duplicate (CORBA_StructDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean CORBA_StructDef::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/StructDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *CORBA_StructDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_StructDef::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_TypedefDef::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_TypedefDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Container::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Container_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IDLType::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* CORBA_StructDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/StructDef:1.0";
}

CORBA_StructMemberSeq * CORBA_StructDef::members (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_StructDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_StructDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.members (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

void CORBA_StructDef::members (
    const CORBA_StructMemberSeq & members
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_StructDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_StructDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  proxy.members (
      this,
      members
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA_UnionDef_ptr
tao_CORBA_UnionDef_duplicate (
    CORBA_UnionDef_ptr p
  )
{
  return CORBA_UnionDef::_duplicate (p);
}

void
tao_CORBA_UnionDef_release (
    CORBA_UnionDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA_UnionDef_ptr
tao_CORBA_UnionDef_nil (
    void
  )
{
  return CORBA_UnionDef::_nil ();
}

CORBA_UnionDef_ptr
tao_CORBA_UnionDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA_UnionDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_UnionDef_upcast (
    void *src
  )
{
  CORBA_UnionDef **tmp =
    ACE_static_cast (CORBA_UnionDef **, src);
  return *tmp;
}

int CORBA_UnionDef::_tao_class_id = 0;

// *************************************************************
// Operations for class CORBA_UnionDef_var
// *************************************************************

CORBA_UnionDef_var::CORBA_UnionDef_var (void) // default constructor
  : ptr_ (CORBA_UnionDef::_nil ())
{}

::CORBA_UnionDef_ptr
CORBA_UnionDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA_UnionDef_var::CORBA_UnionDef_var (const ::CORBA_UnionDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (CORBA_UnionDef::_duplicate (p.ptr ()))
{}

CORBA_UnionDef_var::~CORBA_UnionDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

CORBA_UnionDef_var &
CORBA_UnionDef_var::operator= (CORBA_UnionDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA_UnionDef_var &
CORBA_UnionDef_var::operator= (const ::CORBA_UnionDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA_UnionDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA_UnionDef_var::operator const ::CORBA_UnionDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA_UnionDef_var::operator ::CORBA_UnionDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_UnionDef_ptr
CORBA_UnionDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA_UnionDef_ptr
CORBA_UnionDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA_UnionDef_ptr &
CORBA_UnionDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA_UnionDef_ptr &
CORBA_UnionDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_UnionDef::_nil ();
  return this->ptr_;
}

::CORBA_UnionDef_ptr
CORBA_UnionDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA_UnionDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA_UnionDef::_nil ();
  return val;
}

::CORBA_UnionDef_ptr
CORBA_UnionDef_var::tao_duplicate (CORBA_UnionDef_ptr p)
{
  return ::CORBA_UnionDef::_duplicate (p);
}

void
CORBA_UnionDef_var::tao_release (CORBA_UnionDef_ptr p)
{
  CORBA::release (p);
}

::CORBA_UnionDef_ptr
CORBA_UnionDef_var::tao_nil (void)
{
  return ::CORBA_UnionDef::_nil ();
}

::CORBA_UnionDef_ptr
CORBA_UnionDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA_UnionDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA_UnionDef_var::tao_upcast (void *src)
{
  CORBA_UnionDef **tmp =
    ACE_static_cast (CORBA_UnionDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class CORBA_UnionDef_out
// *************************************************************

CORBA_UnionDef_out::CORBA_UnionDef_out (CORBA_UnionDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA_UnionDef::_nil ();
}

CORBA_UnionDef_out::CORBA_UnionDef_out (CORBA_UnionDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_UnionDef::_nil ();
}

CORBA_UnionDef_out::CORBA_UnionDef_out (const ::CORBA_UnionDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (CORBA_UnionDef_out &, p).ptr_)
{}

::CORBA_UnionDef_out &
CORBA_UnionDef_out::operator= (const ::CORBA_UnionDef_out &p)
{
  this->ptr_ = ACE_const_cast (CORBA_UnionDef_out&, p).ptr_;
  return *this;
}

CORBA_UnionDef_out &
CORBA_UnionDef_out::operator= (const ::CORBA_UnionDef_var &p)
{
  this->ptr_ = ::CORBA_UnionDef::_duplicate (p.ptr ());
  return *this;
}

CORBA_UnionDef_out &
CORBA_UnionDef_out::operator= (CORBA_UnionDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA_UnionDef_out::operator ::CORBA_UnionDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_UnionDef_ptr &
CORBA_UnionDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::CORBA_UnionDef_ptr
CORBA_UnionDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::TypeCode_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_get (const TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_get &);

  CORBA::TypeCode_ptr _result;
};

TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_get::TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_get::result (CORBA::TypeCode_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_IDLType_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_get (const TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_get &);

  CORBA_IDLType_ptr _result;
};

TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_get::TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_get::result (CORBA_IDLType_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA_IDLType_ptr discriminator_type_def
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_set (const TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_set &);
  void operator= (const TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_set &);

  CORBA_IDLType_ptr discriminator_type_def_;

};

TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_set::TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA_IDLType_ptr discriminator_type_def
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    discriminator_type_def_ (discriminator_type_def)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->discriminator_type_def_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

class TAO_ClientRequestInfo_CORBA_UnionDef_members_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_UnionDef_members_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_UnionMemberSeq * result);

private:
  TAO_ClientRequestInfo_CORBA_UnionDef_members_get (const TAO_ClientRequestInfo_CORBA_UnionDef_members_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_UnionDef_members_get &);

  CORBA_UnionMemberSeq * _result;
};

TAO_ClientRequestInfo_CORBA_UnionDef_members_get::TAO_ClientRequestInfo_CORBA_UnionDef_members_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_UnionDef_members_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_UnionDef_members_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_UnionDef_members_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_UnionDef_members_get::result (CORBA_UnionMemberSeq * result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_UnionDef_members_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_UnionDef_members_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA_UnionMemberSeq & members
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_CORBA_UnionDef_members_set (const TAO_ClientRequestInfo_CORBA_UnionDef_members_set &);
  void operator= (const TAO_ClientRequestInfo_CORBA_UnionDef_members_set &);

  const CORBA_UnionMemberSeq & members_;

};

TAO_ClientRequestInfo_CORBA_UnionDef_members_set::TAO_ClientRequestInfo_CORBA_UnionDef_members_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA_UnionMemberSeq & members
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    members_ (members)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_UnionDef_members_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->members_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_UnionDef_members_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_UnionDef_members_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation.
//

_TAO_CORBA_UnionDef_Proxy_Impl::_TAO_CORBA_UnionDef_Proxy_Impl (void)
{}

_TAO_CORBA_UnionDef_Remote_Proxy_Impl::_TAO_CORBA_UnionDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::TypeCode_ptr _TAO_CORBA_UnionDef_Remote_Proxy_Impl::discriminator_type (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_discriminator_type",
      23,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA::TypeCode_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

CORBA_IDLType_ptr _TAO_CORBA_UnionDef_Remote_Proxy_Impl::discriminator_type_def (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_IDLType_ptr _tao_retval = CORBA_IDLType::_nil ();
  CORBA_IDLType_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_discriminator_type_def",
      27,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA_IDLType_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

void _TAO_CORBA_UnionDef_Remote_Proxy_Impl::discriminator_type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA_IDLType_ptr discriminator_type_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_discriminator_type_def",
      27,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_set ri (
        &_tao_call,
        _collocated_tao_target_,
        discriminator_type_def
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << discriminator_type_def)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }


#if TAO_HAS_INTERCEPTORS == 1

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }

}

CORBA_UnionMemberSeq * _TAO_CORBA_UnionDef_Remote_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_UnionMemberSeq *_tao_retval = 0;


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  ACE_NEW_RETURN (_tao_retval, CORBA_UnionMemberSeq, _tao_retval);
  CORBA_UnionMemberSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_members",
      12,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_UnionDef_members_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA_UnionMemberSeq * _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

void _TAO_CORBA_UnionDef_Remote_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    const CORBA_UnionMemberSeq & members
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_members",
      12,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_UnionDef_members_set ri (
        &_tao_call,
        _collocated_tao_target_,
        members
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << members)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }


#if TAO_HAS_INTERCEPTORS == 1

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }

}


//
//            End  Base & Remote  Proxy Implemeentation.
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_CORBA_UnionDef_Proxy_Broker::_TAO_CORBA_UnionDef_Proxy_Broker (void)
{
}

_TAO_CORBA_UnionDef_Proxy_Broker::~_TAO_CORBA_UnionDef_Proxy_Broker (void)
{
}

_TAO_CORBA_UnionDef_Proxy_Broker * (*_TAO_CORBA_UnionDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_CORBA_UnionDef_Remote_Proxy_Broker *
_TAO_CORBA_UnionDef_Remote_Proxy_Broker::the_TAO_CORBA_UnionDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_CORBA_UnionDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_CORBA_UnionDef_Remote_Proxy_Broker::_TAO_CORBA_UnionDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_UnionDef_Remote_Proxy_Broker::~_TAO_CORBA_UnionDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_UnionDef_Proxy_Impl&
_TAO_CORBA_UnionDef_Remote_Proxy_Broker::select_proxy (
  ::CORBA_UnionDef *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
CORBA_UnionDef::CORBA_UnionDef (int collocated)
{
  this->CORBA_UnionDef_setup_collocation (collocated);
}

// destructor
CORBA_UnionDef::~CORBA_UnionDef (void)
{}

void
CORBA_UnionDef::CORBA_UnionDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_CORBA_UnionDef_Proxy_Broker_ =
      ::_TAO_CORBA_UnionDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_CORBA_UnionDef_Proxy_Broker_ =
      ::_TAO_CORBA_UnionDef_Remote_Proxy_Broker::the_TAO_CORBA_UnionDef_Remote_Proxy_Broker ();

  this->CORBA_TypedefDef_setup_collocation (collocated);

  this->CORBA_Container_setup_collocation (collocated);
}

void CORBA_UnionDef::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_UnionDef *tmp = ACE_static_cast (CORBA_UnionDef*, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA_UnionDef_ptr CORBA_UnionDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_UnionDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/UnionDef:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (CORBA_UnionDef::_nil ());
      if (is_a == 0)
        return CORBA_UnionDef::_nil ();
    }
  return CORBA_UnionDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA_UnionDef_ptr CORBA_UnionDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_UnionDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      CORBA_UnionDef_ptr default_proxy = CORBA_UnionDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_CORBA_UnionDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::CORBA_UnionDef (
            stub,
            1,
            obj->_servant ()),

          CORBA_UnionDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::CORBA_UnionDef (stub, 0, obj->_servant ()), CORBA_UnionDef::_nil ());
        return default_proxy;
      }
    else
      return
        ACE_reinterpret_cast
          (
            CORBA_UnionDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &CORBA_UnionDef::_tao_class_id
                    )
                )
          );
}

CORBA_UnionDef_ptr
CORBA_UnionDef::_duplicate (CORBA_UnionDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean CORBA_UnionDef::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/UnionDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *CORBA_UnionDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_UnionDef::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_TypedefDef::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_TypedefDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Container::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Container_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IDLType::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* CORBA_UnionDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/UnionDef:1.0";
}

CORBA::TypeCode_ptr CORBA_UnionDef::discriminator_type (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_UnionDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_UnionDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.discriminator_type (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA_IDLType_ptr CORBA_UnionDef::discriminator_type_def (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_UnionDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_UnionDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.discriminator_type_def (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

void CORBA_UnionDef::discriminator_type_def (
    CORBA_IDLType_ptr discriminator_type_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_UnionDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_UnionDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  proxy.discriminator_type_def (
      this,
      discriminator_type_def
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA_UnionMemberSeq * CORBA_UnionDef::members (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_UnionDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_UnionDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.members (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

void CORBA_UnionDef::members (
    const CORBA_UnionMemberSeq & members
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_UnionDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_UnionDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  proxy.members (
      this,
      members
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA_EnumDef_ptr
tao_CORBA_EnumDef_duplicate (
    CORBA_EnumDef_ptr p
  )
{
  return CORBA_EnumDef::_duplicate (p);
}

void
tao_CORBA_EnumDef_release (
    CORBA_EnumDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA_EnumDef_ptr
tao_CORBA_EnumDef_nil (
    void
  )
{
  return CORBA_EnumDef::_nil ();
}

CORBA_EnumDef_ptr
tao_CORBA_EnumDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA_EnumDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_EnumDef_upcast (
    void *src
  )
{
  CORBA_EnumDef **tmp =
    ACE_static_cast (CORBA_EnumDef **, src);
  return *tmp;
}

int CORBA_EnumDef::_tao_class_id = 0;

// *************************************************************
// Operations for class CORBA_EnumDef_var
// *************************************************************

CORBA_EnumDef_var::CORBA_EnumDef_var (void) // default constructor
  : ptr_ (CORBA_EnumDef::_nil ())
{}

::CORBA_EnumDef_ptr
CORBA_EnumDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA_EnumDef_var::CORBA_EnumDef_var (const ::CORBA_EnumDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (CORBA_EnumDef::_duplicate (p.ptr ()))
{}

CORBA_EnumDef_var::~CORBA_EnumDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

CORBA_EnumDef_var &
CORBA_EnumDef_var::operator= (CORBA_EnumDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA_EnumDef_var &
CORBA_EnumDef_var::operator= (const ::CORBA_EnumDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA_EnumDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA_EnumDef_var::operator const ::CORBA_EnumDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA_EnumDef_var::operator ::CORBA_EnumDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_EnumDef_ptr
CORBA_EnumDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA_EnumDef_ptr
CORBA_EnumDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA_EnumDef_ptr &
CORBA_EnumDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA_EnumDef_ptr &
CORBA_EnumDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_EnumDef::_nil ();
  return this->ptr_;
}

::CORBA_EnumDef_ptr
CORBA_EnumDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA_EnumDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA_EnumDef::_nil ();
  return val;
}

::CORBA_EnumDef_ptr
CORBA_EnumDef_var::tao_duplicate (CORBA_EnumDef_ptr p)
{
  return ::CORBA_EnumDef::_duplicate (p);
}

void
CORBA_EnumDef_var::tao_release (CORBA_EnumDef_ptr p)
{
  CORBA::release (p);
}

::CORBA_EnumDef_ptr
CORBA_EnumDef_var::tao_nil (void)
{
  return ::CORBA_EnumDef::_nil ();
}

::CORBA_EnumDef_ptr
CORBA_EnumDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA_EnumDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA_EnumDef_var::tao_upcast (void *src)
{
  CORBA_EnumDef **tmp =
    ACE_static_cast (CORBA_EnumDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class CORBA_EnumDef_out
// *************************************************************

CORBA_EnumDef_out::CORBA_EnumDef_out (CORBA_EnumDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA_EnumDef::_nil ();
}

CORBA_EnumDef_out::CORBA_EnumDef_out (CORBA_EnumDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_EnumDef::_nil ();
}

CORBA_EnumDef_out::CORBA_EnumDef_out (const ::CORBA_EnumDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (CORBA_EnumDef_out &, p).ptr_)
{}

::CORBA_EnumDef_out &
CORBA_EnumDef_out::operator= (const ::CORBA_EnumDef_out &p)
{
  this->ptr_ = ACE_const_cast (CORBA_EnumDef_out&, p).ptr_;
  return *this;
}

CORBA_EnumDef_out &
CORBA_EnumDef_out::operator= (const ::CORBA_EnumDef_var &p)
{
  this->ptr_ = ::CORBA_EnumDef::_duplicate (p.ptr ());
  return *this;
}

CORBA_EnumDef_out &
CORBA_EnumDef_out::operator= (CORBA_EnumDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA_EnumDef_out::operator ::CORBA_EnumDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_EnumDef_ptr &
CORBA_EnumDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::CORBA_EnumDef_ptr
CORBA_EnumDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_CORBA_EnumDef_members_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_EnumDef_members_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_EnumMemberSeq * result);

private:
  TAO_ClientRequestInfo_CORBA_EnumDef_members_get (const TAO_ClientRequestInfo_CORBA_EnumDef_members_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_EnumDef_members_get &);

  CORBA_EnumMemberSeq * _result;
};

TAO_ClientRequestInfo_CORBA_EnumDef_members_get::TAO_ClientRequestInfo_CORBA_EnumDef_members_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_EnumDef_members_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_EnumDef_members_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_EnumDef_members_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_EnumDef_members_get::result (CORBA_EnumMemberSeq * result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_EnumDef_members_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_EnumDef_members_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA_EnumMemberSeq & members
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_CORBA_EnumDef_members_set (const TAO_ClientRequestInfo_CORBA_EnumDef_members_set &);
  void operator= (const TAO_ClientRequestInfo_CORBA_EnumDef_members_set &);

  const CORBA_EnumMemberSeq & members_;

};

TAO_ClientRequestInfo_CORBA_EnumDef_members_set::TAO_ClientRequestInfo_CORBA_EnumDef_members_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA_EnumMemberSeq & members
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    members_ (members)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_EnumDef_members_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->members_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_EnumDef_members_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_EnumDef_members_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation.
//

_TAO_CORBA_EnumDef_Proxy_Impl::_TAO_CORBA_EnumDef_Proxy_Impl (void)
{}

_TAO_CORBA_EnumDef_Remote_Proxy_Impl::_TAO_CORBA_EnumDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA_EnumMemberSeq * _TAO_CORBA_EnumDef_Remote_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_EnumMemberSeq *_tao_retval = 0;


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  ACE_NEW_RETURN (_tao_retval, CORBA_EnumMemberSeq, _tao_retval);
  CORBA_EnumMemberSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_members",
      12,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_EnumDef_members_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA_EnumMemberSeq * _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

void _TAO_CORBA_EnumDef_Remote_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    const CORBA_EnumMemberSeq & members
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_members",
      12,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_EnumDef_members_set ri (
        &_tao_call,
        _collocated_tao_target_,
        members
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << members)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }


#if TAO_HAS_INTERCEPTORS == 1

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }

}


//
//            End  Base & Remote  Proxy Implemeentation.
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_CORBA_EnumDef_Proxy_Broker::_TAO_CORBA_EnumDef_Proxy_Broker (void)
{
}

_TAO_CORBA_EnumDef_Proxy_Broker::~_TAO_CORBA_EnumDef_Proxy_Broker (void)
{
}

_TAO_CORBA_EnumDef_Proxy_Broker * (*_TAO_CORBA_EnumDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_CORBA_EnumDef_Remote_Proxy_Broker *
_TAO_CORBA_EnumDef_Remote_Proxy_Broker::the_TAO_CORBA_EnumDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_CORBA_EnumDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_CORBA_EnumDef_Remote_Proxy_Broker::_TAO_CORBA_EnumDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_EnumDef_Remote_Proxy_Broker::~_TAO_CORBA_EnumDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_EnumDef_Proxy_Impl&
_TAO_CORBA_EnumDef_Remote_Proxy_Broker::select_proxy (
  ::CORBA_EnumDef *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
CORBA_EnumDef::CORBA_EnumDef (int collocated)
{
  this->CORBA_EnumDef_setup_collocation (collocated);
}

// destructor
CORBA_EnumDef::~CORBA_EnumDef (void)
{}

void
CORBA_EnumDef::CORBA_EnumDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_CORBA_EnumDef_Proxy_Broker_ =
      ::_TAO_CORBA_EnumDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_CORBA_EnumDef_Proxy_Broker_ =
      ::_TAO_CORBA_EnumDef_Remote_Proxy_Broker::the_TAO_CORBA_EnumDef_Remote_Proxy_Broker ();

  this->CORBA_TypedefDef_setup_collocation (collocated);
}

void CORBA_EnumDef::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_EnumDef *tmp = ACE_static_cast (CORBA_EnumDef*, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA_EnumDef_ptr CORBA_EnumDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_EnumDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/EnumDef:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (CORBA_EnumDef::_nil ());
      if (is_a == 0)
        return CORBA_EnumDef::_nil ();
    }
  return CORBA_EnumDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA_EnumDef_ptr CORBA_EnumDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_EnumDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      CORBA_EnumDef_ptr default_proxy = CORBA_EnumDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_CORBA_EnumDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::CORBA_EnumDef (
            stub,
            1,
            obj->_servant ()),

          CORBA_EnumDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::CORBA_EnumDef (stub, 0, obj->_servant ()), CORBA_EnumDef::_nil ());
        return default_proxy;
      }
    else
      return
        ACE_reinterpret_cast
          (
            CORBA_EnumDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &CORBA_EnumDef::_tao_class_id
                    )
                )
          );
}

CORBA_EnumDef_ptr
CORBA_EnumDef::_duplicate (CORBA_EnumDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean CORBA_EnumDef::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/EnumDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *CORBA_EnumDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_EnumDef::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_TypedefDef::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_TypedefDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IDLType::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* CORBA_EnumDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/EnumDef:1.0";
}

CORBA_EnumMemberSeq * CORBA_EnumDef::members (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_EnumDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_EnumDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.members (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

void CORBA_EnumDef::members (
    const CORBA_EnumMemberSeq & members
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_EnumDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_EnumDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  proxy.members (
      this,
      members
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA_AliasDef_ptr
tao_CORBA_AliasDef_duplicate (
    CORBA_AliasDef_ptr p
  )
{
  return CORBA_AliasDef::_duplicate (p);
}

void
tao_CORBA_AliasDef_release (
    CORBA_AliasDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA_AliasDef_ptr
tao_CORBA_AliasDef_nil (
    void
  )
{
  return CORBA_AliasDef::_nil ();
}

CORBA_AliasDef_ptr
tao_CORBA_AliasDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA_AliasDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_AliasDef_upcast (
    void *src
  )
{
  CORBA_AliasDef **tmp =
    ACE_static_cast (CORBA_AliasDef **, src);
  return *tmp;
}

int CORBA_AliasDef::_tao_class_id = 0;

// *************************************************************
// Operations for class CORBA_AliasDef_var
// *************************************************************

CORBA_AliasDef_var::CORBA_AliasDef_var (void) // default constructor
  : ptr_ (CORBA_AliasDef::_nil ())
{}

::CORBA_AliasDef_ptr
CORBA_AliasDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA_AliasDef_var::CORBA_AliasDef_var (const ::CORBA_AliasDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (CORBA_AliasDef::_duplicate (p.ptr ()))
{}

CORBA_AliasDef_var::~CORBA_AliasDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

CORBA_AliasDef_var &
CORBA_AliasDef_var::operator= (CORBA_AliasDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA_AliasDef_var &
CORBA_AliasDef_var::operator= (const ::CORBA_AliasDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA_AliasDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA_AliasDef_var::operator const ::CORBA_AliasDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA_AliasDef_var::operator ::CORBA_AliasDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_AliasDef_ptr
CORBA_AliasDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA_AliasDef_ptr
CORBA_AliasDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA_AliasDef_ptr &
CORBA_AliasDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA_AliasDef_ptr &
CORBA_AliasDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_AliasDef::_nil ();
  return this->ptr_;
}

::CORBA_AliasDef_ptr
CORBA_AliasDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA_AliasDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA_AliasDef::_nil ();
  return val;
}

::CORBA_AliasDef_ptr
CORBA_AliasDef_var::tao_duplicate (CORBA_AliasDef_ptr p)
{
  return ::CORBA_AliasDef::_duplicate (p);
}

void
CORBA_AliasDef_var::tao_release (CORBA_AliasDef_ptr p)
{
  CORBA::release (p);
}

::CORBA_AliasDef_ptr
CORBA_AliasDef_var::tao_nil (void)
{
  return ::CORBA_AliasDef::_nil ();
}

::CORBA_AliasDef_ptr
CORBA_AliasDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA_AliasDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA_AliasDef_var::tao_upcast (void *src)
{
  CORBA_AliasDef **tmp =
    ACE_static_cast (CORBA_AliasDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class CORBA_AliasDef_out
// *************************************************************

CORBA_AliasDef_out::CORBA_AliasDef_out (CORBA_AliasDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA_AliasDef::_nil ();
}

CORBA_AliasDef_out::CORBA_AliasDef_out (CORBA_AliasDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_AliasDef::_nil ();
}

CORBA_AliasDef_out::CORBA_AliasDef_out (const ::CORBA_AliasDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (CORBA_AliasDef_out &, p).ptr_)
{}

::CORBA_AliasDef_out &
CORBA_AliasDef_out::operator= (const ::CORBA_AliasDef_out &p)
{
  this->ptr_ = ACE_const_cast (CORBA_AliasDef_out&, p).ptr_;
  return *this;
}

CORBA_AliasDef_out &
CORBA_AliasDef_out::operator= (const ::CORBA_AliasDef_var &p)
{
  this->ptr_ = ::CORBA_AliasDef::_duplicate (p.ptr ());
  return *this;
}

CORBA_AliasDef_out &
CORBA_AliasDef_out::operator= (CORBA_AliasDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA_AliasDef_out::operator ::CORBA_AliasDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_AliasDef_ptr &
CORBA_AliasDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::CORBA_AliasDef_ptr
CORBA_AliasDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_IDLType_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_get (const TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_get &);

  CORBA_IDLType_ptr _result;
};

TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_get::TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_get::result (CORBA_IDLType_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA_IDLType_ptr original_type_def
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_set (const TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_set &);
  void operator= (const TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_set &);

  CORBA_IDLType_ptr original_type_def_;

};

TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_set::TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA_IDLType_ptr original_type_def
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    original_type_def_ (original_type_def)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->original_type_def_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation.
//

_TAO_CORBA_AliasDef_Proxy_Impl::_TAO_CORBA_AliasDef_Proxy_Impl (void)
{}

_TAO_CORBA_AliasDef_Remote_Proxy_Impl::_TAO_CORBA_AliasDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA_IDLType_ptr _TAO_CORBA_AliasDef_Remote_Proxy_Impl::original_type_def (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_IDLType_ptr _tao_retval = CORBA_IDLType::_nil ();
  CORBA_IDLType_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_original_type_def",
      22,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA_IDLType_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

void _TAO_CORBA_AliasDef_Remote_Proxy_Impl::original_type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA_IDLType_ptr original_type_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_original_type_def",
      22,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_set ri (
        &_tao_call,
        _collocated_tao_target_,
        original_type_def
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << original_type_def)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }


#if TAO_HAS_INTERCEPTORS == 1

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }

}


//
//            End  Base & Remote  Proxy Implemeentation.
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_CORBA_AliasDef_Proxy_Broker::_TAO_CORBA_AliasDef_Proxy_Broker (void)
{
}

_TAO_CORBA_AliasDef_Proxy_Broker::~_TAO_CORBA_AliasDef_Proxy_Broker (void)
{
}

_TAO_CORBA_AliasDef_Proxy_Broker * (*_TAO_CORBA_AliasDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_CORBA_AliasDef_Remote_Proxy_Broker *
_TAO_CORBA_AliasDef_Remote_Proxy_Broker::the_TAO_CORBA_AliasDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_CORBA_AliasDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_CORBA_AliasDef_Remote_Proxy_Broker::_TAO_CORBA_AliasDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_AliasDef_Remote_Proxy_Broker::~_TAO_CORBA_AliasDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_AliasDef_Proxy_Impl&
_TAO_CORBA_AliasDef_Remote_Proxy_Broker::select_proxy (
  ::CORBA_AliasDef *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
CORBA_AliasDef::CORBA_AliasDef (int collocated)
{
  this->CORBA_AliasDef_setup_collocation (collocated);
}

// destructor
CORBA_AliasDef::~CORBA_AliasDef (void)
{}

void
CORBA_AliasDef::CORBA_AliasDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_CORBA_AliasDef_Proxy_Broker_ =
      ::_TAO_CORBA_AliasDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_CORBA_AliasDef_Proxy_Broker_ =
      ::_TAO_CORBA_AliasDef_Remote_Proxy_Broker::the_TAO_CORBA_AliasDef_Remote_Proxy_Broker ();

  this->CORBA_TypedefDef_setup_collocation (collocated);
}

void CORBA_AliasDef::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_AliasDef *tmp = ACE_static_cast (CORBA_AliasDef*, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA_AliasDef_ptr CORBA_AliasDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_AliasDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/AliasDef:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (CORBA_AliasDef::_nil ());
      if (is_a == 0)
        return CORBA_AliasDef::_nil ();
    }
  return CORBA_AliasDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA_AliasDef_ptr CORBA_AliasDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_AliasDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      CORBA_AliasDef_ptr default_proxy = CORBA_AliasDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_CORBA_AliasDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::CORBA_AliasDef (
            stub,
            1,
            obj->_servant ()),

          CORBA_AliasDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::CORBA_AliasDef (stub, 0, obj->_servant ()), CORBA_AliasDef::_nil ());
        return default_proxy;
      }
    else
      return
        ACE_reinterpret_cast
          (
            CORBA_AliasDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &CORBA_AliasDef::_tao_class_id
                    )
                )
          );
}

CORBA_AliasDef_ptr
CORBA_AliasDef::_duplicate (CORBA_AliasDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean CORBA_AliasDef::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/AliasDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *CORBA_AliasDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_AliasDef::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_TypedefDef::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_TypedefDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IDLType::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* CORBA_AliasDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/AliasDef:1.0";
}

CORBA_IDLType_ptr CORBA_AliasDef::original_type_def (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_AliasDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_AliasDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.original_type_def (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

void CORBA_AliasDef::original_type_def (
    CORBA_IDLType_ptr original_type_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_AliasDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_AliasDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  proxy.original_type_def (
      this,
      original_type_def
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA_NativeDef_ptr
tao_CORBA_NativeDef_duplicate (
    CORBA_NativeDef_ptr p
  )
{
  return CORBA_NativeDef::_duplicate (p);
}

void
tao_CORBA_NativeDef_release (
    CORBA_NativeDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA_NativeDef_ptr
tao_CORBA_NativeDef_nil (
    void
  )
{
  return CORBA_NativeDef::_nil ();
}

CORBA_NativeDef_ptr
tao_CORBA_NativeDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA_NativeDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_NativeDef_upcast (
    void *src
  )
{
  CORBA_NativeDef **tmp =
    ACE_static_cast (CORBA_NativeDef **, src);
  return *tmp;
}

int CORBA_NativeDef::_tao_class_id = 0;

// *************************************************************
// Operations for class CORBA_NativeDef_var
// *************************************************************

CORBA_NativeDef_var::CORBA_NativeDef_var (void) // default constructor
  : ptr_ (CORBA_NativeDef::_nil ())
{}

::CORBA_NativeDef_ptr
CORBA_NativeDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA_NativeDef_var::CORBA_NativeDef_var (const ::CORBA_NativeDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (CORBA_NativeDef::_duplicate (p.ptr ()))
{}

CORBA_NativeDef_var::~CORBA_NativeDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

CORBA_NativeDef_var &
CORBA_NativeDef_var::operator= (CORBA_NativeDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA_NativeDef_var &
CORBA_NativeDef_var::operator= (const ::CORBA_NativeDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA_NativeDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA_NativeDef_var::operator const ::CORBA_NativeDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA_NativeDef_var::operator ::CORBA_NativeDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_NativeDef_ptr
CORBA_NativeDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA_NativeDef_ptr
CORBA_NativeDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA_NativeDef_ptr &
CORBA_NativeDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA_NativeDef_ptr &
CORBA_NativeDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_NativeDef::_nil ();
  return this->ptr_;
}

::CORBA_NativeDef_ptr
CORBA_NativeDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA_NativeDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA_NativeDef::_nil ();
  return val;
}

::CORBA_NativeDef_ptr
CORBA_NativeDef_var::tao_duplicate (CORBA_NativeDef_ptr p)
{
  return ::CORBA_NativeDef::_duplicate (p);
}

void
CORBA_NativeDef_var::tao_release (CORBA_NativeDef_ptr p)
{
  CORBA::release (p);
}

::CORBA_NativeDef_ptr
CORBA_NativeDef_var::tao_nil (void)
{
  return ::CORBA_NativeDef::_nil ();
}

::CORBA_NativeDef_ptr
CORBA_NativeDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA_NativeDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA_NativeDef_var::tao_upcast (void *src)
{
  CORBA_NativeDef **tmp =
    ACE_static_cast (CORBA_NativeDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class CORBA_NativeDef_out
// *************************************************************

CORBA_NativeDef_out::CORBA_NativeDef_out (CORBA_NativeDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA_NativeDef::_nil ();
}

CORBA_NativeDef_out::CORBA_NativeDef_out (CORBA_NativeDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_NativeDef::_nil ();
}

CORBA_NativeDef_out::CORBA_NativeDef_out (const ::CORBA_NativeDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (CORBA_NativeDef_out &, p).ptr_)
{}

::CORBA_NativeDef_out &
CORBA_NativeDef_out::operator= (const ::CORBA_NativeDef_out &p)
{
  this->ptr_ = ACE_const_cast (CORBA_NativeDef_out&, p).ptr_;
  return *this;
}

CORBA_NativeDef_out &
CORBA_NativeDef_out::operator= (const ::CORBA_NativeDef_var &p)
{
  this->ptr_ = ::CORBA_NativeDef::_duplicate (p.ptr ());
  return *this;
}

CORBA_NativeDef_out &
CORBA_NativeDef_out::operator= (CORBA_NativeDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA_NativeDef_out::operator ::CORBA_NativeDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_NativeDef_ptr &
CORBA_NativeDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::CORBA_NativeDef_ptr
CORBA_NativeDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation.
//

_TAO_CORBA_NativeDef_Proxy_Impl::_TAO_CORBA_NativeDef_Proxy_Impl (void)
{}

_TAO_CORBA_NativeDef_Remote_Proxy_Impl::_TAO_CORBA_NativeDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods


//
//            End  Base & Remote  Proxy Implemeentation.
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_CORBA_NativeDef_Proxy_Broker::_TAO_CORBA_NativeDef_Proxy_Broker (void)
{
}

_TAO_CORBA_NativeDef_Proxy_Broker::~_TAO_CORBA_NativeDef_Proxy_Broker (void)
{
}

_TAO_CORBA_NativeDef_Proxy_Broker * (*_TAO_CORBA_NativeDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_CORBA_NativeDef_Remote_Proxy_Broker *
_TAO_CORBA_NativeDef_Remote_Proxy_Broker::the_TAO_CORBA_NativeDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_CORBA_NativeDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_CORBA_NativeDef_Remote_Proxy_Broker::_TAO_CORBA_NativeDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_NativeDef_Remote_Proxy_Broker::~_TAO_CORBA_NativeDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_NativeDef_Proxy_Impl&
_TAO_CORBA_NativeDef_Remote_Proxy_Broker::select_proxy (
  ::CORBA_NativeDef *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
CORBA_NativeDef::CORBA_NativeDef (int collocated)
{
  this->CORBA_NativeDef_setup_collocation (collocated);
}

// destructor
CORBA_NativeDef::~CORBA_NativeDef (void)
{}

void
CORBA_NativeDef::CORBA_NativeDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_CORBA_NativeDef_Proxy_Broker_ =
      ::_TAO_CORBA_NativeDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_CORBA_NativeDef_Proxy_Broker_ =
      ::_TAO_CORBA_NativeDef_Remote_Proxy_Broker::the_TAO_CORBA_NativeDef_Remote_Proxy_Broker ();

  this->CORBA_TypedefDef_setup_collocation (collocated);
}

void CORBA_NativeDef::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_NativeDef *tmp = ACE_static_cast (CORBA_NativeDef*, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA_NativeDef_ptr CORBA_NativeDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_NativeDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/NativeDef:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (CORBA_NativeDef::_nil ());
      if (is_a == 0)
        return CORBA_NativeDef::_nil ();
    }
  return CORBA_NativeDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA_NativeDef_ptr CORBA_NativeDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_NativeDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      CORBA_NativeDef_ptr default_proxy = CORBA_NativeDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_CORBA_NativeDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::CORBA_NativeDef (
            stub,
            1,
            obj->_servant ()),

          CORBA_NativeDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::CORBA_NativeDef (stub, 0, obj->_servant ()), CORBA_NativeDef::_nil ());
        return default_proxy;
      }
    else
      return
        ACE_reinterpret_cast
          (
            CORBA_NativeDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &CORBA_NativeDef::_tao_class_id
                    )
                )
          );
}

CORBA_NativeDef_ptr
CORBA_NativeDef::_duplicate (CORBA_NativeDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean CORBA_NativeDef::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/NativeDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *CORBA_NativeDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_NativeDef::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_TypedefDef::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_TypedefDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IDLType::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* CORBA_NativeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/NativeDef:1.0";
}

CORBA_PrimitiveDef_ptr
tao_CORBA_PrimitiveDef_duplicate (
    CORBA_PrimitiveDef_ptr p
  )
{
  return CORBA_PrimitiveDef::_duplicate (p);
}

void
tao_CORBA_PrimitiveDef_release (
    CORBA_PrimitiveDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA_PrimitiveDef_ptr
tao_CORBA_PrimitiveDef_nil (
    void
  )
{
  return CORBA_PrimitiveDef::_nil ();
}

CORBA_PrimitiveDef_ptr
tao_CORBA_PrimitiveDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA_PrimitiveDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_PrimitiveDef_upcast (
    void *src
  )
{
  CORBA_PrimitiveDef **tmp =
    ACE_static_cast (CORBA_PrimitiveDef **, src);
  return *tmp;
}

int CORBA_PrimitiveDef::_tao_class_id = 0;

// *************************************************************
// Operations for class CORBA_PrimitiveDef_var
// *************************************************************

CORBA_PrimitiveDef_var::CORBA_PrimitiveDef_var (void) // default constructor
  : ptr_ (CORBA_PrimitiveDef::_nil ())
{}

::CORBA_PrimitiveDef_ptr
CORBA_PrimitiveDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA_PrimitiveDef_var::CORBA_PrimitiveDef_var (const ::CORBA_PrimitiveDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (CORBA_PrimitiveDef::_duplicate (p.ptr ()))
{}

CORBA_PrimitiveDef_var::~CORBA_PrimitiveDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

CORBA_PrimitiveDef_var &
CORBA_PrimitiveDef_var::operator= (CORBA_PrimitiveDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA_PrimitiveDef_var &
CORBA_PrimitiveDef_var::operator= (const ::CORBA_PrimitiveDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA_PrimitiveDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA_PrimitiveDef_var::operator const ::CORBA_PrimitiveDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA_PrimitiveDef_var::operator ::CORBA_PrimitiveDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_PrimitiveDef_ptr
CORBA_PrimitiveDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA_PrimitiveDef_ptr
CORBA_PrimitiveDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA_PrimitiveDef_ptr &
CORBA_PrimitiveDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA_PrimitiveDef_ptr &
CORBA_PrimitiveDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_PrimitiveDef::_nil ();
  return this->ptr_;
}

::CORBA_PrimitiveDef_ptr
CORBA_PrimitiveDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA_PrimitiveDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA_PrimitiveDef::_nil ();
  return val;
}

::CORBA_PrimitiveDef_ptr
CORBA_PrimitiveDef_var::tao_duplicate (CORBA_PrimitiveDef_ptr p)
{
  return ::CORBA_PrimitiveDef::_duplicate (p);
}

void
CORBA_PrimitiveDef_var::tao_release (CORBA_PrimitiveDef_ptr p)
{
  CORBA::release (p);
}

::CORBA_PrimitiveDef_ptr
CORBA_PrimitiveDef_var::tao_nil (void)
{
  return ::CORBA_PrimitiveDef::_nil ();
}

::CORBA_PrimitiveDef_ptr
CORBA_PrimitiveDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA_PrimitiveDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA_PrimitiveDef_var::tao_upcast (void *src)
{
  CORBA_PrimitiveDef **tmp =
    ACE_static_cast (CORBA_PrimitiveDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class CORBA_PrimitiveDef_out
// *************************************************************

CORBA_PrimitiveDef_out::CORBA_PrimitiveDef_out (CORBA_PrimitiveDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA_PrimitiveDef::_nil ();
}

CORBA_PrimitiveDef_out::CORBA_PrimitiveDef_out (CORBA_PrimitiveDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_PrimitiveDef::_nil ();
}

CORBA_PrimitiveDef_out::CORBA_PrimitiveDef_out (const ::CORBA_PrimitiveDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (CORBA_PrimitiveDef_out &, p).ptr_)
{}

::CORBA_PrimitiveDef_out &
CORBA_PrimitiveDef_out::operator= (const ::CORBA_PrimitiveDef_out &p)
{
  this->ptr_ = ACE_const_cast (CORBA_PrimitiveDef_out&, p).ptr_;
  return *this;
}

CORBA_PrimitiveDef_out &
CORBA_PrimitiveDef_out::operator= (const ::CORBA_PrimitiveDef_var &p)
{
  this->ptr_ = ::CORBA_PrimitiveDef::_duplicate (p.ptr ());
  return *this;
}

CORBA_PrimitiveDef_out &
CORBA_PrimitiveDef_out::operator= (CORBA_PrimitiveDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA_PrimitiveDef_out::operator ::CORBA_PrimitiveDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_PrimitiveDef_ptr &
CORBA_PrimitiveDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::CORBA_PrimitiveDef_ptr
CORBA_PrimitiveDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_CORBA_PrimitiveDef_kind_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_PrimitiveDef_kind_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::PrimitiveKind result);

private:
  TAO_ClientRequestInfo_CORBA_PrimitiveDef_kind_get (const TAO_ClientRequestInfo_CORBA_PrimitiveDef_kind_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_PrimitiveDef_kind_get &);

  CORBA::PrimitiveKind _result;
};

TAO_ClientRequestInfo_CORBA_PrimitiveDef_kind_get::TAO_ClientRequestInfo_CORBA_PrimitiveDef_kind_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_PrimitiveDef_kind_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_PrimitiveDef_kind_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_PrimitiveDef_kind_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_PrimitiveDef_kind_get::result (CORBA::PrimitiveKind result)
{
  // update the result
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation.
//

_TAO_CORBA_PrimitiveDef_Proxy_Impl::_TAO_CORBA_PrimitiveDef_Proxy_Impl (void)
{}

_TAO_CORBA_PrimitiveDef_Remote_Proxy_Impl::_TAO_CORBA_PrimitiveDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::PrimitiveKind _TAO_CORBA_PrimitiveDef_Remote_Proxy_Impl::kind (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::PrimitiveKind _tao_retval = (CORBA::PrimitiveKind)0;


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_kind",
      9,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_PrimitiveDef_kind_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN  (_tao_retval);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                _tao_retval
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA::PrimitiveKind _tao_retval_info = _tao_retval;
          ri.result (_tao_retval_info);

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN  (_tao_retval);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN  (_tao_retval);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_retval;
}


//
//            End  Base & Remote  Proxy Implemeentation.
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_CORBA_PrimitiveDef_Proxy_Broker::_TAO_CORBA_PrimitiveDef_Proxy_Broker (void)
{
}

_TAO_CORBA_PrimitiveDef_Proxy_Broker::~_TAO_CORBA_PrimitiveDef_Proxy_Broker (void)
{
}

_TAO_CORBA_PrimitiveDef_Proxy_Broker * (*_TAO_CORBA_PrimitiveDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_CORBA_PrimitiveDef_Remote_Proxy_Broker *
_TAO_CORBA_PrimitiveDef_Remote_Proxy_Broker::the_TAO_CORBA_PrimitiveDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_CORBA_PrimitiveDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_CORBA_PrimitiveDef_Remote_Proxy_Broker::_TAO_CORBA_PrimitiveDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_PrimitiveDef_Remote_Proxy_Broker::~_TAO_CORBA_PrimitiveDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_PrimitiveDef_Proxy_Impl&
_TAO_CORBA_PrimitiveDef_Remote_Proxy_Broker::select_proxy (
  ::CORBA_PrimitiveDef *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
CORBA_PrimitiveDef::CORBA_PrimitiveDef (int collocated)
{
  this->CORBA_PrimitiveDef_setup_collocation (collocated);
}

// destructor
CORBA_PrimitiveDef::~CORBA_PrimitiveDef (void)
{}

void
CORBA_PrimitiveDef::CORBA_PrimitiveDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_CORBA_PrimitiveDef_Proxy_Broker_ =
      ::_TAO_CORBA_PrimitiveDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_CORBA_PrimitiveDef_Proxy_Broker_ =
      ::_TAO_CORBA_PrimitiveDef_Remote_Proxy_Broker::the_TAO_CORBA_PrimitiveDef_Remote_Proxy_Broker ();

  this->CORBA_IDLType_setup_collocation (collocated);
}

void CORBA_PrimitiveDef::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_PrimitiveDef *tmp = ACE_static_cast (CORBA_PrimitiveDef*, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA_PrimitiveDef_ptr CORBA_PrimitiveDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_PrimitiveDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/PrimitiveDef:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (CORBA_PrimitiveDef::_nil ());
      if (is_a == 0)
        return CORBA_PrimitiveDef::_nil ();
    }
  return CORBA_PrimitiveDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA_PrimitiveDef_ptr CORBA_PrimitiveDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_PrimitiveDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      CORBA_PrimitiveDef_ptr default_proxy = CORBA_PrimitiveDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_CORBA_PrimitiveDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::CORBA_PrimitiveDef (
            stub,
            1,
            obj->_servant ()),

          CORBA_PrimitiveDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::CORBA_PrimitiveDef (stub, 0, obj->_servant ()), CORBA_PrimitiveDef::_nil ());
        return default_proxy;
      }
    else
      return
        ACE_reinterpret_cast
          (
            CORBA_PrimitiveDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &CORBA_PrimitiveDef::_tao_class_id
                    )
                )
          );
}

CORBA_PrimitiveDef_ptr
CORBA_PrimitiveDef::_duplicate (CORBA_PrimitiveDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean CORBA_PrimitiveDef::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/PrimitiveDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *CORBA_PrimitiveDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_PrimitiveDef::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IDLType::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* CORBA_PrimitiveDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/PrimitiveDef:1.0";
}

CORBA::PrimitiveKind CORBA_PrimitiveDef::kind (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_PrimitiveDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_PrimitiveDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN ((CORBA::PrimitiveKind)0);

  return proxy.kind (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA_StringDef_ptr
tao_CORBA_StringDef_duplicate (
    CORBA_StringDef_ptr p
  )
{
  return CORBA_StringDef::_duplicate (p);
}

void
tao_CORBA_StringDef_release (
    CORBA_StringDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA_StringDef_ptr
tao_CORBA_StringDef_nil (
    void
  )
{
  return CORBA_StringDef::_nil ();
}

CORBA_StringDef_ptr
tao_CORBA_StringDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA_StringDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_StringDef_upcast (
    void *src
  )
{
  CORBA_StringDef **tmp =
    ACE_static_cast (CORBA_StringDef **, src);
  return *tmp;
}

int CORBA_StringDef::_tao_class_id = 0;

// *************************************************************
// Operations for class CORBA_StringDef_var
// *************************************************************

CORBA_StringDef_var::CORBA_StringDef_var (void) // default constructor
  : ptr_ (CORBA_StringDef::_nil ())
{}

::CORBA_StringDef_ptr
CORBA_StringDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA_StringDef_var::CORBA_StringDef_var (const ::CORBA_StringDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (CORBA_StringDef::_duplicate (p.ptr ()))
{}

CORBA_StringDef_var::~CORBA_StringDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

CORBA_StringDef_var &
CORBA_StringDef_var::operator= (CORBA_StringDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA_StringDef_var &
CORBA_StringDef_var::operator= (const ::CORBA_StringDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA_StringDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA_StringDef_var::operator const ::CORBA_StringDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA_StringDef_var::operator ::CORBA_StringDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_StringDef_ptr
CORBA_StringDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA_StringDef_ptr
CORBA_StringDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA_StringDef_ptr &
CORBA_StringDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA_StringDef_ptr &
CORBA_StringDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_StringDef::_nil ();
  return this->ptr_;
}

::CORBA_StringDef_ptr
CORBA_StringDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA_StringDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA_StringDef::_nil ();
  return val;
}

::CORBA_StringDef_ptr
CORBA_StringDef_var::tao_duplicate (CORBA_StringDef_ptr p)
{
  return ::CORBA_StringDef::_duplicate (p);
}

void
CORBA_StringDef_var::tao_release (CORBA_StringDef_ptr p)
{
  CORBA::release (p);
}

::CORBA_StringDef_ptr
CORBA_StringDef_var::tao_nil (void)
{
  return ::CORBA_StringDef::_nil ();
}

::CORBA_StringDef_ptr
CORBA_StringDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA_StringDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA_StringDef_var::tao_upcast (void *src)
{
  CORBA_StringDef **tmp =
    ACE_static_cast (CORBA_StringDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class CORBA_StringDef_out
// *************************************************************

CORBA_StringDef_out::CORBA_StringDef_out (CORBA_StringDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA_StringDef::_nil ();
}

CORBA_StringDef_out::CORBA_StringDef_out (CORBA_StringDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_StringDef::_nil ();
}

CORBA_StringDef_out::CORBA_StringDef_out (const ::CORBA_StringDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (CORBA_StringDef_out &, p).ptr_)
{}

::CORBA_StringDef_out &
CORBA_StringDef_out::operator= (const ::CORBA_StringDef_out &p)
{
  this->ptr_ = ACE_const_cast (CORBA_StringDef_out&, p).ptr_;
  return *this;
}

CORBA_StringDef_out &
CORBA_StringDef_out::operator= (const ::CORBA_StringDef_var &p)
{
  this->ptr_ = ::CORBA_StringDef::_duplicate (p.ptr ());
  return *this;
}

CORBA_StringDef_out &
CORBA_StringDef_out::operator= (CORBA_StringDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA_StringDef_out::operator ::CORBA_StringDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_StringDef_ptr &
CORBA_StringDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::CORBA_StringDef_ptr
CORBA_StringDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_CORBA_StringDef_bound_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_StringDef_bound_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::ULong result);

private:
  TAO_ClientRequestInfo_CORBA_StringDef_bound_get (const TAO_ClientRequestInfo_CORBA_StringDef_bound_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_StringDef_bound_get &);

  CORBA::ULong _result;
};

TAO_ClientRequestInfo_CORBA_StringDef_bound_get::TAO_ClientRequestInfo_CORBA_StringDef_bound_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_StringDef_bound_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_StringDef_bound_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_StringDef_bound_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_StringDef_bound_get::result (CORBA::ULong result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_StringDef_bound_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_StringDef_bound_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ULong & bound
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_CORBA_StringDef_bound_set (const TAO_ClientRequestInfo_CORBA_StringDef_bound_set &);
  void operator= (const TAO_ClientRequestInfo_CORBA_StringDef_bound_set &);

  const CORBA::ULong & bound_;

};

TAO_ClientRequestInfo_CORBA_StringDef_bound_set::TAO_ClientRequestInfo_CORBA_StringDef_bound_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA::ULong & bound
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    bound_ (bound)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_StringDef_bound_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= bound_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_StringDef_bound_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_StringDef_bound_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation.
//

_TAO_CORBA_StringDef_Proxy_Impl::_TAO_CORBA_StringDef_Proxy_Impl (void)
{}

_TAO_CORBA_StringDef_Remote_Proxy_Impl::_TAO_CORBA_StringDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::ULong _TAO_CORBA_StringDef_Remote_Proxy_Impl::bound (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::ULong _tao_retval = 0;


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_bound",
      10,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_StringDef_bound_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN  (_tao_retval);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                _tao_retval
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA::ULong _tao_retval_info = _tao_retval;
          ri.result (_tao_retval_info);

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN  (_tao_retval);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN  (_tao_retval);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_retval;
}

void _TAO_CORBA_StringDef_Remote_Proxy_Impl::bound (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong bound
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_bound",
      10,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_StringDef_bound_set ri (
        &_tao_call,
        _collocated_tao_target_,
        bound
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << bound)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }


#if TAO_HAS_INTERCEPTORS == 1

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }

}


//
//            End  Base & Remote  Proxy Implemeentation.
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_CORBA_StringDef_Proxy_Broker::_TAO_CORBA_StringDef_Proxy_Broker (void)
{
}

_TAO_CORBA_StringDef_Proxy_Broker::~_TAO_CORBA_StringDef_Proxy_Broker (void)
{
}

_TAO_CORBA_StringDef_Proxy_Broker * (*_TAO_CORBA_StringDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_CORBA_StringDef_Remote_Proxy_Broker *
_TAO_CORBA_StringDef_Remote_Proxy_Broker::the_TAO_CORBA_StringDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_CORBA_StringDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_CORBA_StringDef_Remote_Proxy_Broker::_TAO_CORBA_StringDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_StringDef_Remote_Proxy_Broker::~_TAO_CORBA_StringDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_StringDef_Proxy_Impl&
_TAO_CORBA_StringDef_Remote_Proxy_Broker::select_proxy (
  ::CORBA_StringDef *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
CORBA_StringDef::CORBA_StringDef (int collocated)
{
  this->CORBA_StringDef_setup_collocation (collocated);
}

// destructor
CORBA_StringDef::~CORBA_StringDef (void)
{}

void
CORBA_StringDef::CORBA_StringDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_CORBA_StringDef_Proxy_Broker_ =
      ::_TAO_CORBA_StringDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_CORBA_StringDef_Proxy_Broker_ =
      ::_TAO_CORBA_StringDef_Remote_Proxy_Broker::the_TAO_CORBA_StringDef_Remote_Proxy_Broker ();

  this->CORBA_IDLType_setup_collocation (collocated);
}

void CORBA_StringDef::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_StringDef *tmp = ACE_static_cast (CORBA_StringDef*, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA_StringDef_ptr CORBA_StringDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_StringDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/StringDef:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (CORBA_StringDef::_nil ());
      if (is_a == 0)
        return CORBA_StringDef::_nil ();
    }
  return CORBA_StringDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA_StringDef_ptr CORBA_StringDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_StringDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      CORBA_StringDef_ptr default_proxy = CORBA_StringDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_CORBA_StringDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::CORBA_StringDef (
            stub,
            1,
            obj->_servant ()),

          CORBA_StringDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::CORBA_StringDef (stub, 0, obj->_servant ()), CORBA_StringDef::_nil ());
        return default_proxy;
      }
    else
      return
        ACE_reinterpret_cast
          (
            CORBA_StringDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &CORBA_StringDef::_tao_class_id
                    )
                )
          );
}

CORBA_StringDef_ptr
CORBA_StringDef::_duplicate (CORBA_StringDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean CORBA_StringDef::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/StringDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *CORBA_StringDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_StringDef::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IDLType::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* CORBA_StringDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/StringDef:1.0";
}

CORBA::ULong CORBA_StringDef::bound (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_StringDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_StringDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.bound (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

void CORBA_StringDef::bound (
    CORBA::ULong bound
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_StringDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_StringDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  proxy.bound (
      this,
      bound
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA_WstringDef_ptr
tao_CORBA_WstringDef_duplicate (
    CORBA_WstringDef_ptr p
  )
{
  return CORBA_WstringDef::_duplicate (p);
}

void
tao_CORBA_WstringDef_release (
    CORBA_WstringDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA_WstringDef_ptr
tao_CORBA_WstringDef_nil (
    void
  )
{
  return CORBA_WstringDef::_nil ();
}

CORBA_WstringDef_ptr
tao_CORBA_WstringDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA_WstringDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_WstringDef_upcast (
    void *src
  )
{
  CORBA_WstringDef **tmp =
    ACE_static_cast (CORBA_WstringDef **, src);
  return *tmp;
}

int CORBA_WstringDef::_tao_class_id = 0;

// *************************************************************
// Operations for class CORBA_WstringDef_var
// *************************************************************

CORBA_WstringDef_var::CORBA_WstringDef_var (void) // default constructor
  : ptr_ (CORBA_WstringDef::_nil ())
{}

::CORBA_WstringDef_ptr
CORBA_WstringDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA_WstringDef_var::CORBA_WstringDef_var (const ::CORBA_WstringDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (CORBA_WstringDef::_duplicate (p.ptr ()))
{}

CORBA_WstringDef_var::~CORBA_WstringDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

CORBA_WstringDef_var &
CORBA_WstringDef_var::operator= (CORBA_WstringDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA_WstringDef_var &
CORBA_WstringDef_var::operator= (const ::CORBA_WstringDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA_WstringDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA_WstringDef_var::operator const ::CORBA_WstringDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA_WstringDef_var::operator ::CORBA_WstringDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_WstringDef_ptr
CORBA_WstringDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA_WstringDef_ptr
CORBA_WstringDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA_WstringDef_ptr &
CORBA_WstringDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA_WstringDef_ptr &
CORBA_WstringDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_WstringDef::_nil ();
  return this->ptr_;
}

::CORBA_WstringDef_ptr
CORBA_WstringDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA_WstringDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA_WstringDef::_nil ();
  return val;
}

::CORBA_WstringDef_ptr
CORBA_WstringDef_var::tao_duplicate (CORBA_WstringDef_ptr p)
{
  return ::CORBA_WstringDef::_duplicate (p);
}

void
CORBA_WstringDef_var::tao_release (CORBA_WstringDef_ptr p)
{
  CORBA::release (p);
}

::CORBA_WstringDef_ptr
CORBA_WstringDef_var::tao_nil (void)
{
  return ::CORBA_WstringDef::_nil ();
}

::CORBA_WstringDef_ptr
CORBA_WstringDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA_WstringDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA_WstringDef_var::tao_upcast (void *src)
{
  CORBA_WstringDef **tmp =
    ACE_static_cast (CORBA_WstringDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class CORBA_WstringDef_out
// *************************************************************

CORBA_WstringDef_out::CORBA_WstringDef_out (CORBA_WstringDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA_WstringDef::_nil ();
}

CORBA_WstringDef_out::CORBA_WstringDef_out (CORBA_WstringDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_WstringDef::_nil ();
}

CORBA_WstringDef_out::CORBA_WstringDef_out (const ::CORBA_WstringDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (CORBA_WstringDef_out &, p).ptr_)
{}

::CORBA_WstringDef_out &
CORBA_WstringDef_out::operator= (const ::CORBA_WstringDef_out &p)
{
  this->ptr_ = ACE_const_cast (CORBA_WstringDef_out&, p).ptr_;
  return *this;
}

CORBA_WstringDef_out &
CORBA_WstringDef_out::operator= (const ::CORBA_WstringDef_var &p)
{
  this->ptr_ = ::CORBA_WstringDef::_duplicate (p.ptr ());
  return *this;
}

CORBA_WstringDef_out &
CORBA_WstringDef_out::operator= (CORBA_WstringDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA_WstringDef_out::operator ::CORBA_WstringDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_WstringDef_ptr &
CORBA_WstringDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::CORBA_WstringDef_ptr
CORBA_WstringDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_CORBA_WstringDef_bound_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_WstringDef_bound_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::ULong result);

private:
  TAO_ClientRequestInfo_CORBA_WstringDef_bound_get (const TAO_ClientRequestInfo_CORBA_WstringDef_bound_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_WstringDef_bound_get &);

  CORBA::ULong _result;
};

TAO_ClientRequestInfo_CORBA_WstringDef_bound_get::TAO_ClientRequestInfo_CORBA_WstringDef_bound_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_WstringDef_bound_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_WstringDef_bound_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_WstringDef_bound_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_WstringDef_bound_get::result (CORBA::ULong result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_WstringDef_bound_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_WstringDef_bound_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ULong & bound
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_CORBA_WstringDef_bound_set (const TAO_ClientRequestInfo_CORBA_WstringDef_bound_set &);
  void operator= (const TAO_ClientRequestInfo_CORBA_WstringDef_bound_set &);

  const CORBA::ULong & bound_;

};

TAO_ClientRequestInfo_CORBA_WstringDef_bound_set::TAO_ClientRequestInfo_CORBA_WstringDef_bound_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA::ULong & bound
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    bound_ (bound)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_WstringDef_bound_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= bound_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_WstringDef_bound_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_WstringDef_bound_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation.
//

_TAO_CORBA_WstringDef_Proxy_Impl::_TAO_CORBA_WstringDef_Proxy_Impl (void)
{}

_TAO_CORBA_WstringDef_Remote_Proxy_Impl::_TAO_CORBA_WstringDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::ULong _TAO_CORBA_WstringDef_Remote_Proxy_Impl::bound (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::ULong _tao_retval = 0;


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_bound",
      10,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_WstringDef_bound_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN  (_tao_retval);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                _tao_retval
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA::ULong _tao_retval_info = _tao_retval;
          ri.result (_tao_retval_info);

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN  (_tao_retval);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN  (_tao_retval);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_retval;
}

void _TAO_CORBA_WstringDef_Remote_Proxy_Impl::bound (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong bound
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_bound",
      10,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_WstringDef_bound_set ri (
        &_tao_call,
        _collocated_tao_target_,
        bound
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << bound)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }


#if TAO_HAS_INTERCEPTORS == 1

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }

}


//
//            End  Base & Remote  Proxy Implemeentation.
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_CORBA_WstringDef_Proxy_Broker::_TAO_CORBA_WstringDef_Proxy_Broker (void)
{
}

_TAO_CORBA_WstringDef_Proxy_Broker::~_TAO_CORBA_WstringDef_Proxy_Broker (void)
{
}

_TAO_CORBA_WstringDef_Proxy_Broker * (*_TAO_CORBA_WstringDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_CORBA_WstringDef_Remote_Proxy_Broker *
_TAO_CORBA_WstringDef_Remote_Proxy_Broker::the_TAO_CORBA_WstringDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_CORBA_WstringDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_CORBA_WstringDef_Remote_Proxy_Broker::_TAO_CORBA_WstringDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_WstringDef_Remote_Proxy_Broker::~_TAO_CORBA_WstringDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_WstringDef_Proxy_Impl&
_TAO_CORBA_WstringDef_Remote_Proxy_Broker::select_proxy (
  ::CORBA_WstringDef *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
CORBA_WstringDef::CORBA_WstringDef (int collocated)
{
  this->CORBA_WstringDef_setup_collocation (collocated);
}

// destructor
CORBA_WstringDef::~CORBA_WstringDef (void)
{}

void
CORBA_WstringDef::CORBA_WstringDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_CORBA_WstringDef_Proxy_Broker_ =
      ::_TAO_CORBA_WstringDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_CORBA_WstringDef_Proxy_Broker_ =
      ::_TAO_CORBA_WstringDef_Remote_Proxy_Broker::the_TAO_CORBA_WstringDef_Remote_Proxy_Broker ();

  this->CORBA_IDLType_setup_collocation (collocated);
}

void CORBA_WstringDef::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_WstringDef *tmp = ACE_static_cast (CORBA_WstringDef*, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA_WstringDef_ptr CORBA_WstringDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_WstringDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/WstringDef:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (CORBA_WstringDef::_nil ());
      if (is_a == 0)
        return CORBA_WstringDef::_nil ();
    }
  return CORBA_WstringDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA_WstringDef_ptr CORBA_WstringDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_WstringDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      CORBA_WstringDef_ptr default_proxy = CORBA_WstringDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_CORBA_WstringDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::CORBA_WstringDef (
            stub,
            1,
            obj->_servant ()),

          CORBA_WstringDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::CORBA_WstringDef (stub, 0, obj->_servant ()), CORBA_WstringDef::_nil ());
        return default_proxy;
      }
    else
      return
        ACE_reinterpret_cast
          (
            CORBA_WstringDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &CORBA_WstringDef::_tao_class_id
                    )
                )
          );
}

CORBA_WstringDef_ptr
CORBA_WstringDef::_duplicate (CORBA_WstringDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean CORBA_WstringDef::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/WstringDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *CORBA_WstringDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_WstringDef::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IDLType::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* CORBA_WstringDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/WstringDef:1.0";
}

CORBA::ULong CORBA_WstringDef::bound (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_WstringDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_WstringDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.bound (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

void CORBA_WstringDef::bound (
    CORBA::ULong bound
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_WstringDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_WstringDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  proxy.bound (
      this,
      bound
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA_SequenceDef_ptr
tao_CORBA_SequenceDef_duplicate (
    CORBA_SequenceDef_ptr p
  )
{
  return CORBA_SequenceDef::_duplicate (p);
}

void
tao_CORBA_SequenceDef_release (
    CORBA_SequenceDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA_SequenceDef_ptr
tao_CORBA_SequenceDef_nil (
    void
  )
{
  return CORBA_SequenceDef::_nil ();
}

CORBA_SequenceDef_ptr
tao_CORBA_SequenceDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA_SequenceDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_SequenceDef_upcast (
    void *src
  )
{
  CORBA_SequenceDef **tmp =
    ACE_static_cast (CORBA_SequenceDef **, src);
  return *tmp;
}

int CORBA_SequenceDef::_tao_class_id = 0;

// *************************************************************
// Operations for class CORBA_SequenceDef_var
// *************************************************************

CORBA_SequenceDef_var::CORBA_SequenceDef_var (void) // default constructor
  : ptr_ (CORBA_SequenceDef::_nil ())
{}

::CORBA_SequenceDef_ptr
CORBA_SequenceDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA_SequenceDef_var::CORBA_SequenceDef_var (const ::CORBA_SequenceDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (CORBA_SequenceDef::_duplicate (p.ptr ()))
{}

CORBA_SequenceDef_var::~CORBA_SequenceDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

CORBA_SequenceDef_var &
CORBA_SequenceDef_var::operator= (CORBA_SequenceDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA_SequenceDef_var &
CORBA_SequenceDef_var::operator= (const ::CORBA_SequenceDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA_SequenceDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA_SequenceDef_var::operator const ::CORBA_SequenceDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA_SequenceDef_var::operator ::CORBA_SequenceDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_SequenceDef_ptr
CORBA_SequenceDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA_SequenceDef_ptr
CORBA_SequenceDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA_SequenceDef_ptr &
CORBA_SequenceDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA_SequenceDef_ptr &
CORBA_SequenceDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_SequenceDef::_nil ();
  return this->ptr_;
}

::CORBA_SequenceDef_ptr
CORBA_SequenceDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA_SequenceDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA_SequenceDef::_nil ();
  return val;
}

::CORBA_SequenceDef_ptr
CORBA_SequenceDef_var::tao_duplicate (CORBA_SequenceDef_ptr p)
{
  return ::CORBA_SequenceDef::_duplicate (p);
}

void
CORBA_SequenceDef_var::tao_release (CORBA_SequenceDef_ptr p)
{
  CORBA::release (p);
}

::CORBA_SequenceDef_ptr
CORBA_SequenceDef_var::tao_nil (void)
{
  return ::CORBA_SequenceDef::_nil ();
}

::CORBA_SequenceDef_ptr
CORBA_SequenceDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA_SequenceDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA_SequenceDef_var::tao_upcast (void *src)
{
  CORBA_SequenceDef **tmp =
    ACE_static_cast (CORBA_SequenceDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class CORBA_SequenceDef_out
// *************************************************************

CORBA_SequenceDef_out::CORBA_SequenceDef_out (CORBA_SequenceDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA_SequenceDef::_nil ();
}

CORBA_SequenceDef_out::CORBA_SequenceDef_out (CORBA_SequenceDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_SequenceDef::_nil ();
}

CORBA_SequenceDef_out::CORBA_SequenceDef_out (const ::CORBA_SequenceDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (CORBA_SequenceDef_out &, p).ptr_)
{}

::CORBA_SequenceDef_out &
CORBA_SequenceDef_out::operator= (const ::CORBA_SequenceDef_out &p)
{
  this->ptr_ = ACE_const_cast (CORBA_SequenceDef_out&, p).ptr_;
  return *this;
}

CORBA_SequenceDef_out &
CORBA_SequenceDef_out::operator= (const ::CORBA_SequenceDef_var &p)
{
  this->ptr_ = ::CORBA_SequenceDef::_duplicate (p.ptr ());
  return *this;
}

CORBA_SequenceDef_out &
CORBA_SequenceDef_out::operator= (CORBA_SequenceDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA_SequenceDef_out::operator ::CORBA_SequenceDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_SequenceDef_ptr &
CORBA_SequenceDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::CORBA_SequenceDef_ptr
CORBA_SequenceDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_CORBA_SequenceDef_bound_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_SequenceDef_bound_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::ULong result);

private:
  TAO_ClientRequestInfo_CORBA_SequenceDef_bound_get (const TAO_ClientRequestInfo_CORBA_SequenceDef_bound_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_SequenceDef_bound_get &);

  CORBA::ULong _result;
};

TAO_ClientRequestInfo_CORBA_SequenceDef_bound_get::TAO_ClientRequestInfo_CORBA_SequenceDef_bound_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_SequenceDef_bound_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_SequenceDef_bound_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_SequenceDef_bound_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_SequenceDef_bound_get::result (CORBA::ULong result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_SequenceDef_bound_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_SequenceDef_bound_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ULong & bound
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_CORBA_SequenceDef_bound_set (const TAO_ClientRequestInfo_CORBA_SequenceDef_bound_set &);
  void operator= (const TAO_ClientRequestInfo_CORBA_SequenceDef_bound_set &);

  const CORBA::ULong & bound_;

};

TAO_ClientRequestInfo_CORBA_SequenceDef_bound_set::TAO_ClientRequestInfo_CORBA_SequenceDef_bound_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA::ULong & bound
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    bound_ (bound)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_SequenceDef_bound_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= bound_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_SequenceDef_bound_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_SequenceDef_bound_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

class TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::TypeCode_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_get (const TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_get &);

  CORBA::TypeCode_ptr _result;
};

TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_get::TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_get::result (CORBA::TypeCode_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_IDLType_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_get (const TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_get &);

  CORBA_IDLType_ptr _result;
};

TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_get::TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_get::result (CORBA_IDLType_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA_IDLType_ptr element_type_def
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_set (const TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_set &);
  void operator= (const TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_set &);

  CORBA_IDLType_ptr element_type_def_;

};

TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_set::TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA_IDLType_ptr element_type_def
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    element_type_def_ (element_type_def)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->element_type_def_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation.
//

_TAO_CORBA_SequenceDef_Proxy_Impl::_TAO_CORBA_SequenceDef_Proxy_Impl (void)
{}

_TAO_CORBA_SequenceDef_Remote_Proxy_Impl::_TAO_CORBA_SequenceDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::ULong _TAO_CORBA_SequenceDef_Remote_Proxy_Impl::bound (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::ULong _tao_retval = 0;


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_bound",
      10,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_SequenceDef_bound_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN  (_tao_retval);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                _tao_retval
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA::ULong _tao_retval_info = _tao_retval;
          ri.result (_tao_retval_info);

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN  (_tao_retval);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN  (_tao_retval);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_retval;
}

void _TAO_CORBA_SequenceDef_Remote_Proxy_Impl::bound (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong bound
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_bound",
      10,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_SequenceDef_bound_set ri (
        &_tao_call,
        _collocated_tao_target_,
        bound
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << bound)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }


#if TAO_HAS_INTERCEPTORS == 1

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }

}

CORBA::TypeCode_ptr _TAO_CORBA_SequenceDef_Remote_Proxy_Impl::element_type (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_element_type",
      17,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA::TypeCode_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

CORBA_IDLType_ptr _TAO_CORBA_SequenceDef_Remote_Proxy_Impl::element_type_def (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_IDLType_ptr _tao_retval = CORBA_IDLType::_nil ();
  CORBA_IDLType_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_element_type_def",
      21,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA_IDLType_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

void _TAO_CORBA_SequenceDef_Remote_Proxy_Impl::element_type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA_IDLType_ptr element_type_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_element_type_def",
      21,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_set ri (
        &_tao_call,
        _collocated_tao_target_,
        element_type_def
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << element_type_def)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }


#if TAO_HAS_INTERCEPTORS == 1

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }

}


//
//            End  Base & Remote  Proxy Implemeentation.
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_CORBA_SequenceDef_Proxy_Broker::_TAO_CORBA_SequenceDef_Proxy_Broker (void)
{
}

_TAO_CORBA_SequenceDef_Proxy_Broker::~_TAO_CORBA_SequenceDef_Proxy_Broker (void)
{
}

_TAO_CORBA_SequenceDef_Proxy_Broker * (*_TAO_CORBA_SequenceDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_CORBA_SequenceDef_Remote_Proxy_Broker *
_TAO_CORBA_SequenceDef_Remote_Proxy_Broker::the_TAO_CORBA_SequenceDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_CORBA_SequenceDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_CORBA_SequenceDef_Remote_Proxy_Broker::_TAO_CORBA_SequenceDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_SequenceDef_Remote_Proxy_Broker::~_TAO_CORBA_SequenceDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_SequenceDef_Proxy_Impl&
_TAO_CORBA_SequenceDef_Remote_Proxy_Broker::select_proxy (
  ::CORBA_SequenceDef *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
CORBA_SequenceDef::CORBA_SequenceDef (int collocated)
{
  this->CORBA_SequenceDef_setup_collocation (collocated);
}

// destructor
CORBA_SequenceDef::~CORBA_SequenceDef (void)
{}

void
CORBA_SequenceDef::CORBA_SequenceDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_CORBA_SequenceDef_Proxy_Broker_ =
      ::_TAO_CORBA_SequenceDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_CORBA_SequenceDef_Proxy_Broker_ =
      ::_TAO_CORBA_SequenceDef_Remote_Proxy_Broker::the_TAO_CORBA_SequenceDef_Remote_Proxy_Broker ();

  this->CORBA_IDLType_setup_collocation (collocated);
}

void CORBA_SequenceDef::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_SequenceDef *tmp = ACE_static_cast (CORBA_SequenceDef*, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA_SequenceDef_ptr CORBA_SequenceDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_SequenceDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/SequenceDef:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (CORBA_SequenceDef::_nil ());
      if (is_a == 0)
        return CORBA_SequenceDef::_nil ();
    }
  return CORBA_SequenceDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA_SequenceDef_ptr CORBA_SequenceDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_SequenceDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      CORBA_SequenceDef_ptr default_proxy = CORBA_SequenceDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_CORBA_SequenceDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::CORBA_SequenceDef (
            stub,
            1,
            obj->_servant ()),

          CORBA_SequenceDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::CORBA_SequenceDef (stub, 0, obj->_servant ()), CORBA_SequenceDef::_nil ());
        return default_proxy;
      }
    else
      return
        ACE_reinterpret_cast
          (
            CORBA_SequenceDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &CORBA_SequenceDef::_tao_class_id
                    )
                )
          );
}

CORBA_SequenceDef_ptr
CORBA_SequenceDef::_duplicate (CORBA_SequenceDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean CORBA_SequenceDef::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/SequenceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *CORBA_SequenceDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_SequenceDef::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IDLType::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* CORBA_SequenceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/SequenceDef:1.0";
}

CORBA::ULong CORBA_SequenceDef::bound (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_SequenceDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_SequenceDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.bound (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

void CORBA_SequenceDef::bound (
    CORBA::ULong bound
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_SequenceDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_SequenceDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  proxy.bound (
      this,
      bound
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA::TypeCode_ptr CORBA_SequenceDef::element_type (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_SequenceDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_SequenceDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.element_type (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA_IDLType_ptr CORBA_SequenceDef::element_type_def (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_SequenceDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_SequenceDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.element_type_def (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

void CORBA_SequenceDef::element_type_def (
    CORBA_IDLType_ptr element_type_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_SequenceDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_SequenceDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  proxy.element_type_def (
      this,
      element_type_def
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA_ArrayDef_ptr
tao_CORBA_ArrayDef_duplicate (
    CORBA_ArrayDef_ptr p
  )
{
  return CORBA_ArrayDef::_duplicate (p);
}

void
tao_CORBA_ArrayDef_release (
    CORBA_ArrayDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA_ArrayDef_ptr
tao_CORBA_ArrayDef_nil (
    void
  )
{
  return CORBA_ArrayDef::_nil ();
}

CORBA_ArrayDef_ptr
tao_CORBA_ArrayDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA_ArrayDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_ArrayDef_upcast (
    void *src
  )
{
  CORBA_ArrayDef **tmp =
    ACE_static_cast (CORBA_ArrayDef **, src);
  return *tmp;
}

int CORBA_ArrayDef::_tao_class_id = 0;

// *************************************************************
// Operations for class CORBA_ArrayDef_var
// *************************************************************

CORBA_ArrayDef_var::CORBA_ArrayDef_var (void) // default constructor
  : ptr_ (CORBA_ArrayDef::_nil ())
{}

::CORBA_ArrayDef_ptr
CORBA_ArrayDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA_ArrayDef_var::CORBA_ArrayDef_var (const ::CORBA_ArrayDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (CORBA_ArrayDef::_duplicate (p.ptr ()))
{}

CORBA_ArrayDef_var::~CORBA_ArrayDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

CORBA_ArrayDef_var &
CORBA_ArrayDef_var::operator= (CORBA_ArrayDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA_ArrayDef_var &
CORBA_ArrayDef_var::operator= (const ::CORBA_ArrayDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA_ArrayDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA_ArrayDef_var::operator const ::CORBA_ArrayDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA_ArrayDef_var::operator ::CORBA_ArrayDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_ArrayDef_ptr
CORBA_ArrayDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA_ArrayDef_ptr
CORBA_ArrayDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA_ArrayDef_ptr &
CORBA_ArrayDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA_ArrayDef_ptr &
CORBA_ArrayDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_ArrayDef::_nil ();
  return this->ptr_;
}

::CORBA_ArrayDef_ptr
CORBA_ArrayDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA_ArrayDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA_ArrayDef::_nil ();
  return val;
}

::CORBA_ArrayDef_ptr
CORBA_ArrayDef_var::tao_duplicate (CORBA_ArrayDef_ptr p)
{
  return ::CORBA_ArrayDef::_duplicate (p);
}

void
CORBA_ArrayDef_var::tao_release (CORBA_ArrayDef_ptr p)
{
  CORBA::release (p);
}

::CORBA_ArrayDef_ptr
CORBA_ArrayDef_var::tao_nil (void)
{
  return ::CORBA_ArrayDef::_nil ();
}

::CORBA_ArrayDef_ptr
CORBA_ArrayDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA_ArrayDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA_ArrayDef_var::tao_upcast (void *src)
{
  CORBA_ArrayDef **tmp =
    ACE_static_cast (CORBA_ArrayDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class CORBA_ArrayDef_out
// *************************************************************

CORBA_ArrayDef_out::CORBA_ArrayDef_out (CORBA_ArrayDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA_ArrayDef::_nil ();
}

CORBA_ArrayDef_out::CORBA_ArrayDef_out (CORBA_ArrayDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_ArrayDef::_nil ();
}

CORBA_ArrayDef_out::CORBA_ArrayDef_out (const ::CORBA_ArrayDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (CORBA_ArrayDef_out &, p).ptr_)
{}

::CORBA_ArrayDef_out &
CORBA_ArrayDef_out::operator= (const ::CORBA_ArrayDef_out &p)
{
  this->ptr_ = ACE_const_cast (CORBA_ArrayDef_out&, p).ptr_;
  return *this;
}

CORBA_ArrayDef_out &
CORBA_ArrayDef_out::operator= (const ::CORBA_ArrayDef_var &p)
{
  this->ptr_ = ::CORBA_ArrayDef::_duplicate (p.ptr ());
  return *this;
}

CORBA_ArrayDef_out &
CORBA_ArrayDef_out::operator= (CORBA_ArrayDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA_ArrayDef_out::operator ::CORBA_ArrayDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_ArrayDef_ptr &
CORBA_ArrayDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::CORBA_ArrayDef_ptr
CORBA_ArrayDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_CORBA_ArrayDef_length_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ArrayDef_length_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::ULong result);

private:
  TAO_ClientRequestInfo_CORBA_ArrayDef_length_get (const TAO_ClientRequestInfo_CORBA_ArrayDef_length_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_ArrayDef_length_get &);

  CORBA::ULong _result;
};

TAO_ClientRequestInfo_CORBA_ArrayDef_length_get::TAO_ClientRequestInfo_CORBA_ArrayDef_length_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ArrayDef_length_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ArrayDef_length_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_ArrayDef_length_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_ArrayDef_length_get::result (CORBA::ULong result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_ArrayDef_length_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ArrayDef_length_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ULong & length
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_CORBA_ArrayDef_length_set (const TAO_ClientRequestInfo_CORBA_ArrayDef_length_set &);
  void operator= (const TAO_ClientRequestInfo_CORBA_ArrayDef_length_set &);

  const CORBA::ULong & length_;

};

TAO_ClientRequestInfo_CORBA_ArrayDef_length_set::TAO_ClientRequestInfo_CORBA_ArrayDef_length_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA::ULong & length
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    length_ (length)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ArrayDef_length_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= length_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ArrayDef_length_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_ArrayDef_length_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

class TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::TypeCode_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_get (const TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_get &);

  CORBA::TypeCode_ptr _result;
};

TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_get::TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_get::result (CORBA::TypeCode_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_IDLType_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_get (const TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_get &);

  CORBA_IDLType_ptr _result;
};

TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_get::TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_get::result (CORBA_IDLType_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA_IDLType_ptr element_type_def
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_set (const TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_set &);
  void operator= (const TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_set &);

  CORBA_IDLType_ptr element_type_def_;

};

TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_set::TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA_IDLType_ptr element_type_def
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    element_type_def_ (element_type_def)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->element_type_def_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation.
//

_TAO_CORBA_ArrayDef_Proxy_Impl::_TAO_CORBA_ArrayDef_Proxy_Impl (void)
{}

_TAO_CORBA_ArrayDef_Remote_Proxy_Impl::_TAO_CORBA_ArrayDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::ULong _TAO_CORBA_ArrayDef_Remote_Proxy_Impl::length (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::ULong _tao_retval = 0;


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_length",
      11,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ArrayDef_length_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN  (_tao_retval);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                _tao_retval
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA::ULong _tao_retval_info = _tao_retval;
          ri.result (_tao_retval_info);

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN  (_tao_retval);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN  (_tao_retval);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_retval;
}

void _TAO_CORBA_ArrayDef_Remote_Proxy_Impl::length (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong length
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_length",
      11,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ArrayDef_length_set ri (
        &_tao_call,
        _collocated_tao_target_,
        length
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << length)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }


#if TAO_HAS_INTERCEPTORS == 1

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }

}

CORBA::TypeCode_ptr _TAO_CORBA_ArrayDef_Remote_Proxy_Impl::element_type (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_element_type",
      17,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA::TypeCode_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

CORBA_IDLType_ptr _TAO_CORBA_ArrayDef_Remote_Proxy_Impl::element_type_def (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_IDLType_ptr _tao_retval = CORBA_IDLType::_nil ();
  CORBA_IDLType_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_element_type_def",
      21,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA_IDLType_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

void _TAO_CORBA_ArrayDef_Remote_Proxy_Impl::element_type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA_IDLType_ptr element_type_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_element_type_def",
      21,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_set ri (
        &_tao_call,
        _collocated_tao_target_,
        element_type_def
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << element_type_def)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }


#if TAO_HAS_INTERCEPTORS == 1

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }

}


//
//            End  Base & Remote  Proxy Implemeentation.
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_CORBA_ArrayDef_Proxy_Broker::_TAO_CORBA_ArrayDef_Proxy_Broker (void)
{
}

_TAO_CORBA_ArrayDef_Proxy_Broker::~_TAO_CORBA_ArrayDef_Proxy_Broker (void)
{
}

_TAO_CORBA_ArrayDef_Proxy_Broker * (*_TAO_CORBA_ArrayDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_CORBA_ArrayDef_Remote_Proxy_Broker *
_TAO_CORBA_ArrayDef_Remote_Proxy_Broker::the_TAO_CORBA_ArrayDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_CORBA_ArrayDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_CORBA_ArrayDef_Remote_Proxy_Broker::_TAO_CORBA_ArrayDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_ArrayDef_Remote_Proxy_Broker::~_TAO_CORBA_ArrayDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_ArrayDef_Proxy_Impl&
_TAO_CORBA_ArrayDef_Remote_Proxy_Broker::select_proxy (
  ::CORBA_ArrayDef *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
CORBA_ArrayDef::CORBA_ArrayDef (int collocated)
{
  this->CORBA_ArrayDef_setup_collocation (collocated);
}

// destructor
CORBA_ArrayDef::~CORBA_ArrayDef (void)
{}

void
CORBA_ArrayDef::CORBA_ArrayDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_CORBA_ArrayDef_Proxy_Broker_ =
      ::_TAO_CORBA_ArrayDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_CORBA_ArrayDef_Proxy_Broker_ =
      ::_TAO_CORBA_ArrayDef_Remote_Proxy_Broker::the_TAO_CORBA_ArrayDef_Remote_Proxy_Broker ();

  this->CORBA_IDLType_setup_collocation (collocated);
}

void CORBA_ArrayDef::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_ArrayDef *tmp = ACE_static_cast (CORBA_ArrayDef*, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA_ArrayDef_ptr CORBA_ArrayDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_ArrayDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/ArrayDef:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (CORBA_ArrayDef::_nil ());
      if (is_a == 0)
        return CORBA_ArrayDef::_nil ();
    }
  return CORBA_ArrayDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA_ArrayDef_ptr CORBA_ArrayDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_ArrayDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      CORBA_ArrayDef_ptr default_proxy = CORBA_ArrayDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_CORBA_ArrayDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::CORBA_ArrayDef (
            stub,
            1,
            obj->_servant ()),

          CORBA_ArrayDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::CORBA_ArrayDef (stub, 0, obj->_servant ()), CORBA_ArrayDef::_nil ());
        return default_proxy;
      }
    else
      return
        ACE_reinterpret_cast
          (
            CORBA_ArrayDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &CORBA_ArrayDef::_tao_class_id
                    )
                )
          );
}

CORBA_ArrayDef_ptr
CORBA_ArrayDef::_duplicate (CORBA_ArrayDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean CORBA_ArrayDef::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ArrayDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *CORBA_ArrayDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_ArrayDef::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IDLType::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* CORBA_ArrayDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ArrayDef:1.0";
}

CORBA::ULong CORBA_ArrayDef::length (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_ArrayDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_ArrayDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.length (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

void CORBA_ArrayDef::length (
    CORBA::ULong length
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_ArrayDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_ArrayDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  proxy.length (
      this,
      length
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA::TypeCode_ptr CORBA_ArrayDef::element_type (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_ArrayDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_ArrayDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.element_type (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA_IDLType_ptr CORBA_ArrayDef::element_type_def (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_ArrayDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_ArrayDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.element_type_def (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

void CORBA_ArrayDef::element_type_def (
    CORBA_IDLType_ptr element_type_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_ArrayDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_ArrayDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  proxy.element_type_def (
      this,
      element_type_def
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA_ExceptionDef_ptr
tao_CORBA_ExceptionDef_duplicate (
    CORBA_ExceptionDef_ptr p
  )
{
  return CORBA_ExceptionDef::_duplicate (p);
}

void
tao_CORBA_ExceptionDef_release (
    CORBA_ExceptionDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA_ExceptionDef_ptr
tao_CORBA_ExceptionDef_nil (
    void
  )
{
  return CORBA_ExceptionDef::_nil ();
}

CORBA_ExceptionDef_ptr
tao_CORBA_ExceptionDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA_ExceptionDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_ExceptionDef_upcast (
    void *src
  )
{
  CORBA_ExceptionDef **tmp =
    ACE_static_cast (CORBA_ExceptionDef **, src);
  return *tmp;
}

int CORBA_ExceptionDef::_tao_class_id = 0;

// *************************************************************
// Operations for class CORBA_ExceptionDef_var
// *************************************************************

CORBA_ExceptionDef_var::CORBA_ExceptionDef_var (void) // default constructor
  : ptr_ (CORBA_ExceptionDef::_nil ())
{}

::CORBA_ExceptionDef_ptr
CORBA_ExceptionDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA_ExceptionDef_var::CORBA_ExceptionDef_var (const ::CORBA_ExceptionDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (CORBA_ExceptionDef::_duplicate (p.ptr ()))
{}

CORBA_ExceptionDef_var::~CORBA_ExceptionDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

CORBA_ExceptionDef_var &
CORBA_ExceptionDef_var::operator= (CORBA_ExceptionDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA_ExceptionDef_var &
CORBA_ExceptionDef_var::operator= (const ::CORBA_ExceptionDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA_ExceptionDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA_ExceptionDef_var::operator const ::CORBA_ExceptionDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA_ExceptionDef_var::operator ::CORBA_ExceptionDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_ExceptionDef_ptr
CORBA_ExceptionDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA_ExceptionDef_ptr
CORBA_ExceptionDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA_ExceptionDef_ptr &
CORBA_ExceptionDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA_ExceptionDef_ptr &
CORBA_ExceptionDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_ExceptionDef::_nil ();
  return this->ptr_;
}

::CORBA_ExceptionDef_ptr
CORBA_ExceptionDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA_ExceptionDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA_ExceptionDef::_nil ();
  return val;
}

::CORBA_ExceptionDef_ptr
CORBA_ExceptionDef_var::tao_duplicate (CORBA_ExceptionDef_ptr p)
{
  return ::CORBA_ExceptionDef::_duplicate (p);
}

void
CORBA_ExceptionDef_var::tao_release (CORBA_ExceptionDef_ptr p)
{
  CORBA::release (p);
}

::CORBA_ExceptionDef_ptr
CORBA_ExceptionDef_var::tao_nil (void)
{
  return ::CORBA_ExceptionDef::_nil ();
}

::CORBA_ExceptionDef_ptr
CORBA_ExceptionDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA_ExceptionDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA_ExceptionDef_var::tao_upcast (void *src)
{
  CORBA_ExceptionDef **tmp =
    ACE_static_cast (CORBA_ExceptionDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class CORBA_ExceptionDef_out
// *************************************************************

CORBA_ExceptionDef_out::CORBA_ExceptionDef_out (CORBA_ExceptionDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA_ExceptionDef::_nil ();
}

CORBA_ExceptionDef_out::CORBA_ExceptionDef_out (CORBA_ExceptionDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_ExceptionDef::_nil ();
}

CORBA_ExceptionDef_out::CORBA_ExceptionDef_out (const ::CORBA_ExceptionDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (CORBA_ExceptionDef_out &, p).ptr_)
{}

::CORBA_ExceptionDef_out &
CORBA_ExceptionDef_out::operator= (const ::CORBA_ExceptionDef_out &p)
{
  this->ptr_ = ACE_const_cast (CORBA_ExceptionDef_out&, p).ptr_;
  return *this;
}

CORBA_ExceptionDef_out &
CORBA_ExceptionDef_out::operator= (const ::CORBA_ExceptionDef_var &p)
{
  this->ptr_ = ::CORBA_ExceptionDef::_duplicate (p.ptr ());
  return *this;
}

CORBA_ExceptionDef_out &
CORBA_ExceptionDef_out::operator= (CORBA_ExceptionDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA_ExceptionDef_out::operator ::CORBA_ExceptionDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_ExceptionDef_ptr &
CORBA_ExceptionDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::CORBA_ExceptionDef_ptr
CORBA_ExceptionDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_CORBA_ExceptionDef_type_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ExceptionDef_type_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::TypeCode_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_ExceptionDef_type_get (const TAO_ClientRequestInfo_CORBA_ExceptionDef_type_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_ExceptionDef_type_get &);

  CORBA::TypeCode_ptr _result;
};

TAO_ClientRequestInfo_CORBA_ExceptionDef_type_get::TAO_ClientRequestInfo_CORBA_ExceptionDef_type_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ExceptionDef_type_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ExceptionDef_type_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_ExceptionDef_type_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_ExceptionDef_type_get::result (CORBA::TypeCode_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_ExceptionDef_members_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ExceptionDef_members_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_StructMemberSeq * result);

private:
  TAO_ClientRequestInfo_CORBA_ExceptionDef_members_get (const TAO_ClientRequestInfo_CORBA_ExceptionDef_members_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_ExceptionDef_members_get &);

  CORBA_StructMemberSeq * _result;
};

TAO_ClientRequestInfo_CORBA_ExceptionDef_members_get::TAO_ClientRequestInfo_CORBA_ExceptionDef_members_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ExceptionDef_members_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ExceptionDef_members_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_ExceptionDef_members_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_ExceptionDef_members_get::result (CORBA_StructMemberSeq * result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_ExceptionDef_members_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ExceptionDef_members_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA_StructMemberSeq & members
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_CORBA_ExceptionDef_members_set (const TAO_ClientRequestInfo_CORBA_ExceptionDef_members_set &);
  void operator= (const TAO_ClientRequestInfo_CORBA_ExceptionDef_members_set &);

  const CORBA_StructMemberSeq & members_;

};

TAO_ClientRequestInfo_CORBA_ExceptionDef_members_set::TAO_ClientRequestInfo_CORBA_ExceptionDef_members_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA_StructMemberSeq & members
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    members_ (members)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ExceptionDef_members_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->members_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ExceptionDef_members_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_ExceptionDef_members_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation.
//

_TAO_CORBA_ExceptionDef_Proxy_Impl::_TAO_CORBA_ExceptionDef_Proxy_Impl (void)
{}

_TAO_CORBA_ExceptionDef_Remote_Proxy_Impl::_TAO_CORBA_ExceptionDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::TypeCode_ptr _TAO_CORBA_ExceptionDef_Remote_Proxy_Impl::type (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_type",
      9,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ExceptionDef_type_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA::TypeCode_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

CORBA_StructMemberSeq * _TAO_CORBA_ExceptionDef_Remote_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_StructMemberSeq *_tao_retval = 0;


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  ACE_NEW_RETURN (_tao_retval, CORBA_StructMemberSeq, _tao_retval);
  CORBA_StructMemberSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_members",
      12,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ExceptionDef_members_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA_StructMemberSeq * _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

void _TAO_CORBA_ExceptionDef_Remote_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    const CORBA_StructMemberSeq & members
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_members",
      12,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ExceptionDef_members_set ri (
        &_tao_call,
        _collocated_tao_target_,
        members
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << members)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }


#if TAO_HAS_INTERCEPTORS == 1

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }

}


//
//            End  Base & Remote  Proxy Implemeentation.
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_CORBA_ExceptionDef_Proxy_Broker::_TAO_CORBA_ExceptionDef_Proxy_Broker (void)
{
}

_TAO_CORBA_ExceptionDef_Proxy_Broker::~_TAO_CORBA_ExceptionDef_Proxy_Broker (void)
{
}

_TAO_CORBA_ExceptionDef_Proxy_Broker * (*_TAO_CORBA_ExceptionDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_CORBA_ExceptionDef_Remote_Proxy_Broker *
_TAO_CORBA_ExceptionDef_Remote_Proxy_Broker::the_TAO_CORBA_ExceptionDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_CORBA_ExceptionDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_CORBA_ExceptionDef_Remote_Proxy_Broker::_TAO_CORBA_ExceptionDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_ExceptionDef_Remote_Proxy_Broker::~_TAO_CORBA_ExceptionDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_ExceptionDef_Proxy_Impl&
_TAO_CORBA_ExceptionDef_Remote_Proxy_Broker::select_proxy (
  ::CORBA_ExceptionDef *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
CORBA_ExceptionDef::CORBA_ExceptionDef (int collocated)
{
  this->CORBA_ExceptionDef_setup_collocation (collocated);
}

// destructor
CORBA_ExceptionDef::~CORBA_ExceptionDef (void)
{}

void
CORBA_ExceptionDef::CORBA_ExceptionDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_CORBA_ExceptionDef_Proxy_Broker_ =
      ::_TAO_CORBA_ExceptionDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_CORBA_ExceptionDef_Proxy_Broker_ =
      ::_TAO_CORBA_ExceptionDef_Remote_Proxy_Broker::the_TAO_CORBA_ExceptionDef_Remote_Proxy_Broker ();

  this->CORBA_Contained_setup_collocation (collocated);

  this->CORBA_Container_setup_collocation (collocated);
}

void CORBA_ExceptionDef::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_ExceptionDef *tmp = ACE_static_cast (CORBA_ExceptionDef*, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA_ExceptionDef_ptr CORBA_ExceptionDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_ExceptionDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/ExceptionDef:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (CORBA_ExceptionDef::_nil ());
      if (is_a == 0)
        return CORBA_ExceptionDef::_nil ();
    }
  return CORBA_ExceptionDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA_ExceptionDef_ptr CORBA_ExceptionDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_ExceptionDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      CORBA_ExceptionDef_ptr default_proxy = CORBA_ExceptionDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_CORBA_ExceptionDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::CORBA_ExceptionDef (
            stub,
            1,
            obj->_servant ()),

          CORBA_ExceptionDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::CORBA_ExceptionDef (stub, 0, obj->_servant ()), CORBA_ExceptionDef::_nil ());
        return default_proxy;
      }
    else
      return
        ACE_reinterpret_cast
          (
            CORBA_ExceptionDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &CORBA_ExceptionDef::_tao_class_id
                    )
                )
          );
}

CORBA_ExceptionDef_ptr
CORBA_ExceptionDef::_duplicate (CORBA_ExceptionDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean CORBA_ExceptionDef::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ExceptionDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *CORBA_ExceptionDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_ExceptionDef::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Container::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Container_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* CORBA_ExceptionDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ExceptionDef:1.0";
}

CORBA::TypeCode_ptr CORBA_ExceptionDef::type (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_ExceptionDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_ExceptionDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.type (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA_StructMemberSeq * CORBA_ExceptionDef::members (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_ExceptionDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_ExceptionDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.members (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

void CORBA_ExceptionDef::members (
    const CORBA_StructMemberSeq & members
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_ExceptionDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_ExceptionDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  proxy.members (
      this,
      members
      ACE_ENV_ARG_PARAMETER
    );
}

void CORBA_ExceptionDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_ExceptionDescription *tmp = ACE_static_cast (CORBA_ExceptionDescription*, _tao_void_pointer);
  delete tmp;
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_EXCEPTIONDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_EXCEPTIONDEFSEQ_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
_TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq::_allocate_buffer (CORBA::ULong length)
{
  CORBA_ExceptionDef **tmp = 0;
  tmp = _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq::allocbuf (length);

  if (this->buffer_ != 0)
  {
    CORBA_ExceptionDef **old = ACE_reinterpret_cast (CORBA_ExceptionDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        if (!this->release_)
          {
            tmp[i] = CORBA_ExceptionDef::_duplicate (old[i]);
          }
        else
          {
            tmp[i] = old[i];
          }
      }

    if (this->release_)
      {
        delete[] old;
      }
  }
  this->buffer_ = tmp;
}

void
_TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;
  CORBA_ExceptionDef **tmp = ACE_reinterpret_cast (CORBA_ExceptionDef**, this->buffer_);

  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = CORBA_ExceptionDef::_nil ();
    }

  _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq::freebuf (tmp);
  this->buffer_ = 0;
}

_TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq::~_TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq (void)
{
  this->_deallocate_buffer ();
}

void
_TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  CORBA_ExceptionDef **tmp = ACE_reinterpret_cast (CORBA_ExceptionDef**, this->buffer_);

  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = CORBA_ExceptionDef::_nil ();
    }
}

void
_TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq::_downcast (
    void* target,
    CORBA_Object *src
    ACE_ENV_ARG_DECL
  )
{
  CORBA_ExceptionDef **tmp = ACE_static_cast (CORBA_ExceptionDef**, target);
  *tmp = CORBA_ExceptionDef::_narrow (src ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}

CORBA_Object*
_TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq::_upcast (void *src) const
{
  CORBA_ExceptionDef **tmp = ACE_static_cast (CORBA_ExceptionDef**, src);
  return *tmp;
}

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_EXCEPTIONDEFSEQ_CS_)
#define _CORBA_EXCEPTIONDEFSEQ_CS_

// *************************************************************
// CORBA_ExceptionDefSeq
// *************************************************************

CORBA_ExceptionDefSeq::CORBA_ExceptionDefSeq (void)
{}
CORBA_ExceptionDefSeq::CORBA_ExceptionDefSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<CORBA_ExceptionDef,CORBA_ExceptionDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
CORBA_ExceptionDefSeq::CORBA_ExceptionDefSeq (CORBA::ULong max, CORBA::ULong length, CORBA_ExceptionDef_ptr *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<CORBA_ExceptionDef,CORBA_ExceptionDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
CORBA_ExceptionDefSeq::CORBA_ExceptionDefSeq (const CORBA_ExceptionDefSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<CORBA_ExceptionDef,CORBA_ExceptionDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
CORBA_ExceptionDefSeq::~CORBA_ExceptionDefSeq (void) // dtor
{}
void CORBA_ExceptionDefSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_ExceptionDefSeq *tmp = ACE_static_cast (CORBA_ExceptionDefSeq*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_EXCDESCRIPTIONSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_EXCDESCRIPTIONSEQ_CS_

void
_TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq::_allocate_buffer (CORBA::ULong length)
{
  CORBA_ExceptionDescription* tmp = 0;
  tmp = _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq::allocbuf (length);

  if (this->buffer_ != 0)
  {
    CORBA_ExceptionDescription *old = ACE_reinterpret_cast (CORBA_ExceptionDescription *,this->buffer_);

    for (CORBA::ULong i = 0; i < this->length_; ++i)
      tmp[i] = old[i];

    if (this->release_)
      _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq::freebuf (old);

  }
  this->buffer_ = tmp;
}

void
_TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;

  CORBA_ExceptionDescription *tmp = ACE_reinterpret_cast (CORBA_ExceptionDescription *,this->buffer_);

  _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq::freebuf (tmp);
  this->buffer_ = 0;
}

_TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq::~_TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq (void) // Dtor.
{
  this->_deallocate_buffer ();
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_EXCDESCRIPTIONSEQ_CS_)
#define _CORBA_EXCDESCRIPTIONSEQ_CS_

// *************************************************************
// CORBA_ExcDescriptionSeq
// *************************************************************

CORBA_ExcDescriptionSeq::CORBA_ExcDescriptionSeq (void)
{}
CORBA_ExcDescriptionSeq::CORBA_ExcDescriptionSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA_ExceptionDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
CORBA_ExcDescriptionSeq::CORBA_ExcDescriptionSeq (CORBA::ULong max, CORBA::ULong length, CORBA_ExceptionDescription *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA_ExceptionDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
CORBA_ExcDescriptionSeq::CORBA_ExcDescriptionSeq (const CORBA_ExcDescriptionSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA_ExceptionDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
CORBA_ExcDescriptionSeq::~CORBA_ExcDescriptionSeq (void) // dtor
{}
void CORBA_ExcDescriptionSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_ExcDescriptionSeq *tmp = ACE_static_cast (CORBA_ExcDescriptionSeq*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

CORBA_AttributeDef_ptr
tao_CORBA_AttributeDef_duplicate (
    CORBA_AttributeDef_ptr p
  )
{
  return CORBA_AttributeDef::_duplicate (p);
}

void
tao_CORBA_AttributeDef_release (
    CORBA_AttributeDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA_AttributeDef_ptr
tao_CORBA_AttributeDef_nil (
    void
  )
{
  return CORBA_AttributeDef::_nil ();
}

CORBA_AttributeDef_ptr
tao_CORBA_AttributeDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA_AttributeDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_AttributeDef_upcast (
    void *src
  )
{
  CORBA_AttributeDef **tmp =
    ACE_static_cast (CORBA_AttributeDef **, src);
  return *tmp;
}

int CORBA_AttributeDef::_tao_class_id = 0;

// *************************************************************
// Operations for class CORBA_AttributeDef_var
// *************************************************************

CORBA_AttributeDef_var::CORBA_AttributeDef_var (void) // default constructor
  : ptr_ (CORBA_AttributeDef::_nil ())
{}

::CORBA_AttributeDef_ptr
CORBA_AttributeDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA_AttributeDef_var::CORBA_AttributeDef_var (const ::CORBA_AttributeDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (CORBA_AttributeDef::_duplicate (p.ptr ()))
{}

CORBA_AttributeDef_var::~CORBA_AttributeDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

CORBA_AttributeDef_var &
CORBA_AttributeDef_var::operator= (CORBA_AttributeDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA_AttributeDef_var &
CORBA_AttributeDef_var::operator= (const ::CORBA_AttributeDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA_AttributeDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA_AttributeDef_var::operator const ::CORBA_AttributeDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA_AttributeDef_var::operator ::CORBA_AttributeDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_AttributeDef_ptr
CORBA_AttributeDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA_AttributeDef_ptr
CORBA_AttributeDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA_AttributeDef_ptr &
CORBA_AttributeDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA_AttributeDef_ptr &
CORBA_AttributeDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_AttributeDef::_nil ();
  return this->ptr_;
}

::CORBA_AttributeDef_ptr
CORBA_AttributeDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA_AttributeDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA_AttributeDef::_nil ();
  return val;
}

::CORBA_AttributeDef_ptr
CORBA_AttributeDef_var::tao_duplicate (CORBA_AttributeDef_ptr p)
{
  return ::CORBA_AttributeDef::_duplicate (p);
}

void
CORBA_AttributeDef_var::tao_release (CORBA_AttributeDef_ptr p)
{
  CORBA::release (p);
}

::CORBA_AttributeDef_ptr
CORBA_AttributeDef_var::tao_nil (void)
{
  return ::CORBA_AttributeDef::_nil ();
}

::CORBA_AttributeDef_ptr
CORBA_AttributeDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA_AttributeDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA_AttributeDef_var::tao_upcast (void *src)
{
  CORBA_AttributeDef **tmp =
    ACE_static_cast (CORBA_AttributeDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class CORBA_AttributeDef_out
// *************************************************************

CORBA_AttributeDef_out::CORBA_AttributeDef_out (CORBA_AttributeDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA_AttributeDef::_nil ();
}

CORBA_AttributeDef_out::CORBA_AttributeDef_out (CORBA_AttributeDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_AttributeDef::_nil ();
}

CORBA_AttributeDef_out::CORBA_AttributeDef_out (const ::CORBA_AttributeDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (CORBA_AttributeDef_out &, p).ptr_)
{}

::CORBA_AttributeDef_out &
CORBA_AttributeDef_out::operator= (const ::CORBA_AttributeDef_out &p)
{
  this->ptr_ = ACE_const_cast (CORBA_AttributeDef_out&, p).ptr_;
  return *this;
}

CORBA_AttributeDef_out &
CORBA_AttributeDef_out::operator= (const ::CORBA_AttributeDef_var &p)
{
  this->ptr_ = ::CORBA_AttributeDef::_duplicate (p.ptr ());
  return *this;
}

CORBA_AttributeDef_out &
CORBA_AttributeDef_out::operator= (CORBA_AttributeDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA_AttributeDef_out::operator ::CORBA_AttributeDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_AttributeDef_ptr &
CORBA_AttributeDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::CORBA_AttributeDef_ptr
CORBA_AttributeDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_CORBA_AttributeDef_type_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_AttributeDef_type_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::TypeCode_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_AttributeDef_type_get (const TAO_ClientRequestInfo_CORBA_AttributeDef_type_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_AttributeDef_type_get &);

  CORBA::TypeCode_ptr _result;
};

TAO_ClientRequestInfo_CORBA_AttributeDef_type_get::TAO_ClientRequestInfo_CORBA_AttributeDef_type_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_AttributeDef_type_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_AttributeDef_type_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_AttributeDef_type_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_AttributeDef_type_get::result (CORBA::TypeCode_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_IDLType_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_get (const TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_get &);

  CORBA_IDLType_ptr _result;
};

TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_get::TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_get::result (CORBA_IDLType_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA_IDLType_ptr type_def
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_set (const TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_set &);
  void operator= (const TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_set &);

  CORBA_IDLType_ptr type_def_;

};

TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_set::TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA_IDLType_ptr type_def
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    type_def_ (type_def)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->type_def_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

class TAO_ClientRequestInfo_CORBA_AttributeDef_mode_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_AttributeDef_mode_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::AttributeMode result);

private:
  TAO_ClientRequestInfo_CORBA_AttributeDef_mode_get (const TAO_ClientRequestInfo_CORBA_AttributeDef_mode_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_AttributeDef_mode_get &);

  CORBA::AttributeMode _result;
};

TAO_ClientRequestInfo_CORBA_AttributeDef_mode_get::TAO_ClientRequestInfo_CORBA_AttributeDef_mode_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_AttributeDef_mode_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_AttributeDef_mode_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_AttributeDef_mode_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_AttributeDef_mode_get::result (CORBA::AttributeMode result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_AttributeDef_mode_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_AttributeDef_mode_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::AttributeMode & mode
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_CORBA_AttributeDef_mode_set (const TAO_ClientRequestInfo_CORBA_AttributeDef_mode_set &);
  void operator= (const TAO_ClientRequestInfo_CORBA_AttributeDef_mode_set &);

  const CORBA::AttributeMode & mode_;

};

TAO_ClientRequestInfo_CORBA_AttributeDef_mode_set::TAO_ClientRequestInfo_CORBA_AttributeDef_mode_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::AttributeMode & mode
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    mode_ (mode)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_AttributeDef_mode_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->mode_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_AttributeDef_mode_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_AttributeDef_mode_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation.
//

_TAO_CORBA_AttributeDef_Proxy_Impl::_TAO_CORBA_AttributeDef_Proxy_Impl (void)
{}

_TAO_CORBA_AttributeDef_Remote_Proxy_Impl::_TAO_CORBA_AttributeDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::TypeCode_ptr _TAO_CORBA_AttributeDef_Remote_Proxy_Impl::type (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_type",
      9,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_AttributeDef_type_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA::TypeCode_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

CORBA_IDLType_ptr _TAO_CORBA_AttributeDef_Remote_Proxy_Impl::type_def (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_IDLType_ptr _tao_retval = CORBA_IDLType::_nil ();
  CORBA_IDLType_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_type_def",
      13,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA_IDLType_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

void _TAO_CORBA_AttributeDef_Remote_Proxy_Impl::type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA_IDLType_ptr type_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_type_def",
      13,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_set ri (
        &_tao_call,
        _collocated_tao_target_,
        type_def
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << type_def)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }


#if TAO_HAS_INTERCEPTORS == 1

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }

}

CORBA::AttributeMode _TAO_CORBA_AttributeDef_Remote_Proxy_Impl::mode (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::AttributeMode _tao_retval = (CORBA::AttributeMode)0;


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_mode",
      9,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_AttributeDef_mode_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN  (_tao_retval);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                _tao_retval
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA::AttributeMode _tao_retval_info = _tao_retval;
          ri.result (_tao_retval_info);

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN  (_tao_retval);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN  (_tao_retval);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_retval;
}

void _TAO_CORBA_AttributeDef_Remote_Proxy_Impl::mode (
    CORBA_Object *_collocated_tao_target_,
    CORBA::AttributeMode mode
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_mode",
      9,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_AttributeDef_mode_set ri (
        &_tao_call,
        _collocated_tao_target_,
        mode
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << mode)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }


#if TAO_HAS_INTERCEPTORS == 1

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }

}


//
//            End  Base & Remote  Proxy Implemeentation.
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_CORBA_AttributeDef_Proxy_Broker::_TAO_CORBA_AttributeDef_Proxy_Broker (void)
{
}

_TAO_CORBA_AttributeDef_Proxy_Broker::~_TAO_CORBA_AttributeDef_Proxy_Broker (void)
{
}

_TAO_CORBA_AttributeDef_Proxy_Broker * (*_TAO_CORBA_AttributeDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_CORBA_AttributeDef_Remote_Proxy_Broker *
_TAO_CORBA_AttributeDef_Remote_Proxy_Broker::the_TAO_CORBA_AttributeDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_CORBA_AttributeDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_CORBA_AttributeDef_Remote_Proxy_Broker::_TAO_CORBA_AttributeDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_AttributeDef_Remote_Proxy_Broker::~_TAO_CORBA_AttributeDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_AttributeDef_Proxy_Impl&
_TAO_CORBA_AttributeDef_Remote_Proxy_Broker::select_proxy (
  ::CORBA_AttributeDef *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
CORBA_AttributeDef::CORBA_AttributeDef (int collocated)
{
  this->CORBA_AttributeDef_setup_collocation (collocated);
}

// destructor
CORBA_AttributeDef::~CORBA_AttributeDef (void)
{}

void
CORBA_AttributeDef::CORBA_AttributeDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_CORBA_AttributeDef_Proxy_Broker_ =
      ::_TAO_CORBA_AttributeDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_CORBA_AttributeDef_Proxy_Broker_ =
      ::_TAO_CORBA_AttributeDef_Remote_Proxy_Broker::the_TAO_CORBA_AttributeDef_Remote_Proxy_Broker ();

  this->CORBA_Contained_setup_collocation (collocated);
}

void CORBA_AttributeDef::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_AttributeDef *tmp = ACE_static_cast (CORBA_AttributeDef*, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA_AttributeDef_ptr CORBA_AttributeDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_AttributeDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/AttributeDef:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (CORBA_AttributeDef::_nil ());
      if (is_a == 0)
        return CORBA_AttributeDef::_nil ();
    }
  return CORBA_AttributeDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA_AttributeDef_ptr CORBA_AttributeDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_AttributeDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      CORBA_AttributeDef_ptr default_proxy = CORBA_AttributeDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_CORBA_AttributeDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::CORBA_AttributeDef (
            stub,
            1,
            obj->_servant ()),

          CORBA_AttributeDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::CORBA_AttributeDef (stub, 0, obj->_servant ()), CORBA_AttributeDef::_nil ());
        return default_proxy;
      }
    else
      return
        ACE_reinterpret_cast
          (
            CORBA_AttributeDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &CORBA_AttributeDef::_tao_class_id
                    )
                )
          );
}

CORBA_AttributeDef_ptr
CORBA_AttributeDef::_duplicate (CORBA_AttributeDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean CORBA_AttributeDef::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/AttributeDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *CORBA_AttributeDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_AttributeDef::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* CORBA_AttributeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/AttributeDef:1.0";
}

CORBA::TypeCode_ptr CORBA_AttributeDef::type (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_AttributeDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_AttributeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.type (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA_IDLType_ptr CORBA_AttributeDef::type_def (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_AttributeDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_AttributeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.type_def (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

void CORBA_AttributeDef::type_def (
    CORBA_IDLType_ptr type_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_AttributeDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_AttributeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  proxy.type_def (
      this,
      type_def
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA::AttributeMode CORBA_AttributeDef::mode (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_AttributeDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_AttributeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN ((CORBA::AttributeMode)0);

  return proxy.mode (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

void CORBA_AttributeDef::mode (
    CORBA::AttributeMode mode
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_AttributeDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_AttributeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  proxy.mode (
      this,
      mode
      ACE_ENV_ARG_PARAMETER
    );
}

void CORBA_AttributeDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_AttributeDescription *tmp = ACE_static_cast (CORBA_AttributeDescription*, _tao_void_pointer);
  delete tmp;
}


void CORBA_ParameterDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_ParameterDescription *tmp = ACE_static_cast (CORBA_ParameterDescription*, _tao_void_pointer);
  delete tmp;
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_PARDESCRIPTIONSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_PARDESCRIPTIONSEQ_CS_

void
_TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq::_allocate_buffer (CORBA::ULong length)
{
  CORBA_ParameterDescription* tmp = 0;
  tmp = _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq::allocbuf (length);

  if (this->buffer_ != 0)
  {
    CORBA_ParameterDescription *old = ACE_reinterpret_cast (CORBA_ParameterDescription *,this->buffer_);

    for (CORBA::ULong i = 0; i < this->length_; ++i)
      tmp[i] = old[i];

    if (this->release_)
      _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq::freebuf (old);

  }
  this->buffer_ = tmp;
}

void
_TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;

  CORBA_ParameterDescription *tmp = ACE_reinterpret_cast (CORBA_ParameterDescription *,this->buffer_);

  _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq::freebuf (tmp);
  this->buffer_ = 0;
}

_TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq::~_TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq (void) // Dtor.
{
  this->_deallocate_buffer ();
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_PARDESCRIPTIONSEQ_CS_)
#define _CORBA_PARDESCRIPTIONSEQ_CS_

// *************************************************************
// CORBA_ParDescriptionSeq
// *************************************************************

CORBA_ParDescriptionSeq::CORBA_ParDescriptionSeq (void)
{}
CORBA_ParDescriptionSeq::CORBA_ParDescriptionSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA_ParameterDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
CORBA_ParDescriptionSeq::CORBA_ParDescriptionSeq (CORBA::ULong max, CORBA::ULong length, CORBA_ParameterDescription *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA_ParameterDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
CORBA_ParDescriptionSeq::CORBA_ParDescriptionSeq (const CORBA_ParDescriptionSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA_ParameterDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
CORBA_ParDescriptionSeq::~CORBA_ParDescriptionSeq (void) // dtor
{}
void CORBA_ParDescriptionSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_ParDescriptionSeq *tmp = ACE_static_cast (CORBA_ParDescriptionSeq*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

#if !defined (_CORBA_CONTEXTIDSEQ_CS_)
#define _CORBA_CONTEXTIDSEQ_CS_

// *************************************************************
// CORBA_ContextIdSeq
// *************************************************************

CORBA_ContextIdSeq::CORBA_ContextIdSeq (void)
{}
CORBA_ContextIdSeq::CORBA_ContextIdSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
CORBA_ContextIdSeq::CORBA_ContextIdSeq (CORBA::ULong max, CORBA::ULong length, char * *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
CORBA_ContextIdSeq::CORBA_ContextIdSeq (const CORBA_ContextIdSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
CORBA_ContextIdSeq::~CORBA_ContextIdSeq (void) // dtor
{}
void CORBA_ContextIdSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_ContextIdSeq *tmp = ACE_static_cast (CORBA_ContextIdSeq*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

CORBA_OperationDef_ptr
tao_CORBA_OperationDef_duplicate (
    CORBA_OperationDef_ptr p
  )
{
  return CORBA_OperationDef::_duplicate (p);
}

void
tao_CORBA_OperationDef_release (
    CORBA_OperationDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA_OperationDef_ptr
tao_CORBA_OperationDef_nil (
    void
  )
{
  return CORBA_OperationDef::_nil ();
}

CORBA_OperationDef_ptr
tao_CORBA_OperationDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA_OperationDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_OperationDef_upcast (
    void *src
  )
{
  CORBA_OperationDef **tmp =
    ACE_static_cast (CORBA_OperationDef **, src);
  return *tmp;
}

int CORBA_OperationDef::_tao_class_id = 0;

// *************************************************************
// Operations for class CORBA_OperationDef_var
// *************************************************************

CORBA_OperationDef_var::CORBA_OperationDef_var (void) // default constructor
  : ptr_ (CORBA_OperationDef::_nil ())
{}

::CORBA_OperationDef_ptr
CORBA_OperationDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA_OperationDef_var::CORBA_OperationDef_var (const ::CORBA_OperationDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (CORBA_OperationDef::_duplicate (p.ptr ()))
{}

CORBA_OperationDef_var::~CORBA_OperationDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

CORBA_OperationDef_var &
CORBA_OperationDef_var::operator= (CORBA_OperationDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA_OperationDef_var &
CORBA_OperationDef_var::operator= (const ::CORBA_OperationDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA_OperationDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA_OperationDef_var::operator const ::CORBA_OperationDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA_OperationDef_var::operator ::CORBA_OperationDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_OperationDef_ptr
CORBA_OperationDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA_OperationDef_ptr
CORBA_OperationDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA_OperationDef_ptr &
CORBA_OperationDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA_OperationDef_ptr &
CORBA_OperationDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_OperationDef::_nil ();
  return this->ptr_;
}

::CORBA_OperationDef_ptr
CORBA_OperationDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA_OperationDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA_OperationDef::_nil ();
  return val;
}

::CORBA_OperationDef_ptr
CORBA_OperationDef_var::tao_duplicate (CORBA_OperationDef_ptr p)
{
  return ::CORBA_OperationDef::_duplicate (p);
}

void
CORBA_OperationDef_var::tao_release (CORBA_OperationDef_ptr p)
{
  CORBA::release (p);
}

::CORBA_OperationDef_ptr
CORBA_OperationDef_var::tao_nil (void)
{
  return ::CORBA_OperationDef::_nil ();
}

::CORBA_OperationDef_ptr
CORBA_OperationDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA_OperationDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA_OperationDef_var::tao_upcast (void *src)
{
  CORBA_OperationDef **tmp =
    ACE_static_cast (CORBA_OperationDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class CORBA_OperationDef_out
// *************************************************************

CORBA_OperationDef_out::CORBA_OperationDef_out (CORBA_OperationDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA_OperationDef::_nil ();
}

CORBA_OperationDef_out::CORBA_OperationDef_out (CORBA_OperationDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_OperationDef::_nil ();
}

CORBA_OperationDef_out::CORBA_OperationDef_out (const ::CORBA_OperationDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (CORBA_OperationDef_out &, p).ptr_)
{}

::CORBA_OperationDef_out &
CORBA_OperationDef_out::operator= (const ::CORBA_OperationDef_out &p)
{
  this->ptr_ = ACE_const_cast (CORBA_OperationDef_out&, p).ptr_;
  return *this;
}

CORBA_OperationDef_out &
CORBA_OperationDef_out::operator= (const ::CORBA_OperationDef_var &p)
{
  this->ptr_ = ::CORBA_OperationDef::_duplicate (p.ptr ());
  return *this;
}

CORBA_OperationDef_out &
CORBA_OperationDef_out::operator= (CORBA_OperationDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA_OperationDef_out::operator ::CORBA_OperationDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_OperationDef_ptr &
CORBA_OperationDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::CORBA_OperationDef_ptr
CORBA_OperationDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_CORBA_OperationDef_result_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_OperationDef_result_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::TypeCode_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_OperationDef_result_get (const TAO_ClientRequestInfo_CORBA_OperationDef_result_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_OperationDef_result_get &);

  CORBA::TypeCode_ptr _result;
};

TAO_ClientRequestInfo_CORBA_OperationDef_result_get::TAO_ClientRequestInfo_CORBA_OperationDef_result_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_OperationDef_result_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_OperationDef_result_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_OperationDef_result_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_OperationDef_result_get::result (CORBA::TypeCode_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_OperationDef_result_def_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_OperationDef_result_def_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_IDLType_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_OperationDef_result_def_get (const TAO_ClientRequestInfo_CORBA_OperationDef_result_def_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_OperationDef_result_def_get &);

  CORBA_IDLType_ptr _result;
};

TAO_ClientRequestInfo_CORBA_OperationDef_result_def_get::TAO_ClientRequestInfo_CORBA_OperationDef_result_def_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_OperationDef_result_def_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_OperationDef_result_def_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_OperationDef_result_def_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_OperationDef_result_def_get::result (CORBA_IDLType_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_OperationDef_result_def_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_OperationDef_result_def_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA_IDLType_ptr result_def
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_CORBA_OperationDef_result_def_set (const TAO_ClientRequestInfo_CORBA_OperationDef_result_def_set &);
  void operator= (const TAO_ClientRequestInfo_CORBA_OperationDef_result_def_set &);

  CORBA_IDLType_ptr result_def_;

};

TAO_ClientRequestInfo_CORBA_OperationDef_result_def_set::TAO_ClientRequestInfo_CORBA_OperationDef_result_def_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA_IDLType_ptr result_def
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    result_def_ (result_def)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_OperationDef_result_def_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->result_def_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_OperationDef_result_def_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_OperationDef_result_def_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

class TAO_ClientRequestInfo_CORBA_OperationDef_params_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_OperationDef_params_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_ParDescriptionSeq * result);

private:
  TAO_ClientRequestInfo_CORBA_OperationDef_params_get (const TAO_ClientRequestInfo_CORBA_OperationDef_params_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_OperationDef_params_get &);

  CORBA_ParDescriptionSeq * _result;
};

TAO_ClientRequestInfo_CORBA_OperationDef_params_get::TAO_ClientRequestInfo_CORBA_OperationDef_params_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_OperationDef_params_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_OperationDef_params_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_OperationDef_params_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_OperationDef_params_get::result (CORBA_ParDescriptionSeq * result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_OperationDef_params_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_OperationDef_params_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA_ParDescriptionSeq & params
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_CORBA_OperationDef_params_set (const TAO_ClientRequestInfo_CORBA_OperationDef_params_set &);
  void operator= (const TAO_ClientRequestInfo_CORBA_OperationDef_params_set &);

  const CORBA_ParDescriptionSeq & params_;

};

TAO_ClientRequestInfo_CORBA_OperationDef_params_set::TAO_ClientRequestInfo_CORBA_OperationDef_params_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA_ParDescriptionSeq & params
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    params_ (params)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_OperationDef_params_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->params_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_OperationDef_params_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_OperationDef_params_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

class TAO_ClientRequestInfo_CORBA_OperationDef_mode_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_OperationDef_mode_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::OperationMode result);

private:
  TAO_ClientRequestInfo_CORBA_OperationDef_mode_get (const TAO_ClientRequestInfo_CORBA_OperationDef_mode_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_OperationDef_mode_get &);

  CORBA::OperationMode _result;
};

TAO_ClientRequestInfo_CORBA_OperationDef_mode_get::TAO_ClientRequestInfo_CORBA_OperationDef_mode_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_OperationDef_mode_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_OperationDef_mode_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_OperationDef_mode_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_OperationDef_mode_get::result (CORBA::OperationMode result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_OperationDef_mode_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_OperationDef_mode_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::OperationMode & mode
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_CORBA_OperationDef_mode_set (const TAO_ClientRequestInfo_CORBA_OperationDef_mode_set &);
  void operator= (const TAO_ClientRequestInfo_CORBA_OperationDef_mode_set &);

  const CORBA::OperationMode & mode_;

};

TAO_ClientRequestInfo_CORBA_OperationDef_mode_set::TAO_ClientRequestInfo_CORBA_OperationDef_mode_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::OperationMode & mode
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    mode_ (mode)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_OperationDef_mode_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->mode_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_OperationDef_mode_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_OperationDef_mode_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

class TAO_ClientRequestInfo_CORBA_OperationDef_contexts_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_OperationDef_contexts_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_ContextIdSeq * result);

private:
  TAO_ClientRequestInfo_CORBA_OperationDef_contexts_get (const TAO_ClientRequestInfo_CORBA_OperationDef_contexts_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_OperationDef_contexts_get &);

  CORBA_ContextIdSeq * _result;
};

TAO_ClientRequestInfo_CORBA_OperationDef_contexts_get::TAO_ClientRequestInfo_CORBA_OperationDef_contexts_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_OperationDef_contexts_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_OperationDef_contexts_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_OperationDef_contexts_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_OperationDef_contexts_get::result (CORBA_ContextIdSeq * result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_OperationDef_contexts_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_OperationDef_contexts_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA_ContextIdSeq & contexts
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_CORBA_OperationDef_contexts_set (const TAO_ClientRequestInfo_CORBA_OperationDef_contexts_set &);
  void operator= (const TAO_ClientRequestInfo_CORBA_OperationDef_contexts_set &);

  const CORBA_ContextIdSeq & contexts_;

};

TAO_ClientRequestInfo_CORBA_OperationDef_contexts_set::TAO_ClientRequestInfo_CORBA_OperationDef_contexts_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA_ContextIdSeq & contexts
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    contexts_ (contexts)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_OperationDef_contexts_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->contexts_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_OperationDef_contexts_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_OperationDef_contexts_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

class TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_ExceptionDefSeq * result);

private:
  TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_get (const TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_get &);

  CORBA_ExceptionDefSeq * _result;
};

TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_get::TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_get::result (CORBA_ExceptionDefSeq * result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA_ExceptionDefSeq & exceptions
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_set (const TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_set &);
  void operator= (const TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_set &);

  const CORBA_ExceptionDefSeq & exceptions_;

};

TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_set::TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA_ExceptionDefSeq & exceptions
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    exceptions_ (exceptions)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->exceptions_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation.
//

_TAO_CORBA_OperationDef_Proxy_Impl::_TAO_CORBA_OperationDef_Proxy_Impl (void)
{}

_TAO_CORBA_OperationDef_Remote_Proxy_Impl::_TAO_CORBA_OperationDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::TypeCode_ptr _TAO_CORBA_OperationDef_Remote_Proxy_Impl::result (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_result",
      11,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_OperationDef_result_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA::TypeCode_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

CORBA_IDLType_ptr _TAO_CORBA_OperationDef_Remote_Proxy_Impl::result_def (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_IDLType_ptr _tao_retval = CORBA_IDLType::_nil ();
  CORBA_IDLType_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_result_def",
      15,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_OperationDef_result_def_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA_IDLType_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

void _TAO_CORBA_OperationDef_Remote_Proxy_Impl::result_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA_IDLType_ptr result_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_result_def",
      15,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_OperationDef_result_def_set ri (
        &_tao_call,
        _collocated_tao_target_,
        result_def
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << result_def)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }


#if TAO_HAS_INTERCEPTORS == 1

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }

}

CORBA_ParDescriptionSeq * _TAO_CORBA_OperationDef_Remote_Proxy_Impl::params (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_ParDescriptionSeq *_tao_retval = 0;


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  ACE_NEW_RETURN (_tao_retval, CORBA_ParDescriptionSeq, _tao_retval);
  CORBA_ParDescriptionSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_params",
      11,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_OperationDef_params_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA_ParDescriptionSeq * _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

void _TAO_CORBA_OperationDef_Remote_Proxy_Impl::params (
    CORBA_Object *_collocated_tao_target_,
    const CORBA_ParDescriptionSeq & params
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_params",
      11,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_OperationDef_params_set ri (
        &_tao_call,
        _collocated_tao_target_,
        params
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << params)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }


#if TAO_HAS_INTERCEPTORS == 1

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }

}

CORBA::OperationMode _TAO_CORBA_OperationDef_Remote_Proxy_Impl::mode (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::OperationMode _tao_retval = (CORBA::OperationMode)0;


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_mode",
      9,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_OperationDef_mode_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN  (_tao_retval);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                _tao_retval
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA::OperationMode _tao_retval_info = _tao_retval;
          ri.result (_tao_retval_info);

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN  (_tao_retval);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN  (_tao_retval);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_retval;
}

void _TAO_CORBA_OperationDef_Remote_Proxy_Impl::mode (
    CORBA_Object *_collocated_tao_target_,
    CORBA::OperationMode mode
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_mode",
      9,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_OperationDef_mode_set ri (
        &_tao_call,
        _collocated_tao_target_,
        mode
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << mode)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }


#if TAO_HAS_INTERCEPTORS == 1

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }

}

CORBA_ContextIdSeq * _TAO_CORBA_OperationDef_Remote_Proxy_Impl::contexts (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_ContextIdSeq *_tao_retval = 0;


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  ACE_NEW_RETURN (_tao_retval, CORBA_ContextIdSeq, _tao_retval);
  CORBA_ContextIdSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_contexts",
      13,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_OperationDef_contexts_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA_ContextIdSeq * _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

void _TAO_CORBA_OperationDef_Remote_Proxy_Impl::contexts (
    CORBA_Object *_collocated_tao_target_,
    const CORBA_ContextIdSeq & contexts
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_contexts",
      13,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_OperationDef_contexts_set ri (
        &_tao_call,
        _collocated_tao_target_,
        contexts
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << contexts)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }


#if TAO_HAS_INTERCEPTORS == 1

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }

}

CORBA_ExceptionDefSeq * _TAO_CORBA_OperationDef_Remote_Proxy_Impl::exceptions (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_ExceptionDefSeq *_tao_retval = 0;


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  ACE_NEW_RETURN (_tao_retval, CORBA_ExceptionDefSeq, _tao_retval);
  CORBA_ExceptionDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_exceptions",
      15,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA_ExceptionDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

void _TAO_CORBA_OperationDef_Remote_Proxy_Impl::exceptions (
    CORBA_Object *_collocated_tao_target_,
    const CORBA_ExceptionDefSeq & exceptions
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_exceptions",
      15,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_set ri (
        &_tao_call,
        _collocated_tao_target_,
        exceptions
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << exceptions)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }


#if TAO_HAS_INTERCEPTORS == 1

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }

}


//
//            End  Base & Remote  Proxy Implemeentation.
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_CORBA_OperationDef_Proxy_Broker::_TAO_CORBA_OperationDef_Proxy_Broker (void)
{
}

_TAO_CORBA_OperationDef_Proxy_Broker::~_TAO_CORBA_OperationDef_Proxy_Broker (void)
{
}

_TAO_CORBA_OperationDef_Proxy_Broker * (*_TAO_CORBA_OperationDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_CORBA_OperationDef_Remote_Proxy_Broker *
_TAO_CORBA_OperationDef_Remote_Proxy_Broker::the_TAO_CORBA_OperationDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_CORBA_OperationDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_CORBA_OperationDef_Remote_Proxy_Broker::_TAO_CORBA_OperationDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_OperationDef_Remote_Proxy_Broker::~_TAO_CORBA_OperationDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_OperationDef_Proxy_Impl&
_TAO_CORBA_OperationDef_Remote_Proxy_Broker::select_proxy (
  ::CORBA_OperationDef *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
CORBA_OperationDef::CORBA_OperationDef (int collocated)
{
  this->CORBA_OperationDef_setup_collocation (collocated);
}

// destructor
CORBA_OperationDef::~CORBA_OperationDef (void)
{}

void
CORBA_OperationDef::CORBA_OperationDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_CORBA_OperationDef_Proxy_Broker_ =
      ::_TAO_CORBA_OperationDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_CORBA_OperationDef_Proxy_Broker_ =
      ::_TAO_CORBA_OperationDef_Remote_Proxy_Broker::the_TAO_CORBA_OperationDef_Remote_Proxy_Broker ();

  this->CORBA_Contained_setup_collocation (collocated);
}

void CORBA_OperationDef::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_OperationDef *tmp = ACE_static_cast (CORBA_OperationDef*, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA_OperationDef_ptr CORBA_OperationDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_OperationDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/OperationDef:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (CORBA_OperationDef::_nil ());
      if (is_a == 0)
        return CORBA_OperationDef::_nil ();
    }
  return CORBA_OperationDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA_OperationDef_ptr CORBA_OperationDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_OperationDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      CORBA_OperationDef_ptr default_proxy = CORBA_OperationDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_CORBA_OperationDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::CORBA_OperationDef (
            stub,
            1,
            obj->_servant ()),

          CORBA_OperationDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::CORBA_OperationDef (stub, 0, obj->_servant ()), CORBA_OperationDef::_nil ());
        return default_proxy;
      }
    else
      return
        ACE_reinterpret_cast
          (
            CORBA_OperationDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &CORBA_OperationDef::_tao_class_id
                    )
                )
          );
}

CORBA_OperationDef_ptr
CORBA_OperationDef::_duplicate (CORBA_OperationDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean CORBA_OperationDef::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/OperationDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *CORBA_OperationDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_OperationDef::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* CORBA_OperationDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/OperationDef:1.0";
}

CORBA::TypeCode_ptr CORBA_OperationDef::result (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_OperationDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_OperationDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.result (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA_IDLType_ptr CORBA_OperationDef::result_def (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_OperationDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_OperationDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.result_def (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

void CORBA_OperationDef::result_def (
    CORBA_IDLType_ptr result_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_OperationDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_OperationDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  proxy.result_def (
      this,
      result_def
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA_ParDescriptionSeq * CORBA_OperationDef::params (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_OperationDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_OperationDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.params (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

void CORBA_OperationDef::params (
    const CORBA_ParDescriptionSeq & params
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_OperationDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_OperationDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  proxy.params (
      this,
      params
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA::OperationMode CORBA_OperationDef::mode (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_OperationDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_OperationDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN ((CORBA::OperationMode)0);

  return proxy.mode (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

void CORBA_OperationDef::mode (
    CORBA::OperationMode mode
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_OperationDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_OperationDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  proxy.mode (
      this,
      mode
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA_ContextIdSeq * CORBA_OperationDef::contexts (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_OperationDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_OperationDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.contexts (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

void CORBA_OperationDef::contexts (
    const CORBA_ContextIdSeq & contexts
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_OperationDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_OperationDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  proxy.contexts (
      this,
      contexts
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA_ExceptionDefSeq * CORBA_OperationDef::exceptions (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_OperationDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_OperationDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.exceptions (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

void CORBA_OperationDef::exceptions (
    const CORBA_ExceptionDefSeq & exceptions
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_OperationDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_OperationDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  proxy.exceptions (
      this,
      exceptions
      ACE_ENV_ARG_PARAMETER
    );
}


void CORBA_OperationDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_OperationDescription *tmp = ACE_static_cast (CORBA_OperationDescription*, _tao_void_pointer);
  delete tmp;
}


#if !defined (_CORBA_REPOSITORYIDSEQ_CS_)
#define _CORBA_REPOSITORYIDSEQ_CS_

// *************************************************************
// CORBA_RepositoryIdSeq
// *************************************************************

CORBA_RepositoryIdSeq::CORBA_RepositoryIdSeq (void)
{}
CORBA_RepositoryIdSeq::CORBA_RepositoryIdSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
CORBA_RepositoryIdSeq::CORBA_RepositoryIdSeq (CORBA::ULong max, CORBA::ULong length, char * *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
CORBA_RepositoryIdSeq::CORBA_RepositoryIdSeq (const CORBA_RepositoryIdSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
CORBA_RepositoryIdSeq::~CORBA_RepositoryIdSeq (void) // dtor
{}
void CORBA_RepositoryIdSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_RepositoryIdSeq *tmp = ACE_static_cast (CORBA_RepositoryIdSeq*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_OPDESCRIPTIONSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_OPDESCRIPTIONSEQ_CS_

void
_TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq::_allocate_buffer (CORBA::ULong length)
{
  CORBA_OperationDescription* tmp = 0;
  tmp = _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq::allocbuf (length);

  if (this->buffer_ != 0)
  {
    CORBA_OperationDescription *old = ACE_reinterpret_cast (CORBA_OperationDescription *,this->buffer_);

    for (CORBA::ULong i = 0; i < this->length_; ++i)
      tmp[i] = old[i];

    if (this->release_)
      _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq::freebuf (old);

  }
  this->buffer_ = tmp;
}

void
_TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;

  CORBA_OperationDescription *tmp = ACE_reinterpret_cast (CORBA_OperationDescription *,this->buffer_);

  _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq::freebuf (tmp);
  this->buffer_ = 0;
}

_TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq::~_TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq (void) // Dtor.
{
  this->_deallocate_buffer ();
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_OPDESCRIPTIONSEQ_CS_)
#define _CORBA_OPDESCRIPTIONSEQ_CS_

// *************************************************************
// CORBA_OpDescriptionSeq
// *************************************************************

CORBA_OpDescriptionSeq::CORBA_OpDescriptionSeq (void)
{}
CORBA_OpDescriptionSeq::CORBA_OpDescriptionSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA_OperationDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
CORBA_OpDescriptionSeq::CORBA_OpDescriptionSeq (CORBA::ULong max, CORBA::ULong length, CORBA_OperationDescription *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA_OperationDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
CORBA_OpDescriptionSeq::CORBA_OpDescriptionSeq (const CORBA_OpDescriptionSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA_OperationDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
CORBA_OpDescriptionSeq::~CORBA_OpDescriptionSeq (void) // dtor
{}
void CORBA_OpDescriptionSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_OpDescriptionSeq *tmp = ACE_static_cast (CORBA_OpDescriptionSeq*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_ATTRDESCRIPTIONSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_ATTRDESCRIPTIONSEQ_CS_

void
_TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq::_allocate_buffer (CORBA::ULong length)
{
  CORBA_AttributeDescription* tmp = 0;
  tmp = _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq::allocbuf (length);

  if (this->buffer_ != 0)
  {
    CORBA_AttributeDescription *old = ACE_reinterpret_cast (CORBA_AttributeDescription *,this->buffer_);

    for (CORBA::ULong i = 0; i < this->length_; ++i)
      tmp[i] = old[i];

    if (this->release_)
      _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq::freebuf (old);

  }
  this->buffer_ = tmp;
}

void
_TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;

  CORBA_AttributeDescription *tmp = ACE_reinterpret_cast (CORBA_AttributeDescription *,this->buffer_);

  _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq::freebuf (tmp);
  this->buffer_ = 0;
}

_TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq::~_TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq (void) // Dtor.
{
  this->_deallocate_buffer ();
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_ATTRDESCRIPTIONSEQ_CS_)
#define _CORBA_ATTRDESCRIPTIONSEQ_CS_

// *************************************************************
// CORBA_AttrDescriptionSeq
// *************************************************************

CORBA_AttrDescriptionSeq::CORBA_AttrDescriptionSeq (void)
{}
CORBA_AttrDescriptionSeq::CORBA_AttrDescriptionSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA_AttributeDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
CORBA_AttrDescriptionSeq::CORBA_AttrDescriptionSeq (CORBA::ULong max, CORBA::ULong length, CORBA_AttributeDescription *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA_AttributeDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
CORBA_AttrDescriptionSeq::CORBA_AttrDescriptionSeq (const CORBA_AttrDescriptionSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA_AttributeDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
CORBA_AttrDescriptionSeq::~CORBA_AttrDescriptionSeq (void) // dtor
{}
void CORBA_AttrDescriptionSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_AttrDescriptionSeq *tmp = ACE_static_cast (CORBA_AttrDescriptionSeq*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */


CORBA_InterfaceDef_ptr
tao_CORBA_InterfaceDef_duplicate (
    CORBA_InterfaceDef_ptr p
  )
{
  return CORBA_InterfaceDef::_duplicate (p);
}

void
tao_CORBA_InterfaceDef_release (
    CORBA_InterfaceDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA_InterfaceDef_ptr
tao_CORBA_InterfaceDef_nil (
    void
  )
{
  return CORBA_InterfaceDef::_nil ();
}

CORBA_InterfaceDef_ptr
tao_CORBA_InterfaceDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA_InterfaceDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_InterfaceDef_upcast (
    void *src
  )
{
  CORBA_InterfaceDef **tmp =
    ACE_static_cast (CORBA_InterfaceDef **, src);
  return *tmp;
}

int CORBA_InterfaceDef::_tao_class_id = 0;

// *************************************************************
// Operations for class CORBA_InterfaceDef_var
// *************************************************************

CORBA_InterfaceDef_var::CORBA_InterfaceDef_var (void) // default constructor
  : ptr_ (CORBA_InterfaceDef::_nil ())
{}

::CORBA_InterfaceDef_ptr
CORBA_InterfaceDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA_InterfaceDef_var::CORBA_InterfaceDef_var (const ::CORBA_InterfaceDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (CORBA_InterfaceDef::_duplicate (p.ptr ()))
{}

CORBA_InterfaceDef_var::~CORBA_InterfaceDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

CORBA_InterfaceDef_var &
CORBA_InterfaceDef_var::operator= (CORBA_InterfaceDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA_InterfaceDef_var &
CORBA_InterfaceDef_var::operator= (const ::CORBA_InterfaceDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA_InterfaceDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA_InterfaceDef_var::operator const ::CORBA_InterfaceDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA_InterfaceDef_var::operator ::CORBA_InterfaceDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_InterfaceDef_ptr
CORBA_InterfaceDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA_InterfaceDef_ptr
CORBA_InterfaceDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA_InterfaceDef_ptr &
CORBA_InterfaceDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA_InterfaceDef_ptr &
CORBA_InterfaceDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_InterfaceDef::_nil ();
  return this->ptr_;
}

::CORBA_InterfaceDef_ptr
CORBA_InterfaceDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA_InterfaceDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA_InterfaceDef::_nil ();
  return val;
}

::CORBA_InterfaceDef_ptr
CORBA_InterfaceDef_var::tao_duplicate (CORBA_InterfaceDef_ptr p)
{
  return ::CORBA_InterfaceDef::_duplicate (p);
}

void
CORBA_InterfaceDef_var::tao_release (CORBA_InterfaceDef_ptr p)
{
  CORBA::release (p);
}

::CORBA_InterfaceDef_ptr
CORBA_InterfaceDef_var::tao_nil (void)
{
  return ::CORBA_InterfaceDef::_nil ();
}

::CORBA_InterfaceDef_ptr
CORBA_InterfaceDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA_InterfaceDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA_InterfaceDef_var::tao_upcast (void *src)
{
  CORBA_InterfaceDef **tmp =
    ACE_static_cast (CORBA_InterfaceDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class CORBA_InterfaceDef_out
// *************************************************************

CORBA_InterfaceDef_out::CORBA_InterfaceDef_out (CORBA_InterfaceDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA_InterfaceDef::_nil ();
}

CORBA_InterfaceDef_out::CORBA_InterfaceDef_out (CORBA_InterfaceDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_InterfaceDef::_nil ();
}

CORBA_InterfaceDef_out::CORBA_InterfaceDef_out (const ::CORBA_InterfaceDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (CORBA_InterfaceDef_out &, p).ptr_)
{}

::CORBA_InterfaceDef_out &
CORBA_InterfaceDef_out::operator= (const ::CORBA_InterfaceDef_out &p)
{
  this->ptr_ = ACE_const_cast (CORBA_InterfaceDef_out&, p).ptr_;
  return *this;
}

CORBA_InterfaceDef_out &
CORBA_InterfaceDef_out::operator= (const ::CORBA_InterfaceDef_var &p)
{
  this->ptr_ = ::CORBA_InterfaceDef::_duplicate (p.ptr ());
  return *this;
}

CORBA_InterfaceDef_out &
CORBA_InterfaceDef_out::operator= (CORBA_InterfaceDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA_InterfaceDef_out::operator ::CORBA_InterfaceDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_InterfaceDef_ptr &
CORBA_InterfaceDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::CORBA_InterfaceDef_ptr
CORBA_InterfaceDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_InterfaceDefSeq * result);

private:
  TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_get (const TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_get &);

  CORBA_InterfaceDefSeq * _result;
};

TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_get::TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_get::result (CORBA_InterfaceDefSeq * result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA_InterfaceDefSeq & base_interfaces
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_set (const TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_set &);
  void operator= (const TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_set &);

  const CORBA_InterfaceDefSeq & base_interfaces_;

};

TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_set::TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA_InterfaceDefSeq & base_interfaces
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    base_interfaces_ (base_interfaces)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->base_interfaces_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

class TAO_ClientRequestInfo_CORBA_InterfaceDef_is_a : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_InterfaceDef_is_a (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * interface_id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Boolean result);

private:
  TAO_ClientRequestInfo_CORBA_InterfaceDef_is_a (const TAO_ClientRequestInfo_CORBA_InterfaceDef_is_a &);
  void operator= (const TAO_ClientRequestInfo_CORBA_InterfaceDef_is_a &);

  const char * interface_id_;
  CORBA::Boolean _result;
};

TAO_ClientRequestInfo_CORBA_InterfaceDef_is_a::TAO_ClientRequestInfo_CORBA_InterfaceDef_is_a (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * interface_id
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    interface_id_ (interface_id)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_InterfaceDef_is_a::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= interface_id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_InterfaceDef_is_a::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_InterfaceDef_is_a::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_InterfaceDef_is_a::result (CORBA::Boolean result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_InterfaceDef_describe_interface : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_InterfaceDef_describe_interface (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_InterfaceDef::FullInterfaceDescription * result);

private:
  TAO_ClientRequestInfo_CORBA_InterfaceDef_describe_interface (const TAO_ClientRequestInfo_CORBA_InterfaceDef_describe_interface &);
  void operator= (const TAO_ClientRequestInfo_CORBA_InterfaceDef_describe_interface &);

  CORBA_InterfaceDef::FullInterfaceDescription * _result;
};

TAO_ClientRequestInfo_CORBA_InterfaceDef_describe_interface::TAO_ClientRequestInfo_CORBA_InterfaceDef_describe_interface (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_InterfaceDef_describe_interface::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_InterfaceDef_describe_interface::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_InterfaceDef_describe_interface::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_InterfaceDef_describe_interface::result (CORBA_InterfaceDef::FullInterfaceDescription * result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_InterfaceDef_create_attribute : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_InterfaceDef_create_attribute (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA_IDLType_ptr type,
      CORBA::AttributeMode & mode
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_AttributeDef_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_InterfaceDef_create_attribute (const TAO_ClientRequestInfo_CORBA_InterfaceDef_create_attribute &);
  void operator= (const TAO_ClientRequestInfo_CORBA_InterfaceDef_create_attribute &);

  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_IDLType_ptr type_;
  const CORBA::AttributeMode & mode_;
  CORBA_AttributeDef_ptr _result;
};

TAO_ClientRequestInfo_CORBA_InterfaceDef_create_attribute::TAO_ClientRequestInfo_CORBA_InterfaceDef_create_attribute (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr type,
    CORBA::AttributeMode & mode
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    type_ (type),
    mode_ (mode)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_InterfaceDef_create_attribute::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (5);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->mode_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_InterfaceDef_create_attribute::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_InterfaceDef_create_attribute::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_InterfaceDef_create_attribute::result (CORBA_AttributeDef_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_InterfaceDef_create_operation : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_InterfaceDef_create_operation (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA_IDLType_ptr result,
      CORBA::OperationMode & mode,
      const CORBA_ParDescriptionSeq & params,
      const CORBA_ExceptionDefSeq & exceptions,
      const CORBA_ContextIdSeq & contexts
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_OperationDef_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_InterfaceDef_create_operation (const TAO_ClientRequestInfo_CORBA_InterfaceDef_create_operation &);
  void operator= (const TAO_ClientRequestInfo_CORBA_InterfaceDef_create_operation &);

  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_IDLType_ptr result_;
  const CORBA::OperationMode & mode_;
  const CORBA_ParDescriptionSeq & params_;
  const CORBA_ExceptionDefSeq & exceptions_;
  const CORBA_ContextIdSeq & contexts_;
  CORBA_OperationDef_ptr _result;
};

TAO_ClientRequestInfo_CORBA_InterfaceDef_create_operation::TAO_ClientRequestInfo_CORBA_InterfaceDef_create_operation (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr result,
    CORBA::OperationMode & mode,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions,
    const CORBA_ContextIdSeq & contexts
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    result_ (result),
    mode_ (mode),
    params_ (params),
    exceptions_ (exceptions),
    contexts_ (contexts)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_InterfaceDef_create_operation::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (8);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->result_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->mode_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->params_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->exceptions_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->contexts_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_InterfaceDef_create_operation::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_CORBA_InterfaceDef_create_operation::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_CORBA_InterfaceDef_create_operation::result (CORBA_OperationDef_ptr result)
{
  // update the result
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation.
//

_TAO_CORBA_InterfaceDef_Proxy_Impl::_TAO_CORBA_InterfaceDef_Proxy_Impl (void)
{}

_TAO_CORBA_InterfaceDef_Remote_Proxy_Impl::_TAO_CORBA_InterfaceDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA_InterfaceDefSeq * _TAO_CORBA_InterfaceDef_Remote_Proxy_Impl::base_interfaces (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_InterfaceDefSeq *_tao_retval = 0;


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  ACE_NEW_RETURN (_tao_retval, CORBA_InterfaceDefSeq, _tao_retval);
  CORBA_InterfaceDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_base_interfaces",
      20,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA_InterfaceDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

void _TAO_CORBA_InterfaceDef_Remote_Proxy_Impl::base_interfaces (
    CORBA_Object *_collocated_tao_target_,
    const CORBA_InterfaceDefSeq & base_interfaces
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_base_interfaces",
      20,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_set ri (
        &_tao_call,
        _collocated_tao_target_,
        base_interfaces
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << base_interfaces)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }


#if TAO_HAS_INTERCEPTORS == 1

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }

}

CORBA::Boolean _TAO_CORBA_InterfaceDef_Remote_Proxy_Impl::is_a (
    CORBA_Object *_collocated_tao_target_,
    const char * interface_id
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::Boolean _tao_retval = 0;


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "is_a",
      4,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_InterfaceDef_is_a ri (
        &_tao_call,
        _collocated_tao_target_,
        interface_id
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN  (_tao_retval);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << interface_id)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              _tao_retval
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                _tao_retval
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA::Boolean _tao_retval_info = _tao_retval;
          ri.result (_tao_retval_info);

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN  (_tao_retval);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN  (_tao_retval);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_retval;
}

CORBA_InterfaceDef::FullInterfaceDescription * _TAO_CORBA_InterfaceDef_Remote_Proxy_Impl::describe_interface (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_InterfaceDef::FullInterfaceDescription *_tao_retval = 0;

  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  ACE_NEW_RETURN (_tao_retval, CORBA_InterfaceDef::FullInterfaceDescription, _tao_retval);
  CORBA_InterfaceDef::FullInterfaceDescription_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "describe_interface",
      18,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_InterfaceDef_describe_interface ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA_InterfaceDef::FullInterfaceDescription * _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

CORBA_AttributeDef_ptr _TAO_CORBA_InterfaceDef_Remote_Proxy_Impl::create_attribute (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr type,
    CORBA::AttributeMode mode
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_AttributeDef_ptr _tao_retval = CORBA_AttributeDef::_nil ();
  CORBA_AttributeDef_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_attribute",
      16,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_InterfaceDef_create_attribute ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        type,
        mode
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << type) &&
              (_tao_out << mode)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA_AttributeDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

CORBA_OperationDef_ptr _TAO_CORBA_InterfaceDef_Remote_Proxy_Impl::create_operation (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr result,
    CORBA::OperationMode mode,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions,
    const CORBA_ContextIdSeq & contexts
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_OperationDef_ptr _tao_retval = CORBA_OperationDef::_nil ();
  CORBA_OperationDef_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_operation",
      16,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_InterfaceDef_create_operation ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        result,
        mode,
        params,
        exceptions,
        contexts
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << result) &&
              (_tao_out << mode) &&
              (_tao_out << params) &&
              (_tao_out << exceptions) &&
              (_tao_out << contexts)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA_OperationDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation.
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_CORBA_InterfaceDef_Proxy_Broker::_TAO_CORBA_InterfaceDef_Proxy_Broker (void)
{
}

_TAO_CORBA_InterfaceDef_Proxy_Broker::~_TAO_CORBA_InterfaceDef_Proxy_Broker (void)
{
}

_TAO_CORBA_InterfaceDef_Proxy_Broker * (*_TAO_CORBA_InterfaceDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_CORBA_InterfaceDef_Remote_Proxy_Broker *
_TAO_CORBA_InterfaceDef_Remote_Proxy_Broker::the_TAO_CORBA_InterfaceDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_CORBA_InterfaceDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_CORBA_InterfaceDef_Remote_Proxy_Broker::_TAO_CORBA_InterfaceDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_InterfaceDef_Remote_Proxy_Broker::~_TAO_CORBA_InterfaceDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_InterfaceDef_Proxy_Impl&
_TAO_CORBA_InterfaceDef_Remote_Proxy_Broker::select_proxy (
  ::CORBA_InterfaceDef *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
CORBA_InterfaceDef::CORBA_InterfaceDef (int collocated)
{
  this->CORBA_InterfaceDef_setup_collocation (collocated);
}

// destructor
CORBA_InterfaceDef::~CORBA_InterfaceDef (void)
{}

void
CORBA_InterfaceDef::CORBA_InterfaceDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_CORBA_InterfaceDef_Proxy_Broker_ =
      ::_TAO_CORBA_InterfaceDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_CORBA_InterfaceDef_Proxy_Broker_ =
      ::_TAO_CORBA_InterfaceDef_Remote_Proxy_Broker::the_TAO_CORBA_InterfaceDef_Remote_Proxy_Broker ();

  this->CORBA_Container_setup_collocation (collocated);

  this->CORBA_Contained_setup_collocation (collocated);

  this->CORBA_IDLType_setup_collocation (collocated);
}

void CORBA_InterfaceDef::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_InterfaceDef *tmp = ACE_static_cast (CORBA_InterfaceDef*, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA_InterfaceDef_ptr CORBA_InterfaceDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_InterfaceDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/InterfaceDef:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (CORBA_InterfaceDef::_nil ());
      if (is_a == 0)
        return CORBA_InterfaceDef::_nil ();
    }
  return CORBA_InterfaceDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA_InterfaceDef_ptr CORBA_InterfaceDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_InterfaceDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      CORBA_InterfaceDef_ptr default_proxy = CORBA_InterfaceDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_CORBA_InterfaceDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::CORBA_InterfaceDef (
            stub,
            1,
            obj->_servant ()),

          CORBA_InterfaceDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::CORBA_InterfaceDef (stub, 0, obj->_servant ()), CORBA_InterfaceDef::_nil ());
        return default_proxy;
      }
    else
      return
        ACE_reinterpret_cast
          (
            CORBA_InterfaceDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &CORBA_InterfaceDef::_tao_class_id
                    )
                )
          );
}

CORBA_InterfaceDef_ptr
CORBA_InterfaceDef::_duplicate (CORBA_InterfaceDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean CORBA_InterfaceDef::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *CORBA_InterfaceDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_InterfaceDef::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Container::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Container_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IDLType::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* CORBA_InterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/InterfaceDef:1.0";
}

CORBA_InterfaceDefSeq * CORBA_InterfaceDef::base_interfaces (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_InterfaceDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_InterfaceDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.base_interfaces (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

void CORBA_InterfaceDef::base_interfaces (
    const CORBA_InterfaceDefSeq & base_interfaces
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_InterfaceDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_InterfaceDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  proxy.base_interfaces (
      this,
      base_interfaces
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA::Boolean CORBA_InterfaceDef::is_a (
    const char * interface_id
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_InterfaceDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_InterfaceDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.is_a (
      this,
      interface_id
      ACE_ENV_ARG_PARAMETER
    );
}

static const CORBA::Long _oc_CORBA_InterfaceDef_FullInterfaceDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  60,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x434f5242),
  ACE_NTOHL (0x412f496e),
  ACE_NTOHL (0x74657266),
  ACE_NTOHL (0x61636544),
  ACE_NTOHL (0x65662f46),
  ACE_NTOHL (0x756c6c49),
  ACE_NTOHL (0x6e746572),
  ACE_NTOHL (0x66616365),
  ACE_NTOHL (0x44657363),
  ACE_NTOHL (0x72697074),
  ACE_NTOHL (0x696f6e3a),
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/InterfaceDef/FullInterfaceDescription:1.0
  25,
  ACE_NTOHL (0x46756c6c),
  ACE_NTOHL (0x496e7465),
  ACE_NTOHL (0x72666163),
  ACE_NTOHL (0x65446573),
  ACE_NTOHL (0x63726970),
  ACE_NTOHL (0x74696f6e),
  ACE_NTOHL (0x0),  // name = FullInterfaceDescription
  8, // member count
  5,
  ACE_NTOHL (0x6e616d65),
  ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x434f5242),
    ACE_NTOHL (0x412f4964),
    ACE_NTOHL (0x656e7469),
    ACE_NTOHL (0x66696572),
    ACE_NTOHL (0x3a312e30),
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11,
    ACE_NTOHL (0x4964656e),
    ACE_NTOHL (0x74696669),
    ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string,
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x434f5242),
    ACE_NTOHL (0x412f5265),
    ACE_NTOHL (0x706f7369),
    ACE_NTOHL (0x746f7279),
    ACE_NTOHL (0x49643a31),
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f),
    ACE_NTOHL (0x7369746f),
    ACE_NTOHL (0x72794964),
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  11,
  ACE_NTOHL (0x64656669),
  ACE_NTOHL (0x6e65645f),
  ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x434f5242),
    ACE_NTOHL (0x412f5265),
    ACE_NTOHL (0x706f7369),
    ACE_NTOHL (0x746f7279),
    ACE_NTOHL (0x49643a31),
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f),
    ACE_NTOHL (0x7369746f),
    ACE_NTOHL (0x72794964),
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  8,
  ACE_NTOHL (0x76657273),
  ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x434f5242),
    ACE_NTOHL (0x412f5665),
    ACE_NTOHL (0x7273696f),
    ACE_NTOHL (0x6e537065),
    ACE_NTOHL (0x633a312e),
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
    12,
    ACE_NTOHL (0x56657273),
    ACE_NTOHL (0x696f6e53),
    ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string,
    0U, // string length

  11,
  ACE_NTOHL (0x6f706572),
  ACE_NTOHL (0x6174696f),
  ACE_NTOHL (0x6e730000),  // name = operations
  CORBA::tk_alias, // typecode kind for typedefs
  2036, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    39,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x434f5242),
    ACE_NTOHL (0x412f4f70),
    ACE_NTOHL (0x44657363),
    ACE_NTOHL (0x72697074),
    ACE_NTOHL (0x696f6e53),
    ACE_NTOHL (0x65713a31),
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OpDescriptionSeq:1.0
    17,
    ACE_NTOHL (0x4f704465),
    ACE_NTOHL (0x73637269),
    ACE_NTOHL (0x7074696f),
    ACE_NTOHL (0x6e536571),
    ACE_NTOHL (0x0),  // name = OpDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    1956, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      1940, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43,
        ACE_NTOHL (0x49444c3a),
        ACE_NTOHL (0x6f6d672e),
        ACE_NTOHL (0x6f72672f),
        ACE_NTOHL (0x434f5242),
        ACE_NTOHL (0x412f4f70),
        ACE_NTOHL (0x65726174),
        ACE_NTOHL (0x696f6e44),
        ACE_NTOHL (0x65736372),
        ACE_NTOHL (0x69707469),
        ACE_NTOHL (0x6f6e3a31),
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OperationDescription:1.0
        21,
        ACE_NTOHL (0x4f706572),
        ACE_NTOHL (0x6174696f),
        ACE_NTOHL (0x6e446573),
        ACE_NTOHL (0x63726970),
        ACE_NTOHL (0x74696f6e),
        ACE_NTOHL (0x0),  // name = OperationDescription
        9, // member count
        5,
        ACE_NTOHL (0x6e616d65),
        ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33,
          ACE_NTOHL (0x49444c3a),
          ACE_NTOHL (0x6f6d672e),
          ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f4964),
          ACE_NTOHL (0x656e7469),
          ACE_NTOHL (0x66696572),
          ACE_NTOHL (0x3a312e30),
          ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11,
          ACE_NTOHL (0x4964656e),
          ACE_NTOHL (0x74696669),
          ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string,
          0U, // string length

        3,
        ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35,
          ACE_NTOHL (0x49444c3a),
          ACE_NTOHL (0x6f6d672e),
          ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f5265),
          ACE_NTOHL (0x706f7369),
          ACE_NTOHL (0x746f7279),
          ACE_NTOHL (0x49643a31),
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13,
          ACE_NTOHL (0x5265706f),
          ACE_NTOHL (0x7369746f),
          ACE_NTOHL (0x72794964),
          ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string,
          0U, // string length

        11,
        ACE_NTOHL (0x64656669),
        ACE_NTOHL (0x6e65645f),
        ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35,
          ACE_NTOHL (0x49444c3a),
          ACE_NTOHL (0x6f6d672e),
          ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f5265),
          ACE_NTOHL (0x706f7369),
          ACE_NTOHL (0x746f7279),
          ACE_NTOHL (0x49643a31),
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13,
          ACE_NTOHL (0x5265706f),
          ACE_NTOHL (0x7369746f),
          ACE_NTOHL (0x72794964),
          ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string,
          0U, // string length

        8,
        ACE_NTOHL (0x76657273),
        ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          34,
          ACE_NTOHL (0x49444c3a),
          ACE_NTOHL (0x6f6d672e),
          ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f5665),
          ACE_NTOHL (0x7273696f),
          ACE_NTOHL (0x6e537065),
          ACE_NTOHL (0x633a312e),
          ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
          12,
          ACE_NTOHL (0x56657273),
          ACE_NTOHL (0x696f6e53),
          ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string,
          0U, // string length

        7,
        ACE_NTOHL (0x72657375),
        ACE_NTOHL (0x6c740000),  // name = result
        CORBA::tk_TypeCode,

        5,
        ACE_NTOHL (0x6d6f6465),
        ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        100, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          36,
          ACE_NTOHL (0x49444c3a),
          ACE_NTOHL (0x6f6d672e),
          ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f4f70),
          ACE_NTOHL (0x65726174),
          ACE_NTOHL (0x696f6e4d),
          ACE_NTOHL (0x6f64653a),
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/OperationMode:1.0
          14,
          ACE_NTOHL (0x4f706572),
          ACE_NTOHL (0x6174696f),
          ACE_NTOHL (0x6e4d6f64),
          ACE_NTOHL (0x65000000),  // name = OperationMode
          2, // member count
          10,
          ACE_NTOHL (0x4f505f4e),
          ACE_NTOHL (0x4f524d41),
          ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
          10,
          ACE_NTOHL (0x4f505f4f),
          ACE_NTOHL (0x4e455741),
          ACE_NTOHL (0x59000000),  // name = OP_ONEWAY

        9,
        ACE_NTOHL (0x636f6e74),
        ACE_NTOHL (0x65787473),
        ACE_NTOHL (0x0),  // name = contexts
        CORBA::tk_alias, // typecode kind for typedefs
        236, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35,
          ACE_NTOHL (0x49444c3a),
          ACE_NTOHL (0x6f6d672e),
          ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f436f),
          ACE_NTOHL (0x6e746578),
          ACE_NTOHL (0x74496453),
          ACE_NTOHL (0x65713a31),
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ContextIdSeq:1.0
          13,
          ACE_NTOHL (0x436f6e74),
          ACE_NTOHL (0x65787449),
          ACE_NTOHL (0x64536571),
          ACE_NTOHL (0x0),  // name = ContextIdSeq
          CORBA::tk_sequence, // typecode kind
          164, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_alias, // typecode kind for typedefs
            148, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40,
              ACE_NTOHL (0x49444c3a),
              ACE_NTOHL (0x6f6d672e),
              ACE_NTOHL (0x6f72672f),
              ACE_NTOHL (0x434f5242),
              ACE_NTOHL (0x412f436f),
              ACE_NTOHL (0x6e746578),
              ACE_NTOHL (0x74496465),
              ACE_NTOHL (0x6e746966),
              ACE_NTOHL (0x6965723a),
              ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ContextIdentifier:1.0
              18,
              ACE_NTOHL (0x436f6e74),
              ACE_NTOHL (0x65787449),
              ACE_NTOHL (0x64656e74),
              ACE_NTOHL (0x69666965),
              ACE_NTOHL (0x72000000),  // name = ContextIdentifier
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33,
                ACE_NTOHL (0x49444c3a),
                ACE_NTOHL (0x6f6d672e),
                ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f4964),
                ACE_NTOHL (0x656e7469),
                ACE_NTOHL (0x66696572),
                ACE_NTOHL (0x3a312e30),
                ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11,
                ACE_NTOHL (0x4964656e),
                ACE_NTOHL (0x74696669),
                ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string,
                0U, // string length


            0U,


        11,
        ACE_NTOHL (0x70617261),
        ACE_NTOHL (0x6d657465),
        ACE_NTOHL (0x72730000),  // name = parameters
        CORBA::tk_alias, // typecode kind for typedefs
        496, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          40,
          ACE_NTOHL (0x49444c3a),
          ACE_NTOHL (0x6f6d672e),
          ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f5061),
          ACE_NTOHL (0x72446573),
          ACE_NTOHL (0x63726970),
          ACE_NTOHL (0x74696f6e),
          ACE_NTOHL (0x5365713a),
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParDescriptionSeq:1.0
          18,
          ACE_NTOHL (0x50617244),
          ACE_NTOHL (0x65736372),
          ACE_NTOHL (0x69707469),
          ACE_NTOHL (0x6f6e5365),
          ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          416, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            400, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              43,
              ACE_NTOHL (0x49444c3a),
              ACE_NTOHL (0x6f6d672e),
              ACE_NTOHL (0x6f72672f),
              ACE_NTOHL (0x434f5242),
              ACE_NTOHL (0x412f5061),
              ACE_NTOHL (0x72616d65),
              ACE_NTOHL (0x74657244),
              ACE_NTOHL (0x65736372),
              ACE_NTOHL (0x69707469),
              ACE_NTOHL (0x6f6e3a31),
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ParameterDescription:1.0
              21,
              ACE_NTOHL (0x50617261),
              ACE_NTOHL (0x6d657465),
              ACE_NTOHL (0x72446573),
              ACE_NTOHL (0x63726970),
              ACE_NTOHL (0x74696f6e),
              ACE_NTOHL (0x0),  // name = ParameterDescription
              4, // member count
              5,
              ACE_NTOHL (0x6e616d65),
              ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33,
                ACE_NTOHL (0x49444c3a),
                ACE_NTOHL (0x6f6d672e),
                ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f4964),
                ACE_NTOHL (0x656e7469),
                ACE_NTOHL (0x66696572),
                ACE_NTOHL (0x3a312e30),
                ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11,
                ACE_NTOHL (0x4964656e),
                ACE_NTOHL (0x74696669),
                ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string,
                0U, // string length

              5,
              ACE_NTOHL (0x74797065),
              ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,

              9,
              ACE_NTOHL (0x74797065),
              ACE_NTOHL (0x5f646566),
              ACE_NTOHL (0x0),  // name = type_def
              CORBA::tk_objref, // typecode kind
              52, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30,
                ACE_NTOHL (0x49444c3a),
                ACE_NTOHL (0x6f6d672e),
                ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f4944),
                ACE_NTOHL (0x4c547970),
                ACE_NTOHL (0x653a312e),
                ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
                8,
                ACE_NTOHL (0x49444c54),
                ACE_NTOHL (0x79706500),  // name = IDLType

              5,
              ACE_NTOHL (0x6d6f6465),
              ACE_NTOHL (0x0),  // name = mode
              CORBA::tk_enum, // typecode kind
              116, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                36,
                ACE_NTOHL (0x49444c3a),
                ACE_NTOHL (0x6f6d672e),
                ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f5061),
                ACE_NTOHL (0x72616d65),
                ACE_NTOHL (0x7465724d),
                ACE_NTOHL (0x6f64653a),
                ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParameterMode:1.0
                14,
                ACE_NTOHL (0x50617261),
                ACE_NTOHL (0x6d657465),
                ACE_NTOHL (0x724d6f64),
                ACE_NTOHL (0x65000000),  // name = ParameterMode
                3, // member count
                9,
                ACE_NTOHL (0x50415241),
                ACE_NTOHL (0x4d5f494e),
                ACE_NTOHL (0x0),  // name = PARAM_IN
                10,
                ACE_NTOHL (0x50415241),
                ACE_NTOHL (0x4d5f4f55),
                ACE_NTOHL (0x54000000),  // name = PARAM_OUT
                12,
                ACE_NTOHL (0x50415241),
                ACE_NTOHL (0x4d5f494e),
                ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT


            0U,


        11,
        ACE_NTOHL (0x65786365),
        ACE_NTOHL (0x7074696f),
        ACE_NTOHL (0x6e730000),  // name = exceptions
        CORBA::tk_alias, // typecode kind for typedefs
        556, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          40,
          ACE_NTOHL (0x49444c3a),
          ACE_NTOHL (0x6f6d672e),
          ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f4578),
          ACE_NTOHL (0x63446573),
          ACE_NTOHL (0x63726970),
          ACE_NTOHL (0x74696f6e),
          ACE_NTOHL (0x5365713a),
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExcDescriptionSeq:1.0
          18,
          ACE_NTOHL (0x45786344),
          ACE_NTOHL (0x65736372),
          ACE_NTOHL (0x69707469),
          ACE_NTOHL (0x6f6e5365),
          ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          476, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            460, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              43,
              ACE_NTOHL (0x49444c3a),
              ACE_NTOHL (0x6f6d672e),
              ACE_NTOHL (0x6f72672f),
              ACE_NTOHL (0x434f5242),
              ACE_NTOHL (0x412f4578),
              ACE_NTOHL (0x63657074),
              ACE_NTOHL (0x696f6e44),
              ACE_NTOHL (0x65736372),
              ACE_NTOHL (0x69707469),
              ACE_NTOHL (0x6f6e3a31),
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDescription:1.0
              21,
              ACE_NTOHL (0x45786365),
              ACE_NTOHL (0x7074696f),
              ACE_NTOHL (0x6e446573),
              ACE_NTOHL (0x63726970),
              ACE_NTOHL (0x74696f6e),
              ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
              5,
              ACE_NTOHL (0x6e616d65),
              ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33,
                ACE_NTOHL (0x49444c3a),
                ACE_NTOHL (0x6f6d672e),
                ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f4964),
                ACE_NTOHL (0x656e7469),
                ACE_NTOHL (0x66696572),
                ACE_NTOHL (0x3a312e30),
                ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11,
                ACE_NTOHL (0x4964656e),
                ACE_NTOHL (0x74696669),
                ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string,
                0U, // string length

              3,
              ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              72, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                35,
                ACE_NTOHL (0x49444c3a),
                ACE_NTOHL (0x6f6d672e),
                ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f5265),
                ACE_NTOHL (0x706f7369),
                ACE_NTOHL (0x746f7279),
                ACE_NTOHL (0x49643a31),
                ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13,
                ACE_NTOHL (0x5265706f),
                ACE_NTOHL (0x7369746f),
                ACE_NTOHL (0x72794964),
                ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string,
                0U, // string length

              11,
              ACE_NTOHL (0x64656669),
              ACE_NTOHL (0x6e65645f),
              ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_alias, // typecode kind for typedefs
              72, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                35,
                ACE_NTOHL (0x49444c3a),
                ACE_NTOHL (0x6f6d672e),
                ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f5265),
                ACE_NTOHL (0x706f7369),
                ACE_NTOHL (0x746f7279),
                ACE_NTOHL (0x49643a31),
                ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13,
                ACE_NTOHL (0x5265706f),
                ACE_NTOHL (0x7369746f),
                ACE_NTOHL (0x72794964),
                ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string,
                0U, // string length

              8,
              ACE_NTOHL (0x76657273),
              ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                34,
                ACE_NTOHL (0x49444c3a),
                ACE_NTOHL (0x6f6d672e),
                ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f5665),
                ACE_NTOHL (0x7273696f),
                ACE_NTOHL (0x6e537065),
                ACE_NTOHL (0x633a312e),
                ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
                12,
                ACE_NTOHL (0x56657273),
                ACE_NTOHL (0x696f6e53),
                ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string,
                0U, // string length

              5,
              ACE_NTOHL (0x74797065),
              ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,



      0U,


  11,
  ACE_NTOHL (0x61747472),
  ACE_NTOHL (0x69627574),
  ACE_NTOHL (0x65730000),  // name = attributes
  CORBA::tk_alias, // typecode kind for typedefs
  684, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    41,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x434f5242),
    ACE_NTOHL (0x412f4174),
    ACE_NTOHL (0x74724465),
    ACE_NTOHL (0x73637269),
    ACE_NTOHL (0x7074696f),
    ACE_NTOHL (0x6e536571),
    ACE_NTOHL (0x3a312e30),
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/AttrDescriptionSeq:1.0
    19,
    ACE_NTOHL (0x41747472),
    ACE_NTOHL (0x44657363),
    ACE_NTOHL (0x72697074),
    ACE_NTOHL (0x696f6e53),
    ACE_NTOHL (0x65710000),  // name = AttrDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    600, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      584, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43,
        ACE_NTOHL (0x49444c3a),
        ACE_NTOHL (0x6f6d672e),
        ACE_NTOHL (0x6f72672f),
        ACE_NTOHL (0x434f5242),
        ACE_NTOHL (0x412f4174),
        ACE_NTOHL (0x74726962),
        ACE_NTOHL (0x75746544),
        ACE_NTOHL (0x65736372),
        ACE_NTOHL (0x69707469),
        ACE_NTOHL (0x6f6e3a31),
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/AttributeDescription:1.0
        21,
        ACE_NTOHL (0x41747472),
        ACE_NTOHL (0x69627574),
        ACE_NTOHL (0x65446573),
        ACE_NTOHL (0x63726970),
        ACE_NTOHL (0x74696f6e),
        ACE_NTOHL (0x0),  // name = AttributeDescription
        6, // member count
        5,
        ACE_NTOHL (0x6e616d65),
        ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33,
          ACE_NTOHL (0x49444c3a),
          ACE_NTOHL (0x6f6d672e),
          ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f4964),
          ACE_NTOHL (0x656e7469),
          ACE_NTOHL (0x66696572),
          ACE_NTOHL (0x3a312e30),
          ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11,
          ACE_NTOHL (0x4964656e),
          ACE_NTOHL (0x74696669),
          ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string,
          0U, // string length

        3,
        ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35,
          ACE_NTOHL (0x49444c3a),
          ACE_NTOHL (0x6f6d672e),
          ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f5265),
          ACE_NTOHL (0x706f7369),
          ACE_NTOHL (0x746f7279),
          ACE_NTOHL (0x49643a31),
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13,
          ACE_NTOHL (0x5265706f),
          ACE_NTOHL (0x7369746f),
          ACE_NTOHL (0x72794964),
          ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string,
          0U, // string length

        11,
        ACE_NTOHL (0x64656669),
        ACE_NTOHL (0x6e65645f),
        ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35,
          ACE_NTOHL (0x49444c3a),
          ACE_NTOHL (0x6f6d672e),
          ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f5265),
          ACE_NTOHL (0x706f7369),
          ACE_NTOHL (0x746f7279),
          ACE_NTOHL (0x49643a31),
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13,
          ACE_NTOHL (0x5265706f),
          ACE_NTOHL (0x7369746f),
          ACE_NTOHL (0x72794964),
          ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string,
          0U, // string length

        8,
        ACE_NTOHL (0x76657273),
        ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          34,
          ACE_NTOHL (0x49444c3a),
          ACE_NTOHL (0x6f6d672e),
          ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f5665),
          ACE_NTOHL (0x7273696f),
          ACE_NTOHL (0x6e537065),
          ACE_NTOHL (0x633a312e),
          ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
          12,
          ACE_NTOHL (0x56657273),
          ACE_NTOHL (0x696f6e53),
          ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string,
          0U, // string length

        5,
        ACE_NTOHL (0x74797065),
        ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,

        5,
        ACE_NTOHL (0x6d6f6465),
        ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        104, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          36,
          ACE_NTOHL (0x49444c3a),
          ACE_NTOHL (0x6f6d672e),
          ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f4174),
          ACE_NTOHL (0x74726962),
          ACE_NTOHL (0x7574654d),
          ACE_NTOHL (0x6f64653a),
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/AttributeMode:1.0
          14,
          ACE_NTOHL (0x41747472),
          ACE_NTOHL (0x69627574),
          ACE_NTOHL (0x654d6f64),
          ACE_NTOHL (0x65000000),  // name = AttributeMode
          2, // member count
          12,
          ACE_NTOHL (0x41545452),
          ACE_NTOHL (0x5f4e4f52),
          ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
          14,
          ACE_NTOHL (0x41545452),
          ACE_NTOHL (0x5f524541),
          ACE_NTOHL (0x444f4e4c),
          ACE_NTOHL (0x59000000),  // name = ATTR_READONLY


      0U,


  16,
  ACE_NTOHL (0x62617365),
  ACE_NTOHL (0x5f696e74),
  ACE_NTOHL (0x65726661),
  ACE_NTOHL (0x63657300),  // name = base_interfaces
  CORBA::tk_alias, // typecode kind for typedefs
  164, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    38,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x434f5242),
    ACE_NTOHL (0x412f5265),
    ACE_NTOHL (0x706f7369),
    ACE_NTOHL (0x746f7279),
    ACE_NTOHL (0x49645365),
    ACE_NTOHL (0x713a312e),
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/RepositoryIdSeq:1.0
    16,
    ACE_NTOHL (0x5265706f),
    ACE_NTOHL (0x7369746f),
    ACE_NTOHL (0x72794964),
    ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
    CORBA::tk_sequence, // typecode kind
    88, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35,
        ACE_NTOHL (0x49444c3a),
        ACE_NTOHL (0x6f6d672e),
        ACE_NTOHL (0x6f72672f),
        ACE_NTOHL (0x434f5242),
        ACE_NTOHL (0x412f5265),
        ACE_NTOHL (0x706f7369),
        ACE_NTOHL (0x746f7279),
        ACE_NTOHL (0x49643a31),
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13,
        ACE_NTOHL (0x5265706f),
        ACE_NTOHL (0x7369746f),
        ACE_NTOHL (0x72794964),
        ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string,
        0U, // string length

      0U,


  5,
  ACE_NTOHL (0x74797065),
  ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_InterfaceDef_FullInterfaceDescription (
    CORBA::tk_struct,
    sizeof (_oc_CORBA_InterfaceDef_FullInterfaceDescription),
    (char *) &_oc_CORBA_InterfaceDef_FullInterfaceDescription,
    0,
    sizeof (CORBA_InterfaceDef::FullInterfaceDescription)
  );

CORBA::TypeCode_ptr CORBA_InterfaceDef::_tc_FullInterfaceDescription =
  &_tc_TAO_tc_CORBA_InterfaceDef_FullInterfaceDescription;

void CORBA_InterfaceDef::FullInterfaceDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  FullInterfaceDescription *tmp = ACE_static_cast (FullInterfaceDescription*, _tao_void_pointer);
  delete tmp;
}

CORBA_InterfaceDef::FullInterfaceDescription * CORBA_InterfaceDef::describe_interface (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_InterfaceDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_InterfaceDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.describe_interface (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA_AttributeDef_ptr CORBA_InterfaceDef::create_attribute (
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr type,
    CORBA::AttributeMode mode
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_InterfaceDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_InterfaceDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.create_attribute (
      this,
      id,
      name,
      version,
      type,
      mode
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA_OperationDef_ptr CORBA_InterfaceDef::create_operation (
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr result,
    CORBA::OperationMode mode,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions,
    const CORBA_ContextIdSeq & contexts
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_CORBA_InterfaceDef_Proxy_Impl &proxy =
    this->the_TAO_CORBA_InterfaceDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.create_operation (
      this,
      id,
      name,
      version,
      result,
      mode,
      params,
      exceptions,
      contexts
      ACE_ENV_ARG_PARAMETER
  );
}

void CORBA_InterfaceDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_InterfaceDescription *tmp = ACE_static_cast (CORBA_InterfaceDescription*, _tao_void_pointer);
  delete tmp;
}

CORBA_AbstractInterfaceDef_ptr
tao_CORBA_AbstractInterfaceDef_duplicate (
    CORBA_AbstractInterfaceDef_ptr p
  )
{
  return CORBA_AbstractInterfaceDef::_duplicate (p);
}

void
tao_CORBA_AbstractInterfaceDef_release (
    CORBA_AbstractInterfaceDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA_AbstractInterfaceDef_ptr
tao_CORBA_AbstractInterfaceDef_nil (
    void
  )
{
  return CORBA_AbstractInterfaceDef::_nil ();
}

CORBA_AbstractInterfaceDef_ptr
tao_CORBA_AbstractInterfaceDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA_AbstractInterfaceDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_AbstractInterfaceDef_upcast (
    void *src
  )
{
  CORBA_AbstractInterfaceDef **tmp =
    ACE_static_cast (CORBA_AbstractInterfaceDef **, src);
  return *tmp;
}

int CORBA_AbstractInterfaceDef::_tao_class_id = 0;

// *************************************************************
// Operations for class CORBA_AbstractInterfaceDef_var
// *************************************************************

CORBA_AbstractInterfaceDef_var::CORBA_AbstractInterfaceDef_var (void) // default constructor
  : ptr_ (CORBA_AbstractInterfaceDef::_nil ())
{}

::CORBA_AbstractInterfaceDef_ptr
CORBA_AbstractInterfaceDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA_AbstractInterfaceDef_var::CORBA_AbstractInterfaceDef_var (const ::CORBA_AbstractInterfaceDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (CORBA_AbstractInterfaceDef::_duplicate (p.ptr ()))
{}

CORBA_AbstractInterfaceDef_var::~CORBA_AbstractInterfaceDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

CORBA_AbstractInterfaceDef_var &
CORBA_AbstractInterfaceDef_var::operator= (CORBA_AbstractInterfaceDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA_AbstractInterfaceDef_var &
CORBA_AbstractInterfaceDef_var::operator= (const ::CORBA_AbstractInterfaceDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA_AbstractInterfaceDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA_AbstractInterfaceDef_var::operator const ::CORBA_AbstractInterfaceDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA_AbstractInterfaceDef_var::operator ::CORBA_AbstractInterfaceDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_AbstractInterfaceDef_ptr
CORBA_AbstractInterfaceDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA_AbstractInterfaceDef_ptr
CORBA_AbstractInterfaceDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA_AbstractInterfaceDef_ptr &
CORBA_AbstractInterfaceDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA_AbstractInterfaceDef_ptr &
CORBA_AbstractInterfaceDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_AbstractInterfaceDef::_nil ();
  return this->ptr_;
}

::CORBA_AbstractInterfaceDef_ptr
CORBA_AbstractInterfaceDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA_AbstractInterfaceDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA_AbstractInterfaceDef::_nil ();
  return val;
}

::CORBA_AbstractInterfaceDef_ptr
CORBA_AbstractInterfaceDef_var::tao_duplicate (CORBA_AbstractInterfaceDef_ptr p)
{
  return ::CORBA_AbstractInterfaceDef::_duplicate (p);
}

void
CORBA_AbstractInterfaceDef_var::tao_release (CORBA_AbstractInterfaceDef_ptr p)
{
  CORBA::release (p);
}

::CORBA_AbstractInterfaceDef_ptr
CORBA_AbstractInterfaceDef_var::tao_nil (void)
{
  return ::CORBA_AbstractInterfaceDef::_nil ();
}

::CORBA_AbstractInterfaceDef_ptr
CORBA_AbstractInterfaceDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA_AbstractInterfaceDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA_AbstractInterfaceDef_var::tao_upcast (void *src)
{
  CORBA_AbstractInterfaceDef **tmp =
    ACE_static_cast (CORBA_AbstractInterfaceDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class CORBA_AbstractInterfaceDef_out
// *************************************************************

CORBA_AbstractInterfaceDef_out::CORBA_AbstractInterfaceDef_out (CORBA_AbstractInterfaceDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA_AbstractInterfaceDef::_nil ();
}

CORBA_AbstractInterfaceDef_out::CORBA_AbstractInterfaceDef_out (CORBA_AbstractInterfaceDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_AbstractInterfaceDef::_nil ();
}

CORBA_AbstractInterfaceDef_out::CORBA_AbstractInterfaceDef_out (const ::CORBA_AbstractInterfaceDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (CORBA_AbstractInterfaceDef_out &, p).ptr_)
{}

::CORBA_AbstractInterfaceDef_out &
CORBA_AbstractInterfaceDef_out::operator= (const ::CORBA_AbstractInterfaceDef_out &p)
{
  this->ptr_ = ACE_const_cast (CORBA_AbstractInterfaceDef_out&, p).ptr_;
  return *this;
}

CORBA_AbstractInterfaceDef_out &
CORBA_AbstractInterfaceDef_out::operator= (const ::CORBA_AbstractInterfaceDef_var &p)
{
  this->ptr_ = ::CORBA_AbstractInterfaceDef::_duplicate (p.ptr ());
  return *this;
}

CORBA_AbstractInterfaceDef_out &
CORBA_AbstractInterfaceDef_out::operator= (CORBA_AbstractInterfaceDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA_AbstractInterfaceDef_out::operator ::CORBA_AbstractInterfaceDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_AbstractInterfaceDef_ptr &
CORBA_AbstractInterfaceDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::CORBA_AbstractInterfaceDef_ptr
CORBA_AbstractInterfaceDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation.
//

_TAO_CORBA_AbstractInterfaceDef_Proxy_Impl::_TAO_CORBA_AbstractInterfaceDef_Proxy_Impl (void)
{}

_TAO_CORBA_AbstractInterfaceDef_Remote_Proxy_Impl::_TAO_CORBA_AbstractInterfaceDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods


//
//            End  Base & Remote  Proxy Implemeentation.
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_CORBA_AbstractInterfaceDef_Proxy_Broker::_TAO_CORBA_AbstractInterfaceDef_Proxy_Broker (void)
{
}

_TAO_CORBA_AbstractInterfaceDef_Proxy_Broker::~_TAO_CORBA_AbstractInterfaceDef_Proxy_Broker (void)
{
}

_TAO_CORBA_AbstractInterfaceDef_Proxy_Broker * (*_TAO_CORBA_AbstractInterfaceDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_CORBA_AbstractInterfaceDef_Remote_Proxy_Broker *
_TAO_CORBA_AbstractInterfaceDef_Remote_Proxy_Broker::the_TAO_CORBA_AbstractInterfaceDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_CORBA_AbstractInterfaceDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_CORBA_AbstractInterfaceDef_Remote_Proxy_Broker::_TAO_CORBA_AbstractInterfaceDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_AbstractInterfaceDef_Remote_Proxy_Broker::~_TAO_CORBA_AbstractInterfaceDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_AbstractInterfaceDef_Proxy_Impl&
_TAO_CORBA_AbstractInterfaceDef_Remote_Proxy_Broker::select_proxy (
  ::CORBA_AbstractInterfaceDef *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
CORBA_AbstractInterfaceDef::CORBA_AbstractInterfaceDef (int collocated)
{
  this->CORBA_AbstractInterfaceDef_setup_collocation (collocated);
}

// destructor
CORBA_AbstractInterfaceDef::~CORBA_AbstractInterfaceDef (void)
{}

void
CORBA_AbstractInterfaceDef::CORBA_AbstractInterfaceDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_CORBA_AbstractInterfaceDef_Proxy_Broker_ =
      ::_TAO_CORBA_AbstractInterfaceDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_CORBA_AbstractInterfaceDef_Proxy_Broker_ =
      ::_TAO_CORBA_AbstractInterfaceDef_Remote_Proxy_Broker::the_TAO_CORBA_AbstractInterfaceDef_Remote_Proxy_Broker ();

  this->CORBA_InterfaceDef_setup_collocation (collocated);
}

void CORBA_AbstractInterfaceDef::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_AbstractInterfaceDef *tmp = ACE_static_cast (CORBA_AbstractInterfaceDef*, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA_AbstractInterfaceDef_ptr CORBA_AbstractInterfaceDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_AbstractInterfaceDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/AbstractInterfaceDef:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (CORBA_AbstractInterfaceDef::_nil ());
      if (is_a == 0)
        return CORBA_AbstractInterfaceDef::_nil ();
    }
  return CORBA_AbstractInterfaceDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA_AbstractInterfaceDef_ptr CORBA_AbstractInterfaceDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_AbstractInterfaceDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      CORBA_AbstractInterfaceDef_ptr default_proxy = CORBA_AbstractInterfaceDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_CORBA_AbstractInterfaceDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::CORBA_AbstractInterfaceDef (
            stub,
            1,
            obj->_servant ()),

          CORBA_AbstractInterfaceDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::CORBA_AbstractInterfaceDef (stub, 0, obj->_servant ()), CORBA_AbstractInterfaceDef::_nil ());
        return default_proxy;
      }
    else
      return
        ACE_reinterpret_cast
          (
            CORBA_AbstractInterfaceDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &CORBA_AbstractInterfaceDef::_tao_class_id
                    )
                )
          );
}

CORBA_AbstractInterfaceDef_ptr
CORBA_AbstractInterfaceDef::_duplicate (CORBA_AbstractInterfaceDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean CORBA_AbstractInterfaceDef::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/AbstractInterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *CORBA_AbstractInterfaceDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_AbstractInterfaceDef::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_InterfaceDef::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_InterfaceDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Container::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Container_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IDLType::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* CORBA_AbstractInterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/AbstractInterfaceDef:1.0";
}

CORBA_LocalInterfaceDef_ptr
tao_CORBA_LocalInterfaceDef_duplicate (
    CORBA_LocalInterfaceDef_ptr p
  )
{
  return CORBA_LocalInterfaceDef::_duplicate (p);
}

void
tao_CORBA_LocalInterfaceDef_release (
    CORBA_LocalInterfaceDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA_LocalInterfaceDef_ptr
tao_CORBA_LocalInterfaceDef_nil (
    void
  )
{
  return CORBA_LocalInterfaceDef::_nil ();
}

CORBA_LocalInterfaceDef_ptr
tao_CORBA_LocalInterfaceDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA_LocalInterfaceDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_LocalInterfaceDef_upcast (
    void *src
  )
{
  CORBA_LocalInterfaceDef **tmp =
    ACE_static_cast (CORBA_LocalInterfaceDef **, src);
  return *tmp;
}

int CORBA_LocalInterfaceDef::_tao_class_id = 0;

// *************************************************************
// Operations for class CORBA_LocalInterfaceDef_var
// *************************************************************

CORBA_LocalInterfaceDef_var::CORBA_LocalInterfaceDef_var (void) // default constructor
  : ptr_ (CORBA_LocalInterfaceDef::_nil ())
{}

::CORBA_LocalInterfaceDef_ptr
CORBA_LocalInterfaceDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA_LocalInterfaceDef_var::CORBA_LocalInterfaceDef_var (const ::CORBA_LocalInterfaceDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (CORBA_LocalInterfaceDef::_duplicate (p.ptr ()))
{}

CORBA_LocalInterfaceDef_var::~CORBA_LocalInterfaceDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

CORBA_LocalInterfaceDef_var &
CORBA_LocalInterfaceDef_var::operator= (CORBA_LocalInterfaceDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA_LocalInterfaceDef_var &
CORBA_LocalInterfaceDef_var::operator= (const ::CORBA_LocalInterfaceDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA_LocalInterfaceDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA_LocalInterfaceDef_var::operator const ::CORBA_LocalInterfaceDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA_LocalInterfaceDef_var::operator ::CORBA_LocalInterfaceDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_LocalInterfaceDef_ptr
CORBA_LocalInterfaceDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA_LocalInterfaceDef_ptr
CORBA_LocalInterfaceDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA_LocalInterfaceDef_ptr &
CORBA_LocalInterfaceDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA_LocalInterfaceDef_ptr &
CORBA_LocalInterfaceDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_LocalInterfaceDef::_nil ();
  return this->ptr_;
}

::CORBA_LocalInterfaceDef_ptr
CORBA_LocalInterfaceDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA_LocalInterfaceDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA_LocalInterfaceDef::_nil ();
  return val;
}

::CORBA_LocalInterfaceDef_ptr
CORBA_LocalInterfaceDef_var::tao_duplicate (CORBA_LocalInterfaceDef_ptr p)
{
  return ::CORBA_LocalInterfaceDef::_duplicate (p);
}

void
CORBA_LocalInterfaceDef_var::tao_release (CORBA_LocalInterfaceDef_ptr p)
{
  CORBA::release (p);
}

::CORBA_LocalInterfaceDef_ptr
CORBA_LocalInterfaceDef_var::tao_nil (void)
{
  return ::CORBA_LocalInterfaceDef::_nil ();
}

::CORBA_LocalInterfaceDef_ptr
CORBA_LocalInterfaceDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA_LocalInterfaceDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA_LocalInterfaceDef_var::tao_upcast (void *src)
{
  CORBA_LocalInterfaceDef **tmp =
    ACE_static_cast (CORBA_LocalInterfaceDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class CORBA_LocalInterfaceDef_out
// *************************************************************

CORBA_LocalInterfaceDef_out::CORBA_LocalInterfaceDef_out (CORBA_LocalInterfaceDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA_LocalInterfaceDef::_nil ();
}

CORBA_LocalInterfaceDef_out::CORBA_LocalInterfaceDef_out (CORBA_LocalInterfaceDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA_LocalInterfaceDef::_nil ();
}

CORBA_LocalInterfaceDef_out::CORBA_LocalInterfaceDef_out (const ::CORBA_LocalInterfaceDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (CORBA_LocalInterfaceDef_out &, p).ptr_)
{}

::CORBA_LocalInterfaceDef_out &
CORBA_LocalInterfaceDef_out::operator= (const ::CORBA_LocalInterfaceDef_out &p)
{
  this->ptr_ = ACE_const_cast (CORBA_LocalInterfaceDef_out&, p).ptr_;
  return *this;
}

CORBA_LocalInterfaceDef_out &
CORBA_LocalInterfaceDef_out::operator= (const ::CORBA_LocalInterfaceDef_var &p)
{
  this->ptr_ = ::CORBA_LocalInterfaceDef::_duplicate (p.ptr ());
  return *this;
}

CORBA_LocalInterfaceDef_out &
CORBA_LocalInterfaceDef_out::operator= (CORBA_LocalInterfaceDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA_LocalInterfaceDef_out::operator ::CORBA_LocalInterfaceDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA_LocalInterfaceDef_ptr &
CORBA_LocalInterfaceDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::CORBA_LocalInterfaceDef_ptr
CORBA_LocalInterfaceDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation.
//

_TAO_CORBA_LocalInterfaceDef_Proxy_Impl::_TAO_CORBA_LocalInterfaceDef_Proxy_Impl (void)
{}

_TAO_CORBA_LocalInterfaceDef_Remote_Proxy_Impl::_TAO_CORBA_LocalInterfaceDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods


//
//            End  Base & Remote  Proxy Implemeentation.
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_CORBA_LocalInterfaceDef_Proxy_Broker::_TAO_CORBA_LocalInterfaceDef_Proxy_Broker (void)
{
}

_TAO_CORBA_LocalInterfaceDef_Proxy_Broker::~_TAO_CORBA_LocalInterfaceDef_Proxy_Broker (void)
{
}

_TAO_CORBA_LocalInterfaceDef_Proxy_Broker * (*_TAO_CORBA_LocalInterfaceDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_CORBA_LocalInterfaceDef_Remote_Proxy_Broker *
_TAO_CORBA_LocalInterfaceDef_Remote_Proxy_Broker::the_TAO_CORBA_LocalInterfaceDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_CORBA_LocalInterfaceDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_CORBA_LocalInterfaceDef_Remote_Proxy_Broker::_TAO_CORBA_LocalInterfaceDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_LocalInterfaceDef_Remote_Proxy_Broker::~_TAO_CORBA_LocalInterfaceDef_Remote_Proxy_Broker (void)
{
}

_TAO_CORBA_LocalInterfaceDef_Proxy_Impl&
_TAO_CORBA_LocalInterfaceDef_Remote_Proxy_Broker::select_proxy (
  ::CORBA_LocalInterfaceDef *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
CORBA_LocalInterfaceDef::CORBA_LocalInterfaceDef (int collocated)
{
  this->CORBA_LocalInterfaceDef_setup_collocation (collocated);
}

// destructor
CORBA_LocalInterfaceDef::~CORBA_LocalInterfaceDef (void)
{}

void
CORBA_LocalInterfaceDef::CORBA_LocalInterfaceDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_CORBA_LocalInterfaceDef_Proxy_Broker_ =
      ::_TAO_CORBA_LocalInterfaceDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_CORBA_LocalInterfaceDef_Proxy_Broker_ =
      ::_TAO_CORBA_LocalInterfaceDef_Remote_Proxy_Broker::the_TAO_CORBA_LocalInterfaceDef_Remote_Proxy_Broker ();

  this->CORBA_InterfaceDef_setup_collocation (collocated);
}

void CORBA_LocalInterfaceDef::_tao_any_destructor (void *_tao_void_pointer)
{
  CORBA_LocalInterfaceDef *tmp = ACE_static_cast (CORBA_LocalInterfaceDef*, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA_LocalInterfaceDef_ptr CORBA_LocalInterfaceDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_LocalInterfaceDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/LocalInterfaceDef:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (CORBA_LocalInterfaceDef::_nil ());
      if (is_a == 0)
        return CORBA_LocalInterfaceDef::_nil ();
    }
  return CORBA_LocalInterfaceDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA_LocalInterfaceDef_ptr CORBA_LocalInterfaceDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_LocalInterfaceDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      CORBA_LocalInterfaceDef_ptr default_proxy = CORBA_LocalInterfaceDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_CORBA_LocalInterfaceDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::CORBA_LocalInterfaceDef (
            stub,
            1,
            obj->_servant ()),

          CORBA_LocalInterfaceDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::CORBA_LocalInterfaceDef (stub, 0, obj->_servant ()), CORBA_LocalInterfaceDef::_nil ());
        return default_proxy;
      }
    else
      return
        ACE_reinterpret_cast
          (
            CORBA_LocalInterfaceDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &CORBA_LocalInterfaceDef::_tao_class_id
                    )
                )
          );
}

CORBA_LocalInterfaceDef_ptr
CORBA_LocalInterfaceDef::_duplicate (CORBA_LocalInterfaceDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean CORBA_LocalInterfaceDef::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/LocalInterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *CORBA_LocalInterfaceDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_LocalInterfaceDef::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_InterfaceDef::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_InterfaceDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Container::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Container_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IDLType::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* CORBA_LocalInterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/LocalInterfaceDef:1.0";
}

void operator<<= (CORBA::Any &_tao_any, CORBA::PrimitiveKind _tao_elem)
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_PrimitiveKind,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::PrimitiveKind &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_PrimitiveKind ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, CORBA_Repository_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_Repository,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        CORBA_Repository::_duplicate (_tao_elem),
        CORBA_Repository::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_Repository_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA_Repository::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_Repository ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_Repository,
          1,
          _tao_elem,
          CORBA_Repository::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA_Repository::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA_Repository::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<CORBA_Repository,CORBA_Repository_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<CORBA_Repository,CORBA_Repository_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, CORBA_ModuleDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_ModuleDef,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        CORBA_ModuleDef::_duplicate (_tao_elem),
        CORBA_ModuleDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_ModuleDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA_ModuleDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_ModuleDef ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_ModuleDef,
          1,
          _tao_elem,
          CORBA_ModuleDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA_ModuleDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA_ModuleDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<CORBA_ModuleDef,CORBA_ModuleDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<CORBA_ModuleDef,CORBA_ModuleDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const CORBA_ModuleDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_ModuleDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, CORBA_ModuleDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_ModuleDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      CORBA_ModuleDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_ModuleDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const CORBA_ModuleDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA_ModuleDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_ModuleDescription ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const CORBA_ModuleDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      CORBA_ModuleDescription *tmp;
      ACE_NEW_RETURN (tmp, CORBA_ModuleDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ModuleDescription,
            1,
            ACE_static_cast (void *, tmp),
            CORBA_ModuleDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, CORBA_ConstantDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_ConstantDef,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        CORBA_ConstantDef::_duplicate (_tao_elem),
        CORBA_ConstantDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_ConstantDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA_ConstantDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_ConstantDef ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_ConstantDef,
          1,
          _tao_elem,
          CORBA_ConstantDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA_ConstantDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA_ConstantDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<CORBA_ConstantDef,CORBA_ConstantDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<CORBA_ConstantDef,CORBA_ConstantDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const CORBA_ConstantDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_ConstantDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, CORBA_ConstantDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_ConstantDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      CORBA_ConstantDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_ConstantDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const CORBA_ConstantDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA_ConstantDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_ConstantDescription ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const CORBA_ConstantDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      CORBA_ConstantDescription *tmp;
      ACE_NEW_RETURN (tmp, CORBA_ConstantDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ConstantDescription,
            1,
            ACE_static_cast (void *, tmp),
            CORBA_ConstantDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, CORBA_StructDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_StructDef,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        CORBA_StructDef::_duplicate (_tao_elem),
        CORBA_StructDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_StructDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA_StructDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_StructDef ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_StructDef,
          1,
          _tao_elem,
          CORBA_StructDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA_StructDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA_StructDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<CORBA_StructDef,CORBA_StructDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<CORBA_StructDef,CORBA_StructDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, CORBA_UnionDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_UnionDef,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        CORBA_UnionDef::_duplicate (_tao_elem),
        CORBA_UnionDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_UnionDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA_UnionDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_UnionDef ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_UnionDef,
          1,
          _tao_elem,
          CORBA_UnionDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA_UnionDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA_UnionDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<CORBA_UnionDef,CORBA_UnionDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<CORBA_UnionDef,CORBA_UnionDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, CORBA_EnumDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_EnumDef,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        CORBA_EnumDef::_duplicate (_tao_elem),
        CORBA_EnumDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_EnumDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA_EnumDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_EnumDef ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_EnumDef,
          1,
          _tao_elem,
          CORBA_EnumDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA_EnumDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA_EnumDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<CORBA_EnumDef,CORBA_EnumDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<CORBA_EnumDef,CORBA_EnumDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, CORBA_AliasDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_AliasDef,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        CORBA_AliasDef::_duplicate (_tao_elem),
        CORBA_AliasDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_AliasDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA_AliasDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_AliasDef ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_AliasDef,
          1,
          _tao_elem,
          CORBA_AliasDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA_AliasDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA_AliasDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<CORBA_AliasDef,CORBA_AliasDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<CORBA_AliasDef,CORBA_AliasDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, CORBA_NativeDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_NativeDef,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        CORBA_NativeDef::_duplicate (_tao_elem),
        CORBA_NativeDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_NativeDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA_NativeDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_NativeDef ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_NativeDef,
          1,
          _tao_elem,
          CORBA_NativeDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA_NativeDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA_NativeDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<CORBA_NativeDef,CORBA_NativeDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<CORBA_NativeDef,CORBA_NativeDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, CORBA_PrimitiveDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_PrimitiveDef,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        CORBA_PrimitiveDef::_duplicate (_tao_elem),
        CORBA_PrimitiveDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_PrimitiveDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA_PrimitiveDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_PrimitiveDef ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_PrimitiveDef,
          1,
          _tao_elem,
          CORBA_PrimitiveDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA_PrimitiveDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA_PrimitiveDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<CORBA_PrimitiveDef,CORBA_PrimitiveDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<CORBA_PrimitiveDef,CORBA_PrimitiveDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, CORBA_StringDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_StringDef,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        CORBA_StringDef::_duplicate (_tao_elem),
        CORBA_StringDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_StringDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA_StringDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_StringDef ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_StringDef,
          1,
          _tao_elem,
          CORBA_StringDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA_StringDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA_StringDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<CORBA_StringDef,CORBA_StringDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<CORBA_StringDef,CORBA_StringDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, CORBA_WstringDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_WstringDef,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        CORBA_WstringDef::_duplicate (_tao_elem),
        CORBA_WstringDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_WstringDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA_WstringDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_WstringDef ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_WstringDef,
          1,
          _tao_elem,
          CORBA_WstringDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA_WstringDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA_WstringDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<CORBA_WstringDef,CORBA_WstringDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<CORBA_WstringDef,CORBA_WstringDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, CORBA_SequenceDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_SequenceDef,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        CORBA_SequenceDef::_duplicate (_tao_elem),
        CORBA_SequenceDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_SequenceDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA_SequenceDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_SequenceDef ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_SequenceDef,
          1,
          _tao_elem,
          CORBA_SequenceDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA_SequenceDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA_SequenceDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<CORBA_SequenceDef,CORBA_SequenceDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<CORBA_SequenceDef,CORBA_SequenceDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, CORBA_ArrayDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_ArrayDef,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        CORBA_ArrayDef::_duplicate (_tao_elem),
        CORBA_ArrayDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_ArrayDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA_ArrayDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_ArrayDef ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_ArrayDef,
          1,
          _tao_elem,
          CORBA_ArrayDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA_ArrayDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA_ArrayDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<CORBA_ArrayDef,CORBA_ArrayDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<CORBA_ArrayDef,CORBA_ArrayDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, CORBA_ExceptionDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_ExceptionDef,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        CORBA_ExceptionDef::_duplicate (_tao_elem),
        CORBA_ExceptionDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_ExceptionDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA_ExceptionDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_ExceptionDef ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_ExceptionDef,
          1,
          _tao_elem,
          CORBA_ExceptionDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA_ExceptionDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA_ExceptionDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<CORBA_ExceptionDef,CORBA_ExceptionDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<CORBA_ExceptionDef,CORBA_ExceptionDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const CORBA_ExceptionDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_ExceptionDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, CORBA_ExceptionDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_ExceptionDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      CORBA_ExceptionDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_ExceptionDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const CORBA_ExceptionDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA_ExceptionDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_ExceptionDescription ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const CORBA_ExceptionDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      CORBA_ExceptionDescription *tmp;
      ACE_NEW_RETURN (tmp, CORBA_ExceptionDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ExceptionDescription,
            1,
            ACE_static_cast (void *, tmp),
            CORBA_ExceptionDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA_ExceptionDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_ExceptionDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, CORBA_ExceptionDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_ExceptionDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      CORBA_ExceptionDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_ExceptionDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const CORBA_ExceptionDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA_ExceptionDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_ExceptionDefSeq ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const CORBA_ExceptionDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      CORBA_ExceptionDefSeq *tmp;
      ACE_NEW_RETURN (tmp, CORBA_ExceptionDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ExceptionDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            CORBA_ExceptionDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA_ExcDescriptionSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_ExcDescriptionSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, CORBA_ExcDescriptionSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_ExcDescriptionSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      CORBA_ExcDescriptionSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_ExcDescriptionSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const CORBA_ExcDescriptionSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA_ExcDescriptionSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_ExcDescriptionSeq ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const CORBA_ExcDescriptionSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      CORBA_ExcDescriptionSeq *tmp;
      ACE_NEW_RETURN (tmp, CORBA_ExcDescriptionSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ExcDescriptionSeq,
            1,
            ACE_static_cast (void *, tmp),
            CORBA_ExcDescriptionSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::AttributeMode _tao_elem)
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_AttributeMode,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::AttributeMode &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_AttributeMode ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, CORBA_AttributeDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_AttributeDef,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        CORBA_AttributeDef::_duplicate (_tao_elem),
        CORBA_AttributeDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_AttributeDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA_AttributeDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_AttributeDef ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_AttributeDef,
          1,
          _tao_elem,
          CORBA_AttributeDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA_AttributeDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA_AttributeDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<CORBA_AttributeDef,CORBA_AttributeDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<CORBA_AttributeDef,CORBA_AttributeDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const CORBA_AttributeDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_AttributeDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, CORBA_AttributeDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_AttributeDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      CORBA_AttributeDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_AttributeDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const CORBA_AttributeDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA_AttributeDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_AttributeDescription ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const CORBA_AttributeDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      CORBA_AttributeDescription *tmp;
      ACE_NEW_RETURN (tmp, CORBA_AttributeDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_AttributeDescription,
            1,
            ACE_static_cast (void *, tmp),
            CORBA_AttributeDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::OperationMode _tao_elem)
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_OperationMode,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::OperationMode &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_OperationMode ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ParameterMode _tao_elem)
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_ParameterMode,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ParameterMode &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_ParameterMode ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const CORBA_ParameterDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_ParameterDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, CORBA_ParameterDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_ParameterDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      CORBA_ParameterDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_ParameterDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const CORBA_ParameterDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA_ParameterDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_ParameterDescription ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const CORBA_ParameterDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      CORBA_ParameterDescription *tmp;
      ACE_NEW_RETURN (tmp, CORBA_ParameterDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ParameterDescription,
            1,
            ACE_static_cast (void *, tmp),
            CORBA_ParameterDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA_ParDescriptionSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_ParDescriptionSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, CORBA_ParDescriptionSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_ParDescriptionSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      CORBA_ParDescriptionSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_ParDescriptionSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const CORBA_ParDescriptionSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA_ParDescriptionSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_ParDescriptionSeq ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const CORBA_ParDescriptionSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      CORBA_ParDescriptionSeq *tmp;
      ACE_NEW_RETURN (tmp, CORBA_ParDescriptionSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ParDescriptionSeq,
            1,
            ACE_static_cast (void *, tmp),
            CORBA_ParDescriptionSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA_ContextIdSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_ContextIdSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, CORBA_ContextIdSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_ContextIdSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      CORBA_ContextIdSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_ContextIdSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const CORBA_ContextIdSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA_ContextIdSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_ContextIdSeq ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const CORBA_ContextIdSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      CORBA_ContextIdSeq *tmp;
      ACE_NEW_RETURN (tmp, CORBA_ContextIdSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ContextIdSeq,
            1,
            ACE_static_cast (void *, tmp),
            CORBA_ContextIdSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, CORBA_OperationDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_OperationDef,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        CORBA_OperationDef::_duplicate (_tao_elem),
        CORBA_OperationDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_OperationDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA_OperationDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_OperationDef ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_OperationDef,
          1,
          _tao_elem,
          CORBA_OperationDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA_OperationDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA_OperationDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<CORBA_OperationDef,CORBA_OperationDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<CORBA_OperationDef,CORBA_OperationDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const CORBA_OperationDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_OperationDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, CORBA_OperationDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_OperationDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      CORBA_OperationDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_OperationDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const CORBA_OperationDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA_OperationDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_OperationDescription ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const CORBA_OperationDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      CORBA_OperationDescription *tmp;
      ACE_NEW_RETURN (tmp, CORBA_OperationDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_OperationDescription,
            1,
            ACE_static_cast (void *, tmp),
            CORBA_OperationDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA_RepositoryIdSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_RepositoryIdSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, CORBA_RepositoryIdSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_RepositoryIdSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      CORBA_RepositoryIdSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_RepositoryIdSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const CORBA_RepositoryIdSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA_RepositoryIdSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_RepositoryIdSeq ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const CORBA_RepositoryIdSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      CORBA_RepositoryIdSeq *tmp;
      ACE_NEW_RETURN (tmp, CORBA_RepositoryIdSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_RepositoryIdSeq,
            1,
            ACE_static_cast (void *, tmp),
            CORBA_RepositoryIdSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA_OpDescriptionSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_OpDescriptionSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, CORBA_OpDescriptionSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_OpDescriptionSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      CORBA_OpDescriptionSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_OpDescriptionSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const CORBA_OpDescriptionSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA_OpDescriptionSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_OpDescriptionSeq ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const CORBA_OpDescriptionSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      CORBA_OpDescriptionSeq *tmp;
      ACE_NEW_RETURN (tmp, CORBA_OpDescriptionSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_OpDescriptionSeq,
            1,
            ACE_static_cast (void *, tmp),
            CORBA_OpDescriptionSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA_AttrDescriptionSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_AttrDescriptionSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, CORBA_AttrDescriptionSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_AttrDescriptionSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      CORBA_AttrDescriptionSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_AttrDescriptionSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const CORBA_AttrDescriptionSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA_AttrDescriptionSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_AttrDescriptionSeq ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const CORBA_AttrDescriptionSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      CORBA_AttrDescriptionSeq *tmp;
      ACE_NEW_RETURN (tmp, CORBA_AttrDescriptionSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_AttrDescriptionSeq,
            1,
            ACE_static_cast (void *, tmp),
            CORBA_AttrDescriptionSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, CORBA_InterfaceDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_InterfaceDef,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        CORBA_InterfaceDef::_duplicate (_tao_elem),
        CORBA_InterfaceDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_InterfaceDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA_InterfaceDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_InterfaceDef ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_InterfaceDef,
          1,
          _tao_elem,
          CORBA_InterfaceDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA_InterfaceDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA_InterfaceDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<CORBA_InterfaceDef,CORBA_InterfaceDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<CORBA_InterfaceDef,CORBA_InterfaceDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const CORBA_InterfaceDef::FullInterfaceDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      CORBA_InterfaceDef::_tc_FullInterfaceDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, CORBA_InterfaceDef::FullInterfaceDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      CORBA_InterfaceDef::_tc_FullInterfaceDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      CORBA_InterfaceDef::FullInterfaceDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_InterfaceDef::FullInterfaceDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const CORBA_InterfaceDef::FullInterfaceDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA_InterfaceDef::FullInterfaceDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA_InterfaceDef::_tc_FullInterfaceDescription ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const CORBA_InterfaceDef::FullInterfaceDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      CORBA_InterfaceDef::FullInterfaceDescription *tmp;
      ACE_NEW_RETURN (tmp, CORBA_InterfaceDef::FullInterfaceDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA_InterfaceDef::_tc_FullInterfaceDescription,
            1,
            ACE_static_cast (void *, tmp),
            CORBA_InterfaceDef::FullInterfaceDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const CORBA_InterfaceDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_InterfaceDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, CORBA_InterfaceDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_InterfaceDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      CORBA_InterfaceDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_InterfaceDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const CORBA_InterfaceDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA_InterfaceDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_InterfaceDescription ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const CORBA_InterfaceDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      CORBA_InterfaceDescription *tmp;
      ACE_NEW_RETURN (tmp, CORBA_InterfaceDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_InterfaceDescription,
            1,
            ACE_static_cast (void *, tmp),
            CORBA_InterfaceDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, CORBA_AbstractInterfaceDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_AbstractInterfaceDef,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        CORBA_AbstractInterfaceDef::_duplicate (_tao_elem),
        CORBA_AbstractInterfaceDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_AbstractInterfaceDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA_AbstractInterfaceDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_AbstractInterfaceDef ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_AbstractInterfaceDef,
          1,
          _tao_elem,
          CORBA_AbstractInterfaceDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA_AbstractInterfaceDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA_AbstractInterfaceDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<CORBA_AbstractInterfaceDef,CORBA_AbstractInterfaceDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<CORBA_AbstractInterfaceDef,CORBA_AbstractInterfaceDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, CORBA_LocalInterfaceDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_LocalInterfaceDef,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        CORBA_LocalInterfaceDef::_duplicate (_tao_elem),
        CORBA_LocalInterfaceDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_LocalInterfaceDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA_LocalInterfaceDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (CORBA::_tc_LocalInterfaceDef ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_LocalInterfaceDef,
          1,
          _tao_elem,
          CORBA_LocalInterfaceDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA_LocalInterfaceDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA_LocalInterfaceDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<CORBA_LocalInterfaceDef,CORBA_LocalInterfaceDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<CORBA_LocalInterfaceDef,CORBA_LocalInterfaceDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_Repository_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_Repository_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      CORBA_Repository::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_ModuleDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_ModuleDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      CORBA_ModuleDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_ConstantDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_ConstantDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      CORBA_ConstantDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_StructDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_StructDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      CORBA_StructDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_UnionDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_UnionDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      CORBA_UnionDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_EnumDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_EnumDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      CORBA_EnumDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_AliasDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_AliasDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      CORBA_AliasDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_NativeDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_NativeDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      CORBA_NativeDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_PrimitiveDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_PrimitiveDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      CORBA_PrimitiveDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_StringDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_StringDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      CORBA_StringDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_WstringDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_WstringDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      CORBA_WstringDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_SequenceDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_SequenceDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      CORBA_SequenceDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_ArrayDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_ArrayDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      CORBA_ArrayDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_ExceptionDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_ExceptionDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      CORBA_ExceptionDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_ExceptionDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_ExceptionDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len)
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_ExcDescriptionSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_ExcDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len)
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_AttributeDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_AttributeDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      CORBA_AttributeDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_ParDescriptionSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_ParDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len)
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_ContextIdSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_ContextIdSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len)
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_OperationDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_OperationDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      CORBA_OperationDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_RepositoryIdSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_RepositoryIdSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len)
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_OpDescriptionSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_OpDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len)
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_AttrDescriptionSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_AttrDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len)
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_InterfaceDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_InterfaceDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      CORBA_InterfaceDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_AbstractInterfaceDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_AbstractInterfaceDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      CORBA_AbstractInterfaceDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_LocalInterfaceDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_LocalInterfaceDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      CORBA_LocalInterfaceDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}
