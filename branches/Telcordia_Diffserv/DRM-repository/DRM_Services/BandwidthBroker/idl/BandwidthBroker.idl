// BandwidthBroker.idl
//The DARPA ARMS Program
// The software supporting this interface
// is governed by Government Purpose Rights
// Contract No: NBCHC030132
// Telcordia Technologies, Inc.
// 1 Technology Drive
// Piscataway, NJ 08854-4157

// Authors: Kirthika Parmeswaran <kirthika@research.telcordia.com>,
//          Balakrishnan Dasarathy <das@research.telcordia.com>,
//	    Murray Conarty <murray.conarty@prismtechnologies.com>,
//          Shree Gadgil <sgadgil@research.telcordia.com>
// Date:   December 4, 2003; modified Feb. 20, 2004; modified March 22, 2004;
//        Modified June 9, 2004

#ifndef _BANDWIDTH_BROKER_IDL_
#define _BANDWIDTH_BROKER_IDL_

#include "CommonDef.idl"
#include "FaultMonitor.idl"

 module mil { module darpa { module arms { module mlrm {
 module BandwidthBroker {

  interface AdmissionControl {

    // This Admission Control interface is the main interface
    // for the Bandwidth Broker for the ARMS program.
    // The operations supported include:
    // flow setup (request), flow delete,  flow modify,
    // bandwidth query between pools/subnets and
    // modify (Change policy on) the bandwidth allocated to various service classes
    // The flow setup can be done in two operations reserve and commit
    // or as one operation reserve with commit
     
    // Note: All bandwidth/rates are in kilo[1000]bits/seconds

    // This exception is raised when the admission control fails
    exception AdmissionControlException
    {
      string reason;
    };
        
    // This Bandwidth Broker version supports four service classes:
    // highPriority, highReliability and  multimedia voice.
    // (mmVoice) and multimedia Video (mmVideo).
      
    // The highPriorty is mapped to Expedited Forwarding (EF) class 
    // It has the highest priority. 
    // Use this for communication among the DRM entities 
    // and for application data that has high priority/importance or low latency
    // The HighReliability (but with less bandwidth requirements) 
    // and   mmVoice and mmVideo(both with high throughput but        
    // with less reliablity requirements) classes 
    // are eventually mapped to AF classes. 
    // The AF classes has less priority than the EF class. 
    // The HighReliability class, as the name suggests, should be used 
    // for flows, such as TCP, that should avoid dropping packets 
    // mmVoice and mmVideo are two classes that support udp based 
    // multimedia traffic.
    // While there is no difference the way these two classes are treated in the core
    // network, on the edge router we have different burst size provisioning
    // to account for cbr and vbr charateristics of voice and video traffic.
    // mmVoice and mmVideo traffic classes are tolerant to some packet loss
    // bestEffort class cannot be used for provisioning purposes.
    // Any traffic that is not admitted by the Bandwidth Broker is by bestEffort!
    // The bestEffort and raw class has been is included here as a possible 
    // class for query purposes only

    // raw class is used for query of physical bandwidth
  
    // Protocol supported for flows 
    enum BBProtocolType
    {
      _tcp,
      _udp,
      _sctp,
      _notSpecified // not relevant or applicable or can be deduced 
    };

    // Bandwidth requested for a flow
    struct BandwidthRate
    {
      // necessary bandwidth
      long requiredBW;
      // If available, allocate this over-budget bandwidth
      long extraBW; 
    };

    // Bandwidth allocation policy; each policy has a different
    // percentage bandwidth allocation to different service classes
    // appropriate for different operations (environmental conditions
    // load and network resource availability)
    
    enum BandwidthPolicy
    {
      policy1, 
      policy2
    };
  

    // Flow specific information for bi-directional flows
    // srcIP : source IP Address
    // The source and destination IP address fields 
    // are used to specify both the IP address and the subnet mask.
    // (See commonDef.idl)
    // If the subnet mask is a valid subnet mask
    // the allocation request is for the entire subnet
    // If the subnet mask is a blank  string or 255.255.255.255,
    // the allocation is for the host denoted by the IP address.
    // srcPort : source port (or range of ports)
    // destIP : destination IP Address
    // destPort : destination port (range of ports )
    // protocol : flow transport
    // fwdRate : flow rate for source-destination flow
    // revRate : flow rate for destination-source flow
    // flowType: uni-directional or bi-directional flow
    // biDirectional: when true, flow is bi-directional else uni-directional
    // flowDuration : flow period
    struct FlowInfo
    {
      CommonDef::IPAddress srcIP;
      CommonDef::PortInfo srcPort;
      CommonDef::IPAddress destIP;  
      CommonDef::PortInfo destPort;
      BBProtocolType protocol;
      BandwidthRate fwdRate;
      BandwidthRate revRate;
      boolean biDirectional;
      long flowDuration;
    };
    
    // Available bandwidth per service class
    struct BWPerQoS
    {
      BandwidthRate availableBW;
      CommonDef::QOSRequired qos;
    };
    typedef sequence <BWPerQoS> BWPerQoSSeq;

    // Percentage of total available bandwidth per service class
    struct BWPercentPerQoS
    {
      CommonDef::QOSRequired qos;
      short bwPercent;
    };
    typedef sequence <BWPercentPerQoS> BWPercentPerQoSSeq;

    struct BWBetnPools 
    {
      // source pool name 
      string srcPoolName;
      // destination pool name
      string destPoolName;
      // This is the target bandwidth per service class between
      // different pools 
      BWPerQoSSeq bwPerClassSeq;
    };
    typedef sequence <BWBetnPools>  BWBetnPoolsSeq;

    struct BWBetnSubnets 
    {
      // source subnet
      CommonDef::IPAddress srcSubnet;
      // destination subnet 
      CommonDef::IPAddress destSubnet;
      // This is the target bandwidth per service class
      BWPerQoSSeq bwPerClassSeq;
    };
    typedef sequence <BWBetnSubnets>  BWBetnSubnetsSeq;

    typedef sequence <string> l3InterfaceSeq;

    // Outcome obtained on admission control requests
    enum AdmissionControlResult
    {
      DECISION_ADMIT, 
      DECISION_DENY, 
      DECISION_REV_DENY, 
      DUPLICATE_REQ,
      NOFLOWID, 
      BADDATA, 
      DECISION_ERROR,
      REQ_DROP,
      MODIFY,
      DECISION_DELETE
    };

    // SchedulingAction : Used to distinguish between simply analyzing
    // and reserving the bandwidth and actually allocating it on the network
    enum SchedulingAction
    {
      reserve,
      reserve_and_commit
    };
    
    // New flow request
    // Input arguments are:
    // flowInfo : flow specific data
    // qos : QoS properties required for the flow
    // schAction : Distinguishes scheduling of flow; whether to simply
    //             reserve the flow or to allocate it on the network
    // Output Argument: flowToken, a  string uniquely identifying this
    //                  FlowInfo allocation. Only a single flowToken
    //                  is needed even for bi-directional flows. 
    //                  dscp: dscp value returned by BB should be used
    //                  by the applications to mark the packets belonging
    //                  to the flow.
    // Return message could be one of the following

    // DECISION_ADMIT, DECISION_DENY, DECISION_REV_DENY, 
    // DUPLICATE_REQ, NOFLOWID, BADDATA, ERROR or 
    // REQ_DROP
    AdmissionControlResult flowRequest (in FlowInfo theFlowInfo,  
					in CommonDef::QOSRequired qos, 
					in SchedulingAction schAction,
					out string flowToken,
                                        out long dscp)
      raises (AdmissionControlException); 
    // Similar operation as the one above.
    // Add one more parameter for fault tolerance
    
    AdmissionControlResult flowRequest_ft (in FlowInfo theFlowInfo,  
					in CommonDef::QOSRequired qos, 
					in SchedulingAction schAction,
					out string flowToken,
                                        out long dscp,
					in string reference)
      raises (AdmissionControlException); 
   
    
    AdmissionControlResult flowRequest_ext (in FlowInfo theFlowInfo,  
					in CommonDef::QOSRequired qos, 
					in SchedulingAction schAction,
					out string flowToken,
                                        out long dscp,
					in long priority,
					in string reference)
      raises (AdmissionControlException); 
   
    // Operation to commit the request with the flow token identifying
    // the original request
    AdmissionControlResult flowRequestCommit (in string flowToken)  
      raises (AdmissionControlException); 
    
    // For deleting an application flow
    // Input parameter:
    // flowToken: flowToken that identifies the flow/s that are to be
    //            deleted (for bi-directional case, both forward and
    //            reverse flows will be deleted based on the same token)
    // Return value is a message with one of the following responses:
    // NOFLOWID, BADDATA, ERROR on error else DELETE 
    AdmissionControlResult flowDelete (in string flowToken) 
        raises (AdmissionControlException);   

    // Flow Update 
    // Input parameters are:
    // flowToken : flowToken that identifies the flow that is to be updated    
    // oldFlowInfo : Orginal flow request information for validation
    //               purposes
    // newFlowInfo : Flow information for updation
    // oldQoS : Original QoS properties required for validation
    //          purposes
    // newQoS : QoS properties for updation
    // Return message could be one of the following:
    // DECISION_ADMIT, DECISION_DENY, DECISION_REV_DENY, 
    // DUPLICATE_REQ,
    // NOFLOWID, BADDATA, ERROR or REQ_DROP
    AdmissionControlResult unidirectionalFlowUpdate (in string flowToken,
						     in long oldfwdRate,
						     in long newfwdRate)
      raises (AdmissionControlException);

    AdmissionControlResult bidirectionalFlowUpdate (in string flowToken,    
						    in long oldfwdRate,
						    in long newfwdRate,
						    in long revRate,
						    in long newRevRate)
      raises (AdmissionControlException);

    AdmissionControlResult flowQosUpdate (in string flowToken,
					  in CommonDef::QOSRequired oldQos,
					  in CommonDef::QOSRequired newQos)
      raises (AdmissionControlException);


    // Query for actual allocated bandwidth for a flow based on the
    // flow token.  The forward and reverse bandwidth rates are
    // returned. 

    AdmissionControlResult allocatedFlowBandwidthQuery (in string flowToken,
							out long  fwdBW,
							out long  revBW)
       raises (AdmissionControlException);


    // QueryType: Used to distinguish, if the query is for available bandwidth
    // or provisioned bandwidth
    enum BWQueryType
    {
       provisioned,
       available
    };
    
    // Query for available bandwidth between subnets. 
    // Target bandwidth required between the
    // source and destination subnets can be specified.
    // This method returns the
    // target bandwidth (unchanged)  per service class, if it can be met 
    // If it cannot be met, or if input target value specified is zero for a service class,
    // the bandwidth returned is the remaining bandwidth divided equally among all
    // flows exercising the same path/subpath. 
    // Currently, service classes supported are expedited forwardinghihgPriority, and 
    // HighReliablity and HighThroughputmmVoice and mmVideo Assured Forwarding classes

    // The operation supports taking in a whole series of source and destination subnets, 
    // so that Bandwidth Broker can determine atomically 
     // whether such allocation is possible 
    // among the pairs of subnets, taking into account the fact that paths/subpaths may be 
    // shared by the traffic between subnet pairs. 
    // At the end of the operation, no bandwidth is reserved 
    // or committed. So, if a sequence of  these operations is issued, the 
    // Bandwidth Broker treats each request as a new one

    // This query can also be used to find physical bandwidth or provisioned
    // bandwidth for a specified class. type parameter should be set to 
    // provsioned
    
    AdmissionControlResult subnetbandwidthQuery (inout BWBetnSubnetsSeq
						    subnetBandwidthInfo,
						 in BWQueryType type)
      raises (AdmissionControlException);


    // Query for available bandwidth between pools. 
    // Target bandwidth required between the
    // source and destination pools can be specified.
    // This method returns the
    // target bandwidth (unchanged)  per service class, if it can be met 
    // If it cannot be met, or if input target value specified is zero for a service class,
    // the bandwidth returned is the remaining bandwidth divided equally among all
    // flows exercising the same path/subpath. 
    // Currently, service classes supported are highPriority,  
    // HighReliablity and mmVoice and mmVideo.

    // The operation supports taking in a whole series of source and destination pools, 
    // so that Bandwidth Broker can determine atomically 
     // whether such allocation is possible 
    // among the pairs of pools, taking into account the fact that paths/subpaths may be 
    // shared by the traffic between pool pairs. 
    // At the end of the operation, no bandwidth is reserved 
    // or committed. So, if a sequence of  these operations is issued, the 
    // Bandwidth Broker treats each request as a new one

    AdmissionControlResult poolbandwidthQuery (inout BWBetnPoolsSeq
					         poolBandwidthInfo,
					       in BWQueryType type)
      raises (AdmissionControlException);
    


    
    // Policy action used by the Infrastructure Allocator to change
    // the allocation of  bandwidth to various service classes This will result 
    // in switches and routers to be
    // reconfigured during operation.
    // As such, ensure care  
    // before  invoking this operation. 
    // The total percentage should be less than hundred. 
    // No need to specify Best Effort class or its bandwidth %
    
    AdmissionControlResult allocateBandwidthPercentPerQoS ( in
							    BWPercentPerQoSSeq bwPercentageSeq)
      raises (AdmissionControlException);

    AdmissionControlResult changeBandwidthAllocationPolicyTo (in BandwidthPolicy bwPolicy)
	raises (AdmissionControlException);
    
    // This call is for DO NOT HARM test 
    // The Bandwidth Broker will release all the flows that are currently
    // admitted and allow the processes to use the network as it is in
    // bestEffort mode.
    AdmissionControlResult standby () raises (AdmissionControlException); 
   
    AdmissionControlResult resume () raises (AdmissionControlException); 

    AdmissionControlResult processNetworkEvent (in FaultMonitor::NetworkFault f);
    AdmissionControlResult processL3NetworkEvent (in l3InterfaceSeq l3i) 
                                          raises (AdmissionControlException); 

  }; // end of module AdmissionControl
    
 }; // end of module BandwidthBroker   

 }; }; }; };
#endif // _BANDWIDTH_BROKER_IDL_
