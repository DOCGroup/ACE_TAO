// $Id$

#include "BE_Workspace_Generator.h"
#include "Project_Generator.h"
#include "Dependency_Generator.h"
#include "boost/bind.hpp"
#include <algorithm>
#include <sstream>

const std::string WORKSPACE_SUFFIX ("_CUTS");
const std::string CUTS_TESTING_SERVICE ("cuts_testing_service");

//
// CUTS_BE_Workspace_Generator
//
CUTS_BE_Workspace_Generator::
CUTS_BE_Workspace_Generator (const std::string & outdir,
                             CUTS_BE_Project_Generator * project)
: outdir_ (outdir),
  project_ (project),
  coworker_ (false)
{
  this->project_->init (this->outdir_,
                        &this->graph_);
}

//
// ~CUTS_BE_Workspace_Generator
//
CUTS_BE_Workspace_Generator::~CUTS_BE_Workspace_Generator (void)
{

}

//
// Visit_RootFolder
//
void CUTS_BE_Workspace_Generator::
Visit_RootFolder (const PICML::RootFolder & root)
{
  // Construct the filename for the workspace and open it for
  // writing.
  std::ostringstream filename;
  filename << this->outdir_ << "\\" << root.name () << "_CUTS.mwc";

  this->workspace_.open (filename.str ().c_str ());

  if (this->workspace_.is_open ())
  {
    this->workspace_
      << "// This workspace file was generated by" << std::endl
      << "// $Id$"
      << std::endl
      << std::endl
      << "workspace (" << root.name () << WORKSPACE_SUFFIX << ") {" << std::endl

      // Specify where to locate base projects for this workspace.
      << "  // -- Initialize the includes for the project." << std::endl
      << "  cmdline += -include $CUTS_ROOT/etc/config" << std::endl
      << std::endl
      << "  // -- Explicitly specify which components(s) to build"
      << std::endl;

    // Create the dependency graph for this project.
    CUTS_Dependency_Generator depends (this->graph_);
    PICML::RootFolder (root).Accept (depends);

    // Visit the component implemenation folders.
    typedef std::vector <PICML::ComponentImplementations> Folder_Set;
    Folder_Set folders = root.ComponentImplementations_children ();

    std::for_each (folders.begin (),
                   folders.end (),
                   boost::bind (&Folder_Set::value_type::Accept,
                                _1,
                                boost::ref (*this)));

    this->workspace_ 
      << std::endl
      << "  // -- stub projects" << std::endl;

    std::for_each (
      this->graph_.graph ().begin (),
      this->graph_.graph ().end (),
      boost::bind (&CUTS_BE_Workspace_Generator::write_stub_project,
                   this,
                   boost::bind (&CUTS_Dependency_Graph::Dependency_Graph::
                                value_type::second,
                                _1)));
                                
    this->workspace_ << "}" << std::endl;
    this->workspace_.close ();
  }

  // Reset the <workspace_> flags if necessary.
  if (!this->workspace_.good ())
    this->workspace_.clear ();
}

//
// Visit_ComponentImplementations
//
void CUTS_BE_Workspace_Generator::
Visit_ComponentImplementations (const PICML::ComponentImplementations & folder)
{
  // Visit all the component implementation containers.
  typedef std::vector <PICML::ComponentImplementationContainer> Container_Set;
  Container_Set containers = folder.ComponentImplementationContainer_children ();

  std::for_each (containers.begin (),
                 containers.end (),
                 boost::bind (&Container_Set::value_type::Accept,
                              _1,
                              boost::ref (*this)));
}

//
// Visit_ComponentImplementationContainer
//
void CUTS_BE_Workspace_Generator::
Visit_ComponentImplementationContainer (
const PICML::ComponentImplementationContainer & container)
{
  typedef std::vector <PICML::MonolithicImplementation> Impl_Set;
  Impl_Set monos = container.MonolithicImplementation_kind_children ();

  // Make sure we have the flag in the "off" state.
  this->coworker_ = false;

  for (Impl_Set::iterator iter = monos.begin ();
       iter != monos.end ();
       iter ++)
  {
    // Since we only care about CoWorkEr components, we should
    // verify that this is a CoWorkEr implementation before
    // continuing. Eventually we would want to abstract this
    // out so that we can do non-CoWorkEr components as well.
    iter->Accept (*this);
    if (!this->coworker_)
      continue;

    // Turn off the flag since we have made it this far.
    this->coworker_ = false;

    // Construct the MPC filename.
    std::string project = container.name ();
    project.append (".mpc");

    // Write the project to the workspace.
    std::ostringstream pathname;
    pathname << this->outdir_ << "\\" << project;
    this->workspace_ << "  " << project << std::endl;

    // Pass control to the project generator, if applicable.
    if (this->project_.get () != 0)
    {
      PICML::ComponentImplementationContainer (container).
      Accept (*this->project_.get ());
    }
  }
}

//
// Visit_MonolithicImplementation
//
void CUTS_BE_Workspace_Generator::
Visit_MonolithicImplementation (const PICML::MonolithicImplementation & mono)
{
  // Get the <Implements> connection from the model.
  PICML::Implements implements = mono.dstImplements ();
  if (implements == Udm::null)
    return;

  // Get the <ComponentRef> that we are attached to so that we
  // can visit the component.
  PICML::ComponentRef ref = implements.dstImplements_end ();
  PICML::Component component = ref.ref ();
  if (component == Udm::null)
    return;

  component.Accept (*this);
}

//
// Visit_Component
//
void CUTS_BE_Workspace_Generator::
Visit_Component (const PICML::Component & component)
{
  typedef std::vector <PICML::RequiredRequestPort> Receptacle_Set;
  Receptacle_Set facets = component.RequiredRequestPort_kind_children ();

  // We need to locate the facet with the name "cuts_testing_service".
  // So, let's iterate over all the facets and look for one with the
  // name "cuts_testing_service".
  for (Receptacle_Set::iterator iter = facets.begin ();
       iter != facets.end ();
       iter ++)
  {
    if ((std::string) iter->name () == CUTS_TESTING_SERVICE)
    {
      this->coworker_ = true;
      return;
    }
  }
}

//
// write_stub_project
//
void CUTS_BE_Workspace_Generator::
write_stub_project (CUTS_Dependency_Node * node)
{
  if ((node->flags_ & CUTS_Dependency_Node::DNF_STUB))
    this->write_stub_project_i (node);
}

//
// write_stub_project
//
void CUTS_BE_Workspace_Generator::
write_stub_project_i (CUTS_Dependency_Node * node)
{
  // We should only visit a node once.
  if ((node->flags_ & CUTS_Dependency_Node::DNF_VISITED) != 0)
    return;

  node->flags_ |= CUTS_Dependency_Node::DNF_VISITED;

  if (this->project_.get () != 0)
  {
    // Write the stub project and add it to the listing of 
    // project files if we are successful.
    if (this->project_->write_stub_project (node))
      this->workspace_ << "  " << node->name () << "_stub.mpc" << std::endl;
  }

  std::for_each (node->references_.begin (),
                 node->references_.end (),
                 boost::bind (&CUTS_BE_Workspace_Generator::write_stub_project_i,
                              this,
                              _1));
}
