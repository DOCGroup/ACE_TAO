// $Id$

#include "CIAO_Project_Generator.h"
#include "Export_File_Generator.h"
#include "Header_File_Generator.h"
#include "Source_File_Generator.h"
#include "cuts/be/Dependency_Graph.h"
#include "boost/bind.hpp"
#include "Uml.h"

#include <algorithm>
#include <fstream>
#include <sstream>

#define EXEC_SUFFIX       "_exec"
#define SVNT_SUFFIX       "_svnt"
#define STUB_SUFFIX       "_stub"

#define CLIENT_SUFFIX     "C"
#define SERVER_SUFFIX     "S"

//
// CUTS_CIAO_Project_Generator
//
CUTS_CIAO_Project_Generator::CUTS_CIAO_Project_Generator (void)
{
  this->manager_.insert (new CUTS_CIAO_Header_File_Generator ());
  this->manager_.insert (new CUTS_CIAO_Source_File_Generator ());
}

//
// ~CUTS_CIAO_Project_Generator
//
CUTS_CIAO_Project_Generator::~CUTS_CIAO_Project_Generator (void)
{

}

//
// write_project
//
void CUTS_CIAO_Project_Generator::
write_project (const PICML::ComponentImplementationContainer & container,
               const CUTS_BE_Preprocess_Data & ppd)
{
  // Let's locate the node of the file that contains the component
  // we are implementing.
  typedef std::vector <PICML::MonolithicImplementation> Mono_Set;
  Mono_Set monos = container.MonolithicImplementation_kind_children ();

  PICML::Implements implements = monos.begin ()->dstImplements ();
  PICML::ComponentRef ref = implements.dstImplements_end ();
  PICML::Component component = ref.ref ();

  PICML::MgaObject parent = component.parent ();
  while ((std::string)parent.type ().name () !=
         (std::string)PICML::File::meta.name ())
  {
    parent = PICML::MgaObject::Cast (parent.parent ());
  }

  CUTS_Dependency_Node * node = 0;
  this->graph_->find_node (parent.name (), node);

  if (node != 0)
  {
    // Open the project file for writing.
    std::ostringstream filename;
    filename << this->outdir_ << "\\" << container.name () << ".mpc";

    std::ofstream outfile;
    outfile.open (filename.str ().c_str ());

    if (!outfile.is_open ())
      return;
    
    // Write the preamble for the project file. We need to add
    // a more detailed one in the near future.
    outfile
      << "// This project file was generated by" << std::endl
      << "// $Id$"
      << std::endl
      << std::endl;

    this->write_exec_project (outfile, container, node, ppd);
    this->write_svnt_project (outfile, container, node);
    outfile.close ();
  }
}

//
// write_exec_project
//
void CUTS_CIAO_Project_Generator::
write_exec_project (std::ofstream & project,
                    const PICML::ComponentImplementationContainer & container,
                    CUTS_Dependency_Node * node,
                    const CUTS_BE_Preprocess_Data & ppd)
{
  // Generate the export file for the project.
  std::string project_name = container.name ();
  project_name.append (EXEC_SUFFIX);

  CUTS_Export_File_Generator efg (project_name);
  efg.generate (this->outdir_);

  // Construct the name of the servant project.
  std::string svnt_project = container.name ();
  svnt_project.append (SVNT_SUFFIX);

  // Generate the executor project.
  project
    << "project (" << project_name << ") : cuts_coworker_exec {"
    << std::endl
    << "  sharedname = " << project_name << std::endl
    << std::endl
    << "  dynamicflags = " << efg.build_flag () << std::endl
    << std::endl
    << "  after += " << svnt_project << std::endl
    << std::endl

    // Generate the import libraries for the project.
    << "  libs  += " << svnt_project;

  // Generate the STUB import libraries for this node.
  this->generate_stub_listing (project, node);
  
  node->flags_ &= ~CUTS_Dependency_Node::DNF_VISITED;
  this->graph_->reset_visit_flag ();

  // Generate the remaining MPC stuff for this project.
  project
    << std::endl
    << std::endl
    << "  // implementation specific settings" << std::endl;
  this->generate_mpc_i (project, ppd);

  project
    << std::endl
    << std::endl

    // Generate the source files.
    << "  Source_Files {" << std::endl
    << "    " << project_name << "_i.cpp" << std::endl
    << "  }" << std::endl
    << std::endl

    // Generate the header files.
    << "  Header_Files {" << std::endl
    << std::endl
    << "  }" << std::endl
    << std::endl
    << "  Inline_Files {" << std::endl
    << std::endl
    << "  }" << std::endl
    << std::endl
    << "  IDL_Files {" << std::endl
    << std::endl
    << "  }" << std::endl
    << "}" << std::endl
    << std::endl;
}

//
// write_svnt_project
//
void CUTS_CIAO_Project_Generator::
write_svnt_project (std::ofstream & project,
                    const PICML::ComponentImplementationContainer & container,
                    CUTS_Dependency_Node * node)
{
  // Generate the export file for the project.
  std::string project_name = container.name ();
  project_name.append (SVNT_SUFFIX);

  CUTS_Export_File_Generator efg (project_name);
  efg.generate (this->outdir_);

  // Generate the project, keeping in mind the export file.
  project
    << "project (" << project_name << ") : cuts_coworker_svnt {" << std::endl
    << "  sharedname = " << project_name << std::endl
    << std::endl
    << "  dynamicflags = " << efg.build_flag () << std::endl
    << std::endl

    // Generate the IDL flag definitions.
    << "  idlflags += -Wb,export_macro=" << efg.export_macro ()
    << " \\" << std::endl
    << "              -Wb,export_include=" << efg.export_file ()
    << std::endl
    << std::endl;

  // Generate the STUB dependencies for this node.
  if (!node->references_.empty ())
  {
    project << "  after +=";

    this->generate_stub_listing (project, node);
    this->graph_->reset_visit_flag ();

    project << std::endl << std::endl;
  }

  // Generate the STUB import libraries for this node.
  if (!node->references_.empty ())
  {
    project << "  libs +=";

    this->generate_stub_listing (project, node);
    this->graph_->reset_visit_flag ();

    project << std::endl << std::endl;
  }

  project
    // Generate the CIDL files
    << "  CIDL_Files {" << std::endl
    << "    " << container.name () << ".cidl" << std::endl
    << "  }" << std::endl
    << std::endl

    // Generate the IDL files
    << "  IDL_Files {" << std::endl
    << "    " << container.name () << "E.idl" << std::endl
    << "  }" << std::endl
    << std::endl

    // Generate the source files
    << "  Source_Files {" << std::endl
    << "    " << container.name () << "EC.cpp" << std::endl
    << "    " << project_name << ".cpp" << std::endl
    << "  }" << std::endl
    << std::endl

    // Generate the header files
    << "  Header_Files {" << std::endl
    << std::endl
    << "  }" << std::endl
    << "}" << std::endl
    << std::endl;
}

//
// generate_stub_listing
//
void CUTS_CIAO_Project_Generator::
generate_stub_listing (std::ofstream & project,
                       CUTS_Dependency_Node * node)
{
  if ((node->flags_ & CUTS_Dependency_Node::DNF_VISITED) != 0)
    return;

  // Keep this node from being visited more than once, then
  // generate the STUB import libraries.
  node->flags_ |= CUTS_Dependency_Node::DNF_VISITED;

  project
    << " \\" << std::endl
    << "    " << node->basename () << STUB_SUFFIX;

  std::for_each (
    node->references_.begin (),
    node->references_.end (),
    boost::bind (&CUTS_CIAO_Project_Generator::generate_stub_listing,
                 this,
                 boost::ref (project),
                 _1));
}

//
// generate_mpc_values
//
void CUTS_CIAO_Project_Generator::
generate_mpc_values (std::ofstream & project,
                     const std::string & heading,
                     const CUTS_String_Set & listing)
{
  if (listing.empty ())
    return;

  project << "  " << heading << " +=";

  for (CUTS_String_Set::const_iterator iter = listing.begin ();
       iter != listing.end ();
       iter ++)
  {
    project
      << " \\" << std::endl
      << "    " << iter->c_str ();
  }
}

//
// genereate_mpc_i
//
void CUTS_CIAO_Project_Generator::
generate_mpc_i (std::ofstream & project,
                const CUTS_BE_Preprocess_Data & ppd)
{
  this->generate_mpc_values (project, "includes", ppd.includes ());
  this->generate_mpc_values (project, "libpaths", ppd.libpaths ());
  this->generate_mpc_values (project, "libs", ppd.libs ());
}

//
// write_stub_project
//
bool CUTS_CIAO_Project_Generator::
write_stub_project (CUTS_Dependency_Node * node)
{
  // Construct the name of the project. We use _Base as the
  // name decorator in hopes of not overwriting an existing
  // file.
  std::string project_name = node->name ();
  project_name.append ("_stub");

  std::string project_file = project_name;
  project_file.append (".mpc");

  std::ostringstream pathname;
  pathname
    << this->outdir_ << "\\" << project_file << std::ends;

  std::ofstream project;
  project.open (pathname.str ().c_str ());

  if (!project.is_open ())
    return false;

  // Write the preamble for the project file. We need to add
  // a more detailed one in the near future.
  project
    << "// This project file was generated by" << std::endl
    << "// $Id$"
    << std::endl
    << std::endl;

  // Generate the export file for the project.
  std::string name = node->basename ();
  name.append (STUB_SUFFIX);

  CUTS_Export_File_Generator efg (name);
  efg.generate (this->outdir_);

  // Generate the project.
  project
    << "project (" << node->basename () << STUB_SUFFIX << ") : "
    << "cuts_coworker_stub {" << std::endl
    << "  sharedname = "
    << node->basename () << STUB_SUFFIX << std::endl
    << std::endl

    // Generate the dynamic flags.
    << "  dynamicflags = " << efg.build_flag () << std::endl
    << std::endl

    // Generate the IDL flag definitions.
    << "  idlflags += -Wb,export_macro="
    << efg.export_macro () << " \\" << std::endl
    << "              -Wb,export_include="
    << efg.export_file () << std::endl;

  if (!node->references_.empty ())
  {
    // Generate the dependencies for this project. This will be
    // all the client projects of the references for this node.
    project
      << std::endl << "  after +=";

    CUTS_Reference_Set::const_iterator iter;

    for (iter  = node->references_.begin ();
         iter != node->references_.end ();
         iter ++)
    {
      project
        << " \\" << std::endl
        << "    " << (*iter)->basename () << STUB_SUFFIX;
    }

    // Generate the import libraries for this project. This will be
    // all client project of the references for this node. The will
    // also be the same as those specified in the "after" tag.
    project
      << std::endl
      << std::endl << "  libs +=";

    for (iter  = node->references_.begin ();
         iter != node->references_.end ();
         iter ++)
    {
      project
        << " \\" << std::endl
        << "    " << (*iter)->basename () << STUB_SUFFIX;
    }

    project << std::endl;
  }

  project
    << std::endl
    // Generate the IDL files for this project.
    << "  IDL_Files {" << std::endl
    << "    " << node->basename () << ".idl" << std::endl
    << "  }" << std::endl
    << std::endl

    // Generate the source files for this project.
    << "  Source_Files {" << std::endl
    << "    " << node->basename () << SERVER_SUFFIX << ".cpp" << std::endl
    << "    " << node->basename () << CLIENT_SUFFIX << ".cpp" << std::endl
    << "  }" << std::endl
    << std::endl
    // Generate the header files for this project.
    << "  Header_Files {" << std::endl
    << std::endl
    << "  }" << std::endl
    << "}" << std::endl
    << std::endl;

  // Close the project and add it to the workspace.
  project.close ();
  return project.good ();
}
