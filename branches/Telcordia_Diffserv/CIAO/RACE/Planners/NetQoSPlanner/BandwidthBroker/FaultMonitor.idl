//$Id$
// FaultMonitor.idl
// The software supporting this interface
// is governed by Government Purpose Rights
// Contract No: NBCHC030132
// Telcordia Technologies, Inc.
// 1 Telcordia Drive
// Piscataway, NJ 08854-4157

// Author: Ravi Vaidyanathan <vravi@research.telcordia.com>
// Date: 03 Jun 2005

// This IDL will serve as an interface to register for and 
// receive network fault events or query network/switch status

#ifndef _FAULT_MONITOR_IDL_
#define _FAULT_MONITOR_IDL_

#include "CommonDef.idl"

module mil { module darpa { module arms { module mlrm {
module BandwidthBroker {

 interface FaultMonitor
 {
  
    // This exception is raised on failure
    exception FaultMonitorException
    {
      string reason;
    };

     
    typedef string switchName;
    typedef string switchPortName;

    enum switchStatus {
	OPERATIONAL,
	BACKUP, // in backup operation - e.g. redundant supervisor
	FAIL
    };

    enum portStatus {
	UP,
	DOWN
    };

    enum portType {
	PHYSICAL,
	VLAN,
	IP_INTERFACE,
	OTHER
    };

    enum NEeventType {
	NULL_EVENT,
	portUP,
	portDOWN,
        portFLAP,
	switchUP,
	switchDOWN,
	ALL_DOWN,	// All down events, port & switch 
	ALL_UP,		// All up events, port & switch
	ALL 
     };	

    struct portInfo {
	switchPortName portName;
        portStatus adminStatus;
	portStatus operStatus;
	portType type;
	NEeventType event;
    };

    typedef sequence <switchName> switchNameSeq;
    typedef sequence <portInfo> portInfoSeq;

    struct switchInfo {
	switchName name;
	switchStatus status;
	portInfoSeq ports;
    };

    typedef switchInfo NetworkFault;
    typedef sequence <switchInfo> switchInfoSeq;

  


   // The methods in this IDL are implicitly used to control monitoring
   // as follows: 
   // 
   // 1. Sychronous getSwitchStatus: queries the current network status if
   //     the device is not being monitored, if it is currently being monitored,
   //     then this method returns the current known status from the DB.
   // 
   // 2. Asychronous subscribeToFaultEvent: if no monitoring exists for this
   //     switch, then monitoring is initiated for this switch/set of switches.
   // 
   // 3. Asynchronous unsubscribeToFaultEvent: if the no. of eventSinks 
   //	  interested in fault events on this switch is 0, then terminate 
   //	  monitoring for this switch.



   //------Synchronous method to obtain switch/port status ------------//
   // Currently the IDL returns the status of the entire switch
   // with all of the associated ports
   // This could be enhanced to query individual ports, if desired

   void getSwitchStatus(in switchName name,
		      out switchInfo info)
     raises (FaultMonitorException);


   //----Asynchronous event subscriptions/registrations and unsubscriptions ----//

   // Subscribe a component for a fault monitor event 
   // Typically, this constitues link/port or switch UP/DOWN
   // transitions. Currently the granularity of subscriptions is 
   // at the switch level 
   void subscribeToFaultEvent (in string eventSinkName,
				in string cookie, 
				in switchNameSeq switches,
				in NEeventType type) 
     raises (FaultMonitorException);

   // Unsubscribe a component for fault monitor events
   void unsubscribeToFaultEvent (in string eventSinkName,
				in string cookie)
     raises (FaultMonitorException);

 }; // end FaultMonitor interface

}; // end module 

 }; }; }; };
#endif // _FAULT_MONITOR_IDL_
