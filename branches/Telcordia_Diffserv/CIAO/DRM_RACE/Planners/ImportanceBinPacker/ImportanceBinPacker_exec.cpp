// ImportanceBinPacker_exec.cpp,v 1.1 2005/09/06 19:57:22 tdamaino Exp
//
// ****              Code generated by the                 ****
// ****  Component Integrated ACE ORB (CIAO) CIDL Compiler ****
// CIAO has been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// CIDL Compiler has been developed by:
//       Institute for Software Integrated Systems
//       Vanderbilt University
//       Nashville, TN
//       USA
//       http://www.isis.vanderbilt.edu/
//
// Information about CIAO is available at:
//    http://www.dre.vanderbilt.edu/CIAO

#include "ace/Mutex.h"
#include "ace/Condition_Thread_Mutex.h"
#include "ace/Bound_Ptr.h"
#include "ace/Null_Mutex.h"
#include <string>
#include <sstream>
#include <vector>

#include "ImportanceBinPacker_exec.h"
#include "ImportanceBinPacker.h"

namespace CIAO
{
  namespace RACE
  {
    namespace CIDL_ImportanceBinPacker_Impl
    {
      //==================================================================
      // Facet Executor Implementation Class:   Planner_I_exec_i
      //==================================================================

      Planner_I_exec_i::Planner_I_exec_i (ImportanceBinPacker_exec_i &exec)
        : exec_ (exec)
      {
      }

      Planner_I_exec_i::~Planner_I_exec_i (void)
      {
      }

      // Structure for node joins.
      struct NodeJoin
      {
        const ::CIAO::RACE::Planner_I::Domain_Changes & changes_;
        char ** joined_nodes_;
        double ** joined_node_capacities_;

        NodeJoin(const ::CIAO::RACE::Planner_I::Domain_Changes & changes)
          :
          changes_(changes),
          joined_nodes_ (0),
          joined_node_capacities_ (0)
        {}

        ~NodeJoin()
        {
          if (joined_nodes_) {
            for (char** p = joined_nodes_; *p != 0; ++p) {
              delete [] (*p);
            }
            delete [] joined_nodes_;
          }

          if (joined_node_capacities_) {
            for (double ** p = joined_node_capacities_; *p != 0; ++p) {
              delete (*p);
            }
            delete [] joined_node_capacities_;
          }
        }
      };

      // Helper function to look for LoadAverage setting
      void LoadAverage(::Deployment::SatisfierProperties & properties, double & capacity)
      {
        for (::CORBA::ULong i = 0, l = properties.length(); i < l; ++i)
        {
          if (properties[i].name.in() != 0 &&
              ACE_OS::strcmp (properties[i].name.in(), "LoadAverage") == 0 &&
              properties[i].kind == ::Deployment::Maximum)
          {
            ::CORBA::Any & capacityAny = properties[i].value;
            ::CORBA::TypeCode_var tcv = capacityAny.type();
            ::CORBA::TCKind       tck = tcv->kind();
            if (tck == ::CORBA::tk_long) {
              ::CORBA::Long capacityLong;
              capacityAny >>= capacityLong;
              capacity = (double) capacityLong;
              break;
            }
          }
        }
      }

      // Helper function to look for a CPULoad setting
      bool CPULoad (::CORBA::StringSeq & resourceTypes)
      {
        for (::CORBA::ULong i = 0, l = resourceTypes.length(); i < l; ++i)
        {
          ::CORBA::String_var resourceType =
              CORBA::string_dup(resourceTypes[i]);

          if (resourceType.in() != 0 &&
              ACE_OS::strcmp (resourceType.in(), "CPULoad") == 0)
          {
            return true;
          }
        }
        return false;
      }

      // Helper function to look for a Processor setting
      void Processor (::Deployment::Resources resources, double & capacity)
      {
        for (::CORBA::ULong i = 0, l = resources.length(); i < l; ++i)
        {
          if (resources[i].name.in() != 0 &&
              ACE_OS::strcmp (resources[i].name.in(), "Processor") == 0)
          {
            if (CPULoad(resources[i].resourceType)) {
              LoadAverage(resources[i].property, capacity);
            }
          }
        }
      }

      // Operations from ::CIAO::RACE::Planner_I

      ::CORBA::Boolean Planner_I_exec_i::process_plan (
          ::CIAO::RACE::Plan_Actions & function_input_output
          ACE_ENV_ARG_DECL_NOT_USED
        )
        ACE_THROW_SPEC ((
          ::CORBA::SystemException,
          ::CIAO::RACE::PlannerFailure
        ))
      {
        this->initialize_domain();

        // Get Ready to call the Importance Bin Packer
        const Plan_Seq & ibp_input  = function_input_output;
        Plan_Seq ibp_output(0);
        ibp_output.length(0);

        // Call the importance Bin Packer
        bool ret_val = this->exec_.ibp_->convert_input(ibp_input, ibp_output);

        // Make the inout variable equal to the output from the
        // Importance Bin Packer
        function_input_output = ibp_output;

        // Return the retval from Importance Bin Packer.
        return ret_val;
      }

      ::CORBA::Boolean Planner_I_exec_i::process_domain_change (
          const ::CIAO::RACE::Planner_I::Domain_Changes & changes,
          ::CIAO::RACE::Plan_Actions_out function_output
          ACE_ENV_ARG_DECL_NOT_USED
        )
        ACE_THROW_SPEC ((
          ::CORBA::SystemException,
          ::CIAO::RACE::PlannerFailure
        ))
      {
        for (CORBA::ULong i = 0; i < changes.length ();i++)
          {
            ACE_DEBUG(( LM_DEBUG, "ImportancePlanner::DomainChange - Host [%s] %s.\n",
                changes[i].hostname.in(),
                (changes[i].change == ::CIAO::RACE::Planner_I::NODE_JOINED)?"recovered":"lost"
                    ));
          }

        NodeJoin node_join_struct (changes);

        this->initialize_domain(& node_join_struct);

        // Get ready to call the Importance Bin Packer.
        Plan_Seq::_var_type ibp_output (new Plan_Seq(0));
        ibp_output->length(0);

        // Call the Importance Bin Packer.
        bool ret_val = this->exec_.ibp_->domain_change
          (changes,
           node_join_struct.joined_nodes_,
           node_join_struct.joined_node_capacities_,
           ibp_output.inout());

        if (ibp_output->length() == 0)
        {
           ACE_DEBUG(( LM_DEBUG, 
               "ImportancePlanner::DomainChange - No managed plans affected by domain changes.\n"
                          ));
        }

        // Make the out variable equal to the output from the Importance
        // Bin Packer.
        function_output = ibp_output._retn();

        // Return the retval from Importance Bin Packer.
        return ret_val;
      }

      char *
      Planner_I_exec_i::name (
      ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
      ACE_THROW_SPEC ((CORBA::SystemException))
      {
        return this->exec_.name ();
      }

      void
      Planner_I_exec_i::initialize_domain (
          NodeJoin * node_join
          ACE_ENV_SINGLE_ARG_DECL
      )
      ACE_THROW_SPEC ((
        ::CORBA::SystemException,
        ::CIAO::RACE::PlannerFailure
      ))
      {
        if (this->exec_.ibp_ == 0 || node_join != 0)
        {
          // Obtain Domain from the Target Manager
          ::Deployment::Domain_var domain;
          ::Deployment::TargetManager_var tgt_mgr;

          ACE_TRY {
            tgt_mgr = exec_.context_->get_connection_target_mgr ();
          } ACE_CATCHANY {
            ACE_ERROR ((LM_ERROR,
                        "Planner_I_exec_i::initialize_domain: "
                        "Caught exception from get_connection_target_mgr: %s\n",
                        ACE_ANY_EXCEPTION._info().fast_rep()));
            ACE_RE_THROW;
          } ACE_CATCHALL {
            const char * message = "Planner_I_exec_i::initialize_domain: "
              "Caught unknown exception from get_connection_target_mgr\n";
            ACE_ERROR ((LM_ERROR, message));
            ACE_THROW (PlannerFailure());
          } ACE_ENDTRY;

          ACE_TRY {
            tgt_mgr->getAvailableResources();
          } ACE_CATCHANY {
            ACE_ERROR ((LM_ERROR,
                        "Planner_I_exec_i::initialize_domain: "
                        "Caught exception from tgt_mgr->getAvailableResources() (1st invoc): %s\n",
                        ACE_ANY_EXCEPTION._info().fast_rep()));
            ACE_RE_THROW;
          } ACE_CATCHALL {
            const char * message = "Planner_I_exec_i::initialize_domain: "
              "Caught unknown exception from tgt_mgr->getAvailableResources() (1st invoc)\n";
            ACE_ERROR ((LM_ERROR, message));
            ACE_THROW (PlannerFailure());
          } ACE_ENDTRY;

          ACE_TRY {
            domain = tgt_mgr->getAvailableResources ();
          } ACE_CATCHANY {
            ACE_ERROR ((LM_ERROR,
                        "Planner_I_exec_i::initialize_domain: "
                        "Caught exception from tgt_mgr->getAvailableResources() (2nd invoc): %s\n",
                        ACE_ANY_EXCEPTION._info().fast_rep()));
            ACE_RE_THROW;
          } ACE_CATCHALL {
            const char * message = "Planner_I_exec_i::initialize_domain: "
              "Caught unknown exception from tgt_mgr->getAvailableResources() (2nd invoc)\n";
            ACE_ERROR ((LM_ERROR, message));
            ACE_THROW (PlannerFailure());
          } ACE_ENDTRY;

          tgt_mgr->getAvailableResources ();

          // Get the Nodes from the Domain.
          ::Deployment::Nodes &nodes = domain->node;
          CORBA::ULong i = 0;
          CORBA::ULong l = nodes.length();

          // Create null-terminated arrays of node names and
          // capacities.
          char ** nodeNames = new char*[l+1];
          nodeNames[l] = 0;
          double ** nodeCapacities = new double*[l+1];
          nodeCapacities[l] = 0;
          for (; i < l; ++i) {
            const char * nodeName = nodes[i].name.in();
            if (nodeName) {
              nodeNames[i] = new char [ACE_OS::strlen(nodeName) + 1];
              ACE_OS::strcpy (nodeNames[i], nodeName);
            } else {
              std::ostringstream out;
              out << "node" << i;
              const std::string & outs = out.str();
              nodeNames[i] = new char [outs.size() + 1];
              ACE_OS::strcpy (nodeNames[i], outs.c_str());
            }

            // Hard-code the node capacity to be 100
            nodeCapacities[i] = new double (100.0);

            // See if there is a different, capacity specified by
            // "CPULoad" in the node model.
            ::Deployment::Resources & resources = nodes[i].resource;
            Processor(resources, *(nodeCapacities[i]));
          }

          // Logic for initializing the ImportanceBinPacker
          // implementation.
          if (this->exec_.ibp_ == 0) {

            // Initialize the Importance Bin Packer
            this->exec_.ibp_ = new ::ImportanceBinPacker (nodeNames, nodeCapacities);

          }

          // Alternative logic for returning joined-node information
          // in the NodeJoin struct.
          else {
            ACE_ASSERT (node_join != 0);
            int joined_node_counter = 0;
            node_join->joined_nodes_ = new char*[l+1];
            node_join->joined_node_capacities_ = new double*[l+1];
            char ** cp = nodeNames;
            double ** dp = nodeCapacities;
            for (;
                 (*cp) != 0 && (*dp) != 0;
                 ++cp, ++dp)
            {
              for (CORBA::ULong change_counter = 0;
                   change_counter < node_join->changes_.length();
                   ++change_counter)
              {
                const ::CIAO::RACE::Planner_I::Domain_Change & change =
                  node_join->changes_[change_counter];
                if (ACE_OS::strcmp (change.hostname.in(), *cp) == 0 &&
                    change.change == ::CIAO::RACE::Planner_I::NODE_JOINED)
                {
                  node_join->joined_nodes_[joined_node_counter] =
                    new char[ACE_OS::strlen(*cp) + 1];
                  ACE_OS::strcpy (node_join->joined_nodes_[joined_node_counter],
                                  *cp);
                  node_join->joined_node_capacities_[joined_node_counter] =
                    new double (**dp);
                  ++joined_node_counter;
                }
              }
            }
            node_join->joined_nodes_[joined_node_counter] = 0;
            node_join->joined_node_capacities_[joined_node_counter] = 0;
          }

          // Delete stuff
          for (i = 0; i < l; ++i) {
            delete [] nodeNames[i];
            delete    nodeCapacities[i];
          }
          delete [] nodeNames;
          delete [] nodeCapacities;
        }
      }

      //==================================================================
      // Component Executor Implementation Class:   ImportanceBinPacker_exec_i
      //==================================================================

      ImportanceBinPacker_exec_i::ImportanceBinPacker_exec_i (void)
        : ibp_(0)
      {
      }

      ImportanceBinPacker_exec_i::~ImportanceBinPacker_exec_i (void)
      {
        delete ibp_;
      }

      // Supported or inherited operations.

      // Attribute operations.

      char *
      ImportanceBinPacker_exec_i::name (
      ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
      ACE_THROW_SPEC ((CORBA::SystemException))
      {
        ACE_DEBUG ((LM_DEBUG, "ImportanceBinPacker_exec_i::name()\n"));
        return CORBA::string_dup ("ImportancePlanner");
      }

      void
      ImportanceBinPacker_exec_i::name (
      const char * /* name */
      ACE_ENV_ARG_DECL_NOT_USED)
      ACE_THROW_SPEC ((CORBA::SystemException))
      {
        // Your code here.
      }

      char *
      ImportanceBinPacker_exec_i::type (
      ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
      ACE_THROW_SPEC ((CORBA::SystemException))
      {
        ACE_DEBUG ((LM_DEBUG, "ImportanceBinPacker_exec_i::type()\n"));
        return CORBA::string_dup ("Component Allocation Planner");
      }

      void
      ImportanceBinPacker_exec_i::type (
      const char * /* type */
      ACE_ENV_ARG_DECL_NOT_USED)
      ACE_THROW_SPEC ((CORBA::SystemException))
      {
        // Your code here.
      }

      // Port operations.

      ::CIAO::RACE::CCM_Planner_I_ptr
      ImportanceBinPacker_exec_i::get_planner_i (
      ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
      ACE_THROW_SPEC ((CORBA::SystemException))
      {
        // Your code here.
        return new Planner_I_exec_i (*this);
      }

      // Operations from Components::SessionComponent

      void
      ImportanceBinPacker_exec_i::set_session_context (
      ::Components::SessionContext_ptr ctx
      ACE_ENV_ARG_DECL)
      ACE_THROW_SPEC ((
      ::CORBA::SystemException,
      ::Components::CCMException))
      {
        this->context_ =
        ImportanceBinPacker_Context::_narrow (
        ctx
        ACE_ENV_ARG_PARAMETER);
        ACE_CHECK;

        if (this->context_ == 0)
        {
          ACE_THROW (CORBA::INTERNAL ());
        }
      }

      void
      ImportanceBinPacker_exec_i::ciao_preactivate (
      ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
      ACE_THROW_SPEC ((
      ::CORBA::SystemException,
      ::Components::CCMException))
      {
        // Your code here.
      }

      void
      ImportanceBinPacker_exec_i::ciao_postactivate (
      ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
      ACE_THROW_SPEC ((
      ::CORBA::SystemException,
      ::Components::CCMException))
      {
        // Your code here.
      }

      void
      ImportanceBinPacker_exec_i::ccm_activate (
      ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
      ACE_THROW_SPEC ((
      ::CORBA::SystemException,
      ::Components::CCMException))
      {
        // Your code here.
      }

      void
      ImportanceBinPacker_exec_i::ccm_passivate (
      ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
      ACE_THROW_SPEC ((
      ::CORBA::SystemException,
      ::Components::CCMException))
      {
        // Your code here.
      }

      void
      ImportanceBinPacker_exec_i::ccm_remove (
      ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
      ACE_THROW_SPEC ((
      ::CORBA::SystemException,
      ::Components::CCMException))
      {
        // Your code here.
      }

      //==================================================================
      // Home Executor Implementation Class:   ImportanceBinPacker_Home_exec_i
      //==================================================================

      ImportanceBinPacker_Home_exec_i::ImportanceBinPacker_Home_exec_i (void)
      {
      }

      ImportanceBinPacker_Home_exec_i::~ImportanceBinPacker_Home_exec_i (void)
      {
      }

      // Supported or inherited operations.

      // Home operations.

      // Factory and finder operations.

      // Attribute operations.

      // Implicit operations.

      ::Components::EnterpriseComponent_ptr
      ImportanceBinPacker_Home_exec_i::create (
      ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((
      ::CORBA::SystemException,
      ::Components::CCMException))
      {
        ::Components::EnterpriseComponent_ptr retval =
        ::Components::EnterpriseComponent::_nil ();

        ACE_NEW_THROW_EX (
        retval,
        ImportanceBinPacker_exec_i,
        CORBA::NO_MEMORY ());
        ACE_CHECK_RETURN (::Components::EnterpriseComponent::_nil ());

        return retval;
      }

      extern "C" IMPORTANCEBINPACKER_EXEC_Export ::Components::HomeExecutorBase_ptr
      create_CIAO_RACE_ImportanceBinPacker_Home_Impl (void)
      {
        ::Components::HomeExecutorBase_ptr retval =
        ::Components::HomeExecutorBase::_nil ();

        ACE_NEW_RETURN (
        retval,
        ImportanceBinPacker_Home_exec_i,
        ::Components::HomeExecutorBase::_nil ());

        return retval;
      }
    }
  }
}
