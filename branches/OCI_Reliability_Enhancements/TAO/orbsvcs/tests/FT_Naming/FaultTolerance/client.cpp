// $Id$

// ============================================================================
//
// = DESCRIPTION
//      This class implements a CORBA client for a redundant CosNaming
//      Service using stubs generated by the TAO ORB IDL compiler.
//
// = AUTHORS
//      Rich Seibel <seibel_r@ociweb.com>
// ============================================================================

#include "test_objectS.h"
#include "orbsvcs/CosNamingC.h"
#include "orbsvcs/FT_NamingManagerC.h"
#include "orbsvcs/Naming/Naming_Server.h"
#include "tao/debug.h"
#include "ace/Get_Opt.h"
#include "ace/OS_NS_stdio.h"
#include "utils/nsgroup/nsgroup_svc.h"

#if defined (_MSC_VER)
# pragma warning (disable : 4250)
#endif /* _MSC_VER */

class My_Test_Object :
  public virtual POA_Test_Object
{
public:
  // = Initialization and termination methods.
  My_Test_Object (CORBA::Short id = 0);
  // Constructor.

  ~My_Test_Object (void);
  // Destructor.

  // = Interface implementation accessor methods.

  void id (CORBA::Short id);
  // Sets id.

  CORBA::Short id (void);
  // Gets id.

private:
  short id_;
};

My_Test_Object::My_Test_Object (CORBA::Short id)
  : id_ (id)
{
}

My_Test_Object::~My_Test_Object (void)
{
}

CORBA::Short
My_Test_Object::id (void)
{
  return id_;
}

void
My_Test_Object::id (CORBA::Short id)
{
  id_ = id;
}

// This function runs the test.
int do_name_test (CORBA::ORB_ptr theOrb, 
             ACE_TCHAR *ns1ref, 
             ACE_TCHAR *ns2ref,
             int c_breadth,
             int c_depth,
             int o_breadth);

// This function runs the test.
int do_object_group_test ( CORBA::ORB_ptr theOrb, 
                           ACE_TCHAR *nm1ref, 
                           ACE_TCHAR *nm2ref);

#if 0
int
group_create (FT_Naming::NamingManager_ptr theManager, const char* group_name, const char* type_id );
#endif


int
ACE_TMAIN(int argc, ACE_TCHAR *argv[])
{
  int rc = 0;
  int c_breadth = 4;
  int c_depth = 4;
  int o_breadth = 4;

  ACE_TCHAR *ns1ref = 0;
  ACE_TCHAR *ns2ref = 0;
  
  ACE_TCHAR *nm1ref = 0;
  ACE_TCHAR *nm2ref = 0;

  typedef enum {
    TT_FAILOVER,
    TT_PERSISTENCE,
    TT_EQUIVALENCE
  } fault_tolerent_test;

  fault_tolerent_test test_type = TT_FAILOVER;

  //////////////////////////////////////////////////////////////////////////////
  // optional
  //////////////////////////////////////////////////////////////////////////////
  // -b <breadth of context tree>
  // -d <depth of context tree>
  // -o <breadth of object tree>
  //////////////////////////////////////////////////////////////////////////////
  // required
  //////////////////////////////////////////////////////////////////////////////
  // -p <ior of first name server>
  // -q <ior of second name server>
  // -r <ior of first naming service>
  // -s <ior of second naming service>
  // --failover run fault tolerant failover test
  // --persistence run fault tolerant persistence test
  // --equivalence run fault tolerant equivalence test

  ACE_Get_Opt get_opts (argc, argv, ACE_TEXT ("b:d:o:p:q:r:s:"));
  int c;
  int i;
  get_opts.long_option ("failover", ACE_Get_Opt::NO_ARG);
  get_opts.long_option ("persistence", ACE_Get_Opt::NO_ARG);
  get_opts.long_option ("equivalence", ACE_Get_Opt::NO_ARG);


  while ((c = get_opts ()) != -1)
    switch (c)
      {
      case 'b':
        i = ACE_OS::atoi(get_opts.opt_arg ());
        if (i<2)
        {
          ACE_ERROR((LM_ERROR,
                     ACE_TEXT ("Invalid breadth, must be 2 or more\n")));
          ACE_OS::exit(1);
        }
        c_breadth = i;
        break;
      case 'd':
        i = ACE_OS::atoi(get_opts.opt_arg ());
        if (i<2)
        {
          ACE_ERROR((LM_ERROR,
                     ACE_TEXT ("Invalid depth, must be 2 or more\n")));
          ACE_OS::exit(1);
        }
        c_depth = i;
        break;
      case 'o':
        i = ACE_OS::atoi(get_opts.opt_arg ());
        if (i<2)
        {
          ACE_ERROR((LM_ERROR,
                     ACE_TEXT ("Invalid breadth, must be 2 or more\n")));
          ACE_OS::exit(1);
        }
        o_breadth = i;
        break;
      case 'p':
        ns1ref = get_opts.opt_arg ();
        break;
      case 'q':
        ns2ref = get_opts.opt_arg ();
        break;
      case 'r':
        nm1ref = get_opts.opt_arg ();
        break;
      case 's':
        nm2ref = get_opts.opt_arg ();
        break;
      case 0:   // A long option was found
        {
          const char* long_option = get_opts.long_option ();
          if (ACE_OS::strcmp (long_option, "failover") == 0)
            {
              ACE_DEBUG ((LM_DEBUG, ACE_TEXT ("Failover test Selected\n")));
              test_type = TT_FAILOVER;
            }
          else if (ACE_OS::strcmp (long_option, "persistence") == 0)
            {
              ACE_DEBUG ((LM_DEBUG, ACE_TEXT ("Persistence test Selected\n")));
              test_type = TT_PERSISTENCE;
            }
          else if (ACE_OS::strcmp (long_option, "equivalence") == 0)
            {
              ACE_DEBUG ((LM_DEBUG, ACE_TEXT ("Equivalence test Selected\n")));
              test_type = TT_EQUIVALENCE;
            }
        }
        break;

      default:
        ACE_ERROR_RETURN ((LM_ERROR,
                           ACE_TEXT ("Argument %c \n usage:  %s")
                           ACE_TEXT (" [-b <breadth of context tree>]")
                           ACE_TEXT (" [-d <depth of context tree>]")
                           ACE_TEXT (" [-o <breadth of object tree>]")
                           ACE_TEXT (" -p <ior of first name server>")
                           ACE_TEXT (" -q <ior of second name server>")
                           ACE_TEXT (" -r <ior of first naming server>")
                           ACE_TEXT (" -s <ior of second naming server>")
                           ACE_TEXT ("\n")),
                          -1);
      }


  try
  {
    // Initialize orb
    CORBA::ORB_var orb = CORBA::ORB_init(argc, argv);

    switch(test_type) {
      case TT_FAILOVER:
        ACE_DEBUG ((LM_DEBUG, ACE_TEXT ("Failover test OK\n")));
        rc = do_name_test(
          orb.in (),
          ns1ref,
          ns2ref,
          c_breadth,
          c_depth,
          o_breadth
        );
        do_object_group_test(
          orb.in (),
          nm1ref,
          nm2ref
        );
      break;
      case TT_PERSISTENCE:
        ACE_DEBUG ((LM_DEBUG, ACE_TEXT ("Persistence test OK\n")));
        rc = do_name_test(
          orb.in (),
          ns1ref,
          ns2ref,
          c_breadth,
          c_depth,
          o_breadth
        );
        do_object_group_test(
          orb.in (),
          nm1ref,
          nm2ref
        );
      break;
      case TT_EQUIVALENCE:
        ACE_DEBUG ((LM_DEBUG, ACE_TEXT ("Equivalence test OK\n")));
        rc = do_name_test(
          orb.in (),
          ns1ref,
          ns2ref,
          c_breadth,
          c_depth,
          o_breadth
        );
        do_object_group_test(
          orb.in (),
          nm1ref,
          nm2ref
        );
      break;
    }
  }
  catch (const CORBA::Exception& ex)
  {
    ex._tao_print_exception (ACE_TEXT ("Unable to resolve name servers"));
    return -1;
  }


  return rc;

}

////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////
int do_name_test (
             CORBA::ORB_ptr theOrb, 
             ACE_TCHAR *ns1ref, 
             ACE_TCHAR *ns2ref,
             int c_breadth,
             int c_depth,
             int o_breadth)
{

  CosNaming::NamingContext_var root_context_1;
  CosNaming::NamingContext_var root_context_2;
  int i;

  try {
    
    if (CORBA::is_nil (theOrb)) 
      ACE_ERROR_RETURN ((LM_ERROR,ACE_TEXT ("invalid orb\n")),-1);
    
    if (CORBA::is_nil (ns1ref)) 
      ACE_ERROR_RETURN ((LM_ERROR,ACE_TEXT ("invalid ns1\n")),-1);

    if (CORBA::is_nil (ns2ref)) 
      ACE_ERROR_RETURN ((LM_ERROR,ACE_TEXT ("invalid ns2\n")),-1);

    CORBA::ORB_var orb = theOrb;
    CORBA::Object_var ns1obj = orb->string_to_object (ACE_TEXT_ALWAYS_CHAR (ns1ref));
    CORBA::Object_var ns2obj = orb->string_to_object (ACE_TEXT_ALWAYS_CHAR (ns2ref));

    if (CORBA::is_nil (ns1obj.in ())) 
      ACE_ERROR_RETURN ((LM_ERROR,ACE_TEXT ("invalid ior <%s>\n"),ns1ref),-1);
    if (CORBA::is_nil (ns2obj.in ())) 
      ACE_ERROR_RETURN ((LM_ERROR,ACE_TEXT ("invalid ior <%s>\n"),ns2ref),-1);

    root_context_1 = CosNaming::NamingContext::_narrow (ns1obj.in ());
    root_context_2 = CosNaming::NamingContext::_narrow (ns2obj.in ());

    if (CORBA::is_nil (root_context_1.in ())) 
      ACE_ERROR_RETURN ((LM_ERROR,ACE_TEXT ("invalid ior <%s>\n"),ns1ref),-1);
    if (CORBA::is_nil (root_context_2.in ())) 
      ACE_ERROR_RETURN ((LM_ERROR,ACE_TEXT ("invalid ior <%s>\n"),ns2ref),-1);
  }
  catch (const CORBA::Exception& ex)
  {
    ex._tao_print_exception (ACE_TEXT ("Unable to resolve name servers"));
    return -1;
  }

  // Create a bunch of objects in one context
  // Note: strings to the naming service must be char, not wchar
  try
  {
    // Bind one context level under root.
    CosNaming::Name level1;
    level1.length (1);
    level1[0].id = CORBA::string_dup ("level1_context");
    CosNaming::NamingContext_var level1_context;
    level1_context = root_context_1->bind_new_context (level1);

    for (i=0; i<o_breadth; i++)
    {
      // Instantiate a dummy object and bind it under the new context.
      My_Test_Object *impl1 = new My_Test_Object (i+1);
      Test_Object_var obj1 = impl1->_this ();
      impl1->_remove_ref ();

      level1.length (2);
      char wide_name[16];
      ACE_OS::sprintf(wide_name, "obj_%d", i);
      level1[1].id = CORBA::string_dup (wide_name);
      root_context_1->bind (level1, obj1.in ());

      // See if the newly bound object is available in the
      // replica
      try {
        CORBA::Object_var obj1_on_replica = root_context_2->resolve (level1);
      }
      catch (const CosNaming::NamingContext::NotFound& ex)
        {
          ex._tao_print_exception ("Unable to resolve object from replica.\n");

          // Try again...
          try {
            CORBA::Object_var obj1_on_replica = root_context_2->resolve (level1);
            // We did find the object on the replica, but only after a wait.
            // This would be caused by a race condition to access the variable.
            ACE_ERROR ((LM_ERROR, "Object appeared after a short wait.\n"));
          }
          catch (const CosNaming::NamingContext::NotFound& second_ex)
            {
              ex._tao_print_exception ("It really is not there. Failing...\n");
              return -1;
            }
        }
    }
  }
  catch (const CORBA::Exception& ex)
  {
    ex._tao_print_exception (ACE_TEXT ("Unable to create a lot of objects"));
    return -1;
  }

  // Create a deep context tree
  try
  {
    CosNaming::NamingContext_var next_context = root_context_1;
    for (i=0; i<c_depth; i++)
    {
      // Bind level1 context under root.
      CosNaming::Name deep;
      deep.length (1);
      char deep_name[16];
      ACE_OS::sprintf(deep_name, "deep_%d", i);
      deep[0].id = CORBA::string_dup (deep_name);
      CosNaming::NamingContext_var deep_context;
      deep_context = next_context->bind_new_context (deep);
      next_context = deep_context;
    }
  }
  catch (const CORBA::Exception& ex)
  {
    ex._tao_print_exception (ACE_TEXT ("Unable to create deep context"));
    return -1;
  }

  // Create a wide context tree
  try
  {
    for (i=0; i<c_breadth; i++)
    {
      // Bind all level of context under root.
      CosNaming::Name wide;
      wide.length (1);
      char wide_name[16];
      ACE_OS::sprintf(wide_name, "wide_%d", i);
      wide[0].id = CORBA::string_dup (wide_name);
      CosNaming::NamingContext_var wide_context;
      wide_context = root_context_1->bind_new_context (wide);

      try {
        // Check if the new context is available in the replica
        CORBA::Object_var obj1_on_replica = root_context_2->resolve (wide);
        // Make sure it is a context
        CosNaming::NamingContext_var nc = CosNaming::NamingContext::_narrow (obj1_on_replica);
      }
      catch (const CosNaming::NamingContext::NotFound& ex)
        {
          ex._tao_print_exception ("Unable to resolve wide context object from replica.\n");

          // Try again to see if it just was a race condition
          try {
            CORBA::Object_var obj1_on_replica = root_context_2->resolve (wide);
            // We did find the object on the replica, but only after a wait.
            // This would be caused by a race condition to access the variable.
            ACE_ERROR ((LM_ERROR, "Object appeared after a short wait.\n"));
          }
          catch (const CosNaming::NamingContext::NotFound& second_ex)
            {
              ex._tao_print_exception ("It really is not there. Failing...\n");
              return -1;
            }
        }
    }
  }
  catch (const CORBA::Exception& ex)
  {
    ex._tao_print_exception (ACE_TEXT ("Unable to create wide context"));
    return -1;
  }

  // Delete three selected things, one from each tree
  try {
    // Remove the second to last object from the Naming Context
    CosNaming::Name wide1;
    wide1.length (2);
    wide1[0].id = CORBA::string_dup ("level1_context");
    char wide_name[16];
    ACE_OS::sprintf(wide_name, "obj_%d", o_breadth-2);
    wide1[1].id = CORBA::string_dup (wide_name);
    root_context_1->unbind (wide1);

    bool retried = false;
    // Make sure it is gone from the replica
    try {
      CORBA::Object_var obj1_on_replica = root_context_2->resolve (wide1);

      // An exception should be thrown by the above or
      // there is an error. This means the replica did
      // not register the loss of the context.
      ACE_ERROR ((LM_ERROR, "Unbound deep context not removed from replica. Trying again...\n"));
      retried = true;  // Mark this so it can be reported in catch block.
      obj1_on_replica = root_context_2->resolve (wide1);
      ACE_ERROR_RETURN ((LM_ERROR, "Unbound context not removed from on retry\n"), -1);
    }
    catch (const CosNaming::NamingContext::NotFound& ex)
      {
        // Not on replica --- as it should be.
        if (retried)  // Was found on the retry
          ACE_ERROR ((LM_ERROR, "Was removed after short wait.\n"));
      }

    // Remove the second to last context from the wide root Naming Context
    CosNaming::Name wide2;
    wide2.length (1);
    ACE_OS::sprintf(wide_name, "wide_%d", c_breadth-2);
    wide2[0].id = CORBA::string_dup (wide_name);
    CORBA::Object_var result_obj_ref = root_context_1->resolve (wide2);
    CosNaming::NamingContext_var result_object = CosNaming::NamingContext::_narrow (result_obj_ref.in ());
    if (CORBA::is_nil (result_object.in ()))
      ACE_ERROR_RETURN ((LM_ERROR, ACE_TEXT ("Problems with resolving wide context ") ACE_TEXT ("- nil object ref.\n")), -1);
    result_object->destroy();
    root_context_1->unbind (wide2);

    // Remove the last context from the deep Naming Context
    CosNaming::Name deep;
    deep.length (c_depth);
    char deep_name[16];
    for (i=0; i<c_depth; i++)
    {
      ACE_OS::sprintf(deep_name, "deep_%d", i);
      deep[i].id = CORBA::string_dup (deep_name);
    }
    result_obj_ref = root_context_1->resolve (deep);
    result_object = CosNaming::NamingContext::_narrow (result_obj_ref.in ());
    if (CORBA::is_nil (result_object.in ()))
      ACE_ERROR_RETURN ((LM_ERROR, ACE_TEXT ("Problems with resolving deep context ") ACE_TEXT ("- nil object ref.\n")), -1);
    result_object->destroy();
    root_context_1->unbind (deep);

    retried = false;
    // Make sure it is gone from the replica
    try {
      CORBA::Object_var obj1_on_replica = root_context_2->resolve (deep);

      // An exception should be thrown by the above or
      // there is an error. This means the replica did
      // not register the loss of the context.
      ACE_ERROR ((LM_ERROR, "Unbound deep context not removed from replica. Trying again...\n"));
      retried = true;  // Mark this so it can be reported in catch block.
      obj1_on_replica = root_context_2->resolve (deep);
      ACE_ERROR_RETURN ((LM_ERROR, "Unbound context not removed from on retry\n"), -1);
    }
    catch (const CosNaming::NamingContext::NotFound& ex)
      {
        // Not on replica --- as it should be.
        if (retried)  // Was found on the retry
          ACE_ERROR ((LM_ERROR, "Was removed after short wait.\n"));
      }
  }
  catch (const CORBA::Exception& ex)
  {
    ex._tao_print_exception (ACE_TEXT ("Unable to delete objects"));
    return -1;
  }

  // Now use the other name server to access 3 objects next to the
  // deleted objects and the 3 deleted objects
  try
  {
    // Access the last object from the Naming Context
    CosNaming::Name wide;
    wide.length (2);
    wide[0].id = CORBA::string_dup ("level1_context");
    char wide_name[16];
    ACE_OS::sprintf(wide_name, "obj_%d", o_breadth-1);
    wide[1].id = CORBA::string_dup (wide_name);
    CORBA::Object_var result_obj_ref = root_context_2->resolve (wide);
    Test_Object_var result_object = Test_Object::_narrow (result_obj_ref.in ());
    if (CORBA::is_nil (result_object.in ()))
      ACE_ERROR_RETURN ((LM_ERROR,
                         ACE_TEXT ("Problems with resolving object from ")
                         ACE_TEXT ("redundant server - nil object ref.\n")),
                         -1);
  }
  catch (const CORBA::Exception& ex)
  {
    ex._tao_print_exception ( ACE_TEXT ( "Unable to resolve object from redundant server"));
    return -1;
  }

  try
  {
    // Access the deleted second to last object from the Naming Context
    CosNaming::Name wide;
    wide.length (2);
    wide[0].id = CORBA::string_dup ("level1_context");
    char wide_name[16];
    ACE_OS::sprintf(wide_name, "obj_%d", o_breadth-2);
    wide[1].id = CORBA::string_dup (wide_name);
    CORBA::Object_var result_obj_ref = root_context_2->resolve (wide);
    ACE_ERROR_RETURN ((LM_ERROR,
                    ACE_TEXT ("Problems with resolving object from ")
                    ACE_TEXT ("redundant server - deleted object found.\n")),
                    -1);
  }
  catch (const CosNaming::NamingContext::NotFound& ex)
  {
    // expect exception since the context was deleted.
    // Make sure the right exception reason is provided.
    if (ex.why != CosNaming::NamingContext::missing_node)
      ACE_ERROR_RETURN ((LM_ERROR, ACE_TEXT ("Wrong exception returned during resolve.\n")), -1);
  }
  catch (const CORBA::Exception& ex)
    {
      ex._tao_print_exception (ACE_TEXT ("Wrong exception type returned from resolve.\n"));
      return -1;
    }

  try
  {
    // Access the last context from the wide Naming Context
    CosNaming::Name wide;
    wide.length (1);
    char wide_name[16];
    ACE_OS::sprintf(wide_name, "wide_%d", c_breadth-1);
    wide[0].id = CORBA::string_dup (wide_name);
    CORBA::Object_var result_obj_ref = root_context_2->resolve (wide);
    CosNaming::NamingContext_var result_object = CosNaming::NamingContext::_narrow (result_obj_ref.in ());
    if (CORBA::is_nil (result_object.in ()))
      ACE_ERROR_RETURN ((LM_ERROR,
                      ACE_TEXT ("Problems with resolving wide context from ")
                      ACE_TEXT ("redundant server - nil object ref.\n")),
                      -1);
  }
  catch (const CosNaming::NamingContext::NotFound&)
    {
      // Expected exception
    }
  catch (const CORBA::Exception& ex)
  {
    ex._tao_print_exception ( ACE_TEXT ("Unexpected Exception received.\n"));
    return -1;
  }

  try
  {
    // Access the deleted second to last object from the Naming Context
    CosNaming::Name wide;
    wide.length (2);
    char wide_name[16];
    ACE_OS::sprintf(wide_name, "wide_%d", c_breadth-2);
    wide[0].id = CORBA::string_dup (wide_name);
    CORBA::Object_var result_obj_ref = root_context_2->resolve (wide);
    ACE_ERROR_RETURN ((LM_ERROR,
                    ACE_TEXT ("Problems with resolving wide context from ")
                    ACE_TEXT ("redundant server - deleted object found.\n")),
                    -1);
  }
  catch (const CosNaming::NamingContext::NotFound&)
    {
      // Expected exception
    }
  catch (const CORBA::Exception& ex)
  {
    ex._tao_print_exception ( ACE_TEXT ("Unexpected Exception received.\n"));
    return -1;
  }

  try
  {
    // Access the deleted last context from the deep Naming Context
    CosNaming::Name deep;
    deep.length (c_depth);
    char deep_name[16];
    for (i=0; i<c_depth; i++)
    {
      ACE_OS::sprintf(deep_name, "deep_%d", i);
      deep[i].id = CORBA::string_dup (deep_name);
    }
    CORBA::Object_var result_obj_ref = root_context_1->resolve (deep);
    ACE_ERROR_RETURN ((LM_ERROR,
                    ACE_TEXT ("Problems with resolving deep context from ")
                    ACE_TEXT ("redundant server - deleted object found.\n")),
                    -1);
  }
  catch (const CosNaming::NamingContext::NotFound&)
    {
      // Expected exception
    }
  catch (const CORBA::Exception& ex)
  {
    ex._tao_print_exception (
             ACE_TEXT ("Unexpected Exception received resolving ")
             ACE_TEXT ("deep cxt from redundant server.\n"));
    return -1;
  }

  try
  {
    // Access the second to last object from the Naming Context
    CosNaming::Name deep;
    deep.length (c_depth-1);
    char deep_name[16];
    for (i=0; i<c_depth-1; i++)
    {
      ACE_OS::sprintf(deep_name, "deep_%d", i);
      deep[i].id = CORBA::string_dup (deep_name);
    }
    CORBA::Object_var result_obj_ref = root_context_1->resolve (deep);
    CosNaming::NamingContext_var result_object = CosNaming::NamingContext::_narrow (result_obj_ref.in ());
    if (CORBA::is_nil (result_object.in ()))
      ACE_ERROR_RETURN ((LM_ERROR,
                      ACE_TEXT ("Problems with resolving deep context from ")
                      ACE_TEXT ("redundant server - nil object ref.\n")),
                      -1);
  }
  catch (const CORBA::Exception& ex)
  {
    ex._tao_print_exception ( ACE_TEXT ( "Unable to resolve deep context from redundant server"));
    return -1;
  }

  return 0;

}

int do_object_group_test ( CORBA::ORB_ptr theOrb, 
                           ACE_TCHAR *nm1ref, 
                           ACE_TCHAR *nm2ref)
{
  int rc = 0;

  FT_Naming::NamingManager_var naming_manager_1;
  FT_Naming::NamingManager_var naming_manager_2;

  try {
    
    if (CORBA::is_nil (theOrb)) 
      ACE_ERROR_RETURN ((LM_ERROR,ACE_TEXT ("invalid orb\n")),-1);
    CORBA::ORB_var orb = theOrb;
    
    if (CORBA::is_nil (nm1ref)) 
      ACE_ERROR_RETURN ((LM_ERROR,ACE_TEXT ("invalid nm1\n")),-1);
    
    ACE_DEBUG ((LM_DEBUG, ACE_TEXT ("nm1ref: %s\n"), nm1ref));
    
    CORBA::Object_var nm1obj = orb->string_to_object (ACE_TEXT_ALWAYS_CHAR (nm1ref));
    if (CORBA::is_nil (nm1obj.in ())) 
      ACE_ERROR_RETURN ((LM_ERROR,ACE_TEXT ("invalid ior <%s>\n"),nm1ref),-1);
    
    naming_manager_1 = FT_Naming::NamingManager::_narrow (nm1obj.in ());
    if (CORBA::is_nil (naming_manager_1.in ())) 
      ACE_ERROR_RETURN ((LM_ERROR,ACE_TEXT ("invalid ior <%s>\n"),nm1ref),-1);
    

    if (!CORBA::is_nil (nm2ref)) {
      ACE_DEBUG ((LM_DEBUG, ACE_TEXT ("nm2ref: %s\n"), nm2ref));
      CORBA::Object_var nm2obj = orb->string_to_object (ACE_TEXT_ALWAYS_CHAR (nm2ref));
      if (CORBA::is_nil (nm2obj.in ())) 
        ACE_ERROR_RETURN ((LM_ERROR,ACE_TEXT ("invalid ior <%s>\n"),nm2ref),-1);
      naming_manager_2 = FT_Naming::NamingManager::_narrow (nm2obj.in ());
    if (CORBA::is_nil (naming_manager_2.in ())) 
        ACE_ERROR_RETURN ((LM_ERROR,ACE_TEXT ("invalid ior <%s>\n"),nm2ref),-1);
    }

    NS_group_svc group_svc;
    
    int rc = group_svc.set_orb (theOrb);    
    if( 0 != rc ) 
    {
      ACE_ERROR_RETURN ((LM_ERROR,ACE_TEXT ("invalid orb\n")),-1);       
    }

    rc = group_svc.set_naming_manager (naming_manager_1);
    if( 0 != rc ) 
    {
      ACE_ERROR_RETURN ((LM_ERROR,ACE_TEXT ("invalid ior <%s>\n"),nm2ref),-1);       
    }

    //group_create (const char* group, const char* type_id, const char* policy);
    rc = group_svc.group_create("test_group","IDL:FT_Naming/NamingManager:1.0", "round");

  }
  catch (const CORBA::Exception& ex)
  {
    ex._tao_print_exception (ACE_TEXT ("Unable to resolve name manager servers"));
    return -1;
  }

  return rc;
}

