 TAO_END_VERSIONED_NAMESPACE_DECL
Index: modules/TAO/tao/operation_details.inl
===================================================================
--- modules/TAO/tao/operation_details.inl	(revision 79294)
+++ modules/TAO/tao/operation_details.inl	(revision 80736)
@@ -20,6 +20,7 @@
     , num_args_ (num)
     , ex_data_ (data)
     , ex_count_ (count)
+//    , compressed_ (false)
     , use_stub_args_ (args ? true : false)
 #if TAO_HAS_INTERCEPTORS == 1
     , ft_expiration_time_ (0)
@@ -234,5 +235,16 @@
   this->reply_dispatcher_ = rd;
 }

+/*ACE_INLINE void
+TAO_Operation_Details::compressed (CORBA::Boolean compressed)
+{
+  this->compressed_ = compressed;
+}

+ACE_INLINE CORBA::Boolean
+TAO_Operation_Details::compressed (void) const
+{
+  return this->compressed_;
+} */
+
 TAO_END_VERSIONED_NAMESPACE_DECL
Index: modules/TAO/tao/GIOP_Message_Base.h
===================================================================
--- modules/TAO/tao/GIOP_Message_Base.h	(revision 79294)
+++ modules/TAO/tao/GIOP_Message_Base.h	(revision 80736)
@@ -64,9 +64,6 @@
   virtual void init (CORBA::Octet major,
                      CORBA::Octet minor);

-  /// Reset the messaging the object
-  virtual void reset (void);
-
   /// Write the RequestHeader in to the @a cdr stream. The underlying
   /// implementation of the mesaging should do the right thing.
   virtual int generate_request_header (TAO_Operation_Details &op,
@@ -177,8 +174,8 @@
                                       TAO_GIOP_Message_Generator_Parser *);

   /// Set the state
-  void set_state (const TAO_GIOP_Message_Version &version,
-                  TAO_GIOP_Message_Generator_Parser *&) const;
+  TAO_GIOP_Message_Generator_Parser *get_parser (
+    const TAO_GIOP_Message_Version &version) const;

   /// Print out a debug messages..
   void dump_msg (const char *label, const u_char *ptr, size_t len);
@@ -186,7 +183,9 @@
   /// Writes the GIOP header in to @a msg
   /// @note If the GIOP header happens to change in the future, we can
   /// push this method in to the generator_parser classes.
-  int write_protocol_header (TAO_GIOP_Message_Type t, TAO_OutputCDR &msg);
+  int write_protocol_header (TAO_GIOP_Message_Type t,
+                             const TAO_GIOP_Message_Version &version,
+                             TAO_OutputCDR &msg);

   /// Make a GIOP_LOCATEREPLY and hand that over to the transport so
   /// that it can be sent over the connection.
Index: modules/TAO/tao/Incoming_Message_Queue.h
===================================================================
--- modules/TAO/tao/Incoming_Message_Queue.h	(revision 79294)
+++ modules/TAO/tao/Incoming_Message_Queue.h	(revision 80736)
@@ -73,6 +73,8 @@

   friend class TAO_Transport;

+  CORBA::Octet compressed_;
+
 private:
   /*!
     \brief A circular linked list of messages awaiting processing.
Index: modules/TAO/tao/Transport.cpp
===================================================================
--- modules/TAO/tao/Transport.cpp	(revision 79294)
+++ modules/TAO/tao/Transport.cpp	(revision 80736)
@@ -23,6 +23,7 @@
 #include "tao/ORB_Core.h"
 #include "tao/MMAP_Allocator.h"
 #include "tao/SystemException.h"
+#include "tao/Operation_Details.h"

 #include "ace/OS_NS_sys_time.h"
 #include "ace/OS_NS_stdio.h"
@@ -424,7 +425,7 @@
     TAO_Target_Specification &spec,
     TAO_OutputCDR &output)
 {
-  // codeset service context is only supposed to be sent in the first request
+  // Codeset service context is only supposed to be sent in the first request
   // on a particular connection.
   if (this->first_request_)
     {
@@ -433,15 +434,31 @@
         csm->generate_service_context (opdetails,*this);
     }

+  // Check whether we have Compression set
+//  if (opdetails.compressed ())
+//    {
+//      TAO_OutputCDR cdr;
+//
+//      // Add the original message length to the service contenxt
+//      CORBA::ULong length = opdetails.uncompressed_size_;
+//      if ((cdr << ACE_OutputCDR::from_boolean (TAO_ENCAP_BYTE_ORDER) == 0)
+//          || (cdr << length) == 0)
+//        return -1;
+//
+//      // Add this info in to the svc_list
+//      opdetails.request_service_context ().set_context (IOP::TAG_ZIOP_COMPONENT,
+//                                                        cdr);
+//    }
+
   if (this->messaging_object ()->generate_request_header (opdetails,
                                                           spec,
                                                           output) == -1)
     {
       if (TAO_debug_level > 0)
         {
-        ACE_DEBUG ((LM_DEBUG,
-                   ACE_TEXT ("(%P|%t) - Transport[%d]::generate_request_header, ")
-                   ACE_TEXT ("error while marshalling the Request header\n"),
+          ACE_ERROR ((LM_ERROR,
+                      ACE_TEXT ("(%P|%t) - Transport[%d]::generate_request_header, ")
+                      ACE_TEXT ("error while marshalling the Request header\n"),
                       this->id()));
         }

@@ -460,8 +477,7 @@
   this->purge_entry ();

   // Then add ourselves to the cache
-  return this->transport_cache_manager ().cache_transport (desc,
-                                                           this);
+  return this->transport_cache_manager ().cache_transport (desc, this);
 }

 int
@@ -490,9 +506,7 @@
 }

 /*
- *
  *  Methods called and used in the output path of the ORB.
- *
  */
 int
 TAO_Transport::handle_output (void)
@@ -1248,8 +1262,6 @@
 TAO_Transport::send_connection_closed_notifications_i (void)
 {
   this->cleanup_queue_i ();
-
-  this->messaging_object ()->reset ();
 }

 int
@@ -1267,13 +1279,11 @@
   switch (message_semantics)
     {
       case TAO_Transport::TAO_TWOWAY_REQUEST:
-        ret = this->send_synchronous_message_i (message_block,
-                                                max_wait_time);
+        ret = this->send_synchronous_message_i (message_block, max_wait_time);
         break;

       case TAO_Transport::TAO_REPLY:
-        ret = this->send_reply_message_i (message_block,
-                                          max_wait_time);
+        ret = this->send_reply_message_i (message_block, max_wait_time);
         break;

       case TAO_Transport::TAO_ONEWAY_REQUEST:
@@ -1831,7 +1841,6 @@
          this->id ()));
     }

-
   // The buffer on the stack which will be used to hold the input
   // messages, ACE_CDR::MAX_ALIGNMENT compensates the
   // memory-alignment. This improves performance with SUN-Java-ORB-1.4
@@ -2190,7 +2199,7 @@

                 }

-              const int retval = this->notify_reactor ();
+              int const retval = this->notify_reactor ();

               if (retval == 1)
                 {
@@ -2209,8 +2218,7 @@
             }

           // PRE: incoming_message_queue is empty
-          if (this->process_parsed_messages (&qd,
-                                             rh) == -1)
+          if (this->process_parsed_messages (&qd, rh) == -1)
             {
               return -1;
             }
Index: modules/TAO/tao/GIOP_Message_Generator_Parser_12.h
===================================================================
--- modules/TAO/tao/GIOP_Message_Generator_Parser_12.h	(revision 79294)
+++ modules/TAO/tao/GIOP_Message_Generator_Parser_12.h	(revision 80736)
@@ -33,7 +33,7 @@
  *
  */

-class TAO_Export TAO_GIOP_Message_Generator_Parser_12:
+class TAO_Export TAO_GIOP_Message_Generator_Parser_12 :
   public TAO_GIOP_Message_Generator_Parser
 {
 public:
@@ -42,29 +42,24 @@
   virtual bool write_request_header (
       const TAO_Operation_Details &opdetails,
       TAO_Target_Specification &spec,
-      TAO_OutputCDR &msg
-    );
+      TAO_OutputCDR &msg);

   /// Write the LocateRequest header
   virtual bool write_locate_request_header (
       CORBA::ULong request_id,
       TAO_Target_Specification &spec,
-      TAO_OutputCDR &msg
-    );
+      TAO_OutputCDR &msg);

   /// Write the reply header in to @a output
   virtual bool write_reply_header (
       TAO_OutputCDR &output,
-      TAO_Pluggable_Reply_Params_Base &reply
+      TAO_Pluggable_Reply_Params_Base &reply);

-    );
-
   /// Writes the locate _reply message in to the @a output
   virtual bool write_locate_reply_mesg (
       TAO_OutputCDR &output,
       CORBA::ULong request_id,
-      TAO_GIOP_Locate_Status_Msg &status
-    );
+      TAO_GIOP_Locate_Status_Msg &status);

   virtual bool write_fragment_header (TAO_OutputCDR & cdr,
                                       CORBA::ULong request_id);
@@ -75,9 +70,7 @@

   /// Parse the LocateRequest Header from the incoming stream. This will do a
   /// version specific parsing of the incoming Request header
-  virtual int parse_locate_header (
-      TAO_GIOP_Locate_Request_Header &
-    );
+  virtual int parse_locate_header (TAO_GIOP_Locate_Request_Header &);

   /// Parse the reply message
   virtual int parse_reply (TAO_InputCDR &input,
@@ -101,22 +94,26 @@
 private:

   /// Marshall the TargetSpecification
-
   /// This method may be required for other GIOP versiona coming out
   /// later than 1.2. We need to share this method
   bool marshall_target_spec (TAO_Target_Specification &spec,
                              TAO_OutputCDR &msg);

   /// Check whether we have BiDirContext info available. If available
-  /// delegate  the responsibility on to the TAO_Transport classes to
+  /// delegate the responsibility on to the TAO_Transport classes to
   /// initiate action.
   /// @note At somepoint this may be needed for future versions of
   /// GIOP and we may have to share this
   bool check_bidirectional_context (TAO_ServerRequest &request);

   /// Process the BiDirContext info that we have received.
-  bool process_bidir_context (TAO_Service_Context &,
+  bool process_bidir_context (TAO_Service_Context &service_context,
                               TAO_Transport *transport);
+
+  bool check_compression_context (TAO_ServerRequest &request);
+
+  bool process_compression_context (TAO_Service_Context &service_context,
+                                    TAO_ServerRequest &request);
 };

 TAO_END_VERSIONED_NAMESPACE_DECL
 ACE_INLINE bool
Index: modules/TAO/tao/Pluggable_Messaging_Utils.h
===================================================================
--- modules/TAO/tao/Pluggable_Messaging_Utils.h	(revision 79294)
+++ modules/TAO/tao/Pluggable_Messaging_Utils.h	(revision 80736)
@@ -81,6 +81,9 @@
   /// marshalled in the reply
   CORBA::Boolean argument_flag_;

+  /// Do we have a compressed reply
+  CORBA::Boolean compressed_;
+
 protected:
   /// The service context list that we don't own.
   IOP::ServiceContextList *service_context_;
Index: modules/TAO/tao/GIOP_Message_Generator_Parser_Impl.h
===================================================================
--- modules/TAO/tao/GIOP_Message_Generator_Parser_Impl.h	(revision 79294)
+++ modules/TAO/tao/GIOP_Message_Generator_Parser_Impl.h	(revision 80736)
@@ -41,7 +41,6 @@
 class TAO_Export TAO_GIOP_Message_Generator_Parser_Impl
 {
 public:
-
   /// Performs a check of the revision numbers
   static CORBA::Boolean check_revision (CORBA::Octet incoming_major,
                                         CORBA::Octet incoming_minor);
Index: modules/TAO/tao/operation_details.h
===================================================================
--- modules/TAO/tao/operation_details.h	(revision 79294)
+++ modules/TAO/tao/operation_details.h	(revision 80736)
@@ -174,6 +174,12 @@
   TAO_Reply_Dispatcher *reply_dispatcher (void) const;
   void reply_dispatcher (TAO_Reply_Dispatcher *rd);

+//  void compressed (CORBA::Boolean compressed);
+//  CORBA::Boolean compressed (void) const;
+
+  /// Temporarily @todo remove
+//  CORBA::ULong uncompressed_size_;
+
 private:

   /// Name of the operation being invoked.
@@ -214,6 +220,9 @@
   /// Count of the exceptions that operations can throw.
   CORBA::ULong ex_count_;

+  /// Compressed operation or not
+//  CORBA::Boolean compressed_;
+
   /// Boolean flag to indicate whether in the skeletons the stub arguments
   /// stored in these operation details should be used or not.
   CORBA::Boolean use_stub_args_;
Index: modules/TAO/tao/Pluggable_Messaging_Utils.inl
===================================================================
--- modules/TAO/tao/Pluggable_Messaging_Utils.inl	(revision 79294)
+++ modules/TAO/tao/Pluggable_Messaging_Utils.inl	(revision 80736)
@@ -12,6 +12,7 @@
     is_dsi_ (0),
     dsi_nvlist_align_ (0),
     argument_flag_ (false),
+    compressed_ (false),
     service_context_ (0)
 {
 }
Index: modules/TAO/tao/Remote_Invocation.cpp
===================================================================
--- modules/TAO/tao/Remote_Invocation.cpp	(revision 79294)
+++ modules/TAO/tao/Remote_Invocation.cpp	(revision 80736)
@@ -78,10 +78,8 @@
       // index that we need.
       CORBA::ULong index = 0;
       IOP::IOR *ior_info = 0;
-      int const retval =
-        this->resolver_.stub ()->create_ior_info (ior_info, index);

-      if (retval == -1)
+      if (this->resolver_.stub ()->create_ior_info (ior_info, index) == -1)
         {
           if (TAO_debug_level > 0)
             {
@@ -109,8 +107,7 @@
     // Send the request for the header
     if (this->resolver_.transport ()->generate_request_header (this->details_,
                                                                spec,
-                                                               out_stream)
-        == -1)
+                                                               out_stream) == -1)
       {
         throw ::CORBA::MARSHAL ();
       }
@@ -121,6 +118,7 @@
   void
   Remote_Invocation::marshal_data (TAO_OutputCDR &out_stream)
   {
+    // @todo Invoke compression??
     if (this->details_.marshal_args (out_stream) == false)
       {
         throw ::CORBA::MARSHAL ();
@@ -145,13 +143,13 @@
     if (nph != 0)
       {
         // nph = 0, means DiffServ library is not used
-        // nph = 0, means DiffServ library is used, and
+        // nph = 0, means DiffServ library is used, and
         // request DSCP and reply DSCP are set.
         // Note that the application could still be using
         // RTCORBA, but still setting DIffServ codepoints
         // using the DiffServ library takes precedence.
         //
-        CORBA::Long dscp = nph->get_dscp_codepoint (this->resolver_.stub (),
+        CORBA::Long const dscp = nph->get_dscp_codepoint (this->resolver_.stub (),
           this->resolver_.object ());
         connection_handler->set_dscp_codepoint (dscp);
       }
Index: modules/TAO/tao/Pluggable_Messaging.h
===================================================================
--- modules/TAO/tao/Pluggable_Messaging.h	(revision 79294)
+++ modules/TAO/tao/Pluggable_Messaging.h	(revision 80736)
@@ -161,9 +161,6 @@
   /// request/response?
   virtual int is_ready_for_bidirectional (TAO_OutputCDR &msg) = 0;

-  /// Reset the messaging the object
-  virtual void reset (void) = 0;
-
   /// Header length
   virtual size_t header_length (void) const = 0;

Index: modules/TAO/tao/IIOP_Transport.cpp
===================================================================
--- modules/TAO/tao/IIOP_Transport.cpp	(revision 79294)
+++ modules/TAO/tao/IIOP_Transport.cpp	(revision 80736)
@@ -74,9 +74,7 @@
                           const ACE_Time_Value *max_wait_time)
 {
   ssize_t const retval =
-    this->connection_handler_->peer ().sendv (iov,
-                                              iovcnt,
-                                              max_wait_time);
+    this->connection_handler_->peer ().sendv (iov, iovcnt, max_wait_time);

   if (retval > 0)
     bytes_transferred = retval;
@@ -307,9 +305,9 @@
   // messaging objects are ready to handle bidirectional connections
   // and also make sure that we have not recd. or sent any information
   // regarding this before...
-  if (this->orb_core ()->bidir_giop_policy () &&
-      this->messaging_object_->is_ready_for_bidirectional (msg) &&
-      this->bidirectional_flag () < 0)
+  if (this->bidirectional_flag () < 0 &&
+      this->orb_core ()->bidir_giop_policy () &&
+      this->messaging_object_->is_ready_for_bidirectional (msg))
     {
       this->set_bidir_context_info (opdetails);

@@ -324,14 +322,11 @@
       opdetails.request_id (this->tms ()->request_id ());
     }

-  return TAO_Transport::generate_request_header (opdetails,
-                                                 spec,
-                                                 msg);
+  return TAO_Transport::generate_request_header (opdetails, spec, msg);
 }

 int
-TAO_IIOP_Transport::messaging_init (CORBA::Octet major,
-                                    CORBA::Octet minor)
+TAO_IIOP_Transport::messaging_init (CORBA::Octet major, CORBA::Octet minor)
 {
   this->messaging_object_->init (major, minor);

@@ -409,8 +404,7 @@
     return;

   // Add this info in to the svc_list
-  opdetails.request_service_context ().set_context (IOP::BI_DIR_IIOP,
-                                                    cdr);
+  opdetails.request_service_context ().set_context (IOP::BI_DIR_IIOP, cdr);

   return;
 }
@@ -427,18 +421,15 @@
     return -1;

   // Get the array of endpoints serviced by TAO_IIOP_Acceptor
-  const ACE_INET_Addr *endpoint_addr =
-    iiop_acceptor->endpoints ();
+  const ACE_INET_Addr *endpoint_addr = iiop_acceptor->endpoints ();

   // Get the endpoint count
-  size_t const count =
-    iiop_acceptor->endpoint_count ();
+  size_t const count = iiop_acceptor->endpoint_count ();

   // Get the local address of the connection
   ACE_INET_Addr local_addr;

-  if (this->connection_handler_->peer ().get_local_addr (local_addr)
-      == -1)
+  if (this->connection_handler_->peer ().get_local_addr (local_addr) == -1)
     {
       ACE_ERROR_RETURN ((LM_ERROR,
                          ACE_TEXT ("TAO (%P|%t) - IIOP_Transport::get_listen_point, ")
Index: modules/TAO/tao/GIOP_Message_Generator_Parser_12.cpp
===================================================================
--- modules/TAO/tao/GIOP_Message_Generator_Parser_12.cpp	(revision 79294)
+++ modules/TAO/tao/GIOP_Message_Generator_Parser_12.cpp	(revision 80736)
@@ -99,8 +114,7 @@
   msg << request_id;

   // Write the target address
-  if (this->marshall_target_spec (spec,
-                                  msg) == false)
+  if (!(this->marshall_target_spec (spec, msg)))
     return false;

   // I dont think we need to align the pointer to an 8 byte boundary
@@ -248,9 +262,12 @@

   request.response_expected ((response_flags > 0));

+  // ?????
+ //request.compressed_ = (response_flags > 0);
+
   // The high bit of the octet has been set if the SyncScope policy
   // value is SYNC_WITH_SERVER.
-  request.sync_with_server ((response_flags == 1));
+  request.sync_with_server (response_flags == 1);

   // Reserved field
   input.skip_bytes (3);
@@ -296,6 +313,8 @@
       this->check_bidirectional_context (request);
     }

+  this->check_compression_context (request);
+
   if (input.length () > 0)
     {
       // Reset the read_ptr to an 8-byte boundary.
@@ -313,7 +332,7 @@
   // Get the stream .
   TAO_InputCDR &msg = request.incoming_stream ();

-  CORBA::Boolean hdr_status = 1;
+  CORBA::Boolean hdr_status = true;

   // Get the request id.
   CORBA::ULong req_id = 0;
@@ -323,8 +342,7 @@
   request.request_id (req_id);

   // Unmarshal the target address field.
-  hdr_status =
-    hdr_status && request.profile ().unmarshall_target_address(msg);
+  hdr_status = hdr_status && request.profile ().unmarshall_target_address(msg);

   // Reset the pointer to an 8-byte bouns]dary
   msg.align_read_ptr (TAO_GIOP_MESSAGE_ALIGN_PTR);
@@ -337,17 +355,17 @@
     TAO_InputCDR &cdr,
     TAO_Pluggable_Reply_Params &params)
 {
-  if (TAO_GIOP_Message_Generator_Parser::parse_reply (cdr,
-                                                      params) == -1)
-
+  if (TAO_GIOP_Message_Generator_Parser::parse_reply (cdr, params) == -1)
     return -1;

   if ((cdr >> params.svc_ctx_) == 0)
     {
-      // if (TAO_debug_level > 0)
-        ACE_ERROR ((LM_ERROR,
-                    ACE_TEXT ("TAO (%P|%t) parse_reply, ")
-                    ACE_TEXT ("extracting context\n")));
+      if (TAO_debug_level)
+        {
+          ACE_ERROR ((LM_ERROR,
+                      ACE_TEXT ("TAO (%P|%t) parse_reply, ")
+                      ACE_TEXT ("extracting context\n")));
+        }

       return -1;
     }
@@ -454,7 +472,7 @@
             if (TAO_debug_level)
               {
                 ACE_DEBUG ((LM_DEBUG,
-                            ACE_TEXT ("(%N |%l) Unable to handle this request \n")));
+                            ACE_TEXT ("(%N |%l) Unable to handle this request\n")));
               }
             return false;
           }
@@ -467,7 +485,7 @@

         // Get the IOR
         IOP::IOR *ior = 0;
-        CORBA::ULong index = spec.iop_ior (ior);
+        CORBA::ULong const index = spec.iop_ior (ior);

         if (ior)
           {
@@ -484,7 +502,7 @@
                 ACE_DEBUG ((LM_DEBUG,
                             ACE_TEXT ("(%N |%l) Unable to handle this request \n")));
               }
-            return 0;
+            return false;
           }
         break;
       }
@@ -492,7 +510,7 @@
       if (TAO_debug_level)
         {
           ACE_DEBUG ((LM_DEBUG,
-                      ACE_TEXT ("(%N |%l) Unable to handle this request \n")));
+                      ACE_TEXT ("(%N |%l) Unable to handle this request\n")));
         }
       return false;
     }
@@ -519,6 +537,23 @@
 }

 bool
+TAO_GIOP_Message_Generator_Parser_12::check_compression_context (
+    TAO_ServerRequest &request)
+{
+  TAO_Service_Context &service_context = request.request_service_context ();
+
+  // Check whether we have the BiDir service context info available in
+  // the ServiceContextList
+  if (service_context.is_service_id (IOP::TAG_ZIOP_COMPONENT))
+    {
+      return this->process_compression_context (service_context, request);
+    }
+
+  return false;
+}
+
+
+bool
 TAO_GIOP_Message_Generator_Parser_12::process_bidir_context (
     TAO_Service_Context &service_context,
     TAO_Transport *transport)
@@ -539,6 +574,49 @@
   return transport->tear_listen_point_list (cdr);
 }

+bool
+TAO_GIOP_Message_Generator_Parser_12::process_compression_context (
+    TAO_Service_Context &service_context,
+    TAO_ServerRequest &request)
+{
+  // Get the context info
+  IOP::ServiceContext context;
+  context.context_id = IOP::TAG_ZIOP_COMPONENT;
+
+  if (service_context.get_context (context) != 1)
+      ACE_ERROR_RETURN ((LM_ERROR,
+                         ACE_TEXT ("(%P|%t) Context info not found \n")),
+                        false);
+
+  TAO_InputCDR cdr (reinterpret_cast<const char*> (
+                      context.context_data.get_buffer ()),
+                      context.context_data.length ());
+
+  CORBA::Boolean byte_order;
+  if ((cdr >> ACE_InputCDR::to_boolean (byte_order)) == 0)
+    return false;
+
+  cdr.reset_byte_order (static_cast<int> (byte_order));
+
+  CORBA::ULong message_length = 0;
+  if (!(cdr >> message_length))
+    return false;
+
+    // @TODO use real typedef
+  CORBA::UShort compressorid = 0;
+  if (!(cdr >> compressorid))
+    return false;
+
+//   request.original_message_length_ = message_length;
+ACE_DEBUG ((LM_DEBUG, "Received compressor %d\n", compressorid));
+//+  request.compressed_ = true;
+//+  request.original_message_length_ = message_length;
+//+
+
+  return true;
+}
+
+
 size_t
 TAO_GIOP_Message_Generator_Parser_12::fragment_header_length (void) const
 {
 TAO_END_VERSIONED_NAMESPACE_DECL
Index: modules/TAO/tao/Synch_Invocation.cpp
===================================================================
--- modules/TAO/tao/Synch_Invocation.cpp	(revision 79294)
+++ modules/TAO/tao/Synch_Invocation.cpp	(revision 80736)
@@ -15,6 +15,7 @@
 #include "tao/ORB_Core.h"
 #include "tao/Service_Context.h"
 #include "tao/SystemException.h"
+#include "tao/ZIOP_Adapter.h"

 #if TAO_HAS_INTERCEPTORS == 1
 # include "tao/PortableInterceptorC.h"
@@ -84,9 +85,17 @@
                                 TAO_Transport::TAO_TWOWAY_REQUEST,
                                 max_wait_time);

+        TAO_OutputCDR second;
+        this->orb_core()->ziop_adapter ()->compress (*this->orb_core(), this->details_, second);
+
         this->write_header (tspec, cdr);

-        this->marshal_data (cdr);
+//        this->marshal_data (cdr);
+        //ACE_CDR::consolidate (&cdr, &second);
+        cdr.write_octet_array_mb (second.begin ());
+        cdr.compressed (true);
+        //cdr.current ()->next (second.
+        //cdr.

         // Register a reply dispatcher for this invocation. Use the
         // preallocated reply dispatcher.
@@ -644,9 +653,11 @@
                                 TAO_Transport::TAO_ONEWAY_REQUEST,
                                 max_wait_time);

+        this->orb_core()->ziop_adapter ()->compress (*this->orb_core(), this->details_, cdr);
+
         this->write_header (tspec, cdr);

-        this->marshal_data (cdr);
+        //this->marshal_data (cdr);

         countdown.update ();


