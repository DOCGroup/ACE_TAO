Index: modules/TAO/tao/GIOP_Message_Base.cpp
===================================================================
--- modules/TAO/tao/GIOP_Message_Base.cpp	(revision 79294)
+++ modules/TAO/tao/GIOP_Message_Base.cpp	(revision 80736)
@@ -12,6 +12,7 @@
 #include "tao/Request_Dispatcher.h"
 #include "tao/Codeset_Manager.h"
 #include "tao/SystemException.h"
+#include "tao/ZIOP_Adapter.h"
 #include "ace/Min_Max.h"

 /*
@@ -61,12 +62,6 @@
   return this->out_stream_;
 }

-void
-TAO_GIOP_Message_Base::reset (void)
-{
-  // no-op
-}
-
 int
 TAO_GIOP_Message_Base::generate_request_header (
     TAO_Operation_Details &op,
@@ -74,16 +69,12 @@
     TAO_OutputCDR &cdr)
 {
   // Get a parser for us
-  TAO_GIOP_Message_Generator_Parser *generator_parser = 0;
   TAO_GIOP_Message_Version giop_version;

   cdr.get_version (giop_version);

-  // Get the state information that we need to use
-  this->set_state (giop_version, generator_parser);
-
   // Write the GIOP header first
-  if (!this->write_protocol_header (TAO_GIOP_REQUEST, cdr))
+  if (!this->write_protocol_header (TAO_GIOP_REQUEST, giop_version, cdr))
     {
       if (TAO_debug_level)
         {
@@ -94,6 +85,10 @@
       return -1;
     }

+  // Get the parser we need to use
+  TAO_GIOP_Message_Generator_Parser *generator_parser =
+    this->get_parser (giop_version);
+
   // Now call the implementation for the rest of the header
   if (!generator_parser->write_request_header (op, spec, cdr))
     {
@@ -113,17 +108,12 @@
     TAO_Target_Specification &spec,
     TAO_OutputCDR &cdr)
 {
-  // Get a parser for us
-  TAO_GIOP_Message_Generator_Parser *generator_parser = 0;
   TAO_GIOP_Message_Version giop_version;

   cdr.get_version (giop_version);

-  // Get the state information that we need to use
-  this->set_state (giop_version, generator_parser);
-
   // Write the GIOP header first
-  if (!this->write_protocol_header (TAO_GIOP_LOCATEREQUEST, cdr))
+  if (!this->write_protocol_header (TAO_GIOP_LOCATEREQUEST, giop_version, cdr))
     {
       if (TAO_debug_level)
         ACE_ERROR ((LM_ERROR,
@@ -132,6 +122,10 @@
       return -1;
     }

+  // Get the parser we need to use
+  TAO_GIOP_Message_Generator_Parser *generator_parser =
+    this->get_parser (giop_version);
+
   // Now call the implementation for the rest of the header
   if (!generator_parser->write_locate_request_header
       (op.request_id (), spec, cdr))
@@ -154,16 +148,12 @@
     TAO_Pluggable_Reply_Params_Base &params)
 {
   // Get a parser for us
-  TAO_GIOP_Message_Generator_Parser *generator_parser = 0;
   TAO_GIOP_Message_Version giop_version;

   cdr.get_version (giop_version);

-  // Get the state information that we need to use
-  this->set_state (giop_version, generator_parser);
-
   // Write the GIOP header first
-  if (!this->write_protocol_header (TAO_GIOP_REPLY, cdr))
+  if (!this->write_protocol_header (TAO_GIOP_REPLY, giop_version, cdr))
     {
       if (TAO_debug_level)
         ACE_ERROR ((LM_ERROR,
@@ -174,11 +164,12 @@

   try
     {
+      // Get the parser we need to use
+      TAO_GIOP_Message_Generator_Parser *generator_parser =
+        this->get_parser (giop_version);
+
       // Now call the implementation for the rest of the header
-      int const result =
-        generator_parser->write_reply_header (cdr, params);
-
-      if (!result)
+      if (!generator_parser->write_reply_header (cdr, params))
         {
           if (TAO_debug_level > 4)
             ACE_ERROR ((LM_ERROR,
@@ -204,8 +195,6 @@
 TAO_GIOP_Message_Base::generate_fragment_header (TAO_OutputCDR & cdr,
                                                  CORBA::ULong request_id)
 {
-  // Get a parser for us
-  TAO_GIOP_Message_Generator_Parser *generator_parser = 0;
   TAO_GIOP_Message_Version giop_version;

   cdr.get_version (giop_version);
@@ -216,11 +205,12 @@
   if (giop_version.major == 1 && giop_version.minor < 2)
     return -1;

-  // Get the state information that we need to use
-  this->set_state (giop_version, generator_parser);
+  // Get the parser we need to use
+  TAO_GIOP_Message_Generator_Parser *generator_parser =
+    this->get_parser (giop_version);

   // Write the GIOP header first
-  if (!this->write_protocol_header (TAO_GIOP_FRAGMENT, cdr)
+  if (!this->write_protocol_header (TAO_GIOP_FRAGMENT, giop_version, cdr)
       || !generator_parser->write_fragment_header (cdr, request_id))
     {
       if (TAO_debug_level)
@@ -237,7 +227,7 @@
 TAO_GIOP_Message_Base::format_message (TAO_OutputCDR &stream)
 {
   // Ptr to first buffer.
-  char * buf = (char *) stream.buffer ();
+  char *buf = const_cast <char*> (stream.buffer ());

   this->set_giop_flags (stream);

@@ -321,7 +311,7 @@
         }

       /* init out-parameters */
-      qd.set_state (state);
+      qd.state (state);
       mesg_length = message_size;

       return 1; /* complete header */
@@ -384,7 +374,7 @@
     }

   size_t copying_len = state.message_size ();
-
+// handle compress
   qd = this->make_queued_data (copying_len);

   if (qd == 0)
@@ -411,7 +401,7 @@
   qd->msg_block ()->copy (incoming.rd_ptr (), copying_len);

   incoming.rd_ptr (copying_len);
-  qd->set_state (state);
+  qd->state (state);

   return 1;
 }
@@ -515,7 +505,7 @@
       incoming.rd_ptr (copy_len);

       // Get the other details...
-      qd->set_state (state);
+      qd->state (state);
     }
   else
     {
@@ -558,12 +548,10 @@
   // Set the upcall thread
   this->orb_core_->lf_strategy ().set_upcall_thread (this->orb_core_->leader_follower ());

-  // Get a parser for us
-  TAO_GIOP_Message_Generator_Parser *generator_parser = 0;
+  // Get the parser we need to use
+  TAO_GIOP_Message_Generator_Parser *generator_parser =
+    this->get_parser (qd->giop_version ());

-  // Get the state information that we need to use
-  this->set_state (qd->giop_version (), generator_parser);
-
   // A buffer that we will use to initialise the CDR stream.  Since we're
   // allocating the buffer on the stack, we may as well allocate the data
   // block on the stack too and avoid an allocation inside the message
@@ -646,6 +634,7 @@
                           qd->giop_version ().major_version (),
                           qd->giop_version ().minor_version (),
                           this->orb_core_);
+input_cdr.compressed_ = qd->state().compressed ();

   transport->assign_translators(&input_cdr,&output);

@@ -682,12 +671,10 @@
     TAO_Pluggable_Reply_Params &params,
     TAO_Queued_Data *qd)
 {
-  // Get a parser for us
-  TAO_GIOP_Message_Generator_Parser *generator_parser = 0;
+  // Get the parser we need to use
+  TAO_GIOP_Message_Generator_Parser *generator_parser =
+    this->get_parser (qd->giop_version());

-  // Get the state information that we need to use
-  this->set_state (qd->giop_version (), generator_parser);
-
   // Get the read and write positions before we steal data.
   size_t rd_pos = qd->msg_block ()->rd_ptr () - qd->msg_block ()->base ();
   size_t const wr_pos = qd->msg_block ()->wr_ptr () - qd->msg_block ()->base ();
@@ -789,6 +776,7 @@

 int
 TAO_GIOP_Message_Base::write_protocol_header (TAO_GIOP_Message_Type type,
+                                              const TAO_GIOP_Message_Version &version,
                                               TAO_OutputCDR &msg)
 {
   // Reset the message type
@@ -804,13 +792,9 @@
       0x50  // 'P'
     };

-  TAO_GIOP_Message_Version giop_version;
+  header[4] = version.major;
+  header[5] = version.minor;

-  msg.get_version (giop_version);
-
-  header[4] = giop_version.major;
-  header[5] = giop_version.minor;
-
   // "flags" octet, i.e. header[6] will be set up later when message
   // is formatted by the transport.

@@ -867,6 +851,25 @@

       CORBA::Object_var forward_to;

+//if (request.original_message_length_ > 0)
+if (cdr.compressed_ == true)
+{
+  this->orb_core_->ziop_adapter ()->decompress (request);
+//+#if !defined (__BORLANDC__)
+//+            Bytef* LargBuffer = new Bytef [request.original_message_length_ * 2];
+//+     uLongf length = request.original_message_length_ * 2;
+//+            int retval = uncompress (LargBuffer,   &length,
+//+       (const Bytef*)cdr.rd_ptr(), cdr.length ());
+//+                          //       reinterpret_cast <const Bytef*>(compression_stream.buffer ()), compression_stream.total_length ());
+//+     char* buf = (char*)LargBuffer;
+
+//+TAO_InputCDR* newstream = new TAO_InputCDR (buf, (size_t)length);
+//+request.incoming_ = newstream;
+//+#endif
+//+
+//+ // do decompression
+}
+
       /*
        * Hook to specialize request processing within TAO
        * This hook will be replaced by specialized request
@@ -1171,10 +1174,13 @@
                                                TAO_OutputCDR &output,
                                                TAO_GIOP_Message_Generator_Parser *parser)
 {
+  TAO_GIOP_Message_Version giop_version;
+  output.get_version (giop_version);
+
   // Note here we are making the Locate reply header which is *QUITE*
   // different from the reply header made by the make_reply () call..
   // Make the GIOP message header
-  this->write_protocol_header (TAO_GIOP_LOCATEREPLY, output);
+  this->write_protocol_header (TAO_GIOP_LOCATEREPLY, giop_version, output);

   // This writes the header & body
   parser->write_locate_reply_mesg (output,
@@ -1253,10 +1259,9 @@
   return result;
 }

-void
-TAO_GIOP_Message_Base::set_state (
-    const TAO_GIOP_Message_Version &version,
-    TAO_GIOP_Message_Generator_Parser *&gen_parser) const
+TAO_GIOP_Message_Generator_Parser*
+TAO_GIOP_Message_Base::get_parser (
+    const TAO_GIOP_Message_Version &version) const
 {
   switch (version.major)
     {
@@ -1264,25 +1269,27 @@
       switch (version.minor)
         {
         case 0:
-          gen_parser =
+          return
             const_cast<TAO_GIOP_Message_Generator_Parser_10 *> (
                                      &this->tao_giop_impl_.tao_giop_10);
           break;
         case 1:
-          gen_parser =
+          return
             const_cast<TAO_GIOP_Message_Generator_Parser_11 *> (
                                      &this->tao_giop_impl_.tao_giop_11);
           break;
         case 2:
-          gen_parser =
+          return
             const_cast<TAO_GIOP_Message_Generator_Parser_12 *> (
                                      &this->tao_giop_impl_.tao_giop_12);
           break;
         default:
+          throw ::CORBA::INTERNAL (0, CORBA::COMPLETED_NO);
           break;
         }
       break;
     default:
+      throw ::CORBA::INTERNAL (0, CORBA::COMPLETED_NO);
       break;
     }
 }
@@ -1448,6 +1455,9 @@
       // Byte order.
       int byte_order = ptr[TAO_GIOP_MESSAGE_FLAGS_OFFSET] & 0x01;

+      // Compressed
+      int compressed = ptr[TAO_GIOP_MESSAGE_FLAGS_OFFSET] & 0x04;
+
       // Get the version info
       CORBA::Octet major = ptr[TAO_GIOP_VERSION_MAJOR_OFFSET];
       CORBA::Octet minor = ptr[TAO_GIOP_VERSION_MINOR_OFFSET];
@@ -1489,12 +1499,13 @@
       ACE_DEBUG ((LM_DEBUG,
                   "TAO (%P|%t) - GIOP_Message_Base::dump_msg, "
                   "%s GIOP v%c.%c msg, %d data bytes, %s endian, "
-                  "Type %s[%u]\n",
+                  "%s compressed, Type %s[%u]\n",
                   ACE_TEXT_CHAR_TO_TCHAR (label),
                   digits[ptr[TAO_GIOP_VERSION_MAJOR_OFFSET]],
                   digits[ptr[TAO_GIOP_VERSION_MINOR_OFFSET]],
                   len - TAO_GIOP_MESSAGE_HEADER_LEN ,
                   (byte_order == TAO_ENCAP_BYTE_ORDER) ? ACE_TEXT("my") : ACE_TEXT("other"),
+                  (compressed == 0) ? ACE_TEXT("not") : ACE_TEXT("is"),
                   ACE_TEXT_CHAR_TO_TCHAR(message_name),
                   *id));

@@ -1517,20 +1528,19 @@
 int
 TAO_GIOP_Message_Base::is_ready_for_bidirectional (TAO_OutputCDR &msg)
 {
-  // Get a parser for us
-  TAO_GIOP_Message_Generator_Parser *parser = 0;
   TAO_GIOP_Message_Version giop_version;

   msg.get_version (giop_version);

-  // Get the state information that we need to use
-  this->set_state (giop_version, parser);
+  // Get the parser we need to use
+  TAO_GIOP_Message_Generator_Parser *generator_parser =
+    this->get_parser (giop_version);

   // We dont really know.. So ask the generator and parser objects that
   // we know.
   // @@ TODO: Need to make this faster, instead of making virtual
   // call, try todo the check within this class
-  return parser->is_ready_for_bidirectional ();
+  return generator_parser->is_ready_for_bidirectional ();
 }


@@ -1543,8 +1553,7 @@
   // bytes. As we may not know how many bytes will be lost, we will
   // allocate ACE_CDR::MAX_ALIGNMENT extra.
   ACE_Data_Block *db =
-    this->orb_core_->create_input_cdr_data_block (sz +
-                                                  ACE_CDR::MAX_ALIGNMENT);
+    this->orb_core_->create_input_cdr_data_block (sz + ACE_CDR::MAX_ALIGNMENT);

   TAO_Queued_Data *qd =
     TAO_Queued_Data::make_queued_data (
@@ -1577,11 +1586,10 @@
 TAO_GIOP_Message_Base::fragment_header_length (
   const TAO_GIOP_Message_Version& giop_version) const
 {
-  TAO_GIOP_Message_Generator_Parser *generator_parser = 0;
+  // Get the parser we need to use
+  TAO_GIOP_Message_Generator_Parser *generator_parser =
+    this->get_parser (giop_version);

-  // Get the state information that we need to use
-  this->set_state (giop_version, generator_parser);
-
   return generator_parser->fragment_header_length ();
 }

@@ -1589,12 +1597,10 @@
 TAO_GIOP_Message_Base::parse_request_id (const TAO_Queued_Data *qd,
                                          CORBA::ULong &request_id) const
 {
-  // Get a parser for us
-  TAO_GIOP_Message_Generator_Parser *generator_parser = 0;
+  // Get the parser we need to use
+  TAO_GIOP_Message_Generator_Parser *generator_parser =
+    this->get_parser (qd->giop_version ());

-  // Get the state information that we need to use
-  this->set_state (qd->giop_version (), generator_parser);
-
   // Get the read and write positions before we steal data.
   size_t rd_pos = qd->msg_block ()->rd_ptr () - qd->msg_block ()->base ();
   size_t wr_pos = qd->msg_block ()->wr_ptr () - qd->msg_block ()->base ();
@@ -1616,8 +1622,7 @@
   // Get the flag in the message block
   flg = qd->msg_block ()->self_flags ();

-  if (ACE_BIT_ENABLED (flg,
-                       ACE_Message_Block::DONT_DELETE))
+  if (ACE_BIT_ENABLED (flg, ACE_Message_Block::DONT_DELETE))
     {
       // Use the same datablock
       db = qd->msg_block ()->data_block ();
@@ -1938,6 +1943,9 @@
   // Only supported in GIOP 1.1 or better.
   if (!(major <= 1 && minor == 0))
     ACE_SET_BITS (flags, msg.more_fragments () << 1);
+
+  if (!(major <= 1 && minor < 2))
+    ACE_SET_BITS (flags, msg.compressed () << 2);
 }

 TAO_END_VERSIONED_NAMESPACE_DECL
Index: modules/TAO/tao/operation_details.inl
===================================================================
--- modules/TAO/tao/operation_details.inl	(revision 79294)
+++ modules/TAO/tao/operation_details.inl	(revision 80736)
@@ -20,6 +20,7 @@
     , num_args_ (num)
     , ex_data_ (data)
     , ex_count_ (count)
+//    , compressed_ (false)
     , use_stub_args_ (args ? true : false)
 #if TAO_HAS_INTERCEPTORS == 1
     , ft_expiration_time_ (0)
@@ -234,5 +235,16 @@
   this->reply_dispatcher_ = rd;
 }

+/*ACE_INLINE void
+TAO_Operation_Details::compressed (CORBA::Boolean compressed)
+{
+  this->compressed_ = compressed;
+}

+ACE_INLINE CORBA::Boolean
+TAO_Operation_Details::compressed (void) const
+{
+  return this->compressed_;
+} */
+
 TAO_END_VERSIONED_NAMESPACE_DECL
Index: modules/TAO/tao/CDR.inl
===================================================================
--- modules/TAO/tao/CDR.inl	(revision 79294)
+++ modules/TAO/tao/CDR.inl	(revision 80736)
@@ -21,7 +21,19 @@
   this->more_fragments_ = more;
 }

+ACE_INLINE bool
+TAO_OutputCDR::compressed (void) const
+{
+  return this->compressed_;
+}
+
 ACE_INLINE void
+TAO_OutputCDR::compressed (bool compressed)
+{
+  this->compressed_ = compressed;
+}
+
+ACE_INLINE void
 TAO_OutputCDR::message_attributes (CORBA::ULong request_id,
                                    TAO_Stub * stub,
                                    int message_semantics,
@@ -77,6 +89,7 @@
                   byte_order,
                   major_version,
                   minor_version),
+                  compressed_ (0),
     orb_core_ (orb_core)
 {
 }
@@ -91,6 +104,7 @@
                   byte_order,
                   major_version,
                   minor_version),
+                  compressed_ (0),
     orb_core_ (orb_core)
 {
 }
@@ -105,6 +119,7 @@
                   byte_order,
                   major_version,
                   minor_version),
+                  compressed_ (0),
     orb_core_ (orb_core)
 {
 }
@@ -121,6 +136,7 @@
                   major_version,
                   minor_version,
                   lock),
+                  compressed_ (0),
     orb_core_ (orb_core)
 {
 }
@@ -137,6 +153,7 @@
                   byte_order,
                   major_version,
                   minor_version),
+                  compressed_ (0),
     orb_core_ (orb_core)
 {
 }
@@ -158,6 +175,7 @@
                   byte_order,
                   major_version,
                   minor_version),
+                  compressed_ (0),
     orb_core_ (orb_core)
 {
 }
@@ -170,6 +188,7 @@
   : ACE_InputCDR (rhs,
                   size,
                   offset),
+                  compressed_ (rhs.compressed_),
     orb_core_ (rhs.orb_core_)
 {
 }
@@ -179,6 +198,7 @@
                             size_t size)
   : ACE_InputCDR (rhs,
                   size),
+                  compressed_ (rhs.compressed_),
     orb_core_ (rhs.orb_core_)
 {
 }
@@ -186,7 +206,8 @@
 ACE_INLINE
 TAO_InputCDR::TAO_InputCDR (const TAO_InputCDR& rhs)
   : ACE_InputCDR (rhs),
-    orb_core_ (rhs.orb_core_)
+                  compressed_ (rhs.compressed_),
+      orb_core_ (rhs.orb_core_)
 {
 }

@@ -194,6 +215,7 @@
 TAO_InputCDR::TAO_InputCDR (ACE_InputCDR::Transfer_Contents rhs,
                             TAO_ORB_Core* orb_core)
   : ACE_InputCDR (rhs),
+                 // compressed_ (rhs.compressed_),
     orb_core_ (orb_core)
 {
 }
Index: modules/TAO/tao/ORB_Core.inl
===================================================================
--- modules/TAO/tao/ORB_Core.inl	(revision 79294)
+++ modules/TAO/tao/ORB_Core.inl	(revision 80736)
@@ -430,6 +430,18 @@
   return this->codeset_manager_;
 }

+ACE_INLINE TAO_ZIOP_Adapter *
+TAO_ORB_Core::ziop_adapter ()
+{
+  ACE_GUARD_RETURN (TAO_SYNCH_MUTEX, mon, this->lock_,
+                    0);
+  if (ziop_adapter_ == 0)
+    {
+      return this->ziop_adapter_i ();
+    }
+  return this->ziop_adapter_;
+}
+
 ACE_INLINE TAO::ORBInitializer_Registry_Adapter *
 TAO_ORB_Core::orbinitializer_registry ()
 {
Index: modules/TAO/tao/GIOP_Message_Base.h
===================================================================
--- modules/TAO/tao/GIOP_Message_Base.h	(revision 79294)
+++ modules/TAO/tao/GIOP_Message_Base.h	(revision 80736)
@@ -64,9 +64,6 @@
   virtual void init (CORBA::Octet major,
                      CORBA::Octet minor);

-  /// Reset the messaging the object
-  virtual void reset (void);
-
   /// Write the RequestHeader in to the @a cdr stream. The underlying
   /// implementation of the mesaging should do the right thing.
   virtual int generate_request_header (TAO_Operation_Details &op,
@@ -177,8 +174,8 @@
                                       TAO_GIOP_Message_Generator_Parser *);

   /// Set the state
-  void set_state (const TAO_GIOP_Message_Version &version,
-                  TAO_GIOP_Message_Generator_Parser *&) const;
+  TAO_GIOP_Message_Generator_Parser *get_parser (
+    const TAO_GIOP_Message_Version &version) const;

   /// Print out a debug messages..
   void dump_msg (const char *label, const u_char *ptr, size_t len);
@@ -186,7 +183,9 @@
   /// Writes the GIOP header in to @a msg
   /// @note If the GIOP header happens to change in the future, we can
   /// push this method in to the generator_parser classes.
-  int write_protocol_header (TAO_GIOP_Message_Type t, TAO_OutputCDR &msg);
+  int write_protocol_header (TAO_GIOP_Message_Type t,
+                             const TAO_GIOP_Message_Version &version,
+                             TAO_OutputCDR &msg);

   /// Make a GIOP_LOCATEREPLY and hand that over to the transport so
   /// that it can be sent over the connection.
Index: modules/TAO/tao/Incoming_Message_Queue.h
===================================================================
--- modules/TAO/tao/Incoming_Message_Queue.h	(revision 79294)
+++ modules/TAO/tao/Incoming_Message_Queue.h	(revision 80736)
@@ -73,6 +73,8 @@

   friend class TAO_Transport;

+  CORBA::Octet compressed_;
+
 private:
   /*!
     \brief A circular linked list of messages awaiting processing.
Index: modules/TAO/tao/IOP_IOR.pidl
===================================================================
--- modules/TAO/tao/IOP_IOR.pidl	(revision 79294)
+++ modules/TAO/tao/IOP_IOR.pidl	(revision 80736)
@@ -32,6 +32,12 @@

 module IOP
 {
+struct CompressedData {
+  long compressorid;
+  long original_length;
+  CORBA::OctetSeq data;
+};
+
   typedef unsigned long ProfileId;
   const ProfileId TAG_INTERNET_IOP = 0;
   const ProfileId TAG_MULTIPLE_COMPONENTS = 1;
@@ -104,6 +110,8 @@

   const ServiceId REP_NWPRIORITY = 0x54410005;

+  const ComponentId TAG_ZIOP_COMPONENT = 0x54410555;
+
   // The following are defined in 03-01-11
   const ProfileId TAG_UIPMC = 3;
   const ComponentId TAG_GROUP = 39;
Index: modules/TAO/tao/TAO_Internal.cpp
===================================================================
--- modules/TAO/tao/TAO_Internal.cpp	(revision 79294)
+++ modules/TAO/tao/TAO_Internal.cpp	(revision 80736)
@@ -451,7 +451,7 @@
 #endif /* TAO_PLATFORM_SVC_CONF_FILE_NOTSUP */

     // Copy command line parameter to allow conversion
-    ACE_Argv_Type_Converter command_line (argc, argv);
+    ACE_Argv_Type_Converter command_line (argc, argv);

     return pcfg->open (command_line.get_argc (),
                        command_line.get_TCHAR_argv (),
Index: modules/TAO/tao/TAO_Server_Request.cpp
===================================================================
--- modules/TAO/tao/TAO_Server_Request.cpp	(revision 79294)
+++ modules/TAO/tao/TAO_Server_Request.cpp	(revision 80736)
@@ -354,9 +354,9 @@

   this->outgoing_->more_fragments (false);

-  int result = this->transport_->send_message (*this->outgoing_,
-                                               0,
-                                               TAO_Transport::TAO_REPLY);
+  int const result = this->transport_->send_message (*this->outgoing_,
+                                                      0,
+                                                      TAO_Transport::TAO_REPLY);
   if (result == -1)
     {
       if (TAO_debug_level > 0)
Index: modules/TAO/tao/Transport.cpp
===================================================================
--- modules/TAO/tao/Transport.cpp	(revision 79294)
+++ modules/TAO/tao/Transport.cpp	(revision 80736)
@@ -23,6 +23,7 @@
 #include "tao/ORB_Core.h"
 #include "tao/MMAP_Allocator.h"
 #include "tao/SystemException.h"
+#include "tao/Operation_Details.h"

 #include "ace/OS_NS_sys_time.h"
 #include "ace/OS_NS_stdio.h"
@@ -424,7 +425,7 @@
     TAO_Target_Specification &spec,
     TAO_OutputCDR &output)
 {
-  // codeset service context is only supposed to be sent in the first request
+  // Codeset service context is only supposed to be sent in the first request
   // on a particular connection.
   if (this->first_request_)
     {
@@ -433,15 +434,31 @@
         csm->generate_service_context (opdetails,*this);
     }

+  // Check whether we have Compression set
+//  if (opdetails.compressed ())
+//    {
+//      TAO_OutputCDR cdr;
+//
+//      // Add the original message length to the service contenxt
+//      CORBA::ULong length = opdetails.uncompressed_size_;
+//      if ((cdr << ACE_OutputCDR::from_boolean (TAO_ENCAP_BYTE_ORDER) == 0)
+//          || (cdr << length) == 0)
+//        return -1;
+//
+//      // Add this info in to the svc_list
+//      opdetails.request_service_context ().set_context (IOP::TAG_ZIOP_COMPONENT,
+//                                                        cdr);
+//    }
+
   if (this->messaging_object ()->generate_request_header (opdetails,
                                                           spec,
                                                           output) == -1)
     {
       if (TAO_debug_level > 0)
         {
-        ACE_DEBUG ((LM_DEBUG,
-                   ACE_TEXT ("(%P|%t) - Transport[%d]::generate_request_header, ")
-                   ACE_TEXT ("error while marshalling the Request header\n"),
+          ACE_ERROR ((LM_ERROR,
+                      ACE_TEXT ("(%P|%t) - Transport[%d]::generate_request_header, ")
+                      ACE_TEXT ("error while marshalling the Request header\n"),
                       this->id()));
         }

@@ -460,8 +477,7 @@
   this->purge_entry ();

   // Then add ourselves to the cache
-  return this->transport_cache_manager ().cache_transport (desc,
-                                                           this);
+  return this->transport_cache_manager ().cache_transport (desc, this);
 }

 int
@@ -490,9 +506,7 @@
 }

 /*
- *
  *  Methods called and used in the output path of the ORB.
- *
  */
 int
 TAO_Transport::handle_output (void)
@@ -1248,8 +1262,6 @@
 TAO_Transport::send_connection_closed_notifications_i (void)
 {
   this->cleanup_queue_i ();
-
-  this->messaging_object ()->reset ();
 }

 int
@@ -1267,13 +1279,11 @@
   switch (message_semantics)
     {
       case TAO_Transport::TAO_TWOWAY_REQUEST:
-        ret = this->send_synchronous_message_i (message_block,
-                                                max_wait_time);
+        ret = this->send_synchronous_message_i (message_block, max_wait_time);
         break;

       case TAO_Transport::TAO_REPLY:
-        ret = this->send_reply_message_i (message_block,
-                                          max_wait_time);
+        ret = this->send_reply_message_i (message_block, max_wait_time);
         break;

       case TAO_Transport::TAO_ONEWAY_REQUEST:
@@ -1831,7 +1841,6 @@
          this->id ()));
     }

-
   // The buffer on the stack which will be used to hold the input
   // messages, ACE_CDR::MAX_ALIGNMENT compensates the
   // memory-alignment. This improves performance with SUN-Java-ORB-1.4
@@ -2190,7 +2199,7 @@

                 }

-              const int retval = this->notify_reactor ();
+              int const retval = this->notify_reactor ();

               if (retval == 1)
                 {
@@ -2209,8 +2218,7 @@
             }

           // PRE: incoming_message_queue is empty
-          if (this->process_parsed_messages (&qd,
-                                             rh) == -1)
+          if (this->process_parsed_messages (&qd, rh) == -1)
             {
               return -1;
             }
Index: modules/TAO/tao/GIOP_Message_State.cpp
===================================================================
--- modules/TAO/tao/GIOP_Message_State.cpp	(revision 79294)
+++ modules/TAO/tao/GIOP_Message_State.cpp	(revision 80736)
@@ -45,9 +45,7 @@

   // Parse the magic bytes first
   if (this->parse_magic_bytes (buf) == -1)
-    {
-      return -1;
-    }
+    return -1;

   // Get the version information
   if (this->get_version_info (buf) == -1)
@@ -230,9 +228,13 @@

       // Read the fragment bit
       this->more_fragments_ =
-        (CORBA::Octet) (buf[TAO_GIOP_MESSAGE_FLAGS_OFFSET]& 0x02);
+        ((buf[TAO_GIOP_MESSAGE_FLAGS_OFFSET]& 0x02) == 2);

-      if ((buf[TAO_GIOP_MESSAGE_FLAGS_OFFSET] & ~0x3) != 0)
+      // Read the compressed bit
+      this->compressed_ =
+        ((buf[TAO_GIOP_MESSAGE_FLAGS_OFFSET]& 0x04) == 4);
+
+      if ((buf[TAO_GIOP_MESSAGE_FLAGS_OFFSET] & ~0x7) != 0)
         {
           if (TAO_debug_level > 2)
             {
Index: modules/TAO/tao/GIOP_Message_State.h
===================================================================
--- modules/TAO/tao/GIOP_Message_State.h	(revision 79294)
+++ modules/TAO/tao/GIOP_Message_State.h	(revision 80736)
@@ -8,10 +8,10 @@
  *
  *   GIOP utility definitions
  *
+ *
  *  @author  Chris Cleeland <cleeland@cs.wustl.edu>
  *  @author  Carlos O' Ryan <coryan@uci.edu>
  *  @author  Balachandran Natarajan <bala@cs.wustl.edu>
- *  @author  Johnny Willemsen <jwillemsen@remedy.nl>
  */
 //=============================================================================
 #ifndef TAO_GIOP_MESSAGE_STATE_H
@@ -72,6 +72,9 @@
   /// Get the GIOP version
   TAO_GIOP_Message_Version const &giop_version (void) const;

+  /// Return the compressed information
+  CORBA::Boolean compressed (void) const;
+
 private:
   /// Parse the message header.
   int parse_message_header_i (ACE_Message_Block &incoming);
@@ -101,7 +104,7 @@
   CORBA::ULong read_ulong (const char *buf) const;

 private:
-  // GIOP version information..
+  /// GIOP version information..
   TAO_GIOP_Message_Version giop_version_;

   /// 0 = big, 1 = little
@@ -114,10 +117,12 @@
   CORBA::ULong payload_size_;

   /// (Requests and Replys)
-  /// A value of zero indicates that this message does not have any
-  /// fragments.  A value of non-zero indicates that it does have
-  /// fragments.
-  CORBA::Octet more_fragments_;
+  /// A false indicates that this message does not have any
+  /// fragments.  A value of true indicates that it does have fragments.
+  CORBA::Boolean more_fragments_;
+
+  /// Compressed
+  CORBA::Boolean compressed_;
 };

 TAO_END_VERSIONED_NAMESPACE_DECL
Index: modules/TAO/tao/CDR.h
===================================================================
--- modules/TAO/tao/CDR.h	(revision 79294)
+++ modules/TAO/tao/CDR.h	(revision 80736)
@@ -180,6 +180,12 @@
   /// Specify whether there are more data fragments to come.
   void more_fragments (bool more);

+  /// Are we containing compressed data?
+  bool compressed (void) const;
+
+  /// Specify whether we have compressed data.
+  void compressed (bool compressed);
+
   /// Set fragmented message attributes.
   void message_attributes (CORBA::ULong request_id,
                            TAO_Stub * stub,
@@ -235,6 +241,9 @@

   /// Request/reply send timeout.
   ACE_Time_Value * timeout_;
+
+  /// Do we contain compressed data
+  bool compressed_;
   //@}

 };
@@ -262,6 +271,7 @@
 class TAO_Export TAO_InputCDR : public ACE_InputCDR
 {
 public:
+  CORBA::Boolean compressed_;
   /**
    * Create an input stream from an arbitrary buffer, care must be
    * exercised wrt alignment, because this contructor will *not* work
Index: modules/TAO/tao/GIOP_Message_Generator_Parser_12.h
===================================================================
--- modules/TAO/tao/GIOP_Message_Generator_Parser_12.h	(revision 79294)
+++ modules/TAO/tao/GIOP_Message_Generator_Parser_12.h	(revision 80736)
@@ -33,7 +33,7 @@
  *
  */

-class TAO_Export TAO_GIOP_Message_Generator_Parser_12:
+class TAO_Export TAO_GIOP_Message_Generator_Parser_12 :
   public TAO_GIOP_Message_Generator_Parser
 {
 public:
@@ -42,29 +42,24 @@
   virtual bool write_request_header (
       const TAO_Operation_Details &opdetails,
       TAO_Target_Specification &spec,
-      TAO_OutputCDR &msg
-    );
+      TAO_OutputCDR &msg);

   /// Write the LocateRequest header
   virtual bool write_locate_request_header (
       CORBA::ULong request_id,
       TAO_Target_Specification &spec,
-      TAO_OutputCDR &msg
-    );
+      TAO_OutputCDR &msg);

   /// Write the reply header in to @a output
   virtual bool write_reply_header (
       TAO_OutputCDR &output,
-      TAO_Pluggable_Reply_Params_Base &reply
+      TAO_Pluggable_Reply_Params_Base &reply);

-    );
-
   /// Writes the locate _reply message in to the @a output
   virtual bool write_locate_reply_mesg (
       TAO_OutputCDR &output,
       CORBA::ULong request_id,
-      TAO_GIOP_Locate_Status_Msg &status
-    );
+      TAO_GIOP_Locate_Status_Msg &status);

   virtual bool write_fragment_header (TAO_OutputCDR & cdr,
                                       CORBA::ULong request_id);
@@ -75,9 +70,7 @@

   /// Parse the LocateRequest Header from the incoming stream. This will do a
   /// version specific parsing of the incoming Request header
-  virtual int parse_locate_header (
-      TAO_GIOP_Locate_Request_Header &
-    );
+  virtual int parse_locate_header (TAO_GIOP_Locate_Request_Header &);

   /// Parse the reply message
   virtual int parse_reply (TAO_InputCDR &input,
@@ -101,22 +94,26 @@
 private:

   /// Marshall the TargetSpecification
-
   /// This method may be required for other GIOP versiona coming out
   /// later than 1.2. We need to share this method
   bool marshall_target_spec (TAO_Target_Specification &spec,
                              TAO_OutputCDR &msg);

   /// Check whether we have BiDirContext info available. If available
-  /// delegate  the responsibility on to the TAO_Transport classes to
+  /// delegate the responsibility on to the TAO_Transport classes to
   /// initiate action.
   /// @note At somepoint this may be needed for future versions of
   /// GIOP and we may have to share this
   bool check_bidirectional_context (TAO_ServerRequest &request);

   /// Process the BiDirContext info that we have received.
-  bool process_bidir_context (TAO_Service_Context &,
+  bool process_bidir_context (TAO_Service_Context &service_context,
                               TAO_Transport *transport);
+
+  bool check_compression_context (TAO_ServerRequest &request);
+
+  bool process_compression_context (TAO_Service_Context &service_context,
+                                    TAO_ServerRequest &request);
 };

 TAO_END_VERSIONED_NAMESPACE_DECL
 ACE_INLINE bool
Index: modules/TAO/tao/Pluggable_Messaging_Utils.h
===================================================================
--- modules/TAO/tao/Pluggable_Messaging_Utils.h	(revision 79294)
+++ modules/TAO/tao/Pluggable_Messaging_Utils.h	(revision 80736)
@@ -81,6 +81,9 @@
   /// marshalled in the reply
   CORBA::Boolean argument_flag_;

+  /// Do we have a compressed reply
+  CORBA::Boolean compressed_;
+
 protected:
   /// The service context list that we don't own.
   IOP::ServiceContextList *service_context_;
Index: modules/TAO/tao/GIOP_Message_Generator_Parser_Impl.h
===================================================================
--- modules/TAO/tao/GIOP_Message_Generator_Parser_Impl.h	(revision 79294)
+++ modules/TAO/tao/GIOP_Message_Generator_Parser_Impl.h	(revision 80736)
@@ -41,7 +41,6 @@
 class TAO_Export TAO_GIOP_Message_Generator_Parser_Impl
 {
 public:
-
   /// Performs a check of the revision numbers
   static CORBA::Boolean check_revision (CORBA::Octet incoming_major,
                                         CORBA::Octet incoming_minor);
Index: modules/TAO/tao/operation_details.h
===================================================================
--- modules/TAO/tao/operation_details.h	(revision 79294)
+++ modules/TAO/tao/operation_details.h	(revision 80736)
@@ -174,6 +174,12 @@
   TAO_Reply_Dispatcher *reply_dispatcher (void) const;
   void reply_dispatcher (TAO_Reply_Dispatcher *rd);

+//  void compressed (CORBA::Boolean compressed);
+//  CORBA::Boolean compressed (void) const;
+
+  /// Temporarily @todo remove
+//  CORBA::ULong uncompressed_size_;
+
 private:

   /// Name of the operation being invoked.
@@ -214,6 +220,9 @@
   /// Count of the exceptions that operations can throw.
   CORBA::ULong ex_count_;

+  /// Compressed operation or not
+//  CORBA::Boolean compressed_;
+
   /// Boolean flag to indicate whether in the skeletons the stub arguments
   /// stored in these operation details should be used or not.
   CORBA::Boolean use_stub_args_;
Index: modules/TAO/tao/Pluggable_Messaging_Utils.inl
===================================================================
--- modules/TAO/tao/Pluggable_Messaging_Utils.inl	(revision 79294)
+++ modules/TAO/tao/Pluggable_Messaging_Utils.inl	(revision 80736)
@@ -12,6 +12,7 @@
     is_dsi_ (0),
     dsi_nvlist_align_ (0),
     argument_flag_ (false),
+    compressed_ (false),
     service_context_ (0)
 {
 }
Index: modules/TAO/tao/Remote_Invocation.cpp
===================================================================
--- modules/TAO/tao/Remote_Invocation.cpp	(revision 79294)
+++ modules/TAO/tao/Remote_Invocation.cpp	(revision 80736)
@@ -78,10 +78,8 @@
       // index that we need.
       CORBA::ULong index = 0;
       IOP::IOR *ior_info = 0;
-      int const retval =
-        this->resolver_.stub ()->create_ior_info (ior_info, index);

-      if (retval == -1)
+      if (this->resolver_.stub ()->create_ior_info (ior_info, index) == -1)
         {
           if (TAO_debug_level > 0)
             {
@@ -109,8 +107,7 @@
     // Send the request for the header
     if (this->resolver_.transport ()->generate_request_header (this->details_,
                                                                spec,
-                                                               out_stream)
-        == -1)
+                                                               out_stream) == -1)
       {
         throw ::CORBA::MARSHAL ();
       }
@@ -121,6 +118,7 @@
   void
   Remote_Invocation::marshal_data (TAO_OutputCDR &out_stream)
   {
+    // @todo Invoke compression??
     if (this->details_.marshal_args (out_stream) == false)
       {
         throw ::CORBA::MARSHAL ();
@@ -145,13 +143,13 @@
     if (nph != 0)
       {
         // nph = 0, means DiffServ library is not used
-        // nph = 0, means DiffServ library is used, and
+        // nph = 0, means DiffServ library is used, and
         // request DSCP and reply DSCP are set.
         // Note that the application could still be using
         // RTCORBA, but still setting DIffServ codepoints
         // using the DiffServ library takes precedence.
         //
-        CORBA::Long dscp = nph->get_dscp_codepoint (this->resolver_.stub (),
+        CORBA::Long const dscp = nph->get_dscp_codepoint (this->resolver_.stub (),
           this->resolver_.object ());
         connection_handler->set_dscp_codepoint (dscp);
       }
Index: modules/TAO/tao/Pluggable_Messaging.h
===================================================================
--- modules/TAO/tao/Pluggable_Messaging.h	(revision 79294)
+++ modules/TAO/tao/Pluggable_Messaging.h	(revision 80736)
@@ -161,9 +161,6 @@
   /// request/response?
   virtual int is_ready_for_bidirectional (TAO_OutputCDR &msg) = 0;

-  /// Reset the messaging the object
-  virtual void reset (void) = 0;
-
   /// Header length
   virtual size_t header_length (void) const = 0;

Index: modules/TAO/tao/IIOP_Transport.cpp
===================================================================
--- modules/TAO/tao/IIOP_Transport.cpp	(revision 79294)
+++ modules/TAO/tao/IIOP_Transport.cpp	(revision 80736)
@@ -74,9 +74,7 @@
                           const ACE_Time_Value *max_wait_time)
 {
   ssize_t const retval =
-    this->connection_handler_->peer ().sendv (iov,
-                                              iovcnt,
-                                              max_wait_time);
+    this->connection_handler_->peer ().sendv (iov, iovcnt, max_wait_time);

   if (retval > 0)
     bytes_transferred = retval;
@@ -307,9 +305,9 @@
   // messaging objects are ready to handle bidirectional connections
   // and also make sure that we have not recd. or sent any information
   // regarding this before...
-  if (this->orb_core ()->bidir_giop_policy () &&
-      this->messaging_object_->is_ready_for_bidirectional (msg) &&
-      this->bidirectional_flag () < 0)
+  if (this->bidirectional_flag () < 0 &&
+      this->orb_core ()->bidir_giop_policy () &&
+      this->messaging_object_->is_ready_for_bidirectional (msg))
     {
       this->set_bidir_context_info (opdetails);

@@ -324,14 +322,11 @@
       opdetails.request_id (this->tms ()->request_id ());
     }

-  return TAO_Transport::generate_request_header (opdetails,
-                                                 spec,
-                                                 msg);
+  return TAO_Transport::generate_request_header (opdetails, spec, msg);
 }

 int
-TAO_IIOP_Transport::messaging_init (CORBA::Octet major,
-                                    CORBA::Octet minor)
+TAO_IIOP_Transport::messaging_init (CORBA::Octet major, CORBA::Octet minor)
 {
   this->messaging_object_->init (major, minor);

@@ -409,8 +404,7 @@
     return;

   // Add this info in to the svc_list
-  opdetails.request_service_context ().set_context (IOP::BI_DIR_IIOP,
-                                                    cdr);
+  opdetails.request_service_context ().set_context (IOP::BI_DIR_IIOP, cdr);

   return;
 }
@@ -427,18 +421,15 @@
     return -1;

   // Get the array of endpoints serviced by TAO_IIOP_Acceptor
-  const ACE_INET_Addr *endpoint_addr =
-    iiop_acceptor->endpoints ();
+  const ACE_INET_Addr *endpoint_addr = iiop_acceptor->endpoints ();

   // Get the endpoint count
-  size_t const count =
-    iiop_acceptor->endpoint_count ();
+  size_t const count = iiop_acceptor->endpoint_count ();

   // Get the local address of the connection
   ACE_INET_Addr local_addr;

-  if (this->connection_handler_->peer ().get_local_addr (local_addr)
-      == -1)
+  if (this->connection_handler_->peer ().get_local_addr (local_addr) == -1)
     {
       ACE_ERROR_RETURN ((LM_ERROR,
                          ACE_TEXT ("TAO (%P|%t) - IIOP_Transport::get_listen_point, ")
Index: modules/TAO/tao/GIOP_Message_Generator_Parser_12.cpp
===================================================================
--- modules/TAO/tao/GIOP_Message_Generator_Parser_12.cpp	(revision 79294)
+++ modules/TAO/tao/GIOP_Message_Generator_Parser_12.cpp	(revision 80736)
@@ -89,6 +89,21 @@
   return true;
 }

+/*
+  // We have the ListenPointList at this point. Create a output CDR
+  // stream at this point
+  TAO_OutputCDR cdr;
+
+  // Marshal the information into the stream
+  if ((cdr << ACE_OutputCDR::from_boolean (TAO_ENCAP_BYTE_ORDER) == 0)
+      || (cdr << listen_point_list) == 0)
+    return;
+
+  // Add this info in to the svc_list
+  opdetails.request_service_context ().set_context (IOP::BI_DIR_IIOP,
+                                                    cdr);
+ */
+
 bool
 TAO_GIOP_Message_Generator_Parser_12::write_locate_request_header (
     CORBA::ULong request_id,
@@ -99,8 +114,7 @@
   msg << request_id;

   // Write the target address
-  if (this->marshall_target_spec (spec,
-                                  msg) == false)
+  if (!(this->marshall_target_spec (spec, msg)))
     return false;

   // I dont think we need to align the pointer to an 8 byte boundary
@@ -248,9 +262,12 @@

   request.response_expected ((response_flags > 0));

+  // ?????
+ //request.compressed_ = (response_flags > 0);
+
   // The high bit of the octet has been set if the SyncScope policy
   // value is SYNC_WITH_SERVER.
-  request.sync_with_server ((response_flags == 1));
+  request.sync_with_server (response_flags == 1);

   // Reserved field
   input.skip_bytes (3);
@@ -296,6 +313,8 @@
       this->check_bidirectional_context (request);
     }

+  this->check_compression_context (request);
+
   if (input.length () > 0)
     {
       // Reset the read_ptr to an 8-byte boundary.
@@ -313,7 +332,7 @@
   // Get the stream .
   TAO_InputCDR &msg = request.incoming_stream ();

-  CORBA::Boolean hdr_status = 1;
+  CORBA::Boolean hdr_status = true;

   // Get the request id.
   CORBA::ULong req_id = 0;
@@ -323,8 +342,7 @@
   request.request_id (req_id);

   // Unmarshal the target address field.
-  hdr_status =
-    hdr_status && request.profile ().unmarshall_target_address(msg);
+  hdr_status = hdr_status && request.profile ().unmarshall_target_address(msg);

   // Reset the pointer to an 8-byte bouns]dary
   msg.align_read_ptr (TAO_GIOP_MESSAGE_ALIGN_PTR);
@@ -337,17 +355,17 @@
     TAO_InputCDR &cdr,
     TAO_Pluggable_Reply_Params &params)
 {
-  if (TAO_GIOP_Message_Generator_Parser::parse_reply (cdr,
-                                                      params) == -1)
-
+  if (TAO_GIOP_Message_Generator_Parser::parse_reply (cdr, params) == -1)
     return -1;

   if ((cdr >> params.svc_ctx_) == 0)
     {
-      // if (TAO_debug_level > 0)
-        ACE_ERROR ((LM_ERROR,
-                    ACE_TEXT ("TAO (%P|%t) parse_reply, ")
-                    ACE_TEXT ("extracting context\n")));
+      if (TAO_debug_level)
+        {
+          ACE_ERROR ((LM_ERROR,
+                      ACE_TEXT ("TAO (%P|%t) parse_reply, ")
+                      ACE_TEXT ("extracting context\n")));
+        }

       return -1;
     }
@@ -454,7 +472,7 @@
             if (TAO_debug_level)
               {
                 ACE_DEBUG ((LM_DEBUG,
-                            ACE_TEXT ("(%N |%l) Unable to handle this request \n")));
+                            ACE_TEXT ("(%N |%l) Unable to handle this request\n")));
               }
             return false;
           }
@@ -467,7 +485,7 @@

         // Get the IOR
         IOP::IOR *ior = 0;
-        CORBA::ULong index = spec.iop_ior (ior);
+        CORBA::ULong const index = spec.iop_ior (ior);

         if (ior)
           {
@@ -484,7 +502,7 @@
                 ACE_DEBUG ((LM_DEBUG,
                             ACE_TEXT ("(%N |%l) Unable to handle this request \n")));
               }
-            return 0;
+            return false;
           }
         break;
       }
@@ -492,7 +510,7 @@
       if (TAO_debug_level)
         {
           ACE_DEBUG ((LM_DEBUG,
-                      ACE_TEXT ("(%N |%l) Unable to handle this request \n")));
+                      ACE_TEXT ("(%N |%l) Unable to handle this request\n")));
         }
       return false;
     }
@@ -519,6 +537,23 @@
 }

 bool
+TAO_GIOP_Message_Generator_Parser_12::check_compression_context (
+    TAO_ServerRequest &request)
+{
+  TAO_Service_Context &service_context = request.request_service_context ();
+
+  // Check whether we have the BiDir service context info available in
+  // the ServiceContextList
+  if (service_context.is_service_id (IOP::TAG_ZIOP_COMPONENT))
+    {
+      return this->process_compression_context (service_context, request);
+    }
+
+  return false;
+}
+
+
+bool
 TAO_GIOP_Message_Generator_Parser_12::process_bidir_context (
     TAO_Service_Context &service_context,
     TAO_Transport *transport)
@@ -539,6 +574,49 @@
   return transport->tear_listen_point_list (cdr);
 }

+bool
+TAO_GIOP_Message_Generator_Parser_12::process_compression_context (
+    TAO_Service_Context &service_context,
+    TAO_ServerRequest &request)
+{
+  // Get the context info
+  IOP::ServiceContext context;
+  context.context_id = IOP::TAG_ZIOP_COMPONENT;
+
+  if (service_context.get_context (context) != 1)
+      ACE_ERROR_RETURN ((LM_ERROR,
+                         ACE_TEXT ("(%P|%t) Context info not found \n")),
+                        false);
+
+  TAO_InputCDR cdr (reinterpret_cast<const char*> (
+                      context.context_data.get_buffer ()),
+                      context.context_data.length ());
+
+  CORBA::Boolean byte_order;
+  if ((cdr >> ACE_InputCDR::to_boolean (byte_order)) == 0)
+    return false;
+
+  cdr.reset_byte_order (static_cast<int> (byte_order));
+
+  CORBA::ULong message_length = 0;
+  if (!(cdr >> message_length))
+    return false;
+
+    // @TODO use real typedef
+  CORBA::UShort compressorid = 0;
+  if (!(cdr >> compressorid))
+    return false;
+
+//   request.original_message_length_ = message_length;
+ACE_DEBUG ((LM_DEBUG, "Received compressor %d\n", compressorid));
+//+  request.compressed_ = true;
+//+  request.original_message_length_ = message_length;
+//+
+
+  return true;
+}
+
+
 size_t
 TAO_GIOP_Message_Generator_Parser_12::fragment_header_length (void) const
 {
Index: modules/TAO/tao/GIOP_Message_State.inl
===================================================================
--- modules/TAO/tao/GIOP_Message_State.inl	(revision 79294)
+++ modules/TAO/tao/GIOP_Message_State.inl	(revision 80736)
@@ -11,10 +11,12 @@
     byte_order_ (0),
     message_type_ (TAO_PLUGGABLE_MESSAGE_REQUEST),
     payload_size_ (0),
-    more_fragments_ (0)
+    more_fragments_ (false),
+    compressed_ (false)
 {
 }

+
 ACE_INLINE CORBA::ULong
 TAO_GIOP_Message_State::message_size (void) const
 {
@@ -57,4 +59,10 @@
   return this->giop_version_;
 }

+ACE_INLINE CORBA::Boolean
+TAO_GIOP_Message_State::compressed (void) const
+{
+  return this->compressed_;
+}
+
 TAO_END_VERSIONED_NAMESPACE_DECL
Index: modules/TAO/tao/Synch_Invocation.cpp
===================================================================
--- modules/TAO/tao/Synch_Invocation.cpp	(revision 79294)
+++ modules/TAO/tao/Synch_Invocation.cpp	(revision 80736)
@@ -15,6 +15,7 @@
 #include "tao/ORB_Core.h"
 #include "tao/Service_Context.h"
 #include "tao/SystemException.h"
+#include "tao/ZIOP_Adapter.h"

 #if TAO_HAS_INTERCEPTORS == 1
 # include "tao/PortableInterceptorC.h"
@@ -84,9 +85,17 @@
                                 TAO_Transport::TAO_TWOWAY_REQUEST,
                                 max_wait_time);

+        TAO_OutputCDR second;
+        this->orb_core()->ziop_adapter ()->compress (*this->orb_core(), this->details_, second);
+
         this->write_header (tspec, cdr);

-        this->marshal_data (cdr);
+//        this->marshal_data (cdr);
+        //ACE_CDR::consolidate (&cdr, &second);
+        cdr.write_octet_array_mb (second.begin ());
+        cdr.compressed (true);
+        //cdr.current ()->next (second.
+        //cdr.

         // Register a reply dispatcher for this invocation. Use the
         // preallocated reply dispatcher.
@@ -644,9 +653,11 @@
                                 TAO_Transport::TAO_ONEWAY_REQUEST,
                                 max_wait_time);

+        this->orb_core()->ziop_adapter ()->compress (*this->orb_core(), this->details_, cdr);
+
         this->write_header (tspec, cdr);

-        this->marshal_data (cdr);
+        //this->marshal_data (cdr);

         countdown.update ();


