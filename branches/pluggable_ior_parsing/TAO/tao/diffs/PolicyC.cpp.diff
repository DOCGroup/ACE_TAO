--- orig/PolicyC.cpp	Thu Jun 15 14:01:44 2000
+++ PolicyC.cpp	Wed Jun  7 13:29:46 2000
@@ -1,78 +1,72 @@
-/* -*- C++ -*- $Id$ */
+// $Id$
+
+/* -*- C++ -*- */
 
 // ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
-// TAO and the TAO IDL Compiler have been developed by the Center for
-// Distributed Object Computing at Washington University, St. Louis.
+// TAO ORB and the TAO IDL Compiler have been developed by Washington
+// University Computer Science's Distributed Object Computing Group.
 //
-// Information about TAO is available at:
+// Information on TAO is available at
 //                 http://www.cs.wustl.edu/~schmidt/TAO.html
 
-#include "PolicyC.h"
+#include "tao/PolicyC.h"
+#include "tao/Stub.h"
+#include "tao/Servant_Base.h"
+#include "tao/POA_CORBA.h"
+#include "tao/Invocation.h"
 
 #if !defined (__ACE_INLINE__)
 #include "PolicyC.i"
 #endif /* !defined INLINE */
 
-static const CORBA::Long _oc_CORBA_PolicyErrorCode[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x4572726f), ACE_NTOHL (0x72436f64), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/PolicyErrorCode:1.0
-  16, ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63794572), ACE_NTOHL (0x726f7243), ACE_NTOHL (0x6f646500),  // name = PolicyErrorCode
-  CORBA::tk_short,
-
-};
-static CORBA::TypeCode _tc_TAO_tc_CORBA_PolicyErrorCode (CORBA::tk_alias, sizeof (_oc_CORBA_PolicyErrorCode), (char *) &_oc_CORBA_PolicyErrorCode, 0, sizeof (CORBA::PolicyErrorCode));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (CORBA)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PolicyErrorCode, &_tc_TAO_tc_CORBA_PolicyErrorCode)
-TAO_NAMESPACE_END
-TAO_NAMESPACE_TYPE (const CORBA::Short)
+ACE_RCSID(tao, PolicyC, "$Id$")
+
+// ****************************************************************
+
+TAO_NAMESPACE_TYPE (const CORBA::PolicyErrorCode)
 TAO_NAMESPACE_BEGIN (CORBA)
-TAO_NAMESPACE_DEFINE (const CORBA::Short, BAD_POLICY, 0)
+TAO_NAMESPACE_DEFINE (const CORBA::PolicyErrorCode, BAD_POLICY, 0)
 TAO_NAMESPACE_END
-TAO_NAMESPACE_TYPE (const CORBA::Short)
+TAO_NAMESPACE_TYPE (const CORBA::PolicyErrorCode)
 TAO_NAMESPACE_BEGIN (CORBA)
-TAO_NAMESPACE_DEFINE (const CORBA::Short, UNSUPPORTED_POLICY, 1)
+TAO_NAMESPACE_DEFINE (const CORBA::PolicyErrorCode, UNSUPPORTED_POLICY, 1)
 TAO_NAMESPACE_END
-TAO_NAMESPACE_TYPE (const CORBA::Short)
+TAO_NAMESPACE_TYPE (const CORBA::PolicyErrorCode)
 TAO_NAMESPACE_BEGIN (CORBA)
-TAO_NAMESPACE_DEFINE (const CORBA::Short, BAD_POLICY_TYPE, 2)
+TAO_NAMESPACE_DEFINE (const CORBA::PolicyErrorCode, BAD_POLICY_TYPE, 2)
 TAO_NAMESPACE_END
-TAO_NAMESPACE_TYPE (const CORBA::Short)
+TAO_NAMESPACE_TYPE (const CORBA::PolicyErrorCode)
 TAO_NAMESPACE_BEGIN (CORBA)
-TAO_NAMESPACE_DEFINE (const CORBA::Short, BAD_POLICY_VALUE, 3)
+TAO_NAMESPACE_DEFINE (const CORBA::PolicyErrorCode, BAD_POLICY_VALUE, 3)
 TAO_NAMESPACE_END
-TAO_NAMESPACE_TYPE (const CORBA::Short)
+TAO_NAMESPACE_TYPE (const CORBA::PolicyErrorCode)
 TAO_NAMESPACE_BEGIN (CORBA)
-TAO_NAMESPACE_DEFINE (const CORBA::Short, UNSUPPORTED_POLICY_VALUE, 4)
+TAO_NAMESPACE_DEFINE (const CORBA::PolicyErrorCode, UNSUPPORTED_POLICY_VALUE, 4)
 TAO_NAMESPACE_END
+
+// ****************************************************************
+
 // default constructor
-CORBA::PolicyError::PolicyError (void)
-  : CORBA_UserException (::CORBA::_tc_PolicyError)
+CORBA_PolicyError::CORBA_PolicyError (void)
+  : CORBA_UserException (CORBA::_tc_PolicyError)
 {
 }
 
 // destructor - all members are of self managing types
-CORBA::PolicyError::~PolicyError (void)
+CORBA_PolicyError::~CORBA_PolicyError (void)
 {
 }
 
-void CORBA::PolicyError::_tao_any_destructor (void *x)
-{
-  PolicyError *tmp = ACE_static_cast (PolicyError*,x);
-  delete tmp;
-}
-
 // copy constructor
-CORBA::PolicyError::PolicyError (const ::CORBA::PolicyError &_tao_excp)
+CORBA_PolicyError::CORBA_PolicyError (const CORBA_PolicyError &_tao_excp)
   : CORBA_UserException (_tao_excp._type ())
 {
     this->reason = _tao_excp.reason;
 }
 
 // assignment operator
-CORBA::PolicyError&
-CORBA::PolicyError::operator= (const ::CORBA::PolicyError &_tao_excp)
+CORBA_PolicyError&
+CORBA_PolicyError::operator= (const CORBA_PolicyError &_tao_excp)
 {
 
   this->CORBA_UserException::operator= (_tao_excp);
@@ -81,35 +75,30 @@
 }
 
 // narrow
-CORBA::PolicyError *
-CORBA::PolicyError::_downcast (CORBA::Exception *exc)
+CORBA_PolicyError_ptr
+CORBA_PolicyError::_downcast (CORBA::Exception *exc)
 {
   if (!ACE_OS::strcmp ("IDL:omg.org/CORBA/PolicyError:1.0", exc->_id ())) // same type
-    return ACE_dynamic_cast (PolicyError *, exc);
+    return ACE_dynamic_cast (CORBA_PolicyError_ptr, exc);
   else
     return 0;
 }
 
-
-void CORBA::PolicyError::_raise ()
+void CORBA_PolicyError::_raise (void)
 {
   TAO_RAISE(*this);
 }
 
-
-void CORBA::PolicyError::_tao_encode (
-    TAO_OutputCDR &cdr,
-    CORBA::Environment &ACE_TRY_ENV) const
+void CORBA_PolicyError::_tao_encode (TAO_OutputCDR &cdr,
+                                     CORBA::Environment &ACE_TRY_ENV) const
 {
   if (cdr << *this)
     return;
   ACE_THROW (CORBA::MARSHAL ());
 }
 
-
-void CORBA::PolicyError::_tao_decode (
-    TAO_InputCDR &cdr,
-    CORBA::Environment &ACE_TRY_ENV)
+void CORBA_PolicyError::_tao_decode (TAO_InputCDR &cdr,
+                                     CORBA::Environment &ACE_TRY_ENV)
 {
   if (cdr >> *this)
     return;
@@ -117,165 +106,47 @@
 }
 
 // TAO extension - the _alloc method
-CORBA::Exception *CORBA::PolicyError::_alloc (void)
+CORBA::Exception *CORBA_PolicyError::_alloc (void)
 {
   CORBA::Exception *retval = 0;
-  ACE_NEW_RETURN (retval, ::CORBA::PolicyError, 0);
+
+  ACE_NEW_RETURN (retval,
+                  CORBA_PolicyError,
+                  0);
   return retval;
 }
 
-CORBA::PolicyError::PolicyError (
-  CORBA::PolicyErrorCode _tao_reason
-)
+CORBA_PolicyError::CORBA_PolicyError(
+  CORBA::PolicyErrorCode _tao_reason)
+
   : CORBA_UserException  (CORBA::TypeCode::_duplicate (CORBA::_tc_PolicyError))
 {
     this->reason = _tao_reason;
 }
 
-static const CORBA::Long _oc_CORBA_PolicyError[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x4572726f), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/PolicyError:1.0
-  12, ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63794572), ACE_NTOHL (0x726f7200),  // name = PolicyError
-  1, // member count
-  7, ACE_NTOHL (0x72656173), ACE_NTOHL (0x6f6e0000),  // name = reason
-  CORBA::tk_alias, // typecode kind for typedefs
-  72, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x4572726f), ACE_NTOHL (0x72436f64), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/PolicyErrorCode:1.0
-    16, ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63794572), ACE_NTOHL (0x726f7243), ACE_NTOHL (0x6f646500),  // name = PolicyErrorCode
-    CORBA::tk_short,
-
-
-};
-static CORBA::TypeCode _tc_TAO_tc_CORBA_PolicyError (CORBA::tk_except, sizeof (_oc_CORBA_PolicyError), (char *) &_oc_CORBA_PolicyError, 0, sizeof (CORBA::PolicyError));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (CORBA)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PolicyError, &_tc_TAO_tc_CORBA_PolicyError)
-TAO_NAMESPACE_END
-
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  
-#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_INVALIDPOLICIES__TAO_SEQ_USHORT_CS_)
-#define __TAO_UNBOUNDED_SEQUENCE_CORBA_INVALIDPOLICIES__TAO_SEQ_USHORT_CS_
-
-  void
-  CORBA::InvalidPolicies::_TAO_Unbounded_Sequence_CORBA_InvalidPolicies__tao_seq_UShort::_allocate_buffer (CORBA::ULong length)
-  {
-    CORBA::UShort* tmp = 0;
-    tmp = _TAO_Unbounded_Sequence_CORBA_InvalidPolicies__tao_seq_UShort::allocbuf (length);
-    
-    if (this->buffer_ != 0)
-    {
-      CORBA::UShort *old = ACE_reinterpret_cast (CORBA::UShort *,this->buffer_);
-      
-      for (CORBA::ULong i = 0; i < this->length_; ++i)
-        tmp[i] = old[i];
-      
-      if (this->release_)
-        _TAO_Unbounded_Sequence_CORBA_InvalidPolicies__tao_seq_UShort::freebuf (old);
-      
-    }
-    this->buffer_ = tmp;
-  }
-  
-  void
-  CORBA::InvalidPolicies::_TAO_Unbounded_Sequence_CORBA_InvalidPolicies__tao_seq_UShort::_deallocate_buffer (void)
-  {
-    if (this->buffer_ == 0 || this->release_ == 0)
-      return;
-    
-    CORBA::UShort *tmp = ACE_reinterpret_cast (CORBA::UShort *,this->buffer_);
-    
-    _TAO_Unbounded_Sequence_CORBA_InvalidPolicies__tao_seq_UShort::freebuf (tmp);
-    this->buffer_ = 0;
-  } 
-  
-  CORBA::InvalidPolicies::_TAO_Unbounded_Sequence_CORBA_InvalidPolicies__tao_seq_UShort::~_TAO_Unbounded_Sequence_CORBA_InvalidPolicies__tao_seq_UShort (void) // Dtor.
-  {
-    this->_deallocate_buffer ();
-  }
-  
-  
-#endif /* end #if !defined */
-
-
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
-
-#if !defined (_CORBA_INVALIDPOLICIES__TAO_SEQ_USHORT_CS_)
-#define _CORBA_INVALIDPOLICIES__TAO_SEQ_USHORT_CS_
-
-// *************************************************************
-// CORBA::InvalidPolicies::_tao_seq_UShort
-// *************************************************************
-
-CORBA::InvalidPolicies::_tao_seq_UShort::_tao_seq_UShort (void)
-{}
-CORBA::InvalidPolicies::_tao_seq_UShort::_tao_seq_UShort (CORBA::ULong max) // uses max size
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Sequence_CORBA_InvalidPolicies__tao_seq_UShort
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<CORBA::UShort>
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (max)
-{}
-CORBA::InvalidPolicies::_tao_seq_UShort::_tao_seq_UShort (CORBA::ULong max, CORBA::ULong length, CORBA::UShort *buffer, CORBA::Boolean release)
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Sequence_CORBA_InvalidPolicies__tao_seq_UShort
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<CORBA::UShort>
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (max, length, buffer, release)
-{}
-CORBA::InvalidPolicies::_tao_seq_UShort::_tao_seq_UShort (const _tao_seq_UShort &seq) // copy ctor
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Sequence_CORBA_InvalidPolicies__tao_seq_UShort
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<CORBA::UShort>
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (seq)
-{}
-CORBA::InvalidPolicies::_tao_seq_UShort::~_tao_seq_UShort (void) // dtor
-{}
-void CORBA::InvalidPolicies::_tao_seq_UShort::_tao_any_destructor (void *x)
-{
-  _tao_seq_UShort *tmp = ACE_static_cast (_tao_seq_UShort*,x);
-  delete tmp;
-}
-
-
-#endif /* end #if !defined */
+// ****************************************************************
 
 // default constructor
-CORBA::InvalidPolicies::InvalidPolicies (void)
-  : CORBA_UserException (::CORBA::_tc_InvalidPolicies)
+CORBA_InvalidPolicies::CORBA_InvalidPolicies (void)
+  : CORBA_UserException (CORBA::_tc_InvalidPolicies)
 {
 }
 
 // destructor - all members are of self managing types
-CORBA::InvalidPolicies::~InvalidPolicies (void)
+CORBA_InvalidPolicies::~CORBA_InvalidPolicies (void)
 {
 }
 
-void CORBA::InvalidPolicies::_tao_any_destructor (void *x)
-{
-  InvalidPolicies *tmp = ACE_static_cast (InvalidPolicies*,x);
-  delete tmp;
-}
-
 // copy constructor
-CORBA::InvalidPolicies::InvalidPolicies (const ::CORBA::InvalidPolicies &_tao_excp)
+CORBA_InvalidPolicies::CORBA_InvalidPolicies (const CORBA_InvalidPolicies &_tao_excp)
   : CORBA_UserException (_tao_excp._type ())
 {
     this->indices = _tao_excp.indices;
 }
 
 // assignment operator
-CORBA::InvalidPolicies&
-CORBA::InvalidPolicies::operator= (const ::CORBA::InvalidPolicies &_tao_excp)
+CORBA_InvalidPolicies&
+CORBA_InvalidPolicies::operator= (const CORBA_InvalidPolicies &_tao_excp)
 {
 
   this->CORBA_UserException::operator= (_tao_excp);
@@ -284,35 +155,30 @@
 }
 
 // narrow
-CORBA::InvalidPolicies *
-CORBA::InvalidPolicies::_downcast (CORBA::Exception *exc)
+CORBA_InvalidPolicies_ptr
+CORBA_InvalidPolicies::_downcast (CORBA::Exception *exc)
 {
   if (!ACE_OS::strcmp ("IDL:omg.org/CORBA/InvalidPolicies:1.0", exc->_id ())) // same type
-    return ACE_dynamic_cast (InvalidPolicies *, exc);
+    return ACE_dynamic_cast (CORBA_InvalidPolicies_ptr, exc);
   else
     return 0;
 }
 
-
-void CORBA::InvalidPolicies::_raise ()
+void CORBA_InvalidPolicies::_raise (void)
 {
   TAO_RAISE(*this);
 }
 
-
-void CORBA::InvalidPolicies::_tao_encode (
-    TAO_OutputCDR &cdr,
-    CORBA::Environment &ACE_TRY_ENV) const
+void CORBA_InvalidPolicies::_tao_encode (TAO_OutputCDR &cdr,
+                                         CORBA::Environment &ACE_TRY_ENV) const
 {
   if (cdr << *this)
     return;
   ACE_THROW (CORBA::MARSHAL ());
 }
 
-
-void CORBA::InvalidPolicies::_tao_decode (
-    TAO_InputCDR &cdr,
-    CORBA::Environment &ACE_TRY_ENV)
+void CORBA_InvalidPolicies::_tao_decode (TAO_InputCDR &cdr,
+                                         CORBA::Environment &ACE_TRY_ENV)
 {
   if (cdr >> *this)
     return;
@@ -320,269 +186,143 @@
 }
 
 // TAO extension - the _alloc method
-CORBA::Exception *CORBA::InvalidPolicies::_alloc (void)
+CORBA::Exception *CORBA_InvalidPolicies::_alloc (void)
 {
   CORBA::Exception *retval = 0;
-  ACE_NEW_RETURN (retval, ::CORBA::InvalidPolicies, 0);
+
+  ACE_NEW_RETURN (retval,
+                  CORBA_InvalidPolicies,
+                  0);
+
   return retval;
 }
 
-CORBA::InvalidPolicies::InvalidPolicies (
-  const CORBA::InvalidPolicies::_tao_seq_UShort & _tao_indices
-)
+CORBA_InvalidPolicies::CORBA_InvalidPolicies(
+  const CORBA_InvalidPolicies::_tao_seq_UShort & _tao_indices)
+
   : CORBA_UserException  (CORBA::TypeCode::_duplicate (CORBA::_tc_InvalidPolicies))
 {
     this->indices = _tao_indices;
 }
 
-static const CORBA::Long _oc_CORBA_InvalidPolicies[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f496e), ACE_NTOHL (0x76616c69), ACE_NTOHL (0x64506f6c), ACE_NTOHL (0x69636965), ACE_NTOHL (0x733a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/InvalidPolicies:1.0
-  16, ACE_NTOHL (0x496e7661), ACE_NTOHL (0x6c696450), ACE_NTOHL (0x6f6c6963), ACE_NTOHL (0x69657300),  // name = InvalidPolicies
-  1, // member count
-  8, ACE_NTOHL (0x696e6469), ACE_NTOHL (0x63657300),  // name = indices
-  CORBA::tk_sequence, // typecode kind
-  12, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    CORBA::tk_ushort,
-
-    0U,
-
-};
-static CORBA::TypeCode _tc_TAO_tc_CORBA_InvalidPolicies (CORBA::tk_except, sizeof (_oc_CORBA_InvalidPolicies), (char *) &_oc_CORBA_InvalidPolicies, 0, sizeof (CORBA::InvalidPolicies));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (CORBA)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_InvalidPolicies, &_tc_TAO_tc_CORBA_InvalidPolicies)
-TAO_NAMESPACE_END
-static const CORBA::Long _oc_CORBA_PolicyType[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x54797065), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/PolicyType:1.0
-  11, ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63795479), ACE_NTOHL (0x70650000),  // name = PolicyType
-  CORBA::tk_ulong,
-
-};
-static CORBA::TypeCode _tc_TAO_tc_CORBA_PolicyType (CORBA::tk_alias, sizeof (_oc_CORBA_PolicyType), (char *) &_oc_CORBA_PolicyType, 0, sizeof (CORBA::PolicyType));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (CORBA)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PolicyType, &_tc_TAO_tc_CORBA_PolicyType)
-TAO_NAMESPACE_END
-
-// default constructor
-CORBA::Policy::Policy (void)
-{}
-
-// destructor
-CORBA::Policy::~Policy (void)
-{}
-
-void CORBA::Policy::_tao_any_destructor (void *x)
-{
-  Policy *tmp = ACE_static_cast (Policy*,x);
-  CORBA::release (tmp);
-}
+// ****************************************************************
 
-CORBA::Policy_ptr CORBA::Policy::_narrow (
+CORBA_Policy_ptr CORBA_Policy::_narrow (
     CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
 {
   if (CORBA::is_nil (obj))
-    return Policy::_nil ();
-  if (! obj->_is_local ())
-    {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/Policy:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (Policy::_nil ());
-      if (is_a == 0)
-        return Policy::_nil ();
-    }
-  return Policy::_unchecked_narrow (obj, ACE_TRY_ENV);
-}
-
-CORBA::Policy_ptr CORBA::Policy::_unchecked_narrow (
-    CORBA::Object_ptr obj,
-    CORBA::Environment &
-  )
-{
-  if (CORBA::is_nil (obj))
-    return Policy::_nil ();
-  if (! obj->_is_local ())
-    {
-      TAO_Stub* stub = obj->_stubobj ();
-      if (stub)
-        stub->_incr_refcnt ();
-      Policy_ptr default_proxy = Policy::_nil ();
-
-      if (obj->_is_collocated () && _TAO_collocation_CORBA_Policy_Stub_Factory_function_pointer != 0)
-        {
-          default_proxy = _TAO_collocation_CORBA_Policy_Stub_Factory_function_pointer (obj);
-        }
-      if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, Policy (stub), Policy::_nil ());
-      #if (TAO_HAS_SMART_PROXIES == 1)
-        return TAO_CORBA_Policy_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
-      #else 
-        return default_proxy;
-      #endif /*TAO_HAS_SMART_PROXIES == 1*/
-    }
-  else 
-    return
-      ACE_reinterpret_cast
-        (
-          Policy_ptr,
-            obj->_tao_QueryInterface
-              (
-                ACE_reinterpret_cast
-                  (
-                    ptr_arith_t,
-                    &Policy::_narrow
-                  )
-              )
-        );
-}
+    return CORBA_Policy::_nil ();
+  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/Policy:1.0", ACE_TRY_ENV);
+  ACE_CHECK_RETURN (CORBA_Policy::_nil ());
+  if (is_a == 0)
+    return CORBA_Policy::_nil ();
+  TAO_Stub* stub = obj->_stubobj ();
+  void* servant = 0;
+  if (obj->_is_collocated () && obj->_servant() != 0)
+    servant = obj->_servant()->_downcast ("IDL:omg.org/CORBA/Policy:1.0");
+#if defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
+  if (servant == 0)
+    ACE_THROW_RETURN (CORBA::MARSHAL (), CORBA::Policy::_nil ());
+#else
+  stub->_incr_refcnt ();
+  if (servant == 0)
+    {
+      CORBA_Policy_ptr rval =
+        CORBA_Policy::_nil ();
+
+      ACE_NEW_RETURN (rval,
+                      CORBA_Policy (stub),
+                      CORBA_Policy::_nil ());
+
+      return rval;
+    }
+
+#endif /* TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */
+
+  CORBA_Policy_ptr retval =
+    CORBA_Policy::_nil ();
+
+  ACE_NEW_RETURN (
+      retval,
+      POA_CORBA::_tao_collocated_Policy (
+          ACE_reinterpret_cast (POA_CORBA::Policy_ptr,
+                                servant),
+          stub
+        ),
+      CORBA_Policy::_nil ()
+    );
 
-CORBA::Policy_ptr
-CORBA::Policy::_duplicate (Policy_ptr obj)
-{
-  if (!CORBA::is_nil (obj))
-    obj->_add_ref ();
-  return obj;
+  return retval;
 }
 
-CORBA::PolicyType CORBA::Policy::policy_type (
+#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
+CORBA::PolicyType CORBA_Policy::policy_type (
     CORBA::Environment &ACE_TRY_ENV
   )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  CORBA::PolicyType _tao_retval = 0;
-  
-  
+{
+    CORBA::PolicyType _tao_retval = 0;
+
   TAO_Stub *istub = this->_stubobj ();
   if (istub == 0)
     ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
 
-  
+
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
-      "_get_policy_type",
+      "_get_""policy_type",
       16,
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-    TAO_ClientRequestInterceptor_Adapter
-      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
-    ACE_CHECK_RETURN  (_tao_retval);
-    PortableInterceptor::Cookies _tao_cookies;
-    CORBA::NVList_var _tao_interceptor_args;
-    if (_tao_vfr.valid ())
-      {
-        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
-        ACE_CHECK_RETURN  (_tao_retval);
-      }
-
-    ACE_TRY
-      {
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      for (;;)
-      {
-        _tao_call.start (ACE_TRY_ENV);
-        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-
-        TAO_INTERCEPTOR (
-            _tao_vfr.preinvoke (
-                _tao_call.request_id (),
-                1,
-                this,
-                "_get_policy_type",
-                _tao_call.service_info (),
-                _tao_interceptor_args.inout (),
-                _tao_cookies,
-                ACE_TRY_ENV
-              )
-          );
-        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-        CORBA::Short flag = TAO_TWOWAY_RESPONSE_FLAG;
-        
-        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
-        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-
-        int _invoke_status =
-          _tao_call.invoke (0, 0, ACE_TRY_ENV);
-                TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-
-        if (_invoke_status == TAO_INVOKE_RESTART)
-          continue;
-        if (_invoke_status != TAO_INVOKE_OK)
-        {
-          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
-
-        }
-        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-        if (!(
-              (_tao_in >> _tao_retval)
-          ))
-          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
-
-        TAO_INTERCEPTOR (
-            _tao_vfr.postinvoke (
-                _tao_call.request_id (),
-                1,
-                this,
-                "_get_policy_type",
-                _tao_call.service_info (),
-                _tao_interceptor_args.inout (),
-                _tao_cookies,
-                ACE_TRY_ENV
-              )
-          );
-        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
-        break;
-        
-      }
-#if (TAO_HAS_INTERCEPTORS == 1)
-      
-    }
-  ACE_CATCHANY
+
+  for (;;)
+  {
+    _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (_tao_retval);
+
+    CORBA::Short flag = TAO_TWOWAY_RESPONSE_FLAG;
+
+    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
+                              ACE_TRY_ENV);
+    ACE_CHECK_RETURN (_tao_retval);
+
+    int _invoke_status =
+      _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (_tao_retval);
+
+    if (_invoke_status == TAO_INVOKE_RESTART)
+      continue;
+    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
+      // cannot happen
+    if (_invoke_status != TAO_INVOKE_OK)
     {
-      _tao_vfr.exception_occurred (
-          _tao_call.request_id (),
-          1,
-          this,
-          "_get_policy_type",
-          _tao_cookies,
-          ACE_TRY_ENV
-        );
-      ACE_RETHROW;
+      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
+
     }
-  ACE_ENDTRY;
-  ACE_CHECK_RETURN  (_tao_retval);
-#endif /* TAO_HAS_INTERCEPTORS */
+    break;
+
+  }
+  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+  if (!(
+        (_tao_in >> _tao_retval)
+    ))
+    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
   return _tao_retval;
 }
 
-CORBA::Policy_ptr CORBA::Policy::copy (
+CORBA_Policy_ptr CORBA_Policy::copy (
     CORBA::Environment &ACE_TRY_ENV
   )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  CORBA::Policy_ptr _tao_retval = CORBA::Policy::_nil ();
-  CORBA::Policy_var _tao_safe_retval (_tao_retval);
-  
-  
+{
+    CORBA_Policy_ptr _tao_retval = CORBA_Policy::_nil ();
+
   TAO_Stub *istub = this->_stubobj ();
   if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
+    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);
+
 
-  
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
       "copy",
@@ -590,115 +330,52 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-    TAO_ClientRequestInterceptor_Adapter
-      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
-    ACE_CHECK_RETURN (0);
-    PortableInterceptor::Cookies _tao_cookies;
-    CORBA::NVList_var _tao_interceptor_args;
-    if (_tao_vfr.valid ())
-      {
-        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
-        ACE_CHECK_RETURN (0);
-      }
-
-    ACE_TRY
-      {
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      for (;;)
-      {
-        _tao_call.start (ACE_TRY_ENV);
-        TAO_INTERCEPTOR_CHECK_RETURN (0);
-
-        TAO_INTERCEPTOR (
-            _tao_vfr.preinvoke (
-                _tao_call.request_id (),
-                1,
-                this,
-                "copy",
-                _tao_call.service_info (),
-                _tao_interceptor_args.inout (),
-                _tao_cookies,
-                ACE_TRY_ENV
-              )
-          );
-        TAO_INTERCEPTOR_CHECK_RETURN (0);
-        CORBA::Short flag = TAO_TWOWAY_RESPONSE_FLAG;
-        
-        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
-        TAO_INTERCEPTOR_CHECK_RETURN (0);
-
-        int _invoke_status =
-          _tao_call.invoke (0, 0, ACE_TRY_ENV);
-                TAO_INTERCEPTOR_CHECK_RETURN (0);
-
-        if (_invoke_status == TAO_INVOKE_RESTART)
-          continue;
-        if (_invoke_status != TAO_INVOKE_OK)
-        {
-          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);
-
-        }
-        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-        if (!(
-              (_tao_in >> _tao_safe_retval.inout ())
-          ))
-          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);
-
-        TAO_INTERCEPTOR (
-            _tao_vfr.postinvoke (
-                _tao_call.request_id (),
-                1,
-                this,
-                "copy",
-                _tao_call.service_info (),
-                _tao_interceptor_args.inout (),
-                _tao_cookies,
-                ACE_TRY_ENV
-              )
-          );
-        TAO_INTERCEPTOR_CHECK_RETURN (0);
-        break;
-        
-      }
-#if (TAO_HAS_INTERCEPTORS == 1)
-      
-    }
-  ACE_CATCHANY
+
+  for (;;)
+  {
+    _tao_call.start (ACE_TRY_ENV);
+        ACE_CHECK_RETURN (_tao_retval);
+
+    CORBA::Short flag = TAO_TWOWAY_RESPONSE_FLAG;
+
+    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
+                              ACE_TRY_ENV);
+    ACE_CHECK_RETURN (_tao_retval);
+
+    int _invoke_status =
+      _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK_RETURN (_tao_retval);
+
+    if (_invoke_status == TAO_INVOKE_RESTART)
+      continue;
+    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
+      // cannot happen
+    if (_invoke_status != TAO_INVOKE_OK)
     {
-      _tao_vfr.exception_occurred (
-          _tao_call.request_id (),
-          1,
-          this,
-          "copy",
-          _tao_cookies,
-          ACE_TRY_ENV
-        );
-      ACE_RETHROW;
+      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
+
     }
-  ACE_ENDTRY;
-  ACE_CHECK_RETURN (0);
-#endif /* TAO_HAS_INTERCEPTORS */
-  return _tao_safe_retval._retn ();
+    break;
+
+  }
+  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
+  if (!(
+        (_tao_in >> _tao_retval)
+    ))
+    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
+  return _tao_retval;
 }
 
-void CORBA::Policy::destroy (
+void CORBA_Policy::destroy (
     CORBA::Environment &ACE_TRY_ENV
   )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
 {
-  
 
-  
-  
   TAO_Stub *istub = this->_stubobj ();
   if (istub == 0)
     ACE_THROW (CORBA::INTERNAL ());
 
-  
+
   TAO_GIOP_Twoway_Invocation _tao_call (
       istub,
       "destroy",
@@ -706,1109 +383,336 @@
       istub->orb_core ()
     );
 
-#if (TAO_HAS_INTERCEPTORS == 1)
-    TAO_ClientRequestInterceptor_Adapter
-      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
-    ACE_CHECK;
-    PortableInterceptor::Cookies _tao_cookies;
-    CORBA::NVList_var _tao_interceptor_args;
-    if (_tao_vfr.valid ())
-      {
-        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
+
+  for (;;)
+  {
+    _tao_call.start (ACE_TRY_ENV);
         ACE_CHECK;
-      }
 
-    ACE_TRY
-      {
-#endif /* TAO_HAS_INTERCEPTORS */
+    CORBA::Short flag = TAO_TWOWAY_RESPONSE_FLAG;
 
-      for (;;)
-      {
-        _tao_call.start (ACE_TRY_ENV);
-        TAO_INTERCEPTOR_CHECK;
+    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
+                              ACE_TRY_ENV);
+    ACE_CHECK;
 
-        TAO_INTERCEPTOR (
-            _tao_vfr.preinvoke (
-                _tao_call.request_id (),
-                1,
-                this,
-                "destroy",
-                _tao_call.service_info (),
-                _tao_interceptor_args.inout (),
-                _tao_cookies,
-                ACE_TRY_ENV
-              )
-          );
-        TAO_INTERCEPTOR_CHECK;
-        CORBA::Short flag = TAO_TWOWAY_RESPONSE_FLAG;
-        
-        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
-        TAO_INTERCEPTOR_CHECK;
-
-        int _invoke_status =
-          _tao_call.invoke (0, 0, ACE_TRY_ENV);
-                TAO_INTERCEPTOR_CHECK;
-
-        if (_invoke_status == TAO_INVOKE_RESTART)
-          continue;
-        if (_invoke_status != TAO_INVOKE_OK)
-        {
-          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
-        }
-        
-        TAO_INTERCEPTOR (
-            _tao_vfr.postinvoke (
-                _tao_call.request_id (),
-                1,
-                this,
-                "destroy",
-                _tao_call.service_info (),
-                _tao_interceptor_args.inout (),
-                _tao_cookies,
-                ACE_TRY_ENV
-              )
-          );
-        TAO_INTERCEPTOR_CHECK;
-        break;
-        
-      }
-#if (TAO_HAS_INTERCEPTORS == 1)
-      
-    }
-  ACE_CATCHANY
+    int _invoke_status =
+      _tao_call.invoke (0, 0, ACE_TRY_ENV);
+        ACE_CHECK;
+
+    if (_invoke_status == TAO_INVOKE_RESTART)
+      continue;
+    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
+      // cannot happen
+    if (_invoke_status != TAO_INVOKE_OK)
     {
-      _tao_vfr.exception_occurred (
-          _tao_call.request_id (),
-          1,
-          this,
-          "destroy",
-          _tao_cookies,
-          ACE_TRY_ENV
-        );
-      ACE_RETHROW;
+      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
+
     }
-  ACE_ENDTRY;
-  ACE_CHECK;
-#endif /* TAO_HAS_INTERCEPTORS */
+    break;
+
+  }
 
 }
+#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */
 
-CORBA::Boolean CORBA::Policy::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+CORBA::Boolean CORBA_Policy::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
   if (
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
   return 1; // success using local knowledge
   else
-    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
+    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV); // remote call
 }
 
-void *CORBA::Policy::_tao_QueryInterface (ptr_arith_t type)
+const char* CORBA_Policy::_interface_repository_id (void) const
 {
-  void *retv = 0;
-  if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::CORBA, Policy)::_narrow))
-    retv = ACE_reinterpret_cast (void*, this);
-  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
-    retv = ACE_reinterpret_cast (void *,
-      ACE_static_cast (CORBA::Object_ptr, this));
-    
-  if (retv)
-    this->_add_ref ();
-  return retv;
+  return "IDL:omg.org/CORBA/Policy:1.0";
 }
 
-const char* CORBA::Policy::_interface_repository_id (void) const
+CORBA_Policy_ptr
+CORBA_Policy::_duplicate (CORBA_Policy_ptr obj)
 {
-  return "IDL:omg.org/CORBA/Policy:1.0";
+  if (!CORBA::is_nil (obj))
+    obj->_add_ref ();
+  return obj;
 }
 
-static const CORBA::Long _oc_CORBA_Policy[] =
+CORBA_Policy_ptr
+CORBA_Policy::_nil (void)
 {
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Policy:1.0
-  7, ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63790000),  // name = Policy
-};
-static CORBA::TypeCode _tc_TAO_tc_CORBA_Policy (CORBA::tk_objref, sizeof (_oc_CORBA_Policy), (char *) &_oc_CORBA_Policy, 0, sizeof (CORBA::Policy));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (CORBA)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Policy, &_tc_TAO_tc_CORBA_Policy)
-TAO_NAMESPACE_END
-
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  
-#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_POLICYLIST_CS_)
-#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_POLICYLIST_CS_
-
-  // The Base_Sequence functions, please see tao/Sequence.h
-  void
-  CORBA::_TAO_Unbounded_Object_Sequence_CORBA_PolicyList::_allocate_buffer (CORBA::ULong length)
-  {
-    CORBA::Policy **tmp = 0;
-    tmp = _TAO_Unbounded_Object_Sequence_CORBA_PolicyList::allocbuf (length);
-    
-    if (this->buffer_ != 0)
-    {
-      CORBA::Policy **old = ACE_reinterpret_cast (CORBA::Policy**, this->buffer_);
-      for (CORBA::ULong i = 0; i < this->length_; ++i)
-        if (!this->release_)
-          tmp[i] = CORBA::Policy::_duplicate (old[i]);
-        else
-          tmp[i] = old[i];
-        
-      if (this->release_)
-        delete[] old;
-      
-    }
-    this->buffer_ = tmp;
-  }
-  
-  void
-  CORBA::_TAO_Unbounded_Object_Sequence_CORBA_PolicyList::_deallocate_buffer (void)
-  {
-    if (this->buffer_ == 0 || this->release_ == 0)
-      return;
-    CORBA::Policy **tmp = ACE_reinterpret_cast (CORBA::Policy**, this->buffer_);
-    for (CORBA::ULong i = 0; i < this->length_; ++i)
-    {
-      CORBA::release (tmp[i]);
-      tmp[i] = CORBA::Policy::_nil ();
-    }
-    _TAO_Unbounded_Object_Sequence_CORBA_PolicyList::freebuf (tmp);
-    this->buffer_ = 0;
-  }
-  
-  CORBA::_TAO_Unbounded_Object_Sequence_CORBA_PolicyList::~_TAO_Unbounded_Object_Sequence_CORBA_PolicyList (void)
-  {
-    this->_deallocate_buffer ();
-  }
-  
-  void
-  CORBA::_TAO_Unbounded_Object_Sequence_CORBA_PolicyList::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
-  {
-    CORBA::Policy **tmp = ACE_reinterpret_cast (CORBA::Policy**, this->buffer_);
-    
-    for (CORBA::ULong i = nl; i < ol; ++i)
-    {
-      CORBA::release (tmp[i]);
-      tmp[i] = CORBA::Policy::_nil ();
-    }
-  }
-  void 
-  CORBA::_TAO_Unbounded_Object_Sequence_CORBA_PolicyList::_downcast (
-      void* target,
-      CORBA_Object *src,
-      CORBA_Environment &ACE_TRY_ENV
-    )
-  {
-    CORBA::Policy **tmp = ACE_static_cast (CORBA::Policy**, target);
-    *tmp = CORBA::Policy::_narrow (src, ACE_TRY_ENV);
-  }
-
-  CORBA_Object*
-  CORBA::_TAO_Unbounded_Object_Sequence_CORBA_PolicyList::_upcast (void *src) const
-  {
-    CORBA::Policy **tmp = ACE_static_cast (CORBA::Policy**, src);
-    return *tmp;
-  }
-  
-#endif /* end #if !defined */
+  return (CORBA_Policy_ptr)0;
+}
 
+////////////////////////////////////////////////////////////////
+//        Serialization Support Methods
+//
+CORBA::Boolean 
+CORBA_Policy::_tao_encode (TAO_OutputCDR &)
+{
+  return 0; 
+}
 
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
+CORBA::Boolean 
+CORBA_Policy::_tao_decode (TAO_InputCDR &)
+{
+  return 0;
+}
 
-#if !defined (_CORBA_POLICYLIST_CS_)
-#define _CORBA_POLICYLIST_CS_
 
 // *************************************************************
-// CORBA::PolicyList
+// CORBA_PolicyList
 // *************************************************************
 
-CORBA::PolicyList::PolicyList (void)
+CORBA_PolicyList::CORBA_PolicyList (void)
 {}
-CORBA::PolicyList::PolicyList (CORBA::ULong max) // uses max size
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Object_Sequence_CORBA_PolicyList
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<CORBA::Policy,CORBA::Policy_var>
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (max)
+CORBA_PolicyList::CORBA_PolicyList (CORBA::ULong max) // uses max size
+  : TAO_Unbounded_Object_Sequence<CORBA_Policy,CORBA_Policy_var> (max)
 {}
-CORBA::PolicyList::PolicyList (CORBA::ULong max, CORBA::ULong length, CORBA::Policy_ptr *buffer, CORBA::Boolean release)
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Object_Sequence_CORBA_PolicyList
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<CORBA::Policy,CORBA::Policy_var>
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (max, length, buffer, release)
+CORBA_PolicyList::CORBA_PolicyList (CORBA::ULong max, CORBA::ULong length, CORBA_Policy_ptr *buffer, CORBA::Boolean release)
+  : TAO_Unbounded_Object_Sequence<CORBA_Policy,CORBA_Policy_var> (max, length, buffer, release)
 {}
-CORBA::PolicyList::PolicyList (const PolicyList &seq) // copy ctor
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Object_Sequence_CORBA_PolicyList
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Object_Sequence<CORBA::Policy,CORBA::Policy_var>
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (seq)
+CORBA_PolicyList::CORBA_PolicyList (const CORBA_PolicyList &seq) // copy ctor
+  : TAO_Unbounded_Object_Sequence<CORBA_Policy,CORBA_Policy_var> (seq)
 {}
-CORBA::PolicyList::~PolicyList (void) // dtor
+CORBA_PolicyList::~CORBA_PolicyList (void) // dtor
 {}
-void CORBA::PolicyList::_tao_any_destructor (void *x)
-{
-  PolicyList *tmp = ACE_static_cast (PolicyList*,x);
-  delete tmp;
-}
-
-
-#endif /* end #if !defined */
-
-static const CORBA::Long _oc_CORBA_PolicyList[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x4c697374), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/PolicyList:1.0
-  11, ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63794c69), ACE_NTOHL (0x73740000),  // name = PolicyList
-  CORBA::tk_sequence, // typecode kind
-  68, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    CORBA::tk_objref, // typecode kind
-    52, // encapsulation length
-      TAO_ENCAP_BYTE_ORDER, // byte order
-      29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Policy:1.0
-      7, ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63790000),  // name = Policy
-
-    0U,
-
-};
-static CORBA::TypeCode _tc_TAO_tc_CORBA_PolicyList (CORBA::tk_alias, sizeof (_oc_CORBA_PolicyList), (char *) &_oc_CORBA_PolicyList, 0, sizeof (CORBA::PolicyList));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (CORBA)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PolicyList, &_tc_TAO_tc_CORBA_PolicyList)
-TAO_NAMESPACE_END
-
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  
-#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_POLICYTYPESEQ_CS_)
-#define __TAO_UNBOUNDED_SEQUENCE_CORBA_POLICYTYPESEQ_CS_
-
-  void
-  CORBA::_TAO_Unbounded_Sequence_CORBA_PolicyTypeSeq::_allocate_buffer (CORBA::ULong length)
-  {
-    CORBA::ULong* tmp = 0;
-    tmp = _TAO_Unbounded_Sequence_CORBA_PolicyTypeSeq::allocbuf (length);
-    
-    if (this->buffer_ != 0)
-    {
-      CORBA::ULong *old = ACE_reinterpret_cast (CORBA::ULong *,this->buffer_);
-      
-      for (CORBA::ULong i = 0; i < this->length_; ++i)
-        tmp[i] = old[i];
-      
-      if (this->release_)
-        _TAO_Unbounded_Sequence_CORBA_PolicyTypeSeq::freebuf (old);
-      
-    }
-    this->buffer_ = tmp;
-  }
-  
-  void
-  CORBA::_TAO_Unbounded_Sequence_CORBA_PolicyTypeSeq::_deallocate_buffer (void)
-  {
-    if (this->buffer_ == 0 || this->release_ == 0)
-      return;
-    
-    CORBA::ULong *tmp = ACE_reinterpret_cast (CORBA::ULong *,this->buffer_);
-    
-    _TAO_Unbounded_Sequence_CORBA_PolicyTypeSeq::freebuf (tmp);
-    this->buffer_ = 0;
-  } 
-  
-  CORBA::_TAO_Unbounded_Sequence_CORBA_PolicyTypeSeq::~_TAO_Unbounded_Sequence_CORBA_PolicyTypeSeq (void) // Dtor.
-  {
-    this->_deallocate_buffer ();
-  }
-  
-  
-#endif /* end #if !defined */
-
-
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
-
-#if !defined (_CORBA_POLICYTYPESEQ_CS_)
-#define _CORBA_POLICYTYPESEQ_CS_
 
 // *************************************************************
-// CORBA::PolicyTypeSeq
+// CORBA_PolicyTypeSeq
 // *************************************************************
 
-CORBA::PolicyTypeSeq::PolicyTypeSeq (void)
+CORBA_PolicyTypeSeq::CORBA_PolicyTypeSeq (void)
 {}
-CORBA::PolicyTypeSeq::PolicyTypeSeq (CORBA::ULong max) // uses max size
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Sequence_CORBA_PolicyTypeSeq
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<CORBA::ULong>
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
+CORBA_PolicyTypeSeq::CORBA_PolicyTypeSeq (CORBA::ULong max) // uses max size
+  : TAO_Unbounded_Sequence<CORBA::ULong>
  (max)
 {}
-CORBA::PolicyTypeSeq::PolicyTypeSeq (CORBA::ULong max, CORBA::ULong length, CORBA::ULong *buffer, CORBA::Boolean release)
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Sequence_CORBA_PolicyTypeSeq
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<CORBA::ULong>
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (max, length, buffer, release)
+CORBA_PolicyTypeSeq::CORBA_PolicyTypeSeq (CORBA::ULong max, CORBA::ULong length, CORBA::ULong *buffer, CORBA::Boolean release)
+  : TAO_Unbounded_Sequence<CORBA::ULong> (max, length, buffer, release)
 {}
-CORBA::PolicyTypeSeq::PolicyTypeSeq (const PolicyTypeSeq &seq) // copy ctor
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-  _TAO_Unbounded_Sequence_CORBA_PolicyTypeSeq
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-  TAO_Unbounded_Sequence<CORBA::ULong>
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (seq)
+CORBA_PolicyTypeSeq::CORBA_PolicyTypeSeq (const CORBA_PolicyTypeSeq &seq)
+  : TAO_Unbounded_Sequence<CORBA::ULong> (seq)
 {}
-CORBA::PolicyTypeSeq::~PolicyTypeSeq (void) // dtor
+CORBA_PolicyTypeSeq::~CORBA_PolicyTypeSeq (void)
 {}
-void CORBA::PolicyTypeSeq::_tao_any_destructor (void *x)
-{
-  PolicyTypeSeq *tmp = ACE_static_cast (PolicyTypeSeq*,x);
-  delete tmp;
-}
-
 
-#endif /* end #if !defined */
+// ****************************************************************
 
-static const CORBA::Long _oc_CORBA_PolicyTypeSeq[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x54797065), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/PolicyTypeSeq:1.0
-  14, ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63795479), ACE_NTOHL (0x70655365), ACE_NTOHL (0x71000000),  // name = PolicyTypeSeq
-  CORBA::tk_sequence, // typecode kind
-  80, // encapsulation length
-    TAO_ENCAP_BYTE_ORDER, // byte order
-    CORBA::tk_alias, // typecode kind for typedefs
-    64, // encapsulation length
-      TAO_ENCAP_BYTE_ORDER, // byte order
-      33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x54797065), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/PolicyType:1.0
-      11, ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63795479), ACE_NTOHL (0x70650000),  // name = PolicyType
-      CORBA::tk_ulong,
-
-
-    0U,
-
-};
-static CORBA::TypeCode _tc_TAO_tc_CORBA_PolicyTypeSeq (CORBA::tk_alias, sizeof (_oc_CORBA_PolicyTypeSeq), (char *) &_oc_CORBA_PolicyTypeSeq, 0, sizeof (CORBA::PolicyTypeSeq));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (CORBA)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PolicyTypeSeq, &_tc_TAO_tc_CORBA_PolicyTypeSeq)
-TAO_NAMESPACE_END
-static const CORBA::Long _oc_CORBA_SetOverrideType[] =
+CORBA::PolicyManager_ptr CORBA_PolicyManager::_narrow (
+    CORBA::Object_ptr obj,
+    CORBA::Environment &ACE_TRY_ENV
+  )
 {
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5365), ACE_NTOHL (0x744f7665), ACE_NTOHL (0x72726964), ACE_NTOHL (0x65547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/SetOverrideType:1.0
-  16, ACE_NTOHL (0x5365744f), ACE_NTOHL (0x76657272), ACE_NTOHL (0x69646554), ACE_NTOHL (0x79706500),  // name = SetOverrideType
-  2, // member count
-  13, ACE_NTOHL (0x5345545f), ACE_NTOHL (0x4f564552), ACE_NTOHL (0x52494445), ACE_NTOHL (0x0),  // name = SET_OVERRIDE
-  13, ACE_NTOHL (0x4144445f), ACE_NTOHL (0x4f564552), ACE_NTOHL (0x52494445), ACE_NTOHL (0x0),  // name = ADD_OVERRIDE
-};
-static CORBA::TypeCode _tc_TAO_tc_CORBA_SetOverrideType (CORBA::tk_enum, sizeof (_oc_CORBA_SetOverrideType), (char *) &_oc_CORBA_SetOverrideType, 0, sizeof (CORBA::SetOverrideType));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (CORBA)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_SetOverrideType, &_tc_TAO_tc_CORBA_SetOverrideType)
-TAO_NAMESPACE_END
-
-// default constructor
-CORBA::PolicyManager::PolicyManager (void)
-{}
+  if (CORBA::is_nil (obj))
+    return CORBA_PolicyManager::_nil ();
+  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/PolicyManager:1.0", ACE_TRY_ENV);
+  ACE_CHECK_RETURN (CORBA_PolicyManager::_nil ());
+  if (is_a == 0)
+    return CORBA_PolicyManager::_nil ();
+  void* servant = 0;
+  if (!obj->_is_collocated () || !obj->_servant() ||
+      (servant = obj->_servant()->_downcast ("IDL:omg.org/CORBA/PolicyManager:1.0")) == 0)
+    ACE_THROW_RETURN (CORBA::MARSHAL (), CORBA_PolicyManager::_nil ());
+
+  CORBA::PolicyManager_ptr retval =
+    CORBA_PolicyManager::_nil ();
+
+  ACE_NEW_RETURN (
+      retval,
+      POA_CORBA::_tao_collocated_PolicyManager (
+          ACE_reinterpret_cast (POA_CORBA::PolicyManager_ptr,
+                                servant),
+          0
+        ),
+      CORBA_PolicyManager::_nil ()
+    );
 
-// destructor
-CORBA::PolicyManager::~PolicyManager (void)
-{}
+  return retval;
+}
 
-void CORBA::PolicyManager::_tao_any_destructor (void *x)
+CORBA_PolicyList * CORBA_PolicyManager::get_policy_overrides (
+    const CORBA_PolicyTypeSeq & ts,
+    CORBA::Environment &ACE_TRY_ENV
+  )
 {
-  PolicyManager *tmp = ACE_static_cast (PolicyManager*,x);
-  CORBA::release (tmp);
+  CORBA_PolicyList* _tao_retval = 0;
+  ACE_UNUSED_ARG (_tao_retval);
+  ACE_UNUSED_ARG (ts);
+  ACE_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);
 }
 
-CORBA::PolicyManager_ptr CORBA::PolicyManager::_narrow (
-    CORBA::Object_ptr obj,
+void CORBA_PolicyManager::set_policy_overrides (
+    const CORBA_PolicyList & policies,
+    CORBA::SetOverrideType set_add,
     CORBA::Environment &ACE_TRY_ENV
   )
 {
-  if (CORBA::is_nil (obj))
-    return PolicyManager::_nil ();
-  if (! obj->_is_local ())
-    {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/PolicyManager:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (PolicyManager::_nil ());
-      if (is_a == 0)
-        return PolicyManager::_nil ();
-    }
-  return PolicyManager::_unchecked_narrow (obj, ACE_TRY_ENV);
+  ACE_UNUSED_ARG (policies);
+  ACE_UNUSED_ARG (set_add);
+
+  ACE_THROW (CORBA::MARSHAL ());
 }
 
-CORBA::PolicyManager_ptr CORBA::PolicyManager::_unchecked_narrow (
-    CORBA::Object_ptr obj,
-    CORBA::Environment &
-  )
+CORBA::Boolean CORBA_PolicyManager::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
-  if (CORBA::is_nil (obj))
-    return PolicyManager::_nil ();
-  if (! obj->_is_local ())
-    {
-      TAO_Stub* stub = obj->_stubobj ();
-      if (stub)
-        stub->_incr_refcnt ();
-      PolicyManager_ptr default_proxy = PolicyManager::_nil ();
-
-      if (obj->_is_collocated () && _TAO_collocation_CORBA_PolicyManager_Stub_Factory_function_pointer != 0)
-        {
-          default_proxy = _TAO_collocation_CORBA_PolicyManager_Stub_Factory_function_pointer (obj);
-        }
-      if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, PolicyManager (stub), PolicyManager::_nil ());
-      #if (TAO_HAS_SMART_PROXIES == 1)
-        return TAO_CORBA_PolicyManager_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
-      #else 
-        return default_proxy;
-      #endif /*TAO_HAS_SMART_PROXIES == 1*/
-    }
-  else 
-    return
-      ACE_reinterpret_cast
-        (
-          PolicyManager_ptr,
-            obj->_tao_QueryInterface
-              (
-                ACE_reinterpret_cast
-                  (
-                    ptr_arith_t,
-                    &PolicyManager::_narrow
-                  )
-              )
-        );
+  if (
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/PolicyManager:1.0")) ||
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
+  return 1; // success using local knowledge
+  else
+    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV); // remote call
 }
 
-CORBA::PolicyManager_ptr
-CORBA::PolicyManager::_duplicate (PolicyManager_ptr obj)
+const char* CORBA_PolicyManager::_interface_repository_id (void) const
 {
-  if (!CORBA::is_nil (obj))
-    obj->_add_ref ();
-  return obj;
+  return "IDL:omg.org/CORBA/PolicyManager:1.0";
 }
 
-CORBA::PolicyList * CORBA::PolicyManager::get_policy_overrides (
-    const CORBA::PolicyTypeSeq & ts,
+// ****************************************************************
+
+
+CORBA_PolicyCurrent_ptr CORBA_PolicyCurrent::_narrow (
+    CORBA::Object_ptr obj,
     CORBA::Environment &ACE_TRY_ENV
   )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException
-  ))
-{
-  
-  CORBA::PolicyList *_tao_retval = 0;
-  
-  
-  TAO_Stub *istub = this->_stubobj ();
-  if (istub == 0)
-    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
-
-  
-  ACE_NEW_RETURN (_tao_retval, CORBA::PolicyList, _tao_retval);
-  CORBA::PolicyList_var _tao_safe_retval (_tao_retval);
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "get_policy_overrides",
-      20,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-    TAO_ClientRequestInterceptor_Adapter
-      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
-    ACE_CHECK_RETURN (0);
-    PortableInterceptor::Cookies _tao_cookies;
-    CORBA::NVList_var _tao_interceptor_args;
-    if (_tao_vfr.valid ())
-      {
-        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
-        ACE_CHECK_RETURN (0);
-      }
-
-    ACE_TRY
-      {
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      for (;;)
-      {
-        _tao_call.start (ACE_TRY_ENV);
-        TAO_INTERCEPTOR_CHECK_RETURN (0);
-
-        TAO_INTERCEPTOR (
-            _tao_vfr.preinvoke (
-                _tao_call.request_id (),
-                1,
-                this,
-                "get_policy_overrides",
-                _tao_call.service_info (),
-                _tao_interceptor_args.inout (),
-                _tao_cookies,
-                ACE_TRY_ENV
-              )
-          );
-        TAO_INTERCEPTOR_CHECK_RETURN (0);
-        CORBA::Short flag = TAO_TWOWAY_RESPONSE_FLAG;
-        
-        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
-        TAO_INTERCEPTOR_CHECK_RETURN (0);
-
-        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-        if (!(
-              (_tao_out << ts)
-          ))
-          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);
-
-        int _invoke_status =
-          _tao_call.invoke (0, 0, ACE_TRY_ENV);
-                TAO_INTERCEPTOR_CHECK_RETURN (0);
-
-        if (_invoke_status == TAO_INVOKE_RESTART)
-          continue;
-        if (_invoke_status != TAO_INVOKE_OK)
-        {
-          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);
-
-        }
-        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
-        if (!(
-              (_tao_in >> _tao_safe_retval.inout ())
-          ))
-          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);
-
-        TAO_INTERCEPTOR (
-            _tao_vfr.postinvoke (
-                _tao_call.request_id (),
-                1,
-                this,
-                "get_policy_overrides",
-                _tao_call.service_info (),
-                _tao_interceptor_args.inout (),
-                _tao_cookies,
-                ACE_TRY_ENV
-              )
-          );
-        TAO_INTERCEPTOR_CHECK_RETURN (0);
-        break;
-        
-      }
-#if (TAO_HAS_INTERCEPTORS == 1)
-      
-    }
-  ACE_CATCHANY
-    {
-      _tao_vfr.exception_occurred (
-          _tao_call.request_id (),
-          1,
-          this,
-          "get_policy_overrides",
-          _tao_cookies,
-          ACE_TRY_ENV
-        );
-      ACE_RETHROW;
-    }
-  ACE_ENDTRY;
-  ACE_CHECK_RETURN (0);
-#endif /* TAO_HAS_INTERCEPTORS */
-  return _tao_safe_retval._retn ();
-}
-
-void CORBA::PolicyManager::set_policy_overrides (
-    const CORBA::PolicyList & policies,
-    CORBA::SetOverrideType set_add,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-  ACE_THROW_SPEC ((
-    CORBA::SystemException,
-    CORBA::InvalidPolicies
-  ))
-{
-  
-  static TAO_Exception_Data _tao_CORBA_PolicyManager_set_policy_overrides_exceptiondata [] = 
-  {
-    {CORBA::_tc_InvalidPolicies, CORBA::InvalidPolicies::_alloc}
-  };
-
-
-  
-  
-  TAO_Stub *istub = this->_stubobj ();
-  if (istub == 0)
-    ACE_THROW (CORBA::INTERNAL ());
-
-  
-  TAO_GIOP_Twoway_Invocation _tao_call (
-      istub,
-      "set_policy_overrides",
-      20,
-      istub->orb_core ()
-    );
-
-#if (TAO_HAS_INTERCEPTORS == 1)
-    TAO_ClientRequestInterceptor_Adapter
-      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
-    ACE_CHECK;
-    PortableInterceptor::Cookies _tao_cookies;
-    CORBA::NVList_var _tao_interceptor_args;
-    if (_tao_vfr.valid ())
-      {
-        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
-        ACE_CHECK;
-      }
-
-    ACE_TRY
-      {
-#endif /* TAO_HAS_INTERCEPTORS */
-
-      for (;;)
-      {
-        _tao_call.start (ACE_TRY_ENV);
-        TAO_INTERCEPTOR_CHECK;
-
-        TAO_INTERCEPTOR (
-            _tao_vfr.preinvoke (
-                _tao_call.request_id (),
-                1,
-                this,
-                "set_policy_overrides",
-                _tao_call.service_info (),
-                _tao_interceptor_args.inout (),
-                _tao_cookies,
-                ACE_TRY_ENV
-              )
-          );
-        TAO_INTERCEPTOR_CHECK;
-        CORBA::Short flag = TAO_TWOWAY_RESPONSE_FLAG;
-        
-        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
-        TAO_INTERCEPTOR_CHECK;
-
-        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
-        if (!(
-              (_tao_out << policies) &&
-              (_tao_out << set_add)
-          ))
-          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
-        int _invoke_status =
-          _tao_call.invoke (_tao_CORBA_PolicyManager_set_policy_overrides_exceptiondata, 1, ACE_TRY_ENV);
-                TAO_INTERCEPTOR_CHECK;
-
-        if (_invoke_status == TAO_INVOKE_RESTART)
-          continue;
-        if (_invoke_status != TAO_INVOKE_OK)
-        {
-          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
-        }
-        
-        TAO_INTERCEPTOR (
-            _tao_vfr.postinvoke (
-                _tao_call.request_id (),
-                1,
-                this,
-                "set_policy_overrides",
-                _tao_call.service_info (),
-                _tao_interceptor_args.inout (),
-                _tao_cookies,
-                ACE_TRY_ENV
-              )
-          );
-        TAO_INTERCEPTOR_CHECK;
-        break;
-        
-      }
-#if (TAO_HAS_INTERCEPTORS == 1)
-      
-    }
-  ACE_CATCHANY
-    {
-      _tao_vfr.exception_occurred (
-          _tao_call.request_id (),
-          1,
-          this,
-          "set_policy_overrides",
-          _tao_cookies,
-          ACE_TRY_ENV
-        );
-      ACE_RETHROW;
-    }
-  ACE_ENDTRY;
-  ACE_CHECK;
-#endif /* TAO_HAS_INTERCEPTORS */
+{
+  if (CORBA::is_nil (obj))
+    return CORBA_PolicyCurrent::_nil ();
+  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/PolicyCurrent:1.0", ACE_TRY_ENV);
+  ACE_CHECK_RETURN (CORBA_PolicyCurrent::_nil ());
+  if (is_a == 0)
+    return CORBA_PolicyCurrent::_nil ();
+  void* servant = 0;
+  if (!obj->_is_collocated () || !obj->_servant() ||
+      (servant = obj->_servant()->_downcast ("IDL:omg.org/CORBA/PolicyCurrent:1.0")) == 0)
+    ACE_THROW_RETURN (CORBA::MARSHAL (), CORBA_PolicyCurrent::_nil ());
+
+  CORBA_PolicyCurrent_ptr retval =
+    CORBA_PolicyCurrent::_nil ();
+
+  ACE_NEW_RETURN (
+      retval,
+      POA_CORBA::_tao_collocated_PolicyCurrent (
+          ACE_reinterpret_cast  (POA_CORBA::PolicyCurrent_ptr,
+                                 servant),
+          0
+        ),
+      CORBA_PolicyCurrent::_nil ()
+    );
 
+  return retval;
 }
 
-CORBA::Boolean CORBA::PolicyManager::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
+CORBA::Boolean CORBA_PolicyCurrent::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
 {
   if (
+    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/PolicyCurrent:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/PolicyManager:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
-  return 1; // success using local knowledge
-  else
-    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
-}
-
-void *CORBA::PolicyManager::_tao_QueryInterface (ptr_arith_t type)
-{
-  void *retv = 0;
-  if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::CORBA, PolicyManager)::_narrow))
-    retv = ACE_reinterpret_cast (void*, this);
-  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
-    retv = ACE_reinterpret_cast (void *,
-      ACE_static_cast (CORBA::Object_ptr, this));
-    
-  if (retv)
-    this->_add_ref ();
-  return retv;
-}
-
-const char* CORBA::PolicyManager::_interface_repository_id (void) const
-{
-  return "IDL:omg.org/CORBA/PolicyManager:1.0";
-}
-
-static const CORBA::Long _oc_CORBA_PolicyManager[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x4d616e61), ACE_NTOHL (0x6765723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/PolicyManager:1.0
-  14, ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63794d61), ACE_NTOHL (0x6e616765), ACE_NTOHL (0x72000000),  // name = PolicyManager
-};
-static CORBA::TypeCode _tc_TAO_tc_CORBA_PolicyManager (CORBA::tk_objref, sizeof (_oc_CORBA_PolicyManager), (char *) &_oc_CORBA_PolicyManager, 0, sizeof (CORBA::PolicyManager));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (CORBA)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PolicyManager, &_tc_TAO_tc_CORBA_PolicyManager)
-TAO_NAMESPACE_END
-
-// default constructor
-CORBA::Current::Current (void)
-{}
-
-// destructor
-CORBA::Current::~Current (void)
-{}
-
-void CORBA::Current::_tao_any_destructor (void *x)
-{
-  Current *tmp = ACE_static_cast (Current*,x);
-  CORBA::release (tmp);
-}
-
-CORBA::Current_ptr CORBA::Current::_narrow (
-    CORBA::Object_ptr obj,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-{
-  if (CORBA::is_nil (obj))
-    return Current::_nil ();
-  if (! obj->_is_local ())
-    {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/Current:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (Current::_nil ());
-      if (is_a == 0)
-        return Current::_nil ();
-    }
-  return Current::_unchecked_narrow (obj, ACE_TRY_ENV);
-}
-
-CORBA::Current_ptr CORBA::Current::_unchecked_narrow (
-    CORBA::Object_ptr obj,
-    CORBA::Environment &
-  )
-{
-  if (CORBA::is_nil (obj))
-    return Current::_nil ();
-  if (! obj->_is_local ())
-    {
-      TAO_Stub* stub = obj->_stubobj ();
-      if (stub)
-        stub->_incr_refcnt ();
-      Current_ptr default_proxy = Current::_nil ();
-
-      if (obj->_is_collocated () && _TAO_collocation_CORBA_Current_Stub_Factory_function_pointer != 0)
-        {
-          default_proxy = _TAO_collocation_CORBA_Current_Stub_Factory_function_pointer (obj);
-        }
-      if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, Current (stub), Current::_nil ());
-      #if (TAO_HAS_SMART_PROXIES == 1)
-        return TAO_CORBA_Current_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
-      #else 
-        return default_proxy;
-      #endif /*TAO_HAS_SMART_PROXIES == 1*/
-    }
-  else 
-    return
-      ACE_reinterpret_cast
-        (
-          Current_ptr,
-            obj->_tao_QueryInterface
-              (
-                ACE_reinterpret_cast
-                  (
-                    ptr_arith_t,
-                    &Current::_narrow
-                  )
-              )
-        );
-}
-
-CORBA::Current_ptr
-CORBA::Current::_duplicate (Current_ptr obj)
-{
-  if (!CORBA::is_nil (obj))
-    obj->_add_ref ();
-  return obj;
-}
-
-CORBA::Boolean CORBA::Current::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
-{
-  if (
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Current:1.0")) ||
     (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
   return 1; // success using local knowledge
   else
-    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
-}
-
-void *CORBA::Current::_tao_QueryInterface (ptr_arith_t type)
-{
-  void *retv = 0;
-  if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::CORBA, Current)::_narrow))
-    retv = ACE_reinterpret_cast (void*, this);
-  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
-    retv = ACE_reinterpret_cast (void *,
-      ACE_static_cast (CORBA::Object_ptr, this));
-    
-  if (retv)
-    this->_add_ref ();
-  return retv;
-}
-
-const char* CORBA::Current::_interface_repository_id (void) const
-{
-  return "IDL:omg.org/CORBA/Current:1.0";
-}
-
-static const CORBA::Long _oc_CORBA_Current[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4375), ACE_NTOHL (0x7272656e), ACE_NTOHL (0x743a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/Current:1.0
-  8, ACE_NTOHL (0x43757272), ACE_NTOHL (0x656e7400),  // name = Current
-};
-static CORBA::TypeCode _tc_TAO_tc_CORBA_Current (CORBA::tk_objref, sizeof (_oc_CORBA_Current), (char *) &_oc_CORBA_Current, 0, sizeof (CORBA::Current));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (CORBA)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Current, &_tc_TAO_tc_CORBA_Current)
-TAO_NAMESPACE_END
-
-// default constructor
-CORBA::PolicyCurrent::PolicyCurrent (void)
-{}
-
-// destructor
-CORBA::PolicyCurrent::~PolicyCurrent (void)
-{}
-
-void CORBA::PolicyCurrent::_tao_any_destructor (void *x)
-{
-  PolicyCurrent *tmp = ACE_static_cast (PolicyCurrent*,x);
-  CORBA::release (tmp);
-}
-
-CORBA::PolicyCurrent_ptr CORBA::PolicyCurrent::_narrow (
-    CORBA::Object_ptr obj,
-    CORBA::Environment &ACE_TRY_ENV
-  )
-{
-  if (CORBA::is_nil (obj))
-    return PolicyCurrent::_nil ();
-  if (! obj->_is_local ())
-    {
-      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/PolicyCurrent:1.0", ACE_TRY_ENV);
-      ACE_CHECK_RETURN (PolicyCurrent::_nil ());
-      if (is_a == 0)
-        return PolicyCurrent::_nil ();
-    }
-  return PolicyCurrent::_unchecked_narrow (obj, ACE_TRY_ENV);
+    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV); // remote call
 }
 
-CORBA::PolicyCurrent_ptr CORBA::PolicyCurrent::_unchecked_narrow (
-    CORBA::Object_ptr obj,
-    CORBA::Environment &
-  )
+const char* CORBA_PolicyCurrent::_interface_repository_id (void) const
 {
-  if (CORBA::is_nil (obj))
-    return PolicyCurrent::_nil ();
-  if (! obj->_is_local ())
-    {
-      TAO_Stub* stub = obj->_stubobj ();
-      if (stub)
-        stub->_incr_refcnt ();
-      PolicyCurrent_ptr default_proxy = PolicyCurrent::_nil ();
-
-      if (obj->_is_collocated () && _TAO_collocation_CORBA_PolicyCurrent_Stub_Factory_function_pointer != 0)
-        {
-          default_proxy = _TAO_collocation_CORBA_PolicyCurrent_Stub_Factory_function_pointer (obj);
-        }
-      if (CORBA::is_nil (default_proxy))
-        ACE_NEW_RETURN (default_proxy, PolicyCurrent (stub), PolicyCurrent::_nil ());
-      #if (TAO_HAS_SMART_PROXIES == 1)
-        return TAO_CORBA_PolicyCurrent_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
-      #else 
-        return default_proxy;
-      #endif /*TAO_HAS_SMART_PROXIES == 1*/
-    }
-  else 
-    return
-      ACE_reinterpret_cast
-        (
-          PolicyCurrent_ptr,
-            obj->_tao_QueryInterface
-              (
-                ACE_reinterpret_cast
-                  (
-                    ptr_arith_t,
-                    &PolicyCurrent::_narrow
-                  )
-              )
-        );
+  return "IDL:omg.org/CORBA/PolicyCurrent:1.0";
 }
 
-CORBA::PolicyCurrent_ptr
-CORBA::PolicyCurrent::_duplicate (PolicyCurrent_ptr obj)
-{
-  if (!CORBA::is_nil (obj))
-    obj->_add_ref ();
-  return obj;
-}
+// ****************************************************************
 
-CORBA::Boolean CORBA::PolicyCurrent::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
-{
-  if (
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/PolicyCurrent:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/PolicyManager:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Current:1.0")) ||
-    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
-  return 1; // success using local knowledge
-  else
-    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
-}
 
-void *CORBA::PolicyCurrent::_tao_QueryInterface (ptr_arith_t type)
+void operator<<= (CORBA::Any &_tao_any, const CORBA::PolicyError &_tao_elem) // copying
 {
-  void *retv = 0;
-  if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::CORBA, PolicyCurrent)::_narrow))
-    retv = ACE_reinterpret_cast (void*, this);
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::CORBA, PolicyManager)::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            CORBA::PolicyManager_ptr,
-            this
-          )
-      );
-  else if (type == ACE_reinterpret_cast
-    (ptr_arith_t,
-      &ACE_NESTED_CLASS (::CORBA, Current)::_narrow))
-    retv = ACE_reinterpret_cast
-      (
-        void *,
-        ACE_static_cast
-          (
-            CORBA::Current_ptr,
-            this
-          )
+    TAO_OutputCDR stream;
+    stream << _tao_elem;
+    _tao_any._tao_replace (
+        CORBA::_tc_PolicyError,
+        TAO_ENCAP_BYTE_ORDER,
+        stream.begin ()
       );
-  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
-    retv = ACE_reinterpret_cast (void *,
-      ACE_static_cast (CORBA::Object_ptr, this));
-    
-  if (retv)
-    this->_add_ref ();
-  return retv;
-}
-
-const char* CORBA::PolicyCurrent::_interface_repository_id (void) const
-{
-  return "IDL:omg.org/CORBA/PolicyCurrent:1.0";
 }
 
-static const CORBA::Long _oc_CORBA_PolicyCurrent[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x43757272), ACE_NTOHL (0x656e743a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/PolicyCurrent:1.0
-  14, ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63794375), ACE_NTOHL (0x7272656e), ACE_NTOHL (0x74000000),  // name = PolicyCurrent
-};
-static CORBA::TypeCode _tc_TAO_tc_CORBA_PolicyCurrent (CORBA::tk_objref, sizeof (_oc_CORBA_PolicyCurrent), (char *) &_oc_CORBA_PolicyCurrent, 0, sizeof (CORBA::PolicyCurrent));
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (CORBA)
-TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PolicyCurrent, &_tc_TAO_tc_CORBA_PolicyCurrent)
-TAO_NAMESPACE_END
-void operator<<= (CORBA::Any &_tao_any, const CORBA::PolicyError &_tao_elem) // copying
+void CORBA::PolicyError::_tao_any_destructor (void *x)
 {
-  TAO_OutputCDR stream;
-  stream << _tao_elem;
-  _tao_any._tao_replace (
-      CORBA::_tc_PolicyError,
-      TAO_ENCAP_BYTE_ORDER,
-      stream.begin ()
-    );
+  CORBA::PolicyError *tmp = ACE_static_cast(CORBA::PolicyError*,x);
+  delete tmp;
 }
 
 void operator<<= (CORBA::Any &_tao_any, CORBA::PolicyError *_tao_elem) // non copying
 {
-  TAO_OutputCDR stream;
-  stream << *_tao_elem;
-  _tao_any._tao_replace (
-      CORBA::_tc_PolicyError,
-      TAO_ENCAP_BYTE_ORDER,
-      stream.begin (),
-      1,
-      _tao_elem,
-      CORBA::PolicyError::_tao_any_destructor
-    );
+    TAO_OutputCDR stream;
+    stream << *_tao_elem;
+    _tao_any._tao_replace (
+        CORBA::_tc_PolicyError,
+        TAO_ENCAP_BYTE_ORDER,
+        stream.begin (),
+        1,
+        _tao_elem,
+        CORBA::PolicyError::_tao_any_destructor
+      );
 }
 
 CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::PolicyError *&_tao_elem)
 {
-  return _tao_any >>= ACE_const_cast(
-      const CORBA::PolicyError*&,
-      _tao_elem
-    );
+  ACE_TRY_NEW_ENV
+  {
+    CORBA::TypeCode_var type = _tao_any.type ();
+    if (!type->equivalent (CORBA::_tc_PolicyError, ACE_TRY_ENV)) // not equal
+      {
+        _tao_elem = 0;
+        return 0;
+      }
+    ACE_TRY_CHECK;
+    if (_tao_any.any_owns_data ())
+    {
+      _tao_elem = (CORBA::PolicyError *)_tao_any.value ();
+      return 1;
+    }
+    else
+    {
+      ACE_NEW_RETURN (_tao_elem, CORBA::PolicyError, 0);
+      TAO_InputCDR stream (
+          _tao_any._tao_get_cdr (),
+          _tao_any._tao_byte_order ()
+        );
+      if (stream >> *_tao_elem)
+      {
+        ((CORBA::Any *)&_tao_any)->_tao_replace (
+            CORBA::_tc_PolicyError,
+            1,
+            ACE_reinterpret_cast (void *, _tao_elem),
+            CORBA::PolicyError::_tao_any_destructor
+          );
+        return 1;
+      }
+      else
+      {
+        delete _tao_elem;
+        _tao_elem = 0;
+      }
+    }
+  }
+  ACE_CATCHANY
+  {
+    delete _tao_elem;
+    _tao_elem = 0;
+    return 0;
+  }
+  ACE_ENDTRY;
+  return 0;
 }
 
 CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::PolicyError *&_tao_elem)
 {
-  _tao_elem = 0;
   ACE_TRY_NEW_ENV
   {
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (CORBA::_tc_PolicyError, ACE_TRY_ENV)) // not equal
       {
+        _tao_elem = 0;
         return 0;
       }
     ACE_TRY_CHECK;
@@ -1819,38 +723,33 @@
     }
     else
     {
-      CORBA::PolicyError *tmp;
-      ACE_NEW_RETURN (tmp, CORBA::PolicyError, 0);
+      ACE_NEW_RETURN (_tao_elem, CORBA::PolicyError, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
         );
-      CORBA::String_var interface_repository_id;
-      if (!(stream >> interface_repository_id.out ()))
-        return 0;
-      if (ACE_OS::strcmp (
-          interface_repository_id.in (),
-          "IDL:omg.org/CORBA/PolicyError:1.0"))
-        return 0;
-      if (stream >> *tmp)
+      if (stream >> *(CORBA::PolicyError *)_tao_elem)
       {
         ((CORBA::Any *)&_tao_any)->_tao_replace (
             CORBA::_tc_PolicyError,
             1,
-            tmp,
+            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::PolicyError *&, _tao_elem)),
             CORBA::PolicyError::_tao_any_destructor
           );
-        _tao_elem = tmp;
         return 1;
       }
       else
       {
-        delete tmp;
+        delete ACE_const_cast (CORBA::PolicyError *&, _tao_elem);
+        _tao_elem = 0;
       }
     }
   }
   ACE_CATCHANY
   {
+    delete ACE_const_cast (CORBA::PolicyError *&, _tao_elem);
+    _tao_elem = 0;
+    return 0;
   }
   ACE_ENDTRY;
   return 0;
@@ -1858,45 +757,93 @@
 
 void operator<<= (CORBA::Any &_tao_any, const CORBA::InvalidPolicies &_tao_elem) // copying
 {
-  TAO_OutputCDR stream;
-  stream << _tao_elem;
-  _tao_any._tao_replace (
-      CORBA::_tc_InvalidPolicies,
-      TAO_ENCAP_BYTE_ORDER,
-      stream.begin ()
-    );
+    TAO_OutputCDR stream;
+    stream << _tao_elem;
+    _tao_any._tao_replace (
+        CORBA::_tc_InvalidPolicies,
+        TAO_ENCAP_BYTE_ORDER,
+        stream.begin ()
+      );
+}
+
+void CORBA::InvalidPolicies::_tao_any_destructor (void *x)
+{
+  CORBA::InvalidPolicies *tmp = ACE_static_cast(CORBA::InvalidPolicies*,x);
+  delete tmp;
 }
 
 void operator<<= (CORBA::Any &_tao_any, CORBA::InvalidPolicies *_tao_elem) // non copying
 {
-  TAO_OutputCDR stream;
-  stream << *_tao_elem;
-  _tao_any._tao_replace (
-      CORBA::_tc_InvalidPolicies,
-      TAO_ENCAP_BYTE_ORDER,
-      stream.begin (),
-      1,
-      _tao_elem,
-      CORBA::InvalidPolicies::_tao_any_destructor
-    );
+    TAO_OutputCDR stream;
+    stream << *_tao_elem;
+    _tao_any._tao_replace (
+        CORBA::_tc_InvalidPolicies,
+        TAO_ENCAP_BYTE_ORDER,
+        stream.begin (),
+        1,
+        _tao_elem,
+        CORBA::InvalidPolicies::_tao_any_destructor
+      );
 }
 
 CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::InvalidPolicies *&_tao_elem)
 {
-  return _tao_any >>= ACE_const_cast(
-      const CORBA::InvalidPolicies*&,
-      _tao_elem
-    );
+  ACE_TRY_NEW_ENV
+  {
+    CORBA::TypeCode_var type = _tao_any.type ();
+    if (!type->equivalent (CORBA::_tc_InvalidPolicies, ACE_TRY_ENV)) // not equal
+      {
+        _tao_elem = 0;
+        return 0;
+      }
+    ACE_TRY_CHECK;
+    if (_tao_any.any_owns_data ())
+    {
+      _tao_elem = (CORBA::InvalidPolicies *)_tao_any.value ();
+      return 1;
+    }
+    else
+    {
+      ACE_NEW_RETURN (_tao_elem, CORBA::InvalidPolicies, 0);
+      TAO_InputCDR stream (
+          _tao_any._tao_get_cdr (),
+          _tao_any._tao_byte_order ()
+        );
+      if (stream >> *_tao_elem)
+      {
+        ((CORBA::Any *)&_tao_any)->_tao_replace (
+            CORBA::_tc_InvalidPolicies,
+            1,
+            ACE_reinterpret_cast (void *, _tao_elem),
+            CORBA::InvalidPolicies::_tao_any_destructor
+          );
+        return 1;
+      }
+      else
+      {
+        delete _tao_elem;
+        _tao_elem = 0;
+      }
+    }
+  }
+  ACE_CATCHANY
+  {
+    delete _tao_elem;
+    _tao_elem = 0;
+    return 0;
+  }
+  ACE_ENDTRY;
+  return 0;
 }
 
 CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::InvalidPolicies *&_tao_elem)
 {
-  _tao_elem = 0;
   ACE_TRY_NEW_ENV
   {
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (CORBA::_tc_InvalidPolicies, ACE_TRY_ENV)) // not equal
       {
+        _tao_elem = 0;
         return 0;
       }
     ACE_TRY_CHECK;
@@ -1907,278 +854,371 @@
     }
     else
     {
-      CORBA::InvalidPolicies *tmp;
-      ACE_NEW_RETURN (tmp, CORBA::InvalidPolicies, 0);
+      ACE_NEW_RETURN (_tao_elem, CORBA::InvalidPolicies, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
         );
-      CORBA::String_var interface_repository_id;
-      if (!(stream >> interface_repository_id.out ()))
-        return 0;
-      if (ACE_OS::strcmp (
-          interface_repository_id.in (),
-          "IDL:omg.org/CORBA/InvalidPolicies:1.0"))
-        return 0;
-      if (stream >> *tmp)
+      if (stream >> *(CORBA::InvalidPolicies *)_tao_elem)
       {
         ((CORBA::Any *)&_tao_any)->_tao_replace (
             CORBA::_tc_InvalidPolicies,
             1,
-            tmp,
+            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::InvalidPolicies *&, _tao_elem)),
             CORBA::InvalidPolicies::_tao_any_destructor
           );
-        _tao_elem = tmp;
         return 1;
       }
       else
       {
-        delete tmp;
+        delete ACE_const_cast (CORBA::InvalidPolicies *&, _tao_elem);
+        _tao_elem = 0;
       }
     }
   }
   ACE_CATCHANY
   {
+    delete ACE_const_cast (CORBA::InvalidPolicies *&, _tao_elem);
+    _tao_elem = 0;
+    return 0;
   }
   ACE_ENDTRY;
   return 0;
 }
 
+void CORBA::Policy::_tao_any_destructor (void *x)
+{
+  CORBA::Policy *tmp = ACE_static_cast(CORBA::Policy*,x);
+  CORBA::release (tmp);
+}
+
 CORBA::Policy_ptr (*_TAO_collocation_CORBA_Policy_Stub_Factory_function_pointer) (
     CORBA::Object_ptr obj
   ) = 0;
 void operator<<= (CORBA::Any &_tao_any, CORBA::Policy_ptr _tao_elem)
 {
-  TAO_OutputCDR stream;
-  if (stream << _tao_elem)
+    TAO_OutputCDR stream;
+    if (stream << _tao_elem)
+    {
+      _tao_any._tao_replace (
+          CORBA::_tc_Policy,
+          TAO_ENCAP_BYTE_ORDER,
+          stream.begin (),
+          1,
+          _tao_elem,
+          CORBA::Policy::_tao_any_destructor
+        );
+    }
+}
+
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::Policy_ptr &_tao_elem)
+{
+  ACE_TRY_NEW_ENV
+  {
+    _tao_elem = CORBA::Policy::_nil ();
+    CORBA::TypeCode_var type = _tao_any.type ();
+    if (!type->equivalent (CORBA::_tc_Policy, ACE_TRY_ENV)) // not equal
+      {
+        return 0;
+      }
+    ACE_TRY_CHECK;
+    TAO_InputCDR stream (
+        _tao_any._tao_get_cdr (),
+        _tao_any._tao_byte_order ()
+      );
+    CORBA::Object_var _tao_obj_var;
+    if (stream >> _tao_obj_var.out ())
+    {
+      _tao_elem = CORBA::Policy::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
+      ACE_TRY_CHECK;
+      ((CORBA::Any *)&_tao_any)->_tao_replace (
+          CORBA::_tc_Policy,
+          1,
+          _tao_elem,
+          CORBA::Policy::_tao_any_destructor
+        );
+      return 1;
+    }
+  }
+  ACE_CATCHANY
+  {
+    _tao_elem = CORBA::Policy::_nil ();
+    return 0;
+  }
+  ACE_ENDTRY;
+  _tao_elem = CORBA::Policy::_nil ();
+  return 0;
+}
+
+// ****************************************************************
+
+void operator<<= (
+    CORBA::Any &_tao_any,
+    const CORBA::PolicyList &_tao_elem
+  ) // copying
+{
+    TAO_OutputCDR stream;
+    if (stream << _tao_elem)
+    {
+      _tao_any._tao_replace (
+          CORBA::_tc_PolicyList,
+          TAO_ENCAP_BYTE_ORDER,
+          stream.begin ()
+        );
+    }
+}
+
+void CORBA::PolicyList::_tao_any_destructor (void *x)
+{
+  CORBA::PolicyList *tmp = ACE_static_cast(CORBA::PolicyList*,x);
+  delete tmp;
+}
+
+void operator<<= (CORBA::Any &_tao_any, CORBA::PolicyList *_tao_elem) // non copying
+{
+    TAO_OutputCDR stream;
+    stream << *_tao_elem;
+    _tao_any._tao_replace (
+        CORBA::_tc_PolicyList,
+        TAO_ENCAP_BYTE_ORDER,
+        stream.begin (),
+        1,
+        _tao_elem,
+        CORBA::PolicyList::_tao_any_destructor
+      );
+}
+
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::PolicyList *&_tao_elem)
+{
+  ACE_TRY_NEW_ENV
+  {
+    CORBA::TypeCode_var type = _tao_any.type ();
+    if (!type->equivalent (CORBA::_tc_PolicyList, ACE_TRY_ENV)) // not equal
+      {
+        _tao_elem = 0;
+        return 0;
+      }
+    ACE_TRY_CHECK;
+    if (_tao_any.any_owns_data ())
+    {
+      _tao_elem = (CORBA::PolicyList *)_tao_any.value ();
+      return 1;
+    }
+    else
+    {
+      ACE_NEW_RETURN (_tao_elem, CORBA::PolicyList, 0);
+      TAO_InputCDR stream (
+          _tao_any._tao_get_cdr (),
+          _tao_any._tao_byte_order ()
+        );
+      if (stream >> *_tao_elem)
+      {
+        ((CORBA::Any *)&_tao_any)->_tao_replace (
+            CORBA::_tc_PolicyList,
+            1,
+            ACE_reinterpret_cast (void *, _tao_elem),
+            CORBA::PolicyList::_tao_any_destructor
+          );
+        return 1;
+      }
+      else
+      {
+        delete _tao_elem;
+        _tao_elem = 0;
+      }
+    }
+  }
+  ACE_CATCHANY
   {
-    _tao_any._tao_replace (
-        CORBA::_tc_Policy, 
-        TAO_ENCAP_BYTE_ORDER,
-        stream.begin (),
-        1,
-        CORBA::Policy::_duplicate (_tao_elem),
-        CORBA::Policy::_tao_any_destructor
-      );
+    delete _tao_elem;
+    _tao_elem = 0;
+    return 0;
   }
+  ACE_ENDTRY;
+  return 0;
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::Policy_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::PolicyList *&_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = CORBA::Policy::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
-    if (!type->equivalent (CORBA::_tc_Policy, ACE_TRY_ENV)) // not equal
+    if (!type->equivalent (CORBA::_tc_PolicyList, ACE_TRY_ENV)) // not equal
       {
+        _tao_elem = 0;
         return 0;
       }
     ACE_TRY_CHECK;
-    TAO_InputCDR stream (
-        _tao_any._tao_get_cdr (),
-        _tao_any._tao_byte_order ()
-      );
-    if (stream >> _tao_elem)
+    if (_tao_any.any_owns_data ())
     {
-      ((CORBA::Any *)&_tao_any)->_tao_replace (
-          CORBA::_tc_Policy,
-          1,
-          _tao_elem,
-          CORBA::Policy::_tao_any_destructor
-        );
+      _tao_elem = (CORBA::PolicyList *)_tao_any.value ();
       return 1;
     }
+    else
+    {
+      ACE_NEW_RETURN (_tao_elem, CORBA::PolicyList, 0);
+      TAO_InputCDR stream (
+          _tao_any._tao_get_cdr (),
+          _tao_any._tao_byte_order ()
+        );
+      if (stream >> *(CORBA::PolicyList *)_tao_elem)
+      {
+        ((CORBA::Any *)&_tao_any)->_tao_replace (
+            CORBA::_tc_PolicyList,
+            1,
+            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::PolicyList *&, _tao_elem)),
+            CORBA::PolicyList::_tao_any_destructor
+          );
+        return 1;
+      }
+      else
+      {
+        delete ACE_const_cast (CORBA::PolicyList *&, _tao_elem);
+        _tao_elem = 0;
+      }
+    }
   }
   ACE_CATCHANY
   {
-    _tao_elem = CORBA::Policy::_nil ();
+    delete ACE_const_cast (CORBA::PolicyList *&, _tao_elem);
+    _tao_elem = 0;
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = CORBA::Policy::_nil ();
   return 0;
 }
 
-#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
-    defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<CORBA::Policy,CORBA::Policy_var>;
-  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<CORBA::Policy,CORBA::Policy_var>
-#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
-
 void operator<<= (
     CORBA::Any &_tao_any,
-    const CORBA::PolicyList &_tao_elem
+    const CORBA::PolicyTypeSeq &_tao_elem
   ) // copying
 {
-  TAO_OutputCDR stream;
-  if (stream << _tao_elem)
-  {
-    _tao_any._tao_replace (
-        CORBA::_tc_PolicyList,
-        TAO_ENCAP_BYTE_ORDER,
-        stream.begin ()
-      );
-  }
+    TAO_OutputCDR stream;
+    if (stream << _tao_elem)
+    {
+      _tao_any._tao_replace (
+          CORBA::_tc_PolicyTypeSeq,
+          TAO_ENCAP_BYTE_ORDER,
+          stream.begin ()
+        );
+    }
 }
 
-void operator<<= (CORBA::Any &_tao_any, CORBA::PolicyList *_tao_elem) // non copying
+void CORBA::PolicyTypeSeq::_tao_any_destructor (void *x)
 {
-  TAO_OutputCDR stream;
-  stream << *_tao_elem;
-  _tao_any._tao_replace (
-      CORBA::_tc_PolicyList,
-      TAO_ENCAP_BYTE_ORDER,
-      stream.begin (),
-      1,
-      _tao_elem,
-      CORBA::PolicyList::_tao_any_destructor
-    );
+  CORBA::PolicyTypeSeq *tmp = ACE_static_cast(CORBA::PolicyTypeSeq*,x);
+  delete tmp;
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::PolicyList *&_tao_elem)
+void operator<<= (CORBA::Any &_tao_any, CORBA::PolicyTypeSeq *_tao_elem) // non copying
 {
-  return _tao_any >>= ACE_const_cast(
-      const CORBA::PolicyList*&,
-      _tao_elem
-    );
+    TAO_OutputCDR stream;
+    stream << *_tao_elem;
+    _tao_any._tao_replace (
+        CORBA::_tc_PolicyTypeSeq,
+        TAO_ENCAP_BYTE_ORDER,
+        stream.begin (),
+        1,
+        _tao_elem,
+        CORBA::PolicyTypeSeq::_tao_any_destructor
+      );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::PolicyList *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::PolicyTypeSeq *&_tao_elem)
 {
-  _tao_elem = 0;
   ACE_TRY_NEW_ENV
   {
     CORBA::TypeCode_var type = _tao_any.type ();
-    if (!type->equivalent (CORBA::_tc_PolicyList, ACE_TRY_ENV)) // not equal
+    if (!type->equivalent (CORBA::_tc_PolicyTypeSeq, ACE_TRY_ENV)) // not equal
       {
+        _tao_elem = 0;
         return 0;
       }
     ACE_TRY_CHECK;
     if (_tao_any.any_owns_data ())
     {
-      _tao_elem = ACE_static_cast(
-          const CORBA::PolicyList*,
-          _tao_any.value ()
-        );
+      _tao_elem = (CORBA::PolicyTypeSeq *)_tao_any.value ();
       return 1;
     }
     else
     {
-      CORBA::PolicyList *tmp;
-      ACE_NEW_RETURN (tmp, CORBA::PolicyList, 0);
+      ACE_NEW_RETURN (_tao_elem, CORBA::PolicyTypeSeq, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
         );
-      if (stream >> *tmp)
+      if (stream >> *_tao_elem)
       {
         ((CORBA::Any *)&_tao_any)->_tao_replace (
-            CORBA::_tc_PolicyList,
+            CORBA::_tc_PolicyTypeSeq,
             1,
-            ACE_static_cast (void *, tmp),
-            CORBA::PolicyList::_tao_any_destructor
+            ACE_reinterpret_cast (void *, _tao_elem),
+            CORBA::PolicyTypeSeq::_tao_any_destructor
           );
-        _tao_elem = tmp;
         return 1;
       }
       else
       {
-        delete tmp;
+        delete _tao_elem;
+        _tao_elem = 0;
       }
     }
   }
   ACE_CATCHANY
   {
+    delete _tao_elem;
+    _tao_elem = 0;
+    return 0;
   }
   ACE_ENDTRY;
   return 0;
 }
 
-void operator<<= (
-    CORBA::Any &_tao_any,
-    const CORBA::PolicyTypeSeq &_tao_elem
-  ) // copying
-{
-  TAO_OutputCDR stream;
-  if (stream << _tao_elem)
-  {
-    _tao_any._tao_replace (
-        CORBA::_tc_PolicyTypeSeq,
-        TAO_ENCAP_BYTE_ORDER,
-        stream.begin ()
-      );
-  }
-}
-
-void operator<<= (CORBA::Any &_tao_any, CORBA::PolicyTypeSeq *_tao_elem) // non copying
-{
-  TAO_OutputCDR stream;
-  stream << *_tao_elem;
-  _tao_any._tao_replace (
-      CORBA::_tc_PolicyTypeSeq,
-      TAO_ENCAP_BYTE_ORDER,
-      stream.begin (),
-      1,
-      _tao_elem,
-      CORBA::PolicyTypeSeq::_tao_any_destructor
-    );
-}
-
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::PolicyTypeSeq *&_tao_elem)
-{
-  return _tao_any >>= ACE_const_cast(
-      const CORBA::PolicyTypeSeq*&,
-      _tao_elem
-    );
-}
-
 CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::PolicyTypeSeq *&_tao_elem)
 {
-  _tao_elem = 0;
   ACE_TRY_NEW_ENV
   {
     CORBA::TypeCode_var type = _tao_any.type ();
     if (!type->equivalent (CORBA::_tc_PolicyTypeSeq, ACE_TRY_ENV)) // not equal
       {
+        _tao_elem = 0;
         return 0;
       }
     ACE_TRY_CHECK;
     if (_tao_any.any_owns_data ())
     {
-      _tao_elem = ACE_static_cast(
-          const CORBA::PolicyTypeSeq*,
-          _tao_any.value ()
-        );
+      _tao_elem = (CORBA::PolicyTypeSeq *)_tao_any.value ();
       return 1;
     }
     else
     {
-      CORBA::PolicyTypeSeq *tmp;
-      ACE_NEW_RETURN (tmp, CORBA::PolicyTypeSeq, 0);
+      ACE_NEW_RETURN (_tao_elem, CORBA::PolicyTypeSeq, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
         );
-      if (stream >> *tmp)
+      if (stream >> *(CORBA::PolicyTypeSeq *)_tao_elem)
       {
         ((CORBA::Any *)&_tao_any)->_tao_replace (
             CORBA::_tc_PolicyTypeSeq,
             1,
-            ACE_static_cast (void *, tmp),
+            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::PolicyTypeSeq *&, _tao_elem)),
             CORBA::PolicyTypeSeq::_tao_any_destructor
           );
-        _tao_elem = tmp;
         return 1;
       }
       else
       {
-        delete tmp;
+        delete ACE_const_cast (CORBA::PolicyTypeSeq *&, _tao_elem);
+        _tao_elem = 0;
       }
     }
   }
   ACE_CATCHANY
   {
+    delete ACE_const_cast (CORBA::PolicyTypeSeq *&, _tao_elem);
+    _tao_elem = 0;
+    return 0;
   }
   ACE_ENDTRY;
   return 0;
@@ -2186,13 +1226,13 @@
 
 void operator<<= (CORBA::Any &_tao_any, CORBA::SetOverrideType _tao_elem)
 {
-  TAO_OutputCDR stream;
-  stream << _tao_elem;
-  _tao_any._tao_replace (
-      CORBA::_tc_SetOverrideType,
-      TAO_ENCAP_BYTE_ORDER,
-      stream.begin ()
-    );
+    TAO_OutputCDR stream;
+    stream << _tao_elem;
+    _tao_any._tao_replace (
+        CORBA::_tc_SetOverrideType,
+        TAO_ENCAP_BYTE_ORDER,
+        stream.begin ()
+      );
 }
 
 CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::SetOverrideType &_tao_elem)
@@ -2222,94 +1262,75 @@
   return 0;
 }
 
-CORBA::PolicyManager_ptr (*_TAO_collocation_CORBA_PolicyManager_Stub_Factory_function_pointer) (
-    CORBA::Object_ptr obj
-  ) = 0;
-void operator<<= (CORBA::Any &_tao_any, CORBA::PolicyManager_ptr _tao_elem)
+// ****************************************************************
+
+CORBA::Boolean
+operator<< (
+    TAO_OutputCDR &strm,
+    const CORBA_Policy_ptr _tao_objref
+  )
 {
-  TAO_OutputCDR stream;
-  if (stream << _tao_elem)
-  {
-    _tao_any._tao_replace (
-        CORBA::_tc_PolicyManager, 
-        TAO_ENCAP_BYTE_ORDER,
-        stream.begin (),
-        1,
-        CORBA::PolicyManager::_duplicate (_tao_elem),
-        CORBA::PolicyManager::_tao_any_destructor
-      );
-  }
+  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
+  return (strm << _tao_corba_obj);
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::PolicyManager_ptr &_tao_elem)
+CORBA::Boolean
+operator>> (
+    TAO_InputCDR &strm,
+    CORBA_Policy_ptr &_tao_objref
+  )
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = CORBA::PolicyManager::_nil ();
-    CORBA::TypeCode_var type = _tao_any.type ();
-    if (!type->equivalent (CORBA::_tc_PolicyManager, ACE_TRY_ENV)) // not equal
-      {
-        return 0;
-      }
-    ACE_TRY_CHECK;
-    TAO_InputCDR stream (
-        _tao_any._tao_get_cdr (),
-        _tao_any._tao_byte_order ()
-      );
-    if (stream >> _tao_elem)
-    {
-      ((CORBA::Any *)&_tao_any)->_tao_replace (
-          CORBA::_tc_PolicyManager,
-          1,
-          _tao_elem,
-          CORBA::PolicyManager::_tao_any_destructor
+    CORBA::Object_var obj;
+    if ((strm >> obj.inout ()) == 0)
+      return 0;
+    // narrow to the right type
+    _tao_objref =
+      CORBA_Policy::_narrow (
+          obj.in (),
+          ACE_TRY_ENV
         );
-      return 1;
-    }
+    ACE_TRY_CHECK;
+    return 1;
   }
   ACE_CATCHANY
   {
-    _tao_elem = CORBA::PolicyManager::_nil ();
-    return 0;
+    // do nothing
   }
   ACE_ENDTRY;
-  _tao_elem = CORBA::PolicyManager::_nil ();
   return 0;
 }
 
-#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
-    defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<CORBA::PolicyManager,CORBA::PolicyManager_var>;
-  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<CORBA::PolicyManager,CORBA::PolicyManager_var>
-#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
+void CORBA::PolicyManager::_tao_any_destructor (void *x)
+{
+  CORBA::PolicyManager *tmp = ACE_static_cast(CORBA::PolicyManager*,x);
+  CORBA::release (tmp);
+}
 
-CORBA::Current_ptr (*_TAO_collocation_CORBA_Current_Stub_Factory_function_pointer) (
-    CORBA::Object_ptr obj
-  ) = 0;
-void operator<<= (CORBA::Any &_tao_any, CORBA::Current_ptr _tao_elem)
+void operator<<= (CORBA::Any &_tao_any, CORBA::PolicyManager_ptr _tao_elem)
 {
-  TAO_OutputCDR stream;
-  if (stream << _tao_elem)
-  {
-    _tao_any._tao_replace (
-        CORBA::_tc_Current, 
-        TAO_ENCAP_BYTE_ORDER,
-        stream.begin (),
-        1,
-        CORBA::Current::_duplicate (_tao_elem),
-        CORBA::Current::_tao_any_destructor
-      );
-  }
+    TAO_OutputCDR stream;
+    if (stream << _tao_elem)
+    {
+      _tao_any._tao_replace (
+          CORBA::_tc_PolicyManager,
+          TAO_ENCAP_BYTE_ORDER,
+          stream.begin (),
+          1,
+          _tao_elem,
+          CORBA::PolicyManager::_tao_any_destructor
+        );
+    }
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::Current_ptr &_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::PolicyManager_ptr &_tao_elem)
 {
   ACE_TRY_NEW_ENV
   {
-    _tao_elem = CORBA::Current::_nil ();
+    _tao_elem = CORBA::PolicyManager::_nil ();
     CORBA::TypeCode_var type = _tao_any.type ();
-    if (!type->equivalent (CORBA::_tc_Current, ACE_TRY_ENV)) // not equal
+    if (!type->equivalent (CORBA::_tc_PolicyManager, ACE_TRY_ENV)) // not equal
       {
         return 0;
       }
@@ -2318,51 +1339,50 @@
         _tao_any._tao_get_cdr (),
         _tao_any._tao_byte_order ()
       );
-    if (stream >> _tao_elem)
+    CORBA::Object_var _tao_obj_var;
+    if (stream >> _tao_obj_var.out ())
     {
+      _tao_elem = CORBA::PolicyManager::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
+      ACE_TRY_CHECK;
       ((CORBA::Any *)&_tao_any)->_tao_replace (
-          CORBA::_tc_Current,
+          CORBA::_tc_PolicyManager,
           1,
           _tao_elem,
-          CORBA::Current::_tao_any_destructor
+          CORBA::PolicyManager::_tao_any_destructor
         );
       return 1;
     }
   }
   ACE_CATCHANY
   {
-    _tao_elem = CORBA::Current::_nil ();
+    _tao_elem = CORBA::PolicyManager::_nil ();
     return 0;
   }
   ACE_ENDTRY;
-  _tao_elem = CORBA::Current::_nil ();
+  _tao_elem = CORBA::PolicyManager::_nil ();
   return 0;
 }
 
-#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
-    defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<CORBA::Current,CORBA::Current_var>;
-  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<CORBA::Current,CORBA::Current_var>
-#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
+void CORBA::PolicyCurrent::_tao_any_destructor (void *x)
+{
+  CORBA::PolicyCurrent *tmp = ACE_static_cast(CORBA::PolicyCurrent*,x);
+  CORBA::release (tmp);
+}
 
-CORBA::PolicyCurrent_ptr (*_TAO_collocation_CORBA_PolicyCurrent_Stub_Factory_function_pointer) (
-    CORBA::Object_ptr obj
-  ) = 0;
 void operator<<= (CORBA::Any &_tao_any, CORBA::PolicyCurrent_ptr _tao_elem)
 {
-  TAO_OutputCDR stream;
-  if (stream << _tao_elem)
-  {
-    _tao_any._tao_replace (
-        CORBA::_tc_PolicyCurrent, 
-        TAO_ENCAP_BYTE_ORDER,
-        stream.begin (),
-        1,
-        CORBA::PolicyCurrent::_duplicate (_tao_elem),
-        CORBA::PolicyCurrent::_tao_any_destructor
-      );
-  }
+    TAO_OutputCDR stream;
+    if (stream << _tao_elem)
+    {
+      _tao_any._tao_replace (
+          CORBA::_tc_PolicyCurrent,
+          TAO_ENCAP_BYTE_ORDER,
+          stream.begin (),
+          1,
+          _tao_elem,
+          CORBA::PolicyCurrent::_tao_any_destructor
+        );
+    }
 }
 
 CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::PolicyCurrent_ptr &_tao_elem)
@@ -2380,8 +1400,11 @@
         _tao_any._tao_get_cdr (),
         _tao_any._tao_byte_order ()
       );
-    if (stream >> _tao_elem)
+    CORBA::Object_var _tao_obj_var;
+    if (stream >> _tao_obj_var.out ())
     {
+      _tao_elem = CORBA::PolicyCurrent::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
+      ACE_TRY_CHECK;
       ((CORBA::Any *)&_tao_any)->_tao_replace (
           CORBA::_tc_PolicyCurrent,
           1,
@@ -2401,122 +1424,20 @@
   return 0;
 }
 
-#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
-    defined (ACE_HAS_GNU_REPO)
-    template class TAO_Object_Manager<CORBA::PolicyCurrent,CORBA::PolicyCurrent_var>;
-  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
-  #  pragma instantiate TAO_Object_Manager<CORBA::PolicyCurrent,CORBA::PolicyCurrent_var>
-#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
-
-
-#if !defined _TAO_CDR_OP_CORBA_InvalidPolicies__tao_seq_UShort_CPP_
-#define _TAO_CDR_OP_CORBA_InvalidPolicies__tao_seq_UShort_CPP_
-
-CORBA::Boolean operator<< (
-    TAO_OutputCDR &strm,
-    const CORBA::InvalidPolicies::_tao_seq_UShort &_tao_sequence
-  )
-{
-  if (strm << _tao_sequence.length ())
-  {
-    // encode all elements
-    return strm.write_ushort_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
-  }
-  return 0; // error
-}
-
-CORBA::Boolean operator>> (
-    TAO_InputCDR &strm,
-    CORBA::InvalidPolicies::_tao_seq_UShort &_tao_sequence
-  )
-{
-  CORBA::ULong _tao_seq_len;
-  if (strm >> _tao_seq_len)
-  {
-    // set the length of the sequence
-    _tao_sequence.length (_tao_seq_len);
-    // If length is 0 we return true.
-    if (0 >= _tao_seq_len) 
-      return 1;
-    // retrieve all the elements
-    return strm.read_ushort_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
-  }
-  return 0; // error
-}
-
-#endif /* _TAO_CDR_OP_CORBA_InvalidPolicies__tao_seq_UShort_CPP_ */
+// ****************************************************************
 
-CORBA::Boolean operator<< (
-    TAO_OutputCDR &strm,
-    const CORBA::PolicyList &_tao_sequence
-  )
-{
-  if (strm << _tao_sequence.length ())
-  {
-    // encode all elements
-    CORBA::Boolean _tao_marshal_flag = 1;
-    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
-    {
-      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
-    }
-    return _tao_marshal_flag;
-  }
-  return 0; // error
-}
+#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
 
-CORBA::Boolean operator>> (
-    TAO_InputCDR &strm,
-    CORBA::PolicyList &_tao_sequence
-  )
-{
-  CORBA::ULong _tao_seq_len;
-  if (strm >> _tao_seq_len)
-  {
-    // set the length of the sequence
-    _tao_sequence.length (_tao_seq_len);
-    // If length is 0 we return true.
-    if (0 >= _tao_seq_len) 
-      return 1;
-    // retrieve all the elements
-    CORBA::Boolean _tao_marshal_flag = 1;
-    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
-    {
-      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
-    }
-    return _tao_marshal_flag;
-  }
-  return 0; // error
-}
+template class TAO_Unbounded_Sequence<CORBA::UShort>;
+template class TAO_Unbounded_Sequence<CORBA::ULong>;
+template class TAO_Unbounded_Object_Sequence<CORBA_Policy,CORBA_Policy_var>;
+template class TAO_Object_Manager<CORBA_Policy,CORBA_Policy_var>;
 
-CORBA::Boolean operator<< (
-    TAO_OutputCDR &strm,
-    const CORBA::PolicyTypeSeq &_tao_sequence
-  )
-{
-  if (strm << _tao_sequence.length ())
-  {
-    // encode all elements
-    return strm.write_ulong_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
-  }
-  return 0; // error
-}
+#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
 
-CORBA::Boolean operator>> (
-    TAO_InputCDR &strm,
-    CORBA::PolicyTypeSeq &_tao_sequence
-  )
-{
-  CORBA::ULong _tao_seq_len;
-  if (strm >> _tao_seq_len)
-  {
-    // set the length of the sequence
-    _tao_sequence.length (_tao_seq_len);
-    // If length is 0 we return true.
-    if (0 >= _tao_seq_len) 
-      return 1;
-    // retrieve all the elements
-    return strm.read_ulong_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
-  }
-  return 0; // error
-}
+#pragma instantiate TAO_Unbounded_Sequence<CORBA::UShort>
+#pragma instantiate TAO_Unbounded_Sequence<CORBA::ULong>
+#pragma instantiate TAO_Unbounded_Object_Sequence<CORBA_Policy,CORBA_Policy_var>
+#pragma instantiate TAO_Object_Manager<CORBA_Policy,CORBA_Policy_var>
 
+#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
