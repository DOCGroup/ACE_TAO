// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO ORB and the TAO IDL Compiler have been developed by Washington 
// University Computer Science's Distributed Object Computing Group.
//
// Information on TAO is available at
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

#include "tao/corba.h"
#include "poaC.h"
#include "poaS.h"

#if !defined (__ACE_INLINE__)
#include "poaC.i"
#endif // !defined INLINE

static const CORBA::Long _oc_PortableServer_Identifier[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f49, 0x64656e74, 0x69666965, 0x723a312e, 0x30000000,  // repository ID = IDL:PortableServer/Identifier:1.0
  11, 0x4964656e, 0x74696669, 0x65720000,  // name = Identifier
  CORBA::tk_string, 
  0, // string length
};
static CORBA::TypeCode _tc__tc_PortableServer_Identifier (CORBA::tk_alias, sizeof (_oc_PortableServer_Identifier), (unsigned char *) &_oc_PortableServer_Identifier, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::_tc_Identifier = &_tc__tc_PortableServer_Identifier;

static const CORBA::Long _oc_PortableServer_RepositoryId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  36, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f52, 0x65706f73, 0x69746f72, 0x7949643a, 0x312e3000,  // repository ID = IDL:PortableServer/RepositoryId:1.0
  13, 0x5265706f, 0x7369746f, 0x72794964, 0x0,  // name = RepositoryId
  CORBA::tk_string, 
  0, // string length
};
static CORBA::TypeCode _tc__tc_PortableServer_RepositoryId (CORBA::tk_alias, sizeof (_oc_PortableServer_RepositoryId), (unsigned char *) &_oc_PortableServer_RepositoryId, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::_tc_RepositoryId = &_tc__tc_PortableServer_RepositoryId;

PortableServer::CurrentBase_ptr PortableServer::CurrentBase::_duplicate (PortableServer::CurrentBase_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->AddRef ();
  
  return obj;
} // end of _duplicate

PortableServer::CurrentBase_ptr PortableServer::CurrentBase::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return PortableServer::CurrentBase::_nil ();
  if (!obj->_is_a ("IDL:PortableServer/CurrentBase:1.0", env))
    return PortableServer::CurrentBase::_nil ();
  if (!obj->_is_collocated () || !obj->_servant())
  {
    STUB_Object *istub;
    PortableServer::CurrentBase_ptr new_obj; // to be returned 
    if (obj->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
      return PortableServer::CurrentBase::_nil ();
    
    new_obj = new PortableServer::CurrentBase (istub); // construct obj ref using the stub object
    return new_obj;
  } // end of if

  STUB_Object *stub = obj->_servant ()->_create_stub (env);
  if (env.exception () != 0)
    return PortableServer::CurrentBase::_nil ();
  void* servant = obj->_servant ()->_downcast ("IDL:PortableServer/CurrentBase:1.0");
  return new POA_PortableServer::_tao_collocated_CurrentBase(
      ACE_reinterpret_cast(POA_PortableServer::CurrentBase_ptr, servant),
      stub
    );
}

PortableServer::CurrentBase_ptr PortableServer::CurrentBase::_bind (const char *host, CORBA::UShort port, const char *key, CORBA::Environment &env)
{
  CORBA::Object_ptr objref = CORBA::Object::_nil ();
  IIOP_Object *data = new IIOP_Object (host, port, key);
  if (!data) return PortableServer::CurrentBase::_nil ();
  // get the object_ptr using Query Interface
  if (data->QueryInterface (IID_CORBA_Object, (void **)&objref) != TAO_NOERROR)
  {
  	env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
  	return PortableServer::CurrentBase::_nil ();
  }
  data->Release (); // QueryInterface had bumped up our count
  if (CORBA::is_nil (objref))
  	return PortableServer::CurrentBase::_nil ();
  else // narrow it
  	return PortableServer::CurrentBase::_narrow (objref, env);
}

CORBA::Boolean PortableServer::CurrentBase::_is_a (const CORBA::Char *value, CORBA::Environment &_tao_environment)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/CurrentBase:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
	return 1; // success using local knowledge
  else
  	return this->CORBA_Object::_is_a (value, _tao_environment); // remote call
}

static const CORBA::Long _oc_PortableServer_CurrentBase[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f43, 0x75727265, 0x6e744261, 0x73653a31, 0x2e300000,  // repository ID = IDL:PortableServer/CurrentBase:1.0
  12, 0x43757272, 0x656e7442, 0x61736500,  // name = CurrentBase,
};
static CORBA::TypeCode _tc__tc_PortableServer_CurrentBase (CORBA::tk_objref, sizeof (_oc_PortableServer_CurrentBase), (unsigned char *) &_oc_PortableServer_CurrentBase, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::_tc_CurrentBase = &_tc__tc_PortableServer_CurrentBase;

PortableServer::Policy_ptr PortableServer::Policy::_duplicate (PortableServer::Policy_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->AddRef ();
  
  return obj;
} // end of _duplicate

PortableServer::Policy_ptr PortableServer::Policy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return PortableServer::Policy::_nil ();
  if (!obj->_is_a ("IDL:PortableServer/Policy:1.0", env))
    return PortableServer::Policy::_nil ();
  if (!obj->_is_collocated () || !obj->_servant())
  {
    STUB_Object *istub;
    PortableServer::Policy_ptr new_obj; // to be returned 
    if (obj->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
      return PortableServer::Policy::_nil ();
    
    new_obj = new PortableServer::Policy (istub); // construct obj ref using the stub object
    return new_obj;
  } // end of if

  STUB_Object *stub = obj->_servant ()->_create_stub (env);
  if (env.exception () != 0)
    return PortableServer::Policy::_nil ();
  void* servant = obj->_servant ()->_downcast ("IDL:PortableServer/Policy:1.0");
  return new POA_PortableServer::_tao_collocated_Policy(
      ACE_reinterpret_cast(POA_PortableServer::Policy_ptr, servant),
      stub
    );
}

PortableServer::Policy_ptr PortableServer::Policy::_bind (const char *host, CORBA::UShort port, const char *key, CORBA::Environment &env)
{
  CORBA::Object_ptr objref = CORBA::Object::_nil ();
  IIOP_Object *data = new IIOP_Object (host, port, key);
  if (!data) return PortableServer::Policy::_nil ();
  // get the object_ptr using Query Interface
  if (data->QueryInterface (IID_CORBA_Object, (void **)&objref) != TAO_NOERROR)
  {
  	env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
  	return PortableServer::Policy::_nil ();
  }
  data->Release (); // QueryInterface had bumped up our count
  if (CORBA::is_nil (objref))
  	return PortableServer::Policy::_nil ();
  else // narrow it
  	return PortableServer::Policy::_narrow (objref, env);
}

static const TAO_Param_Data PortableServer_Policy_copy_paramdata [] = 
{
  {PortableServer::_tc_Policy, PARAM_RETURN, 0}
};

static const TAO_Call_Data PortableServer_Policy_copy_calldata = 
{"copy", 1, 1, PortableServer_Policy_copy_paramdata, 0, 0};

PortableServer::Policy_ptr  PortableServer::Policy::copy (CORBA::Environment &env)
{
  CORBA::Object_ptr retval = CORBA::Object::_nil ();
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return PortableServer::Policy::_nil ();
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &PortableServer_Policy_copy_calldata, &retval);
  return PortableServer::Policy::_narrow (retval, env);
  
}

static const TAO_Param_Data PortableServer_Policy_destroy_paramdata [] = 
{
  {CORBA::_tc_void, PARAM_RETURN, 0}
};

static const TAO_Call_Data PortableServer_Policy_destroy_calldata = 
{"destroy", 1, 1, PortableServer_Policy_destroy_paramdata, 0, 0};

void  PortableServer::Policy::destroy (CORBA::Environment &env)
{
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return;
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &PortableServer_Policy_destroy_calldata, 0);
  return; // no value
  
}

CORBA::Boolean PortableServer::Policy::_is_a (const CORBA::Char *value, CORBA::Environment &_tao_environment)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
	return 1; // success using local knowledge
  else
  	return this->CORBA_Object::_is_a (value, _tao_environment); // remote call
}

static const CORBA::Long _oc_PortableServer_Policy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f50, 0x6f6c6963, 0x793a312e, 0x30000000,  // repository ID = IDL:PortableServer/Policy:1.0
  7, 0x506f6c69, 0x63790000,  // name = Policy,
};
static CORBA::TypeCode _tc__tc_PortableServer_Policy (CORBA::tk_objref, sizeof (_oc_PortableServer_Policy), (unsigned char *) &_oc_PortableServer_Policy, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::_tc_Policy = &_tc__tc_PortableServer_Policy;


#if !defined (_PORTABLESERVER__TAO_SEQ_POLICY_CS_)
#define _PORTABLESERVER__TAO_SEQ_POLICY_CS_

static const CORBA::Long _oc_PortableServer__tao_seq_Policy[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    60, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f50, 0x6f6c6963, 0x793a312e, 0x30000000,  // repository ID = IDL:PortableServer/Policy:1.0
    7, 0x506f6c69, 0x63790000,  // name = Policy,
  0,
};
static CORBA::TypeCode _tc__tc_PortableServer__tao_seq_Policy (CORBA::tk_sequence, sizeof (_oc_PortableServer__tao_seq_Policy), (unsigned char *) &_oc_PortableServer__tao_seq_Policy, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::_tc__tao_seq_Policy = &_tc__tc_PortableServer__tao_seq_Policy;


#endif // end #if !defined

static const CORBA::Long _oc_PortableServer_PolicyList[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f50, 0x6f6c6963, 0x794c6973, 0x743a312e, 0x30000000,  // repository ID = IDL:PortableServer/PolicyList:1.0
  11, 0x506f6c69, 0x63794c69, 0x73740000,  // name = PolicyList
  CORBA::tk_sequence, // typecode kind
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    60, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f50, 0x6f6c6963, 0x793a312e, 0x30000000,  // repository ID = IDL:PortableServer/Policy:1.0
    7, 0x506f6c69, 0x63790000,  // name = Policy,
  0,
};
static CORBA::TypeCode _tc__tc_PortableServer_PolicyList (CORBA::tk_alias, sizeof (_oc_PortableServer_PolicyList), (unsigned char *) &_oc_PortableServer_PolicyList, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::_tc_PolicyList = &_tc__tc_PortableServer_PolicyList;


#if !defined (_PORTABLESERVER__TAO_SEQ_OCTET_CS_)
#define _PORTABLESERVER__TAO_SEQ_OCTET_CS_

static const CORBA::Long _oc_PortableServer__tao_seq_Octet[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_octet,

  0,
};
static CORBA::TypeCode _tc__tc_PortableServer__tao_seq_Octet (CORBA::tk_sequence, sizeof (_oc_PortableServer__tao_seq_Octet), (unsigned char *) &_oc_PortableServer__tao_seq_Octet, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::_tc__tao_seq_Octet = &_tc__tc_PortableServer__tao_seq_Octet;


#endif // end #if !defined

static const CORBA::Long _oc_PortableServer_ObjectId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f4f, 0x626a6563, 0x7449643a, 0x312e3000,  // repository ID = IDL:PortableServer/ObjectId:1.0
  9, 0x4f626a65, 0x63744964, 0x0,  // name = ObjectId
  CORBA::tk_sequence, // typecode kind
  12, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_octet,

  0,
};
static CORBA::TypeCode _tc__tc_PortableServer_ObjectId (CORBA::tk_alias, sizeof (_oc_PortableServer_ObjectId), (unsigned char *) &_oc_PortableServer_ObjectId, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::_tc_ObjectId = &_tc__tc_PortableServer_ObjectId;

// copy constructor
PortableServer::ForwardRequest::ForwardRequest(const PortableServer::ForwardRequest &_tao_excp)
	:CORBA_UserException (CORBA::TypeCode::_duplicate (_tao_excp.type ()))
{
    this->forward_reference = _tao_excp.forward_reference;
}

// assignment operator
PortableServer::ForwardRequest&
PortableServer::ForwardRequest::operator= (const PortableServer::ForwardRequest &_tao_excp)
{
  this->type_ = CORBA::TypeCode::_duplicate (_tao_excp.type ());
  this->forward_reference = _tao_excp.forward_reference;
  return *this;
}

// special constructor
PortableServer::ForwardRequest::ForwardRequest(const CORBA::Object_ptr &_tao_forward_reference)
	: CORBA_UserException (CORBA::TypeCode::_duplicate (PortableServer::_tc_ForwardRequest))
{
    this->forward_reference = _tao_forward_reference;
}

// narrow
PortableServer::ForwardRequest_ptr 
PortableServer::ForwardRequest::_narrow(CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:PortableServer/ForwardRequest:1.0", exc->id ())) // same type
  	return ACE_dynamic_cast (PortableServer::ForwardRequest_ptr, exc);
  else
  	return 0;
}

static const CORBA::Long _oc_PortableServer_ForwardRequest[] =
{
  0, // byte order
  38, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f46, 0x6f727761, 0x72645265, 0x71756573, 0x743a312e, 0x30000000,  // repository ID = IDL:PortableServer/ForwardRequest:1.0
  15, 0x466f7277, 0x61726452, 0x65717565, 0x73740000,  // name = ForwardRequest
  1, // member count
    18, 0x666f7277, 0x6172645f, 0x72656665, 0x72656e63, 0x65000000,  // name = forward_reference
    };
static CORBA::TypeCode _tc__tc_PortableServer_ForwardRequest (CORBA::tk_struct, sizeof (_oc_PortableServer_ForwardRequest), (unsigned char *) &_oc_PortableServer_ForwardRequest, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::_tc_ForwardRequest = &_tc__tc_PortableServer_ForwardRequest;


static const CORBA::Long _oc_PortableServer_ThreadPolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  41, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f54, 0x68726561, 0x64506f6c, 0x69637956, 0x616c7565, 0x3a312e30, 0x0,  // repository ID = IDL:PortableServer/ThreadPolicyValue:1.0
  18, 0x54687265, 0x6164506f, 0x6c696379, 0x56616c75, 0x65000000,  // name = ThreadPolicyValue
  2, // member count
    15, 0x4f52425f, 0x4354524c, 0x5f4d4f44, 0x454c0000,  // name = ORB_CTRL_MODEL
    20, 0x53494e47, 0x4c455f54, 0x48524541, 0x445f4d4f, 0x44454c00,  // name = SINGLE_THREAD_MODEL
};
static CORBA::TypeCode _tc__tc_PortableServer_ThreadPolicyValue (CORBA::tk_enum, sizeof (_oc_PortableServer_ThreadPolicyValue), (unsigned char *) &_oc_PortableServer_ThreadPolicyValue, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::_tc_ThreadPolicyValue = &_tc__tc_PortableServer_ThreadPolicyValue;

PortableServer::ThreadPolicy_ptr PortableServer::ThreadPolicy::_duplicate (PortableServer::ThreadPolicy_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->AddRef ();
  
  return obj;
} // end of _duplicate

PortableServer::ThreadPolicy_ptr PortableServer::ThreadPolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return PortableServer::ThreadPolicy::_nil ();
  if (!obj->_is_a ("IDL:PortableServer/ThreadPolicy:1.0", env))
    return PortableServer::ThreadPolicy::_nil ();
  if (!obj->_is_collocated () || !obj->_servant())
  {
    STUB_Object *istub;
    PortableServer::ThreadPolicy_ptr new_obj; // to be returned 
    if (obj->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
      return PortableServer::ThreadPolicy::_nil ();
    
    new_obj = new PortableServer::ThreadPolicy (istub); // construct obj ref using the stub object
    return new_obj;
  } // end of if

  STUB_Object *stub = obj->_servant ()->_create_stub (env);
  if (env.exception () != 0)
    return PortableServer::ThreadPolicy::_nil ();
  void* servant = obj->_servant ()->_downcast ("IDL:PortableServer/ThreadPolicy:1.0");
  return new POA_PortableServer::_tao_collocated_ThreadPolicy(
      ACE_reinterpret_cast(POA_PortableServer::ThreadPolicy_ptr, servant),
      stub
    );
}

PortableServer::ThreadPolicy_ptr PortableServer::ThreadPolicy::_bind (const char *host, CORBA::UShort port, const char *key, CORBA::Environment &env)
{
  CORBA::Object_ptr objref = CORBA::Object::_nil ();
  IIOP_Object *data = new IIOP_Object (host, port, key);
  if (!data) return PortableServer::ThreadPolicy::_nil ();
  // get the object_ptr using Query Interface
  if (data->QueryInterface (IID_CORBA_Object, (void **)&objref) != TAO_NOERROR)
  {
  	env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
  	return PortableServer::ThreadPolicy::_nil ();
  }
  data->Release (); // QueryInterface had bumped up our count
  if (CORBA::is_nil (objref))
  	return PortableServer::ThreadPolicy::_nil ();
  else // narrow it
  	return PortableServer::ThreadPolicy::_narrow (objref, env);
}

static const TAO_Param_Data _get_PortableServer_ThreadPolicy_value_paramdata [] = 
{
  {PortableServer::_tc_ThreadPolicyValue, PARAM_RETURN, 0}};

static const TAO_Call_Data _get_PortableServer_ThreadPolicy_value_calldata = 
{"_get_value", 1, 1, _get_PortableServer_ThreadPolicy_value_paramdata, 0, 0};

PortableServer::ThreadPolicyValue PortableServer::ThreadPolicy::value(CORBA::Environment &env)
{
  PortableServer::ThreadPolicyValue retval;
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return retval;
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &_get_PortableServer_ThreadPolicy_value_calldata, &retval);
  return retval;
  
}

CORBA::Boolean PortableServer::ThreadPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &_tao_environment)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ThreadPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
	return 1; // success using local knowledge
  else
  	return this->CORBA_Object::_is_a (value, _tao_environment); // remote call
}

static const CORBA::Long _oc_PortableServer_ThreadPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  36, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f54, 0x68726561, 0x64506f6c, 0x6963793a, 0x312e3000,  // repository ID = IDL:PortableServer/ThreadPolicy:1.0
  13, 0x54687265, 0x6164506f, 0x6c696379, 0x0,  // name = ThreadPolicy,
};
static CORBA::TypeCode _tc__tc_PortableServer_ThreadPolicy (CORBA::tk_objref, sizeof (_oc_PortableServer_ThreadPolicy), (unsigned char *) &_oc_PortableServer_ThreadPolicy, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::_tc_ThreadPolicy = &_tc__tc_PortableServer_ThreadPolicy;


static const CORBA::Long _oc_PortableServer_LifespanPolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  43, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f4c, 0x69666573, 0x70616e50, 0x6f6c6963, 0x7956616c, 0x75653a31, 0x2e300000,  // repository ID = IDL:PortableServer/LifespanPolicyValue:1.0
  20, 0x4c696665, 0x7370616e, 0x506f6c69, 0x63795661, 0x6c756500,  // name = LifespanPolicyValue
  2, // member count
    10, 0x5452414e, 0x5349454e, 0x54000000,  // name = TRANSIENT
    11, 0x50455253, 0x49535445, 0x4e540000,  // name = PERSISTENT
};
static CORBA::TypeCode _tc__tc_PortableServer_LifespanPolicyValue (CORBA::tk_enum, sizeof (_oc_PortableServer_LifespanPolicyValue), (unsigned char *) &_oc_PortableServer_LifespanPolicyValue, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::_tc_LifespanPolicyValue = &_tc__tc_PortableServer_LifespanPolicyValue;

PortableServer::LifespanPolicy_ptr PortableServer::LifespanPolicy::_duplicate (PortableServer::LifespanPolicy_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->AddRef ();
  
  return obj;
} // end of _duplicate

PortableServer::LifespanPolicy_ptr PortableServer::LifespanPolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return PortableServer::LifespanPolicy::_nil ();
  if (!obj->_is_a ("IDL:PortableServer/LifespanPolicy:1.0", env))
    return PortableServer::LifespanPolicy::_nil ();
  if (!obj->_is_collocated () || !obj->_servant())
  {
    STUB_Object *istub;
    PortableServer::LifespanPolicy_ptr new_obj; // to be returned 
    if (obj->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
      return PortableServer::LifespanPolicy::_nil ();
    
    new_obj = new PortableServer::LifespanPolicy (istub); // construct obj ref using the stub object
    return new_obj;
  } // end of if

  STUB_Object *stub = obj->_servant ()->_create_stub (env);
  if (env.exception () != 0)
    return PortableServer::LifespanPolicy::_nil ();
  void* servant = obj->_servant ()->_downcast ("IDL:PortableServer/LifespanPolicy:1.0");
  return new POA_PortableServer::_tao_collocated_LifespanPolicy(
      ACE_reinterpret_cast(POA_PortableServer::LifespanPolicy_ptr, servant),
      stub
    );
}

PortableServer::LifespanPolicy_ptr PortableServer::LifespanPolicy::_bind (const char *host, CORBA::UShort port, const char *key, CORBA::Environment &env)
{
  CORBA::Object_ptr objref = CORBA::Object::_nil ();
  IIOP_Object *data = new IIOP_Object (host, port, key);
  if (!data) return PortableServer::LifespanPolicy::_nil ();
  // get the object_ptr using Query Interface
  if (data->QueryInterface (IID_CORBA_Object, (void **)&objref) != TAO_NOERROR)
  {
  	env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
  	return PortableServer::LifespanPolicy::_nil ();
  }
  data->Release (); // QueryInterface had bumped up our count
  if (CORBA::is_nil (objref))
  	return PortableServer::LifespanPolicy::_nil ();
  else // narrow it
  	return PortableServer::LifespanPolicy::_narrow (objref, env);
}

static const TAO_Param_Data _get_PortableServer_LifespanPolicy_value_paramdata [] = 
{
  {PortableServer::_tc_LifespanPolicyValue, PARAM_RETURN, 0}};

static const TAO_Call_Data _get_PortableServer_LifespanPolicy_value_calldata = 
{"_get_value", 1, 1, _get_PortableServer_LifespanPolicy_value_paramdata, 0, 0};

PortableServer::LifespanPolicyValue PortableServer::LifespanPolicy::value(CORBA::Environment &env)
{
  PortableServer::LifespanPolicyValue retval;
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return retval;
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &_get_PortableServer_LifespanPolicy_value_calldata, &retval);
  return retval;
  
}

CORBA::Boolean PortableServer::LifespanPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &_tao_environment)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/LifespanPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
	return 1; // success using local knowledge
  else
  	return this->CORBA_Object::_is_a (value, _tao_environment); // remote call
}

static const CORBA::Long _oc_PortableServer_LifespanPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  38, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f4c, 0x69666573, 0x70616e50, 0x6f6c6963, 0x793a312e, 0x30000000,  // repository ID = IDL:PortableServer/LifespanPolicy:1.0
  15, 0x4c696665, 0x7370616e, 0x506f6c69, 0x63790000,  // name = LifespanPolicy,
};
static CORBA::TypeCode _tc__tc_PortableServer_LifespanPolicy (CORBA::tk_objref, sizeof (_oc_PortableServer_LifespanPolicy), (unsigned char *) &_oc_PortableServer_LifespanPolicy, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::_tc_LifespanPolicy = &_tc__tc_PortableServer_LifespanPolicy;


static const CORBA::Long _oc_PortableServer_IdUniquenessPolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  47, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f49, 0x64556e69, 0x7175656e, 0x65737350, 0x6f6c6963, 0x7956616c, 0x75653a31, 0x2e300000,  // repository ID = IDL:PortableServer/IdUniquenessPolicyValue:1.0
  24, 0x4964556e, 0x69717565, 0x6e657373, 0x506f6c69, 0x63795661, 0x6c756500,  // name = IdUniquenessPolicyValue
  2, // member count
    10, 0x554e4951, 0x55455f49, 0x44000000,  // name = UNIQUE_ID
    12, 0x4d554c54, 0x49504c45, 0x5f494400,  // name = MULTIPLE_ID
};
static CORBA::TypeCode _tc__tc_PortableServer_IdUniquenessPolicyValue (CORBA::tk_enum, sizeof (_oc_PortableServer_IdUniquenessPolicyValue), (unsigned char *) &_oc_PortableServer_IdUniquenessPolicyValue, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::_tc_IdUniquenessPolicyValue = &_tc__tc_PortableServer_IdUniquenessPolicyValue;

PortableServer::IdUniquenessPolicy_ptr PortableServer::IdUniquenessPolicy::_duplicate (PortableServer::IdUniquenessPolicy_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->AddRef ();
  
  return obj;
} // end of _duplicate

PortableServer::IdUniquenessPolicy_ptr PortableServer::IdUniquenessPolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return PortableServer::IdUniquenessPolicy::_nil ();
  if (!obj->_is_a ("IDL:PortableServer/IdUniquenessPolicy:1.0", env))
    return PortableServer::IdUniquenessPolicy::_nil ();
  if (!obj->_is_collocated () || !obj->_servant())
  {
    STUB_Object *istub;
    PortableServer::IdUniquenessPolicy_ptr new_obj; // to be returned 
    if (obj->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
      return PortableServer::IdUniquenessPolicy::_nil ();
    
    new_obj = new PortableServer::IdUniquenessPolicy (istub); // construct obj ref using the stub object
    return new_obj;
  } // end of if

  STUB_Object *stub = obj->_servant ()->_create_stub (env);
  if (env.exception () != 0)
    return PortableServer::IdUniquenessPolicy::_nil ();
  void* servant = obj->_servant ()->_downcast ("IDL:PortableServer/IdUniquenessPolicy:1.0");
  return new POA_PortableServer::_tao_collocated_IdUniquenessPolicy(
      ACE_reinterpret_cast(POA_PortableServer::IdUniquenessPolicy_ptr, servant),
      stub
    );
}

PortableServer::IdUniquenessPolicy_ptr PortableServer::IdUniquenessPolicy::_bind (const char *host, CORBA::UShort port, const char *key, CORBA::Environment &env)
{
  CORBA::Object_ptr objref = CORBA::Object::_nil ();
  IIOP_Object *data = new IIOP_Object (host, port, key);
  if (!data) return PortableServer::IdUniquenessPolicy::_nil ();
  // get the object_ptr using Query Interface
  if (data->QueryInterface (IID_CORBA_Object, (void **)&objref) != TAO_NOERROR)
  {
  	env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
  	return PortableServer::IdUniquenessPolicy::_nil ();
  }
  data->Release (); // QueryInterface had bumped up our count
  if (CORBA::is_nil (objref))
  	return PortableServer::IdUniquenessPolicy::_nil ();
  else // narrow it
  	return PortableServer::IdUniquenessPolicy::_narrow (objref, env);
}

static const TAO_Param_Data _get_PortableServer_IdUniquenessPolicy_value_paramdata [] = 
{
  {PortableServer::_tc_IdUniquenessPolicyValue, PARAM_RETURN, 0}};

static const TAO_Call_Data _get_PortableServer_IdUniquenessPolicy_value_calldata = 
{"_get_value", 1, 1, _get_PortableServer_IdUniquenessPolicy_value_paramdata, 0, 0};

PortableServer::IdUniquenessPolicyValue PortableServer::IdUniquenessPolicy::value(CORBA::Environment &env)
{
  PortableServer::IdUniquenessPolicyValue retval;
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return retval;
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &_get_PortableServer_IdUniquenessPolicy_value_calldata, &retval);
  return retval;
  
}

CORBA::Boolean PortableServer::IdUniquenessPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &_tao_environment)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/IdUniquenessPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
	return 1; // success using local knowledge
  else
  	return this->CORBA_Object::_is_a (value, _tao_environment); // remote call
}

static const CORBA::Long _oc_PortableServer_IdUniquenessPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  42, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f49, 0x64556e69, 0x7175656e, 0x65737350, 0x6f6c6963, 0x793a312e, 0x30000000,  // repository ID = IDL:PortableServer/IdUniquenessPolicy:1.0
  19, 0x4964556e, 0x69717565, 0x6e657373, 0x506f6c69, 0x63790000,  // name = IdUniquenessPolicy,
};
static CORBA::TypeCode _tc__tc_PortableServer_IdUniquenessPolicy (CORBA::tk_objref, sizeof (_oc_PortableServer_IdUniquenessPolicy), (unsigned char *) &_oc_PortableServer_IdUniquenessPolicy, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::_tc_IdUniquenessPolicy = &_tc__tc_PortableServer_IdUniquenessPolicy;


static const CORBA::Long _oc_PortableServer_IdAssignmentPolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  47, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f49, 0x64417373, 0x69676e6d, 0x656e7450, 0x6f6c6963, 0x7956616c, 0x75653a31, 0x2e300000,  // repository ID = IDL:PortableServer/IdAssignmentPolicyValue:1.0
  24, 0x49644173, 0x7369676e, 0x6d656e74, 0x506f6c69, 0x63795661, 0x6c756500,  // name = IdAssignmentPolicyValue
  2, // member count
    8, 0x55534552, 0x5f494400,  // name = USER_ID
    10, 0x53595354, 0x454d5f49, 0x44000000,  // name = SYSTEM_ID
};
static CORBA::TypeCode _tc__tc_PortableServer_IdAssignmentPolicyValue (CORBA::tk_enum, sizeof (_oc_PortableServer_IdAssignmentPolicyValue), (unsigned char *) &_oc_PortableServer_IdAssignmentPolicyValue, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::_tc_IdAssignmentPolicyValue = &_tc__tc_PortableServer_IdAssignmentPolicyValue;

PortableServer::IdAssignmentPolicy_ptr PortableServer::IdAssignmentPolicy::_duplicate (PortableServer::IdAssignmentPolicy_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->AddRef ();
  
  return obj;
} // end of _duplicate

PortableServer::IdAssignmentPolicy_ptr PortableServer::IdAssignmentPolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return PortableServer::IdAssignmentPolicy::_nil ();
  if (!obj->_is_a ("IDL:PortableServer/IdAssignmentPolicy:1.0", env))
    return PortableServer::IdAssignmentPolicy::_nil ();
  if (!obj->_is_collocated () || !obj->_servant())
  {
    STUB_Object *istub;
    PortableServer::IdAssignmentPolicy_ptr new_obj; // to be returned 
    if (obj->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
      return PortableServer::IdAssignmentPolicy::_nil ();
    
    new_obj = new PortableServer::IdAssignmentPolicy (istub); // construct obj ref using the stub object
    return new_obj;
  } // end of if

  STUB_Object *stub = obj->_servant ()->_create_stub (env);
  if (env.exception () != 0)
    return PortableServer::IdAssignmentPolicy::_nil ();
  void* servant = obj->_servant ()->_downcast ("IDL:PortableServer/IdAssignmentPolicy:1.0");
  return new POA_PortableServer::_tao_collocated_IdAssignmentPolicy(
      ACE_reinterpret_cast(POA_PortableServer::IdAssignmentPolicy_ptr, servant),
      stub
    );
}

PortableServer::IdAssignmentPolicy_ptr PortableServer::IdAssignmentPolicy::_bind (const char *host, CORBA::UShort port, const char *key, CORBA::Environment &env)
{
  CORBA::Object_ptr objref = CORBA::Object::_nil ();
  IIOP_Object *data = new IIOP_Object (host, port, key);
  if (!data) return PortableServer::IdAssignmentPolicy::_nil ();
  // get the object_ptr using Query Interface
  if (data->QueryInterface (IID_CORBA_Object, (void **)&objref) != TAO_NOERROR)
  {
  	env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
  	return PortableServer::IdAssignmentPolicy::_nil ();
  }
  data->Release (); // QueryInterface had bumped up our count
  if (CORBA::is_nil (objref))
  	return PortableServer::IdAssignmentPolicy::_nil ();
  else // narrow it
  	return PortableServer::IdAssignmentPolicy::_narrow (objref, env);
}

static const TAO_Param_Data _get_PortableServer_IdAssignmentPolicy_value_paramdata [] = 
{
  {PortableServer::_tc_IdAssignmentPolicyValue, PARAM_RETURN, 0}};

static const TAO_Call_Data _get_PortableServer_IdAssignmentPolicy_value_calldata = 
{"_get_value", 1, 1, _get_PortableServer_IdAssignmentPolicy_value_paramdata, 0, 0};

PortableServer::IdAssignmentPolicyValue PortableServer::IdAssignmentPolicy::value(CORBA::Environment &env)
{
  PortableServer::IdAssignmentPolicyValue retval;
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return retval;
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &_get_PortableServer_IdAssignmentPolicy_value_calldata, &retval);
  return retval;
  
}

CORBA::Boolean PortableServer::IdAssignmentPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &_tao_environment)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/IdAssignmentPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
	return 1; // success using local knowledge
  else
  	return this->CORBA_Object::_is_a (value, _tao_environment); // remote call
}

static const CORBA::Long _oc_PortableServer_IdAssignmentPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  42, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f49, 0x64417373, 0x69676e6d, 0x656e7450, 0x6f6c6963, 0x793a312e, 0x30000000,  // repository ID = IDL:PortableServer/IdAssignmentPolicy:1.0
  19, 0x49644173, 0x7369676e, 0x6d656e74, 0x506f6c69, 0x63790000,  // name = IdAssignmentPolicy,
};
static CORBA::TypeCode _tc__tc_PortableServer_IdAssignmentPolicy (CORBA::tk_objref, sizeof (_oc_PortableServer_IdAssignmentPolicy), (unsigned char *) &_oc_PortableServer_IdAssignmentPolicy, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::_tc_IdAssignmentPolicy = &_tc__tc_PortableServer_IdAssignmentPolicy;


static const CORBA::Long _oc_PortableServer_ImplicitActivationPolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  53, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f49, 0x6d706c69, 0x63697441, 0x63746976, 0x6174696f, 0x6e506f6c, 0x69637956, 0x616c7565, 0x3a312e30, 0x0,  // repository ID = IDL:PortableServer/ImplicitActivationPolicyValue:1.0
  30, 0x496d706c, 0x69636974, 0x41637469, 0x76617469, 0x6f6e506f, 0x6c696379, 0x56616c75, 0x65000000,  // name = ImplicitActivationPolicyValue
  2, // member count
    20, 0x494d504c, 0x49434954, 0x5f414354, 0x49564154, 0x494f4e00,  // name = IMPLICIT_ACTIVATION
    23, 0x4e4f5f49, 0x4d504c49, 0x4349545f, 0x41435449, 0x56415449, 0x4f4e0000,  // name = NO_IMPLICIT_ACTIVATION
};
static CORBA::TypeCode _tc__tc_PortableServer_ImplicitActivationPolicyValue (CORBA::tk_enum, sizeof (_oc_PortableServer_ImplicitActivationPolicyValue), (unsigned char *) &_oc_PortableServer_ImplicitActivationPolicyValue, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::_tc_ImplicitActivationPolicyValue = &_tc__tc_PortableServer_ImplicitActivationPolicyValue;

PortableServer::ImplicitActivationPolicy_ptr PortableServer::ImplicitActivationPolicy::_duplicate (PortableServer::ImplicitActivationPolicy_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->AddRef ();
  
  return obj;
} // end of _duplicate

PortableServer::ImplicitActivationPolicy_ptr PortableServer::ImplicitActivationPolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return PortableServer::ImplicitActivationPolicy::_nil ();
  if (!obj->_is_a ("IDL:PortableServer/ImplicitActivationPolicy:1.0", env))
    return PortableServer::ImplicitActivationPolicy::_nil ();
  if (!obj->_is_collocated () || !obj->_servant())
  {
    STUB_Object *istub;
    PortableServer::ImplicitActivationPolicy_ptr new_obj; // to be returned 
    if (obj->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
      return PortableServer::ImplicitActivationPolicy::_nil ();
    
    new_obj = new PortableServer::ImplicitActivationPolicy (istub); // construct obj ref using the stub object
    return new_obj;
  } // end of if

  STUB_Object *stub = obj->_servant ()->_create_stub (env);
  if (env.exception () != 0)
    return PortableServer::ImplicitActivationPolicy::_nil ();
  void* servant = obj->_servant ()->_downcast ("IDL:PortableServer/ImplicitActivationPolicy:1.0");
  return new POA_PortableServer::_tao_collocated_ImplicitActivationPolicy(
      ACE_reinterpret_cast(POA_PortableServer::ImplicitActivationPolicy_ptr, servant),
      stub
    );
}

PortableServer::ImplicitActivationPolicy_ptr PortableServer::ImplicitActivationPolicy::_bind (const char *host, CORBA::UShort port, const char *key, CORBA::Environment &env)
{
  CORBA::Object_ptr objref = CORBA::Object::_nil ();
  IIOP_Object *data = new IIOP_Object (host, port, key);
  if (!data) return PortableServer::ImplicitActivationPolicy::_nil ();
  // get the object_ptr using Query Interface
  if (data->QueryInterface (IID_CORBA_Object, (void **)&objref) != TAO_NOERROR)
  {
  	env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
  	return PortableServer::ImplicitActivationPolicy::_nil ();
  }
  data->Release (); // QueryInterface had bumped up our count
  if (CORBA::is_nil (objref))
  	return PortableServer::ImplicitActivationPolicy::_nil ();
  else // narrow it
  	return PortableServer::ImplicitActivationPolicy::_narrow (objref, env);
}

static const TAO_Param_Data _get_PortableServer_ImplicitActivationPolicy_value_paramdata [] = 
{
  {PortableServer::_tc_ImplicitActivationPolicyValue, PARAM_RETURN, 0}};

static const TAO_Call_Data _get_PortableServer_ImplicitActivationPolicy_value_calldata = 
{"_get_value", 1, 1, _get_PortableServer_ImplicitActivationPolicy_value_paramdata, 0, 0};

PortableServer::ImplicitActivationPolicyValue PortableServer::ImplicitActivationPolicy::value(CORBA::Environment &env)
{
  PortableServer::ImplicitActivationPolicyValue retval;
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return retval;
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &_get_PortableServer_ImplicitActivationPolicy_value_calldata, &retval);
  return retval;
  
}

CORBA::Boolean PortableServer::ImplicitActivationPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &_tao_environment)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ImplicitActivationPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
	return 1; // success using local knowledge
  else
  	return this->CORBA_Object::_is_a (value, _tao_environment); // remote call
}

static const CORBA::Long _oc_PortableServer_ImplicitActivationPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  48, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f49, 0x6d706c69, 0x63697441, 0x63746976, 0x6174696f, 0x6e506f6c, 0x6963793a, 0x312e3000,  // repository ID = IDL:PortableServer/ImplicitActivationPolicy:1.0
  25, 0x496d706c, 0x69636974, 0x41637469, 0x76617469, 0x6f6e506f, 0x6c696379, 0x0,  // name = ImplicitActivationPolicy,
};
static CORBA::TypeCode _tc__tc_PortableServer_ImplicitActivationPolicy (CORBA::tk_objref, sizeof (_oc_PortableServer_ImplicitActivationPolicy), (unsigned char *) &_oc_PortableServer_ImplicitActivationPolicy, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::_tc_ImplicitActivationPolicy = &_tc__tc_PortableServer_ImplicitActivationPolicy;


static const CORBA::Long _oc_PortableServer_ServantRetentionPolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  51, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f53, 0x65727661, 0x6e745265, 0x74656e74, 0x696f6e50, 0x6f6c6963, 0x7956616c, 0x75653a31, 0x2e300000,  // repository ID = IDL:PortableServer/ServantRetentionPolicyValue:1.0
  28, 0x53657276, 0x616e7452, 0x6574656e, 0x74696f6e, 0x506f6c69, 0x63795661, 0x6c756500,  // name = ServantRetentionPolicyValue
  2, // member count
    7, 0x52455441, 0x494e0000,  // name = RETAIN
    11, 0x4e4f4e5f, 0x52455441, 0x494e0000,  // name = NON_RETAIN
};
static CORBA::TypeCode _tc__tc_PortableServer_ServantRetentionPolicyValue (CORBA::tk_enum, sizeof (_oc_PortableServer_ServantRetentionPolicyValue), (unsigned char *) &_oc_PortableServer_ServantRetentionPolicyValue, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::_tc_ServantRetentionPolicyValue = &_tc__tc_PortableServer_ServantRetentionPolicyValue;

PortableServer::ServantRetentionPolicy_ptr PortableServer::ServantRetentionPolicy::_duplicate (PortableServer::ServantRetentionPolicy_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->AddRef ();
  
  return obj;
} // end of _duplicate

PortableServer::ServantRetentionPolicy_ptr PortableServer::ServantRetentionPolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return PortableServer::ServantRetentionPolicy::_nil ();
  if (!obj->_is_a ("IDL:PortableServer/ServantRetentionPolicy:1.0", env))
    return PortableServer::ServantRetentionPolicy::_nil ();
  if (!obj->_is_collocated () || !obj->_servant())
  {
    STUB_Object *istub;
    PortableServer::ServantRetentionPolicy_ptr new_obj; // to be returned 
    if (obj->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
      return PortableServer::ServantRetentionPolicy::_nil ();
    
    new_obj = new PortableServer::ServantRetentionPolicy (istub); // construct obj ref using the stub object
    return new_obj;
  } // end of if

  STUB_Object *stub = obj->_servant ()->_create_stub (env);
  if (env.exception () != 0)
    return PortableServer::ServantRetentionPolicy::_nil ();
  void* servant = obj->_servant ()->_downcast ("IDL:PortableServer/ServantRetentionPolicy:1.0");
  return new POA_PortableServer::_tao_collocated_ServantRetentionPolicy(
      ACE_reinterpret_cast(POA_PortableServer::ServantRetentionPolicy_ptr, servant),
      stub
    );
}

PortableServer::ServantRetentionPolicy_ptr PortableServer::ServantRetentionPolicy::_bind (const char *host, CORBA::UShort port, const char *key, CORBA::Environment &env)
{
  CORBA::Object_ptr objref = CORBA::Object::_nil ();
  IIOP_Object *data = new IIOP_Object (host, port, key);
  if (!data) return PortableServer::ServantRetentionPolicy::_nil ();
  // get the object_ptr using Query Interface
  if (data->QueryInterface (IID_CORBA_Object, (void **)&objref) != TAO_NOERROR)
  {
  	env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
  	return PortableServer::ServantRetentionPolicy::_nil ();
  }
  data->Release (); // QueryInterface had bumped up our count
  if (CORBA::is_nil (objref))
  	return PortableServer::ServantRetentionPolicy::_nil ();
  else // narrow it
  	return PortableServer::ServantRetentionPolicy::_narrow (objref, env);
}

static const TAO_Param_Data _get_PortableServer_ServantRetentionPolicy_value_paramdata [] = 
{
  {PortableServer::_tc_ServantRetentionPolicyValue, PARAM_RETURN, 0}};

static const TAO_Call_Data _get_PortableServer_ServantRetentionPolicy_value_calldata = 
{"_get_value", 1, 1, _get_PortableServer_ServantRetentionPolicy_value_paramdata, 0, 0};

PortableServer::ServantRetentionPolicyValue PortableServer::ServantRetentionPolicy::value(CORBA::Environment &env)
{
  PortableServer::ServantRetentionPolicyValue retval;
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return retval;
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &_get_PortableServer_ServantRetentionPolicy_value_calldata, &retval);
  return retval;
  
}

CORBA::Boolean PortableServer::ServantRetentionPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &_tao_environment)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ServantRetentionPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
	return 1; // success using local knowledge
  else
  	return this->CORBA_Object::_is_a (value, _tao_environment); // remote call
}

static const CORBA::Long _oc_PortableServer_ServantRetentionPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  46, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f53, 0x65727661, 0x6e745265, 0x74656e74, 0x696f6e50, 0x6f6c6963, 0x793a312e, 0x30000000,  // repository ID = IDL:PortableServer/ServantRetentionPolicy:1.0
  23, 0x53657276, 0x616e7452, 0x6574656e, 0x74696f6e, 0x506f6c69, 0x63790000,  // name = ServantRetentionPolicy,
};
static CORBA::TypeCode _tc__tc_PortableServer_ServantRetentionPolicy (CORBA::tk_objref, sizeof (_oc_PortableServer_ServantRetentionPolicy), (unsigned char *) &_oc_PortableServer_ServantRetentionPolicy, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::_tc_ServantRetentionPolicy = &_tc__tc_PortableServer_ServantRetentionPolicy;


static const CORBA::Long _oc_PortableServer_RequestProcessingPolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  52, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f52, 0x65717565, 0x73745072, 0x6f636573, 0x73696e67, 0x506f6c69, 0x63795661, 0x6c75653a, 0x312e3000,  // repository ID = IDL:PortableServer/RequestProcessingPolicyValue:1.0
  29, 0x52657175, 0x65737450, 0x726f6365, 0x7373696e, 0x67506f6c, 0x69637956, 0x616c7565, 0x0,  // name = RequestProcessingPolicyValue
  3, // member count
    27, 0x5553455f, 0x41435449, 0x56455f4f, 0x424a4543, 0x545f4d41, 0x505f4f4e, 0x4c590000,  // name = USE_ACTIVE_OBJECT_MAP_ONLY
    20, 0x5553455f, 0x44454641, 0x554c545f, 0x53455256, 0x414e5400,  // name = USE_DEFAULT_SERVANT
    20, 0x5553455f, 0x53455256, 0x414e545f, 0x4d414e41, 0x47455200,  // name = USE_SERVANT_MANAGER
};
static CORBA::TypeCode _tc__tc_PortableServer_RequestProcessingPolicyValue (CORBA::tk_enum, sizeof (_oc_PortableServer_RequestProcessingPolicyValue), (unsigned char *) &_oc_PortableServer_RequestProcessingPolicyValue, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::_tc_RequestProcessingPolicyValue = &_tc__tc_PortableServer_RequestProcessingPolicyValue;

PortableServer::RequestProcessingPolicy_ptr PortableServer::RequestProcessingPolicy::_duplicate (PortableServer::RequestProcessingPolicy_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->AddRef ();
  
  return obj;
} // end of _duplicate

PortableServer::RequestProcessingPolicy_ptr PortableServer::RequestProcessingPolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return PortableServer::RequestProcessingPolicy::_nil ();
  if (!obj->_is_a ("IDL:PortableServer/RequestProcessingPolicy:1.0", env))
    return PortableServer::RequestProcessingPolicy::_nil ();
  if (!obj->_is_collocated () || !obj->_servant())
  {
    STUB_Object *istub;
    PortableServer::RequestProcessingPolicy_ptr new_obj; // to be returned 
    if (obj->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
      return PortableServer::RequestProcessingPolicy::_nil ();
    
    new_obj = new PortableServer::RequestProcessingPolicy (istub); // construct obj ref using the stub object
    return new_obj;
  } // end of if

  STUB_Object *stub = obj->_servant ()->_create_stub (env);
  if (env.exception () != 0)
    return PortableServer::RequestProcessingPolicy::_nil ();
  void* servant = obj->_servant ()->_downcast ("IDL:PortableServer/RequestProcessingPolicy:1.0");
  return new POA_PortableServer::_tao_collocated_RequestProcessingPolicy(
      ACE_reinterpret_cast(POA_PortableServer::RequestProcessingPolicy_ptr, servant),
      stub
    );
}

PortableServer::RequestProcessingPolicy_ptr PortableServer::RequestProcessingPolicy::_bind (const char *host, CORBA::UShort port, const char *key, CORBA::Environment &env)
{
  CORBA::Object_ptr objref = CORBA::Object::_nil ();
  IIOP_Object *data = new IIOP_Object (host, port, key);
  if (!data) return PortableServer::RequestProcessingPolicy::_nil ();
  // get the object_ptr using Query Interface
  if (data->QueryInterface (IID_CORBA_Object, (void **)&objref) != TAO_NOERROR)
  {
  	env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
  	return PortableServer::RequestProcessingPolicy::_nil ();
  }
  data->Release (); // QueryInterface had bumped up our count
  if (CORBA::is_nil (objref))
  	return PortableServer::RequestProcessingPolicy::_nil ();
  else // narrow it
  	return PortableServer::RequestProcessingPolicy::_narrow (objref, env);
}

static const TAO_Param_Data _get_PortableServer_RequestProcessingPolicy_value_paramdata [] = 
{
  {PortableServer::_tc_RequestProcessingPolicyValue, PARAM_RETURN, 0}};

static const TAO_Call_Data _get_PortableServer_RequestProcessingPolicy_value_calldata = 
{"_get_value", 1, 1, _get_PortableServer_RequestProcessingPolicy_value_paramdata, 0, 0};

PortableServer::RequestProcessingPolicyValue PortableServer::RequestProcessingPolicy::value(CORBA::Environment &env)
{
  PortableServer::RequestProcessingPolicyValue retval;
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return retval;
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &_get_PortableServer_RequestProcessingPolicy_value_calldata, &retval);
  return retval;
  
}

CORBA::Boolean PortableServer::RequestProcessingPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &_tao_environment)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/RequestProcessingPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
	return 1; // success using local knowledge
  else
  	return this->CORBA_Object::_is_a (value, _tao_environment); // remote call
}

static const CORBA::Long _oc_PortableServer_RequestProcessingPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  47, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f52, 0x65717565, 0x73745072, 0x6f636573, 0x73696e67, 0x506f6c69, 0x63793a31, 0x2e300000,  // repository ID = IDL:PortableServer/RequestProcessingPolicy:1.0
  24, 0x52657175, 0x65737450, 0x726f6365, 0x7373696e, 0x67506f6c, 0x69637900,  // name = RequestProcessingPolicy,
};
static CORBA::TypeCode _tc__tc_PortableServer_RequestProcessingPolicy (CORBA::tk_objref, sizeof (_oc_PortableServer_RequestProcessingPolicy), (unsigned char *) &_oc_PortableServer_RequestProcessingPolicy, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::_tc_RequestProcessingPolicy = &_tc__tc_PortableServer_RequestProcessingPolicy;

PortableServer::POAManager_ptr PortableServer::POAManager::_duplicate (PortableServer::POAManager_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->AddRef ();
  
  return obj;
} // end of _duplicate

PortableServer::POAManager_ptr PortableServer::POAManager::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return PortableServer::POAManager::_nil ();
  if (!obj->_is_a ("IDL:PortableServer/POAManager:1.0", env))
    return PortableServer::POAManager::_nil ();
  if (!obj->_is_collocated () || !obj->_servant())
  {
    STUB_Object *istub;
    PortableServer::POAManager_ptr new_obj; // to be returned 
    if (obj->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
      return PortableServer::POAManager::_nil ();
    
    new_obj = new PortableServer::POAManager (istub); // construct obj ref using the stub object
    return new_obj;
  } // end of if

  STUB_Object *stub = obj->_servant ()->_create_stub (env);
  if (env.exception () != 0)
    return PortableServer::POAManager::_nil ();
  void* servant = obj->_servant ()->_downcast ("IDL:PortableServer/POAManager:1.0");
  return new POA_PortableServer::_tao_collocated_POAManager(
      ACE_reinterpret_cast(POA_PortableServer::POAManager_ptr, servant),
      stub
    );
}

PortableServer::POAManager_ptr PortableServer::POAManager::_bind (const char *host, CORBA::UShort port, const char *key, CORBA::Environment &env)
{
  CORBA::Object_ptr objref = CORBA::Object::_nil ();
  IIOP_Object *data = new IIOP_Object (host, port, key);
  if (!data) return PortableServer::POAManager::_nil ();
  // get the object_ptr using Query Interface
  if (data->QueryInterface (IID_CORBA_Object, (void **)&objref) != TAO_NOERROR)
  {
  	env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
  	return PortableServer::POAManager::_nil ();
  }
  data->Release (); // QueryInterface had bumped up our count
  if (CORBA::is_nil (objref))
  	return PortableServer::POAManager::_nil ();
  else // narrow it
  	return PortableServer::POAManager::_narrow (objref, env);
}

// copy constructor
PortableServer::POAManager::AdapterInactive::AdapterInactive(const PortableServer::POAManager::AdapterInactive &_tao_excp)
	:CORBA_UserException (CORBA::TypeCode::_duplicate (_tao_excp.type ()))
{
  }

// assignment operator
PortableServer::POAManager::AdapterInactive&
PortableServer::POAManager::AdapterInactive::operator= (const PortableServer::POAManager::AdapterInactive &_tao_excp)
{
  this->type_ = CORBA::TypeCode::_duplicate (_tao_excp.type ());
  return *this;
}

// narrow
PortableServer::POAManager::AdapterInactive_ptr 
PortableServer::POAManager::AdapterInactive::_narrow(CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:PortableServer/POAManager/AdapterInactive:1.0", exc->id ())) // same type
  	return ACE_dynamic_cast (PortableServer::POAManager::AdapterInactive_ptr, exc);
  else
  	return 0;
}

static const CORBA::Long _oc_PortableServer_POAManager_AdapterInactive[] =
{
  0, // byte order
  50, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f50, 0x4f414d61, 0x6e616765, 0x722f4164, 0x61707465, 0x72496e61, 0x63746976, 0x653a312e, 0x30000000,  // repository ID = IDL:PortableServer/POAManager/AdapterInactive:1.0
  16, 0x41646170, 0x74657249, 0x6e616374, 0x69766500,  // name = AdapterInactive
  0, // member count
};
static CORBA::TypeCode _tc__tc_PortableServer_POAManager_AdapterInactive (CORBA::tk_struct, sizeof (_oc_PortableServer_POAManager_AdapterInactive), (unsigned char *) &_oc_PortableServer_POAManager_AdapterInactive, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::POAManager::_tc_AdapterInactive = &_tc__tc_PortableServer_POAManager_AdapterInactive;

static const TAO_Param_Data PortableServer_POAManager_activate_paramdata [] = 
{
  {CORBA::_tc_void, PARAM_RETURN, 0}
};

static const TAO_Call_Data PortableServer_POAManager_activate_calldata = 
{"activate", 1, 1, PortableServer_POAManager_activate_paramdata, 0, 0};

void  PortableServer::POAManager::activate (CORBA::Environment &env)
{
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return;
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &PortableServer_POAManager_activate_calldata, 0);
  return; // no value
  
}

static const TAO_Param_Data PortableServer_POAManager_hold_requests_paramdata [] = 
{
  {CORBA::_tc_void, PARAM_RETURN, 0},
  {CORBA::_tc_boolean, PARAM_IN, 0}
};

static const TAO_Call_Data PortableServer_POAManager_hold_requests_calldata = 
{"hold_requests", 1, 2, PortableServer_POAManager_hold_requests_paramdata, 0, 0};

void  PortableServer::POAManager::hold_requests (CORBA::Boolean wait_for_completion, CORBA::Environment &env)
{
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return;
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &PortableServer_POAManager_hold_requests_calldata, 0, &wait_for_completion);
  return; // no value
  
}

static const TAO_Param_Data PortableServer_POAManager_discard_requests_paramdata [] = 
{
  {CORBA::_tc_void, PARAM_RETURN, 0},
  {CORBA::_tc_boolean, PARAM_IN, 0}
};

static const TAO_Call_Data PortableServer_POAManager_discard_requests_calldata = 
{"discard_requests", 1, 2, PortableServer_POAManager_discard_requests_paramdata, 0, 0};

void  PortableServer::POAManager::discard_requests (CORBA::Boolean wait_for_completion, CORBA::Environment &env)
{
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return;
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &PortableServer_POAManager_discard_requests_calldata, 0, &wait_for_completion);
  return; // no value
  
}

static const TAO_Param_Data PortableServer_POAManager_deactivate_paramdata [] = 
{
  {CORBA::_tc_void, PARAM_RETURN, 0},
  {CORBA::_tc_boolean, PARAM_IN, 0},
  {CORBA::_tc_boolean, PARAM_IN, 0}
};

static const TAO_Call_Data PortableServer_POAManager_deactivate_calldata = 
{"deactivate", 1, 3, PortableServer_POAManager_deactivate_paramdata, 0, 0};

void  PortableServer::POAManager::deactivate (CORBA::Boolean etherealize_objects, CORBA::Boolean wait_for_completion, CORBA::Environment &env)
{
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return;
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &PortableServer_POAManager_deactivate_calldata, 0, &etherealize_objects, &wait_for_completion);
  return; // no value
  
}

CORBA::Boolean PortableServer::POAManager::_is_a (const CORBA::Char *value, CORBA::Environment &_tao_environment)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/POAManager:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
	return 1; // success using local knowledge
  else
  	return this->CORBA_Object::_is_a (value, _tao_environment); // remote call
}

static const CORBA::Long _oc_PortableServer_POAManager[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f50, 0x4f414d61, 0x6e616765, 0x723a312e, 0x30000000,  // repository ID = IDL:PortableServer/POAManager:1.0
  11, 0x504f414d, 0x616e6167, 0x65720000,  // name = POAManager,
};
static CORBA::TypeCode _tc__tc_PortableServer_POAManager (CORBA::tk_objref, sizeof (_oc_PortableServer_POAManager), (unsigned char *) &_oc_PortableServer_POAManager, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::_tc_POAManager = &_tc__tc_PortableServer_POAManager;

PortableServer::AdapterActivator_ptr PortableServer::AdapterActivator::_duplicate (PortableServer::AdapterActivator_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->AddRef ();
  
  return obj;
} // end of _duplicate

PortableServer::AdapterActivator_ptr PortableServer::AdapterActivator::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return PortableServer::AdapterActivator::_nil ();
  if (!obj->_is_a ("IDL:PortableServer/AdapterActivator:1.0", env))
    return PortableServer::AdapterActivator::_nil ();
  if (!obj->_is_collocated () || !obj->_servant())
  {
    STUB_Object *istub;
    PortableServer::AdapterActivator_ptr new_obj; // to be returned 
    if (obj->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
      return PortableServer::AdapterActivator::_nil ();
    
    new_obj = new PortableServer::AdapterActivator (istub); // construct obj ref using the stub object
    return new_obj;
  } // end of if

  STUB_Object *stub = obj->_servant ()->_create_stub (env);
  if (env.exception () != 0)
    return PortableServer::AdapterActivator::_nil ();
  void* servant = obj->_servant ()->_downcast ("IDL:PortableServer/AdapterActivator:1.0");
  return new POA_PortableServer::_tao_collocated_AdapterActivator(
      ACE_reinterpret_cast(POA_PortableServer::AdapterActivator_ptr, servant),
      stub
    );
}

PortableServer::AdapterActivator_ptr PortableServer::AdapterActivator::_bind (const char *host, CORBA::UShort port, const char *key, CORBA::Environment &env)
{
  CORBA::Object_ptr objref = CORBA::Object::_nil ();
  IIOP_Object *data = new IIOP_Object (host, port, key);
  if (!data) return PortableServer::AdapterActivator::_nil ();
  // get the object_ptr using Query Interface
  if (data->QueryInterface (IID_CORBA_Object, (void **)&objref) != TAO_NOERROR)
  {
  	env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
  	return PortableServer::AdapterActivator::_nil ();
  }
  data->Release (); // QueryInterface had bumped up our count
  if (CORBA::is_nil (objref))
  	return PortableServer::AdapterActivator::_nil ();
  else // narrow it
  	return PortableServer::AdapterActivator::_narrow (objref, env);
}

static const TAO_Param_Data PortableServer_AdapterActivator_unknown_adapter_paramdata [] = 
{
  {CORBA::_tc_boolean, PARAM_RETURN, 0},
  {PortableServer::_tc_POA, PARAM_IN, 0},
  {CORBA::_tc_string, PARAM_IN, 0}
};

static const TAO_Call_Data PortableServer_AdapterActivator_unknown_adapter_calldata = 
{"unknown_adapter", 1, 3, PortableServer_AdapterActivator_unknown_adapter_paramdata, 0, 0};

CORBA::Boolean  PortableServer::AdapterActivator::unknown_adapter (PortableServer::POA_ptr parent, const char *name, CORBA::Environment &env)
{
  CORBA::Boolean retval;
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return retval;
  }
  this->Release (); // QueryInterface has bumped up our refcount
  CORBA::Object_ptr _tao_base_parent = parent; // cast it
  istub->do_call (env, &PortableServer_AdapterActivator_unknown_adapter_calldata, &retval, &_tao_base_parent, &name);
  return retval;
  
}

CORBA::Boolean PortableServer::AdapterActivator::_is_a (const CORBA::Char *value, CORBA::Environment &_tao_environment)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/AdapterActivator:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
	return 1; // success using local knowledge
  else
  	return this->CORBA_Object::_is_a (value, _tao_environment); // remote call
}

static const CORBA::Long _oc_PortableServer_AdapterActivator[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f41, 0x64617074, 0x65724163, 0x74697661, 0x746f723a, 0x312e3000,  // repository ID = IDL:PortableServer/AdapterActivator:1.0
  17, 0x41646170, 0x74657241, 0x63746976, 0x61746f72, 0x0,  // name = AdapterActivator,
};
static CORBA::TypeCode _tc__tc_PortableServer_AdapterActivator (CORBA::tk_objref, sizeof (_oc_PortableServer_AdapterActivator), (unsigned char *) &_oc_PortableServer_AdapterActivator, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::_tc_AdapterActivator = &_tc__tc_PortableServer_AdapterActivator;

PortableServer::ServantManager_ptr PortableServer::ServantManager::_duplicate (PortableServer::ServantManager_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->AddRef ();
  
  return obj;
} // end of _duplicate

PortableServer::ServantManager_ptr PortableServer::ServantManager::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return PortableServer::ServantManager::_nil ();
  if (!obj->_is_a ("IDL:PortableServer/ServantManager:1.0", env))
    return PortableServer::ServantManager::_nil ();
  if (!obj->_is_collocated () || !obj->_servant())
  {
    STUB_Object *istub;
    PortableServer::ServantManager_ptr new_obj; // to be returned 
    if (obj->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
      return PortableServer::ServantManager::_nil ();
    
    new_obj = new PortableServer::ServantManager (istub); // construct obj ref using the stub object
    return new_obj;
  } // end of if

  STUB_Object *stub = obj->_servant ()->_create_stub (env);
  if (env.exception () != 0)
    return PortableServer::ServantManager::_nil ();
  void* servant = obj->_servant ()->_downcast ("IDL:PortableServer/ServantManager:1.0");
  return new POA_PortableServer::_tao_collocated_ServantManager(
      ACE_reinterpret_cast(POA_PortableServer::ServantManager_ptr, servant),
      stub
    );
}

PortableServer::ServantManager_ptr PortableServer::ServantManager::_bind (const char *host, CORBA::UShort port, const char *key, CORBA::Environment &env)
{
  CORBA::Object_ptr objref = CORBA::Object::_nil ();
  IIOP_Object *data = new IIOP_Object (host, port, key);
  if (!data) return PortableServer::ServantManager::_nil ();
  // get the object_ptr using Query Interface
  if (data->QueryInterface (IID_CORBA_Object, (void **)&objref) != TAO_NOERROR)
  {
  	env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
  	return PortableServer::ServantManager::_nil ();
  }
  data->Release (); // QueryInterface had bumped up our count
  if (CORBA::is_nil (objref))
  	return PortableServer::ServantManager::_nil ();
  else // narrow it
  	return PortableServer::ServantManager::_narrow (objref, env);
}

CORBA::Boolean PortableServer::ServantManager::_is_a (const CORBA::Char *value, CORBA::Environment &_tao_environment)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ServantManager:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
	return 1; // success using local knowledge
  else
  	return this->CORBA_Object::_is_a (value, _tao_environment); // remote call
}

static const CORBA::Long _oc_PortableServer_ServantManager[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  38, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f53, 0x65727661, 0x6e744d61, 0x6e616765, 0x723a312e, 0x30000000,  // repository ID = IDL:PortableServer/ServantManager:1.0
  15, 0x53657276, 0x616e744d, 0x616e6167, 0x65720000,  // name = ServantManager,
};
static CORBA::TypeCode _tc__tc_PortableServer_ServantManager (CORBA::tk_objref, sizeof (_oc_PortableServer_ServantManager), (unsigned char *) &_oc_PortableServer_ServantManager, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::_tc_ServantManager = &_tc__tc_PortableServer_ServantManager;

PortableServer::ServantActivator_ptr PortableServer::ServantActivator::_duplicate (PortableServer::ServantActivator_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->AddRef ();
  
  return obj;
} // end of _duplicate

PortableServer::ServantActivator_ptr PortableServer::ServantActivator::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return PortableServer::ServantActivator::_nil ();
  if (!obj->_is_a ("IDL:PortableServer/ServantActivator:1.0", env))
    return PortableServer::ServantActivator::_nil ();
  if (!obj->_is_collocated () || !obj->_servant())
  {
    STUB_Object *istub;
    PortableServer::ServantActivator_ptr new_obj; // to be returned 
    if (obj->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
      return PortableServer::ServantActivator::_nil ();
    
    new_obj = new PortableServer::ServantActivator (istub); // construct obj ref using the stub object
    return new_obj;
  } // end of if

  STUB_Object *stub = obj->_servant ()->_create_stub (env);
  if (env.exception () != 0)
    return PortableServer::ServantActivator::_nil ();
  void* servant = obj->_servant ()->_downcast ("IDL:PortableServer/ServantActivator:1.0");
  return new POA_PortableServer::_tao_collocated_ServantActivator(
      ACE_reinterpret_cast(POA_PortableServer::ServantActivator_ptr, servant),
      stub
    );
}

PortableServer::ServantActivator_ptr PortableServer::ServantActivator::_bind (const char *host, CORBA::UShort port, const char *key, CORBA::Environment &env)
{
  CORBA::Object_ptr objref = CORBA::Object::_nil ();
  IIOP_Object *data = new IIOP_Object (host, port, key);
  if (!data) return PortableServer::ServantActivator::_nil ();
  // get the object_ptr using Query Interface
  if (data->QueryInterface (IID_CORBA_Object, (void **)&objref) != TAO_NOERROR)
  {
  	env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
  	return PortableServer::ServantActivator::_nil ();
  }
  data->Release (); // QueryInterface had bumped up our count
  if (CORBA::is_nil (objref))
  	return PortableServer::ServantActivator::_nil ();
  else // narrow it
  	return PortableServer::ServantActivator::_narrow (objref, env);
}

PortableServer::Servant PortableServer::ServantActivator::incarnate (const PortableServer::ObjectId &oid, PortableServer::POA_ptr adapter, CORBA::Environment &env)
{
  env.exception (new CORBA::MARSHAL (CORBA::COMPLETED_NO));
  return 0;

}

void  PortableServer::ServantActivator::etherealize (const PortableServer::ObjectId &oid, PortableServer::POA_ptr adapter, PortableServer::Servant serv, CORBA::Boolean cleanup_in_progress, CORBA::Boolean remaining_activations, CORBA::Environment &env)
{
  env.exception (new CORBA::MARSHAL (CORBA::COMPLETED_NO));
  return;

}

CORBA::Boolean PortableServer::ServantActivator::_is_a (const CORBA::Char *value, CORBA::Environment &_tao_environment)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ServantActivator:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ServantManager:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
	return 1; // success using local knowledge
  else
  	return this->CORBA_Object::_is_a (value, _tao_environment); // remote call
}

static const CORBA::Long _oc_PortableServer_ServantActivator[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f53, 0x65727661, 0x6e744163, 0x74697661, 0x746f723a, 0x312e3000,  // repository ID = IDL:PortableServer/ServantActivator:1.0
  17, 0x53657276, 0x616e7441, 0x63746976, 0x61746f72, 0x0,  // name = ServantActivator,
};
static CORBA::TypeCode _tc__tc_PortableServer_ServantActivator (CORBA::tk_objref, sizeof (_oc_PortableServer_ServantActivator), (unsigned char *) &_oc_PortableServer_ServantActivator, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::_tc_ServantActivator = &_tc__tc_PortableServer_ServantActivator;

PortableServer::ServantLocator_ptr PortableServer::ServantLocator::_duplicate (PortableServer::ServantLocator_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->AddRef ();
  
  return obj;
} // end of _duplicate

PortableServer::ServantLocator_ptr PortableServer::ServantLocator::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return PortableServer::ServantLocator::_nil ();
  if (!obj->_is_a ("IDL:PortableServer/ServantLocator:1.0", env))
    return PortableServer::ServantLocator::_nil ();
  if (!obj->_is_collocated () || !obj->_servant())
  {
    STUB_Object *istub;
    PortableServer::ServantLocator_ptr new_obj; // to be returned 
    if (obj->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
      return PortableServer::ServantLocator::_nil ();
    
    new_obj = new PortableServer::ServantLocator (istub); // construct obj ref using the stub object
    return new_obj;
  } // end of if

  STUB_Object *stub = obj->_servant ()->_create_stub (env);
  if (env.exception () != 0)
    return PortableServer::ServantLocator::_nil ();
  void* servant = obj->_servant ()->_downcast ("IDL:PortableServer/ServantLocator:1.0");
  return new POA_PortableServer::_tao_collocated_ServantLocator(
      ACE_reinterpret_cast(POA_PortableServer::ServantLocator_ptr, servant),
      stub
    );
}

PortableServer::ServantLocator_ptr PortableServer::ServantLocator::_bind (const char *host, CORBA::UShort port, const char *key, CORBA::Environment &env)
{
  CORBA::Object_ptr objref = CORBA::Object::_nil ();
  IIOP_Object *data = new IIOP_Object (host, port, key);
  if (!data) return PortableServer::ServantLocator::_nil ();
  // get the object_ptr using Query Interface
  if (data->QueryInterface (IID_CORBA_Object, (void **)&objref) != TAO_NOERROR)
  {
  	env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
  	return PortableServer::ServantLocator::_nil ();
  }
  data->Release (); // QueryInterface had bumped up our count
  if (CORBA::is_nil (objref))
  	return PortableServer::ServantLocator::_nil ();
  else // narrow it
  	return PortableServer::ServantLocator::_narrow (objref, env);
}

PortableServer::Servant PortableServer::ServantLocator::preinvoke (const PortableServer::ObjectId &oid, PortableServer::POA_ptr adapter, const char *operation, PortableServer::ServantLocator::Cookie the_cookie, CORBA::Environment &env)
{
  env.exception (new CORBA::MARSHAL (CORBA::COMPLETED_NO));
  return 0;

}

void  PortableServer::ServantLocator::postinvoke (const PortableServer::ObjectId &oid, PortableServer::POA_ptr adapter, const char *operation, PortableServer::ServantLocator::Cookie the_cookie, PortableServer::Servant the_servant, CORBA::Environment &env)
{
  env.exception (new CORBA::MARSHAL (CORBA::COMPLETED_NO));
  return;

}

CORBA::Boolean PortableServer::ServantLocator::_is_a (const CORBA::Char *value, CORBA::Environment &_tao_environment)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ServantLocator:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ServantManager:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
	return 1; // success using local knowledge
  else
  	return this->CORBA_Object::_is_a (value, _tao_environment); // remote call
}

static const CORBA::Long _oc_PortableServer_ServantLocator[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  38, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f53, 0x65727661, 0x6e744c6f, 0x6361746f, 0x723a312e, 0x30000000,  // repository ID = IDL:PortableServer/ServantLocator:1.0
  15, 0x53657276, 0x616e744c, 0x6f636174, 0x6f720000,  // name = ServantLocator,
};
static CORBA::TypeCode _tc__tc_PortableServer_ServantLocator (CORBA::tk_objref, sizeof (_oc_PortableServer_ServantLocator), (unsigned char *) &_oc_PortableServer_ServantLocator, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::_tc_ServantLocator = &_tc__tc_PortableServer_ServantLocator;

PortableServer::POA_ptr PortableServer::POA::_duplicate (PortableServer::POA_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->AddRef ();
  
  return obj;
} // end of _duplicate

PortableServer::POA_ptr PortableServer::POA::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return PortableServer::POA::_nil ();
  if (!obj->_is_a ("IDL:PortableServer/POA:1.0", env))
    return PortableServer::POA::_nil ();
  if (!obj->_is_collocated () || !obj->_servant())
  {
    STUB_Object *istub;
    PortableServer::POA_ptr new_obj; // to be returned 
    if (obj->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
      return PortableServer::POA::_nil ();
    
    new_obj = new PortableServer::POA (istub); // construct obj ref using the stub object
    return new_obj;
  } // end of if

  STUB_Object *stub = obj->_servant ()->_create_stub (env);
  if (env.exception () != 0)
    return PortableServer::POA::_nil ();
  void* servant = obj->_servant ()->_downcast ("IDL:PortableServer/POA:1.0");
  return new POA_PortableServer::_tao_collocated_POA(
      ACE_reinterpret_cast(POA_PortableServer::POA_ptr, servant),
      stub
    );
}

PortableServer::POA_ptr PortableServer::POA::_bind (const char *host, CORBA::UShort port, const char *key, CORBA::Environment &env)
{
  CORBA::Object_ptr objref = CORBA::Object::_nil ();
  IIOP_Object *data = new IIOP_Object (host, port, key);
  if (!data) return PortableServer::POA::_nil ();
  // get the object_ptr using Query Interface
  if (data->QueryInterface (IID_CORBA_Object, (void **)&objref) != TAO_NOERROR)
  {
  	env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
  	return PortableServer::POA::_nil ();
  }
  data->Release (); // QueryInterface had bumped up our count
  if (CORBA::is_nil (objref))
  	return PortableServer::POA::_nil ();
  else // narrow it
  	return PortableServer::POA::_narrow (objref, env);
}

// copy constructor
PortableServer::POA::AdapterAlreadyExists::AdapterAlreadyExists(const PortableServer::POA::AdapterAlreadyExists &_tao_excp)
	:CORBA_UserException (CORBA::TypeCode::_duplicate (_tao_excp.type ()))
{
  }

// assignment operator
PortableServer::POA::AdapterAlreadyExists&
PortableServer::POA::AdapterAlreadyExists::operator= (const PortableServer::POA::AdapterAlreadyExists &_tao_excp)
{
  this->type_ = CORBA::TypeCode::_duplicate (_tao_excp.type ());
  return *this;
}

// narrow
PortableServer::POA::AdapterAlreadyExists_ptr 
PortableServer::POA::AdapterAlreadyExists::_narrow(CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:PortableServer/POA/AdapterAlreadyExists:1.0", exc->id ())) // same type
  	return ACE_dynamic_cast (PortableServer::POA::AdapterAlreadyExists_ptr, exc);
  else
  	return 0;
}

static const CORBA::Long _oc_PortableServer_POA_AdapterAlreadyExists[] =
{
  0, // byte order
  48, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f50, 0x4f412f41, 0x64617074, 0x6572416c, 0x72656164, 0x79457869, 0x7374733a, 0x312e3000,  // repository ID = IDL:PortableServer/POA/AdapterAlreadyExists:1.0
  21, 0x41646170, 0x74657241, 0x6c726561, 0x64794578, 0x69737473, 0x0,  // name = AdapterAlreadyExists
  0, // member count
};
static CORBA::TypeCode _tc__tc_PortableServer_POA_AdapterAlreadyExists (CORBA::tk_struct, sizeof (_oc_PortableServer_POA_AdapterAlreadyExists), (unsigned char *) &_oc_PortableServer_POA_AdapterAlreadyExists, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::POA::_tc_AdapterAlreadyExists = &_tc__tc_PortableServer_POA_AdapterAlreadyExists;

// copy constructor
PortableServer::POA::AdapterInactive::AdapterInactive(const PortableServer::POA::AdapterInactive &_tao_excp)
	:CORBA_UserException (CORBA::TypeCode::_duplicate (_tao_excp.type ()))
{
  }

// assignment operator
PortableServer::POA::AdapterInactive&
PortableServer::POA::AdapterInactive::operator= (const PortableServer::POA::AdapterInactive &_tao_excp)
{
  this->type_ = CORBA::TypeCode::_duplicate (_tao_excp.type ());
  return *this;
}

// narrow
PortableServer::POA::AdapterInactive_ptr 
PortableServer::POA::AdapterInactive::_narrow(CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:PortableServer/POA/AdapterInactive:1.0", exc->id ())) // same type
  	return ACE_dynamic_cast (PortableServer::POA::AdapterInactive_ptr, exc);
  else
  	return 0;
}

static const CORBA::Long _oc_PortableServer_POA_AdapterInactive[] =
{
  0, // byte order
  43, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f50, 0x4f412f41, 0x64617074, 0x6572496e, 0x61637469, 0x76653a31, 0x2e300000,  // repository ID = IDL:PortableServer/POA/AdapterInactive:1.0
  16, 0x41646170, 0x74657249, 0x6e616374, 0x69766500,  // name = AdapterInactive
  0, // member count
};
static CORBA::TypeCode _tc__tc_PortableServer_POA_AdapterInactive (CORBA::tk_struct, sizeof (_oc_PortableServer_POA_AdapterInactive), (unsigned char *) &_oc_PortableServer_POA_AdapterInactive, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::POA::_tc_AdapterInactive = &_tc__tc_PortableServer_POA_AdapterInactive;

// copy constructor
PortableServer::POA::AdapterNonExistent::AdapterNonExistent(const PortableServer::POA::AdapterNonExistent &_tao_excp)
	:CORBA_UserException (CORBA::TypeCode::_duplicate (_tao_excp.type ()))
{
  }

// assignment operator
PortableServer::POA::AdapterNonExistent&
PortableServer::POA::AdapterNonExistent::operator= (const PortableServer::POA::AdapterNonExistent &_tao_excp)
{
  this->type_ = CORBA::TypeCode::_duplicate (_tao_excp.type ());
  return *this;
}

// narrow
PortableServer::POA::AdapterNonExistent_ptr 
PortableServer::POA::AdapterNonExistent::_narrow(CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:PortableServer/POA/AdapterNonExistent:1.0", exc->id ())) // same type
  	return ACE_dynamic_cast (PortableServer::POA::AdapterNonExistent_ptr, exc);
  else
  	return 0;
}

static const CORBA::Long _oc_PortableServer_POA_AdapterNonExistent[] =
{
  0, // byte order
  46, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f50, 0x4f412f41, 0x64617074, 0x65724e6f, 0x6e457869, 0x7374656e, 0x743a312e, 0x30000000,  // repository ID = IDL:PortableServer/POA/AdapterNonExistent:1.0
  19, 0x41646170, 0x7465724e, 0x6f6e4578, 0x69737465, 0x6e740000,  // name = AdapterNonExistent
  0, // member count
};
static CORBA::TypeCode _tc__tc_PortableServer_POA_AdapterNonExistent (CORBA::tk_struct, sizeof (_oc_PortableServer_POA_AdapterNonExistent), (unsigned char *) &_oc_PortableServer_POA_AdapterNonExistent, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::POA::_tc_AdapterNonExistent = &_tc__tc_PortableServer_POA_AdapterNonExistent;

// copy constructor
PortableServer::POA::InvalidPolicy::InvalidPolicy(const PortableServer::POA::InvalidPolicy &_tao_excp)
	:CORBA_UserException (CORBA::TypeCode::_duplicate (_tao_excp.type ()))
{
    this->index = _tao_excp.index;
}

// assignment operator
PortableServer::POA::InvalidPolicy&
PortableServer::POA::InvalidPolicy::operator= (const PortableServer::POA::InvalidPolicy &_tao_excp)
{
  this->type_ = CORBA::TypeCode::_duplicate (_tao_excp.type ());
  this->index = _tao_excp.index;
  return *this;
}

// special constructor
PortableServer::POA::InvalidPolicy::InvalidPolicy(const CORBA::UShort _tao_index)
	: CORBA_UserException (CORBA::TypeCode::_duplicate (PortableServer::POA::_tc_InvalidPolicy))
{
    this->index = _tao_index;
}

// narrow
PortableServer::POA::InvalidPolicy_ptr 
PortableServer::POA::InvalidPolicy::_narrow(CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:PortableServer/POA/InvalidPolicy:1.0", exc->id ())) // same type
  	return ACE_dynamic_cast (PortableServer::POA::InvalidPolicy_ptr, exc);
  else
  	return 0;
}

static const CORBA::Long _oc_PortableServer_POA_InvalidPolicy[] =
{
  0, // byte order
  41, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f50, 0x4f412f49, 0x6e76616c, 0x6964506f, 0x6c696379, 0x3a312e30, 0x0,  // repository ID = IDL:PortableServer/POA/InvalidPolicy:1.0
  14, 0x496e7661, 0x6c696450, 0x6f6c6963, 0x79000000,  // name = InvalidPolicy
  1, // member count
    6, 0x696e6465, 0x78000000,  // name = index
    CORBA::tk_ushort,

};
static CORBA::TypeCode _tc__tc_PortableServer_POA_InvalidPolicy (CORBA::tk_struct, sizeof (_oc_PortableServer_POA_InvalidPolicy), (unsigned char *) &_oc_PortableServer_POA_InvalidPolicy, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::POA::_tc_InvalidPolicy = &_tc__tc_PortableServer_POA_InvalidPolicy;

// copy constructor
PortableServer::POA::NoServant::NoServant(const PortableServer::POA::NoServant &_tao_excp)
	:CORBA_UserException (CORBA::TypeCode::_duplicate (_tao_excp.type ()))
{
  }

// assignment operator
PortableServer::POA::NoServant&
PortableServer::POA::NoServant::operator= (const PortableServer::POA::NoServant &_tao_excp)
{
  this->type_ = CORBA::TypeCode::_duplicate (_tao_excp.type ());
  return *this;
}

// narrow
PortableServer::POA::NoServant_ptr 
PortableServer::POA::NoServant::_narrow(CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:PortableServer/POA/NoServant:1.0", exc->id ())) // same type
  	return ACE_dynamic_cast (PortableServer::POA::NoServant_ptr, exc);
  else
  	return 0;
}

static const CORBA::Long _oc_PortableServer_POA_NoServant[] =
{
  0, // byte order
  37, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f50, 0x4f412f4e, 0x6f536572, 0x76616e74, 0x3a312e30, 0x0,  // repository ID = IDL:PortableServer/POA/NoServant:1.0
  10, 0x4e6f5365, 0x7276616e, 0x74000000,  // name = NoServant
  0, // member count
};
static CORBA::TypeCode _tc__tc_PortableServer_POA_NoServant (CORBA::tk_struct, sizeof (_oc_PortableServer_POA_NoServant), (unsigned char *) &_oc_PortableServer_POA_NoServant, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::POA::_tc_NoServant = &_tc__tc_PortableServer_POA_NoServant;

// copy constructor
PortableServer::POA::ObjectAlreadyActive::ObjectAlreadyActive(const PortableServer::POA::ObjectAlreadyActive &_tao_excp)
	:CORBA_UserException (CORBA::TypeCode::_duplicate (_tao_excp.type ()))
{
  }

// assignment operator
PortableServer::POA::ObjectAlreadyActive&
PortableServer::POA::ObjectAlreadyActive::operator= (const PortableServer::POA::ObjectAlreadyActive &_tao_excp)
{
  this->type_ = CORBA::TypeCode::_duplicate (_tao_excp.type ());
  return *this;
}

// narrow
PortableServer::POA::ObjectAlreadyActive_ptr 
PortableServer::POA::ObjectAlreadyActive::_narrow(CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:PortableServer/POA/ObjectAlreadyActive:1.0", exc->id ())) // same type
  	return ACE_dynamic_cast (PortableServer::POA::ObjectAlreadyActive_ptr, exc);
  else
  	return 0;
}

static const CORBA::Long _oc_PortableServer_POA_ObjectAlreadyActive[] =
{
  0, // byte order
  47, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f50, 0x4f412f4f, 0x626a6563, 0x74416c72, 0x65616479, 0x41637469, 0x76653a31, 0x2e300000,  // repository ID = IDL:PortableServer/POA/ObjectAlreadyActive:1.0
  20, 0x4f626a65, 0x6374416c, 0x72656164, 0x79416374, 0x69766500,  // name = ObjectAlreadyActive
  0, // member count
};
static CORBA::TypeCode _tc__tc_PortableServer_POA_ObjectAlreadyActive (CORBA::tk_struct, sizeof (_oc_PortableServer_POA_ObjectAlreadyActive), (unsigned char *) &_oc_PortableServer_POA_ObjectAlreadyActive, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::POA::_tc_ObjectAlreadyActive = &_tc__tc_PortableServer_POA_ObjectAlreadyActive;

// copy constructor
PortableServer::POA::ObjectNotActive::ObjectNotActive(const PortableServer::POA::ObjectNotActive &_tao_excp)
	:CORBA_UserException (CORBA::TypeCode::_duplicate (_tao_excp.type ()))
{
  }

// assignment operator
PortableServer::POA::ObjectNotActive&
PortableServer::POA::ObjectNotActive::operator= (const PortableServer::POA::ObjectNotActive &_tao_excp)
{
  this->type_ = CORBA::TypeCode::_duplicate (_tao_excp.type ());
  return *this;
}

// narrow
PortableServer::POA::ObjectNotActive_ptr 
PortableServer::POA::ObjectNotActive::_narrow(CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:PortableServer/POA/ObjectNotActive:1.0", exc->id ())) // same type
  	return ACE_dynamic_cast (PortableServer::POA::ObjectNotActive_ptr, exc);
  else
  	return 0;
}

static const CORBA::Long _oc_PortableServer_POA_ObjectNotActive[] =
{
  0, // byte order
  43, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f50, 0x4f412f4f, 0x626a6563, 0x744e6f74, 0x41637469, 0x76653a31, 0x2e300000,  // repository ID = IDL:PortableServer/POA/ObjectNotActive:1.0
  16, 0x4f626a65, 0x63744e6f, 0x74416374, 0x69766500,  // name = ObjectNotActive
  0, // member count
};
static CORBA::TypeCode _tc__tc_PortableServer_POA_ObjectNotActive (CORBA::tk_struct, sizeof (_oc_PortableServer_POA_ObjectNotActive), (unsigned char *) &_oc_PortableServer_POA_ObjectNotActive, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::POA::_tc_ObjectNotActive = &_tc__tc_PortableServer_POA_ObjectNotActive;

// copy constructor
PortableServer::POA::ServantAlreadyActive::ServantAlreadyActive(const PortableServer::POA::ServantAlreadyActive &_tao_excp)
	:CORBA_UserException (CORBA::TypeCode::_duplicate (_tao_excp.type ()))
{
  }

// assignment operator
PortableServer::POA::ServantAlreadyActive&
PortableServer::POA::ServantAlreadyActive::operator= (const PortableServer::POA::ServantAlreadyActive &_tao_excp)
{
  this->type_ = CORBA::TypeCode::_duplicate (_tao_excp.type ());
  return *this;
}

// narrow
PortableServer::POA::ServantAlreadyActive_ptr 
PortableServer::POA::ServantAlreadyActive::_narrow(CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:PortableServer/POA/ServantAlreadyActive:1.0", exc->id ())) // same type
  	return ACE_dynamic_cast (PortableServer::POA::ServantAlreadyActive_ptr, exc);
  else
  	return 0;
}

static const CORBA::Long _oc_PortableServer_POA_ServantAlreadyActive[] =
{
  0, // byte order
  48, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f50, 0x4f412f53, 0x65727661, 0x6e74416c, 0x72656164, 0x79416374, 0x6976653a, 0x312e3000,  // repository ID = IDL:PortableServer/POA/ServantAlreadyActive:1.0
  21, 0x53657276, 0x616e7441, 0x6c726561, 0x64794163, 0x74697665, 0x0,  // name = ServantAlreadyActive
  0, // member count
};
static CORBA::TypeCode _tc__tc_PortableServer_POA_ServantAlreadyActive (CORBA::tk_struct, sizeof (_oc_PortableServer_POA_ServantAlreadyActive), (unsigned char *) &_oc_PortableServer_POA_ServantAlreadyActive, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::POA::_tc_ServantAlreadyActive = &_tc__tc_PortableServer_POA_ServantAlreadyActive;

// copy constructor
PortableServer::POA::ServantNotActive::ServantNotActive(const PortableServer::POA::ServantNotActive &_tao_excp)
	:CORBA_UserException (CORBA::TypeCode::_duplicate (_tao_excp.type ()))
{
  }

// assignment operator
PortableServer::POA::ServantNotActive&
PortableServer::POA::ServantNotActive::operator= (const PortableServer::POA::ServantNotActive &_tao_excp)
{
  this->type_ = CORBA::TypeCode::_duplicate (_tao_excp.type ());
  return *this;
}

// narrow
PortableServer::POA::ServantNotActive_ptr 
PortableServer::POA::ServantNotActive::_narrow(CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:PortableServer/POA/ServantNotActive:1.0", exc->id ())) // same type
  	return ACE_dynamic_cast (PortableServer::POA::ServantNotActive_ptr, exc);
  else
  	return 0;
}

static const CORBA::Long _oc_PortableServer_POA_ServantNotActive[] =
{
  0, // byte order
  44, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f50, 0x4f412f53, 0x65727661, 0x6e744e6f, 0x74416374, 0x6976653a, 0x312e3000,  // repository ID = IDL:PortableServer/POA/ServantNotActive:1.0
  17, 0x53657276, 0x616e744e, 0x6f744163, 0x74697665, 0x0,  // name = ServantNotActive
  0, // member count
};
static CORBA::TypeCode _tc__tc_PortableServer_POA_ServantNotActive (CORBA::tk_struct, sizeof (_oc_PortableServer_POA_ServantNotActive), (unsigned char *) &_oc_PortableServer_POA_ServantNotActive, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::POA::_tc_ServantNotActive = &_tc__tc_PortableServer_POA_ServantNotActive;

// copy constructor
PortableServer::POA::WrongAdapter::WrongAdapter(const PortableServer::POA::WrongAdapter &_tao_excp)
	:CORBA_UserException (CORBA::TypeCode::_duplicate (_tao_excp.type ()))
{
  }

// assignment operator
PortableServer::POA::WrongAdapter&
PortableServer::POA::WrongAdapter::operator= (const PortableServer::POA::WrongAdapter &_tao_excp)
{
  this->type_ = CORBA::TypeCode::_duplicate (_tao_excp.type ());
  return *this;
}

// narrow
PortableServer::POA::WrongAdapter_ptr 
PortableServer::POA::WrongAdapter::_narrow(CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:PortableServer/POA/WrongAdapter:1.0", exc->id ())) // same type
  	return ACE_dynamic_cast (PortableServer::POA::WrongAdapter_ptr, exc);
  else
  	return 0;
}

static const CORBA::Long _oc_PortableServer_POA_WrongAdapter[] =
{
  0, // byte order
  40, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f50, 0x4f412f57, 0x726f6e67, 0x41646170, 0x7465723a, 0x312e3000,  // repository ID = IDL:PortableServer/POA/WrongAdapter:1.0
  13, 0x57726f6e, 0x67416461, 0x70746572, 0x0,  // name = WrongAdapter
  0, // member count
};
static CORBA::TypeCode _tc__tc_PortableServer_POA_WrongAdapter (CORBA::tk_struct, sizeof (_oc_PortableServer_POA_WrongAdapter), (unsigned char *) &_oc_PortableServer_POA_WrongAdapter, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::POA::_tc_WrongAdapter = &_tc__tc_PortableServer_POA_WrongAdapter;

// copy constructor
PortableServer::POA::WrongPolicy::WrongPolicy(const PortableServer::POA::WrongPolicy &_tao_excp)
	:CORBA_UserException (CORBA::TypeCode::_duplicate (_tao_excp.type ()))
{
  }

// assignment operator
PortableServer::POA::WrongPolicy&
PortableServer::POA::WrongPolicy::operator= (const PortableServer::POA::WrongPolicy &_tao_excp)
{
  this->type_ = CORBA::TypeCode::_duplicate (_tao_excp.type ());
  return *this;
}

// narrow
PortableServer::POA::WrongPolicy_ptr 
PortableServer::POA::WrongPolicy::_narrow(CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:PortableServer/POA/WrongPolicy:1.0", exc->id ())) // same type
  	return ACE_dynamic_cast (PortableServer::POA::WrongPolicy_ptr, exc);
  else
  	return 0;
}

static const CORBA::Long _oc_PortableServer_POA_WrongPolicy[] =
{
  0, // byte order
  39, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f50, 0x4f412f57, 0x726f6e67, 0x506f6c69, 0x63793a31, 0x2e300000,  // repository ID = IDL:PortableServer/POA/WrongPolicy:1.0
  12, 0x57726f6e, 0x67506f6c, 0x69637900,  // name = WrongPolicy
  0, // member count
};
static CORBA::TypeCode _tc__tc_PortableServer_POA_WrongPolicy (CORBA::tk_struct, sizeof (_oc_PortableServer_POA_WrongPolicy), (unsigned char *) &_oc_PortableServer_POA_WrongPolicy, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::POA::_tc_WrongPolicy = &_tc__tc_PortableServer_POA_WrongPolicy;

static const TAO_Param_Data PortableServer_POA_create_POA_paramdata [] = 
{
  {PortableServer::_tc_POA, PARAM_RETURN, 0},
  {CORBA::_tc_string, PARAM_IN, 0},
  {PortableServer::_tc_POAManager, PARAM_IN, 0},
  {PortableServer::_tc_PolicyList, PARAM_IN, 0}
};

static const TAO_Call_Data PortableServer_POA_create_POA_calldata = 
{"create_POA", 1, 4, PortableServer_POA_create_POA_paramdata, 0, 0};

PortableServer::POA_ptr  PortableServer::POA::create_POA (const char *adapter_name, PortableServer::POAManager_ptr a_POAManager, const PortableServer::PolicyList &policies, CORBA::Environment &env)
{
  CORBA::Object_ptr retval = CORBA::Object::_nil ();
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return PortableServer::POA::_nil ();
  }
  this->Release (); // QueryInterface has bumped up our refcount
  CORBA::Object_ptr _tao_base_a_POAManager = a_POAManager; // cast it
  istub->do_call (env, &PortableServer_POA_create_POA_calldata, &retval, &adapter_name, &_tao_base_a_POAManager, &policies);
  return PortableServer::POA::_narrow (retval, env);
  
}

static const TAO_Param_Data PortableServer_POA_find_POA_paramdata [] = 
{
  {PortableServer::_tc_POA, PARAM_RETURN, 0},
  {CORBA::_tc_string, PARAM_IN, 0},
  {CORBA::_tc_boolean, PARAM_IN, 0}
};

static const TAO_Call_Data PortableServer_POA_find_POA_calldata = 
{"find_POA", 1, 3, PortableServer_POA_find_POA_paramdata, 0, 0};

PortableServer::POA_ptr  PortableServer::POA::find_POA (const char *adapter_name, CORBA::Boolean activate_it, CORBA::Environment &env)
{
  CORBA::Object_ptr retval = CORBA::Object::_nil ();
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return PortableServer::POA::_nil ();
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &PortableServer_POA_find_POA_calldata, &retval, &adapter_name, &activate_it);
  return PortableServer::POA::_narrow (retval, env);
  
}

static const TAO_Param_Data PortableServer_POA_destroy_paramdata [] = 
{
  {CORBA::_tc_void, PARAM_RETURN, 0},
  {CORBA::_tc_boolean, PARAM_IN, 0},
  {CORBA::_tc_boolean, PARAM_IN, 0}
};

static const TAO_Call_Data PortableServer_POA_destroy_calldata = 
{"destroy", 1, 3, PortableServer_POA_destroy_paramdata, 0, 0};

void  PortableServer::POA::destroy (CORBA::Boolean etherealize_objects, CORBA::Boolean wait_for_completion, CORBA::Environment &env)
{
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return;
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &PortableServer_POA_destroy_calldata, 0, &etherealize_objects, &wait_for_completion);
  return; // no value
  
}

static const TAO_Param_Data PortableServer_POA_create_thread_policy_paramdata [] = 
{
  {PortableServer::_tc_ThreadPolicy, PARAM_RETURN, 0},
  {PortableServer::_tc_ThreadPolicyValue, PARAM_IN, 0}
};

static const TAO_Call_Data PortableServer_POA_create_thread_policy_calldata = 
{"create_thread_policy", 1, 2, PortableServer_POA_create_thread_policy_paramdata, 0, 0};

PortableServer::ThreadPolicy_ptr  PortableServer::POA::create_thread_policy (PortableServer::ThreadPolicyValue value, CORBA::Environment &env)
{
  CORBA::Object_ptr retval = CORBA::Object::_nil ();
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return PortableServer::ThreadPolicy::_nil ();
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &PortableServer_POA_create_thread_policy_calldata, &retval, &value);
  return PortableServer::ThreadPolicy::_narrow (retval, env);
  
}

static const TAO_Param_Data PortableServer_POA_create_lifespan_policy_paramdata [] = 
{
  {PortableServer::_tc_LifespanPolicy, PARAM_RETURN, 0},
  {PortableServer::_tc_LifespanPolicyValue, PARAM_IN, 0}
};

static const TAO_Call_Data PortableServer_POA_create_lifespan_policy_calldata = 
{"create_lifespan_policy", 1, 2, PortableServer_POA_create_lifespan_policy_paramdata, 0, 0};

PortableServer::LifespanPolicy_ptr  PortableServer::POA::create_lifespan_policy (PortableServer::LifespanPolicyValue value, CORBA::Environment &env)
{
  CORBA::Object_ptr retval = CORBA::Object::_nil ();
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return PortableServer::LifespanPolicy::_nil ();
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &PortableServer_POA_create_lifespan_policy_calldata, &retval, &value);
  return PortableServer::LifespanPolicy::_narrow (retval, env);
  
}

static const TAO_Param_Data PortableServer_POA_create_id_uniqueness_policy_paramdata [] = 
{
  {PortableServer::_tc_IdUniquenessPolicy, PARAM_RETURN, 0},
  {PortableServer::_tc_IdUniquenessPolicyValue, PARAM_IN, 0}
};

static const TAO_Call_Data PortableServer_POA_create_id_uniqueness_policy_calldata = 
{"create_id_uniqueness_policy", 1, 2, PortableServer_POA_create_id_uniqueness_policy_paramdata, 0, 0};

PortableServer::IdUniquenessPolicy_ptr  PortableServer::POA::create_id_uniqueness_policy (PortableServer::IdUniquenessPolicyValue value, CORBA::Environment &env)
{
  CORBA::Object_ptr retval = CORBA::Object::_nil ();
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return PortableServer::IdUniquenessPolicy::_nil ();
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &PortableServer_POA_create_id_uniqueness_policy_calldata, &retval, &value);
  return PortableServer::IdUniquenessPolicy::_narrow (retval, env);
  
}

static const TAO_Param_Data PortableServer_POA_create_id_assignment_policy_paramdata [] = 
{
  {PortableServer::_tc_IdAssignmentPolicy, PARAM_RETURN, 0},
  {PortableServer::_tc_IdAssignmentPolicyValue, PARAM_IN, 0}
};

static const TAO_Call_Data PortableServer_POA_create_id_assignment_policy_calldata = 
{"create_id_assignment_policy", 1, 2, PortableServer_POA_create_id_assignment_policy_paramdata, 0, 0};

PortableServer::IdAssignmentPolicy_ptr  PortableServer::POA::create_id_assignment_policy (PortableServer::IdAssignmentPolicyValue value, CORBA::Environment &env)
{
  CORBA::Object_ptr retval = CORBA::Object::_nil ();
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return PortableServer::IdAssignmentPolicy::_nil ();
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &PortableServer_POA_create_id_assignment_policy_calldata, &retval, &value);
  return PortableServer::IdAssignmentPolicy::_narrow (retval, env);
  
}

static const TAO_Param_Data PortableServer_POA_create_implicit_activation_policy_paramdata [] = 
{
  {PortableServer::_tc_ImplicitActivationPolicy, PARAM_RETURN, 0},
  {PortableServer::_tc_ImplicitActivationPolicyValue, PARAM_IN, 0}
};

static const TAO_Call_Data PortableServer_POA_create_implicit_activation_policy_calldata = 
{"create_implicit_activation_policy", 1, 2, PortableServer_POA_create_implicit_activation_policy_paramdata, 0, 0};

PortableServer::ImplicitActivationPolicy_ptr  PortableServer::POA::create_implicit_activation_policy (PortableServer::ImplicitActivationPolicyValue value, CORBA::Environment &env)
{
  CORBA::Object_ptr retval = CORBA::Object::_nil ();
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return PortableServer::ImplicitActivationPolicy::_nil ();
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &PortableServer_POA_create_implicit_activation_policy_calldata, &retval, &value);
  return PortableServer::ImplicitActivationPolicy::_narrow (retval, env);
  
}

static const TAO_Param_Data PortableServer_POA_create_servant_retention_policy_paramdata [] = 
{
  {PortableServer::_tc_ServantRetentionPolicy, PARAM_RETURN, 0},
  {PortableServer::_tc_ServantRetentionPolicyValue, PARAM_IN, 0}
};

static const TAO_Call_Data PortableServer_POA_create_servant_retention_policy_calldata = 
{"create_servant_retention_policy", 1, 2, PortableServer_POA_create_servant_retention_policy_paramdata, 0, 0};

PortableServer::ServantRetentionPolicy_ptr  PortableServer::POA::create_servant_retention_policy (PortableServer::ServantRetentionPolicyValue value, CORBA::Environment &env)
{
  CORBA::Object_ptr retval = CORBA::Object::_nil ();
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return PortableServer::ServantRetentionPolicy::_nil ();
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &PortableServer_POA_create_servant_retention_policy_calldata, &retval, &value);
  return PortableServer::ServantRetentionPolicy::_narrow (retval, env);
  
}

static const TAO_Param_Data PortableServer_POA_create_request_processing_policy_paramdata [] = 
{
  {PortableServer::_tc_RequestProcessingPolicy, PARAM_RETURN, 0},
  {PortableServer::_tc_RequestProcessingPolicyValue, PARAM_IN, 0}
};

static const TAO_Call_Data PortableServer_POA_create_request_processing_policy_calldata = 
{"create_request_processing_policy", 1, 2, PortableServer_POA_create_request_processing_policy_paramdata, 0, 0};

PortableServer::RequestProcessingPolicy_ptr  PortableServer::POA::create_request_processing_policy (PortableServer::RequestProcessingPolicyValue value, CORBA::Environment &env)
{
  CORBA::Object_ptr retval = CORBA::Object::_nil ();
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return PortableServer::RequestProcessingPolicy::_nil ();
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &PortableServer_POA_create_request_processing_policy_calldata, &retval, &value);
  return PortableServer::RequestProcessingPolicy::_narrow (retval, env);
  
}

static const TAO_Param_Data _get_PortableServer_POA_the_name_paramdata [] = 
{
  {CORBA::_tc_string, PARAM_RETURN, 0}};

static const TAO_Call_Data _get_PortableServer_POA_the_name_calldata = 
{"_get_the_name", 1, 1, _get_PortableServer_POA_the_name_paramdata, 0, 0};

char * PortableServer::POA::the_name(CORBA::Environment &env)
{
  char *retval = 0;
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return 0;
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &_get_PortableServer_POA_the_name_calldata, &retval);
  return retval;
  
}

static const TAO_Param_Data _get_PortableServer_POA_the_parent_paramdata [] = 
{
  {PortableServer::_tc_POA, PARAM_RETURN, 0}};

static const TAO_Call_Data _get_PortableServer_POA_the_parent_calldata = 
{"_get_the_parent", 1, 1, _get_PortableServer_POA_the_parent_paramdata, 0, 0};

PortableServer::POA_ptr  PortableServer::POA::the_parent(CORBA::Environment &env)
{
  CORBA::Object_ptr retval = CORBA::Object::_nil ();
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return PortableServer::POA::_nil ();
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &_get_PortableServer_POA_the_parent_calldata, &retval);
  return PortableServer::POA::_narrow (retval, env);
  
}

static const TAO_Param_Data _get_PortableServer_POA_the_POAManager_paramdata [] = 
{
  {PortableServer::_tc_POAManager, PARAM_RETURN, 0}};

static const TAO_Call_Data _get_PortableServer_POA_the_POAManager_calldata = 
{"_get_the_POAManager", 1, 1, _get_PortableServer_POA_the_POAManager_paramdata, 0, 0};

PortableServer::POAManager_ptr  PortableServer::POA::the_POAManager(CORBA::Environment &env)
{
  CORBA::Object_ptr retval = CORBA::Object::_nil ();
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return PortableServer::POAManager::_nil ();
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &_get_PortableServer_POA_the_POAManager_calldata, &retval);
  return PortableServer::POAManager::_narrow (retval, env);
  
}

static const TAO_Param_Data _get_PortableServer_POA_the_activator_paramdata [] = 
{
  {PortableServer::_tc_AdapterActivator, PARAM_RETURN, 0}};

static const TAO_Call_Data _get_PortableServer_POA_the_activator_calldata = 
{"_get_the_activator", 1, 1, _get_PortableServer_POA_the_activator_paramdata, 0, 0};

PortableServer::AdapterActivator_ptr  PortableServer::POA::the_activator(CORBA::Environment &env)
{
  CORBA::Object_ptr retval = CORBA::Object::_nil ();
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return PortableServer::AdapterActivator::_nil ();
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &_get_PortableServer_POA_the_activator_calldata, &retval);
  return PortableServer::AdapterActivator::_narrow (retval, env);
  
}

static const TAO_Param_Data _set_PortableServer_POA_the_activator_paramdata [] = 
{
  {CORBA::_tc_void, PARAM_RETURN, 0},
  {PortableServer::_tc_AdapterActivator, PARAM_IN, 0}
};

static const TAO_Call_Data _set_PortableServer_POA_the_activator_calldata = 
{"_set_the_activator", 1, 2, _set_PortableServer_POA_the_activator_paramdata, 0, 0};

void PortableServer::POA::the_activator(PortableServer::AdapterActivator_ptr the_activator, CORBA::Environment &env)
{
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return;
  }
  this->Release (); // QueryInterface has bumped up our refcount
  CORBA::Object_ptr _tao_base_the_activator = the_activator; // cast it
  istub->do_call (env, &_set_PortableServer_POA_the_activator_calldata, 0, &_tao_base_the_activator);
  
}

static const TAO_Param_Data PortableServer_POA_get_servant_manager_paramdata [] = 
{
  {PortableServer::_tc_ServantManager, PARAM_RETURN, 0}
};

static const TAO_Call_Data PortableServer_POA_get_servant_manager_calldata = 
{"get_servant_manager", 1, 1, PortableServer_POA_get_servant_manager_paramdata, 0, 0};

PortableServer::ServantManager_ptr  PortableServer::POA::get_servant_manager (CORBA::Environment &env)
{
  CORBA::Object_ptr retval = CORBA::Object::_nil ();
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return PortableServer::ServantManager::_nil ();
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &PortableServer_POA_get_servant_manager_calldata, &retval);
  return PortableServer::ServantManager::_narrow (retval, env);
  
}

static const TAO_Param_Data PortableServer_POA_set_servant_manager_paramdata [] = 
{
  {CORBA::_tc_void, PARAM_RETURN, 0},
  {PortableServer::_tc_ServantManager, PARAM_IN, 0}
};

static const TAO_Call_Data PortableServer_POA_set_servant_manager_calldata = 
{"set_servant_manager", 1, 2, PortableServer_POA_set_servant_manager_paramdata, 0, 0};

void  PortableServer::POA::set_servant_manager (PortableServer::ServantManager_ptr imgr, CORBA::Environment &env)
{
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return;
  }
  this->Release (); // QueryInterface has bumped up our refcount
  CORBA::Object_ptr _tao_base_imgr = imgr; // cast it
  istub->do_call (env, &PortableServer_POA_set_servant_manager_calldata, 0, &_tao_base_imgr);
  return; // no value
  
}

PortableServer::Servant PortableServer::POA::get_servant (CORBA::Environment &env)
{
  env.exception (new CORBA::MARSHAL (CORBA::COMPLETED_NO));
  return 0;

}

void  PortableServer::POA::set_servant (PortableServer::Servant p_servant, CORBA::Environment &env)
{
  env.exception (new CORBA::MARSHAL (CORBA::COMPLETED_NO));
  return;

}

PortableServer::ObjectId * PortableServer::POA::activate_object (PortableServer::Servant p_servant, CORBA::Environment &env)
{
  env.exception (new CORBA::MARSHAL (CORBA::COMPLETED_NO));
  return 0;

}

void  PortableServer::POA::activate_object_with_id (const PortableServer::ObjectId &id, PortableServer::Servant p_servant, CORBA::Environment &env)
{
  env.exception (new CORBA::MARSHAL (CORBA::COMPLETED_NO));
  return;

}

static const TAO_Param_Data PortableServer_POA_deactivate_object_paramdata [] = 
{
  {CORBA::_tc_void, PARAM_RETURN, 0},
  {PortableServer::_tc_ObjectId, PARAM_IN, 0}
};

static const TAO_Call_Data PortableServer_POA_deactivate_object_calldata = 
{"deactivate_object", 1, 2, PortableServer_POA_deactivate_object_paramdata, 0, 0};

void  PortableServer::POA::deactivate_object (const PortableServer::ObjectId &oid, CORBA::Environment &env)
{
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return;
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &PortableServer_POA_deactivate_object_calldata, 0, &oid);
  return; // no value
  
}

static const TAO_Param_Data PortableServer_POA_create_reference_paramdata [] = 
{
  {CORBA::_tc_Object, PARAM_RETURN, 0},
  {PortableServer::_tc_RepositoryId, PARAM_IN, 0}
};

static const TAO_Call_Data PortableServer_POA_create_reference_calldata = 
{"create_reference", 1, 2, PortableServer_POA_create_reference_paramdata, 0, 0};

CORBA::Object_ptr  PortableServer::POA::create_reference (const char *intf, CORBA::Environment &env)
{
  CORBA::Object_ptr retval;
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return 0;
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &PortableServer_POA_create_reference_calldata, &retval, &intf);
  return retval;
  
}

static const TAO_Param_Data PortableServer_POA_create_reference_with_id_paramdata [] = 
{
  {CORBA::_tc_Object, PARAM_RETURN, 0},
  {PortableServer::_tc_ObjectId, PARAM_IN, 0},
  {PortableServer::_tc_RepositoryId, PARAM_IN, 0}
};

static const TAO_Call_Data PortableServer_POA_create_reference_with_id_calldata = 
{"create_reference_with_id", 1, 3, PortableServer_POA_create_reference_with_id_paramdata, 0, 0};

CORBA::Object_ptr  PortableServer::POA::create_reference_with_id (const PortableServer::ObjectId &oid, const char *intf, CORBA::Environment &env)
{
  CORBA::Object_ptr retval;
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return 0;
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &PortableServer_POA_create_reference_with_id_calldata, &retval, &oid, &intf);
  return retval;
  
}

PortableServer::ObjectId * PortableServer::POA::servant_to_id (PortableServer::Servant p_servant, CORBA::Environment &env)
{
  env.exception (new CORBA::MARSHAL (CORBA::COMPLETED_NO));
  return 0;

}

CORBA::Object_ptr  PortableServer::POA::servant_to_reference (PortableServer::Servant p_servant, CORBA::Environment &env)
{
  env.exception (new CORBA::MARSHAL (CORBA::COMPLETED_NO));
  return 0;

}

PortableServer::Servant PortableServer::POA::reference_to_servant (CORBA::Object_ptr reference, CORBA::Environment &env)
{
  env.exception (new CORBA::MARSHAL (CORBA::COMPLETED_NO));
  return 0;

}

static const TAO_Param_Data PortableServer_POA_reference_to_id_paramdata [] = 
{
  {PortableServer::_tc_ObjectId, PARAM_RETURN, sizeof (PortableServer::ObjectId)},
  {CORBA::_tc_Object, PARAM_IN, 0}
};

static const TAO_Call_Data PortableServer_POA_reference_to_id_calldata = 
{"reference_to_id", 1, 2, PortableServer_POA_reference_to_id_paramdata, 0, 0};

PortableServer::ObjectId * PortableServer::POA::reference_to_id (CORBA::Object_ptr reference, CORBA::Environment &env)
{
  PortableServer::ObjectId *retval = 0;
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return 0;
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &PortableServer_POA_reference_to_id_calldata, &retval, &reference);
  return retval;
  
}

PortableServer::Servant PortableServer::POA::id_to_servant (const PortableServer::ObjectId &oid, CORBA::Environment &env)
{
  env.exception (new CORBA::MARSHAL (CORBA::COMPLETED_NO));
  return 0;

}

static const TAO_Param_Data PortableServer_POA_id_to_reference_paramdata [] = 
{
  {CORBA::_tc_Object, PARAM_RETURN, 0},
  {PortableServer::_tc_ObjectId, PARAM_IN, 0}
};

static const TAO_Call_Data PortableServer_POA_id_to_reference_calldata = 
{"id_to_reference", 1, 2, PortableServer_POA_id_to_reference_paramdata, 0, 0};

CORBA::Object_ptr  PortableServer::POA::id_to_reference (const PortableServer::ObjectId &oid, CORBA::Environment &env)
{
  CORBA::Object_ptr retval;
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return 0;
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &PortableServer_POA_id_to_reference_calldata, &retval, &oid);
  return retval;
  
}

CORBA::Boolean PortableServer::POA::_is_a (const CORBA::Char *value, CORBA::Environment &_tao_environment)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/POA:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
	return 1; // success using local knowledge
  else
  	return this->CORBA_Object::_is_a (value, _tao_environment); // remote call
}

static const CORBA::Long _oc_PortableServer_POA[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  27, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f50, 0x4f413a31, 0x2e300000,  // repository ID = IDL:PortableServer/POA:1.0
  4, 0x504f4100,  // name = POA,
};
static CORBA::TypeCode _tc__tc_PortableServer_POA (CORBA::tk_objref, sizeof (_oc_PortableServer_POA), (unsigned char *) &_oc_PortableServer_POA, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::_tc_POA = &_tc__tc_PortableServer_POA;

PortableServer::Current_ptr PortableServer::Current::_duplicate (PortableServer::Current_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->AddRef ();
  
  return obj;
} // end of _duplicate

PortableServer::Current_ptr PortableServer::Current::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return PortableServer::Current::_nil ();
  if (!obj->_is_a ("IDL:PortableServer/Current:1.0", env))
    return PortableServer::Current::_nil ();
  if (!obj->_is_collocated () || !obj->_servant())
  {
    STUB_Object *istub;
    PortableServer::Current_ptr new_obj; // to be returned 
    if (obj->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
      return PortableServer::Current::_nil ();
    
    new_obj = new PortableServer::Current (istub); // construct obj ref using the stub object
    return new_obj;
  } // end of if

  STUB_Object *stub = obj->_servant ()->_create_stub (env);
  if (env.exception () != 0)
    return PortableServer::Current::_nil ();
  void* servant = obj->_servant ()->_downcast ("IDL:PortableServer/Current:1.0");
  return new POA_PortableServer::_tao_collocated_Current(
      ACE_reinterpret_cast(POA_PortableServer::Current_ptr, servant),
      stub
    );
}

PortableServer::Current_ptr PortableServer::Current::_bind (const char *host, CORBA::UShort port, const char *key, CORBA::Environment &env)
{
  CORBA::Object_ptr objref = CORBA::Object::_nil ();
  IIOP_Object *data = new IIOP_Object (host, port, key);
  if (!data) return PortableServer::Current::_nil ();
  // get the object_ptr using Query Interface
  if (data->QueryInterface (IID_CORBA_Object, (void **)&objref) != TAO_NOERROR)
  {
  	env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
  	return PortableServer::Current::_nil ();
  }
  data->Release (); // QueryInterface had bumped up our count
  if (CORBA::is_nil (objref))
  	return PortableServer::Current::_nil ();
  else // narrow it
  	return PortableServer::Current::_narrow (objref, env);
}

// copy constructor
PortableServer::Current::NoContext::NoContext(const PortableServer::Current::NoContext &_tao_excp)
	:CORBA_UserException (CORBA::TypeCode::_duplicate (_tao_excp.type ()))
{
  }

// assignment operator
PortableServer::Current::NoContext&
PortableServer::Current::NoContext::operator= (const PortableServer::Current::NoContext &_tao_excp)
{
  this->type_ = CORBA::TypeCode::_duplicate (_tao_excp.type ());
  return *this;
}

// narrow
PortableServer::Current::NoContext_ptr 
PortableServer::Current::NoContext::_narrow(CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:PortableServer/Current/NoContext:1.0", exc->id ())) // same type
  	return ACE_dynamic_cast (PortableServer::Current::NoContext_ptr, exc);
  else
  	return 0;
}

static const CORBA::Long _oc_PortableServer_Current_NoContext[] =
{
  0, // byte order
  41, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f43, 0x75727265, 0x6e742f4e, 0x6f436f6e, 0x74657874, 0x3a312e30, 0x0,  // repository ID = IDL:PortableServer/Current/NoContext:1.0
  10, 0x4e6f436f, 0x6e746578, 0x74000000,  // name = NoContext
  0, // member count
};
static CORBA::TypeCode _tc__tc_PortableServer_Current_NoContext (CORBA::tk_struct, sizeof (_oc_PortableServer_Current_NoContext), (unsigned char *) &_oc_PortableServer_Current_NoContext, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::Current::_tc_NoContext = &_tc__tc_PortableServer_Current_NoContext;

static const TAO_Param_Data PortableServer_Current_get_POA_paramdata [] = 
{
  {PortableServer::_tc_POA, PARAM_RETURN, 0}
};

static const TAO_Call_Data PortableServer_Current_get_POA_calldata = 
{"get_POA", 1, 1, PortableServer_Current_get_POA_paramdata, 0, 0};

PortableServer::POA_ptr  PortableServer::Current::get_POA (CORBA::Environment &env)
{
  CORBA::Object_ptr retval = CORBA::Object::_nil ();
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return PortableServer::POA::_nil ();
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &PortableServer_Current_get_POA_calldata, &retval);
  return PortableServer::POA::_narrow (retval, env);
  
}

static const TAO_Param_Data PortableServer_Current_get_object_id_paramdata [] = 
{
  {PortableServer::_tc_ObjectId, PARAM_RETURN, sizeof (PortableServer::ObjectId)}
};

static const TAO_Call_Data PortableServer_Current_get_object_id_calldata = 
{"get_object_id", 1, 1, PortableServer_Current_get_object_id_paramdata, 0, 0};

PortableServer::ObjectId * PortableServer::Current::get_object_id (CORBA::Environment &env)
{
  PortableServer::ObjectId *retval = 0;
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != TAO_NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return 0;
  }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &PortableServer_Current_get_object_id_calldata, &retval);
  return retval;
  
}

CORBA::Boolean PortableServer::Current::_is_a (const CORBA::Char *value, CORBA::Environment &_tao_environment)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Current:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/CurrentBase:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
	return 1; // success using local knowledge
  else
  	return this->CORBA_Object::_is_a (value, _tao_environment); // remote call
}

static const CORBA::Long _oc_PortableServer_Current[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, 0x49444c3a, 0x506f7274, 0x61626c65, 0x53657276, 0x65722f43, 0x75727265, 0x6e743a31, 0x2e300000,  // repository ID = IDL:PortableServer/Current:1.0
  8, 0x43757272, 0x656e7400,  // name = Current,
};
static CORBA::TypeCode _tc__tc_PortableServer_Current (CORBA::tk_objref, sizeof (_oc_PortableServer_Current), (unsigned char *) &_oc_PortableServer_Current, CORBA::B_FALSE);
CORBA::TypeCode_ptr PortableServer::_tc_Current = &_tc__tc_PortableServer_Current;

