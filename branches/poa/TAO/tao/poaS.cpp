// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO ORB and the TAO IDL Compiler have been developed by Washington 
// University Computer Science's Distributed Object Computing Group.
//
// Information on TAO is available at
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

#include "tao/corba.h"
#include "poaS.h"

#if !defined (__ACE_INLINE__)
#include "poaS.i"
#endif // !defined INLINE

static const TAO_operation_db_entry PortableServer_CurrentBase_operations [] = {
  {"_is_a", &POA_PortableServer::CurrentBase::_is_a_skel}
};

TAO_Dynamic_Hash_OpTable tao_PortableServer_CurrentBase_optable (PortableServer_CurrentBase_operations, 1, 2);
// skeleton constructor
POA_PortableServer::CurrentBase::CurrentBase (void)
{
  this->optable_ = &tao_PortableServer_CurrentBase_optable;
}

void POA_PortableServer::CurrentBase::_is_a_skel (
    CORBA::ServerRequest &req, 
    void * _tao_object_reference,
    void * /*context*/,
    CORBA::Environment &_tao_environment
  )
{
  CORBA::NVList_ptr nvlist;
  CORBA::NamedValue_ptr nv;
  CORBA::Any temp_value (CORBA::_tc_string);
  CORBA::Any *any;
  CORBA::Boolean *retval = new CORBA::Boolean;
  CORBA::String value;
  
  req.orb()->create_list (0, nvlist);
  nv = nvlist->add_value (0, temp_value, CORBA::ARG_IN, _tao_environment);
  req.params (nvlist, _tao_environment); // parse the args
  if (_tao_environment.exception () != 0) return;
  value = *(CORBA::String *)nv->value ()->value ();
  POA_PortableServer::CurrentBase_ptr 	 impl = (POA_PortableServer::CurrentBase_ptr) _tao_object_reference;
  *retval = impl->_is_a (value, _tao_environment);
  if (_tao_environment.exception () != 0) return;
  any = new CORBA::Any (CORBA::_tc_boolean, retval, CORBA::B_TRUE);
  req.result (any, _tao_environment);
}

CORBA::Boolean POA_PortableServer::CurrentBase::_is_a (
    const char* value,
    CORBA::Environment &_tao_environment
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/CurrentBase:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
      return CORBA::B_TRUE;
    else
      return CORBA::B_FALSE;
}

void* POA_PortableServer::CurrentBase::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/CurrentBase:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::CurrentBase_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::CurrentBase::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  CORBA::String opname = req.op_name (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
  }
else
  	skel (req, this, context, env);
}

const char* POA_PortableServer::CurrentBase::_interface_repository_id (void) const
{
  return "IDL:PortableServer/CurrentBase:1.0";
}

POA_PortableServer::_tao_collocated_CurrentBase::_tao_collocated_CurrentBase (
    POA_PortableServer::CurrentBase_ptr  servant,
    STUB_Object *stub
  )
  : ACE_NESTED_CLASS (PortableServer, CurrentBase) (stub, servant, CORBA::B_TRUE),
    CORBA_Object (stub, servant, CORBA::B_TRUE),
    servant_ (servant)
{
}

POA_PortableServer::CurrentBase_ptr POA_PortableServer::_tao_collocated_CurrentBase::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_CurrentBase::_is_a (
    const char* logical_type_id,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      _tao_environment
    );
}


PortableServer::CurrentBase*
POA_PortableServer::CurrentBase::_this (CORBA_Environment &_env)
{
  STUB_Object *stub = this->_create_stub (_env);
  if (_env.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_CurrentBase (this, stub);
}

static const TAO_operation_db_entry PortableServer_Policy_operations [] = {
  {"copy", &POA_PortableServer::Policy::copy_skel},
  {"destroy", &POA_PortableServer::Policy::destroy_skel},
  {"_is_a", &POA_PortableServer::Policy::_is_a_skel}
};

TAO_Dynamic_Hash_OpTable tao_PortableServer_Policy_optable (PortableServer_Policy_operations, 3, 6);
// skeleton constructor
POA_PortableServer::Policy::Policy (void)
{
  this->optable_ = &tao_PortableServer_Policy_optable;
}

void POA_PortableServer::Policy::copy_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  CORBA::NVList_ptr 	 nvlist;
  POA_PortableServer::Policy_ptr 	 impl = (POA_PortableServer::Policy_ptr) _tao_object_reference;
  CORBA::Any *result;
  CORBA::Object_ptr *retval = new CORBA::Object_ptr;
  *retval = CORBA::Object::_nil ();
    // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (0, nvlist); // initialize a list
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  *retval = impl->copy(_tao_environment);
  result = new CORBA::Any (PortableServer::_tc_Policy, retval, 1); // ORB owns
  _tao_server_request.result (result, _tao_environment);
  
}

void POA_PortableServer::Policy::destroy_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  CORBA::NVList_ptr 	 nvlist;
  POA_PortableServer::Policy_ptr 	 impl = (POA_PortableServer::Policy_ptr) _tao_object_reference;
    // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (0, nvlist); // initialize a list
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  impl->destroy(_tao_environment);
  
}

void POA_PortableServer::Policy::_is_a_skel (
    CORBA::ServerRequest &req, 
    void * _tao_object_reference,
    void * /*context*/,
    CORBA::Environment &_tao_environment
  )
{
  CORBA::NVList_ptr nvlist;
  CORBA::NamedValue_ptr nv;
  CORBA::Any temp_value (CORBA::_tc_string);
  CORBA::Any *any;
  CORBA::Boolean *retval = new CORBA::Boolean;
  CORBA::String value;
  
  req.orb()->create_list (0, nvlist);
  nv = nvlist->add_value (0, temp_value, CORBA::ARG_IN, _tao_environment);
  req.params (nvlist, _tao_environment); // parse the args
  if (_tao_environment.exception () != 0) return;
  value = *(CORBA::String *)nv->value ()->value ();
  POA_PortableServer::Policy_ptr 	 impl = (POA_PortableServer::Policy_ptr) _tao_object_reference;
  *retval = impl->_is_a (value, _tao_environment);
  if (_tao_environment.exception () != 0) return;
  any = new CORBA::Any (CORBA::_tc_boolean, retval, CORBA::B_TRUE);
  req.result (any, _tao_environment);
}

CORBA::Boolean POA_PortableServer::Policy::_is_a (
    const char* value,
    CORBA::Environment &_tao_environment
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
      return CORBA::B_TRUE;
    else
      return CORBA::B_FALSE;
}

void* POA_PortableServer::Policy::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/Policy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::Policy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  CORBA::String opname = req.op_name (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
  }
else
  	skel (req, this, context, env);
}

const char* POA_PortableServer::Policy::_interface_repository_id (void) const
{
  return "IDL:PortableServer/Policy:1.0";
}

POA_PortableServer::_tao_collocated_Policy::_tao_collocated_Policy (
    POA_PortableServer::Policy_ptr  servant,
    STUB_Object *stub
  )
  : ACE_NESTED_CLASS (PortableServer, Policy) (stub, servant, CORBA::B_TRUE),
    CORBA_Object (stub, servant, CORBA::B_TRUE),
    servant_ (servant)
{
}

POA_PortableServer::Policy_ptr POA_PortableServer::_tao_collocated_Policy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_Policy::_is_a (
    const char* logical_type_id,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      _tao_environment
    );
}

PortableServer::Policy_ptr POA_PortableServer::_tao_collocated_Policy::copy (
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->copy (
       _tao_environment
    );
}

void POA_PortableServer::_tao_collocated_Policy::destroy (
    CORBA::Environment &_tao_environment
  )
{
  this->servant_->destroy (
       _tao_environment
    );
}


PortableServer::Policy*
POA_PortableServer::Policy::_this (CORBA_Environment &_env)
{
  STUB_Object *stub = this->_create_stub (_env);
  if (_env.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_Policy (this, stub);
}

static const TAO_operation_db_entry PortableServer_ThreadPolicy_operations [] = {
  {"_get_value", &POA_PortableServer::ThreadPolicy::_get_value_skel},
  {"copy", &POA_PortableServer::ThreadPolicy::copy_skel},
  {"destroy", &POA_PortableServer::ThreadPolicy::destroy_skel},
  {"_is_a", &POA_PortableServer::ThreadPolicy::_is_a_skel}
};

TAO_Dynamic_Hash_OpTable tao_PortableServer_ThreadPolicy_optable (PortableServer_ThreadPolicy_operations, 4, 8);
// skeleton constructor
POA_PortableServer::ThreadPolicy::ThreadPolicy (void)
{
  this->optable_ = &tao_PortableServer_ThreadPolicy_optable;
}

void POA_PortableServer::ThreadPolicy::_get_value_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void * /*context*/, CORBA::Environment &_tao_environment)
{
  POA_PortableServer::ThreadPolicy_ptr impl = (POA_PortableServer::ThreadPolicy_ptr) _tao_object_reference;
  CORBA::Any *result;
  PortableServer::ThreadPolicyValue *retval = new PortableServer::ThreadPolicyValue;
    // this method has no incoming parameters. Nothing to parse
  *retval = impl->value(_tao_environment);
  result = new CORBA::Any (PortableServer::_tc_ThreadPolicyValue, retval, 1); // ORB owns
  _tao_server_request.result (result, _tao_environment);
}

void POA_PortableServer::ThreadPolicy::_is_a_skel (
    CORBA::ServerRequest &req, 
    void * _tao_object_reference,
    void * /*context*/,
    CORBA::Environment &_tao_environment
  )
{
  CORBA::NVList_ptr nvlist;
  CORBA::NamedValue_ptr nv;
  CORBA::Any temp_value (CORBA::_tc_string);
  CORBA::Any *any;
  CORBA::Boolean *retval = new CORBA::Boolean;
  CORBA::String value;
  
  req.orb()->create_list (0, nvlist);
  nv = nvlist->add_value (0, temp_value, CORBA::ARG_IN, _tao_environment);
  req.params (nvlist, _tao_environment); // parse the args
  if (_tao_environment.exception () != 0) return;
  value = *(CORBA::String *)nv->value ()->value ();
  POA_PortableServer::ThreadPolicy_ptr 	 impl = (POA_PortableServer::ThreadPolicy_ptr) _tao_object_reference;
  *retval = impl->_is_a (value, _tao_environment);
  if (_tao_environment.exception () != 0) return;
  any = new CORBA::Any (CORBA::_tc_boolean, retval, CORBA::B_TRUE);
  req.result (any, _tao_environment);
}

CORBA::Boolean POA_PortableServer::ThreadPolicy::_is_a (
    const char* value,
    CORBA::Environment &_tao_environment
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ThreadPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
      return CORBA::B_TRUE;
    else
      return CORBA::B_FALSE;
}

void* POA_PortableServer::ThreadPolicy::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/ThreadPolicy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ThreadPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/Policy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::ThreadPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  CORBA::String opname = req.op_name (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
  }
else
  	skel (req, this, context, env);
}

const char* POA_PortableServer::ThreadPolicy::_interface_repository_id (void) const
{
  return "IDL:PortableServer/ThreadPolicy:1.0";
}

POA_PortableServer::_tao_collocated_ThreadPolicy::_tao_collocated_ThreadPolicy (
    POA_PortableServer::ThreadPolicy_ptr  servant,
    STUB_Object *stub
  )
  : ACE_NESTED_CLASS (PortableServer, ThreadPolicy) (stub, servant, CORBA::B_TRUE),
    _tao_collocated_Policy (servant, stub),
    CORBA_Object (stub, servant, CORBA::B_TRUE),
    servant_ (servant)
{
}

POA_PortableServer::ThreadPolicy_ptr POA_PortableServer::_tao_collocated_ThreadPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_ThreadPolicy::_is_a (
    const char* logical_type_id,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      _tao_environment
    );
}

PortableServer::ThreadPolicyValue
POA_PortableServer::_tao_collocated_ThreadPolicy::value (
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->value(_tao_environment);
}

PortableServer::ThreadPolicy*
POA_PortableServer::ThreadPolicy::_this (CORBA_Environment &_env)
{
  STUB_Object *stub = this->_create_stub (_env);
  if (_env.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_ThreadPolicy (this, stub);
}

static const TAO_operation_db_entry PortableServer_LifespanPolicy_operations [] = {
  {"_get_value", &POA_PortableServer::LifespanPolicy::_get_value_skel},
  {"copy", &POA_PortableServer::LifespanPolicy::copy_skel},
  {"destroy", &POA_PortableServer::LifespanPolicy::destroy_skel},
  {"_is_a", &POA_PortableServer::LifespanPolicy::_is_a_skel}
};

TAO_Dynamic_Hash_OpTable tao_PortableServer_LifespanPolicy_optable (PortableServer_LifespanPolicy_operations, 4, 8);
// skeleton constructor
POA_PortableServer::LifespanPolicy::LifespanPolicy (void)
{
  this->optable_ = &tao_PortableServer_LifespanPolicy_optable;
}

void POA_PortableServer::LifespanPolicy::_get_value_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void * /*context*/, CORBA::Environment &_tao_environment)
{
  POA_PortableServer::LifespanPolicy_ptr impl = (POA_PortableServer::LifespanPolicy_ptr) _tao_object_reference;
  CORBA::Any *result;
  PortableServer::LifespanPolicyValue *retval = new PortableServer::LifespanPolicyValue;
    // this method has no incoming parameters. Nothing to parse
  *retval = impl->value(_tao_environment);
  result = new CORBA::Any (PortableServer::_tc_LifespanPolicyValue, retval, 1); // ORB owns
  _tao_server_request.result (result, _tao_environment);
}

void POA_PortableServer::LifespanPolicy::_is_a_skel (
    CORBA::ServerRequest &req, 
    void * _tao_object_reference,
    void * /*context*/,
    CORBA::Environment &_tao_environment
  )
{
  CORBA::NVList_ptr nvlist;
  CORBA::NamedValue_ptr nv;
  CORBA::Any temp_value (CORBA::_tc_string);
  CORBA::Any *any;
  CORBA::Boolean *retval = new CORBA::Boolean;
  CORBA::String value;
  
  req.orb()->create_list (0, nvlist);
  nv = nvlist->add_value (0, temp_value, CORBA::ARG_IN, _tao_environment);
  req.params (nvlist, _tao_environment); // parse the args
  if (_tao_environment.exception () != 0) return;
  value = *(CORBA::String *)nv->value ()->value ();
  POA_PortableServer::LifespanPolicy_ptr 	 impl = (POA_PortableServer::LifespanPolicy_ptr) _tao_object_reference;
  *retval = impl->_is_a (value, _tao_environment);
  if (_tao_environment.exception () != 0) return;
  any = new CORBA::Any (CORBA::_tc_boolean, retval, CORBA::B_TRUE);
  req.result (any, _tao_environment);
}

CORBA::Boolean POA_PortableServer::LifespanPolicy::_is_a (
    const char* value,
    CORBA::Environment &_tao_environment
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/LifespanPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
      return CORBA::B_TRUE;
    else
      return CORBA::B_FALSE;
}

void* POA_PortableServer::LifespanPolicy::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/LifespanPolicy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::LifespanPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/Policy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::LifespanPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  CORBA::String opname = req.op_name (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
  }
else
  	skel (req, this, context, env);
}

const char* POA_PortableServer::LifespanPolicy::_interface_repository_id (void) const
{
  return "IDL:PortableServer/LifespanPolicy:1.0";
}

POA_PortableServer::_tao_collocated_LifespanPolicy::_tao_collocated_LifespanPolicy (
    POA_PortableServer::LifespanPolicy_ptr  servant,
    STUB_Object *stub
  )
  : ACE_NESTED_CLASS (PortableServer, LifespanPolicy) (stub, servant, CORBA::B_TRUE),
    _tao_collocated_Policy (servant, stub),
    CORBA_Object (stub, servant, CORBA::B_TRUE),
    servant_ (servant)
{
}

POA_PortableServer::LifespanPolicy_ptr POA_PortableServer::_tao_collocated_LifespanPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_LifespanPolicy::_is_a (
    const char* logical_type_id,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      _tao_environment
    );
}

PortableServer::LifespanPolicyValue
POA_PortableServer::_tao_collocated_LifespanPolicy::value (
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->value(_tao_environment);
}

PortableServer::LifespanPolicy*
POA_PortableServer::LifespanPolicy::_this (CORBA_Environment &_env)
{
  STUB_Object *stub = this->_create_stub (_env);
  if (_env.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_LifespanPolicy (this, stub);
}

static const TAO_operation_db_entry PortableServer_IdUniquenessPolicy_operations [] = {
  {"_get_value", &POA_PortableServer::IdUniquenessPolicy::_get_value_skel},
  {"copy", &POA_PortableServer::IdUniquenessPolicy::copy_skel},
  {"destroy", &POA_PortableServer::IdUniquenessPolicy::destroy_skel},
  {"_is_a", &POA_PortableServer::IdUniquenessPolicy::_is_a_skel}
};

TAO_Dynamic_Hash_OpTable tao_PortableServer_IdUniquenessPolicy_optable (PortableServer_IdUniquenessPolicy_operations, 4, 8);
// skeleton constructor
POA_PortableServer::IdUniquenessPolicy::IdUniquenessPolicy (void)
{
  this->optable_ = &tao_PortableServer_IdUniquenessPolicy_optable;
}

void POA_PortableServer::IdUniquenessPolicy::_get_value_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void * /*context*/, CORBA::Environment &_tao_environment)
{
  POA_PortableServer::IdUniquenessPolicy_ptr impl = (POA_PortableServer::IdUniquenessPolicy_ptr) _tao_object_reference;
  CORBA::Any *result;
  PortableServer::IdUniquenessPolicyValue *retval = new PortableServer::IdUniquenessPolicyValue;
    // this method has no incoming parameters. Nothing to parse
  *retval = impl->value(_tao_environment);
  result = new CORBA::Any (PortableServer::_tc_IdUniquenessPolicyValue, retval, 1); // ORB owns
  _tao_server_request.result (result, _tao_environment);
}

void POA_PortableServer::IdUniquenessPolicy::_is_a_skel (
    CORBA::ServerRequest &req, 
    void * _tao_object_reference,
    void * /*context*/,
    CORBA::Environment &_tao_environment
  )
{
  CORBA::NVList_ptr nvlist;
  CORBA::NamedValue_ptr nv;
  CORBA::Any temp_value (CORBA::_tc_string);
  CORBA::Any *any;
  CORBA::Boolean *retval = new CORBA::Boolean;
  CORBA::String value;
  
  req.orb()->create_list (0, nvlist);
  nv = nvlist->add_value (0, temp_value, CORBA::ARG_IN, _tao_environment);
  req.params (nvlist, _tao_environment); // parse the args
  if (_tao_environment.exception () != 0) return;
  value = *(CORBA::String *)nv->value ()->value ();
  POA_PortableServer::IdUniquenessPolicy_ptr 	 impl = (POA_PortableServer::IdUniquenessPolicy_ptr) _tao_object_reference;
  *retval = impl->_is_a (value, _tao_environment);
  if (_tao_environment.exception () != 0) return;
  any = new CORBA::Any (CORBA::_tc_boolean, retval, CORBA::B_TRUE);
  req.result (any, _tao_environment);
}

CORBA::Boolean POA_PortableServer::IdUniquenessPolicy::_is_a (
    const char* value,
    CORBA::Environment &_tao_environment
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/IdUniquenessPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
      return CORBA::B_TRUE;
    else
      return CORBA::B_FALSE;
}

void* POA_PortableServer::IdUniquenessPolicy::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/IdUniquenessPolicy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::IdUniquenessPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/Policy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::IdUniquenessPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  CORBA::String opname = req.op_name (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
  }
else
  	skel (req, this, context, env);
}

const char* POA_PortableServer::IdUniquenessPolicy::_interface_repository_id (void) const
{
  return "IDL:PortableServer/IdUniquenessPolicy:1.0";
}

POA_PortableServer::_tao_collocated_IdUniquenessPolicy::_tao_collocated_IdUniquenessPolicy (
    POA_PortableServer::IdUniquenessPolicy_ptr  servant,
    STUB_Object *stub
  )
  : ACE_NESTED_CLASS (PortableServer, IdUniquenessPolicy) (stub, servant, CORBA::B_TRUE),
    _tao_collocated_Policy (servant, stub),
    CORBA_Object (stub, servant, CORBA::B_TRUE),
    servant_ (servant)
{
}

POA_PortableServer::IdUniquenessPolicy_ptr POA_PortableServer::_tao_collocated_IdUniquenessPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_IdUniquenessPolicy::_is_a (
    const char* logical_type_id,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      _tao_environment
    );
}

PortableServer::IdUniquenessPolicyValue
POA_PortableServer::_tao_collocated_IdUniquenessPolicy::value (
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->value(_tao_environment);
}

PortableServer::IdUniquenessPolicy*
POA_PortableServer::IdUniquenessPolicy::_this (CORBA_Environment &_env)
{
  STUB_Object *stub = this->_create_stub (_env);
  if (_env.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_IdUniquenessPolicy (this, stub);
}

static const TAO_operation_db_entry PortableServer_IdAssignmentPolicy_operations [] = {
  {"_get_value", &POA_PortableServer::IdAssignmentPolicy::_get_value_skel},
  {"copy", &POA_PortableServer::IdAssignmentPolicy::copy_skel},
  {"destroy", &POA_PortableServer::IdAssignmentPolicy::destroy_skel},
  {"_is_a", &POA_PortableServer::IdAssignmentPolicy::_is_a_skel}
};

TAO_Dynamic_Hash_OpTable tao_PortableServer_IdAssignmentPolicy_optable (PortableServer_IdAssignmentPolicy_operations, 4, 8);
// skeleton constructor
POA_PortableServer::IdAssignmentPolicy::IdAssignmentPolicy (void)
{
  this->optable_ = &tao_PortableServer_IdAssignmentPolicy_optable;
}

void POA_PortableServer::IdAssignmentPolicy::_get_value_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void * /*context*/, CORBA::Environment &_tao_environment)
{
  POA_PortableServer::IdAssignmentPolicy_ptr impl = (POA_PortableServer::IdAssignmentPolicy_ptr) _tao_object_reference;
  CORBA::Any *result;
  PortableServer::IdAssignmentPolicyValue *retval = new PortableServer::IdAssignmentPolicyValue;
    // this method has no incoming parameters. Nothing to parse
  *retval = impl->value(_tao_environment);
  result = new CORBA::Any (PortableServer::_tc_IdAssignmentPolicyValue, retval, 1); // ORB owns
  _tao_server_request.result (result, _tao_environment);
}

void POA_PortableServer::IdAssignmentPolicy::_is_a_skel (
    CORBA::ServerRequest &req, 
    void * _tao_object_reference,
    void * /*context*/,
    CORBA::Environment &_tao_environment
  )
{
  CORBA::NVList_ptr nvlist;
  CORBA::NamedValue_ptr nv;
  CORBA::Any temp_value (CORBA::_tc_string);
  CORBA::Any *any;
  CORBA::Boolean *retval = new CORBA::Boolean;
  CORBA::String value;
  
  req.orb()->create_list (0, nvlist);
  nv = nvlist->add_value (0, temp_value, CORBA::ARG_IN, _tao_environment);
  req.params (nvlist, _tao_environment); // parse the args
  if (_tao_environment.exception () != 0) return;
  value = *(CORBA::String *)nv->value ()->value ();
  POA_PortableServer::IdAssignmentPolicy_ptr 	 impl = (POA_PortableServer::IdAssignmentPolicy_ptr) _tao_object_reference;
  *retval = impl->_is_a (value, _tao_environment);
  if (_tao_environment.exception () != 0) return;
  any = new CORBA::Any (CORBA::_tc_boolean, retval, CORBA::B_TRUE);
  req.result (any, _tao_environment);
}

CORBA::Boolean POA_PortableServer::IdAssignmentPolicy::_is_a (
    const char* value,
    CORBA::Environment &_tao_environment
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/IdAssignmentPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
      return CORBA::B_TRUE;
    else
      return CORBA::B_FALSE;
}

void* POA_PortableServer::IdAssignmentPolicy::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/IdAssignmentPolicy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::IdAssignmentPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/Policy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::IdAssignmentPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  CORBA::String opname = req.op_name (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
  }
else
  	skel (req, this, context, env);
}

const char* POA_PortableServer::IdAssignmentPolicy::_interface_repository_id (void) const
{
  return "IDL:PortableServer/IdAssignmentPolicy:1.0";
}

POA_PortableServer::_tao_collocated_IdAssignmentPolicy::_tao_collocated_IdAssignmentPolicy (
    POA_PortableServer::IdAssignmentPolicy_ptr  servant,
    STUB_Object *stub
  )
  : ACE_NESTED_CLASS (PortableServer, IdAssignmentPolicy) (stub, servant, CORBA::B_TRUE),
    _tao_collocated_Policy (servant, stub),
    CORBA_Object (stub, servant, CORBA::B_TRUE),
    servant_ (servant)
{
}

POA_PortableServer::IdAssignmentPolicy_ptr POA_PortableServer::_tao_collocated_IdAssignmentPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_IdAssignmentPolicy::_is_a (
    const char* logical_type_id,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      _tao_environment
    );
}

PortableServer::IdAssignmentPolicyValue
POA_PortableServer::_tao_collocated_IdAssignmentPolicy::value (
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->value(_tao_environment);
}

PortableServer::IdAssignmentPolicy*
POA_PortableServer::IdAssignmentPolicy::_this (CORBA_Environment &_env)
{
  STUB_Object *stub = this->_create_stub (_env);
  if (_env.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_IdAssignmentPolicy (this, stub);
}

static const TAO_operation_db_entry PortableServer_ImplicitActivationPolicy_operations [] = {
  {"_get_value", &POA_PortableServer::ImplicitActivationPolicy::_get_value_skel},
  {"copy", &POA_PortableServer::ImplicitActivationPolicy::copy_skel},
  {"destroy", &POA_PortableServer::ImplicitActivationPolicy::destroy_skel},
  {"_is_a", &POA_PortableServer::ImplicitActivationPolicy::_is_a_skel}
};

TAO_Dynamic_Hash_OpTable tao_PortableServer_ImplicitActivationPolicy_optable (PortableServer_ImplicitActivationPolicy_operations, 4, 8);
// skeleton constructor
POA_PortableServer::ImplicitActivationPolicy::ImplicitActivationPolicy (void)
{
  this->optable_ = &tao_PortableServer_ImplicitActivationPolicy_optable;
}

void POA_PortableServer::ImplicitActivationPolicy::_get_value_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void * /*context*/, CORBA::Environment &_tao_environment)
{
  POA_PortableServer::ImplicitActivationPolicy_ptr impl = (POA_PortableServer::ImplicitActivationPolicy_ptr) _tao_object_reference;
  CORBA::Any *result;
  PortableServer::ImplicitActivationPolicyValue *retval = new PortableServer::ImplicitActivationPolicyValue;
    // this method has no incoming parameters. Nothing to parse
  *retval = impl->value(_tao_environment);
  result = new CORBA::Any (PortableServer::_tc_ImplicitActivationPolicyValue, retval, 1); // ORB owns
  _tao_server_request.result (result, _tao_environment);
}

void POA_PortableServer::ImplicitActivationPolicy::_is_a_skel (
    CORBA::ServerRequest &req, 
    void * _tao_object_reference,
    void * /*context*/,
    CORBA::Environment &_tao_environment
  )
{
  CORBA::NVList_ptr nvlist;
  CORBA::NamedValue_ptr nv;
  CORBA::Any temp_value (CORBA::_tc_string);
  CORBA::Any *any;
  CORBA::Boolean *retval = new CORBA::Boolean;
  CORBA::String value;
  
  req.orb()->create_list (0, nvlist);
  nv = nvlist->add_value (0, temp_value, CORBA::ARG_IN, _tao_environment);
  req.params (nvlist, _tao_environment); // parse the args
  if (_tao_environment.exception () != 0) return;
  value = *(CORBA::String *)nv->value ()->value ();
  POA_PortableServer::ImplicitActivationPolicy_ptr 	 impl = (POA_PortableServer::ImplicitActivationPolicy_ptr) _tao_object_reference;
  *retval = impl->_is_a (value, _tao_environment);
  if (_tao_environment.exception () != 0) return;
  any = new CORBA::Any (CORBA::_tc_boolean, retval, CORBA::B_TRUE);
  req.result (any, _tao_environment);
}

CORBA::Boolean POA_PortableServer::ImplicitActivationPolicy::_is_a (
    const char* value,
    CORBA::Environment &_tao_environment
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ImplicitActivationPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
      return CORBA::B_TRUE;
    else
      return CORBA::B_FALSE;
}

void* POA_PortableServer::ImplicitActivationPolicy::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/ImplicitActivationPolicy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ImplicitActivationPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/Policy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::ImplicitActivationPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  CORBA::String opname = req.op_name (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
  }
else
  	skel (req, this, context, env);
}

const char* POA_PortableServer::ImplicitActivationPolicy::_interface_repository_id (void) const
{
  return "IDL:PortableServer/ImplicitActivationPolicy:1.0";
}

POA_PortableServer::_tao_collocated_ImplicitActivationPolicy::_tao_collocated_ImplicitActivationPolicy (
    POA_PortableServer::ImplicitActivationPolicy_ptr  servant,
    STUB_Object *stub
  )
  : ACE_NESTED_CLASS (PortableServer, ImplicitActivationPolicy) (stub, servant, CORBA::B_TRUE),
    _tao_collocated_Policy (servant, stub),
    CORBA_Object (stub, servant, CORBA::B_TRUE),
    servant_ (servant)
{
}

POA_PortableServer::ImplicitActivationPolicy_ptr POA_PortableServer::_tao_collocated_ImplicitActivationPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_ImplicitActivationPolicy::_is_a (
    const char* logical_type_id,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      _tao_environment
    );
}

PortableServer::ImplicitActivationPolicyValue
POA_PortableServer::_tao_collocated_ImplicitActivationPolicy::value (
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->value(_tao_environment);
}

PortableServer::ImplicitActivationPolicy*
POA_PortableServer::ImplicitActivationPolicy::_this (CORBA_Environment &_env)
{
  STUB_Object *stub = this->_create_stub (_env);
  if (_env.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_ImplicitActivationPolicy (this, stub);
}

static const TAO_operation_db_entry PortableServer_ServantRetentionPolicy_operations [] = {
  {"_get_value", &POA_PortableServer::ServantRetentionPolicy::_get_value_skel},
  {"copy", &POA_PortableServer::ServantRetentionPolicy::copy_skel},
  {"destroy", &POA_PortableServer::ServantRetentionPolicy::destroy_skel},
  {"_is_a", &POA_PortableServer::ServantRetentionPolicy::_is_a_skel}
};

TAO_Dynamic_Hash_OpTable tao_PortableServer_ServantRetentionPolicy_optable (PortableServer_ServantRetentionPolicy_operations, 4, 8);
// skeleton constructor
POA_PortableServer::ServantRetentionPolicy::ServantRetentionPolicy (void)
{
  this->optable_ = &tao_PortableServer_ServantRetentionPolicy_optable;
}

void POA_PortableServer::ServantRetentionPolicy::_get_value_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void * /*context*/, CORBA::Environment &_tao_environment)
{
  POA_PortableServer::ServantRetentionPolicy_ptr impl = (POA_PortableServer::ServantRetentionPolicy_ptr) _tao_object_reference;
  CORBA::Any *result;
  PortableServer::ServantRetentionPolicyValue *retval = new PortableServer::ServantRetentionPolicyValue;
    // this method has no incoming parameters. Nothing to parse
  *retval = impl->value(_tao_environment);
  result = new CORBA::Any (PortableServer::_tc_ServantRetentionPolicyValue, retval, 1); // ORB owns
  _tao_server_request.result (result, _tao_environment);
}

void POA_PortableServer::ServantRetentionPolicy::_is_a_skel (
    CORBA::ServerRequest &req, 
    void * _tao_object_reference,
    void * /*context*/,
    CORBA::Environment &_tao_environment
  )
{
  CORBA::NVList_ptr nvlist;
  CORBA::NamedValue_ptr nv;
  CORBA::Any temp_value (CORBA::_tc_string);
  CORBA::Any *any;
  CORBA::Boolean *retval = new CORBA::Boolean;
  CORBA::String value;
  
  req.orb()->create_list (0, nvlist);
  nv = nvlist->add_value (0, temp_value, CORBA::ARG_IN, _tao_environment);
  req.params (nvlist, _tao_environment); // parse the args
  if (_tao_environment.exception () != 0) return;
  value = *(CORBA::String *)nv->value ()->value ();
  POA_PortableServer::ServantRetentionPolicy_ptr 	 impl = (POA_PortableServer::ServantRetentionPolicy_ptr) _tao_object_reference;
  *retval = impl->_is_a (value, _tao_environment);
  if (_tao_environment.exception () != 0) return;
  any = new CORBA::Any (CORBA::_tc_boolean, retval, CORBA::B_TRUE);
  req.result (any, _tao_environment);
}

CORBA::Boolean POA_PortableServer::ServantRetentionPolicy::_is_a (
    const char* value,
    CORBA::Environment &_tao_environment
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ServantRetentionPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
      return CORBA::B_TRUE;
    else
      return CORBA::B_FALSE;
}

void* POA_PortableServer::ServantRetentionPolicy::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/ServantRetentionPolicy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ServantRetentionPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/Policy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::ServantRetentionPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  CORBA::String opname = req.op_name (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
  }
else
  	skel (req, this, context, env);
}

const char* POA_PortableServer::ServantRetentionPolicy::_interface_repository_id (void) const
{
  return "IDL:PortableServer/ServantRetentionPolicy:1.0";
}

POA_PortableServer::_tao_collocated_ServantRetentionPolicy::_tao_collocated_ServantRetentionPolicy (
    POA_PortableServer::ServantRetentionPolicy_ptr  servant,
    STUB_Object *stub
  )
  : ACE_NESTED_CLASS (PortableServer, ServantRetentionPolicy) (stub, servant, CORBA::B_TRUE),
    _tao_collocated_Policy (servant, stub),
    CORBA_Object (stub, servant, CORBA::B_TRUE),
    servant_ (servant)
{
}

POA_PortableServer::ServantRetentionPolicy_ptr POA_PortableServer::_tao_collocated_ServantRetentionPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_ServantRetentionPolicy::_is_a (
    const char* logical_type_id,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      _tao_environment
    );
}

PortableServer::ServantRetentionPolicyValue
POA_PortableServer::_tao_collocated_ServantRetentionPolicy::value (
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->value(_tao_environment);
}

PortableServer::ServantRetentionPolicy*
POA_PortableServer::ServantRetentionPolicy::_this (CORBA_Environment &_env)
{
  STUB_Object *stub = this->_create_stub (_env);
  if (_env.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_ServantRetentionPolicy (this, stub);
}

static const TAO_operation_db_entry PortableServer_RequestProcessingPolicy_operations [] = {
  {"_get_value", &POA_PortableServer::RequestProcessingPolicy::_get_value_skel},
  {"copy", &POA_PortableServer::RequestProcessingPolicy::copy_skel},
  {"destroy", &POA_PortableServer::RequestProcessingPolicy::destroy_skel},
  {"_is_a", &POA_PortableServer::RequestProcessingPolicy::_is_a_skel}
};

TAO_Dynamic_Hash_OpTable tao_PortableServer_RequestProcessingPolicy_optable (PortableServer_RequestProcessingPolicy_operations, 4, 8);
// skeleton constructor
POA_PortableServer::RequestProcessingPolicy::RequestProcessingPolicy (void)
{
  this->optable_ = &tao_PortableServer_RequestProcessingPolicy_optable;
}

void POA_PortableServer::RequestProcessingPolicy::_get_value_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void * /*context*/, CORBA::Environment &_tao_environment)
{
  POA_PortableServer::RequestProcessingPolicy_ptr impl = (POA_PortableServer::RequestProcessingPolicy_ptr) _tao_object_reference;
  CORBA::Any *result;
  PortableServer::RequestProcessingPolicyValue *retval = new PortableServer::RequestProcessingPolicyValue;
    // this method has no incoming parameters. Nothing to parse
  *retval = impl->value(_tao_environment);
  result = new CORBA::Any (PortableServer::_tc_RequestProcessingPolicyValue, retval, 1); // ORB owns
  _tao_server_request.result (result, _tao_environment);
}

void POA_PortableServer::RequestProcessingPolicy::_is_a_skel (
    CORBA::ServerRequest &req, 
    void * _tao_object_reference,
    void * /*context*/,
    CORBA::Environment &_tao_environment
  )
{
  CORBA::NVList_ptr nvlist;
  CORBA::NamedValue_ptr nv;
  CORBA::Any temp_value (CORBA::_tc_string);
  CORBA::Any *any;
  CORBA::Boolean *retval = new CORBA::Boolean;
  CORBA::String value;
  
  req.orb()->create_list (0, nvlist);
  nv = nvlist->add_value (0, temp_value, CORBA::ARG_IN, _tao_environment);
  req.params (nvlist, _tao_environment); // parse the args
  if (_tao_environment.exception () != 0) return;
  value = *(CORBA::String *)nv->value ()->value ();
  POA_PortableServer::RequestProcessingPolicy_ptr 	 impl = (POA_PortableServer::RequestProcessingPolicy_ptr) _tao_object_reference;
  *retval = impl->_is_a (value, _tao_environment);
  if (_tao_environment.exception () != 0) return;
  any = new CORBA::Any (CORBA::_tc_boolean, retval, CORBA::B_TRUE);
  req.result (any, _tao_environment);
}

CORBA::Boolean POA_PortableServer::RequestProcessingPolicy::_is_a (
    const char* value,
    CORBA::Environment &_tao_environment
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/RequestProcessingPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
      return CORBA::B_TRUE;
    else
      return CORBA::B_FALSE;
}

void* POA_PortableServer::RequestProcessingPolicy::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/RequestProcessingPolicy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::RequestProcessingPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/Policy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::RequestProcessingPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  CORBA::String opname = req.op_name (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
  }
else
  	skel (req, this, context, env);
}

const char* POA_PortableServer::RequestProcessingPolicy::_interface_repository_id (void) const
{
  return "IDL:PortableServer/RequestProcessingPolicy:1.0";
}

POA_PortableServer::_tao_collocated_RequestProcessingPolicy::_tao_collocated_RequestProcessingPolicy (
    POA_PortableServer::RequestProcessingPolicy_ptr  servant,
    STUB_Object *stub
  )
  : ACE_NESTED_CLASS (PortableServer, RequestProcessingPolicy) (stub, servant, CORBA::B_TRUE),
    _tao_collocated_Policy (servant, stub),
    CORBA_Object (stub, servant, CORBA::B_TRUE),
    servant_ (servant)
{
}

POA_PortableServer::RequestProcessingPolicy_ptr POA_PortableServer::_tao_collocated_RequestProcessingPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_RequestProcessingPolicy::_is_a (
    const char* logical_type_id,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      _tao_environment
    );
}

PortableServer::RequestProcessingPolicyValue
POA_PortableServer::_tao_collocated_RequestProcessingPolicy::value (
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->value(_tao_environment);
}

PortableServer::RequestProcessingPolicy*
POA_PortableServer::RequestProcessingPolicy::_this (CORBA_Environment &_env)
{
  STUB_Object *stub = this->_create_stub (_env);
  if (_env.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_RequestProcessingPolicy (this, stub);
}

static const TAO_operation_db_entry PortableServer_POAManager_operations [] = {
  {"activate", &POA_PortableServer::POAManager::activate_skel},
  {"hold_requests", &POA_PortableServer::POAManager::hold_requests_skel},
  {"discard_requests", &POA_PortableServer::POAManager::discard_requests_skel},
  {"deactivate", &POA_PortableServer::POAManager::deactivate_skel},
  {"_is_a", &POA_PortableServer::POAManager::_is_a_skel}
};

TAO_Dynamic_Hash_OpTable tao_PortableServer_POAManager_optable (PortableServer_POAManager_operations, 5, 10);
// skeleton constructor
POA_PortableServer::POAManager::POAManager (void)
{
  this->optable_ = &tao_PortableServer_POAManager_optable;
}

void POA_PortableServer::POAManager::activate_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  CORBA::NVList_ptr 	 nvlist;
  POA_PortableServer::POAManager_ptr 	 impl = (POA_PortableServer::POAManager_ptr) _tao_object_reference;
    // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (0, nvlist); // initialize a list
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  impl->activate(_tao_environment);
  
}

void POA_PortableServer::POAManager::hold_requests_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  CORBA::NVList_ptr 	 nvlist;
  POA_PortableServer::POAManager_ptr 	 impl = (POA_PortableServer::POAManager_ptr) _tao_object_reference;
    // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (1, nvlist); // initialize a list
  // add each argument according to the in, out, inout semantics
  CORBA::Boolean wait_for_completion;
  (void) nvlist->add_item ("wait_for_completion", CORBA::ARG_IN, _tao_environment)->value ()->replace (CORBA::_tc_boolean, &wait_for_completion, 0, _tao_environment); // ORB does not own
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  impl->hold_requests(wait_for_completion, _tao_environment);
  
}

void POA_PortableServer::POAManager::discard_requests_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  CORBA::NVList_ptr 	 nvlist;
  POA_PortableServer::POAManager_ptr 	 impl = (POA_PortableServer::POAManager_ptr) _tao_object_reference;
    // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (1, nvlist); // initialize a list
  // add each argument according to the in, out, inout semantics
  CORBA::Boolean wait_for_completion;
  (void) nvlist->add_item ("wait_for_completion", CORBA::ARG_IN, _tao_environment)->value ()->replace (CORBA::_tc_boolean, &wait_for_completion, 0, _tao_environment); // ORB does not own
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  impl->discard_requests(wait_for_completion, _tao_environment);
  
}

void POA_PortableServer::POAManager::deactivate_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  CORBA::NVList_ptr 	 nvlist;
  POA_PortableServer::POAManager_ptr 	 impl = (POA_PortableServer::POAManager_ptr) _tao_object_reference;
    // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (2, nvlist); // initialize a list
  // add each argument according to the in, out, inout semantics
  CORBA::Boolean etherealize_objects;
  (void) nvlist->add_item ("etherealize_objects", CORBA::ARG_IN, _tao_environment)->value ()->replace (CORBA::_tc_boolean, &etherealize_objects, 0, _tao_environment); // ORB does not own
  CORBA::Boolean wait_for_completion;
  (void) nvlist->add_item ("wait_for_completion", CORBA::ARG_IN, _tao_environment)->value ()->replace (CORBA::_tc_boolean, &wait_for_completion, 0, _tao_environment); // ORB does not own
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  impl->deactivate(etherealize_objects, wait_for_completion, _tao_environment);
  
}

void POA_PortableServer::POAManager::_is_a_skel (
    CORBA::ServerRequest &req, 
    void * _tao_object_reference,
    void * /*context*/,
    CORBA::Environment &_tao_environment
  )
{
  CORBA::NVList_ptr nvlist;
  CORBA::NamedValue_ptr nv;
  CORBA::Any temp_value (CORBA::_tc_string);
  CORBA::Any *any;
  CORBA::Boolean *retval = new CORBA::Boolean;
  CORBA::String value;
  
  req.orb()->create_list (0, nvlist);
  nv = nvlist->add_value (0, temp_value, CORBA::ARG_IN, _tao_environment);
  req.params (nvlist, _tao_environment); // parse the args
  if (_tao_environment.exception () != 0) return;
  value = *(CORBA::String *)nv->value ()->value ();
  POA_PortableServer::POAManager_ptr 	 impl = (POA_PortableServer::POAManager_ptr) _tao_object_reference;
  *retval = impl->_is_a (value, _tao_environment);
  if (_tao_environment.exception () != 0) return;
  any = new CORBA::Any (CORBA::_tc_boolean, retval, CORBA::B_TRUE);
  req.result (any, _tao_environment);
}

CORBA::Boolean POA_PortableServer::POAManager::_is_a (
    const char* value,
    CORBA::Environment &_tao_environment
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/POAManager:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
      return CORBA::B_TRUE;
    else
      return CORBA::B_FALSE;
}

void* POA_PortableServer::POAManager::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/POAManager:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::POAManager_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::POAManager::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  CORBA::String opname = req.op_name (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
  }
else
  	skel (req, this, context, env);
}

const char* POA_PortableServer::POAManager::_interface_repository_id (void) const
{
  return "IDL:PortableServer/POAManager:1.0";
}

POA_PortableServer::_tao_collocated_POAManager::_tao_collocated_POAManager (
    POA_PortableServer::POAManager_ptr  servant,
    STUB_Object *stub
  )
  : ACE_NESTED_CLASS (PortableServer, POAManager) (stub, servant, CORBA::B_TRUE),
    CORBA_Object (stub, servant, CORBA::B_TRUE),
    servant_ (servant)
{
}

POA_PortableServer::POAManager_ptr POA_PortableServer::_tao_collocated_POAManager::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_POAManager::_is_a (
    const char* logical_type_id,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      _tao_environment
    );
}

void POA_PortableServer::_tao_collocated_POAManager::activate (
    CORBA::Environment &_tao_environment
  )
{
  this->servant_->activate (
       _tao_environment
    );
}

void POA_PortableServer::_tao_collocated_POAManager::hold_requests (
    CORBA::Boolean wait_for_completion,
    CORBA::Environment &_tao_environment
  )
{
  this->servant_->hold_requests (
      wait_for_completion,
       _tao_environment
    );
}

void POA_PortableServer::_tao_collocated_POAManager::discard_requests (
    CORBA::Boolean wait_for_completion,
    CORBA::Environment &_tao_environment
  )
{
  this->servant_->discard_requests (
      wait_for_completion,
       _tao_environment
    );
}

void POA_PortableServer::_tao_collocated_POAManager::deactivate (
    CORBA::Boolean etherealize_objects,
    CORBA::Boolean wait_for_completion,
    CORBA::Environment &_tao_environment
  )
{
  this->servant_->deactivate (
      etherealize_objects,
      wait_for_completion,
       _tao_environment
    );
}


PortableServer::POAManager*
POA_PortableServer::POAManager::_this (CORBA_Environment &_env)
{
  STUB_Object *stub = this->_create_stub (_env);
  if (_env.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_POAManager (this, stub);
}

static const TAO_operation_db_entry PortableServer_AdapterActivator_operations [] = {
  {"unknown_adapter", &POA_PortableServer::AdapterActivator::unknown_adapter_skel},
  {"_is_a", &POA_PortableServer::AdapterActivator::_is_a_skel}
};

TAO_Dynamic_Hash_OpTable tao_PortableServer_AdapterActivator_optable (PortableServer_AdapterActivator_operations, 2, 4);
// skeleton constructor
POA_PortableServer::AdapterActivator::AdapterActivator (void)
{
  this->optable_ = &tao_PortableServer_AdapterActivator_optable;
}

void POA_PortableServer::AdapterActivator::unknown_adapter_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  CORBA::NVList_ptr 	 nvlist;
  POA_PortableServer::AdapterActivator_ptr 	 impl = (POA_PortableServer::AdapterActivator_ptr) _tao_object_reference;
  CORBA::Any *result;
  CORBA::Boolean *retval = new CORBA::Boolean;
    // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (2, nvlist); // initialize a list
  // add each argument according to the in, out, inout semantics
  PortableServer::POA_ptr parent;
  CORBA::Object_ptr _tao_base_parent;
  (void) nvlist->add_item ("parent", CORBA::ARG_IN, _tao_environment)->value ()->replace (PortableServer::_tc_POA, &_tao_base_parent, 0, _tao_environment); // ORB does not own
  char *name;
  (void) nvlist->add_item ("name", CORBA::ARG_IN, _tao_environment)->value ()->replace (CORBA::_tc_string, &name, 0, _tao_environment); // ORB does not own
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  parent = PortableServer::POA::_narrow (_tao_base_parent, _tao_environment);
  if (_tao_environment.exception ()) return;
   *retval = impl->unknown_adapter(parent, name, _tao_environment);
  CORBA::release (parent);
  CORBA::release (_tao_base_parent);
  CORBA::string_free (name);
  result = new CORBA::Any (CORBA::_tc_boolean, retval, 1); // ORB owns
  _tao_server_request.result (result, _tao_environment);
  
}

void POA_PortableServer::AdapterActivator::_is_a_skel (
    CORBA::ServerRequest &req, 
    void * _tao_object_reference,
    void * /*context*/,
    CORBA::Environment &_tao_environment
  )
{
  CORBA::NVList_ptr nvlist;
  CORBA::NamedValue_ptr nv;
  CORBA::Any temp_value (CORBA::_tc_string);
  CORBA::Any *any;
  CORBA::Boolean *retval = new CORBA::Boolean;
  CORBA::String value;
  
  req.orb()->create_list (0, nvlist);
  nv = nvlist->add_value (0, temp_value, CORBA::ARG_IN, _tao_environment);
  req.params (nvlist, _tao_environment); // parse the args
  if (_tao_environment.exception () != 0) return;
  value = *(CORBA::String *)nv->value ()->value ();
  POA_PortableServer::AdapterActivator_ptr 	 impl = (POA_PortableServer::AdapterActivator_ptr) _tao_object_reference;
  *retval = impl->_is_a (value, _tao_environment);
  if (_tao_environment.exception () != 0) return;
  any = new CORBA::Any (CORBA::_tc_boolean, retval, CORBA::B_TRUE);
  req.result (any, _tao_environment);
}

CORBA::Boolean POA_PortableServer::AdapterActivator::_is_a (
    const char* value,
    CORBA::Environment &_tao_environment
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/AdapterActivator:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
      return CORBA::B_TRUE;
    else
      return CORBA::B_FALSE;
}

void* POA_PortableServer::AdapterActivator::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/AdapterActivator:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::AdapterActivator_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::AdapterActivator::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  CORBA::String opname = req.op_name (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
  }
else
  	skel (req, this, context, env);
}

const char* POA_PortableServer::AdapterActivator::_interface_repository_id (void) const
{
  return "IDL:PortableServer/AdapterActivator:1.0";
}

POA_PortableServer::_tao_collocated_AdapterActivator::_tao_collocated_AdapterActivator (
    POA_PortableServer::AdapterActivator_ptr  servant,
    STUB_Object *stub
  )
  : ACE_NESTED_CLASS (PortableServer, AdapterActivator) (stub, servant, CORBA::B_TRUE),
    CORBA_Object (stub, servant, CORBA::B_TRUE),
    servant_ (servant)
{
}

POA_PortableServer::AdapterActivator_ptr POA_PortableServer::_tao_collocated_AdapterActivator::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_AdapterActivator::_is_a (
    const char* logical_type_id,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      _tao_environment
    );
}

CORBA::Boolean POA_PortableServer::_tao_collocated_AdapterActivator::unknown_adapter (
    PortableServer::POA_ptr  parent,
    const char* name,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->unknown_adapter (
      parent,
      name,
       _tao_environment
    );
}


PortableServer::AdapterActivator*
POA_PortableServer::AdapterActivator::_this (CORBA_Environment &_env)
{
  STUB_Object *stub = this->_create_stub (_env);
  if (_env.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_AdapterActivator (this, stub);
}

static const TAO_operation_db_entry PortableServer_ServantManager_operations [] = {
  {"_is_a", &POA_PortableServer::ServantManager::_is_a_skel}
};

TAO_Dynamic_Hash_OpTable tao_PortableServer_ServantManager_optable (PortableServer_ServantManager_operations, 1, 2);
// skeleton constructor
POA_PortableServer::ServantManager::ServantManager (void)
{
  this->optable_ = &tao_PortableServer_ServantManager_optable;
}

void POA_PortableServer::ServantManager::_is_a_skel (
    CORBA::ServerRequest &req, 
    void * _tao_object_reference,
    void * /*context*/,
    CORBA::Environment &_tao_environment
  )
{
  CORBA::NVList_ptr nvlist;
  CORBA::NamedValue_ptr nv;
  CORBA::Any temp_value (CORBA::_tc_string);
  CORBA::Any *any;
  CORBA::Boolean *retval = new CORBA::Boolean;
  CORBA::String value;
  
  req.orb()->create_list (0, nvlist);
  nv = nvlist->add_value (0, temp_value, CORBA::ARG_IN, _tao_environment);
  req.params (nvlist, _tao_environment); // parse the args
  if (_tao_environment.exception () != 0) return;
  value = *(CORBA::String *)nv->value ()->value ();
  POA_PortableServer::ServantManager_ptr 	 impl = (POA_PortableServer::ServantManager_ptr) _tao_object_reference;
  *retval = impl->_is_a (value, _tao_environment);
  if (_tao_environment.exception () != 0) return;
  any = new CORBA::Any (CORBA::_tc_boolean, retval, CORBA::B_TRUE);
  req.result (any, _tao_environment);
}

CORBA::Boolean POA_PortableServer::ServantManager::_is_a (
    const char* value,
    CORBA::Environment &_tao_environment
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ServantManager:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
      return CORBA::B_TRUE;
    else
      return CORBA::B_FALSE;
}

void* POA_PortableServer::ServantManager::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/ServantManager:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ServantManager_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::ServantManager::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  CORBA::String opname = req.op_name (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
  }
else
  	skel (req, this, context, env);
}

const char* POA_PortableServer::ServantManager::_interface_repository_id (void) const
{
  return "IDL:PortableServer/ServantManager:1.0";
}

POA_PortableServer::_tao_collocated_ServantManager::_tao_collocated_ServantManager (
    POA_PortableServer::ServantManager_ptr  servant,
    STUB_Object *stub
  )
  : ACE_NESTED_CLASS (PortableServer, ServantManager) (stub, servant, CORBA::B_TRUE),
    CORBA_Object (stub, servant, CORBA::B_TRUE),
    servant_ (servant)
{
}

POA_PortableServer::ServantManager_ptr POA_PortableServer::_tao_collocated_ServantManager::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_ServantManager::_is_a (
    const char* logical_type_id,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      _tao_environment
    );
}


PortableServer::ServantManager*
POA_PortableServer::ServantManager::_this (CORBA_Environment &_env)
{
  STUB_Object *stub = this->_create_stub (_env);
  if (_env.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_ServantManager (this, stub);
}

static const TAO_operation_db_entry PortableServer_ServantActivator_operations [] = {
  {"incarnate", &POA_PortableServer::ServantActivator::incarnate_skel},
  {"etherealize", &POA_PortableServer::ServantActivator::etherealize_skel},
  {"_is_a", &POA_PortableServer::ServantActivator::_is_a_skel}
};

TAO_Dynamic_Hash_OpTable tao_PortableServer_ServantActivator_optable (PortableServer_ServantActivator_operations, 3, 6);
// skeleton constructor
POA_PortableServer::ServantActivator::ServantActivator (void)
{
  this->optable_ = &tao_PortableServer_ServantActivator_optable;
}

void POA_PortableServer::ServantActivator::incarnate_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  _tao_environment.exception (new CORBA::MARSHAL (CORBA::COMPLETED_NO));
}

void POA_PortableServer::ServantActivator::etherealize_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  _tao_environment.exception (new CORBA::MARSHAL (CORBA::COMPLETED_NO));
}

void POA_PortableServer::ServantActivator::_is_a_skel (
    CORBA::ServerRequest &req, 
    void * _tao_object_reference,
    void * /*context*/,
    CORBA::Environment &_tao_environment
  )
{
  CORBA::NVList_ptr nvlist;
  CORBA::NamedValue_ptr nv;
  CORBA::Any temp_value (CORBA::_tc_string);
  CORBA::Any *any;
  CORBA::Boolean *retval = new CORBA::Boolean;
  CORBA::String value;
  
  req.orb()->create_list (0, nvlist);
  nv = nvlist->add_value (0, temp_value, CORBA::ARG_IN, _tao_environment);
  req.params (nvlist, _tao_environment); // parse the args
  if (_tao_environment.exception () != 0) return;
  value = *(CORBA::String *)nv->value ()->value ();
  POA_PortableServer::ServantActivator_ptr 	 impl = (POA_PortableServer::ServantActivator_ptr) _tao_object_reference;
  *retval = impl->_is_a (value, _tao_environment);
  if (_tao_environment.exception () != 0) return;
  any = new CORBA::Any (CORBA::_tc_boolean, retval, CORBA::B_TRUE);
  req.result (any, _tao_environment);
}

CORBA::Boolean POA_PortableServer::ServantActivator::_is_a (
    const char* value,
    CORBA::Environment &_tao_environment
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ServantActivator:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ServantManager:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
      return CORBA::B_TRUE;
    else
      return CORBA::B_FALSE;
}

void* POA_PortableServer::ServantActivator::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/ServantActivator:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ServantActivator_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/ServantManager:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ServantManager_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::ServantActivator::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  CORBA::String opname = req.op_name (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
  }
else
  	skel (req, this, context, env);
}

const char* POA_PortableServer::ServantActivator::_interface_repository_id (void) const
{
  return "IDL:PortableServer/ServantActivator:1.0";
}

POA_PortableServer::_tao_collocated_ServantActivator::_tao_collocated_ServantActivator (
    POA_PortableServer::ServantActivator_ptr  servant,
    STUB_Object *stub
  )
  : ACE_NESTED_CLASS (PortableServer, ServantActivator) (stub, servant, CORBA::B_TRUE),
    _tao_collocated_ServantManager (servant, stub),
    CORBA_Object (stub, servant, CORBA::B_TRUE),
    servant_ (servant)
{
}

POA_PortableServer::ServantActivator_ptr POA_PortableServer::_tao_collocated_ServantActivator::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_ServantActivator::_is_a (
    const char* logical_type_id,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      _tao_environment
    );
}

PortableServer::Servant POA_PortableServer::_tao_collocated_ServantActivator::incarnate (
    const PortableServer::ObjectId & oid,
    PortableServer::POA_ptr  adapter,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->incarnate (
      oid,
      adapter,
       _tao_environment
    );
}

void POA_PortableServer::_tao_collocated_ServantActivator::etherealize (
    const PortableServer::ObjectId & oid,
    PortableServer::POA_ptr  adapter,
    PortableServer::Servant serv,
    CORBA::Boolean cleanup_in_progress,
    CORBA::Boolean remaining_activations,
    CORBA::Environment &_tao_environment
  )
{
  this->servant_->etherealize (
      oid,
      adapter,
      serv,
      cleanup_in_progress,
      remaining_activations,
       _tao_environment
    );
}


PortableServer::ServantActivator*
POA_PortableServer::ServantActivator::_this (CORBA_Environment &_env)
{
  STUB_Object *stub = this->_create_stub (_env);
  if (_env.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_ServantActivator (this, stub);
}

static const TAO_operation_db_entry PortableServer_ServantLocator_operations [] = {
  {"preinvoke", &POA_PortableServer::ServantLocator::preinvoke_skel},
  {"postinvoke", &POA_PortableServer::ServantLocator::postinvoke_skel},
  {"_is_a", &POA_PortableServer::ServantLocator::_is_a_skel}
};

TAO_Dynamic_Hash_OpTable tao_PortableServer_ServantLocator_optable (PortableServer_ServantLocator_operations, 3, 6);
// skeleton constructor
POA_PortableServer::ServantLocator::ServantLocator (void)
{
  this->optable_ = &tao_PortableServer_ServantLocator_optable;
}

void POA_PortableServer::ServantLocator::preinvoke_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  _tao_environment.exception (new CORBA::MARSHAL (CORBA::COMPLETED_NO));
}

void POA_PortableServer::ServantLocator::postinvoke_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  _tao_environment.exception (new CORBA::MARSHAL (CORBA::COMPLETED_NO));
}

void POA_PortableServer::ServantLocator::_is_a_skel (
    CORBA::ServerRequest &req, 
    void * _tao_object_reference,
    void * /*context*/,
    CORBA::Environment &_tao_environment
  )
{
  CORBA::NVList_ptr nvlist;
  CORBA::NamedValue_ptr nv;
  CORBA::Any temp_value (CORBA::_tc_string);
  CORBA::Any *any;
  CORBA::Boolean *retval = new CORBA::Boolean;
  CORBA::String value;
  
  req.orb()->create_list (0, nvlist);
  nv = nvlist->add_value (0, temp_value, CORBA::ARG_IN, _tao_environment);
  req.params (nvlist, _tao_environment); // parse the args
  if (_tao_environment.exception () != 0) return;
  value = *(CORBA::String *)nv->value ()->value ();
  POA_PortableServer::ServantLocator_ptr 	 impl = (POA_PortableServer::ServantLocator_ptr) _tao_object_reference;
  *retval = impl->_is_a (value, _tao_environment);
  if (_tao_environment.exception () != 0) return;
  any = new CORBA::Any (CORBA::_tc_boolean, retval, CORBA::B_TRUE);
  req.result (any, _tao_environment);
}

CORBA::Boolean POA_PortableServer::ServantLocator::_is_a (
    const char* value,
    CORBA::Environment &_tao_environment
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ServantLocator:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ServantManager:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
      return CORBA::B_TRUE;
    else
      return CORBA::B_FALSE;
}

void* POA_PortableServer::ServantLocator::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/ServantLocator:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ServantLocator_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/ServantManager:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ServantManager_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::ServantLocator::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  CORBA::String opname = req.op_name (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
  }
else
  	skel (req, this, context, env);
}

const char* POA_PortableServer::ServantLocator::_interface_repository_id (void) const
{
  return "IDL:PortableServer/ServantLocator:1.0";
}

POA_PortableServer::_tao_collocated_ServantLocator::_tao_collocated_ServantLocator (
    POA_PortableServer::ServantLocator_ptr  servant,
    STUB_Object *stub
  )
  : ACE_NESTED_CLASS (PortableServer, ServantLocator) (stub, servant, CORBA::B_TRUE),
    _tao_collocated_ServantManager (servant, stub),
    CORBA_Object (stub, servant, CORBA::B_TRUE),
    servant_ (servant)
{
}

POA_PortableServer::ServantLocator_ptr POA_PortableServer::_tao_collocated_ServantLocator::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_ServantLocator::_is_a (
    const char* logical_type_id,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      _tao_environment
    );
}

PortableServer::Servant POA_PortableServer::_tao_collocated_ServantLocator::preinvoke (
    const PortableServer::ObjectId & oid,
    PortableServer::POA_ptr  adapter,
    const char * operation,
    PortableServer::ServantLocator::Cookie & the_cookie,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->preinvoke (
      oid,
      adapter,
      operation,
      the_cookie,
       _tao_environment
    );
}

void POA_PortableServer::_tao_collocated_ServantLocator::postinvoke (
    const PortableServer::ObjectId & oid,
    PortableServer::POA_ptr  adapter,
    const char * operation,
    PortableServer::ServantLocator::Cookie the_cookie,
    PortableServer::Servant the_servant,
    CORBA::Environment &_tao_environment
  )
{
  this->servant_->postinvoke (
      oid,
      adapter,
      operation,
      the_cookie,
      the_servant,
       _tao_environment
    );
}


PortableServer::ServantLocator*
POA_PortableServer::ServantLocator::_this (CORBA_Environment &_env)
{
  STUB_Object *stub = this->_create_stub (_env);
  if (_env.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_ServantLocator (this, stub);
}

static const TAO_operation_db_entry PortableServer_POA_operations [] = {
  {"create_POA", &POA_PortableServer::POA::create_POA_skel},
  {"find_POA", &POA_PortableServer::POA::find_POA_skel},
  {"destroy", &POA_PortableServer::POA::destroy_skel},
  {"create_thread_policy", &POA_PortableServer::POA::create_thread_policy_skel},
  {"create_lifespan_policy", &POA_PortableServer::POA::create_lifespan_policy_skel},
  {"create_id_uniqueness_policy", &POA_PortableServer::POA::create_id_uniqueness_policy_skel},
  {"create_id_assignment_policy", &POA_PortableServer::POA::create_id_assignment_policy_skel},
  {"create_implicit_activation_policy", &POA_PortableServer::POA::create_implicit_activation_policy_skel},
  {"create_servant_retention_policy", &POA_PortableServer::POA::create_servant_retention_policy_skel},
  {"create_request_processing_policy", &POA_PortableServer::POA::create_request_processing_policy_skel},
  {"_get_the_name", &POA_PortableServer::POA::_get_the_name_skel},
  {"_get_the_parent", &POA_PortableServer::POA::_get_the_parent_skel},
  {"_get_the_POAManager", &POA_PortableServer::POA::_get_the_POAManager_skel},
  {"_get_the_activator", &POA_PortableServer::POA::_get_the_activator_skel},
  {"_set_the_activator", &POA_PortableServer::POA::_set_the_activator_skel},
  {"get_servant_manager", &POA_PortableServer::POA::get_servant_manager_skel},
  {"set_servant_manager", &POA_PortableServer::POA::set_servant_manager_skel},
  {"get_servant", &POA_PortableServer::POA::get_servant_skel},
  {"set_servant", &POA_PortableServer::POA::set_servant_skel},
  {"activate_object", &POA_PortableServer::POA::activate_object_skel},
  {"activate_object_with_id", &POA_PortableServer::POA::activate_object_with_id_skel},
  {"deactivate_object", &POA_PortableServer::POA::deactivate_object_skel},
  {"create_reference", &POA_PortableServer::POA::create_reference_skel},
  {"create_reference_with_id", &POA_PortableServer::POA::create_reference_with_id_skel},
  {"servant_to_id", &POA_PortableServer::POA::servant_to_id_skel},
  {"servant_to_reference", &POA_PortableServer::POA::servant_to_reference_skel},
  {"reference_to_servant", &POA_PortableServer::POA::reference_to_servant_skel},
  {"reference_to_id", &POA_PortableServer::POA::reference_to_id_skel},
  {"id_to_servant", &POA_PortableServer::POA::id_to_servant_skel},
  {"id_to_reference", &POA_PortableServer::POA::id_to_reference_skel},
  {"_is_a", &POA_PortableServer::POA::_is_a_skel}
};

TAO_Dynamic_Hash_OpTable tao_PortableServer_POA_optable (PortableServer_POA_operations, 31, 62);
// skeleton constructor
POA_PortableServer::POA::POA (void)
{
  this->optable_ = &tao_PortableServer_POA_optable;
}

void POA_PortableServer::POA::create_POA_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  CORBA::NVList_ptr 	 nvlist;
  POA_PortableServer::POA_ptr 	 impl = (POA_PortableServer::POA_ptr) _tao_object_reference;
  CORBA::Any *result;
  CORBA::Object_ptr *retval = new CORBA::Object_ptr;
  *retval = CORBA::Object::_nil ();
    // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (3, nvlist); // initialize a list
  // add each argument according to the in, out, inout semantics
  char *adapter_name;
  (void) nvlist->add_item ("adapter_name", CORBA::ARG_IN, _tao_environment)->value ()->replace (CORBA::_tc_string, &adapter_name, 0, _tao_environment); // ORB does not own
  PortableServer::POAManager_ptr a_POAManager;
  CORBA::Object_ptr _tao_base_a_POAManager;
  (void) nvlist->add_item ("a_POAManager", CORBA::ARG_IN, _tao_environment)->value ()->replace (PortableServer::_tc_POAManager, &_tao_base_a_POAManager, 0, _tao_environment); // ORB does not own
  PortableServer::PolicyList policies;
  (void) nvlist->add_item ("policies", CORBA::ARG_IN, _tao_environment)->value ()->replace (PortableServer::_tc_PolicyList, &policies, 0, _tao_environment); // ORB does not own
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  a_POAManager = PortableServer::POAManager::_narrow (_tao_base_a_POAManager, _tao_environment);
  if (_tao_environment.exception ()) return;
  *retval = impl->create_POA(adapter_name, a_POAManager, policies, _tao_environment);
  CORBA::string_free (adapter_name);
  CORBA::release (a_POAManager);
  CORBA::release (_tao_base_a_POAManager);
  result = new CORBA::Any (PortableServer::_tc_POA, retval, 1); // ORB owns
  _tao_server_request.result (result, _tao_environment);
  
}

void POA_PortableServer::POA::find_POA_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  CORBA::NVList_ptr 	 nvlist;
  POA_PortableServer::POA_ptr 	 impl = (POA_PortableServer::POA_ptr) _tao_object_reference;
  CORBA::Any *result;
  CORBA::Object_ptr *retval = new CORBA::Object_ptr;
  *retval = CORBA::Object::_nil ();
    // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (2, nvlist); // initialize a list
  // add each argument according to the in, out, inout semantics
  char *adapter_name;
  (void) nvlist->add_item ("adapter_name", CORBA::ARG_IN, _tao_environment)->value ()->replace (CORBA::_tc_string, &adapter_name, 0, _tao_environment); // ORB does not own
  CORBA::Boolean activate_it;
  (void) nvlist->add_item ("activate_it", CORBA::ARG_IN, _tao_environment)->value ()->replace (CORBA::_tc_boolean, &activate_it, 0, _tao_environment); // ORB does not own
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  *retval = impl->find_POA(adapter_name, activate_it, _tao_environment);
  CORBA::string_free (adapter_name);
  result = new CORBA::Any (PortableServer::_tc_POA, retval, 1); // ORB owns
  _tao_server_request.result (result, _tao_environment);
  
}

void POA_PortableServer::POA::destroy_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  CORBA::NVList_ptr 	 nvlist;
  POA_PortableServer::POA_ptr 	 impl = (POA_PortableServer::POA_ptr) _tao_object_reference;
    // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (2, nvlist); // initialize a list
  // add each argument according to the in, out, inout semantics
  CORBA::Boolean etherealize_objects;
  (void) nvlist->add_item ("etherealize_objects", CORBA::ARG_IN, _tao_environment)->value ()->replace (CORBA::_tc_boolean, &etherealize_objects, 0, _tao_environment); // ORB does not own
  CORBA::Boolean wait_for_completion;
  (void) nvlist->add_item ("wait_for_completion", CORBA::ARG_IN, _tao_environment)->value ()->replace (CORBA::_tc_boolean, &wait_for_completion, 0, _tao_environment); // ORB does not own
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  impl->destroy(etherealize_objects, wait_for_completion, _tao_environment);
  
}

void POA_PortableServer::POA::create_thread_policy_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  CORBA::NVList_ptr 	 nvlist;
  POA_PortableServer::POA_ptr 	 impl = (POA_PortableServer::POA_ptr) _tao_object_reference;
  CORBA::Any *result;
  CORBA::Object_ptr *retval = new CORBA::Object_ptr;
  *retval = CORBA::Object::_nil ();
    // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (1, nvlist); // initialize a list
  // add each argument according to the in, out, inout semantics
  PortableServer::ThreadPolicyValue value;
  (void) nvlist->add_item ("value", CORBA::ARG_IN, _tao_environment)->value ()->replace (PortableServer::_tc_ThreadPolicyValue, &value, 0, _tao_environment); // ORB does not own
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  *retval = impl->create_thread_policy(value, _tao_environment);
  result = new CORBA::Any (PortableServer::_tc_ThreadPolicy, retval, 1); // ORB owns
  _tao_server_request.result (result, _tao_environment);
  
}

void POA_PortableServer::POA::create_lifespan_policy_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  CORBA::NVList_ptr 	 nvlist;
  POA_PortableServer::POA_ptr 	 impl = (POA_PortableServer::POA_ptr) _tao_object_reference;
  CORBA::Any *result;
  CORBA::Object_ptr *retval = new CORBA::Object_ptr;
  *retval = CORBA::Object::_nil ();
    // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (1, nvlist); // initialize a list
  // add each argument according to the in, out, inout semantics
  PortableServer::LifespanPolicyValue value;
  (void) nvlist->add_item ("value", CORBA::ARG_IN, _tao_environment)->value ()->replace (PortableServer::_tc_LifespanPolicyValue, &value, 0, _tao_environment); // ORB does not own
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  *retval = impl->create_lifespan_policy(value, _tao_environment);
  result = new CORBA::Any (PortableServer::_tc_LifespanPolicy, retval, 1); // ORB owns
  _tao_server_request.result (result, _tao_environment);
  
}

void POA_PortableServer::POA::create_id_uniqueness_policy_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  CORBA::NVList_ptr 	 nvlist;
  POA_PortableServer::POA_ptr 	 impl = (POA_PortableServer::POA_ptr) _tao_object_reference;
  CORBA::Any *result;
  CORBA::Object_ptr *retval = new CORBA::Object_ptr;
  *retval = CORBA::Object::_nil ();
    // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (1, nvlist); // initialize a list
  // add each argument according to the in, out, inout semantics
  PortableServer::IdUniquenessPolicyValue value;
  (void) nvlist->add_item ("value", CORBA::ARG_IN, _tao_environment)->value ()->replace (PortableServer::_tc_IdUniquenessPolicyValue, &value, 0, _tao_environment); // ORB does not own
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  *retval = impl->create_id_uniqueness_policy(value, _tao_environment);
  result = new CORBA::Any (PortableServer::_tc_IdUniquenessPolicy, retval, 1); // ORB owns
  _tao_server_request.result (result, _tao_environment);
  
}

void POA_PortableServer::POA::create_id_assignment_policy_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  CORBA::NVList_ptr 	 nvlist;
  POA_PortableServer::POA_ptr 	 impl = (POA_PortableServer::POA_ptr) _tao_object_reference;
  CORBA::Any *result;
  CORBA::Object_ptr *retval = new CORBA::Object_ptr;
  *retval = CORBA::Object::_nil ();
    // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (1, nvlist); // initialize a list
  // add each argument according to the in, out, inout semantics
  PortableServer::IdAssignmentPolicyValue value;
  (void) nvlist->add_item ("value", CORBA::ARG_IN, _tao_environment)->value ()->replace (PortableServer::_tc_IdAssignmentPolicyValue, &value, 0, _tao_environment); // ORB does not own
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  *retval = impl->create_id_assignment_policy(value, _tao_environment);
  result = new CORBA::Any (PortableServer::_tc_IdAssignmentPolicy, retval, 1); // ORB owns
  _tao_server_request.result (result, _tao_environment);
  
}

void POA_PortableServer::POA::create_implicit_activation_policy_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  CORBA::NVList_ptr 	 nvlist;
  POA_PortableServer::POA_ptr 	 impl = (POA_PortableServer::POA_ptr) _tao_object_reference;
  CORBA::Any *result;
  CORBA::Object_ptr *retval = new CORBA::Object_ptr;
  *retval = CORBA::Object::_nil ();
    // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (1, nvlist); // initialize a list
  // add each argument according to the in, out, inout semantics
  PortableServer::ImplicitActivationPolicyValue value;
  (void) nvlist->add_item ("value", CORBA::ARG_IN, _tao_environment)->value ()->replace (PortableServer::_tc_ImplicitActivationPolicyValue, &value, 0, _tao_environment); // ORB does not own
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  *retval = impl->create_implicit_activation_policy(value, _tao_environment);
  result = new CORBA::Any (PortableServer::_tc_ImplicitActivationPolicy, retval, 1); // ORB owns
  _tao_server_request.result (result, _tao_environment);
  
}

void POA_PortableServer::POA::create_servant_retention_policy_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  CORBA::NVList_ptr 	 nvlist;
  POA_PortableServer::POA_ptr 	 impl = (POA_PortableServer::POA_ptr) _tao_object_reference;
  CORBA::Any *result;
  CORBA::Object_ptr *retval = new CORBA::Object_ptr;
  *retval = CORBA::Object::_nil ();
    // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (1, nvlist); // initialize a list
  // add each argument according to the in, out, inout semantics
  PortableServer::ServantRetentionPolicyValue value;
  (void) nvlist->add_item ("value", CORBA::ARG_IN, _tao_environment)->value ()->replace (PortableServer::_tc_ServantRetentionPolicyValue, &value, 0, _tao_environment); // ORB does not own
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  *retval = impl->create_servant_retention_policy(value, _tao_environment);
  result = new CORBA::Any (PortableServer::_tc_ServantRetentionPolicy, retval, 1); // ORB owns
  _tao_server_request.result (result, _tao_environment);
  
}

void POA_PortableServer::POA::create_request_processing_policy_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  CORBA::NVList_ptr 	 nvlist;
  POA_PortableServer::POA_ptr 	 impl = (POA_PortableServer::POA_ptr) _tao_object_reference;
  CORBA::Any *result;
  CORBA::Object_ptr *retval = new CORBA::Object_ptr;
  *retval = CORBA::Object::_nil ();
    // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (1, nvlist); // initialize a list
  // add each argument according to the in, out, inout semantics
  PortableServer::RequestProcessingPolicyValue value;
  (void) nvlist->add_item ("value", CORBA::ARG_IN, _tao_environment)->value ()->replace (PortableServer::_tc_RequestProcessingPolicyValue, &value, 0, _tao_environment); // ORB does not own
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  *retval = impl->create_request_processing_policy(value, _tao_environment);
  result = new CORBA::Any (PortableServer::_tc_RequestProcessingPolicy, retval, 1); // ORB owns
  _tao_server_request.result (result, _tao_environment);
  
}

void POA_PortableServer::POA::_get_the_name_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void * /*context*/, CORBA::Environment &_tao_environment)
{
  POA_PortableServer::POA_ptr impl = (POA_PortableServer::POA_ptr) _tao_object_reference;
  CORBA::Any *result;
  char **retval = new char*;
    // this method has no incoming parameters. Nothing to parse
  *retval = impl->the_name(_tao_environment);
  result = new CORBA::Any (CORBA::_tc_string, retval, 1); // ORB owns
  _tao_server_request.result (result, _tao_environment);
}

void POA_PortableServer::POA::_get_the_parent_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void * /*context*/, CORBA::Environment &_tao_environment)
{
  POA_PortableServer::POA_ptr impl = (POA_PortableServer::POA_ptr) _tao_object_reference;
  CORBA::Any *result;
  CORBA::Object_ptr *retval = new CORBA::Object_ptr;
  *retval = CORBA::Object::_nil ();
    // this method has no incoming parameters. Nothing to parse
  *retval = impl->the_parent(_tao_environment);
  result = new CORBA::Any (PortableServer::_tc_POA, retval, 1); // ORB owns
  _tao_server_request.result (result, _tao_environment);
}

void POA_PortableServer::POA::_get_the_POAManager_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void * /*context*/, CORBA::Environment &_tao_environment)
{
  POA_PortableServer::POA_ptr impl = (POA_PortableServer::POA_ptr) _tao_object_reference;
  CORBA::Any *result;
  CORBA::Object_ptr *retval = new CORBA::Object_ptr;
  *retval = CORBA::Object::_nil ();
    // this method has no incoming parameters. Nothing to parse
  *retval = impl->the_POAManager(_tao_environment);
  result = new CORBA::Any (PortableServer::_tc_POAManager, retval, 1); // ORB owns
  _tao_server_request.result (result, _tao_environment);
}

void POA_PortableServer::POA::_get_the_activator_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void * /*context*/, CORBA::Environment &_tao_environment)
{
  POA_PortableServer::POA_ptr impl = (POA_PortableServer::POA_ptr) _tao_object_reference;
  CORBA::Any *result;
  CORBA::Object_ptr *retval = new CORBA::Object_ptr;
  *retval = CORBA::Object::_nil ();
    // this method has no incoming parameters. Nothing to parse
  *retval = impl->the_activator(_tao_environment);
  result = new CORBA::Any (PortableServer::_tc_AdapterActivator, retval, 1); // ORB owns
  _tao_server_request.result (result, _tao_environment);
}

void POA_PortableServer::POA::_set_the_activator_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void * /*context*/, CORBA::Environment &_tao_environment)
{
  CORBA::NVList_ptr 	 nvlist;
  POA_PortableServer::POA_ptr 	 impl = (POA_PortableServer::POA_ptr)_tao_object_reference;
    // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (1, nvlist); // initialize a list
  PortableServer::AdapterActivator_ptr the_activator;
  CORBA::Object_ptr _tao_base_the_activator;
  (void) nvlist->add_item ("the_activator", CORBA::ARG_IN, _tao_environment)->value ()->replace (PortableServer::_tc_AdapterActivator, &_tao_base_the_activator, 0, _tao_environment); // ORB does not own
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  the_activator = PortableServer::AdapterActivator::_narrow (_tao_base_the_activator, _tao_environment);
  if (_tao_environment.exception ()) return;
  impl->the_activator(the_activator, _tao_environment);
  CORBA::release (the_activator);
  CORBA::release (_tao_base_the_activator);
  
}

void POA_PortableServer::POA::get_servant_manager_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  CORBA::NVList_ptr 	 nvlist;
  POA_PortableServer::POA_ptr 	 impl = (POA_PortableServer::POA_ptr) _tao_object_reference;
  CORBA::Any *result;
  CORBA::Object_ptr *retval = new CORBA::Object_ptr;
  *retval = CORBA::Object::_nil ();
    // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (0, nvlist); // initialize a list
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  *retval = impl->get_servant_manager(_tao_environment);
  result = new CORBA::Any (PortableServer::_tc_ServantManager, retval, 1); // ORB owns
  _tao_server_request.result (result, _tao_environment);
  
}

void POA_PortableServer::POA::set_servant_manager_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  CORBA::NVList_ptr 	 nvlist;
  POA_PortableServer::POA_ptr 	 impl = (POA_PortableServer::POA_ptr) _tao_object_reference;
    // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (1, nvlist); // initialize a list
  // add each argument according to the in, out, inout semantics
  PortableServer::ServantManager_ptr imgr;
  CORBA::Object_ptr _tao_base_imgr;
  (void) nvlist->add_item ("imgr", CORBA::ARG_IN, _tao_environment)->value ()->replace (PortableServer::_tc_ServantManager, &_tao_base_imgr, 0, _tao_environment); // ORB does not own
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  imgr = PortableServer::ServantManager::_narrow (_tao_base_imgr, _tao_environment);
  if (_tao_environment.exception ()) return;
  impl->set_servant_manager(imgr, _tao_environment);
  CORBA::release (imgr);
  CORBA::release (_tao_base_imgr);
  
}

void POA_PortableServer::POA::get_servant_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  _tao_environment.exception (new CORBA::MARSHAL (CORBA::COMPLETED_NO));
}

void POA_PortableServer::POA::set_servant_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  _tao_environment.exception (new CORBA::MARSHAL (CORBA::COMPLETED_NO));
}

void POA_PortableServer::POA::activate_object_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  _tao_environment.exception (new CORBA::MARSHAL (CORBA::COMPLETED_NO));
}

void POA_PortableServer::POA::activate_object_with_id_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  _tao_environment.exception (new CORBA::MARSHAL (CORBA::COMPLETED_NO));
}

void POA_PortableServer::POA::deactivate_object_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  CORBA::NVList_ptr 	 nvlist;
  POA_PortableServer::POA_ptr 	 impl = (POA_PortableServer::POA_ptr) _tao_object_reference;
    // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (1, nvlist); // initialize a list
  // add each argument according to the in, out, inout semantics
  PortableServer::ObjectId oid;
  (void) nvlist->add_item ("oid", CORBA::ARG_IN, _tao_environment)->value ()->replace (PortableServer::_tc_ObjectId, &oid, 0, _tao_environment); // ORB does not own
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  impl->deactivate_object(oid, _tao_environment);
  
}

void POA_PortableServer::POA::create_reference_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  CORBA::NVList_ptr 	 nvlist;
  POA_PortableServer::POA_ptr 	 impl = (POA_PortableServer::POA_ptr) _tao_object_reference;
  CORBA::Any *result;
  CORBA::Object_ptr *retval = new CORBA::Object_ptr;
    // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (1, nvlist); // initialize a list
  // add each argument according to the in, out, inout semantics
  char *intf;
  (void) nvlist->add_item ("intf", CORBA::ARG_IN, _tao_environment)->value ()->replace (PortableServer::_tc_RepositoryId, &intf, 0, _tao_environment); // ORB does not own
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  *retval = impl->create_reference(intf, _tao_environment);
  CORBA::string_free (intf);
  result = new CORBA::Any (CORBA::_tc_Object, retval, 1); // ORB owns
  _tao_server_request.result (result, _tao_environment);
  
}

void POA_PortableServer::POA::create_reference_with_id_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  CORBA::NVList_ptr 	 nvlist;
  POA_PortableServer::POA_ptr 	 impl = (POA_PortableServer::POA_ptr) _tao_object_reference;
  CORBA::Any *result;
  CORBA::Object_ptr *retval = new CORBA::Object_ptr;
    // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (2, nvlist); // initialize a list
  // add each argument according to the in, out, inout semantics
  PortableServer::ObjectId oid;
  (void) nvlist->add_item ("oid", CORBA::ARG_IN, _tao_environment)->value ()->replace (PortableServer::_tc_ObjectId, &oid, 0, _tao_environment); // ORB does not own
  char *intf;
  (void) nvlist->add_item ("intf", CORBA::ARG_IN, _tao_environment)->value ()->replace (PortableServer::_tc_RepositoryId, &intf, 0, _tao_environment); // ORB does not own
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  *retval = impl->create_reference_with_id(oid, intf, _tao_environment);
  CORBA::string_free (intf);
  result = new CORBA::Any (CORBA::_tc_Object, retval, 1); // ORB owns
  _tao_server_request.result (result, _tao_environment);
  
}

void POA_PortableServer::POA::servant_to_id_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  _tao_environment.exception (new CORBA::MARSHAL (CORBA::COMPLETED_NO));
}

void POA_PortableServer::POA::servant_to_reference_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  _tao_environment.exception (new CORBA::MARSHAL (CORBA::COMPLETED_NO));
}

void POA_PortableServer::POA::reference_to_servant_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  _tao_environment.exception (new CORBA::MARSHAL (CORBA::COMPLETED_NO));
}

void POA_PortableServer::POA::reference_to_id_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  CORBA::NVList_ptr 	 nvlist;
  POA_PortableServer::POA_ptr 	 impl = (POA_PortableServer::POA_ptr) _tao_object_reference;
  CORBA::Any *result;
  PortableServer::ObjectId *retval;
    // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (1, nvlist); // initialize a list
  // add each argument according to the in, out, inout semantics
  CORBA::Object_ptr reference;
  (void) nvlist->add_item ("reference", CORBA::ARG_IN, _tao_environment)->value ()->replace (CORBA::_tc_Object, &reference, 0, _tao_environment); // ORB does not own
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  retval = impl->reference_to_id(reference, _tao_environment);
  CORBA::release (reference);
  result = new CORBA::Any (PortableServer::_tc_ObjectId, retval, 1); // ORB owns
  _tao_server_request.result (result, _tao_environment);
  
}

void POA_PortableServer::POA::id_to_servant_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  _tao_environment.exception (new CORBA::MARSHAL (CORBA::COMPLETED_NO));
}

void POA_PortableServer::POA::id_to_reference_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  CORBA::NVList_ptr 	 nvlist;
  POA_PortableServer::POA_ptr 	 impl = (POA_PortableServer::POA_ptr) _tao_object_reference;
  CORBA::Any *result;
  CORBA::Object_ptr *retval = new CORBA::Object_ptr;
    // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (1, nvlist); // initialize a list
  // add each argument according to the in, out, inout semantics
  PortableServer::ObjectId oid;
  (void) nvlist->add_item ("oid", CORBA::ARG_IN, _tao_environment)->value ()->replace (PortableServer::_tc_ObjectId, &oid, 0, _tao_environment); // ORB does not own
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  *retval = impl->id_to_reference(oid, _tao_environment);
  result = new CORBA::Any (CORBA::_tc_Object, retval, 1); // ORB owns
  _tao_server_request.result (result, _tao_environment);
  
}

void POA_PortableServer::POA::_is_a_skel (
    CORBA::ServerRequest &req, 
    void * _tao_object_reference,
    void * /*context*/,
    CORBA::Environment &_tao_environment
  )
{
  CORBA::NVList_ptr nvlist;
  CORBA::NamedValue_ptr nv;
  CORBA::Any temp_value (CORBA::_tc_string);
  CORBA::Any *any;
  CORBA::Boolean *retval = new CORBA::Boolean;
  CORBA::String value;
  
  req.orb()->create_list (0, nvlist);
  nv = nvlist->add_value (0, temp_value, CORBA::ARG_IN, _tao_environment);
  req.params (nvlist, _tao_environment); // parse the args
  if (_tao_environment.exception () != 0) return;
  value = *(CORBA::String *)nv->value ()->value ();
  POA_PortableServer::POA_ptr 	 impl = (POA_PortableServer::POA_ptr) _tao_object_reference;
  *retval = impl->_is_a (value, _tao_environment);
  if (_tao_environment.exception () != 0) return;
  any = new CORBA::Any (CORBA::_tc_boolean, retval, CORBA::B_TRUE);
  req.result (any, _tao_environment);
}

CORBA::Boolean POA_PortableServer::POA::_is_a (
    const char* value,
    CORBA::Environment &_tao_environment
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/POA:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
      return CORBA::B_TRUE;
    else
      return CORBA::B_FALSE;
}

void* POA_PortableServer::POA::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/POA:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::POA_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::POA::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  CORBA::String opname = req.op_name (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
  }
else
  	skel (req, this, context, env);
}

const char* POA_PortableServer::POA::_interface_repository_id (void) const
{
  return "IDL:PortableServer/POA:1.0";
}

POA_PortableServer::_tao_collocated_POA::_tao_collocated_POA (
    POA_PortableServer::POA_ptr  servant,
    STUB_Object *stub
  )
  : ACE_NESTED_CLASS (PortableServer, POA) (stub, servant, CORBA::B_TRUE),
    CORBA_Object (stub, servant, CORBA::B_TRUE),
    servant_ (servant)
{
}

POA_PortableServer::POA_ptr POA_PortableServer::_tao_collocated_POA::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_POA::_is_a (
    const char* logical_type_id,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      _tao_environment
    );
}

PortableServer::POA_ptr POA_PortableServer::_tao_collocated_POA::create_POA (
    const char* adapter_name,
    PortableServer::POAManager_ptr  a_POAManager,
    const PortableServer::PolicyList & policies,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->create_POA (
      adapter_name,
      a_POAManager,
      policies,
       _tao_environment
    );
}

PortableServer::POA_ptr POA_PortableServer::_tao_collocated_POA::find_POA (
    const char* adapter_name,
    CORBA::Boolean activate_it,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->find_POA (
      adapter_name,
      activate_it,
       _tao_environment
    );
}

void POA_PortableServer::_tao_collocated_POA::destroy (
    CORBA::Boolean etherealize_objects,
    CORBA::Boolean wait_for_completion,
    CORBA::Environment &_tao_environment
  )
{
  this->servant_->destroy (
      etherealize_objects,
      wait_for_completion,
       _tao_environment
    );
}

PortableServer::ThreadPolicy_ptr POA_PortableServer::_tao_collocated_POA::create_thread_policy (
    PortableServer::ThreadPolicyValue value,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->create_thread_policy (
      value,
       _tao_environment
    );
}

PortableServer::LifespanPolicy_ptr POA_PortableServer::_tao_collocated_POA::create_lifespan_policy (
    PortableServer::LifespanPolicyValue value,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->create_lifespan_policy (
      value,
       _tao_environment
    );
}

PortableServer::IdUniquenessPolicy_ptr POA_PortableServer::_tao_collocated_POA::create_id_uniqueness_policy (
    PortableServer::IdUniquenessPolicyValue value,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->create_id_uniqueness_policy (
      value,
       _tao_environment
    );
}

PortableServer::IdAssignmentPolicy_ptr POA_PortableServer::_tao_collocated_POA::create_id_assignment_policy (
    PortableServer::IdAssignmentPolicyValue value,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->create_id_assignment_policy (
      value,
       _tao_environment
    );
}

PortableServer::ImplicitActivationPolicy_ptr POA_PortableServer::_tao_collocated_POA::create_implicit_activation_policy (
    PortableServer::ImplicitActivationPolicyValue value,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->create_implicit_activation_policy (
      value,
       _tao_environment
    );
}

PortableServer::ServantRetentionPolicy_ptr POA_PortableServer::_tao_collocated_POA::create_servant_retention_policy (
    PortableServer::ServantRetentionPolicyValue value,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->create_servant_retention_policy (
      value,
       _tao_environment
    );
}

PortableServer::RequestProcessingPolicy_ptr POA_PortableServer::_tao_collocated_POA::create_request_processing_policy (
    PortableServer::RequestProcessingPolicyValue value,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->create_request_processing_policy (
      value,
       _tao_environment
    );
}

char* 
POA_PortableServer::_tao_collocated_POA::the_name (
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->the_name(_tao_environment);
}
PortableServer::POA_ptr
POA_PortableServer::_tao_collocated_POA::the_parent (
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->the_parent(_tao_environment);
}
PortableServer::POAManager_ptr
POA_PortableServer::_tao_collocated_POA::the_POAManager (
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->the_POAManager(_tao_environment);
}
PortableServer::AdapterActivator_ptr
POA_PortableServer::_tao_collocated_POA::the_activator (
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->the_activator(_tao_environment);
}

void POA_PortableServer::_tao_collocated_POA::the_activator (
    PortableServer::AdapterActivator_ptr _tao_value,
    CORBA::Environment &_tao_environment
  )
{
  this->servant_->the_activator (
      _tao_value,
      _tao_environment
    );
}

PortableServer::ServantManager_ptr POA_PortableServer::_tao_collocated_POA::get_servant_manager (
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->get_servant_manager (
       _tao_environment
    );
}

void POA_PortableServer::_tao_collocated_POA::set_servant_manager (
    PortableServer::ServantManager_ptr  imgr,
    CORBA::Environment &_tao_environment
  )
{
  this->servant_->set_servant_manager (
      imgr,
       _tao_environment
    );
}

PortableServer::Servant POA_PortableServer::_tao_collocated_POA::get_servant (
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->get_servant (
       _tao_environment
    );
}

void POA_PortableServer::_tao_collocated_POA::set_servant (
    PortableServer::Servant p_servant,
    CORBA::Environment &_tao_environment
  )
{
  this->servant_->set_servant (
      p_servant,
       _tao_environment
    );
}

PortableServer::ObjectId * POA_PortableServer::_tao_collocated_POA::activate_object (
    PortableServer::Servant p_servant,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->activate_object (
      p_servant,
       _tao_environment
    );
}

void POA_PortableServer::_tao_collocated_POA::activate_object_with_id (
    const PortableServer::ObjectId & id,
    PortableServer::Servant p_servant,
    CORBA::Environment &_tao_environment
  )
{
  this->servant_->activate_object_with_id (
      id,
      p_servant,
       _tao_environment
    );
}

void POA_PortableServer::_tao_collocated_POA::deactivate_object (
    const PortableServer::ObjectId & oid,
    CORBA::Environment &_tao_environment
  )
{
  this->servant_->deactivate_object (
      oid,
       _tao_environment
    );
}

CORBA::Object_ptr POA_PortableServer::_tao_collocated_POA::create_reference (
    const char *intf,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->create_reference (
      intf,
       _tao_environment
    );
}

CORBA::Object_ptr POA_PortableServer::_tao_collocated_POA::create_reference_with_id (
    const PortableServer::ObjectId & oid,
    const char *intf,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->create_reference_with_id (
      oid,
      intf,
       _tao_environment
    );
}

PortableServer::ObjectId * POA_PortableServer::_tao_collocated_POA::servant_to_id (
    PortableServer::Servant p_servant,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->servant_to_id (
      p_servant,
       _tao_environment
    );
}

CORBA::Object_ptr POA_PortableServer::_tao_collocated_POA::servant_to_reference (
    PortableServer::Servant p_servant,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->servant_to_reference (
      p_servant,
       _tao_environment
    );
}

PortableServer::Servant POA_PortableServer::_tao_collocated_POA::reference_to_servant (
    CORBA::Object_ptr  reference,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->reference_to_servant (
      reference,
       _tao_environment
    );
}

PortableServer::ObjectId * POA_PortableServer::_tao_collocated_POA::reference_to_id (
    CORBA::Object_ptr  reference,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->reference_to_id (
      reference,
       _tao_environment
    );
}

PortableServer::Servant POA_PortableServer::_tao_collocated_POA::id_to_servant (
    const PortableServer::ObjectId & oid,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->id_to_servant (
      oid,
       _tao_environment
    );
}

CORBA::Object_ptr POA_PortableServer::_tao_collocated_POA::id_to_reference (
    const PortableServer::ObjectId & oid,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->id_to_reference (
      oid,
       _tao_environment
    );
}


PortableServer::POA*
POA_PortableServer::POA::_this (CORBA_Environment &_env)
{
  STUB_Object *stub = this->_create_stub (_env);
  if (_env.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_POA (this, stub);
}

static const TAO_operation_db_entry PortableServer_Current_operations [] = {
  {"get_POA", &POA_PortableServer::Current::get_POA_skel},
  {"get_object_id", &POA_PortableServer::Current::get_object_id_skel},
  {"_is_a", &POA_PortableServer::Current::_is_a_skel}
};

TAO_Dynamic_Hash_OpTable tao_PortableServer_Current_optable (PortableServer_Current_operations, 3, 6);
// skeleton constructor
POA_PortableServer::Current::Current (void)
{
  this->optable_ = &tao_PortableServer_Current_optable;
}

void POA_PortableServer::Current::get_POA_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  CORBA::NVList_ptr 	 nvlist;
  POA_PortableServer::Current_ptr 	 impl = (POA_PortableServer::Current_ptr) _tao_object_reference;
  CORBA::Any *result;
  CORBA::Object_ptr *retval = new CORBA::Object_ptr;
  *retval = CORBA::Object::_nil ();
    // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (0, nvlist); // initialize a list
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  *retval = impl->get_POA(_tao_environment);
  result = new CORBA::Any (PortableServer::_tc_POA, retval, 1); // ORB owns
  _tao_server_request.result (result, _tao_environment);
  
}

void POA_PortableServer::Current::get_object_id_skel (CORBA::ServerRequest &_tao_server_request, void *_tao_object_reference, void *context, CORBA::Environment &_tao_environment)
{
  ACE_UNUSED_ARG (context);
  CORBA::NVList_ptr 	 nvlist;
  POA_PortableServer::Current_ptr 	 impl = (POA_PortableServer::Current_ptr) _tao_object_reference;
  CORBA::Any *result;
  PortableServer::ObjectId *retval;
    // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (0, nvlist); // initialize a list
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  retval = impl->get_object_id(_tao_environment);
  result = new CORBA::Any (PortableServer::_tc_ObjectId, retval, 1); // ORB owns
  _tao_server_request.result (result, _tao_environment);
  
}

void POA_PortableServer::Current::_is_a_skel (
    CORBA::ServerRequest &req, 
    void * _tao_object_reference,
    void * /*context*/,
    CORBA::Environment &_tao_environment
  )
{
  CORBA::NVList_ptr nvlist;
  CORBA::NamedValue_ptr nv;
  CORBA::Any temp_value (CORBA::_tc_string);
  CORBA::Any *any;
  CORBA::Boolean *retval = new CORBA::Boolean;
  CORBA::String value;
  
  req.orb()->create_list (0, nvlist);
  nv = nvlist->add_value (0, temp_value, CORBA::ARG_IN, _tao_environment);
  req.params (nvlist, _tao_environment); // parse the args
  if (_tao_environment.exception () != 0) return;
  value = *(CORBA::String *)nv->value ()->value ();
  POA_PortableServer::Current_ptr 	 impl = (POA_PortableServer::Current_ptr) _tao_object_reference;
  *retval = impl->_is_a (value, _tao_environment);
  if (_tao_environment.exception () != 0) return;
  any = new CORBA::Any (CORBA::_tc_boolean, retval, CORBA::B_TRUE);
  req.result (any, _tao_environment);
}

CORBA::Boolean POA_PortableServer::Current::_is_a (
    const char* value,
    CORBA::Environment &_tao_environment
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Current:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/CurrentBase:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
      return CORBA::B_TRUE;
    else
      return CORBA::B_FALSE;
}

void* POA_PortableServer::Current::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/Current:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::Current_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/CurrentBase:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::CurrentBase_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::Current::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  CORBA::String opname = req.op_name (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
  }
else
  	skel (req, this, context, env);
}

const char* POA_PortableServer::Current::_interface_repository_id (void) const
{
  return "IDL:PortableServer/Current:1.0";
}

POA_PortableServer::_tao_collocated_Current::_tao_collocated_Current (
    POA_PortableServer::Current_ptr  servant,
    STUB_Object *stub
  )
  : ACE_NESTED_CLASS (PortableServer, Current) (stub, servant, CORBA::B_TRUE),
    _tao_collocated_CurrentBase (servant, stub),
    CORBA_Object (stub, servant, CORBA::B_TRUE),
    servant_ (servant)
{
}

POA_PortableServer::Current_ptr POA_PortableServer::_tao_collocated_Current::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_Current::_is_a (
    const char* logical_type_id,
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      _tao_environment
    );
}

PortableServer::POA_ptr POA_PortableServer::_tao_collocated_Current::get_POA (
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->get_POA (
       _tao_environment
    );
}

PortableServer::ObjectId * POA_PortableServer::_tao_collocated_Current::get_object_id (
    CORBA::Environment &_tao_environment
  )
{
  return this->servant_->get_object_id (
       _tao_environment
    );
}


PortableServer::Current*
POA_PortableServer::Current::_this (CORBA_Environment &_env)
{
  STUB_Object *stub = this->_create_stub (_env);
  if (_env.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_Current (this, stub);
}

