// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#ifndef _TAO_IDL_IFR_EXTENDEDC_H_
#define _TAO_IDL_IFR_EXTENDEDC_H_

#include "ace/pre.h"
#include "IFR_BasicC.h"

#if !defined (ACE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */

#if defined (TAO_EXPORT_MACRO)
#undef TAO_EXPORT_MACRO
#endif
#define TAO_EXPORT_MACRO TAO_IFR_Client_Export

#if defined (TAO_EXPORT_NESTED_CLASSES)
#  if defined (TAO_EXPORT_NESTED_MACRO)
#    undef TAO_EXPORT_NESTED_MACRO
#  endif /* defined (TAO_EXPORT_NESTED_MACRO) */
#  define TAO_EXPORT_NESTED_MACRO TAO_IFR_Client_Export
#endif /* TAO_EXPORT_NESTED_CLASSES */

#if defined(_MSC_VER)
#if (_MSC_VER >= 1200)
#pragma warning(push)
#endif /* _MSC_VER >= 1200 */
#pragma warning(disable:4250)
#endif /* _MSC_VER */

#if defined (__BORLANDC__)
#pragma option push -w-rvl -w-rch -w-ccc -w-inl
#endif /* __BORLANDC__ */

#if !defined (_CORBA_FIXEDDEF___PTR_CH_)
#define _CORBA_FIXEDDEF___PTR_CH_

class CORBA_FixedDef;
typedef CORBA_FixedDef *CORBA_FixedDef_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_FIXEDDEF___VAR_CH_)
#define _CORBA_FIXEDDEF___VAR_CH_

class TAO_IFR_Client_Export CORBA_FixedDef_var : public TAO_Base_var
{
public:
  CORBA_FixedDef_var (void); // default constructor
  CORBA_FixedDef_var (CORBA_FixedDef_ptr p) : ptr_ (p) {} 
  CORBA_FixedDef_var (const CORBA_FixedDef_var &); // copy constructor
  ~CORBA_FixedDef_var (void); // destructor
  
  CORBA_FixedDef_var &operator= (CORBA_FixedDef_ptr);
  CORBA_FixedDef_var &operator= (const CORBA_FixedDef_var &);
  CORBA_FixedDef_ptr operator-> (void) const;
  
  operator const CORBA_FixedDef_ptr &() const;
  operator CORBA_FixedDef_ptr &();
  // in, inout, out, _retn 
  CORBA_FixedDef_ptr in (void) const;
  CORBA_FixedDef_ptr &inout (void);
  CORBA_FixedDef_ptr &out (void);
  CORBA_FixedDef_ptr _retn (void);
  CORBA_FixedDef_ptr ptr (void) const;
  
  // Hooks used by template sequence and object manager classes
  // for non-defined forward declared interfaces.
  static CORBA_FixedDef_ptr duplicate (CORBA_FixedDef_ptr);
  static void release (CORBA_FixedDef_ptr);
  static CORBA_FixedDef_ptr nil (void);
  static CORBA_FixedDef_ptr narrow (CORBA::Object *, CORBA::Environment &);
  static CORBA::Object * upcast (void *);

private:
  CORBA_FixedDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  CORBA_FixedDef_var (const TAO_Base_var &rhs);
  CORBA_FixedDef_var &operator= (const TAO_Base_var &rhs);
};


#endif /* end #if !defined */


#if !defined (_CORBA_FIXEDDEF___OUT_CH_)
#define _CORBA_FIXEDDEF___OUT_CH_

class TAO_IFR_Client_Export CORBA_FixedDef_out
{
public:
  CORBA_FixedDef_out (CORBA_FixedDef_ptr &);
  CORBA_FixedDef_out (CORBA_FixedDef_var &);
  CORBA_FixedDef_out (const CORBA_FixedDef_out &);
  CORBA_FixedDef_out &operator= (const CORBA_FixedDef_out &);
  CORBA_FixedDef_out &operator= (const CORBA_FixedDef_var &);
  CORBA_FixedDef_out &operator= (CORBA_FixedDef_ptr);
  operator CORBA_FixedDef_ptr &();
  CORBA_FixedDef_ptr &ptr (void);
  CORBA_FixedDef_ptr operator-> (void);

private:
  CORBA_FixedDef_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_FIXEDDEF_CH_)
#define _CORBA_FIXEDDEF_CH_

// Forward Classes Declaration
class _TAO_CORBA_FixedDef_Proxy_Impl;
class _TAO_CORBA_FixedDef_Remote_Proxy_Impl;
class _TAO_CORBA_FixedDef_Proxy_Broker;
class _TAO_CORBA_FixedDef_Remote_Proxy_Broker;

class TAO_IFR_Client_Export CORBA_FixedDef: public virtual CORBA_IDLType
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_FixedDef_ptr _ptr_type;
  typedef CORBA_FixedDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static CORBA_FixedDef_ptr _duplicate (CORBA_FixedDef_ptr obj);
  static CORBA_FixedDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_FixedDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_FixedDef_ptr _nil (void)
    {
      return (CORBA_FixedDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::UShort digits (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void digits (
      CORBA::UShort digits,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Short scale (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void scale (
      CORBA::Short scale,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id, 
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);
  
  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_CORBA_FixedDef_Proxy_Broker *the_TAO_CORBA_FixedDef_Proxy_Broker_;
  
protected:
  CORBA_FixedDef (int collocated = 0);
  
  protected:
    // This methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode
    virtual void CORBA_FixedDef_setup_collocation (int collocated);
    
    CORBA_FixedDef (
      TAO_Stub *objref, 
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
      );
    
    friend class _TAO_CORBA_FixedDef_Remote_Proxy_Impl;
    friend class _TAO_CORBA_FixedDef_ThruPOA_Proxy_Impl;
    friend class _TAO_CORBA_FixedDef_Direct_Proxy_Impl;
  
  virtual ~CORBA_FixedDef (void);
private:
  CORBA_FixedDef (const CORBA_FixedDef &);
  void operator= (const CORBA_FixedDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_CORBA_FixedDef_Proxy_Impl : 
  public virtual _TAO_CORBA_IDLType_Proxy_Impl
{
public:
  virtual ~_TAO_CORBA_FixedDef_Proxy_Impl (void) { }
  
    virtual CORBA::UShort digits (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void digits (
      CORBA_Object *_collocated_tao_target_,
      CORBA::UShort digits,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::Short scale (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void scale (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Short scale,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_CORBA_FixedDef_Proxy_Impl (void);

};
//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_CORBA_FixedDef_Remote_Proxy_Impl : 
  public virtual _TAO_CORBA_FixedDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_CORBA_IDLType_Remote_Proxy_Impl
  
{
public:
  _TAO_CORBA_FixedDef_Remote_Proxy_Impl (void);
  
  virtual ~_TAO_CORBA_FixedDef_Remote_Proxy_Impl (void) { }
  
    virtual CORBA::UShort digits (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void digits (
      CORBA_Object *_collocated_tao_target_,
      CORBA::UShort digits,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Short scale (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void scale (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Short scale,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new 
// collocation scheme, the proxy to be used can vary on
// a call by call basis. 



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_CORBA_FixedDef_Proxy_Broker
{
public:
  virtual ~_TAO_CORBA_FixedDef_Proxy_Broker (void);
  virtual _TAO_CORBA_FixedDef_Proxy_Impl &select_proxy (
    CORBA_FixedDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_CORBA_FixedDef_Proxy_Broker (void);
  
};

//
//              End Base Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_CORBA_FixedDef_Remote_Proxy_Broker : public virtual _TAO_CORBA_FixedDef_Proxy_Broker
{
public: 
  _TAO_CORBA_FixedDef_Remote_Proxy_Broker (void);
  
  virtual ~_TAO_CORBA_FixedDef_Remote_Proxy_Broker (void);
  
  virtual _TAO_CORBA_FixedDef_Proxy_Impl &select_proxy (
    CORBA_FixedDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_CORBA_FixedDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_CORBA_FixedDef_Remote_Proxy_Broker *the_TAO_CORBA_FixedDef_Remote_Proxy_Broker (void);
};


//
//              End Remote Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */

struct CORBA_ValueMember;
class CORBA_ValueMember_var;

struct TAO_IFR_Client_Export CORBA_ValueMember
{

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_ValueMember_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static void _tao_any_destructor (void*);

  TAO_String_Manager name;
  TAO_String_Manager id;
  TAO_String_Manager defined_in;
  TAO_String_Manager version;
  CORBA::TypeCode_var type;
  CORBA_IDLType_var type_def;
  CORBA::Visibility access;
};

class TAO_IFR_Client_Export CORBA_ValueMember_var
{
public:
  CORBA_ValueMember_var (void); // default constructor
  CORBA_ValueMember_var (CORBA_ValueMember *);
  CORBA_ValueMember_var (const CORBA_ValueMember_var &); // copy constructor
  ~CORBA_ValueMember_var (void); // destructor
  
  CORBA_ValueMember_var &operator= (CORBA_ValueMember *);
  CORBA_ValueMember_var &operator= (const CORBA_ValueMember_var &);
  CORBA_ValueMember *operator-> (void);
  const CORBA_ValueMember *operator-> (void) const;
  
  operator const CORBA_ValueMember &() const;
  operator CORBA_ValueMember &();
  operator CORBA_ValueMember &() const;
  operator CORBA_ValueMember *&(); // variable-size types only
  
  // in, inout, out, _retn 
  const CORBA_ValueMember &in (void) const;
  CORBA_ValueMember &inout (void);
  CORBA_ValueMember *&out (void);
  CORBA_ValueMember *_retn (void);
  CORBA_ValueMember *ptr (void) const;

private:
  CORBA_ValueMember *ptr_;
};

class TAO_IFR_Client_Export CORBA_ValueMember_out
{
public:
  CORBA_ValueMember_out (CORBA_ValueMember *&);
  CORBA_ValueMember_out (CORBA_ValueMember_var &);
  CORBA_ValueMember_out (const CORBA_ValueMember_out &);
  CORBA_ValueMember_out &operator= (const CORBA_ValueMember_out &);
  CORBA_ValueMember_out &operator= (CORBA_ValueMember *);
  operator CORBA_ValueMember *&();
  CORBA_ValueMember *&ptr (void);
  CORBA_ValueMember *operator-> (void);
  
private:
  CORBA_ValueMember *&ptr_;
  // assignment from T_var not allowed
  void operator= (const CORBA_ValueMember_var &);
};


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_VALUEMEMBERSEQ_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_VALUEMEMBERSEQ_CH_

  class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.
    
    _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq (void); // Default constructor.
    _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq (CORBA::ULong maximum); 
    _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      CORBA_ValueMember *data,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq (const _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq &rhs);
    _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq &operator= (const _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq &rhs);
    virtual ~_TAO_Unbounded_Sequence_CORBA_ValueMemberSeq (void); // Dtor.
    // = Accessors.
    CORBA_ValueMember &operator[] (CORBA::ULong i);
    const CORBA_ValueMember &operator[] (CORBA::ULong i) const;
    // = Static operations.
    static CORBA_ValueMember *allocbuf (CORBA::ULong size);
    static void freebuf (CORBA_ValueMember *buffer);
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    // Implement the TAO_Base_Sequence methods (see Sequence.h)
    
    CORBA_ValueMember *get_buffer (CORBA::Boolean orphan = 0);
    const CORBA_ValueMember *get_buffer (void) const;
    void replace (CORBA::ULong max,
      CORBA::ULong length,
      CORBA_ValueMember *data,
      CORBA::Boolean release);
  };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_VALUEMEMBERSEQ_CH_)
#define _CORBA_VALUEMEMBERSEQ_CH_

class CORBA_ValueMemberSeq;
class CORBA_ValueMemberSeq_var;

// *************************************************************
// CORBA_ValueMemberSeq
// *************************************************************

class TAO_IFR_Client_Export CORBA_ValueMemberSeq : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_ValueMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
{
public:
  CORBA_ValueMemberSeq (void); // default ctor
  CORBA_ValueMemberSeq (CORBA::ULong max); // uses max size
  CORBA_ValueMemberSeq (
    CORBA::ULong max, 
    CORBA::ULong length, 
    CORBA_ValueMember *buffer, 
    CORBA::Boolean release = 0
  );
  CORBA_ValueMemberSeq (const CORBA_ValueMemberSeq &); // copy ctor
  ~CORBA_ValueMemberSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_ValueMemberSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

#endif /* end #if !defined */


#if !defined (_CORBA_VALUEMEMBERSEQ___VAR_CH_)
#define _CORBA_VALUEMEMBERSEQ___VAR_CH_

// *************************************************************
// class CORBA_ValueMemberSeq_var
// *************************************************************

class TAO_IFR_Client_Export CORBA_ValueMemberSeq_var
{
public:
  CORBA_ValueMemberSeq_var (void); // default constructor
  CORBA_ValueMemberSeq_var (CORBA_ValueMemberSeq *);
  CORBA_ValueMemberSeq_var (const CORBA_ValueMemberSeq_var &); // copy constructor
  ~CORBA_ValueMemberSeq_var (void); // destructor
  
  CORBA_ValueMemberSeq_var &operator= (CORBA_ValueMemberSeq *);
  CORBA_ValueMemberSeq_var &operator= (const CORBA_ValueMemberSeq_var &);
  CORBA_ValueMemberSeq *operator-> (void);
  const CORBA_ValueMemberSeq *operator-> (void) const;
  
  operator const CORBA_ValueMemberSeq &() const;
  operator CORBA_ValueMemberSeq &();
  operator CORBA_ValueMemberSeq &() const;
  operator CORBA_ValueMemberSeq *&(); // variable-size base types only
  
  CORBA_ValueMember & operator[] (CORBA::ULong index);
  const CORBA_ValueMember & operator[] (CORBA::ULong index) const;
  
  // in, inout, out, _retn 
  const CORBA_ValueMemberSeq &in (void) const;
  CORBA_ValueMemberSeq &inout (void);
  CORBA_ValueMemberSeq *&out (void);
  CORBA_ValueMemberSeq *_retn (void);
  CORBA_ValueMemberSeq *ptr (void) const;

private:
  CORBA_ValueMemberSeq *ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEMEMBERSEQ___OUT_CH_)
#define _CORBA_VALUEMEMBERSEQ___OUT_CH_

class TAO_IFR_Client_Export CORBA_ValueMemberSeq_out
{
public:
  CORBA_ValueMemberSeq_out (CORBA_ValueMemberSeq *&);
  CORBA_ValueMemberSeq_out (CORBA_ValueMemberSeq_var &);
  CORBA_ValueMemberSeq_out (const CORBA_ValueMemberSeq_out &);
  CORBA_ValueMemberSeq_out &operator= (const CORBA_ValueMemberSeq_out &);
  CORBA_ValueMemberSeq_out &operator= (CORBA_ValueMemberSeq *);
  operator CORBA_ValueMemberSeq *&();
  CORBA_ValueMemberSeq *&ptr (void);
  CORBA_ValueMemberSeq *operator-> (void);
  CORBA_ValueMember & operator[] (CORBA::ULong index);
  
private:
  CORBA_ValueMemberSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const CORBA_ValueMemberSeq_var &);
};


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEMEMBERDEF___PTR_CH_)
#define _CORBA_VALUEMEMBERDEF___PTR_CH_

class CORBA_ValueMemberDef;
typedef CORBA_ValueMemberDef *CORBA_ValueMemberDef_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_VALUEMEMBERDEF___VAR_CH_)
#define _CORBA_VALUEMEMBERDEF___VAR_CH_

class TAO_IFR_Client_Export CORBA_ValueMemberDef_var : public TAO_Base_var
{
public:
  CORBA_ValueMemberDef_var (void); // default constructor
  CORBA_ValueMemberDef_var (CORBA_ValueMemberDef_ptr p) : ptr_ (p) {} 
  CORBA_ValueMemberDef_var (const CORBA_ValueMemberDef_var &); // copy constructor
  ~CORBA_ValueMemberDef_var (void); // destructor
  
  CORBA_ValueMemberDef_var &operator= (CORBA_ValueMemberDef_ptr);
  CORBA_ValueMemberDef_var &operator= (const CORBA_ValueMemberDef_var &);
  CORBA_ValueMemberDef_ptr operator-> (void) const;
  
  operator const CORBA_ValueMemberDef_ptr &() const;
  operator CORBA_ValueMemberDef_ptr &();
  // in, inout, out, _retn 
  CORBA_ValueMemberDef_ptr in (void) const;
  CORBA_ValueMemberDef_ptr &inout (void);
  CORBA_ValueMemberDef_ptr &out (void);
  CORBA_ValueMemberDef_ptr _retn (void);
  CORBA_ValueMemberDef_ptr ptr (void) const;
  
  // Hooks used by template sequence and object manager classes
  // for non-defined forward declared interfaces.
  static CORBA_ValueMemberDef_ptr duplicate (CORBA_ValueMemberDef_ptr);
  static void release (CORBA_ValueMemberDef_ptr);
  static CORBA_ValueMemberDef_ptr nil (void);
  static CORBA_ValueMemberDef_ptr narrow (CORBA::Object *, CORBA::Environment &);
  static CORBA::Object * upcast (void *);

private:
  CORBA_ValueMemberDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  CORBA_ValueMemberDef_var (const TAO_Base_var &rhs);
  CORBA_ValueMemberDef_var &operator= (const TAO_Base_var &rhs);
};


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEMEMBERDEF___OUT_CH_)
#define _CORBA_VALUEMEMBERDEF___OUT_CH_

class TAO_IFR_Client_Export CORBA_ValueMemberDef_out
{
public:
  CORBA_ValueMemberDef_out (CORBA_ValueMemberDef_ptr &);
  CORBA_ValueMemberDef_out (CORBA_ValueMemberDef_var &);
  CORBA_ValueMemberDef_out (const CORBA_ValueMemberDef_out &);
  CORBA_ValueMemberDef_out &operator= (const CORBA_ValueMemberDef_out &);
  CORBA_ValueMemberDef_out &operator= (const CORBA_ValueMemberDef_var &);
  CORBA_ValueMemberDef_out &operator= (CORBA_ValueMemberDef_ptr);
  operator CORBA_ValueMemberDef_ptr &();
  CORBA_ValueMemberDef_ptr &ptr (void);
  CORBA_ValueMemberDef_ptr operator-> (void);

private:
  CORBA_ValueMemberDef_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEMEMBERDEF_CH_)
#define _CORBA_VALUEMEMBERDEF_CH_

// Forward Classes Declaration
class _TAO_CORBA_ValueMemberDef_Proxy_Impl;
class _TAO_CORBA_ValueMemberDef_Remote_Proxy_Impl;
class _TAO_CORBA_ValueMemberDef_Proxy_Broker;
class _TAO_CORBA_ValueMemberDef_Remote_Proxy_Broker;

class TAO_IFR_Client_Export CORBA_ValueMemberDef: public virtual CORBA_Contained
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_ValueMemberDef_ptr _ptr_type;
  typedef CORBA_ValueMemberDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static CORBA_ValueMemberDef_ptr _duplicate (CORBA_ValueMemberDef_ptr obj);
  static CORBA_ValueMemberDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_ValueMemberDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_ValueMemberDef_ptr _nil (void)
    {
      return (CORBA_ValueMemberDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::TypeCode_ptr type (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA_IDLType_ptr type_def (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void type_def (
      CORBA_IDLType_ptr type_def,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Visibility access (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void access (
      CORBA::Visibility access,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id, 
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);
  
  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_CORBA_ValueMemberDef_Proxy_Broker *the_TAO_CORBA_ValueMemberDef_Proxy_Broker_;
  
protected:
  CORBA_ValueMemberDef (int collocated = 0);
  
  protected:
    // This methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode
    virtual void CORBA_ValueMemberDef_setup_collocation (int collocated);
    
    CORBA_ValueMemberDef (
      TAO_Stub *objref, 
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
      );
    
    friend class _TAO_CORBA_ValueMemberDef_Remote_Proxy_Impl;
    friend class _TAO_CORBA_ValueMemberDef_ThruPOA_Proxy_Impl;
    friend class _TAO_CORBA_ValueMemberDef_Direct_Proxy_Impl;
  
  virtual ~CORBA_ValueMemberDef (void);
private:
  CORBA_ValueMemberDef (const CORBA_ValueMemberDef &);
  void operator= (const CORBA_ValueMemberDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_CORBA_ValueMemberDef_Proxy_Impl : 
  public virtual _TAO_CORBA_Contained_Proxy_Impl
{
public:
  virtual ~_TAO_CORBA_ValueMemberDef_Proxy_Impl (void) { }
  
    virtual CORBA::TypeCode_ptr type (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA_IDLType_ptr type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA_IDLType_ptr type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::Visibility access (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void access (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Visibility access,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_CORBA_ValueMemberDef_Proxy_Impl (void);

};
//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_CORBA_ValueMemberDef_Remote_Proxy_Impl : 
  public virtual _TAO_CORBA_ValueMemberDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_CORBA_Contained_Remote_Proxy_Impl
  
{
public:
  _TAO_CORBA_ValueMemberDef_Remote_Proxy_Impl (void);
  
  virtual ~_TAO_CORBA_ValueMemberDef_Remote_Proxy_Impl (void) { }
  
    virtual CORBA::TypeCode_ptr type (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA_IDLType_ptr type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA_IDLType_ptr type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Visibility access (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void access (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Visibility access,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new 
// collocation scheme, the proxy to be used can vary on
// a call by call basis. 



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_CORBA_ValueMemberDef_Proxy_Broker
{
public:
  virtual ~_TAO_CORBA_ValueMemberDef_Proxy_Broker (void);
  virtual _TAO_CORBA_ValueMemberDef_Proxy_Impl &select_proxy (
    CORBA_ValueMemberDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_CORBA_ValueMemberDef_Proxy_Broker (void);
  
};

//
//              End Base Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_CORBA_ValueMemberDef_Remote_Proxy_Broker : public virtual _TAO_CORBA_ValueMemberDef_Proxy_Broker
{
public: 
  _TAO_CORBA_ValueMemberDef_Remote_Proxy_Broker (void);
  
  virtual ~_TAO_CORBA_ValueMemberDef_Remote_Proxy_Broker (void);
  
  virtual _TAO_CORBA_ValueMemberDef_Proxy_Impl &select_proxy (
    CORBA_ValueMemberDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_CORBA_ValueMemberDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_CORBA_ValueMemberDef_Remote_Proxy_Broker *the_TAO_CORBA_ValueMemberDef_Remote_Proxy_Broker (void);
};


//
//              End Remote Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEDEF___PTR_CH_)
#define _CORBA_VALUEDEF___PTR_CH_

class CORBA_ValueDef;
typedef CORBA_ValueDef *CORBA_ValueDef_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_VALUEDEF___VAR_CH_)
#define _CORBA_VALUEDEF___VAR_CH_

class TAO_IFR_Client_Export CORBA_ValueDef_var : public TAO_Base_var
{
public:
  CORBA_ValueDef_var (void); // default constructor
  CORBA_ValueDef_var (CORBA_ValueDef_ptr p) : ptr_ (p) {} 
  CORBA_ValueDef_var (const CORBA_ValueDef_var &); // copy constructor
  ~CORBA_ValueDef_var (void); // destructor
  
  CORBA_ValueDef_var &operator= (CORBA_ValueDef_ptr);
  CORBA_ValueDef_var &operator= (const CORBA_ValueDef_var &);
  CORBA_ValueDef_ptr operator-> (void) const;
  
  operator const CORBA_ValueDef_ptr &() const;
  operator CORBA_ValueDef_ptr &();
  // in, inout, out, _retn 
  CORBA_ValueDef_ptr in (void) const;
  CORBA_ValueDef_ptr &inout (void);
  CORBA_ValueDef_ptr &out (void);
  CORBA_ValueDef_ptr _retn (void);
  CORBA_ValueDef_ptr ptr (void) const;
  
  // Hooks used by template sequence and object manager classes
  // for non-defined forward declared interfaces.
  static CORBA_ValueDef_ptr duplicate (CORBA_ValueDef_ptr);
  static void release (CORBA_ValueDef_ptr);
  static CORBA_ValueDef_ptr nil (void);
  static CORBA_ValueDef_ptr narrow (CORBA::Object *, CORBA::Environment &);
  static CORBA::Object * upcast (void *);

private:
  CORBA_ValueDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  CORBA_ValueDef_var (const TAO_Base_var &rhs);
  CORBA_ValueDef_var &operator= (const TAO_Base_var &rhs);
};


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEDEF___OUT_CH_)
#define _CORBA_VALUEDEF___OUT_CH_

class TAO_IFR_Client_Export CORBA_ValueDef_out
{
public:
  CORBA_ValueDef_out (CORBA_ValueDef_ptr &);
  CORBA_ValueDef_out (CORBA_ValueDef_var &);
  CORBA_ValueDef_out (const CORBA_ValueDef_out &);
  CORBA_ValueDef_out &operator= (const CORBA_ValueDef_out &);
  CORBA_ValueDef_out &operator= (const CORBA_ValueDef_var &);
  CORBA_ValueDef_out &operator= (CORBA_ValueDef_ptr);
  operator CORBA_ValueDef_ptr &();
  CORBA_ValueDef_ptr &ptr (void);
  CORBA_ValueDef_ptr operator-> (void);

private:
  CORBA_ValueDef_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEDEF_CH_)
#define _CORBA_VALUEDEF_CH_

// Forward Classes Declaration
class _TAO_CORBA_ValueDef_Proxy_Impl;
class _TAO_CORBA_ValueDef_Remote_Proxy_Impl;
class _TAO_CORBA_ValueDef_Proxy_Broker;
class _TAO_CORBA_ValueDef_Remote_Proxy_Broker;

class TAO_IFR_Client_Export CORBA_ValueDef: public virtual CORBA_Container, public virtual CORBA_Contained, public virtual CORBA_IDLType
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_ValueDef_ptr _ptr_type;
  typedef CORBA_ValueDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static CORBA_ValueDef_ptr _duplicate (CORBA_ValueDef_ptr obj);
  static CORBA_ValueDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_ValueDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_ValueDef_ptr _nil (void)
    {
      return (CORBA_ValueDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA_InterfaceDefSeq * supported_interfaces (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void supported_interfaces (
      const CORBA_InterfaceDefSeq & supported_interfaces,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA_InitializerSeq * initializers (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void initializers (
      const CORBA_InitializerSeq & initializers,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA_ValueDef_ptr base_value (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void base_value (
      CORBA_ValueDef_ptr base_value,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA_ValueDefSeq * abstract_base_values (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void abstract_base_values (
      const CORBA_ValueDefSeq & abstract_base_values,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean is_abstract (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void is_abstract (
      CORBA::Boolean is_abstract,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean is_custom (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void is_custom (
      CORBA::Boolean is_custom,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean is_truncatable (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void is_truncatable (
      CORBA::Boolean is_truncatable,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  struct FullValueDescription;
  class FullValueDescription_var;
  
  struct TAO_IFR_Client_Export FullValueDescription
  {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef FullValueDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

    static void _tao_any_destructor (void*);

    TAO_String_Manager name;
    TAO_String_Manager id;
    CORBA::Boolean is_abstract;
    CORBA::Boolean is_custom;
    TAO_String_Manager defined_in;
    TAO_String_Manager version;
    CORBA_OpDescriptionSeq operations;
    CORBA_AttrDescriptionSeq attributes;
    CORBA_ValueMemberSeq members;
    CORBA_InitializerSeq initializers;
    CORBA_RepositoryIdSeq supported_interfaces;
    CORBA_RepositoryIdSeq abstract_base_values;
    CORBA::Boolean is_truncatable;
    TAO_String_Manager base_value;
    CORBA::TypeCode_var type;
  };

  class TAO_IFR_Client_Export FullValueDescription_var
  {
  public:
    FullValueDescription_var (void); // default constructor
    FullValueDescription_var (FullValueDescription *);
    FullValueDescription_var (const FullValueDescription_var &); // copy constructor
    ~FullValueDescription_var (void); // destructor
    
    FullValueDescription_var &operator= (FullValueDescription *);
    FullValueDescription_var &operator= (const FullValueDescription_var &);
    FullValueDescription *operator-> (void);
    const FullValueDescription *operator-> (void) const;
    
    operator const FullValueDescription &() const;
    operator FullValueDescription &();
    operator FullValueDescription &() const;
    operator FullValueDescription *&(); // variable-size types only
    
    // in, inout, out, _retn 
    const FullValueDescription &in (void) const;
    FullValueDescription &inout (void);
    FullValueDescription *&out (void);
    FullValueDescription *_retn (void);
    FullValueDescription *ptr (void) const;

  private:
    FullValueDescription *ptr_;
  };

  class TAO_IFR_Client_Export FullValueDescription_out
  {
  public:
    FullValueDescription_out (FullValueDescription *&);
    FullValueDescription_out (FullValueDescription_var &);
    FullValueDescription_out (const FullValueDescription_out &);
    FullValueDescription_out &operator= (const FullValueDescription_out &);
    FullValueDescription_out &operator= (FullValueDescription *);
    operator FullValueDescription *&();
    FullValueDescription *&ptr (void);
    FullValueDescription *operator-> (void);
    
  private:
    FullValueDescription *&ptr_;
    // assignment from T_var not allowed
    void operator= (const FullValueDescription_var &);
  };

  static CORBA::TypeCode_ptr _tc_FullValueDescription;

  virtual CORBA_ValueDef::FullValueDescription * describe_value (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA_ValueMemberDef_ptr create_value_member (
      const char * id,
      const char * name,
      const char * version,
      CORBA_IDLType_ptr type,
      CORBA::Visibility access,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA_AttributeDef_ptr create_attribute (
      const char * id,
      const char * name,
      const char * version,
      CORBA_IDLType_ptr type,
      CORBA::AttributeMode mode,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA_OperationDef_ptr create_operation (
      const char * id,
      const char * name,
      const char * version,
      CORBA_IDLType_ptr result,
      CORBA::OperationMode mode,
      const CORBA_ParDescriptionSeq & params,
      const CORBA_ExceptionDefSeq & exceptions,
      const CORBA_ContextIdSeq & contexts,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id, 
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);
  
  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_CORBA_ValueDef_Proxy_Broker *the_TAO_CORBA_ValueDef_Proxy_Broker_;
  
protected:
  CORBA_ValueDef (int collocated = 0);
  
  protected:
    // This methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode
    virtual void CORBA_ValueDef_setup_collocation (int collocated);
    
    CORBA_ValueDef (
      TAO_Stub *objref, 
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
      );
    
    friend class _TAO_CORBA_ValueDef_Remote_Proxy_Impl;
    friend class _TAO_CORBA_ValueDef_ThruPOA_Proxy_Impl;
    friend class _TAO_CORBA_ValueDef_Direct_Proxy_Impl;
  
  virtual ~CORBA_ValueDef (void);
private:
  CORBA_ValueDef (const CORBA_ValueDef &);
  void operator= (const CORBA_ValueDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_CORBA_ValueDef_Proxy_Impl : 
  public virtual _TAO_CORBA_Container_Proxy_Impl, 
  public virtual _TAO_CORBA_Contained_Proxy_Impl, 
  public virtual _TAO_CORBA_IDLType_Proxy_Impl
{
public:
  virtual ~_TAO_CORBA_ValueDef_Proxy_Impl (void) { }
  
    virtual CORBA_InterfaceDefSeq * supported_interfaces (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void supported_interfaces (
      CORBA_Object *_collocated_tao_target_,
      const CORBA_InterfaceDefSeq & supported_interfaces,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA_InitializerSeq * initializers (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void initializers (
      CORBA_Object *_collocated_tao_target_,
      const CORBA_InitializerSeq & initializers,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA_ValueDef_ptr base_value (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void base_value (
      CORBA_Object *_collocated_tao_target_,
      CORBA_ValueDef_ptr base_value,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA_ValueDefSeq * abstract_base_values (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void abstract_base_values (
      CORBA_Object *_collocated_tao_target_,
      const CORBA_ValueDefSeq & abstract_base_values,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::Boolean is_abstract (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void is_abstract (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Boolean is_abstract,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::Boolean is_custom (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void is_custom (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Boolean is_custom,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::Boolean is_truncatable (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void is_truncatable (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Boolean is_truncatable,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::Boolean is_a (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA_ValueDef::FullValueDescription * describe_value (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA_ValueMemberDef_ptr create_value_member (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      CORBA_IDLType_ptr type,
      CORBA::Visibility access,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA_AttributeDef_ptr create_attribute (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      CORBA_IDLType_ptr type,
      CORBA::AttributeMode mode,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA_OperationDef_ptr create_operation (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      CORBA_IDLType_ptr result,
      CORBA::OperationMode mode,
      const CORBA_ParDescriptionSeq & params,
      const CORBA_ExceptionDefSeq & exceptions,
      const CORBA_ContextIdSeq & contexts,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_CORBA_ValueDef_Proxy_Impl (void);

};
//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_CORBA_ValueDef_Remote_Proxy_Impl : 
  public virtual _TAO_CORBA_ValueDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_CORBA_Container_Remote_Proxy_Impl, 
  public virtual _TAO_CORBA_Contained_Remote_Proxy_Impl, 
  public virtual _TAO_CORBA_IDLType_Remote_Proxy_Impl
  
{
public:
  _TAO_CORBA_ValueDef_Remote_Proxy_Impl (void);
  
  virtual ~_TAO_CORBA_ValueDef_Remote_Proxy_Impl (void) { }
  
    virtual CORBA_InterfaceDefSeq * supported_interfaces (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void supported_interfaces (
      CORBA_Object *_collocated_tao_target_,
      const CORBA_InterfaceDefSeq & supported_interfaces,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA_InitializerSeq * initializers (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void initializers (
      CORBA_Object *_collocated_tao_target_,
      const CORBA_InitializerSeq & initializers,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA_ValueDef_ptr base_value (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void base_value (
      CORBA_Object *_collocated_tao_target_,
      CORBA_ValueDef_ptr base_value,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA_ValueDefSeq * abstract_base_values (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void abstract_base_values (
      CORBA_Object *_collocated_tao_target_,
      const CORBA_ValueDefSeq & abstract_base_values,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean is_abstract (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void is_abstract (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Boolean is_abstract,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean is_custom (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void is_custom (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Boolean is_custom,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean is_truncatable (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void is_truncatable (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Boolean is_truncatable,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean is_a (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA_ValueDef::FullValueDescription * describe_value (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA_ValueMemberDef_ptr create_value_member (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      CORBA_IDLType_ptr type,
      CORBA::Visibility access,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA_AttributeDef_ptr create_attribute (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      CORBA_IDLType_ptr type,
      CORBA::AttributeMode mode,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA_OperationDef_ptr create_operation (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      CORBA_IDLType_ptr result,
      CORBA::OperationMode mode,
      const CORBA_ParDescriptionSeq & params,
      const CORBA_ExceptionDefSeq & exceptions,
      const CORBA_ContextIdSeq & contexts,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new 
// collocation scheme, the proxy to be used can vary on
// a call by call basis. 



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_CORBA_ValueDef_Proxy_Broker
{
public:
  virtual ~_TAO_CORBA_ValueDef_Proxy_Broker (void);
  virtual _TAO_CORBA_ValueDef_Proxy_Impl &select_proxy (
    CORBA_ValueDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_CORBA_ValueDef_Proxy_Broker (void);
  
};

//
//              End Base Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_CORBA_ValueDef_Remote_Proxy_Broker : public virtual _TAO_CORBA_ValueDef_Proxy_Broker
{
public: 
  _TAO_CORBA_ValueDef_Remote_Proxy_Broker (void);
  
  virtual ~_TAO_CORBA_ValueDef_Remote_Proxy_Broker (void);
  
  virtual _TAO_CORBA_ValueDef_Proxy_Impl &select_proxy (
    CORBA_ValueDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_CORBA_ValueDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_CORBA_ValueDef_Remote_Proxy_Broker *the_TAO_CORBA_ValueDef_Remote_Proxy_Broker (void);
};


//
//              End Remote Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */

struct CORBA_ValueDescription;
class CORBA_ValueDescription_var;

struct TAO_IFR_Client_Export CORBA_ValueDescription
{

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_ValueDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static void _tao_any_destructor (void*);

  TAO_String_Manager name;
  TAO_String_Manager id;
  CORBA::Boolean is_abstract;
  CORBA::Boolean is_custom;
  TAO_String_Manager defined_in;
  TAO_String_Manager version;
  CORBA_RepositoryIdSeq supported_interfaces;
  CORBA_RepositoryIdSeq abstract_base_values;
  CORBA::Boolean is_truncatable;
  TAO_String_Manager base_value;
};

class TAO_IFR_Client_Export CORBA_ValueDescription_var
{
public:
  CORBA_ValueDescription_var (void); // default constructor
  CORBA_ValueDescription_var (CORBA_ValueDescription *);
  CORBA_ValueDescription_var (const CORBA_ValueDescription_var &); // copy constructor
  ~CORBA_ValueDescription_var (void); // destructor
  
  CORBA_ValueDescription_var &operator= (CORBA_ValueDescription *);
  CORBA_ValueDescription_var &operator= (const CORBA_ValueDescription_var &);
  CORBA_ValueDescription *operator-> (void);
  const CORBA_ValueDescription *operator-> (void) const;
  
  operator const CORBA_ValueDescription &() const;
  operator CORBA_ValueDescription &();
  operator CORBA_ValueDescription &() const;
  operator CORBA_ValueDescription *&(); // variable-size types only
  
  // in, inout, out, _retn 
  const CORBA_ValueDescription &in (void) const;
  CORBA_ValueDescription &inout (void);
  CORBA_ValueDescription *&out (void);
  CORBA_ValueDescription *_retn (void);
  CORBA_ValueDescription *ptr (void) const;

private:
  CORBA_ValueDescription *ptr_;
};

class TAO_IFR_Client_Export CORBA_ValueDescription_out
{
public:
  CORBA_ValueDescription_out (CORBA_ValueDescription *&);
  CORBA_ValueDescription_out (CORBA_ValueDescription_var &);
  CORBA_ValueDescription_out (const CORBA_ValueDescription_out &);
  CORBA_ValueDescription_out &operator= (const CORBA_ValueDescription_out &);
  CORBA_ValueDescription_out &operator= (CORBA_ValueDescription *);
  operator CORBA_ValueDescription *&();
  CORBA_ValueDescription *&ptr (void);
  CORBA_ValueDescription *operator-> (void);
  
private:
  CORBA_ValueDescription *&ptr_;
  // assignment from T_var not allowed
  void operator= (const CORBA_ValueDescription_var &);
};


#if !defined (_CORBA_VALUEBOXDEF___PTR_CH_)
#define _CORBA_VALUEBOXDEF___PTR_CH_

class CORBA_ValueBoxDef;
typedef CORBA_ValueBoxDef *CORBA_ValueBoxDef_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_VALUEBOXDEF___VAR_CH_)
#define _CORBA_VALUEBOXDEF___VAR_CH_

class TAO_IFR_Client_Export CORBA_ValueBoxDef_var : public TAO_Base_var
{
public:
  CORBA_ValueBoxDef_var (void); // default constructor
  CORBA_ValueBoxDef_var (CORBA_ValueBoxDef_ptr p) : ptr_ (p) {} 
  CORBA_ValueBoxDef_var (const CORBA_ValueBoxDef_var &); // copy constructor
  ~CORBA_ValueBoxDef_var (void); // destructor
  
  CORBA_ValueBoxDef_var &operator= (CORBA_ValueBoxDef_ptr);
  CORBA_ValueBoxDef_var &operator= (const CORBA_ValueBoxDef_var &);
  CORBA_ValueBoxDef_ptr operator-> (void) const;
  
  operator const CORBA_ValueBoxDef_ptr &() const;
  operator CORBA_ValueBoxDef_ptr &();
  // in, inout, out, _retn 
  CORBA_ValueBoxDef_ptr in (void) const;
  CORBA_ValueBoxDef_ptr &inout (void);
  CORBA_ValueBoxDef_ptr &out (void);
  CORBA_ValueBoxDef_ptr _retn (void);
  CORBA_ValueBoxDef_ptr ptr (void) const;
  
  // Hooks used by template sequence and object manager classes
  // for non-defined forward declared interfaces.
  static CORBA_ValueBoxDef_ptr duplicate (CORBA_ValueBoxDef_ptr);
  static void release (CORBA_ValueBoxDef_ptr);
  static CORBA_ValueBoxDef_ptr nil (void);
  static CORBA_ValueBoxDef_ptr narrow (CORBA::Object *, CORBA::Environment &);
  static CORBA::Object * upcast (void *);

private:
  CORBA_ValueBoxDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  CORBA_ValueBoxDef_var (const TAO_Base_var &rhs);
  CORBA_ValueBoxDef_var &operator= (const TAO_Base_var &rhs);
};


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEBOXDEF___OUT_CH_)
#define _CORBA_VALUEBOXDEF___OUT_CH_

class TAO_IFR_Client_Export CORBA_ValueBoxDef_out
{
public:
  CORBA_ValueBoxDef_out (CORBA_ValueBoxDef_ptr &);
  CORBA_ValueBoxDef_out (CORBA_ValueBoxDef_var &);
  CORBA_ValueBoxDef_out (const CORBA_ValueBoxDef_out &);
  CORBA_ValueBoxDef_out &operator= (const CORBA_ValueBoxDef_out &);
  CORBA_ValueBoxDef_out &operator= (const CORBA_ValueBoxDef_var &);
  CORBA_ValueBoxDef_out &operator= (CORBA_ValueBoxDef_ptr);
  operator CORBA_ValueBoxDef_ptr &();
  CORBA_ValueBoxDef_ptr &ptr (void);
  CORBA_ValueBoxDef_ptr operator-> (void);

private:
  CORBA_ValueBoxDef_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEBOXDEF_CH_)
#define _CORBA_VALUEBOXDEF_CH_

// Forward Classes Declaration
class _TAO_CORBA_ValueBoxDef_Proxy_Impl;
class _TAO_CORBA_ValueBoxDef_Remote_Proxy_Impl;
class _TAO_CORBA_ValueBoxDef_Proxy_Broker;
class _TAO_CORBA_ValueBoxDef_Remote_Proxy_Broker;

class TAO_IFR_Client_Export CORBA_ValueBoxDef: public virtual CORBA_TypedefDef
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_ValueBoxDef_ptr _ptr_type;
  typedef CORBA_ValueBoxDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static CORBA_ValueBoxDef_ptr _duplicate (CORBA_ValueBoxDef_ptr obj);
  static CORBA_ValueBoxDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_ValueBoxDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_ValueBoxDef_ptr _nil (void)
    {
      return (CORBA_ValueBoxDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA_IDLType_ptr original_type_def (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void original_type_def (
      CORBA_IDLType_ptr original_type_def,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id, 
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);
  
  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_CORBA_ValueBoxDef_Proxy_Broker *the_TAO_CORBA_ValueBoxDef_Proxy_Broker_;
  
protected:
  CORBA_ValueBoxDef (int collocated = 0);
  
  protected:
    // This methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode
    virtual void CORBA_ValueBoxDef_setup_collocation (int collocated);
    
    CORBA_ValueBoxDef (
      TAO_Stub *objref, 
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
      );
    
    friend class _TAO_CORBA_ValueBoxDef_Remote_Proxy_Impl;
    friend class _TAO_CORBA_ValueBoxDef_ThruPOA_Proxy_Impl;
    friend class _TAO_CORBA_ValueBoxDef_Direct_Proxy_Impl;
  
  virtual ~CORBA_ValueBoxDef (void);
private:
  CORBA_ValueBoxDef (const CORBA_ValueBoxDef &);
  void operator= (const CORBA_ValueBoxDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_CORBA_ValueBoxDef_Proxy_Impl : 
  public virtual _TAO_CORBA_TypedefDef_Proxy_Impl
{
public:
  virtual ~_TAO_CORBA_ValueBoxDef_Proxy_Impl (void) { }
  
    virtual CORBA_IDLType_ptr original_type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void original_type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA_IDLType_ptr original_type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_CORBA_ValueBoxDef_Proxy_Impl (void);

};
//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_CORBA_ValueBoxDef_Remote_Proxy_Impl : 
  public virtual _TAO_CORBA_ValueBoxDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_CORBA_TypedefDef_Remote_Proxy_Impl
  
{
public:
  _TAO_CORBA_ValueBoxDef_Remote_Proxy_Impl (void);
  
  virtual ~_TAO_CORBA_ValueBoxDef_Remote_Proxy_Impl (void) { }
  
    virtual CORBA_IDLType_ptr original_type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void original_type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA_IDLType_ptr original_type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new 
// collocation scheme, the proxy to be used can vary on
// a call by call basis. 



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_CORBA_ValueBoxDef_Proxy_Broker
{
public:
  virtual ~_TAO_CORBA_ValueBoxDef_Proxy_Broker (void);
  virtual _TAO_CORBA_ValueBoxDef_Proxy_Impl &select_proxy (
    CORBA_ValueBoxDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_CORBA_ValueBoxDef_Proxy_Broker (void);
  
};

//
//              End Base Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_CORBA_ValueBoxDef_Remote_Proxy_Broker : public virtual _TAO_CORBA_ValueBoxDef_Proxy_Broker
{
public: 
  _TAO_CORBA_ValueBoxDef_Remote_Proxy_Broker (void);
  
  virtual ~_TAO_CORBA_ValueBoxDef_Remote_Proxy_Broker (void);
  
  virtual _TAO_CORBA_ValueBoxDef_Proxy_Impl &select_proxy (
    CORBA_ValueBoxDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_CORBA_ValueBoxDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_CORBA_ValueBoxDef_Remote_Proxy_Broker *the_TAO_CORBA_ValueBoxDef_Remote_Proxy_Broker (void);
};


//
//              End Remote Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */

// Proxy Broker Factory function pointer declarations.

extern TAO_IFR_Client_Export
_TAO_CORBA_FixedDef_Proxy_Broker *
(*_TAO_CORBA_FixedDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export
_TAO_CORBA_ValueMemberDef_Proxy_Broker *
(*_TAO_CORBA_ValueMemberDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export
_TAO_CORBA_ValueDef_Proxy_Broker *
(*_TAO_CORBA_ValueDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export
_TAO_CORBA_ValueBoxDef_Proxy_Broker *
(*_TAO_CORBA_ValueBoxDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

// Any operators for interface CORBA_FixedDef
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_FixedDef_ptr);
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_FixedDef *&);
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA_ValueMember &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_ValueMember*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_ValueMember *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA_ValueMember *&);
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA_ValueMemberSeq &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_ValueMemberSeq*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_ValueMemberSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA_ValueMemberSeq *&);
// Any operators for interface CORBA_ValueMemberDef
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_ValueMemberDef_ptr);
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_ValueMemberDef *&);
// Any operators for interface CORBA_ValueDef
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_ValueDef_ptr);
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_ValueDef *&);
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA_ValueDef::FullValueDescription &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_ValueDef::FullValueDescription*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_ValueDef::FullValueDescription *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA_ValueDef::FullValueDescription *&);
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA_ValueDescription &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_ValueDescription*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_ValueDescription *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA_ValueDescription *&);
// Any operators for interface CORBA_ValueBoxDef
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_ValueBoxDef_ptr);
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_ValueBoxDef *&);

#ifndef __ACE_INLINE__

TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_FixedDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_FixedDef_ptr &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_ValueMember &);
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_ValueMember &);

#if !defined _TAO_CDR_OP_CORBA_ValueMemberSeq_H_
#define _TAO_CDR_OP_CORBA_ValueMemberSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const CORBA_ValueMemberSeq &
  );
TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CORBA_ValueMemberSeq &
  );

#endif /* _TAO_CDR_OP_CORBA_ValueMemberSeq_H_ */

TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_ValueMemberDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_ValueMemberDef_ptr &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_ValueDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_ValueDef_ptr &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_ValueDef::FullValueDescription &);
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_ValueDef::FullValueDescription &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_ValueDescription &);
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_ValueDescription &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_ValueBoxDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_ValueBoxDef_ptr &);

#endif /* __ACE_INLINE__ */


#if defined (__ACE_INLINE__)
#include "IFR_ExtendedC.i"
#endif /* defined INLINE */

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(pop)
#endif /* _MSC_VER */

#if defined (__BORLANDC__)
#pragma option pop
#endif /* __BORLANDC__ */

#include "ace/post.h"
#endif /* ifndef */
