// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#ifndef _TAO_IDL__________ORBSVCS_IFR_SERVICE_ORIG_IFR_BASES_CPP_
#define _TAO_IDL__________ORBSVCS_IFR_SERVICE_ORIG_IFR_BASES_CPP_

#include "IFR_BaseS.h"

#include "tao/PortableServer/Object_Adapter.h"
#include "tao/PortableServer/Operation_Table.h"
#include "tao/TAO_Server_Request.h"
#include "tao/ORB_Core.h"
#include "tao/Stub.h"
#include "tao/IFR_Client_Adapter.h"
#include "tao/PortableServer/ServerRequestInfo.h"
#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */

#include "ace/Dynamic_Service.h"

#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "IFR_BaseS.i"
#endif /* !defined INLINE */

class TAO_CORBA_IRObject_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 12:14:19 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_IRObject_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_IRObject_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  0, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  0, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_IRObject_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 5,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 0
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_CORBA_IRObject::_is_a_skel},
      {"",0},
      {"destroy", 	&POA_CORBA_IRObject::destroy_skel},
      {"",0},{"",0},
      {"_interface",  &POA_CORBA_IRObject::_interface_skel},
      {"",0},{"",0},
      {"_get_def_kind", 	&POA_CORBA_IRObject::_get_def_kind_skel},
      {"",0},{"",0},{"",0},{"",0},
      {"_non_existent",  &POA_CORBA_IRObject::_non_existent_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 12:14:19 */
static TAO_CORBA_IRObject_Perfect_Hash_OpTable tao_CORBA_IRObject_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_IRObject *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::DefinitionKind result);

private:
  TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get (const TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get &);
  
private:
  POA_CORBA_IRObject *_tao_impl;
  CORBA::DefinitionKind _result;
};

TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get::TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_IRObject *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get::result (CORBA::DefinitionKind result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_IRObject_destroy : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_IRObject_destroy (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_IRObject *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_CORBA_IRObject_destroy (const TAO_ServerRequestInfo_CORBA_IRObject_destroy &);
  void operator= (const TAO_ServerRequestInfo_CORBA_IRObject_destroy &);
  
private:
  POA_CORBA_IRObject *_tao_impl;
  
};

TAO_ServerRequestInfo_CORBA_IRObject_destroy::TAO_ServerRequestInfo_CORBA_IRObject_destroy (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_IRObject *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_IRObject_destroy::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_IRObject_destroy::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_IRObject_destroy::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_IRObject_destroy::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_IRObject_destroy::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
_TAO_CORBA_IRObject_Strategized_Proxy_Broker *_TAO_CORBA_IRObject_Strategized_Proxy_Broker::the_TAO_CORBA_IRObject_Strategized_Proxy_Broker (void)
{
  static _TAO_CORBA_IRObject_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_CORBA_IRObject_Strategized_Proxy_Broker::_TAO_CORBA_IRObject_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

_TAO_CORBA_IRObject_Strategized_Proxy_Broker::~_TAO_CORBA_IRObject_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_CORBA_IRObject_Proxy_Impl&
_TAO_CORBA_IRObject_Strategized_Proxy_Broker::select_proxy (
    ::CORBA_IRObject *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
_TAO_CORBA_IRObject_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_CORBA_IRObject_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_CORBA_IRObject_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_CORBA_IRObject_Proxy_Broker *
_TAO_CORBA_IRObject_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::_TAO_CORBA_IRObject_Strategized_Proxy_Broker::the_TAO_CORBA_IRObject_Strategized_Proxy_Broker();
}

int
_TAO_CORBA_IRObject_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_CORBA_IRObject_Proxy_Broker_Factory_function_pointer = 
    _TAO_CORBA_IRObject_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_CORBA_IRObject_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_CORBA_IRObject_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_CORBA_IRObject_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

_TAO_CORBA_IRObject_ThruPOA_Proxy_Impl::_TAO_CORBA_IRObject_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::DefinitionKind _TAO_CORBA_IRObject_ThruPOA_Proxy_Impl::def_kind (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::DefinitionKind _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "def_kind",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_CORBA_IRObject_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA_IRObject:1.0"
        )
    )->def_kind (
        ACE_TRY_ENV
      );
}

void _TAO_CORBA_IRObject_ThruPOA_Proxy_Impl::destroy (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "destroy",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_IRObject_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA_IRObject:1.0"
        )
    )->destroy (
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA_IRObject::POA_CORBA_IRObject (void)
{
  this->optable_ = &tao_CORBA_IRObject_optable;
}

// copy ctor
POA_CORBA_IRObject::POA_CORBA_IRObject (const POA_CORBA_IRObject& rhs)
  :   TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA_IRObject::~POA_CORBA_IRObject (void)
{
}

void POA_CORBA_IRObject::_get_def_kind_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA_IRObject *_tao_impl = (POA_CORBA_IRObject *)_tao_object_reference;
  
    CORBA::DefinitionKind _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->def_kind (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::DefinitionKind _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval)
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_IRObject::destroy_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA_IRObject *_tao_impl = (POA_CORBA_IRObject *)_tao_object_reference;
  
  _tao_server_request.argument_flag (0);
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_IRObject_destroy ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      _tao_impl->destroy (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_IRObject::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_IRObject *_tao_impl = (POA_CORBA_IRObject *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_IRObject::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA_IRObject *_tao_impl = (POA_CORBA_IRObject *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_IRObject::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA_IRObject *_tao_impl = (POA_CORBA_IRObject *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_CORBA_IRObject::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA_IRObject::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA_IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA_IRObject::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_CORBA_IRObject::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA_IRObject:1.0";
}

CORBA_IRObject*
POA_CORBA_IRObject::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return ::CORBA_IRObject::_unchecked_narrow (obj.in ());
}


class TAO_CORBA_Contained_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 12:14:19 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_Contained_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_Contained_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_Contained_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 16,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move", 	&POA_CORBA_Contained::move_skel},
      {"_is_a",  &POA_CORBA_Contained::_is_a_skel},
      {"_get_id", 	&POA_CORBA_Contained::_get_id_skel},
      {"_set_id", 	&POA_CORBA_Contained::_set_id_skel},
      {"describe", 	&POA_CORBA_Contained::describe_skel},
      {"_get_name", 	&POA_CORBA_Contained::_get_name_skel},
      {"_set_name", 	&POA_CORBA_Contained::_set_name_skel},
      {"_interface",  &POA_CORBA_Contained::_interface_skel},
      {"_get_version", 	&POA_CORBA_Contained::_get_version_skel},
      {"_set_version", 	&POA_CORBA_Contained::_set_version_skel},
      {"_get_def_kind", 	&POA_CORBA_Contained::_get_def_kind_skel},
      {"_get_defined_in", 	&POA_CORBA_Contained::_get_defined_in_skel},
      {"destroy", 	&POA_CORBA_Contained::destroy_skel},
      {"_get_absolute_name", 	&POA_CORBA_Contained::_get_absolute_name_skel},
      {"_non_existent",  &POA_CORBA_Contained::_non_existent_skel},
      {"_get_containing_repository", 	&POA_CORBA_Contained::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -9,  -2, -12,  -2,   4,   5,  -1,  48,   8, -45,  11,  -1, -46,  14, 
       -1,  15,  -1,  16,  17,  -6,  -2,  -1,  -1,  18,  -1,  -1,  -1,  -1, 
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  19, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 12:14:19 */
static TAO_CORBA_Contained_Perfect_Hash_OpTable tao_CORBA_Contained_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_CORBA_Contained_id_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_id_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Contained *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (char * result);

private:
  TAO_ServerRequestInfo_CORBA_Contained_id_get (const TAO_ServerRequestInfo_CORBA_Contained_id_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_id_get &);
  
private:
  POA_CORBA_Contained *_tao_impl;
  char * _result;
};

TAO_ServerRequestInfo_CORBA_Contained_id_get::TAO_ServerRequestInfo_CORBA_Contained_id_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Contained *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_id_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_id_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Contained_id_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Contained_id_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_id_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Contained_id_get::result (char * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Contained_id_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_id_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Contained *tao_impl,
    const char * id,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_CORBA_Contained_id_set (const TAO_ServerRequestInfo_CORBA_Contained_id_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_id_set &);
  
private:
  POA_CORBA_Contained *_tao_impl;
  const char * id_;
  
};

TAO_ServerRequestInfo_CORBA_Contained_id_set::TAO_ServerRequestInfo_CORBA_Contained_id_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Contained *tao_impl,
    const char * id,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_id_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_id_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Contained_id_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_Contained_id_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_id_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

class TAO_ServerRequestInfo_CORBA_Contained_name_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_name_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Contained *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (char * result);

private:
  TAO_ServerRequestInfo_CORBA_Contained_name_get (const TAO_ServerRequestInfo_CORBA_Contained_name_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_name_get &);
  
private:
  POA_CORBA_Contained *_tao_impl;
  char * _result;
};

TAO_ServerRequestInfo_CORBA_Contained_name_get::TAO_ServerRequestInfo_CORBA_Contained_name_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Contained *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_name_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_name_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Contained_name_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Contained_name_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_name_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Contained_name_get::result (char * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Contained_name_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_name_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Contained *tao_impl,
    const char * name,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_CORBA_Contained_name_set (const TAO_ServerRequestInfo_CORBA_Contained_name_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_name_set &);
  
private:
  POA_CORBA_Contained *_tao_impl;
  const char * name_;
  
};

TAO_ServerRequestInfo_CORBA_Contained_name_set::TAO_ServerRequestInfo_CORBA_Contained_name_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Contained *tao_impl,
    const char * name,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    name_ (name)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_name_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_name_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Contained_name_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_Contained_name_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_name_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

class TAO_ServerRequestInfo_CORBA_Contained_version_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_version_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Contained *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (char * result);

private:
  TAO_ServerRequestInfo_CORBA_Contained_version_get (const TAO_ServerRequestInfo_CORBA_Contained_version_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_version_get &);
  
private:
  POA_CORBA_Contained *_tao_impl;
  char * _result;
};

TAO_ServerRequestInfo_CORBA_Contained_version_get::TAO_ServerRequestInfo_CORBA_Contained_version_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Contained *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_version_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_version_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Contained_version_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Contained_version_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_version_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Contained_version_get::result (char * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Contained_version_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_version_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Contained *tao_impl,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_CORBA_Contained_version_set (const TAO_ServerRequestInfo_CORBA_Contained_version_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_version_set &);
  
private:
  POA_CORBA_Contained *_tao_impl;
  const char * version_;
  
};

TAO_ServerRequestInfo_CORBA_Contained_version_set::TAO_ServerRequestInfo_CORBA_Contained_version_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Contained *tao_impl,
    const char * version,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    version_ (version)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_version_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_version_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Contained_version_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_Contained_version_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_version_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

class TAO_ServerRequestInfo_CORBA_Contained_defined_in_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_defined_in_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Contained *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_Container_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Contained_defined_in_get (const TAO_ServerRequestInfo_CORBA_Contained_defined_in_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_defined_in_get &);
  
private:
  POA_CORBA_Contained *_tao_impl;
  CORBA_Container_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Contained_defined_in_get::TAO_ServerRequestInfo_CORBA_Contained_defined_in_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Contained *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_defined_in_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_defined_in_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Contained_defined_in_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Contained_defined_in_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_defined_in_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Contained_defined_in_get::result (CORBA_Container_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Contained *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (char * result);

private:
  TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get (const TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get &);
  
private:
  POA_CORBA_Contained *_tao_impl;
  char * _result;
};

TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get::TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Contained *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get::result (char * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Contained *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_Repository_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get (const TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get &);
  
private:
  POA_CORBA_Contained *_tao_impl;
  CORBA_Repository_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get::TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Contained *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get::result (CORBA_Repository_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Contained_describe : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_describe (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Contained *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_Contained::Description * result);

private:
  TAO_ServerRequestInfo_CORBA_Contained_describe (const TAO_ServerRequestInfo_CORBA_Contained_describe &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_describe &);
  
private:
  POA_CORBA_Contained *_tao_impl;
  CORBA_Contained::Description * _result;
};

TAO_ServerRequestInfo_CORBA_Contained_describe::TAO_ServerRequestInfo_CORBA_Contained_describe (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Contained *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_describe::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_describe::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Contained_describe::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Contained_describe::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_describe::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Contained_describe::result (CORBA_Contained::Description * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Contained_move : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_move (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Contained *tao_impl,
    CORBA_Container_ptr new_container,
    const char * new_name,
    const char * new_version,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_CORBA_Contained_move (const TAO_ServerRequestInfo_CORBA_Contained_move &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_move &);
  
private:
  POA_CORBA_Contained *_tao_impl;
  CORBA_Container_ptr new_container_;
  const char * new_name_;
  const char * new_version_;
  
};

TAO_ServerRequestInfo_CORBA_Contained_move::TAO_ServerRequestInfo_CORBA_Contained_move (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Contained *tao_impl,
    CORBA_Container_ptr new_container,
    const char * new_name,
    const char * new_version,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    new_container_ (new_container),
    new_name_ (new_name),
    new_version_ (new_version)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_move::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_new_container = parameter_list->length ();
  parameter_list->length (length_new_container + 1);
  (*parameter_list)[length_new_container].argument <<=  this->new_container_;
  
  (*parameter_list)[length_new_container].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_new_name = parameter_list->length ();
  parameter_list->length (length_new_name + 1);
  (*parameter_list)[length_new_name].argument <<= new_name_;
  (*parameter_list)[length_new_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_new_version = parameter_list->length ();
  parameter_list->length (length_new_version + 1);
  (*parameter_list)[length_new_version].argument <<= new_version_;
  (*parameter_list)[length_new_version].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_move::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Contained_move::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_Contained_move::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_move::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
_TAO_CORBA_Contained_Strategized_Proxy_Broker *_TAO_CORBA_Contained_Strategized_Proxy_Broker::the_TAO_CORBA_Contained_Strategized_Proxy_Broker (void)
{
  static _TAO_CORBA_Contained_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_CORBA_Contained_Strategized_Proxy_Broker::_TAO_CORBA_Contained_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

_TAO_CORBA_Contained_Strategized_Proxy_Broker::~_TAO_CORBA_Contained_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_CORBA_Contained_Proxy_Impl&
_TAO_CORBA_Contained_Strategized_Proxy_Broker::select_proxy (
    ::CORBA_Contained *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
_TAO_CORBA_Contained_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_CORBA_Contained_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_CORBA_Contained_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_CORBA_Contained_Proxy_Broker *
_TAO_CORBA_Contained_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::_TAO_CORBA_Contained_Strategized_Proxy_Broker::the_TAO_CORBA_Contained_Strategized_Proxy_Broker();
}

int
_TAO_CORBA_Contained_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_CORBA_Contained_Proxy_Broker_Factory_function_pointer = 
    _TAO_CORBA_Contained_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_CORBA_Contained_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_CORBA_Contained_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_CORBA_Contained_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

_TAO_CORBA_Contained_ThruPOA_Proxy_Impl::_TAO_CORBA_Contained_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

char * _TAO_CORBA_Contained_ThruPOA_Proxy_Impl::id (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::String_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "id",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA_Contained:1.0"
        )
    )->id (
        ACE_TRY_ENV
      );
}

void _TAO_CORBA_Contained_ThruPOA_Proxy_Impl::id (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "id",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA_Contained:1.0"
        )
    )->id (
        id,
        ACE_TRY_ENV
      );
  return;
}

char * _TAO_CORBA_Contained_ThruPOA_Proxy_Impl::name (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::String_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "name",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA_Contained:1.0"
        )
    )->name (
        ACE_TRY_ENV
      );
}

void _TAO_CORBA_Contained_ThruPOA_Proxy_Impl::name (
    CORBA_Object *_collocated_tao_target_,
    const char * name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "name",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA_Contained:1.0"
        )
    )->name (
        name,
        ACE_TRY_ENV
      );
  return;
}

char * _TAO_CORBA_Contained_ThruPOA_Proxy_Impl::version (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::String_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "version",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA_Contained:1.0"
        )
    )->version (
        ACE_TRY_ENV
      );
}

void _TAO_CORBA_Contained_ThruPOA_Proxy_Impl::version (
    CORBA_Object *_collocated_tao_target_,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "version",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA_Contained:1.0"
        )
    )->version (
        version,
        ACE_TRY_ENV
      );
  return;
}

CORBA_Container_ptr _TAO_CORBA_Contained_ThruPOA_Proxy_Impl::defined_in (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_Container_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "defined_in",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA_Contained:1.0"
        )
    )->defined_in (
        ACE_TRY_ENV
      );
}

char * _TAO_CORBA_Contained_ThruPOA_Proxy_Impl::absolute_name (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::String_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "absolute_name",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA_Contained:1.0"
        )
    )->absolute_name (
        ACE_TRY_ENV
      );
}

CORBA_Repository_ptr _TAO_CORBA_Contained_ThruPOA_Proxy_Impl::containing_repository (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_Repository_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "containing_repository",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA_Contained:1.0"
        )
    )->containing_repository (
        ACE_TRY_ENV
      );
}

CORBA_Contained::Description * _TAO_CORBA_Contained_ThruPOA_Proxy_Impl::describe (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_Contained::Description_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "describe",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA_Contained:1.0"
        )
    )->describe (
        ACE_TRY_ENV
      );
}

void _TAO_CORBA_Contained_ThruPOA_Proxy_Impl::move (
    CORBA_Object *_collocated_tao_target_,
    CORBA_Container_ptr new_container,
    const char * new_name,
    const char * new_version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "move",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA_Contained:1.0"
        )
    )->move (
        new_container,
        new_name,
        new_version,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA_Contained::POA_CORBA_Contained (void)
{
  this->optable_ = &tao_CORBA_Contained_optable;
}

// copy ctor
POA_CORBA_Contained::POA_CORBA_Contained (const POA_CORBA_Contained& rhs)
  :   POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA_Contained::~POA_CORBA_Contained (void)
{
}

void POA_CORBA_Contained::_get_id_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA_Contained *_tao_impl = (POA_CORBA_Contained *)_tao_object_reference;
  
    CORBA::String_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Contained_id_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->id (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      char * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_Contained::_set_id_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Contained *_tao_impl = (POA_CORBA_Contained *)_tao_object_reference;
  
  _tao_server_request.argument_flag (0);
    CORBA::String_var id;
  if (!(
    (_tao_in >> id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Contained_id_set ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      _tao_impl->id (
          id.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_Contained::_get_name_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA_Contained *_tao_impl = (POA_CORBA_Contained *)_tao_object_reference;
  
    CORBA::String_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Contained_name_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->name (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      char * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_Contained::_set_name_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Contained *_tao_impl = (POA_CORBA_Contained *)_tao_object_reference;
  
  _tao_server_request.argument_flag (0);
    CORBA::String_var name;
  if (!(
    (_tao_in >> name.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Contained_name_set ri (
      _tao_server_request,
      _tao_impl,
      name.in (),
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      _tao_impl->name (
          name.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_Contained::_get_version_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA_Contained *_tao_impl = (POA_CORBA_Contained *)_tao_object_reference;
  
    CORBA::String_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Contained_version_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->version (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      char * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_Contained::_set_version_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Contained *_tao_impl = (POA_CORBA_Contained *)_tao_object_reference;
  
  _tao_server_request.argument_flag (0);
    CORBA::String_var version;
  if (!(
    (_tao_in >> version.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Contained_version_set ri (
      _tao_server_request,
      _tao_impl,
      version.in (),
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      _tao_impl->version (
          version.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_Contained::_get_defined_in_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA_Contained *_tao_impl = (POA_CORBA_Contained *)_tao_object_reference;
  
    CORBA_Container_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Contained_defined_in_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->defined_in (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_Container_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_Contained::_get_absolute_name_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA_Contained *_tao_impl = (POA_CORBA_Contained *)_tao_object_reference;
  
    CORBA::String_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->absolute_name (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      char * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_Contained::_get_containing_repository_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA_Contained *_tao_impl = (POA_CORBA_Contained *)_tao_object_reference;
  
    CORBA_Repository_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->containing_repository (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_Repository_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_Contained::describe_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA_Contained *_tao_impl = (POA_CORBA_Contained *)_tao_object_reference;
  
    CORBA_Contained::Description_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Contained_describe ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->describe (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_Contained::Description * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_Contained::move_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Contained *_tao_impl = (POA_CORBA_Contained *)_tao_object_reference;
  
  _tao_server_request.argument_flag (0);
    CORBA_Container_var new_container;
  CORBA::String_var new_name;
  CORBA::String_var new_version;
  if (!(
    (_tao_in >> new_container.out ()) &&
    (_tao_in >> new_name.out ()) &&
    (_tao_in >> new_version.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Contained_move ri (
      _tao_server_request,
      _tao_impl,
      new_container.in (),
      new_name.in (),
      new_version.in (),
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      _tao_impl->move (
          new_container.in (),
          new_name.in (),
          new_version.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_Contained::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Contained *_tao_impl = (POA_CORBA_Contained *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_Contained::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA_Contained *_tao_impl = (POA_CORBA_Contained *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_Contained::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA_Contained *_tao_impl = (POA_CORBA_Contained *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_CORBA_Contained::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA_Contained::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA_Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA_IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA_Contained::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_CORBA_Contained::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA_Contained:1.0";
}

CORBA_Contained*
POA_CORBA_Contained::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return ::CORBA_Contained::_unchecked_narrow (obj.in ());
}


class TAO_CORBA_Container_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 12:14:19 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_Container_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_Container_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 20,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 10,
     39,  0,  0,  0, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39,  0, 20,  5,
     39,  0, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 15,  5, 39, 39, 39, 10,  0, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39,
#else
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 20, 39, 10, 39,  0,
      0,  0, 39, 39, 39, 39, 39, 39,  0, 20,
      5, 39,  0, 39, 39, 15,  5, 39, 39, 39,
     10,  0, 39, 39, 39, 39, 39, 39,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_Container_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 22,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 25,
      MIN_HASH_VALUE = 6,
      MAX_HASH_VALUE = 38,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 2
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},{"",0},
      {"lookup", 	&POA_CORBA_Container::lookup_skel},
      {"destroy", 	&POA_CORBA_Container::destroy_skel},
      {"lookup_name", 	&POA_CORBA_Container::lookup_name_skel},
      {"create_value", 	&POA_CORBA_Container::create_value_skel},
      {"create_module", 	&POA_CORBA_Container::create_module_skel},
      {"create_native", 	&POA_CORBA_Container::create_native_skel},
      {"create_interface", 	&POA_CORBA_Container::create_interface_skel},
      {"create_union", 	&POA_CORBA_Container::create_union_skel},
      {"create_struct", 	&POA_CORBA_Container::create_struct_skel},
      {"create_constant", 	&POA_CORBA_Container::create_constant_skel},
      {"create_exception", 	&POA_CORBA_Container::create_exception_skel},
      {"create_local_interface", 	&POA_CORBA_Container::create_local_interface_skel},
      {"contents", 	&POA_CORBA_Container::contents_skel},
      {"create_abstract_interface", 	&POA_CORBA_Container::create_abstract_interface_skel},
      {"create_value_box", 	&POA_CORBA_Container::create_value_box_skel},
      {"create_alias", 	&POA_CORBA_Container::create_alias_skel},
      {"_interface",  &POA_CORBA_Container::_interface_skel},
      {"create_enum", 	&POA_CORBA_Container::create_enum_skel},
      {"describe_contents", 	&POA_CORBA_Container::describe_contents_skel},
      {"_get_def_kind", 	&POA_CORBA_Container::_get_def_kind_skel},
      {"_is_a",  &POA_CORBA_Container::_is_a_skel},
      {"_non_existent",  &POA_CORBA_Container::_non_existent_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,  -1,   6,   7,  -1, -10,  -2,   8,   9, -42, 
       -1,  -1,  12,  13,  14,  -1,  15,  16,  17,  18,  -1,  19,  20,  21, 
       -1,  -1,  22,  23,  24,  25,  -1,  26,  -1,  -1,  27, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 12:14:19 */
static TAO_CORBA_Container_Perfect_Hash_OpTable tao_CORBA_Container_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_CORBA_Container_lookup : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_lookup (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    const char * search_name,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_Contained_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_lookup (const TAO_ServerRequestInfo_CORBA_Container_lookup &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_lookup &);
  
private:
  POA_CORBA_Container *_tao_impl;
  const char * search_name_;
  CORBA_Contained_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_lookup::TAO_ServerRequestInfo_CORBA_Container_lookup (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    const char * search_name,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    search_name_ (search_name)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_lookup::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_search_name = parameter_list->length ();
  parameter_list->length (length_search_name + 1);
  (*parameter_list)[length_search_name].argument <<= search_name_;
  (*parameter_list)[length_search_name].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_lookup::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_lookup::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_lookup::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_lookup::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_lookup::result (CORBA_Contained_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_contents : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_contents (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    CORBA::DefinitionKind & limit_type,
    const CORBA::Boolean & exclude_inherited,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_ContainedSeq * result);

private:
  TAO_ServerRequestInfo_CORBA_Container_contents (const TAO_ServerRequestInfo_CORBA_Container_contents &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_contents &);
  
private:
  POA_CORBA_Container *_tao_impl;
  const CORBA::DefinitionKind & limit_type_;
  const CORBA::Boolean & exclude_inherited_;
  CORBA_ContainedSeq * _result;
};

TAO_ServerRequestInfo_CORBA_Container_contents::TAO_ServerRequestInfo_CORBA_Container_contents (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    CORBA::DefinitionKind & limit_type,
    const CORBA::Boolean & exclude_inherited,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    limit_type_ (limit_type),
    exclude_inherited_ (exclude_inherited)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_contents::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_limit_type = parameter_list->length ();
  parameter_list->length (length_limit_type + 1);
  (*parameter_list)[length_limit_type].argument <<=  this->limit_type_;
  
  (*parameter_list)[length_limit_type].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_exclude_inherited = parameter_list->length ();
  parameter_list->length (length_exclude_inherited + 1);
  (*parameter_list)[length_exclude_inherited].argument <<= CORBA::Any::from_boolean (this->exclude_inherited_);
  (*parameter_list)[length_exclude_inherited].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_contents::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_contents::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_contents::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_contents::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_contents::result (CORBA_ContainedSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_lookup_name : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_lookup_name (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    const char * search_name,
    const CORBA::Long & levels_to_search,
    CORBA::DefinitionKind & limit_type,
    const CORBA::Boolean & exclude_inherited,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_ContainedSeq * result);

private:
  TAO_ServerRequestInfo_CORBA_Container_lookup_name (const TAO_ServerRequestInfo_CORBA_Container_lookup_name &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_lookup_name &);
  
private:
  POA_CORBA_Container *_tao_impl;
  const char * search_name_;
  const CORBA::Long & levels_to_search_;
  const CORBA::DefinitionKind & limit_type_;
  const CORBA::Boolean & exclude_inherited_;
  CORBA_ContainedSeq * _result;
};

TAO_ServerRequestInfo_CORBA_Container_lookup_name::TAO_ServerRequestInfo_CORBA_Container_lookup_name (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    const char * search_name,
    const CORBA::Long & levels_to_search,
    CORBA::DefinitionKind & limit_type,
    const CORBA::Boolean & exclude_inherited,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    search_name_ (search_name),
    levels_to_search_ (levels_to_search),
    limit_type_ (limit_type),
    exclude_inherited_ (exclude_inherited)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_lookup_name::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_search_name = parameter_list->length ();
  parameter_list->length (length_search_name + 1);
  (*parameter_list)[length_search_name].argument <<= search_name_;
  (*parameter_list)[length_search_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_levels_to_search = parameter_list->length ();
  parameter_list->length (length_levels_to_search + 1);
  (*parameter_list)[length_levels_to_search].argument <<= levels_to_search_;
  (*parameter_list)[length_levels_to_search].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_limit_type = parameter_list->length ();
  parameter_list->length (length_limit_type + 1);
  (*parameter_list)[length_limit_type].argument <<=  this->limit_type_;
  
  (*parameter_list)[length_limit_type].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_exclude_inherited = parameter_list->length ();
  parameter_list->length (length_exclude_inherited + 1);
  (*parameter_list)[length_exclude_inherited].argument <<= CORBA::Any::from_boolean (this->exclude_inherited_);
  (*parameter_list)[length_exclude_inherited].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_lookup_name::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_lookup_name::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_lookup_name::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_lookup_name::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_lookup_name::result (CORBA_ContainedSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_describe_contents : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_describe_contents (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    CORBA::DefinitionKind & limit_type,
    const CORBA::Boolean & exclude_inherited,
    const CORBA::Long & max_returned_objs,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_Container::DescriptionSeq * result);

private:
  TAO_ServerRequestInfo_CORBA_Container_describe_contents (const TAO_ServerRequestInfo_CORBA_Container_describe_contents &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_describe_contents &);
  
private:
  POA_CORBA_Container *_tao_impl;
  const CORBA::DefinitionKind & limit_type_;
  const CORBA::Boolean & exclude_inherited_;
  const CORBA::Long & max_returned_objs_;
  CORBA_Container::DescriptionSeq * _result;
};

TAO_ServerRequestInfo_CORBA_Container_describe_contents::TAO_ServerRequestInfo_CORBA_Container_describe_contents (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    CORBA::DefinitionKind & limit_type,
    const CORBA::Boolean & exclude_inherited,
    const CORBA::Long & max_returned_objs,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    limit_type_ (limit_type),
    exclude_inherited_ (exclude_inherited),
    max_returned_objs_ (max_returned_objs)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_describe_contents::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_limit_type = parameter_list->length ();
  parameter_list->length (length_limit_type + 1);
  (*parameter_list)[length_limit_type].argument <<=  this->limit_type_;
  
  (*parameter_list)[length_limit_type].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_exclude_inherited = parameter_list->length ();
  parameter_list->length (length_exclude_inherited + 1);
  (*parameter_list)[length_exclude_inherited].argument <<= CORBA::Any::from_boolean (this->exclude_inherited_);
  (*parameter_list)[length_exclude_inherited].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_max_returned_objs = parameter_list->length ();
  parameter_list->length (length_max_returned_objs + 1);
  (*parameter_list)[length_max_returned_objs].argument <<= max_returned_objs_;
  (*parameter_list)[length_max_returned_objs].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_describe_contents::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_describe_contents::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_describe_contents::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_describe_contents::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_describe_contents::result (CORBA_Container::DescriptionSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_module : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_module (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_ModuleDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_module (const TAO_ServerRequestInfo_CORBA_Container_create_module &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_module &);
  
private:
  POA_CORBA_Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_ModuleDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_module::TAO_ServerRequestInfo_CORBA_Container_create_module (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_module::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_module::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_create_module::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_module::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_module::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_create_module::result (CORBA_ModuleDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_constant : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_constant (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr type,
    const CORBA::Any & value,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_ConstantDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_constant (const TAO_ServerRequestInfo_CORBA_Container_create_constant &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_constant &);
  
private:
  POA_CORBA_Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_IDLType_ptr type_;
  const CORBA::Any & value_;
  CORBA_ConstantDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_constant::TAO_ServerRequestInfo_CORBA_Container_create_constant (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr type,
    const CORBA::Any & value,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    type_ (type),
    value_ (value)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_constant::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_type = parameter_list->length ();
  parameter_list->length (length_type + 1);
  (*parameter_list)[length_type].argument <<=  this->type_;
  
  (*parameter_list)[length_type].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_value = parameter_list->length ();
  parameter_list->length (length_value + 1);
  (*parameter_list)[length_value].argument <<= value_;
  (*parameter_list)[length_value].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_constant::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_create_constant::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_constant::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_constant::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_create_constant::result (CORBA_ConstantDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_struct : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_struct (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_StructDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_struct (const TAO_ServerRequestInfo_CORBA_Container_create_struct &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_struct &);
  
private:
  POA_CORBA_Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA_StructMemberSeq & members_;
  CORBA_StructDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_struct::TAO_ServerRequestInfo_CORBA_Container_create_struct (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_StructMemberSeq & members,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    members_ (members)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_struct::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_members = parameter_list->length ();
  parameter_list->length (length_members + 1);
  (*parameter_list)[length_members].argument <<=  this->members_;
  
  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_struct::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_create_struct::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_struct::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_struct::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_create_struct::result (CORBA_StructDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_union : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_union (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr discriminator_type,
    const CORBA_UnionMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_UnionDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_union (const TAO_ServerRequestInfo_CORBA_Container_create_union &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_union &);
  
private:
  POA_CORBA_Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_IDLType_ptr discriminator_type_;
  const CORBA_UnionMemberSeq & members_;
  CORBA_UnionDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_union::TAO_ServerRequestInfo_CORBA_Container_create_union (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr discriminator_type,
    const CORBA_UnionMemberSeq & members,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    discriminator_type_ (discriminator_type),
    members_ (members)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_union::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_discriminator_type = parameter_list->length ();
  parameter_list->length (length_discriminator_type + 1);
  (*parameter_list)[length_discriminator_type].argument <<=  this->discriminator_type_;
  
  (*parameter_list)[length_discriminator_type].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_members = parameter_list->length ();
  parameter_list->length (length_members + 1);
  (*parameter_list)[length_members].argument <<=  this->members_;
  
  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_union::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_create_union::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_union::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_union::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_create_union::result (CORBA_UnionDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_enum : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_enum (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_EnumMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_EnumDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_enum (const TAO_ServerRequestInfo_CORBA_Container_create_enum &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_enum &);
  
private:
  POA_CORBA_Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA_EnumMemberSeq & members_;
  CORBA_EnumDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_enum::TAO_ServerRequestInfo_CORBA_Container_create_enum (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_EnumMemberSeq & members,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    members_ (members)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_enum::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_members = parameter_list->length ();
  parameter_list->length (length_members + 1);
  (*parameter_list)[length_members].argument <<=  this->members_;
  
  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_enum::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_create_enum::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_enum::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_enum::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_create_enum::result (CORBA_EnumDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_alias : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_alias (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr original_type,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_AliasDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_alias (const TAO_ServerRequestInfo_CORBA_Container_create_alias &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_alias &);
  
private:
  POA_CORBA_Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_IDLType_ptr original_type_;
  CORBA_AliasDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_alias::TAO_ServerRequestInfo_CORBA_Container_create_alias (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr original_type,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    original_type_ (original_type)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_alias::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_original_type = parameter_list->length ();
  parameter_list->length (length_original_type + 1);
  (*parameter_list)[length_original_type].argument <<=  this->original_type_;
  
  (*parameter_list)[length_original_type].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_alias::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_create_alias::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_alias::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_alias::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_create_alias::result (CORBA_AliasDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_interface : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_interface (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_InterfaceDefSeq & base_interfaces,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_InterfaceDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_interface (const TAO_ServerRequestInfo_CORBA_Container_create_interface &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_interface &);
  
private:
  POA_CORBA_Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA_InterfaceDefSeq & base_interfaces_;
  CORBA_InterfaceDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_interface::TAO_ServerRequestInfo_CORBA_Container_create_interface (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_InterfaceDefSeq & base_interfaces,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    base_interfaces_ (base_interfaces)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_interface::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_base_interfaces = parameter_list->length ();
  parameter_list->length (length_base_interfaces + 1);
  (*parameter_list)[length_base_interfaces].argument <<=  this->base_interfaces_;
  
  (*parameter_list)[length_base_interfaces].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_interface::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_create_interface::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_interface::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_interface::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_create_interface::result (CORBA_InterfaceDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_value : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_value (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::Boolean & is_custom,
    const CORBA::Boolean & is_abstract,
    CORBA_ValueDef_ptr base_value,
    const CORBA::Boolean & is_truncatable,
    const CORBA_ValueDefSeq & abstract_base_values,
    const CORBA_InterfaceDefSeq & supported_interfaces,
    const CORBA_InitializerSeq & initializers,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_ValueDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_value (const TAO_ServerRequestInfo_CORBA_Container_create_value &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_value &);
  
private:
  POA_CORBA_Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA::Boolean & is_custom_;
  const CORBA::Boolean & is_abstract_;
  CORBA_ValueDef_ptr base_value_;
  const CORBA::Boolean & is_truncatable_;
  const CORBA_ValueDefSeq & abstract_base_values_;
  const CORBA_InterfaceDefSeq & supported_interfaces_;
  const CORBA_InitializerSeq & initializers_;
  CORBA_ValueDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_value::TAO_ServerRequestInfo_CORBA_Container_create_value (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::Boolean & is_custom,
    const CORBA::Boolean & is_abstract,
    CORBA_ValueDef_ptr base_value,
    const CORBA::Boolean & is_truncatable,
    const CORBA_ValueDefSeq & abstract_base_values,
    const CORBA_InterfaceDefSeq & supported_interfaces,
    const CORBA_InitializerSeq & initializers,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    is_custom_ (is_custom),
    is_abstract_ (is_abstract),
    base_value_ (base_value),
    is_truncatable_ (is_truncatable),
    abstract_base_values_ (abstract_base_values),
    supported_interfaces_ (supported_interfaces),
    initializers_ (initializers)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_value::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_is_custom = parameter_list->length ();
  parameter_list->length (length_is_custom + 1);
  (*parameter_list)[length_is_custom].argument <<= CORBA::Any::from_boolean (this->is_custom_);
  (*parameter_list)[length_is_custom].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_is_abstract = parameter_list->length ();
  parameter_list->length (length_is_abstract + 1);
  (*parameter_list)[length_is_abstract].argument <<= CORBA::Any::from_boolean (this->is_abstract_);
  (*parameter_list)[length_is_abstract].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_base_value = parameter_list->length ();
  parameter_list->length (length_base_value + 1);
  (*parameter_list)[length_base_value].argument <<=  this->base_value_;
  
  (*parameter_list)[length_base_value].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_is_truncatable = parameter_list->length ();
  parameter_list->length (length_is_truncatable + 1);
  (*parameter_list)[length_is_truncatable].argument <<= CORBA::Any::from_boolean (this->is_truncatable_);
  (*parameter_list)[length_is_truncatable].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_abstract_base_values = parameter_list->length ();
  parameter_list->length (length_abstract_base_values + 1);
  (*parameter_list)[length_abstract_base_values].argument <<=  this->abstract_base_values_;
  
  (*parameter_list)[length_abstract_base_values].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_supported_interfaces = parameter_list->length ();
  parameter_list->length (length_supported_interfaces + 1);
  (*parameter_list)[length_supported_interfaces].argument <<=  this->supported_interfaces_;
  
  (*parameter_list)[length_supported_interfaces].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_initializers = parameter_list->length ();
  parameter_list->length (length_initializers + 1);
  (*parameter_list)[length_initializers].argument <<=  this->initializers_;
  
  (*parameter_list)[length_initializers].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_value::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_create_value::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_value::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_value::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_create_value::result (CORBA_ValueDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_value_box : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_value_box (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_ValueBoxDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_value_box (const TAO_ServerRequestInfo_CORBA_Container_create_value_box &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_value_box &);
  
private:
  POA_CORBA_Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_IDLType_ptr original_type_def_;
  CORBA_ValueBoxDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_value_box::TAO_ServerRequestInfo_CORBA_Container_create_value_box (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr original_type_def,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    original_type_def_ (original_type_def)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_value_box::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_original_type_def = parameter_list->length ();
  parameter_list->length (length_original_type_def + 1);
  (*parameter_list)[length_original_type_def].argument <<=  this->original_type_def_;
  
  (*parameter_list)[length_original_type_def].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_value_box::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_create_value_box::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_value_box::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_value_box::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_create_value_box::result (CORBA_ValueBoxDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_exception : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_exception (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_ExceptionDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_exception (const TAO_ServerRequestInfo_CORBA_Container_create_exception &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_exception &);
  
private:
  POA_CORBA_Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA_StructMemberSeq & members_;
  CORBA_ExceptionDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_exception::TAO_ServerRequestInfo_CORBA_Container_create_exception (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_StructMemberSeq & members,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    members_ (members)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_exception::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_members = parameter_list->length ();
  parameter_list->length (length_members + 1);
  (*parameter_list)[length_members].argument <<=  this->members_;
  
  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_exception::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_create_exception::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_exception::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_exception::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_create_exception::result (CORBA_ExceptionDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_native : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_native (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_NativeDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_native (const TAO_ServerRequestInfo_CORBA_Container_create_native &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_native &);
  
private:
  POA_CORBA_Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_NativeDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_native::TAO_ServerRequestInfo_CORBA_Container_create_native (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_native::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_native::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_create_native::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_native::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_native::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_create_native::result (CORBA_NativeDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_AbstractInterfaceDefSeq & base_interfaces,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_AbstractInterfaceDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface (const TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface &);
  
private:
  POA_CORBA_Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA_AbstractInterfaceDefSeq & base_interfaces_;
  CORBA_AbstractInterfaceDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface::TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_AbstractInterfaceDefSeq & base_interfaces,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    base_interfaces_ (base_interfaces)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_base_interfaces = parameter_list->length ();
  parameter_list->length (length_base_interfaces + 1);
  (*parameter_list)[length_base_interfaces].argument <<=  this->base_interfaces_;
  
  (*parameter_list)[length_base_interfaces].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface::result (CORBA_AbstractInterfaceDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_local_interface : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_local_interface (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_InterfaceDefSeq & base_interfaces,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_LocalInterfaceDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_local_interface (const TAO_ServerRequestInfo_CORBA_Container_create_local_interface &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_local_interface &);
  
private:
  POA_CORBA_Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA_InterfaceDefSeq & base_interfaces_;
  CORBA_LocalInterfaceDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_local_interface::TAO_ServerRequestInfo_CORBA_Container_create_local_interface (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_InterfaceDefSeq & base_interfaces,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    base_interfaces_ (base_interfaces)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_local_interface::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_base_interfaces = parameter_list->length ();
  parameter_list->length (length_base_interfaces + 1);
  (*parameter_list)[length_base_interfaces].argument <<=  this->base_interfaces_;
  
  (*parameter_list)[length_base_interfaces].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_local_interface::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_create_local_interface::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_local_interface::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_local_interface::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_create_local_interface::result (CORBA_LocalInterfaceDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
_TAO_CORBA_Container_Strategized_Proxy_Broker *_TAO_CORBA_Container_Strategized_Proxy_Broker::the_TAO_CORBA_Container_Strategized_Proxy_Broker (void)
{
  static _TAO_CORBA_Container_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_CORBA_Container_Strategized_Proxy_Broker::_TAO_CORBA_Container_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

_TAO_CORBA_Container_Strategized_Proxy_Broker::~_TAO_CORBA_Container_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_CORBA_Container_Proxy_Impl&
_TAO_CORBA_Container_Strategized_Proxy_Broker::select_proxy (
    ::CORBA_Container *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
_TAO_CORBA_Container_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_CORBA_Container_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_CORBA_Container_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_CORBA_Container_Proxy_Broker *
_TAO_CORBA_Container_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::_TAO_CORBA_Container_Strategized_Proxy_Broker::the_TAO_CORBA_Container_Strategized_Proxy_Broker();
}

int
_TAO_CORBA_Container_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_CORBA_Container_Proxy_Broker_Factory_function_pointer = 
    _TAO_CORBA_Container_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_CORBA_Container_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_CORBA_Container_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_CORBA_Container_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

_TAO_CORBA_Container_ThruPOA_Proxy_Impl::_TAO_CORBA_Container_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA_Contained_ptr _TAO_CORBA_Container_ThruPOA_Proxy_Impl::lookup (
    CORBA_Object *_collocated_tao_target_,
    const char * search_name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_Contained_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "lookup",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA_Container:1.0"
        )
    )->lookup (
        search_name,
        ACE_TRY_ENV
      );
}

CORBA_ContainedSeq * _TAO_CORBA_Container_ThruPOA_Proxy_Impl::contents (
    CORBA_Object *_collocated_tao_target_,
    CORBA::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_ContainedSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "contents",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA_Container:1.0"
        )
    )->contents (
        limit_type,
        exclude_inherited,
        ACE_TRY_ENV
      );
}

CORBA_ContainedSeq * _TAO_CORBA_Container_ThruPOA_Proxy_Impl::lookup_name (
    CORBA_Object *_collocated_tao_target_,
    const char * search_name,
    CORBA::Long levels_to_search,
    CORBA::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_ContainedSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "lookup_name",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA_Container:1.0"
        )
    )->lookup_name (
        search_name,
        levels_to_search,
        limit_type,
        exclude_inherited,
        ACE_TRY_ENV
      );
}

CORBA_Container::DescriptionSeq * _TAO_CORBA_Container_ThruPOA_Proxy_Impl::describe_contents (
    CORBA_Object *_collocated_tao_target_,
    CORBA::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Long max_returned_objs,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_Container::DescriptionSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "describe_contents",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA_Container:1.0"
        )
    )->describe_contents (
        limit_type,
        exclude_inherited,
        max_returned_objs,
        ACE_TRY_ENV
      );
}

CORBA_ModuleDef_ptr _TAO_CORBA_Container_ThruPOA_Proxy_Impl::create_module (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_ModuleDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_module",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA_Container:1.0"
        )
    )->create_module (
        id,
        name,
        version,
        ACE_TRY_ENV
      );
}

CORBA_ConstantDef_ptr _TAO_CORBA_Container_ThruPOA_Proxy_Impl::create_constant (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr type,
    const CORBA::Any & value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_ConstantDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_constant",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA_Container:1.0"
        )
    )->create_constant (
        id,
        name,
        version,
        type,
        value,
        ACE_TRY_ENV
      );
}

CORBA_StructDef_ptr _TAO_CORBA_Container_ThruPOA_Proxy_Impl::create_struct (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_StructDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_struct",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA_Container:1.0"
        )
    )->create_struct (
        id,
        name,
        version,
        members,
        ACE_TRY_ENV
      );
}

CORBA_UnionDef_ptr _TAO_CORBA_Container_ThruPOA_Proxy_Impl::create_union (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr discriminator_type,
    const CORBA_UnionMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_UnionDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_union",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA_Container:1.0"
        )
    )->create_union (
        id,
        name,
        version,
        discriminator_type,
        members,
        ACE_TRY_ENV
      );
}

CORBA_EnumDef_ptr _TAO_CORBA_Container_ThruPOA_Proxy_Impl::create_enum (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_EnumMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_EnumDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_enum",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA_Container:1.0"
        )
    )->create_enum (
        id,
        name,
        version,
        members,
        ACE_TRY_ENV
      );
}

CORBA_AliasDef_ptr _TAO_CORBA_Container_ThruPOA_Proxy_Impl::create_alias (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr original_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_AliasDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_alias",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA_Container:1.0"
        )
    )->create_alias (
        id,
        name,
        version,
        original_type,
        ACE_TRY_ENV
      );
}

CORBA_InterfaceDef_ptr _TAO_CORBA_Container_ThruPOA_Proxy_Impl::create_interface (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_InterfaceDefSeq & base_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_InterfaceDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_interface",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA_Container:1.0"
        )
    )->create_interface (
        id,
        name,
        version,
        base_interfaces,
        ACE_TRY_ENV
      );
}

CORBA_ValueDef_ptr _TAO_CORBA_Container_ThruPOA_Proxy_Impl::create_value (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Boolean is_custom,
    CORBA::Boolean is_abstract,
    CORBA_ValueDef_ptr base_value,
    CORBA::Boolean is_truncatable,
    const CORBA_ValueDefSeq & abstract_base_values,
    const CORBA_InterfaceDefSeq & supported_interfaces,
    const CORBA_InitializerSeq & initializers,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_ValueDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_value",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA_Container:1.0"
        )
    )->create_value (
        id,
        name,
        version,
        is_custom,
        is_abstract,
        base_value,
        is_truncatable,
        abstract_base_values,
        supported_interfaces,
        initializers,
        ACE_TRY_ENV
      );
}

CORBA_ValueBoxDef_ptr _TAO_CORBA_Container_ThruPOA_Proxy_Impl::create_value_box (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_ValueBoxDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_value_box",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA_Container:1.0"
        )
    )->create_value_box (
        id,
        name,
        version,
        original_type_def,
        ACE_TRY_ENV
      );
}

CORBA_ExceptionDef_ptr _TAO_CORBA_Container_ThruPOA_Proxy_Impl::create_exception (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_ExceptionDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_exception",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA_Container:1.0"
        )
    )->create_exception (
        id,
        name,
        version,
        members,
        ACE_TRY_ENV
      );
}

CORBA_NativeDef_ptr _TAO_CORBA_Container_ThruPOA_Proxy_Impl::create_native (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_NativeDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_native",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA_Container:1.0"
        )
    )->create_native (
        id,
        name,
        version,
        ACE_TRY_ENV
      );
}

CORBA_AbstractInterfaceDef_ptr _TAO_CORBA_Container_ThruPOA_Proxy_Impl::create_abstract_interface (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_AbstractInterfaceDefSeq & base_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_AbstractInterfaceDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_abstract_interface",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA_Container:1.0"
        )
    )->create_abstract_interface (
        id,
        name,
        version,
        base_interfaces,
        ACE_TRY_ENV
      );
}

CORBA_LocalInterfaceDef_ptr _TAO_CORBA_Container_ThruPOA_Proxy_Impl::create_local_interface (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_InterfaceDefSeq & base_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_LocalInterfaceDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_local_interface",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA_Container:1.0"
        )
    )->create_local_interface (
        id,
        name,
        version,
        base_interfaces,
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA_Container::POA_CORBA_Container (void)
{
  this->optable_ = &tao_CORBA_Container_optable;
}

// copy ctor
POA_CORBA_Container::POA_CORBA_Container (const POA_CORBA_Container& rhs)
  :   POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA_Container::~POA_CORBA_Container (void)
{
}

void POA_CORBA_Container::lookup_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl = (POA_CORBA_Container *)_tao_object_reference;
  
    CORBA_Contained_var _tao_retval;
  CORBA::String_var search_name;
  if (!(
    (_tao_in >> search_name.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_lookup ri (
      _tao_server_request,
      _tao_impl,
      search_name.in (),
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->lookup (
          search_name.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_Contained_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_Container::contents_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl = (POA_CORBA_Container *)_tao_object_reference;
  
    CORBA_ContainedSeq_var _tao_retval;
  CORBA::DefinitionKind limit_type;
  CORBA::Boolean exclude_inherited;
  if (!(
    (_tao_in >> limit_type) &&
    (_tao_in >> CORBA::Any::to_boolean (exclude_inherited))
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_contents ri (
      _tao_server_request,
      _tao_impl,
      limit_type,
      exclude_inherited,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->contents (
          limit_type,
          exclude_inherited,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_ContainedSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_Container::lookup_name_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl = (POA_CORBA_Container *)_tao_object_reference;
  
    CORBA_ContainedSeq_var _tao_retval;
  CORBA::String_var search_name;
  CORBA::Long levels_to_search;
  CORBA::DefinitionKind limit_type;
  CORBA::Boolean exclude_inherited;
  if (!(
    (_tao_in >> search_name.out ()) &&
    (_tao_in >> levels_to_search) &&
    (_tao_in >> limit_type) &&
    (_tao_in >> CORBA::Any::to_boolean (exclude_inherited))
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_lookup_name ri (
      _tao_server_request,
      _tao_impl,
      search_name.in (),
      levels_to_search,
      limit_type,
      exclude_inherited,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->lookup_name (
          search_name.in (),
          levels_to_search,
          limit_type,
          exclude_inherited,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_ContainedSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_Container::describe_contents_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl = (POA_CORBA_Container *)_tao_object_reference;
  
    CORBA_Container::DescriptionSeq_var _tao_retval;
  CORBA::DefinitionKind limit_type;
  CORBA::Boolean exclude_inherited;
  CORBA::Long max_returned_objs;
  if (!(
    (_tao_in >> limit_type) &&
    (_tao_in >> CORBA::Any::to_boolean (exclude_inherited)) &&
    (_tao_in >> max_returned_objs)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_describe_contents ri (
      _tao_server_request,
      _tao_impl,
      limit_type,
      exclude_inherited,
      max_returned_objs,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->describe_contents (
          limit_type,
          exclude_inherited,
          max_returned_objs,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_Container::DescriptionSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_Container::create_module_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl = (POA_CORBA_Container *)_tao_object_reference;
  
    CORBA_ModuleDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_create_module ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_module (
          id.in (),
          name.in (),
          version.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_ModuleDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_Container::create_constant_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl = (POA_CORBA_Container *)_tao_object_reference;
  
    CORBA_ConstantDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_IDLType_var type;
  CORBA::Any value;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> type.out ()) &&
    (_tao_in >> value)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_create_constant ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      type.in (),
      value,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_constant (
          id.in (),
          name.in (),
          version.in (),
          type.in (),
          value,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_ConstantDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_Container::create_struct_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl = (POA_CORBA_Container *)_tao_object_reference;
  
    CORBA_StructDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_StructMemberSeq members;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_create_struct ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      members,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_struct (
          id.in (),
          name.in (),
          version.in (),
          members,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_StructDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_Container::create_union_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl = (POA_CORBA_Container *)_tao_object_reference;
  
    CORBA_UnionDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_IDLType_var discriminator_type;
  CORBA_UnionMemberSeq members;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> discriminator_type.out ()) &&
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_create_union ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      discriminator_type.in (),
      members,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_union (
          id.in (),
          name.in (),
          version.in (),
          discriminator_type.in (),
          members,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_UnionDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_Container::create_enum_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl = (POA_CORBA_Container *)_tao_object_reference;
  
    CORBA_EnumDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_EnumMemberSeq members;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_create_enum ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      members,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_enum (
          id.in (),
          name.in (),
          version.in (),
          members,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_EnumDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_Container::create_alias_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl = (POA_CORBA_Container *)_tao_object_reference;
  
    CORBA_AliasDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_IDLType_var original_type;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> original_type.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_create_alias ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      original_type.in (),
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_alias (
          id.in (),
          name.in (),
          version.in (),
          original_type.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_AliasDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_Container::create_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl = (POA_CORBA_Container *)_tao_object_reference;
  
    CORBA_InterfaceDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_InterfaceDefSeq base_interfaces;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> base_interfaces)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_create_interface ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      base_interfaces,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_interface (
          id.in (),
          name.in (),
          version.in (),
          base_interfaces,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_InterfaceDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_Container::create_value_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl = (POA_CORBA_Container *)_tao_object_reference;
  
    CORBA_ValueDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::Boolean is_custom;
  CORBA::Boolean is_abstract;
  CORBA_ValueDef_var base_value;
  CORBA::Boolean is_truncatable;
  CORBA_ValueDefSeq abstract_base_values;
  CORBA_InterfaceDefSeq supported_interfaces;
  CORBA_InitializerSeq initializers;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> CORBA::Any::to_boolean (is_custom)) &&
    (_tao_in >> CORBA::Any::to_boolean (is_abstract)) &&
    (_tao_in >> base_value.out ()) &&
    (_tao_in >> CORBA::Any::to_boolean (is_truncatable)) &&
    (_tao_in >> abstract_base_values) &&
    (_tao_in >> supported_interfaces) &&
    (_tao_in >> initializers)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_create_value ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      is_custom,
      is_abstract,
      base_value.in (),
      is_truncatable,
      abstract_base_values,
      supported_interfaces,
      initializers,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_value (
          id.in (),
          name.in (),
          version.in (),
          is_custom,
          is_abstract,
          base_value.in (),
          is_truncatable,
          abstract_base_values,
          supported_interfaces,
          initializers,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_ValueDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_Container::create_value_box_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl = (POA_CORBA_Container *)_tao_object_reference;
  
    CORBA_ValueBoxDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_IDLType_var original_type_def;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> original_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_create_value_box ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      original_type_def.in (),
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_value_box (
          id.in (),
          name.in (),
          version.in (),
          original_type_def.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_ValueBoxDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_Container::create_exception_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl = (POA_CORBA_Container *)_tao_object_reference;
  
    CORBA_ExceptionDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_StructMemberSeq members;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_create_exception ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      members,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_exception (
          id.in (),
          name.in (),
          version.in (),
          members,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_ExceptionDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_Container::create_native_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl = (POA_CORBA_Container *)_tao_object_reference;
  
    CORBA_NativeDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_create_native ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_native (
          id.in (),
          name.in (),
          version.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_NativeDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_Container::create_abstract_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl = (POA_CORBA_Container *)_tao_object_reference;
  
    CORBA_AbstractInterfaceDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_AbstractInterfaceDefSeq base_interfaces;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> base_interfaces)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      base_interfaces,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_abstract_interface (
          id.in (),
          name.in (),
          version.in (),
          base_interfaces,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_AbstractInterfaceDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_Container::create_local_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl = (POA_CORBA_Container *)_tao_object_reference;
  
    CORBA_LocalInterfaceDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_InterfaceDefSeq base_interfaces;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> base_interfaces)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_create_local_interface ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      base_interfaces,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_local_interface (
          id.in (),
          name.in (),
          version.in (),
          base_interfaces,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_LocalInterfaceDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_Container::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl = (POA_CORBA_Container *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_Container::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA_Container *_tao_impl = (POA_CORBA_Container *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_Container::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA_Container *_tao_impl = (POA_CORBA_Container *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_CORBA_Container::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA_Container::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA_Container:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA_IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA_Container::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_CORBA_Container::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA_Container:1.0";
}

CORBA_Container*
POA_CORBA_Container::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return ::CORBA_Container::_unchecked_narrow (obj.in ());
}


class TAO_CORBA_IDLType_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 12:14:19 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_IDLType_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_IDLType_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  0, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  0, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_IDLType_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 6,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 0
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_CORBA_IDLType::_is_a_skel},
      {"",0},
      {"destroy", 	&POA_CORBA_IDLType::destroy_skel},
      {"",0},
      {"_get_type", 	&POA_CORBA_IDLType::_get_type_skel},
      {"_interface",  &POA_CORBA_IDLType::_interface_skel},
      {"",0},{"",0},
      {"_get_def_kind", 	&POA_CORBA_IDLType::_get_def_kind_skel},
      {"",0},{"",0},{"",0},{"",0},
      {"_non_existent",  &POA_CORBA_IDLType::_non_existent_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 12:14:19 */
static TAO_CORBA_IDLType_Perfect_Hash_OpTable tao_CORBA_IDLType_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_CORBA_IDLType_type_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_IDLType_type_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_IDLType *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::TypeCode_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_IDLType_type_get (const TAO_ServerRequestInfo_CORBA_IDLType_type_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_IDLType_type_get &);
  
private:
  POA_CORBA_IDLType *_tao_impl;
  CORBA::TypeCode_ptr _result;
};

TAO_ServerRequestInfo_CORBA_IDLType_type_get::TAO_ServerRequestInfo_CORBA_IDLType_type_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_IDLType *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_IDLType_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_IDLType_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_IDLType_type_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_IDLType_type_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_IDLType_type_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_IDLType_type_get::result (CORBA::TypeCode_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
_TAO_CORBA_IDLType_Strategized_Proxy_Broker *_TAO_CORBA_IDLType_Strategized_Proxy_Broker::the_TAO_CORBA_IDLType_Strategized_Proxy_Broker (void)
{
  static _TAO_CORBA_IDLType_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_CORBA_IDLType_Strategized_Proxy_Broker::_TAO_CORBA_IDLType_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

_TAO_CORBA_IDLType_Strategized_Proxy_Broker::~_TAO_CORBA_IDLType_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_CORBA_IDLType_Proxy_Impl&
_TAO_CORBA_IDLType_Strategized_Proxy_Broker::select_proxy (
    ::CORBA_IDLType *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
_TAO_CORBA_IDLType_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_CORBA_IDLType_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_CORBA_IDLType_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_CORBA_IDLType_Proxy_Broker *
_TAO_CORBA_IDLType_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::_TAO_CORBA_IDLType_Strategized_Proxy_Broker::the_TAO_CORBA_IDLType_Strategized_Proxy_Broker();
}

int
_TAO_CORBA_IDLType_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_CORBA_IDLType_Proxy_Broker_Factory_function_pointer = 
    _TAO_CORBA_IDLType_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_CORBA_IDLType_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_CORBA_IDLType_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_CORBA_IDLType_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

_TAO_CORBA_IDLType_ThruPOA_Proxy_Impl::_TAO_CORBA_IDLType_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::TypeCode_ptr _TAO_CORBA_IDLType_ThruPOA_Proxy_Impl::type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_IDLType_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA_IDLType:1.0"
        )
    )->type (
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA_IDLType::POA_CORBA_IDLType (void)
{
  this->optable_ = &tao_CORBA_IDLType_optable;
}

// copy ctor
POA_CORBA_IDLType::POA_CORBA_IDLType (const POA_CORBA_IDLType& rhs)
  :   POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA_IDLType::~POA_CORBA_IDLType (void)
{
}

void POA_CORBA_IDLType::_get_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA_IDLType *_tao_impl = (POA_CORBA_IDLType *)_tao_object_reference;
  
    CORBA::TypeCode_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_IDLType_type_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->type (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::TypeCode_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_IDLType::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_IDLType *_tao_impl = (POA_CORBA_IDLType *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_IDLType::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA_IDLType *_tao_impl = (POA_CORBA_IDLType *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_IDLType::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA_IDLType *_tao_impl = (POA_CORBA_IDLType *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_CORBA_IDLType::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA_IDLType::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA_IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA_IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA_IDLType::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_CORBA_IDLType::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA_IDLType:1.0";
}

CORBA_IDLType*
POA_CORBA_IDLType::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return ::CORBA_IDLType::_unchecked_narrow (obj.in ());
}


class TAO_CORBA_TypedefDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 12:14:19 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_TypedefDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_TypedefDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_TypedefDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 17,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 5
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move", 	&POA_CORBA_TypedefDef::move_skel},
      {"_is_a",  &POA_CORBA_TypedefDef::_is_a_skel},
      {"_get_id", 	&POA_CORBA_TypedefDef::_get_id_skel},
      {"_set_id", 	&POA_CORBA_TypedefDef::_set_id_skel},
      {"describe", 	&POA_CORBA_TypedefDef::describe_skel},
      {"_get_name", 	&POA_CORBA_TypedefDef::_get_name_skel},
      {"_get_type", 	&POA_CORBA_TypedefDef::_get_type_skel},
      {"_set_name", 	&POA_CORBA_TypedefDef::_set_name_skel},
      {"_interface",  &POA_CORBA_TypedefDef::_interface_skel},
      {"_get_version", 	&POA_CORBA_TypedefDef::_get_version_skel},
      {"_set_version", 	&POA_CORBA_TypedefDef::_set_version_skel},
      {"_get_def_kind", 	&POA_CORBA_TypedefDef::_get_def_kind_skel},
      {"_get_defined_in", 	&POA_CORBA_TypedefDef::_get_defined_in_skel},
      {"destroy", 	&POA_CORBA_TypedefDef::destroy_skel},
      {"_get_absolute_name", 	&POA_CORBA_TypedefDef::_get_absolute_name_skel},
      {"_non_existent",  &POA_CORBA_TypedefDef::_non_existent_skel},
      {"_get_containing_repository", 	&POA_CORBA_TypedefDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -9,  -3, -13,  -2,   4,   5,  -1,  48,   8, -45,  12,  -1, -46,  15, 
       -1,  16,  -1,  17,  18,  -6,  -2,  -1,  -1,  19,  -1,  -1,  -1,  -1, 
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  20, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 12:14:19 */
static TAO_CORBA_TypedefDef_Perfect_Hash_OpTable tao_CORBA_TypedefDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
_TAO_CORBA_TypedefDef_Strategized_Proxy_Broker *_TAO_CORBA_TypedefDef_Strategized_Proxy_Broker::the_TAO_CORBA_TypedefDef_Strategized_Proxy_Broker (void)
{
  static _TAO_CORBA_TypedefDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_CORBA_TypedefDef_Strategized_Proxy_Broker::_TAO_CORBA_TypedefDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

_TAO_CORBA_TypedefDef_Strategized_Proxy_Broker::~_TAO_CORBA_TypedefDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_CORBA_TypedefDef_Proxy_Impl&
_TAO_CORBA_TypedefDef_Strategized_Proxy_Broker::select_proxy (
    ::CORBA_TypedefDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
_TAO_CORBA_TypedefDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_CORBA_TypedefDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_CORBA_TypedefDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_CORBA_TypedefDef_Proxy_Broker *
_TAO_CORBA_TypedefDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::_TAO_CORBA_TypedefDef_Strategized_Proxy_Broker::the_TAO_CORBA_TypedefDef_Strategized_Proxy_Broker();
}

int
_TAO_CORBA_TypedefDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_CORBA_TypedefDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_CORBA_TypedefDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_CORBA_TypedefDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_CORBA_TypedefDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_CORBA_TypedefDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

_TAO_CORBA_TypedefDef_ThruPOA_Proxy_Impl::_TAO_CORBA_TypedefDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA_TypedefDef::POA_CORBA_TypedefDef (void)
{
  this->optable_ = &tao_CORBA_TypedefDef_optable;
}

// copy ctor
POA_CORBA_TypedefDef::POA_CORBA_TypedefDef (const POA_CORBA_TypedefDef& rhs)
  :   POA_CORBA_Contained (rhs),
    POA_CORBA_IDLType (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA_TypedefDef::~POA_CORBA_TypedefDef (void)
{
}

void POA_CORBA_TypedefDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_TypedefDef *_tao_impl = (POA_CORBA_TypedefDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_TypedefDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA_TypedefDef *_tao_impl = (POA_CORBA_TypedefDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_TypedefDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA_TypedefDef *_tao_impl = (POA_CORBA_TypedefDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_CORBA_TypedefDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA_TypedefDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA_TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA_Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA_IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA_IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA_TypedefDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_CORBA_TypedefDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA_TypedefDef:1.0";
}

CORBA_TypedefDef*
POA_CORBA_TypedefDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return ::CORBA_TypedefDef::_unchecked_narrow (obj.in ());
}



#endif /* ifndef */
