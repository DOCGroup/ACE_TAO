/* Generated By:JJTree&JavaCC: Do not edit this line. Lexer.java */
package pddl4j.lexer;

import java.io.File;
import pddl4j.ErrorManager;

public class Lexer/* @bgen(jjtree) */implements LexerTreeConstants,
		LexerConstants {/* @bgen(jjtree) */
	protected JJTLexerState jjtree = new JJTLexerState();
	private ErrorManager mgr;
	private File file;

	private static final int[] BLOCKS = { REQUIREMENTS, TYPES, CONSTANTS,
			PREDICATES, FUNCTIONS, ACTION, DURATIVE_ACTION, DERIVED, OBJECTS,
			INIT, GOAL, METRIC, EOF };

	private boolean isBlock(int token) {
		int i = 0;
		while (i < BLOCKS.length && (BLOCKS[i] != token))
			i++;
		return i == BLOCKS.length;
	}

	private void error(Throwable e, int line, int column) throws ParseException {
		String message = new String();
		if (e.getClass().equals(TokenMgrError.class)) {
			String[] tmp = e.getMessage().split(" ");
			int l = -1;
			int c = -1;
			int i = 0;
			for (i = 0; i < tmp.length; i++) {
				if (tmp[i].equals("line") && i + 1 < tmp.length) {
					l = Integer.parseInt(tmp[i + 1].substring(0, tmp[i + 1]
							.length() - 1));
				}
				if (tmp[i].equals("column") && i + 1 < tmp.length) {
					c = Integer.parseInt(tmp[i + 1].substring(0, tmp[i + 1]
							.length() - 1));
				}
			}
			message = e.getMessage().split(".  ")[1];
			this.mgr.logLexicalError(message, this.file, l, c);
		} else if (e.getClass().equals(ParseException.class)) {
			ParseException pe = (ParseException) e;
			message = generateErrorMesssage(pe);
			this.mgr.logLexicalError(message, this.file,
					pe.currentToken.beginLine, pe.currentToken.beginColumn);
		} else if (e instanceof NullPointerException) {
			// Do nothing
		} else {
			e.printStackTrace();
			throw new ParseException(e.getMessage());
		}
		this.skipToNextBlock();
	}

	private void skipToNextBlock() {
		Token t;
		Token t2;
		do {
			t = getNextToken();
			t2 = getToken(2);

		} while (t2 != null && isBlock(t2.kind));
	}

	public void setErrorManager(ErrorManager mgr) {
		this.mgr = mgr;
	}

	public void setFile(File file) {
		this.file = file;
	}

	/**
	 * Creates the error message from a specific parse exception.
	 * 
	 * @param pe
	 *            the parse exception.
	 * @return the error message.
	 */
	private String generateErrorMesssage(ParseException pe) {
		StringBuffer expected = new StringBuffer();
		boolean expectedSeq = false;
		int maxSize = 0;
		for (int i = 0; i < pe.expectedTokenSequences.length; i++) {
			if (maxSize < pe.expectedTokenSequences[i].length) {
				maxSize = pe.expectedTokenSequences[i].length;
			}
			for (int j = 0; j < pe.expectedTokenSequences[i].length; j++) {
				expected.append(pe.tokenImage[pe.expectedTokenSequences[i][j]])
						.append(" ");
				expectedSeq = true;
			}
			if (pe.expectedTokenSequences[i][pe.expectedTokenSequences[i].length - 1] != 0) {
				expected.append("...");
			}
			if (i < pe.expectedTokenSequences.length - 1) {
				expected.append("\n").append("    ");
			}
		}
		String retval = "unexpected token \"" + pe.currentToken.next.image
				+ "\".";
		if (expectedSeq) {
			if (pe.expectedTokenSequences.length == 1) {
				retval += "\nWas expecting:" + "\n" + "    ";
			} else {
				retval += "\nWas expecting one of:" + "\n" + "    ";
			}
			retval += expected.toString();
		}
		return retval;
	}

	final public SimpleNode parse() throws ParseException {
		/* @bgen(jjtree) ROOT */
		SimpleNode jjtn000 = new SimpleNode(this, JJTROOT);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = null;
		try {
			try {
				if (jj_2_1(4)) {
					t = domain();
				} else if (jj_2_2(4)) {
					t = problem();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.mgr.logLexicalError("Lexical error file ("
						+ file.getName() + ") : to many errors", file);
				{
					if (true)
						throw new ParseException(e.getMessage());
				}
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return jjtn000;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token domain() throws ParseException {
		/* @bgen(jjtree) DOMAIN */
		SimpleNode jjtn000 = new SimpleNode(this, JJTDOMAIN);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(DEFINE);
				jj_consume_token(LPAREN);
				jj_consume_token(DOMAIN);
				domain_name();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			try {
				if (jj_2_3(2)) {
					t = require_def();
				} else {
					;
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			try {
				if (jj_2_4(2)) {
					t = type_def();
				} else {
					;
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			try {
				if (jj_2_5(2)) {
					t = constants_def();
				} else {
					;
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			try {
				if (jj_2_6(2)) {
					t = predicates_def();
				} else {
					;
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			try {
				if (jj_2_7(2)) {
					t = functions_def();
				} else {
					;
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			try {
				if (jj_2_8(2)) {
					t = constraints();
				} else {
					;
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			try {
				label_1: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case LPAREN:
						;
						break;
					default:
						jj_la1[0] = jj_gen;
						break label_1;
					}
					t = structure_def();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			try {
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token require_def() throws ParseException {
		/* @bgen(jjtree) REQUIRE_DEF */
		SimpleNode jjtn000 = new SimpleNode(this, JJTREQUIRE_DEF);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(REQUIREMENTS);
				label_2: while (true) {
					require_key();
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case STRIPS:
					case TYPING:
					case NEGATIVE_PRECONDITIONS:
					case DISJUNCTIVE_PRECONDITIONS:
					case EQUALITY:
					case EXISTENTIAL_PRECONDITIONS:
					case UNIVERSAL_PRECONDITIONS:
					case QUANTIFIED_PRECONDITIONS:
					case CONDITIONAL_EFFECTS:
					case FLUENTS:
					case ADL:
					case DURATIVE_ACTIONS:
					case DERIVED_PREDICATES:
					case TIMED_INITIAL_LITERALS:
					case PREFERENCES:
					case CONSTRAINTS:
					case CONTINUS_EFFECTS:
					case DURATION_INEQUALITIES:
						;
						break;
					default:
						jj_la1[1] = jj_gen;
						break label_2;
					}
				}
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token require_key() throws ParseException {
		/* @bgen(jjtree) REQUIRE_KEY */
		SimpleNode jjtn000 = new SimpleNode(this, JJTREQUIRE_KEY);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case STRIPS:
					t = jj_consume_token(STRIPS);
					break;
				case TYPING:
					t = jj_consume_token(TYPING);
					break;
				case NEGATIVE_PRECONDITIONS:
					t = jj_consume_token(NEGATIVE_PRECONDITIONS);
					break;
				case DISJUNCTIVE_PRECONDITIONS:
					t = jj_consume_token(DISJUNCTIVE_PRECONDITIONS);
					break;
				case EQUALITY:
					t = jj_consume_token(EQUALITY);
					break;
				case EXISTENTIAL_PRECONDITIONS:
					t = jj_consume_token(EXISTENTIAL_PRECONDITIONS);
					break;
				case UNIVERSAL_PRECONDITIONS:
					t = jj_consume_token(UNIVERSAL_PRECONDITIONS);
					break;
				case QUANTIFIED_PRECONDITIONS:
					t = jj_consume_token(QUANTIFIED_PRECONDITIONS);
					break;
				case CONDITIONAL_EFFECTS:
					t = jj_consume_token(CONDITIONAL_EFFECTS);
					break;
				case FLUENTS:
					t = jj_consume_token(FLUENTS);
					break;
				case ADL:
					t = jj_consume_token(ADL);
					break;
				case DURATIVE_ACTIONS:
					t = jj_consume_token(DURATIVE_ACTIONS);
					break;
				case DERIVED_PREDICATES:
					t = jj_consume_token(DERIVED_PREDICATES);
					break;
				case TIMED_INITIAL_LITERALS:
					t = jj_consume_token(TIMED_INITIAL_LITERALS);
					break;
				case PREFERENCES:
					t = jj_consume_token(PREFERENCES);
					break;
				case CONSTRAINTS:
					t = jj_consume_token(CONSTRAINTS);
					break;
				case CONTINUS_EFFECTS:
					t = jj_consume_token(CONTINUS_EFFECTS);
					break;
				case DURATION_INEQUALITIES:
					t = jj_consume_token(DURATION_INEQUALITIES);
					break;
				default:
					jj_la1[2] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			jjtn000.setImage(t.image);
			{
				if (true)
					return t;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token type_def() throws ParseException {
		/* @bgen(jjtree) TYPE_DEF */
		SimpleNode jjtn000 = new SimpleNode(this, JJTTYPE_DEF);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(TYPES);
				typed_list(LexerTreeConstants.JJTPRIMITIVE_TYPE);
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token typed_list(int type) throws ParseException {
		/* @bgen(jjtree) TYPED_LIST */
		SimpleNode jjtn000 = new SimpleNode(this, JJTTYPED_LIST);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (type == LexerTreeConstants.JJTPRIMITIVE_TYPE) {
					label_3: while (true) {
						switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
						case NUMBER_TYPE:
						case OBJECT_TYPE:
						case SYMBOL:
							;
							break;
						default:
							jj_la1[3] = jj_gen;
							break label_3;
						}
						t = primitive_type();
					}
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case SUB:
						jj_consume_token(SUB);
						type();
						typed_list(type);
						break;
					default:
						jj_la1[4] = jj_gen;
						;
					}
				} else if (type == LexerTreeConstants.JJTCONSTANT) {
					label_4: while (true) {
						switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
						case SYMBOL:
							;
							break;
						default:
							jj_la1[5] = jj_gen;
							break label_4;
						}
						t = constant();
					}
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case SUB:
						jj_consume_token(SUB);
						type();
						typed_list(type);
						break;
					default:
						jj_la1[6] = jj_gen;
						;
					}
				} else if (type == LexerTreeConstants.JJTVARIABLE) {
					label_5: while (true) {
						switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
						case 104:
							;
							break;
						default:
							jj_la1[7] = jj_gen;
							break label_5;
						}
						t = variable();
					}
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case SUB:
						jj_consume_token(SUB);
						type();
						typed_list(type);
						break;
					default:
						jj_la1[8] = jj_gen;
						;
					}
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			if (t != null) {
				jjtn000.setLine(t.beginLine);
				jjtn000.setColumn(t.beginColumn);
				jjtn000.setTypeId(LexerTreeConstants.JJTVARIABLE);
			}
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token type() throws ParseException {
		/* @bgen(jjtree) TYPE */
		SimpleNode jjtn000 = new SimpleNode(this, JJTTYPE);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case LPAREN:
					t = jj_consume_token(LPAREN);
					jj_consume_token(EITHER);
					label_6: while (true) {
						primitive_type();
						switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
						case NUMBER_TYPE:
						case OBJECT_TYPE:
						case SYMBOL:
							;
							break;
						default:
							jj_la1[9] = jj_gen;
							break label_6;
						}
					}
					jj_consume_token(RPAREN);
					break;
				case NUMBER_TYPE:
				case OBJECT_TYPE:
				case SYMBOL:
					t = primitive_type();
					break;
				default:
					jj_la1[10] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token primitive_type() throws ParseException {
		/* @bgen(jjtree) PRIMITIVE_TYPE */
		SimpleNode jjtn000 = new SimpleNode(this, JJTPRIMITIVE_TYPE);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case OBJECT_TYPE:
				t = jj_consume_token(OBJECT_TYPE);
				break;
			case NUMBER_TYPE:
				t = jj_consume_token(NUMBER_TYPE);
				break;
			case SYMBOL:
				t = jj_consume_token(SYMBOL);
				break;
			default:
				jj_la1[11] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			jjtn000.setImage(t.image);
			{
				if (true)
					return t;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token constants_def() throws ParseException {
		/* @bgen(jjtree) CONSTANT_DEF */
		SimpleNode jjtn000 = new SimpleNode(this, JJTCONSTANT_DEF);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(CONSTANTS);
				typed_list(LexerTreeConstants.JJTCONSTANT);
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token constant() throws ParseException {
		/* @bgen(jjtree) CONSTANT */
		SimpleNode jjtn000 = new SimpleNode(this, JJTCONSTANT);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			t = jj_consume_token(SYMBOL);
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			jjtn000.setImage(t.image);
			{
				if (true)
					return t;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token predicates_def() throws ParseException {
		/* @bgen(jjtree) PREDICATE_DEF */
		SimpleNode jjtn000 = new SimpleNode(this, JJTPREDICATE_DEF);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(PREDICATES);
				label_7: while (true) {
					atomic_formula_skeleton();
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case LPAREN:
						;
						break;
					default:
						jj_la1[12] = jj_gen;
						break label_7;
					}
				}
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token atomic_formula_skeleton() throws ParseException {
		/* @bgen(jjtree) ATOMIC_FORMULA_SKELETON */
		SimpleNode jjtn000 = new SimpleNode(this, JJTATOMIC_FORMULA_SKELETON);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			t = jj_consume_token(LPAREN);
			predicate();
			typed_list(LexerTreeConstants.JJTVARIABLE);
			jj_consume_token(RPAREN);
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token predicate() throws ParseException {
		/* @bgen(jjtree) PREDICATE */
		SimpleNode jjtn000 = new SimpleNode(this, JJTPREDICATE);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case SYMBOL:
				t = jj_consume_token(SYMBOL);
				break;
			case AT:
				t = jj_consume_token(AT);
				break;
			default:
				jj_la1[13] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			jjtn000.setImage(t.image);
			{
				if (true)
					return t;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token variable() throws ParseException {
		/* @bgen(jjtree) VARIABLE */
		SimpleNode jjtn000 = new SimpleNode(this, JJTVARIABLE);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			jj_consume_token(104);
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case SYMBOL:
				t = jj_consume_token(SYMBOL);
				break;
			case OBJECT_TYPE:
				t = jj_consume_token(OBJECT_TYPE);
				break;
			case NUMBER_TYPE:
				t = jj_consume_token(NUMBER_TYPE);
				break;
			default:
				jj_la1[14] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			jjtn000.setImage(t.image);
			{
				if (true)
					return t;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token functions_def() throws ParseException {
		/* @bgen(jjtree) FUNCTION_DEF */
		SimpleNode jjtn000 = new SimpleNode(this, JJTFUNCTION_DEF);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(FUNCTIONS);
				function_typed_list(LexerTreeConstants.JJTATOMIC_FUNCTION_SKELETON);
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token atomic_function_skeleton() throws ParseException {
		/* @bgen(jjtree) ATOMIC_FUNCTION_SKELETON */
		SimpleNode jjtn000 = new SimpleNode(this, JJTATOMIC_FUNCTION_SKELETON);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			t = jj_consume_token(LPAREN);
			functor();
			typed_list(LexerTreeConstants.JJTVARIABLE);
			jj_consume_token(RPAREN);
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token functor() throws ParseException {
		/* @bgen(jjtree) FUNCTOR */
		SimpleNode jjtn000 = new SimpleNode(this, JJTFUNCTOR);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			t = jj_consume_token(SYMBOL);
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			jjtn000.setImage(t.image);
			{
				if (true)
					return t;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token function_typed_list(int type) throws ParseException {
		/* @bgen(jjtree) FUNCTION_TYPED_LIST */
		SimpleNode jjtn000 = new SimpleNode(this, JJTFUNCTION_TYPED_LIST);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			label_8: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case LPAREN:
					;
					break;
				default:
					jj_la1[15] = jj_gen;
					break label_8;
				}
				t = atomic_function_skeleton();
			}
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case SUB:
				jj_consume_token(SUB);
				function_type();
				function_typed_list(type);
				break;
			default:
				jj_la1[16] = jj_gen;
				;
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			if (t != null) {
				jjtn000.setLine(t.beginLine);
				jjtn000.setColumn(t.beginColumn);
			}
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token function_type() throws ParseException {
		/* @bgen(jjtree) FUNCTION_TYPE */
		SimpleNode jjtn000 = new SimpleNode(this, JJTFUNCTION_TYPE);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			t = jj_consume_token(NUMBER_TYPE);
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			jjtn000.setImage(t.image);
			{
				if (true)
					return t;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token con_gd() throws ParseException {
		/* @bgen(jjtree) CON_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTCON_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_9(2)) {
					t = and_con_gd();
				} else if (jj_2_10(2)) {
					t = forall_con_gd();
				} else if (jj_2_11(2)) {
					t = at_end_con_gd();
				} else if (jj_2_12(2)) {
					t = always_con_gd();
				} else if (jj_2_13(2)) {
					t = sometime_con_gd();
				} else if (jj_2_14(2)) {
					t = within_con_gd();
				} else if (jj_2_15(2)) {
					t = at_most_once_con_gd();
				} else if (jj_2_16(2)) {
					t = sometime_after_con_gd();
				} else if (jj_2_17(2)) {
					t = sometime_before_con_gd();
				} else if (jj_2_18(2)) {
					t = always_within_con_gd();
				} else if (jj_2_19(2)) {
					t = hold_during_con_gd();
				} else if (jj_2_20(2)) {
					t = hold_after_con_gd();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token and_con_gd() throws ParseException {
		/* @bgen(jjtree) AND_CON_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTAND_CON_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(AND);
				label_9: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case LPAREN:
						;
						break;
					default:
						jj_la1[17] = jj_gen;
						break label_9;
					}
					con_gd();
				}
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token forall_con_gd() throws ParseException {
		/* @bgen(jjtree) FORALL_CON_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTFORALL_CON_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(FORALL);
				jj_consume_token(LPAREN);
				typed_list(LexerTreeConstants.JJTVARIABLE);
				jj_consume_token(RPAREN);
				con_gd();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token at_end_con_gd() throws ParseException {
		/* @bgen(jjtree) AT_END_CON_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTAT_END_CON_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(AT);
				jj_consume_token(END);
				gd();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token always_con_gd() throws ParseException {
		/* @bgen(jjtree) ALWAYS_CON_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTALWAYS_CON_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(ALWAYS);
				gd();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token sometime_con_gd() throws ParseException {
		/* @bgen(jjtree) SOMETIME_CON_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTSOMETIME_CON_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(SOMETIME);
				gd();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token within_con_gd() throws ParseException {
		/* @bgen(jjtree) WITHIN_CON_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTWITHIN_CON_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(WITHIN);
				jj_consume_token(NUMBER);
				gd();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token at_most_once_con_gd() throws ParseException {
		/* @bgen(jjtree) AT_MOST_ONCE_CON_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTAT_MOST_ONCE_CON_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(AT_MOST_ONCE);
				gd();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token sometime_after_con_gd() throws ParseException {
		/* @bgen(jjtree) SOMETIME_AFTER_CON_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTSOMETIME_AFTER_CON_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(SOMETIME_AFTER);
				gd();
				gd();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token sometime_before_con_gd() throws ParseException {
		/* @bgen(jjtree) SOMETIME_BEFORE_CON_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTSOMETIME_BEFORE_CON_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(SOMETIME_BEFORE);
				gd();
				gd();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token always_within_con_gd() throws ParseException {
		/* @bgen(jjtree) ALWAYS_WITHIN_CON_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTALWAYS_WITHIN_CON_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(ALWAYS_WITHIN);
				jj_consume_token(NUMBER);
				gd();
				gd();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token hold_during_con_gd() throws ParseException {
		/* @bgen(jjtree) HOLD_DURING_CON_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTHOLD_DURING_CON_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(HOLD_DURING);
				jj_consume_token(NUMBER);
				jj_consume_token(NUMBER);
				gd();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token hold_after_con_gd() throws ParseException {
		/* @bgen(jjtree) HOLD_AFTER_CON_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTHOLD_AFTER_CON_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(HOLD_AFTER);
				jj_consume_token(NUMBER);
				gd();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token gd() throws ParseException {
		/* @bgen(jjtree) GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTGD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_21(2)) {
					t = atomic_formula(LexerTreeConstants.JJTTERM);
				} else if (jj_2_22(2)) {
					t = and_gd();
				} else if (jj_2_23(2)) {
					t = or_gd();
				} else if (jj_2_24(2)) {
					t = not_gd();
				} else if (jj_2_25(2)) {
					t = imply_gd();
				} else if (jj_2_26(2)) {
					t = exists_gd();
				} else if (jj_2_27(2)) {
					t = forall_gd();
				} else if (jj_2_28(2)) {
					t = f_comp();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token and_gd() throws ParseException {
		/* @bgen(jjtree) AND_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTAND_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(AND);
				label_10: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case LPAREN:
						;
						break;
					default:
						jj_la1[18] = jj_gen;
						break label_10;
					}
					gd();
				}
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token or_gd() throws ParseException {
		/* @bgen(jjtree) OR_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTOR_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(OR);
				label_11: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case LPAREN:
						;
						break;
					default:
						jj_la1[19] = jj_gen;
						break label_11;
					}
					gd();
				}
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token not_gd() throws ParseException {
		/* @bgen(jjtree) NOT_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTNOT_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(NOT);
				gd();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token imply_gd() throws ParseException {
		/* @bgen(jjtree) IMPLY_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTIMPLY_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(IMPLY);
				gd();
				gd();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token exists_gd() throws ParseException {
		/* @bgen(jjtree) EXISTS_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTEXISTS_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(EXISTS);
				jj_consume_token(LPAREN);
				typed_list(LexerTreeConstants.JJTVARIABLE);
				jj_consume_token(RPAREN);
				gd();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token forall_gd() throws ParseException {
		/* @bgen(jjtree) FORALL_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTFORALL_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(FORALL);
				jj_consume_token(LPAREN);
				typed_list(LexerTreeConstants.JJTVARIABLE);
				jj_consume_token(RPAREN);
				gd();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token atomic_formula(int type) throws ParseException {
		/* @bgen(jjtree) ATOMIC_FORMULA */
		SimpleNode jjtn000 = new SimpleNode(this, JJTATOMIC_FORMULA);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				predicate();
				if (type == LexerTreeConstants.JJTCONSTANT) {
					label_12: while (true) {
						switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
						case SYMBOL:
							;
							break;
						default:
							jj_la1[20] = jj_gen;
							break label_12;
						}
						constant();
					}
					jjtn000.setTypeId(LexerTreeConstants.JJTCONSTANT);
				} else if (type == LexerTreeConstants.JJTTERM) {
					label_13: while (true) {
						switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
						case SYMBOL:
						case 104:
							;
							break;
						default:
							jj_la1[21] = jj_gen;
							break label_13;
						}
						term();
					}
					jjtn000.setTypeId(LexerTreeConstants.JJTTERM);
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token term() throws ParseException {
		/* @bgen(jjtree) TERM */
		SimpleNode jjtn000 = new SimpleNode(this, JJTTERM);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case SYMBOL:
					t = constant();
					break;
				case 104:
					t = variable();
					break;
				default:
					jj_la1[22] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token literal(int type) throws ParseException {
		/* @bgen(jjtree) LITERAL */
		SimpleNode jjtn000 = new SimpleNode(this, JJTLITERAL);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_29(2)) {
					t = atomic_formula(type);
				} else if (jj_2_30(2)) {
					t = not_atomic_formula(type);
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token not_atomic_formula(int type) throws ParseException {
		/* @bgen(jjtree) NOT_ATOMIC_FORMULA */
		SimpleNode jjtn000 = new SimpleNode(this, JJTNOT_ATOMIC_FORMULA);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(NOT);
				atomic_formula(type);
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token f_comp() throws ParseException {
		/* @bgen(jjtree) F_COMP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTF_COMP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = binary_comp();
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token binary_comp() throws ParseException {
		/* @bgen(jjtree) BINARY_COMP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTBINARY_COMP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_31(2)) {
					t = greater_comp();
				} else if (jj_2_32(2)) {
					t = less_comp();
				} else if (jj_2_33(2)) {
					t = greater_equal_comp();
				} else if (jj_2_34(2)) {
					t = less_equal_comp();
				} else if (jj_2_35(2)) {
					t = equal_comp();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token greater_comp() throws ParseException {
		/* @bgen(jjtree) GREATER_COMP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTGREATER_COMP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(GREATER);
				f_exp();
				f_exp();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token greater_equal_comp() throws ParseException {
		/* @bgen(jjtree) GREATER_EQUAL_COMP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTGREATER_EQUAL_COMP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(GEQUAL);
				f_exp();
				f_exp();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token less_equal_comp() throws ParseException {
		/* @bgen(jjtree) LESS_EQUAL_COMP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTLESS_EQUAL_COMP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(LEQUAL);
				f_exp();
				f_exp();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token less_comp() throws ParseException {
		/* @bgen(jjtree) LESS_COMP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTLESS_COMP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(LESS);
				f_exp();
				f_exp();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token equal_comp() throws ParseException {
		/* @bgen(jjtree) EQUAL_COMP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTEQUAL_COMP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(EQUAL);
				f_exp();
				f_exp();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token f_exp() throws ParseException {
		/* @bgen(jjtree) F_EXP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTF_EXP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case NUMBER:
					t = number();
					break;
				default:
					jj_la1[23] = jj_gen;
					if (jj_2_36(2)) {
						t = op();
					} else if (jj_2_37(2)) {
						t = f_head();
					} else if (jj_2_38(2)) {
						t = variable();
					} else {
						jj_consume_token(-1);
						throw new ParseException();
					}
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token number() throws ParseException {
		/* @bgen(jjtree) NUMBER */
		SimpleNode jjtn000 = new SimpleNode(this, JJTNUMBER);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(NUMBER);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			jjtn000.setImage(t.image);
			{
				if (true)
					return t;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token op() throws ParseException {
		/* @bgen(jjtree) OP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTOP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_39(2)) {
					t = binary_operation();
				} else if (jj_2_40(2)) {
					t = unary_op();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token binary_operation() throws ParseException {
		/* @bgen(jjtree) BINARY_OPERATION */
		SimpleNode jjtn000 = new SimpleNode(this, JJTBINARY_OPERATION);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_41(2)) {
					t = add_op();
				} else if (jj_2_42(2)) {
					t = substract_op();
				} else if (jj_2_43(2)) {
					t = multiply_op();
				} else if (jj_2_44(2)) {
					t = divide_op();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token add_op() throws ParseException {
		/* @bgen(jjtree) ADD_OP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTADD_OP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(ADD);
				f_exp();
				f_exp();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token substract_op() throws ParseException {
		/* @bgen(jjtree) SUBSTRACT_OP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTSUBSTRACT_OP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(SUB);
				f_exp();
				f_exp();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token multiply_op() throws ParseException {
		/* @bgen(jjtree) MULTIPLY_OP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTMULTIPLY_OP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(MUL);
				f_exp();
				f_exp();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token divide_op() throws ParseException {
		/* @bgen(jjtree) DIVIDE_OP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTDIVIDE_OP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(DIV);
				f_exp();
				f_exp();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token unary_op() throws ParseException {
		/* @bgen(jjtree) UNARY_OP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTUNARY_OP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(SUB);
				f_exp_da();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token f_head() throws ParseException {
		/* @bgen(jjtree) F_HEAD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTF_HEAD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				functor();
				label_14: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case SYMBOL:
					case 104:
						;
						break;
					default:
						jj_la1[24] = jj_gen;
						break label_14;
					}
					term();
				}
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token structure_def() throws ParseException {
		/* @bgen(jjtree) STRUCTURE_DEF */
		SimpleNode jjtn000 = new SimpleNode(this, JJTSTRUCTURE_DEF);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_45(2)) {
					t = action_def();
				} else if (jj_2_46(2)) {
					t = durative_action_def();
				} else if (jj_2_47(2)) {
					t = derived_def();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token action_def() throws ParseException {
		/* @bgen(jjtree) ACTION_DEF */
		SimpleNode jjtn000 = new SimpleNode(this, JJTACTION_DEF);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(ACTION);
				action_name();
				jj_consume_token(PARAMETERS);
				jj_consume_token(LPAREN);
				typed_list(LexerTreeConstants.JJTVARIABLE);
				jj_consume_token(RPAREN);
				action_def_body();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token action_name() throws ParseException {
		/* @bgen(jjtree) ACTION_NAME */
		SimpleNode jjtn000 = new SimpleNode(this, JJTACTION_NAME);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(SYMBOL);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			jjtn000.setImage(t.image);
			{
				if (true)
					return t;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token action_def_body() throws ParseException {
		/* @bgen(jjtree) ACTION_DEF_BODY */
		SimpleNode jjtn000 = new SimpleNode(this, JJTACTION_DEF_BODY);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(PRECONDITION);
				pre_gd();
				jj_consume_token(EFFECT);
				effect();
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token pre_gd() throws ParseException {
		/* @bgen(jjtree) PRE_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTPRE_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_48(2)) {
					t = empty_or();
				} else if (jj_2_49(2)) {
					t = pref_gd();
				} else if (jj_2_50(2)) {
					t = and_pre_gd();
				} else if (jj_2_51(2)) {
					t = forall_pre_gd();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token empty_or() throws ParseException {
		/* @bgen(jjtree) EMPTY_OR */
		SimpleNode jjtn000 = new SimpleNode(this, JJTEMPTY_OR);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token and_pre_gd() throws ParseException {
		/* @bgen(jjtree) AND_PRE_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTAND_PRE_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(AND);
				label_15: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case LPAREN:
						;
						break;
					default:
						jj_la1[25] = jj_gen;
						break label_15;
					}
					pre_gd();
				}
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token forall_pre_gd() throws ParseException {
		/* @bgen(jjtree) FORALL_PRE_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTFORALL_PRE_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(FORALL);
				jj_consume_token(LPAREN);
				typed_list(LexerTreeConstants.JJTVARIABLE);
				jj_consume_token(RPAREN);
				pre_gd();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token pref_gd() throws ParseException {
		/* @bgen(jjtree) PREF_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTPREF_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_52(2)) {
					t = named_pref_gd();
				} else {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case LPAREN:
						t = gd();
						break;
					default:
						jj_la1[26] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
					}
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token named_pref_gd() throws ParseException {
		/* @bgen(jjtree) NAMED_PREF_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTNAMED_PREF_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(PREFERENCE);
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case SYMBOL:
					pref_name();
					break;
				default:
					jj_la1[27] = jj_gen;
					;
				}
				gd();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token pref_name() throws ParseException {
		/* @bgen(jjtree) PREF_NAME */
		SimpleNode jjtn000 = new SimpleNode(this, JJTPREF_NAME);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(SYMBOL);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token effect() throws ParseException {
		/* @bgen(jjtree) EFFECT */
		SimpleNode jjtn000 = new SimpleNode(this, JJTEFFECT);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_53(2)) {
					t = and_c_effect();
				} else if (jj_2_54(2)) {
					t = c_effect();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token and_c_effect() throws ParseException {
		/* @bgen(jjtree) AND_C_EFFECT */
		SimpleNode jjtn000 = new SimpleNode(this, JJTAND_C_EFFECT);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(AND);
				label_16: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case LPAREN:
						;
						break;
					default:
						jj_la1[28] = jj_gen;
						break label_16;
					}
					c_effect();
				}
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token prob_effect() throws ParseException {
		/* @bgen(jjtree) PROB_EFFECT */
		SimpleNode jjtn000 = new SimpleNode(this, JJTPROB_EFFECT);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(PROB);
				label_17: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case NUMBER:
						;
						break;
					default:
						jj_la1[29] = jj_gen;
						break label_17;
					}
					prob_term();
				}
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token prob_term() throws ParseException {
		/* @bgen(jjtree) PROB_TERM */
		SimpleNode jjtn000 = new SimpleNode(this, JJTPROB_TERM);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_55(3)) {
					t = number();
					c_effect();
				} else if (jj_2_56(3)) {
					t = number();
					and_c_effect();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token c_effect() throws ParseException {
		/* @bgen(jjtree) C_EFFECT */
		SimpleNode jjtn000 = new SimpleNode(this, JJTC_EFFECT);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_57(2)) {
					t = forall_effect();
				} else if (jj_2_58(2)) {
					t = when_con_effect();
				} else if (jj_2_59(2)) {
					t = p_effect();
				} else if (jj_2_60(2)) {
					t = prob_effect();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token forall_effect() throws ParseException {
		/* @bgen(jjtree) FORALL_EFFECT */
		SimpleNode jjtn000 = new SimpleNode(this, JJTFORALL_EFFECT);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(FORALL);
				jj_consume_token(LPAREN);
				typed_list(LexerTreeConstants.JJTVARIABLE);
				jj_consume_token(RPAREN);
				effect();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token when_con_effect() throws ParseException {
		/* @bgen(jjtree) WHEN_CON_EFFECT */
		SimpleNode jjtn000 = new SimpleNode(this, JJTWHEN_CON_EFFECT);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(WHEN);
				gd();
				cond_effect();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token cond_effect() throws ParseException {
		/* @bgen(jjtree) COND_EFFECT */
		SimpleNode jjtn000 = new SimpleNode(this, JJTCOND_EFFECT);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_61(2)) {
					t = and_c_effect();
				} else if (jj_2_62(2)) {
					t = c_effect();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token and_p_effect() throws ParseException {
		/* @bgen(jjtree) AND_P_EFFECT */
		SimpleNode jjtn000 = new SimpleNode(this, JJTAND_P_EFFECT);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(AND);
				label_18: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case LPAREN:
						;
						break;
					default:
						jj_la1[30] = jj_gen;
						break label_18;
					}
					p_effect();
				}
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token p_effect() throws ParseException {
		/* @bgen(jjtree) P_EFFECT */
		SimpleNode jjtn000 = new SimpleNode(this, JJTP_EFFECT);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_63(2)) {
					t = assign_op();
				} else if (jj_2_64(2)) {
					t = literal(LexerTreeConstants.JJTTERM);
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token assign_op() throws ParseException {
		/* @bgen(jjtree) ASSIGN_OP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTASSIGN_OP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_65(2)) {
					t = assign();
				} else if (jj_2_66(2)) {
					t = scale_up();
				} else if (jj_2_67(2)) {
					t = scale_down();
				} else if (jj_2_68(2)) {
					t = increase();
				} else if (jj_2_69(2)) {
					t = decrease();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token assign() throws ParseException {
		/* @bgen(jjtree) ASSIGN */
		SimpleNode jjtn000 = new SimpleNode(this, JJTASSIGN);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(ASSIGN);
				f_head();
				f_exp();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token scale_up() throws ParseException {
		/* @bgen(jjtree) SCALE_UP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTSCALE_UP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(SCALE_UP);
				f_head();
				f_exp();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token scale_down() throws ParseException {
		/* @bgen(jjtree) SCALE_DOWN */
		SimpleNode jjtn000 = new SimpleNode(this, JJTSCALE_DOWN);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(SCALE_DOWN);
				f_head();
				f_exp();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token increase() throws ParseException {
		/* @bgen(jjtree) INCREASE */
		SimpleNode jjtn000 = new SimpleNode(this, JJTINCREASE);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(INCREASE);
				f_head();
				f_exp();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token decrease() throws ParseException {
		/* @bgen(jjtree) DECREASE */
		SimpleNode jjtn000 = new SimpleNode(this, JJTDECREASE);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(DECREASE);
				f_head();
				f_exp();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token durative_action_def() throws ParseException {
		/* @bgen(jjtree) DURATION_ACTION_DEF */
		SimpleNode jjtn000 = new SimpleNode(this, JJTDURATION_ACTION_DEF);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(DURATIVE_ACTION);
				da_symbol();
				jj_consume_token(PARAMETERS);
				jj_consume_token(LPAREN);
				typed_list(LexerTreeConstants.JJTVARIABLE);
				jj_consume_token(RPAREN);
				da_def_body();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token da_symbol() throws ParseException {
		/* @bgen(jjtree) DA_SYMBOL */
		SimpleNode jjtn000 = new SimpleNode(this, JJTDA_SYMBOL);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(SYMBOL);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			jjtn000.setImage(t.image);
			{
				if (true)
					return t;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token da_def_body() throws ParseException {
		/* @bgen(jjtree) DA_DEF_BODY */
		SimpleNode jjtn000 = new SimpleNode(this, JJTDA_DEF_BODY);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(DURATION);
				duration_constraint();
				jj_consume_token(CONDITION);
				da_gd();
				jj_consume_token(EFFECT);
				da_effect();
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token duration_constraint() throws ParseException {
		/* @bgen(jjtree) DURATION_CONSTRAINT */
		SimpleNode jjtn000 = new SimpleNode(this, JJTDURATION_CONSTRAINT);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_70(2)) {
					t = empty_or();
				} else if (jj_2_71(2)) {
					t = and_simple_duration_constraint();
				} else if (jj_2_72(2)) {
					t = simple_duration_constraint();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token and_simple_duration_constraint() throws ParseException {
		/* @bgen(jjtree) AND_SIMPLE_DURATION_CONSTRAINT */
		SimpleNode jjtn000 = new SimpleNode(this,
				JJTAND_SIMPLE_DURATION_CONSTRAINT);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(AND);
				label_19: while (true) {
					simple_duration_constraint();
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case LPAREN:
						;
						break;
					default:
						jj_la1[31] = jj_gen;
						break label_19;
					}
				}
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token simple_duration_constraint() throws ParseException {
		/* @bgen(jjtree) SIMPLE_DURATION_CONSTRAINT */
		SimpleNode jjtn000 = new SimpleNode(this, JJTSIMPLE_DURATION_CONSTRAINT);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_73(2)) {
					t = d_op();
				} else if (jj_2_74(2)) {
					t = at_simple_duration_constraint();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token at_simple_duration_constraint() throws ParseException {
		/* @bgen(jjtree) AT_SIMPLE_DURATION_CONSTRAINT */
		SimpleNode jjtn000 = new SimpleNode(this,
				JJTAT_SIMPLE_DURATION_CONSTRAINT);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_75(3)) {
					t = at_start_simple_duration_constraint();
				} else if (jj_2_76(3)) {
					t = at_end_simple_duration_constraint();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token at_start_simple_duration_constraint()
			throws ParseException {
		/* @bgen(jjtree) AT_START_SIMPLE_DURATION_CONSTRAINT */
		SimpleNode jjtn000 = new SimpleNode(this,
				JJTAT_START_SIMPLE_DURATION_CONSTRAINT);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(AT);
				jj_consume_token(START);
				simple_duration_constraint();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token at_end_simple_duration_constraint()
			throws ParseException {
		/* @bgen(jjtree) AT_END_SIMPLE_DURATION_CONSTRAINT */
		SimpleNode jjtn000 = new SimpleNode(this,
				JJTAT_END_SIMPLE_DURATION_CONSTRAINT);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(AT);
				jj_consume_token(END);
				simple_duration_constraint();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token d_op() throws ParseException {
		/* @bgen(jjtree) D_OP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTD_OP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_77(2)) {
					t = equal_d_op();
				} else if (jj_2_78(2)) {
					t = gequal_d_op();
				} else if (jj_2_79(2)) {
					t = lequal_d_op();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token equal_d_op() throws ParseException {
		/* @bgen(jjtree) EQUAL_D_OP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTEQUAL_D_OP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(EQUAL);
				var_duration();
				d_value();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token gequal_d_op() throws ParseException {
		/* @bgen(jjtree) GEQUAL_D_OP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTGEQUAL_D_OP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(GEQUAL);
				var_duration();
				d_value();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token lequal_d_op() throws ParseException {
		/* @bgen(jjtree) LEQUAL_D_OP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTLEQUAL_D_OP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(LEQUAL);
				var_duration();
				d_value();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token var_duration() throws ParseException {
		/* @bgen(jjtree) VAR_DURATION */
		SimpleNode jjtn000 = new SimpleNode(this, JJTVAR_DURATION);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(VAR_DURATION);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token d_value() throws ParseException {
		/* @bgen(jjtree) D_VALUE */
		SimpleNode jjtn000 = new SimpleNode(this, JJTD_VALUE);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_80(2)) {
					t = number();
				} else if (jj_2_81(2)) {
					t = f_exp();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token da_gd() throws ParseException {
		/* @bgen(jjtree) DA_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTDA_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_82(2)) {
					t = pref_timed_gd();
				} else if (jj_2_83(2)) {
					t = and_da_gd();
				} else if (jj_2_84(2)) {
					t = forall_da_gd();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token forall_da_gd() throws ParseException {
		/* @bgen(jjtree) FORALL_DA_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTFORALL_DA_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(FORALL);
				jj_consume_token(LPAREN);
				typed_list(LexerTreeConstants.JJTVARIABLE);
				jj_consume_token(RPAREN);
				da_gd();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token and_da_gd() throws ParseException {
		/* @bgen(jjtree) AND_DA_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTAND_DA_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(AND);
				label_20: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case LPAREN:
						;
						break;
					default:
						jj_la1[32] = jj_gen;
						break label_20;
					}
					da_gd();
				}
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token pref_timed_gd() throws ParseException {
		/* @bgen(jjtree) PREF_TIMED_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTPREF_TIMED_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_85(2)) {
					t = timed_gd();
				} else if (jj_2_86(2)) {
					t = named_pref_timed_gd();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token named_pref_timed_gd() throws ParseException {
		/* @bgen(jjtree) NAMED_PREF_TIMED_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTNAMED_PREF_TIMED_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(PREFERENCE);
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case SYMBOL:
					pref_name();
					break;
				default:
					jj_la1[33] = jj_gen;
					;
				}
				timed_gd();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token timed_gd() throws ParseException {
		/* @bgen(jjtree) TIMED_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTTIMED_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_87(2)) {
					t = at_timed_gd();
				} else if (jj_2_88(2)) {
					t = over_timed_gd();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token over_timed_gd() throws ParseException {
		/* @bgen(jjtree) OVER_TIMED_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTOVER_TIMED_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = over_all_timed_gd();
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token over_all_timed_gd() throws ParseException {
		/* @bgen(jjtree) OVER_ALL_TIMED_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTOVER_ALL_TIMED_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(OVER);
				jj_consume_token(ALL);
				gd();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token at_timed_gd() throws ParseException {
		/* @bgen(jjtree) AT_TIMED_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTAT_TIMED_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_89(3)) {
					t = at_start_timed_gd();
				} else if (jj_2_90(2)) {
					t = at_end_timed_gd();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token at_start_timed_gd() throws ParseException {
		/* @bgen(jjtree) AT_START_TIMED_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTAT_START_TIMED_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(AT);
				jj_consume_token(START);
				gd();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token at_end_timed_gd() throws ParseException {
		/* @bgen(jjtree) AT_END_TIMED_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTAT_END_TIMED_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(AT);
				jj_consume_token(END);
				gd();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token interval() throws ParseException {
		/* @bgen(jjtree) INTERVAL */
		SimpleNode jjtn000 = new SimpleNode(this, JJTINTERVAL);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(ALL);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token da_effect() throws ParseException {
		/* @bgen(jjtree) DA_EFFECT */
		SimpleNode jjtn000 = new SimpleNode(this, JJTDA_EFFECT);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_91(2)) {
					t = timed_effect();
				} else if (jj_2_92(2)) {
					t = and_da_effect();
				} else if (jj_2_93(2)) {
					t = forall_da_effect();
				} else if (jj_2_94(2)) {
					t = when_da_effect();
				} else if (jj_2_95(2)) {
					t = da_assign_op();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token da_assign_op() throws ParseException {
		/* @bgen(jjtree) DA_ASSIGN_OP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTDA_ASSIGN_OP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_96(2)) {
					t = da_assign();
				} else if (jj_2_97(2)) {
					t = da_scale_up();
				} else if (jj_2_98(2)) {
					t = da_scale_down();
				} else if (jj_2_99(2)) {
					t = da_increase();
				} else if (jj_2_100(2)) {
					t = da_decrease();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token da_assign() throws ParseException {
		/* @bgen(jjtree) DA_ASSIGN */
		SimpleNode jjtn000 = new SimpleNode(this, JJTDA_ASSIGN);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(ASSIGN);
				f_head();
				f_exp_da();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token da_scale_up() throws ParseException {
		/* @bgen(jjtree) DA_SCALE_UP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTDA_SCALE_UP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(SCALE_UP);
				f_head();
				f_exp_da();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token da_scale_down() throws ParseException {
		/* @bgen(jjtree) DA_SCALE_DOWN */
		SimpleNode jjtn000 = new SimpleNode(this, JJTDA_SCALE_DOWN);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(SCALE_DOWN);
				f_head();
				f_exp_da();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token da_increase() throws ParseException {
		/* @bgen(jjtree) DA_INCREASE */
		SimpleNode jjtn000 = new SimpleNode(this, JJTDA_INCREASE);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(INCREASE);
				f_head();
				f_exp_da();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token da_decrease() throws ParseException {
		/* @bgen(jjtree) DA_DECREASE */
		SimpleNode jjtn000 = new SimpleNode(this, JJTDA_DECREASE);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(DECREASE);
				f_head();
				f_exp_da();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token when_da_effect() throws ParseException {
		/* @bgen(jjtree) WHEN_DA_EFFECT */
		SimpleNode jjtn000 = new SimpleNode(this, JJTWHEN_DA_EFFECT);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(WHEN);
				da_gd();
				timed_effect();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token forall_da_effect() throws ParseException {
		/* @bgen(jjtree) FORALL_DA_EFFECT */
		SimpleNode jjtn000 = new SimpleNode(this, JJTFORALL_DA_EFFECT);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(FORALL);
				jj_consume_token(LPAREN);
				typed_list(LexerTreeConstants.JJTVARIABLE);
				jj_consume_token(RPAREN);
				da_effect();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token and_da_effect() throws ParseException {
		/* @bgen(jjtree) AND_DA_EFFECT */
		SimpleNode jjtn000 = new SimpleNode(this, JJTAND_DA_EFFECT);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(AND);
				label_21: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case LPAREN:
						;
						break;
					default:
						jj_la1[34] = jj_gen;
						break label_21;
					}
					da_effect();
				}
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token timed_effect() throws ParseException {
		/* @bgen(jjtree) TIMED_EFFECT */
		SimpleNode jjtn000 = new SimpleNode(this, JJTTIMED_EFFECT);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_101(2)) {
					t = at_da_effect();
				} else if (jj_2_102(2)) {
					t = at_f_assign_da_effect();
				} else if (jj_2_103(2)) {
					t = assign_op_t();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token at_f_assign_da_effect() throws ParseException {
		/* @bgen(jjtree) AT_F_ASSIGN_DA_EFFECT */
		SimpleNode jjtn000 = new SimpleNode(this, JJTAT_F_ASSIGN_DA_EFFECT);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_104(3)) {
					t = at_start_f_assign_da_effect();
				} else if (jj_2_105(3)) {
					t = at_end_f_assign_da_effect();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token at_start_f_assign_da_effect() throws ParseException {
		/* @bgen(jjtree) AT_START_F_ASSIGN_DA_EFFECT */
		SimpleNode jjtn000 = new SimpleNode(this,
				JJTAT_START_F_ASSIGN_DA_EFFECT);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(AT);
				jj_consume_token(START);
				f_assign_da();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token at_end_f_assign_da_effect() throws ParseException {
		/* @bgen(jjtree) AT_END_F_ASSIGN_DA_EFFECT */
		SimpleNode jjtn000 = new SimpleNode(this, JJTAT_END_F_ASSIGN_DA_EFFECT);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(AT);
				jj_consume_token(END);
				f_assign_da();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token at_da_effect() throws ParseException {
		/* @bgen(jjtree) AT_DA_EFFECT */
		SimpleNode jjtn000 = new SimpleNode(this, JJTAT_DA_EFFECT);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_106(4)) {
					t = at_start_da_effect();
				} else if (jj_2_107(4)) {
					t = at_end_da_effect();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token at_start_da_effect() throws ParseException {
		/* @bgen(jjtree) AT_START_DA_EFFECT */
		SimpleNode jjtn000 = new SimpleNode(this, JJTAT_START_DA_EFFECT);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(AT);
				jj_consume_token(START);
				literal(LexerTreeConstants.JJTTERM);
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token at_end_da_effect() throws ParseException {
		/* @bgen(jjtree) AT_END_DA_EFFECT */
		SimpleNode jjtn000 = new SimpleNode(this, JJTAT_END_DA_EFFECT);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(AT);
				jj_consume_token(END);
				literal(LexerTreeConstants.JJTTERM);
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token assign_op_t() throws ParseException {
		/* @bgen(jjtree) ASSIGN_OP_T */
		SimpleNode jjtn000 = new SimpleNode(this, JJTASSIGN_OP_T);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_108(2)) {
					t = increase_assign_op_t();
				} else if (jj_2_109(2)) {
					t = decrease_assign_op_t();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token increase_assign_op_t() throws ParseException {
		/* @bgen(jjtree) INCREASE_ASSIGN_OP_T */
		SimpleNode jjtn000 = new SimpleNode(this, JJTINCREASE_ASSIGN_OP_T);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(INCREASE);
				f_head();
				f_exp_t();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token decrease_assign_op_t() throws ParseException {
		/* @bgen(jjtree) DECREASE_ASSIGN_OP_T */
		SimpleNode jjtn000 = new SimpleNode(this, JJTDECREASE_ASSIGN_OP_T);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(DECREASE);
				f_head();
				f_exp_t();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token f_exp_t() throws ParseException {
		/* @bgen(jjtree) F_EXP_T */
		SimpleNode jjtn000 = new SimpleNode(this, JJTF_EXP_T);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_110(2)) {
					t = jj_consume_token(LPAREN);
					jj_consume_token(MUL);
					continous_variable();
					f_exp();
					jj_consume_token(RPAREN);
				} else if (jj_2_111(2)) {
					t = jj_consume_token(LPAREN);
					jj_consume_token(MUL);
					f_exp();
					continous_variable();
					jj_consume_token(RPAREN);
				} else if (jj_2_112(2)) {
					t = continous_variable();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token continous_variable() throws ParseException {
		/* @bgen(jjtree) CONTINOUS_VARIABLE */
		SimpleNode jjtn000 = new SimpleNode(this, JJTCONTINOUS_VARIABLE);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(CONTINOUS_VARIABLE);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			jjtn000.setImage(t.image);
			{
				if (true)
					return t;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token f_assign_da() throws ParseException {
		/* @bgen(jjtree) F_ASSIGN_DA */
		SimpleNode jjtn000 = new SimpleNode(this, JJTF_ASSIGN_DA);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_113(2)) {
					t = da_assign();
				} else if (jj_2_114(2)) {
					t = da_scale_up();
				} else if (jj_2_115(2)) {
					t = da_scale_down();
				} else if (jj_2_116(2)) {
					t = da_increase();
				} else if (jj_2_117(2)) {
					t = da_decrease();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token f_exp_da() throws ParseException {
		/* @bgen(jjtree) F_EXP_DA */
		SimpleNode jjtn000 = new SimpleNode(this, JJTF_EXP_DA);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_118(3)) {
					t = f_exp();
				} else if (jj_2_119(3)) {
					t = da_binary_op();
				} else if (jj_2_120(3)) {
					t = da_unary_op();
				} else if (jj_2_121(3)) {
					t = var_duration();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token da_binary_op() throws ParseException {
		/* @bgen(jjtree) DA_BINARY_OP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTDA_BINARY_OP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_122(2)) {
					t = da_add_op();
				} else if (jj_2_123(2)) {
					t = da_substract_op();
				} else if (jj_2_124(2)) {
					t = da_multiply_op();
				} else if (jj_2_125(2)) {
					t = da_divide_op();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token da_add_op() throws ParseException {
		/* @bgen(jjtree) DA_ADD_OP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTDA_ADD_OP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(ADD);
				f_head();
				f_exp_da();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token da_substract_op() throws ParseException {
		/* @bgen(jjtree) DA_SUBSTRACT_OP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTDA_SUBSTRACT_OP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(SUB);
				f_head();
				f_exp_da();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token da_multiply_op() throws ParseException {
		/* @bgen(jjtree) DA_MULTIPLY_OP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTDA_MULTIPLY_OP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(MUL);
				f_head();
				f_exp_da();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token da_divide_op() throws ParseException {
		/* @bgen(jjtree) DA_DIVIDE_OP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTDA_DIVIDE_OP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(DIV);
				f_head();
				f_exp_da();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token da_unary_op() throws ParseException {
		/* @bgen(jjtree) DA_UNARY_OP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTDA_UNARY_OP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(SUB);
				f_exp_da();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token derived_def() throws ParseException {
		/* @bgen(jjtree) DERIVED_DEF */
		SimpleNode jjtn000 = new SimpleNode(this, JJTDERIVED_DEF);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(DERIVED);
				atomic_formula(LexerTreeConstants.JJTVARIABLE);
				gd();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token problem() throws ParseException {
		/* @bgen(jjtree) PROBLEM */
		SimpleNode jjtn000 = new SimpleNode(this, JJTPROBLEM);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(DEFINE);
				jj_consume_token(LPAREN);
				jj_consume_token(PROBLEM);
				problem_name();
				jj_consume_token(RPAREN);
				jj_consume_token(LPAREN);
				jj_consume_token(P_DOMAIN);
				domain_name();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			if (jj_2_126(2)) {
				require_def();
			} else {
				;
			}
			if (jj_2_127(2)) {
				object_declaration();
			} else {
				;
			}
			init();
			goal();
			if (jj_2_128(2)) {
				constraints();
			} else {
				;
			}
			if (jj_2_129(2)) {
				metric_spec();
			} else {
				;
			}
			jj_consume_token(RPAREN);
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token problem_name() throws ParseException {
		/* @bgen(jjtree) PROBLEM_NAME */
		SimpleNode jjtn000 = new SimpleNode(this, JJTPROBLEM_NAME);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(SYMBOL);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			jjtn000.setImage(t.image);
			{
				if (true)
					return t;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token domain_name() throws ParseException {
		/* @bgen(jjtree) DOMAIN_NAME */
		SimpleNode jjtn000 = new SimpleNode(this, JJTDOMAIN_NAME);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(SYMBOL);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			jjtn000.setImage(t.image);
			{
				if (true)
					return t;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token object_declaration() throws ParseException {
		/* @bgen(jjtree) OBJECT_DECLARATION */
		SimpleNode jjtn000 = new SimpleNode(this, JJTOBJECT_DECLARATION);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(OBJECTS);
				typed_list(LexerTreeConstants.JJTCONSTANT);
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token init() throws ParseException {
		/* @bgen(jjtree) INIT */
		SimpleNode jjtn000 = new SimpleNode(this, JJTINIT);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(INIT);
				label_22: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case LPAREN:
						;
						break;
					default:
						jj_la1[35] = jj_gen;
						break label_22;
					}
					init_el();
				}
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token init_el() throws ParseException {
		/* @bgen(jjtree) INIT_EL */
		SimpleNode jjtn000 = new SimpleNode(this, JJTINIT_EL);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_130(2)) {
					t = literal(LexerTreeConstants.JJTCONSTANT);
				} else if (jj_2_131(2)) {
					t = equal_init_el();
				} else if (jj_2_132(3)) {
					t = timed_literal();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token equal_init_el() throws ParseException {
		/* @bgen(jjtree) EQUAL_INIT_EL */
		SimpleNode jjtn000 = new SimpleNode(this, JJTEQUAL_INIT_EL);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(EQUALITY);
				f_head();
				number();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token timed_literal() throws ParseException {
		/* @bgen(jjtree) TIMED_LITERAL */
		SimpleNode jjtn000 = new SimpleNode(this, JJTTIMED_LITERAL);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(AT);
				number();
				literal(LexerTreeConstants.JJTCONSTANT);
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token goal() throws ParseException {
		/* @bgen(jjtree) GOAL */
		SimpleNode jjtn000 = new SimpleNode(this, JJTGOAL);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(GOAL);
				pre_gd();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token constraints() throws ParseException {
		/* @bgen(jjtree) CONSTRAINTS */
		SimpleNode jjtn000 = new SimpleNode(this, JJTCONSTRAINTS);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(CONSTRAINTS);
				pref_con_gd();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token pref_con_gd() throws ParseException {
		/* @bgen(jjtree) PREF_CON_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTPREF_CON_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_133(2)) {
					t = and_pref_con_gd();
				} else if (jj_2_134(2)) {
					t = forall_pref_con_gd();
				} else if (jj_2_135(2)) {
					t = named_pref_con_gd();
				} else if (jj_2_136(2)) {
					t = con_gd();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token and_pref_con_gd() throws ParseException {
		/* @bgen(jjtree) AND_PREF_CON_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTAND_PREF_CON_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(AND);
				label_23: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case LPAREN:
						;
						break;
					default:
						jj_la1[36] = jj_gen;
						break label_23;
					}
					pref_con_gd();
				}
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token named_pref_con_gd() throws ParseException {
		/* @bgen(jjtree) NAMED_PREF_CON_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTNAMED_PREF_CON_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(PREFERENCE);
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case SYMBOL:
					pref_name();
					break;
				default:
					jj_la1[37] = jj_gen;
					;
				}
				con_gd();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token forall_pref_con_gd() throws ParseException {
		/* @bgen(jjtree) FORALL_PREF_CON_GD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTFORALL_PREF_CON_GD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(FORALL);
				jj_consume_token(LPAREN);
				typed_list(LexerTreeConstants.JJTVARIABLE);
				jj_consume_token(RPAREN);
				pref_con_gd();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token metric_spec() throws ParseException {
		/* @bgen(jjtree) METRIC_SPEC */
		SimpleNode jjtn000 = new SimpleNode(this, JJTMETRIC_SPEC);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_137(3)) {
					t = maximize();
				} else if (jj_2_138(3)) {
					t = minimize();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token maximize() throws ParseException {
		/* @bgen(jjtree) MAXIMIZE */
		SimpleNode jjtn000 = new SimpleNode(this, JJTMAXIMIZE);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(METRIC);
				jj_consume_token(MAXIMIZE);
				metric_f_exp();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token minimize() throws ParseException {
		/* @bgen(jjtree) MINIMIZE */
		SimpleNode jjtn000 = new SimpleNode(this, JJTMINIMIZE);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(METRIC);
				jj_consume_token(MINIMIZE);
				metric_f_exp();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token metric_f_exp() throws ParseException {
		/* @bgen(jjtree) METRIC_F_EXP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTMETRIC_F_EXP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_139(2)) {
					t = unary_op_metric_f_exp();
				} else if (jj_2_140(2)) {
					t = binary_op_metric_f_exp();
				} else if (jj_2_141(2)) {
					t = multi_op_metric_f_exp();
				} else if (jj_2_142(2)) {
					t = number();
				} else if (jj_2_143(2)) {
					t = constant_f_head();
				} else if (jj_2_144(2)) {
					t = total_time();
				} else if (jj_2_145(2)) {
					t = violated_pref_exp();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token violated_pref_exp() throws ParseException {
		/* @bgen(jjtree) VIOLATED_PREF_EXP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTVIOLATED_PREF_EXP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(IS_VIOLATED);
				pref_name();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token constant_f_head() throws ParseException {
		/* @bgen(jjtree) CONSTANT_F_HEAD */
		SimpleNode jjtn000 = new SimpleNode(this, JJTCONSTANT_F_HEAD);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				functor();
				label_24: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case SYMBOL:
						;
						break;
					default:
						jj_la1[38] = jj_gen;
						break label_24;
					}
					constant();
				}
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token total_time() throws ParseException {
		/* @bgen(jjtree) TOTAL_TIME */
		SimpleNode jjtn000 = new SimpleNode(this, JJTTOTAL_TIME);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(TOTAL_TIME);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token binary_op_metric_f_exp() throws ParseException {
		/* @bgen(jjtree) BINARY_OP_METRIC_F_EXP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTBINARY_OP_METRIC_F_EXP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_146(2)) {
					t = add_op_metric_f_exp();
				} else if (jj_2_147(2)) {
					t = substract_op_metric_f_exp();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token add_op_metric_f_exp() throws ParseException {
		/* @bgen(jjtree) ADD_OP_METRIC_F_EXP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTADD_OP_METRIC_F_EXP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(ADD);
				metric_f_exp();
				metric_f_exp();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token substract_op_metric_f_exp() throws ParseException {
		/* @bgen(jjtree) SUBSTRACT_OP_METRIC_F_EXP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTSUBSTRACT_OP_METRIC_F_EXP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(SUB);
				metric_f_exp();
				metric_f_exp();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token multi_op_metric_f_exp() throws ParseException {
		/* @bgen(jjtree) MULTI_OP_METRIC_F_EXP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTMULTI_OP_METRIC_F_EXP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				if (jj_2_148(2)) {
					t = multiply_narity_op_metric_f_exp();
				} else if (jj_2_149(2)) {
					t = add_narity_op_metric_f_exp();
				} else {
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token multiply_narity_op_metric_f_exp() throws ParseException {
		/* @bgen(jjtree) MULTIPLY_NARITY_OP_METRIC_F_EXP */
		SimpleNode jjtn000 = new SimpleNode(this,
				JJTMULTIPLY_NARITY_OP_METRIC_F_EXP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(MUL);
				metric_f_exp();
				label_25: while (true) {
					metric_f_exp();
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case LPAREN:
					case TOTAL_TIME:
					case NUMBER:
						;
						break;
					default:
						jj_la1[39] = jj_gen;
						break label_25;
					}
				}
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token add_narity_op_metric_f_exp() throws ParseException {
		/* @bgen(jjtree) ADD_NARITY_OP_METRIC_F_EXP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTADD_NARITY_OP_METRIC_F_EXP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(ADD);
				metric_f_exp();
				label_26: while (true) {
					metric_f_exp();
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case LPAREN:
					case TOTAL_TIME:
					case NUMBER:
						;
						break;
					default:
						jj_la1[40] = jj_gen;
						break label_26;
					}
				}
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public Token unary_op_metric_f_exp() throws ParseException {
		/* @bgen(jjtree) UNARY_OP_METRIC_F_EXP */
		SimpleNode jjtn000 = new SimpleNode(this, JJTUNARY_OP_METRIC_F_EXP);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t = token;
		try {
			try {
				t = jj_consume_token(LPAREN);
				jj_consume_token(SUB);
				metric_f_exp();
				jj_consume_token(RPAREN);
			} catch (Throwable e) {
				this.error(e, t.beginLine, t.beginColumn);
				;
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setLine(t.beginLine);
			jjtn000.setColumn(t.beginColumn);
			{
				if (true)
					return t;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	private boolean jj_2_1(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_1();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(0, xla);
		}
	}

	private boolean jj_2_2(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_2();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(1, xla);
		}
	}

	private boolean jj_2_3(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_3();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(2, xla);
		}
	}

	private boolean jj_2_4(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_4();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(3, xla);
		}
	}

	private boolean jj_2_5(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_5();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(4, xla);
		}
	}

	private boolean jj_2_6(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_6();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(5, xla);
		}
	}

	private boolean jj_2_7(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_7();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(6, xla);
		}
	}

	private boolean jj_2_8(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_8();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(7, xla);
		}
	}

	private boolean jj_2_9(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_9();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(8, xla);
		}
	}

	private boolean jj_2_10(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_10();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(9, xla);
		}
	}

	private boolean jj_2_11(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_11();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(10, xla);
		}
	}

	private boolean jj_2_12(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_12();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(11, xla);
		}
	}

	private boolean jj_2_13(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_13();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(12, xla);
		}
	}

	private boolean jj_2_14(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_14();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(13, xla);
		}
	}

	private boolean jj_2_15(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_15();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(14, xla);
		}
	}

	private boolean jj_2_16(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_16();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(15, xla);
		}
	}

	private boolean jj_2_17(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_17();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(16, xla);
		}
	}

	private boolean jj_2_18(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_18();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(17, xla);
		}
	}

	private boolean jj_2_19(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_19();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(18, xla);
		}
	}

	private boolean jj_2_20(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_20();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(19, xla);
		}
	}

	private boolean jj_2_21(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_21();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(20, xla);
		}
	}

	private boolean jj_2_22(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_22();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(21, xla);
		}
	}

	private boolean jj_2_23(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_23();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(22, xla);
		}
	}

	private boolean jj_2_24(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_24();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(23, xla);
		}
	}

	private boolean jj_2_25(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_25();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(24, xla);
		}
	}

	private boolean jj_2_26(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_26();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(25, xla);
		}
	}

	private boolean jj_2_27(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_27();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(26, xla);
		}
	}

	private boolean jj_2_28(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_28();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(27, xla);
		}
	}

	private boolean jj_2_29(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_29();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(28, xla);
		}
	}

	private boolean jj_2_30(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_30();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(29, xla);
		}
	}

	private boolean jj_2_31(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_31();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(30, xla);
		}
	}

	private boolean jj_2_32(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_32();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(31, xla);
		}
	}

	private boolean jj_2_33(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_33();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(32, xla);
		}
	}

	private boolean jj_2_34(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_34();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(33, xla);
		}
	}

	private boolean jj_2_35(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_35();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(34, xla);
		}
	}

	private boolean jj_2_36(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_36();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(35, xla);
		}
	}

	private boolean jj_2_37(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_37();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(36, xla);
		}
	}

	private boolean jj_2_38(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_38();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(37, xla);
		}
	}

	private boolean jj_2_39(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_39();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(38, xla);
		}
	}

	private boolean jj_2_40(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_40();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(39, xla);
		}
	}

	private boolean jj_2_41(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_41();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(40, xla);
		}
	}

	private boolean jj_2_42(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_42();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(41, xla);
		}
	}

	private boolean jj_2_43(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_43();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(42, xla);
		}
	}

	private boolean jj_2_44(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_44();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(43, xla);
		}
	}

	private boolean jj_2_45(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_45();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(44, xla);
		}
	}

	private boolean jj_2_46(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_46();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(45, xla);
		}
	}

	private boolean jj_2_47(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_47();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(46, xla);
		}
	}

	private boolean jj_2_48(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_48();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(47, xla);
		}
	}

	private boolean jj_2_49(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_49();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(48, xla);
		}
	}

	private boolean jj_2_50(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_50();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(49, xla);
		}
	}

	private boolean jj_2_51(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_51();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(50, xla);
		}
	}

	private boolean jj_2_52(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_52();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(51, xla);
		}
	}

	private boolean jj_2_53(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_53();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(52, xla);
		}
	}

	private boolean jj_2_54(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_54();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(53, xla);
		}
	}

	private boolean jj_2_55(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_55();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(54, xla);
		}
	}

	private boolean jj_2_56(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_56();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(55, xla);
		}
	}

	private boolean jj_2_57(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_57();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(56, xla);
		}
	}

	private boolean jj_2_58(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_58();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(57, xla);
		}
	}

	private boolean jj_2_59(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_59();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(58, xla);
		}
	}

	private boolean jj_2_60(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_60();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(59, xla);
		}
	}

	private boolean jj_2_61(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_61();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(60, xla);
		}
	}

	private boolean jj_2_62(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_62();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(61, xla);
		}
	}

	private boolean jj_2_63(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_63();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(62, xla);
		}
	}

	private boolean jj_2_64(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_64();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(63, xla);
		}
	}

	private boolean jj_2_65(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_65();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(64, xla);
		}
	}

	private boolean jj_2_66(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_66();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(65, xla);
		}
	}

	private boolean jj_2_67(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_67();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(66, xla);
		}
	}

	private boolean jj_2_68(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_68();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(67, xla);
		}
	}

	private boolean jj_2_69(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_69();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(68, xla);
		}
	}

	private boolean jj_2_70(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_70();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(69, xla);
		}
	}

	private boolean jj_2_71(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_71();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(70, xla);
		}
	}

	private boolean jj_2_72(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_72();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(71, xla);
		}
	}

	private boolean jj_2_73(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_73();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(72, xla);
		}
	}

	private boolean jj_2_74(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_74();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(73, xla);
		}
	}

	private boolean jj_2_75(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_75();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(74, xla);
		}
	}

	private boolean jj_2_76(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_76();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(75, xla);
		}
	}

	private boolean jj_2_77(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_77();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(76, xla);
		}
	}

	private boolean jj_2_78(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_78();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(77, xla);
		}
	}

	private boolean jj_2_79(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_79();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(78, xla);
		}
	}

	private boolean jj_2_80(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_80();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(79, xla);
		}
	}

	private boolean jj_2_81(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_81();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(80, xla);
		}
	}

	private boolean jj_2_82(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_82();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(81, xla);
		}
	}

	private boolean jj_2_83(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_83();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(82, xla);
		}
	}

	private boolean jj_2_84(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_84();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(83, xla);
		}
	}

	private boolean jj_2_85(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_85();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(84, xla);
		}
	}

	private boolean jj_2_86(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_86();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(85, xla);
		}
	}

	private boolean jj_2_87(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_87();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(86, xla);
		}
	}

	private boolean jj_2_88(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_88();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(87, xla);
		}
	}

	private boolean jj_2_89(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_89();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(88, xla);
		}
	}

	private boolean jj_2_90(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_90();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(89, xla);
		}
	}

	private boolean jj_2_91(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_91();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(90, xla);
		}
	}

	private boolean jj_2_92(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_92();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(91, xla);
		}
	}

	private boolean jj_2_93(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_93();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(92, xla);
		}
	}

	private boolean jj_2_94(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_94();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(93, xla);
		}
	}

	private boolean jj_2_95(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_95();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(94, xla);
		}
	}

	private boolean jj_2_96(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_96();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(95, xla);
		}
	}

	private boolean jj_2_97(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_97();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(96, xla);
		}
	}

	private boolean jj_2_98(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_98();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(97, xla);
		}
	}

	private boolean jj_2_99(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_99();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(98, xla);
		}
	}

	private boolean jj_2_100(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_100();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(99, xla);
		}
	}

	private boolean jj_2_101(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_101();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(100, xla);
		}
	}

	private boolean jj_2_102(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_102();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(101, xla);
		}
	}

	private boolean jj_2_103(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_103();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(102, xla);
		}
	}

	private boolean jj_2_104(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_104();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(103, xla);
		}
	}

	private boolean jj_2_105(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_105();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(104, xla);
		}
	}

	private boolean jj_2_106(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_106();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(105, xla);
		}
	}

	private boolean jj_2_107(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_107();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(106, xla);
		}
	}

	private boolean jj_2_108(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_108();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(107, xla);
		}
	}

	private boolean jj_2_109(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_109();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(108, xla);
		}
	}

	private boolean jj_2_110(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_110();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(109, xla);
		}
	}

	private boolean jj_2_111(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_111();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(110, xla);
		}
	}

	private boolean jj_2_112(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_112();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(111, xla);
		}
	}

	private boolean jj_2_113(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_113();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(112, xla);
		}
	}

	private boolean jj_2_114(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_114();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(113, xla);
		}
	}

	private boolean jj_2_115(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_115();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(114, xla);
		}
	}

	private boolean jj_2_116(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_116();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(115, xla);
		}
	}

	private boolean jj_2_117(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_117();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(116, xla);
		}
	}

	private boolean jj_2_118(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_118();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(117, xla);
		}
	}

	private boolean jj_2_119(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_119();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(118, xla);
		}
	}

	private boolean jj_2_120(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_120();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(119, xla);
		}
	}

	private boolean jj_2_121(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_121();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(120, xla);
		}
	}

	private boolean jj_2_122(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_122();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(121, xla);
		}
	}

	private boolean jj_2_123(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_123();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(122, xla);
		}
	}

	private boolean jj_2_124(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_124();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(123, xla);
		}
	}

	private boolean jj_2_125(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_125();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(124, xla);
		}
	}

	private boolean jj_2_126(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_126();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(125, xla);
		}
	}

	private boolean jj_2_127(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_127();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(126, xla);
		}
	}

	private boolean jj_2_128(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_128();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(127, xla);
		}
	}

	private boolean jj_2_129(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_129();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(128, xla);
		}
	}

	private boolean jj_2_130(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_130();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(129, xla);
		}
	}

	private boolean jj_2_131(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_131();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(130, xla);
		}
	}

	private boolean jj_2_132(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_132();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(131, xla);
		}
	}

	private boolean jj_2_133(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_133();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(132, xla);
		}
	}

	private boolean jj_2_134(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_134();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(133, xla);
		}
	}

	private boolean jj_2_135(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_135();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(134, xla);
		}
	}

	private boolean jj_2_136(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_136();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(135, xla);
		}
	}

	private boolean jj_2_137(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_137();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(136, xla);
		}
	}

	private boolean jj_2_138(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_138();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(137, xla);
		}
	}

	private boolean jj_2_139(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_139();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(138, xla);
		}
	}

	private boolean jj_2_140(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_140();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(139, xla);
		}
	}

	private boolean jj_2_141(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_141();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(140, xla);
		}
	}

	private boolean jj_2_142(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_142();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(141, xla);
		}
	}

	private boolean jj_2_143(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_143();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(142, xla);
		}
	}

	private boolean jj_2_144(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_144();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(143, xla);
		}
	}

	private boolean jj_2_145(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_145();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(144, xla);
		}
	}

	private boolean jj_2_146(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_146();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(145, xla);
		}
	}

	private boolean jj_2_147(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_147();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(146, xla);
		}
	}

	private boolean jj_2_148(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_148();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(147, xla);
		}
	}

	private boolean jj_2_149(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_149();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(148, xla);
		}
	}

	private boolean jj_3R_105() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3_87()) {
			jj_scanpos = xsp;
			if (jj_3_88())
				return true;
		}
		return false;
	}

	private boolean jj_3R_36() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(FORALL))
			return true;
		return false;
	}

	private boolean jj_3R_106() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(PREFERENCE))
			return true;
		return false;
	}

	private boolean jj_3R_35() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(AND))
			return true;
		return false;
	}

	private boolean jj_3_86() {
		if (jj_3R_106())
			return true;
		return false;
	}

	private boolean jj_3_85() {
		if (jj_3R_105())
			return true;
		return false;
	}

	private boolean jj_3R_138() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(OBJECTS))
			return true;
		return false;
	}

	private boolean jj_3_20() {
		if (jj_3R_46())
			return true;
		return false;
	}

	private boolean jj_3_19() {
		if (jj_3R_45())
			return true;
		return false;
	}

	private boolean jj_3_18() {
		if (jj_3R_44())
			return true;
		return false;
	}

	private boolean jj_3_17() {
		if (jj_3R_43())
			return true;
		return false;
	}

	private boolean jj_3R_102() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3_85()) {
			jj_scanpos = xsp;
			if (jj_3_86())
				return true;
		}
		return false;
	}

	private boolean jj_3_16() {
		if (jj_3R_42())
			return true;
		return false;
	}

	private boolean jj_3_15() {
		if (jj_3R_41())
			return true;
		return false;
	}

	private boolean jj_3_14() {
		if (jj_3R_40())
			return true;
		return false;
	}

	private boolean jj_3_13() {
		if (jj_3R_39())
			return true;
		return false;
	}

	private boolean jj_3_12() {
		if (jj_3R_38())
			return true;
		return false;
	}

	private boolean jj_3_11() {
		if (jj_3R_37())
			return true;
		return false;
	}

	private boolean jj_3_10() {
		if (jj_3R_36())
			return true;
		return false;
	}

	private boolean jj_3_9() {
		if (jj_3R_35())
			return true;
		return false;
	}

	private boolean jj_3R_145() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3_9()) {
			jj_scanpos = xsp;
			if (jj_3_10()) {
				jj_scanpos = xsp;
				if (jj_3_11()) {
					jj_scanpos = xsp;
					if (jj_3_12()) {
						jj_scanpos = xsp;
						if (jj_3_13()) {
							jj_scanpos = xsp;
							if (jj_3_14()) {
								jj_scanpos = xsp;
								if (jj_3_15()) {
									jj_scanpos = xsp;
									if (jj_3_16()) {
										jj_scanpos = xsp;
										if (jj_3_17()) {
											jj_scanpos = xsp;
											if (jj_3_18()) {
												jj_scanpos = xsp;
												if (jj_3_19()) {
													jj_scanpos = xsp;
													if (jj_3_20())
														return true;
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		return false;
	}

	private boolean jj_3R_103() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(AND))
			return true;
		return false;
	}

	private boolean jj_3R_70() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(ACTION))
			return true;
		return false;
	}

	private boolean jj_3R_166() {
		if (jj_3R_167())
			return true;
		return false;
	}

	private boolean jj_3_47() {
		if (jj_3R_72())
			return true;
		return false;
	}

	private boolean jj_3_46() {
		if (jj_3R_71())
			return true;
		return false;
	}

	private boolean jj_3_45() {
		if (jj_3R_70())
			return true;
		return false;
	}

	private boolean jj_3R_104() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(FORALL))
			return true;
		return false;
	}

	private boolean jj_3_129() {
		if (jj_3R_139())
			return true;
		return false;
	}

	private boolean jj_3_128() {
		if (jj_3R_34())
			return true;
		return false;
	}

	private boolean jj_3_84() {
		if (jj_3R_104())
			return true;
		return false;
	}

	private boolean jj_3_83() {
		if (jj_3R_103())
			return true;
		return false;
	}

	private boolean jj_3_127() {
		if (jj_3R_138())
			return true;
		return false;
	}

	private boolean jj_3_82() {
		if (jj_3R_102())
			return true;
		return false;
	}

	private boolean jj_3_126() {
		if (jj_3R_29())
			return true;
		return false;
	}

	private boolean jj_3R_28() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(DEFINE))
			return true;
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(PROBLEM))
			return true;
		return false;
	}

	private boolean jj_3R_160() {
		if (jj_scan_token(SYMBOL))
			return true;
		return false;
	}

	private boolean jj_3R_62() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_3R_160())
			return true;
		Token xsp;
		while (true) {
			xsp = jj_scanpos;
			if (jj_3R_166()) {
				jj_scanpos = xsp;
				break;
			}
		}
		if (jj_scan_token(RPAREN))
			return true;
		return false;
	}

	private boolean jj_3_81() {
		if (jj_3R_101())
			return true;
		return false;
	}

	private boolean jj_3_80() {
		if (jj_3R_80())
			return true;
		return false;
	}

	private boolean jj_3R_72() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(DERIVED))
			return true;
		return false;
	}

	private boolean jj_3R_65() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(SUB))
			return true;
		if (jj_3R_164())
			return true;
		return false;
	}

	private boolean jj_3R_132() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(SUB))
			return true;
		if (jj_3R_164())
			return true;
		return false;
	}

	private boolean jj_3R_133() {
		if (jj_scan_token(VAR_DURATION))
			return true;
		return false;
	}

	private boolean jj_3R_33() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(FUNCTIONS))
			return true;
		return false;
	}

	private boolean jj_3R_69() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(DIV))
			return true;
		if (jj_3R_101())
			return true;
		return false;
	}

	private boolean jj_3R_137() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(DIV))
			return true;
		if (jj_3R_62())
			return true;
		return false;
	}

	private boolean jj_3R_63() {
		if (jj_scan_token(104))
			return true;
		Token xsp;
		xsp = jj_scanpos;
		if (jj_scan_token(100)) {
			jj_scanpos = xsp;
			if (jj_scan_token(99)) {
				jj_scanpos = xsp;
				if (jj_scan_token(98))
					return true;
			}
		}
		return false;
	}

	private boolean jj_3R_100() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(LEQUAL))
			return true;
		return false;
	}

	private boolean jj_3R_68() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(MUL))
			return true;
		if (jj_3R_101())
			return true;
		return false;
	}

	private boolean jj_3R_158() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_scan_token(100)) {
			jj_scanpos = xsp;
			if (jj_scan_token(87))
				return true;
		}
		return false;
	}

	private boolean jj_3R_136() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(MUL))
			return true;
		if (jj_3R_62())
			return true;
		return false;
	}

	private boolean jj_3R_99() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(GEQUAL))
			return true;
		return false;
	}

	private boolean jj_3R_67() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(SUB))
			return true;
		if (jj_3R_101())
			return true;
		return false;
	}

	private boolean jj_3R_135() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(SUB))
			return true;
		if (jj_3R_62())
			return true;
		return false;
	}

	private boolean jj_3R_98() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(EQUAL))
			return true;
		return false;
	}

	private boolean jj_3R_66() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(ADD))
			return true;
		if (jj_3R_101())
			return true;
		return false;
	}

	private boolean jj_3R_32() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(PREDICATES))
			return true;
		return false;
	}

	private boolean jj_3_79() {
		if (jj_3R_100())
			return true;
		return false;
	}

	private boolean jj_3_78() {
		if (jj_3R_99())
			return true;
		return false;
	}

	private boolean jj_3_77() {
		if (jj_3R_98())
			return true;
		return false;
	}

	private boolean jj_3_44() {
		if (jj_3R_69())
			return true;
		return false;
	}

	private boolean jj_3R_134() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(ADD))
			return true;
		if (jj_3R_62())
			return true;
		return false;
	}

	private boolean jj_3_43() {
		if (jj_3R_68())
			return true;
		return false;
	}

	private boolean jj_3_42() {
		if (jj_3R_67())
			return true;
		return false;
	}

	private boolean jj_3_41() {
		if (jj_3R_66())
			return true;
		return false;
	}

	private boolean jj_3R_94() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3_77()) {
			jj_scanpos = xsp;
			if (jj_3_78()) {
				jj_scanpos = xsp;
				if (jj_3_79())
					return true;
			}
		}
		return false;
	}

	private boolean jj_3R_170() {
		if (jj_scan_token(SYMBOL))
			return true;
		return false;
	}

	private boolean jj_3_125() {
		if (jj_3R_137())
			return true;
		return false;
	}

	private boolean jj_3_124() {
		if (jj_3R_136())
			return true;
		return false;
	}

	private boolean jj_3_123() {
		if (jj_3R_135())
			return true;
		return false;
	}

	private boolean jj_3_122() {
		if (jj_3R_134())
			return true;
		return false;
	}

	private boolean jj_3R_64() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3_41()) {
			jj_scanpos = xsp;
			if (jj_3_42()) {
				jj_scanpos = xsp;
				if (jj_3_43()) {
					jj_scanpos = xsp;
					if (jj_3_44())
						return true;
				}
			}
		}
		return false;
	}

	private boolean jj_3_40() {
		if (jj_3R_65())
			return true;
		return false;
	}

	private boolean jj_3R_131() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3_122()) {
			jj_scanpos = xsp;
			if (jj_3_123()) {
				jj_scanpos = xsp;
				if (jj_3_124()) {
					jj_scanpos = xsp;
					if (jj_3_125())
						return true;
				}
			}
		}
		return false;
	}

	private boolean jj_3_39() {
		if (jj_3R_64())
			return true;
		return false;
	}

	private boolean jj_3R_97() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(AT))
			return true;
		if (jj_scan_token(END))
			return true;
		return false;
	}

	private boolean jj_3R_31() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(CONSTANTS))
			return true;
		return false;
	}

	private boolean jj_3_121() {
		if (jj_3R_133())
			return true;
		return false;
	}

	private boolean jj_3R_61() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3_39()) {
			jj_scanpos = xsp;
			if (jj_3_40())
				return true;
		}
		return false;
	}

	private boolean jj_3_120() {
		if (jj_3R_132())
			return true;
		return false;
	}

	private boolean jj_3_119() {
		if (jj_3R_131())
			return true;
		return false;
	}

	private boolean jj_3_118() {
		if (jj_3R_101())
			return true;
		return false;
	}

	private boolean jj_3R_96() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(AT))
			return true;
		if (jj_scan_token(START))
			return true;
		return false;
	}

	private boolean jj_3R_164() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3_118()) {
			jj_scanpos = xsp;
			if (jj_3_119()) {
				jj_scanpos = xsp;
				if (jj_3_120()) {
					jj_scanpos = xsp;
					if (jj_3_121())
						return true;
				}
			}
		}
		return false;
	}

	private boolean jj_3_76() {
		if (jj_3R_97())
			return true;
		return false;
	}

	private boolean jj_3_75() {
		if (jj_3R_96())
			return true;
		return false;
	}

	private boolean jj_3_117() {
		if (jj_3R_120())
			return true;
		return false;
	}

	private boolean jj_3R_80() {
		if (jj_scan_token(NUMBER))
			return true;
		return false;
	}

	private boolean jj_3_116() {
		if (jj_3R_119())
			return true;
		return false;
	}

	private boolean jj_3_115() {
		if (jj_3R_118())
			return true;
		return false;
	}

	private boolean jj_3_114() {
		if (jj_3R_117())
			return true;
		return false;
	}

	private boolean jj_3_113() {
		if (jj_3R_116())
			return true;
		return false;
	}

	private boolean jj_3R_95() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3_75()) {
			jj_scanpos = xsp;
			if (jj_3_76())
				return true;
		}
		return false;
	}

	private boolean jj_3_38() {
		if (jj_3R_63())
			return true;
		return false;
	}

	private boolean jj_3_37() {
		if (jj_3R_62())
			return true;
		return false;
	}

	private boolean jj_3_36() {
		if (jj_3R_61())
			return true;
		return false;
	}

	private boolean jj_3R_162() {
		if (jj_3R_80())
			return true;
		return false;
	}

	private boolean jj_3_74() {
		if (jj_3R_95())
			return true;
		return false;
	}

	private boolean jj_3_73() {
		if (jj_3R_94())
			return true;
		return false;
	}

	private boolean jj_3R_101() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_162()) {
			jj_scanpos = xsp;
			if (jj_3_36()) {
				jj_scanpos = xsp;
				if (jj_3_37()) {
					jj_scanpos = xsp;
					if (jj_3_38())
						return true;
				}
			}
		}
		return false;
	}

	private boolean jj_3R_93() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3_73()) {
			jj_scanpos = xsp;
			if (jj_3_74())
				return true;
		}
		return false;
	}

	private boolean jj_3R_130() {
		if (jj_scan_token(CONTINOUS_VARIABLE))
			return true;
		return false;
	}

	private boolean jj_3R_60() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(EQUAL))
			return true;
		return false;
	}

	private boolean jj_3_112() {
		if (jj_3R_130())
			return true;
		return false;
	}

	private boolean jj_3_111() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(MUL))
			return true;
		return false;
	}

	private boolean jj_3_110() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(MUL))
			return true;
		return false;
	}

	private boolean jj_3R_92() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(AND))
			return true;
		return false;
	}

	private boolean jj_3_72() {
		if (jj_3R_93())
			return true;
		return false;
	}

	private boolean jj_3R_30() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(TYPES))
			return true;
		return false;
	}

	private boolean jj_3_71() {
		if (jj_3R_92())
			return true;
		return false;
	}

	private boolean jj_3_70() {
		if (jj_3R_73())
			return true;
		return false;
	}

	private boolean jj_3R_57() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(LESS))
			return true;
		return false;
	}

	private boolean jj_3R_129() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(DECREASE))
			return true;
		return false;
	}

	private boolean jj_3R_59() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(LEQUAL))
			return true;
		return false;
	}

	private boolean jj_3R_128() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(INCREASE))
			return true;
		return false;
	}

	private boolean jj_3R_58() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(GEQUAL))
			return true;
		return false;
	}

	private boolean jj_3_109() {
		if (jj_3R_129())
			return true;
		return false;
	}

	private boolean jj_3_108() {
		if (jj_3R_128())
			return true;
		return false;
	}

	private boolean jj_3R_123() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3_108()) {
			jj_scanpos = xsp;
			if (jj_3_109())
				return true;
		}
		return false;
	}

	private boolean jj_3R_29() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(REQUIREMENTS))
			return true;
		return false;
	}

	private boolean jj_3R_56() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(GREATER))
			return true;
		return false;
	}

	private boolean jj_3_35() {
		if (jj_3R_60())
			return true;
		return false;
	}

	private boolean jj_3_34() {
		if (jj_3R_59())
			return true;
		return false;
	}

	private boolean jj_3_33() {
		if (jj_3R_58())
			return true;
		return false;
	}

	private boolean jj_3_32() {
		if (jj_3R_57())
			return true;
		return false;
	}

	private boolean jj_3_31() {
		if (jj_3R_56())
			return true;
		return false;
	}

	private boolean jj_3R_71() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(DURATIVE_ACTION))
			return true;
		return false;
	}

	private boolean jj_3R_127() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(AT))
			return true;
		if (jj_scan_token(END))
			return true;
		if (jj_3R_86())
			return true;
		return false;
	}

	private boolean jj_3_8() {
		if (jj_3R_34())
			return true;
		return false;
	}

	private boolean jj_3_7() {
		if (jj_3R_33())
			return true;
		return false;
	}

	private boolean jj_3R_159() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3_31()) {
			jj_scanpos = xsp;
			if (jj_3_32()) {
				jj_scanpos = xsp;
				if (jj_3_33()) {
					jj_scanpos = xsp;
					if (jj_3_34()) {
						jj_scanpos = xsp;
						if (jj_3_35())
							return true;
					}
				}
			}
		}
		return false;
	}

	private boolean jj_3_6() {
		if (jj_3R_32())
			return true;
		return false;
	}

	private boolean jj_3R_148() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(SUB))
			return true;
		return false;
	}

	private boolean jj_3R_91() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(DECREASE))
			return true;
		return false;
	}

	private boolean jj_3_5() {
		if (jj_3R_31())
			return true;
		return false;
	}

	private boolean jj_3R_126() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(AT))
			return true;
		if (jj_scan_token(START))
			return true;
		if (jj_3R_86())
			return true;
		return false;
	}

	private boolean jj_3_4() {
		if (jj_3R_30())
			return true;
		return false;
	}

	private boolean jj_3R_54() {
		if (jj_3R_159())
			return true;
		return false;
	}

	private boolean jj_3_107() {
		if (jj_3R_127())
			return true;
		return false;
	}

	private boolean jj_3_3() {
		if (jj_3R_29())
			return true;
		return false;
	}

	private boolean jj_3_106() {
		if (jj_3R_126())
			return true;
		return false;
	}

	private boolean jj_3R_157() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(ADD))
			return true;
		return false;
	}

	private boolean jj_3R_90() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(INCREASE))
			return true;
		return false;
	}

	private boolean jj_3R_121() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3_106()) {
			jj_scanpos = xsp;
			if (jj_3_107())
				return true;
		}
		return false;
	}

	private boolean jj_3R_55() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(NOT))
			return true;
		return false;
	}

	private boolean jj_3R_27() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(DEFINE))
			return true;
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(DOMAIN))
			return true;
		return false;
	}

	private boolean jj_3R_156() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(MUL))
			return true;
		return false;
	}

	private boolean jj_3_30() {
		if (jj_3R_55())
			return true;
		return false;
	}

	private boolean jj_3_29() {
		if (jj_3R_47())
			return true;
		return false;
	}

	private boolean jj_3R_89() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(SCALE_DOWN))
			return true;
		return false;
	}

	private boolean jj_3_2() {
		if (jj_3R_28())
			return true;
		return false;
	}

	private boolean jj_3_1() {
		if (jj_3R_27())
			return true;
		return false;
	}

	private boolean jj_3R_125() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(AT))
			return true;
		if (jj_scan_token(END))
			return true;
		return false;
	}

	private boolean jj_3_149() {
		if (jj_3R_157())
			return true;
		return false;
	}

	private boolean jj_3_148() {
		if (jj_3R_156())
			return true;
		return false;
	}

	private boolean jj_3R_86() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3_29()) {
			jj_scanpos = xsp;
			if (jj_3_30())
				return true;
		}
		return false;
	}

	private boolean jj_3R_150() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3_148()) {
			jj_scanpos = xsp;
			if (jj_3_149())
				return true;
		}
		return false;
	}

	private boolean jj_3R_88() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(SCALE_UP))
			return true;
		return false;
	}

	private boolean jj_3R_169() {
		if (jj_3R_63())
			return true;
		return false;
	}

	private boolean jj_3R_168() {
		if (jj_3R_170())
			return true;
		return false;
	}

	private boolean jj_3R_124() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(AT))
			return true;
		if (jj_scan_token(START))
			return true;
		return false;
	}

	private boolean jj_3R_167() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_168()) {
			jj_scanpos = xsp;
			if (jj_3R_169())
				return true;
		}
		return false;
	}

	private boolean jj_3_105() {
		if (jj_3R_125())
			return true;
		return false;
	}

	private boolean jj_3_104() {
		if (jj_3R_124())
			return true;
		return false;
	}

	private boolean jj_3R_155() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(SUB))
			return true;
		return false;
	}

	private boolean jj_3R_87() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(ASSIGN))
			return true;
		return false;
	}

	private boolean jj_3R_122() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3_104()) {
			jj_scanpos = xsp;
			if (jj_3_105())
				return true;
		}
		return false;
	}

	private boolean jj_3_69() {
		if (jj_3R_91())
			return true;
		return false;
	}

	private boolean jj_3_68() {
		if (jj_3R_90())
			return true;
		return false;
	}

	private boolean jj_3_67() {
		if (jj_3R_89())
			return true;
		return false;
	}

	private boolean jj_3_66() {
		if (jj_3R_88())
			return true;
		return false;
	}

	private boolean jj_3_65() {
		if (jj_3R_87())
			return true;
		return false;
	}

	private boolean jj_3_103() {
		if (jj_3R_123())
			return true;
		return false;
	}

	private boolean jj_3_102() {
		if (jj_3R_122())
			return true;
		return false;
	}

	private boolean jj_3R_154() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(ADD))
			return true;
		return false;
	}

	private boolean jj_3_101() {
		if (jj_3R_121())
			return true;
		return false;
	}

	private boolean jj_3R_47() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_3R_158())
			return true;
		return false;
	}

	private boolean jj_3R_85() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3_65()) {
			jj_scanpos = xsp;
			if (jj_3_66()) {
				jj_scanpos = xsp;
				if (jj_3_67()) {
					jj_scanpos = xsp;
					if (jj_3_68()) {
						jj_scanpos = xsp;
						if (jj_3_69())
							return true;
					}
				}
			}
		}
		return false;
	}

	private boolean jj_3_147() {
		if (jj_3R_155())
			return true;
		return false;
	}

	private boolean jj_3_146() {
		if (jj_3R_154())
			return true;
		return false;
	}

	private boolean jj_3R_111() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3_101()) {
			jj_scanpos = xsp;
			if (jj_3_102()) {
				jj_scanpos = xsp;
				if (jj_3_103())
					return true;
			}
		}
		return false;
	}

	private boolean jj_3_64() {
		if (jj_3R_86())
			return true;
		return false;
	}

	private boolean jj_3_63() {
		if (jj_3R_85())
			return true;
		return false;
	}

	private boolean jj_3R_149() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3_146()) {
			jj_scanpos = xsp;
			if (jj_3_147())
				return true;
		}
		return false;
	}

	private boolean jj_3R_53() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(FORALL))
			return true;
		return false;
	}

	private boolean jj_3R_83() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3_63()) {
			jj_scanpos = xsp;
			if (jj_3_64())
				return true;
		}
		return false;
	}

	private boolean jj_3R_112() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(AND))
			return true;
		return false;
	}

	private boolean jj_3R_152() {
		if (jj_scan_token(TOTAL_TIME))
			return true;
		return false;
	}

	private boolean jj_3R_52() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(EXISTS))
			return true;
		return false;
	}

	private boolean jj_3R_113() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(FORALL))
			return true;
		return false;
	}

	private boolean jj_3_62() {
		if (jj_3R_79())
			return true;
		return false;
	}

	private boolean jj_3_61() {
		if (jj_3R_78())
			return true;
		return false;
	}

	private boolean jj_3R_151() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_3R_160())
			return true;
		return false;
	}

	private boolean jj_3R_51() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(IMPLY))
			return true;
		return false;
	}

	private boolean jj_3R_114() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(WHEN))
			return true;
		return false;
	}

	private boolean jj_3R_153() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(IS_VIOLATED))
			return true;
		return false;
	}

	private boolean jj_3R_50() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(NOT))
			return true;
		return false;
	}

	private boolean jj_3R_82() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(WHEN))
			return true;
		return false;
	}

	private boolean jj_3_145() {
		if (jj_3R_153())
			return true;
		return false;
	}

	private boolean jj_3R_120() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(DECREASE))
			return true;
		return false;
	}

	private boolean jj_3_144() {
		if (jj_3R_152())
			return true;
		return false;
	}

	private boolean jj_3_143() {
		if (jj_3R_151())
			return true;
		return false;
	}

	private boolean jj_3_142() {
		if (jj_3R_80())
			return true;
		return false;
	}

	private boolean jj_3_141() {
		if (jj_3R_150())
			return true;
		return false;
	}

	private boolean jj_3_140() {
		if (jj_3R_149())
			return true;
		return false;
	}

	private boolean jj_3_139() {
		if (jj_3R_148())
			return true;
		return false;
	}

	private boolean jj_3R_49() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(OR))
			return true;
		return false;
	}

	private boolean jj_3R_81() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(FORALL))
			return true;
		return false;
	}

	private boolean jj_3R_119() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(INCREASE))
			return true;
		return false;
	}

	private boolean jj_3_60() {
		if (jj_3R_84())
			return true;
		return false;
	}

	private boolean jj_3R_48() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(AND))
			return true;
		return false;
	}

	private boolean jj_3_59() {
		if (jj_3R_83())
			return true;
		return false;
	}

	private boolean jj_3_58() {
		if (jj_3R_82())
			return true;
		return false;
	}

	private boolean jj_3_57() {
		if (jj_3R_81())
			return true;
		return false;
	}

	private boolean jj_3R_147() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(METRIC))
			return true;
		if (jj_scan_token(MINIMIZE))
			return true;
		return false;
	}

	private boolean jj_3_28() {
		if (jj_3R_54())
			return true;
		return false;
	}

	private boolean jj_3R_118() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(SCALE_DOWN))
			return true;
		return false;
	}

	private boolean jj_3_27() {
		if (jj_3R_53())
			return true;
		return false;
	}

	private boolean jj_3_26() {
		if (jj_3R_52())
			return true;
		return false;
	}

	private boolean jj_3_25() {
		if (jj_3R_51())
			return true;
		return false;
	}

	private boolean jj_3R_79() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3_57()) {
			jj_scanpos = xsp;
			if (jj_3_58()) {
				jj_scanpos = xsp;
				if (jj_3_59()) {
					jj_scanpos = xsp;
					if (jj_3_60())
						return true;
				}
			}
		}
		return false;
	}

	private boolean jj_3_24() {
		if (jj_3R_50())
			return true;
		return false;
	}

	private boolean jj_3_23() {
		if (jj_3R_49())
			return true;
		return false;
	}

	private boolean jj_3_22() {
		if (jj_3R_48())
			return true;
		return false;
	}

	private boolean jj_3_21() {
		if (jj_3R_47())
			return true;
		return false;
	}

	private boolean jj_3R_146() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(METRIC))
			return true;
		if (jj_scan_token(MAXIMIZE))
			return true;
		return false;
	}

	private boolean jj_3R_165() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3_21()) {
			jj_scanpos = xsp;
			if (jj_3_22()) {
				jj_scanpos = xsp;
				if (jj_3_23()) {
					jj_scanpos = xsp;
					if (jj_3_24()) {
						jj_scanpos = xsp;
						if (jj_3_25()) {
							jj_scanpos = xsp;
							if (jj_3_26()) {
								jj_scanpos = xsp;
								if (jj_3_27()) {
									jj_scanpos = xsp;
									if (jj_3_28())
										return true;
								}
							}
						}
					}
				}
			}
		}
		return false;
	}

	private boolean jj_3R_117() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(SCALE_UP))
			return true;
		return false;
	}

	private boolean jj_3_56() {
		if (jj_3R_80())
			return true;
		if (jj_3R_78())
			return true;
		return false;
	}

	private boolean jj_3_55() {
		if (jj_3R_80())
			return true;
		if (jj_3R_79())
			return true;
		return false;
	}

	private boolean jj_3_138() {
		if (jj_3R_147())
			return true;
		return false;
	}

	private boolean jj_3_137() {
		if (jj_3R_146())
			return true;
		return false;
	}

	private boolean jj_3R_139() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3_137()) {
			jj_scanpos = xsp;
			if (jj_3_138())
				return true;
		}
		return false;
	}

	private boolean jj_3R_46() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(HOLD_AFTER))
			return true;
		return false;
	}

	private boolean jj_3R_116() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(ASSIGN))
			return true;
		return false;
	}

	private boolean jj_3R_84() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(PROB))
			return true;
		return false;
	}

	private boolean jj_3_100() {
		if (jj_3R_120())
			return true;
		return false;
	}

	private boolean jj_3_99() {
		if (jj_3R_119())
			return true;
		return false;
	}

	private boolean jj_3_98() {
		if (jj_3R_118())
			return true;
		return false;
	}

	private boolean jj_3_97() {
		if (jj_3R_117())
			return true;
		return false;
	}

	private boolean jj_3_96() {
		if (jj_3R_116())
			return true;
		return false;
	}

	private boolean jj_3R_143() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(FORALL))
			return true;
		return false;
	}

	private boolean jj_3R_45() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(HOLD_DURING))
			return true;
		return false;
	}

	private boolean jj_3R_115() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3_96()) {
			jj_scanpos = xsp;
			if (jj_3_97()) {
				jj_scanpos = xsp;
				if (jj_3_98()) {
					jj_scanpos = xsp;
					if (jj_3_99()) {
						jj_scanpos = xsp;
						if (jj_3_100())
							return true;
					}
				}
			}
		}
		return false;
	}

	private boolean jj_3R_78() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(AND))
			return true;
		return false;
	}

	private boolean jj_3_95() {
		if (jj_3R_115())
			return true;
		return false;
	}

	private boolean jj_3_94() {
		if (jj_3R_114())
			return true;
		return false;
	}

	private boolean jj_3_93() {
		if (jj_3R_113())
			return true;
		return false;
	}

	private boolean jj_3R_144() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(PREFERENCE))
			return true;
		return false;
	}

	private boolean jj_3_92() {
		if (jj_3R_112())
			return true;
		return false;
	}

	private boolean jj_3_54() {
		if (jj_3R_79())
			return true;
		return false;
	}

	private boolean jj_3_91() {
		if (jj_3R_111())
			return true;
		return false;
	}

	private boolean jj_3R_44() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(ALWAYS_WITHIN))
			return true;
		return false;
	}

	private boolean jj_3_53() {
		if (jj_3R_78())
			return true;
		return false;
	}

	private boolean jj_3R_142() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(AND))
			return true;
		return false;
	}

	private boolean jj_3R_43() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(SOMETIME_BEFORE))
			return true;
		return false;
	}

	private boolean jj_3_136() {
		if (jj_3R_145())
			return true;
		return false;
	}

	private boolean jj_3_135() {
		if (jj_3R_144())
			return true;
		return false;
	}

	private boolean jj_3_134() {
		if (jj_3R_143())
			return true;
		return false;
	}

	private boolean jj_3_133() {
		if (jj_3R_142())
			return true;
		return false;
	}

	private boolean jj_3R_42() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(SOMETIME_AFTER))
			return true;
		return false;
	}

	private boolean jj_3R_110() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(AT))
			return true;
		return false;
	}

	private boolean jj_3R_77() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(PREFERENCE))
			return true;
		return false;
	}

	private boolean jj_3R_41() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(AT_MOST_ONCE))
			return true;
		return false;
	}

	private boolean jj_3R_34() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(CONSTRAINTS))
			return true;
		return false;
	}

	private boolean jj_3R_161() {
		if (jj_3R_165())
			return true;
		return false;
	}

	private boolean jj_3_52() {
		if (jj_3R_77())
			return true;
		return false;
	}

	private boolean jj_3R_109() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(AT))
			return true;
		if (jj_scan_token(START))
			return true;
		return false;
	}

	private boolean jj_3R_74() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3_52()) {
			jj_scanpos = xsp;
			if (jj_3R_161())
				return true;
		}
		return false;
	}

	private boolean jj_3_90() {
		if (jj_3R_110())
			return true;
		return false;
	}

	private boolean jj_3R_40() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(WITHIN))
			return true;
		return false;
	}

	private boolean jj_3_89() {
		if (jj_3R_109())
			return true;
		return false;
	}

	private boolean jj_3R_107() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3_89()) {
			jj_scanpos = xsp;
			if (jj_3_90())
				return true;
		}
		return false;
	}

	private boolean jj_3R_76() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(FORALL))
			return true;
		return false;
	}

	private boolean jj_3R_39() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(SOMETIME))
			return true;
		return false;
	}

	private boolean jj_3R_141() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(AT))
			return true;
		if (jj_3R_80())
			return true;
		return false;
	}

	private boolean jj_3R_163() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(OVER))
			return true;
		return false;
	}

	private boolean jj_3R_75() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(AND))
			return true;
		return false;
	}

	private boolean jj_3R_38() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(ALWAYS))
			return true;
		return false;
	}

	private boolean jj_3R_140() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(EQUALITY))
			return true;
		return false;
	}

	private boolean jj_3_132() {
		if (jj_3R_141())
			return true;
		return false;
	}

	private boolean jj_3R_108() {
		if (jj_3R_163())
			return true;
		return false;
	}

	private boolean jj_3_131() {
		if (jj_3R_140())
			return true;
		return false;
	}

	private boolean jj_3_130() {
		if (jj_3R_86())
			return true;
		return false;
	}

	private boolean jj_3R_73() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(RPAREN))
			return true;
		return false;
	}

	private boolean jj_3R_37() {
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_scan_token(AT))
			return true;
		return false;
	}

	private boolean jj_3_88() {
		if (jj_3R_108())
			return true;
		return false;
	}

	private boolean jj_3_87() {
		if (jj_3R_107())
			return true;
		return false;
	}

	private boolean jj_3_51() {
		if (jj_3R_76())
			return true;
		return false;
	}

	private boolean jj_3_50() {
		if (jj_3R_75())
			return true;
		return false;
	}

	private boolean jj_3_49() {
		if (jj_3R_74())
			return true;
		return false;
	}

	private boolean jj_3_48() {
		if (jj_3R_73())
			return true;
		return false;
	}

	/** Generated Token Manager. */
	public LexerTokenManager token_source;
	SimpleCharStream jj_input_stream;
	/** Current token. */
	public Token token;
	/** Next token. */
	public Token jj_nt;
	private int jj_ntk;
	private Token jj_scanpos, jj_lastpos;
	private int jj_la;
	private int jj_gen;
	final private int[] jj_la1 = new int[41];
	static private int[] jj_la1_0;
	static private int[] jj_la1_1;
	static private int[] jj_la1_2;
	static private int[] jj_la1_3;
	static {
		jj_la1_init_0();
		jj_la1_init_1();
		jj_la1_init_2();
		jj_la1_init_3();
	}

	private static void jj_la1_init_0() {
		jj_la1_0 = new int[] { 0x2000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x2000, 0x0, 0x2000, 0x0, 0x0, 0x2000, 0x0, 0x2000,
				0x2000, 0x2000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2000, 0x2000, 0x0,
				0x2000, 0x0, 0x2000, 0x2000, 0x2000, 0x0, 0x2000, 0x2000,
				0x2000, 0x0, 0x0, 0x2000, 0x2000, };
	}

	private static void jj_la1_init_1() {
		jj_la1_1 = new int[] { 0x0, 0x3ffff00, 0x3ffff00, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, };
	}

	private static void jj_la1_init_2() {
		jj_la1_2 = new int[] { 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x4, 0x0, 0x4,
				0x0, 0x0, 0x0, 0x0, 0x800000, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10000000, 0x10000000, };
	}

	private static void jj_la1_init_3() {
		jj_la1_3 = new int[] { 0x0, 0x0, 0x0, 0x1c, 0x0, 0x10, 0x0, 0x100, 0x0,
				0x1c, 0x1c, 0x1c, 0x0, 0x10, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x10, 0x110, 0x110, 0x20, 0x110, 0x0, 0x0, 0x10, 0x0, 0x20,
				0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x10, 0x10, 0x20, 0x20, };
	}

	final private JJCalls[] jj_2_rtns = new JJCalls[149];
	private boolean jj_rescan = false;
	private int jj_gc = 0;

	/** Constructor with InputStream. */
	public Lexer(java.io.InputStream stream) {
		this(stream, null);
	}

	/** Constructor with InputStream and supplied encoding */
	public Lexer(java.io.InputStream stream, String encoding) {
		try {
			jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
		} catch (java.io.UnsupportedEncodingException e) {
			throw new RuntimeException(e);
		}
		token_source = new LexerTokenManager(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 41; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	/** Reinitialise. */
	public void ReInit(java.io.InputStream stream) {
		ReInit(stream, null);
	}

	/** Reinitialise. */
	public void ReInit(java.io.InputStream stream, String encoding) {
		try {
			jj_input_stream.ReInit(stream, encoding, 1, 1);
		} catch (java.io.UnsupportedEncodingException e) {
			throw new RuntimeException(e);
		}
		token_source.ReInit(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jjtree.reset();
		jj_gen = 0;
		for (int i = 0; i < 41; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	/** Constructor. */
	public Lexer(java.io.Reader stream) {
		jj_input_stream = new SimpleCharStream(stream, 1, 1);
		token_source = new LexerTokenManager(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 41; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	/** Reinitialise. */
	public void ReInit(java.io.Reader stream) {
		jj_input_stream.ReInit(stream, 1, 1);
		token_source.ReInit(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jjtree.reset();
		jj_gen = 0;
		for (int i = 0; i < 41; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	/** Constructor with generated Token Manager. */
	public Lexer(LexerTokenManager tm) {
		token_source = tm;
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 41; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	/** Reinitialise. */
	public void ReInit(LexerTokenManager tm) {
		token_source = tm;
		token = new Token();
		jj_ntk = -1;
		jjtree.reset();
		jj_gen = 0;
		for (int i = 0; i < 41; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	private Token jj_consume_token(int kind) throws ParseException {
		Token oldToken;
		if ((oldToken = token).next != null)
			token = token.next;
		else
			token = token.next = token_source.getNextToken();
		jj_ntk = -1;
		if (token.kind == kind) {
			jj_gen++;
			if (++jj_gc > 100) {
				jj_gc = 0;
				for (int i = 0; i < jj_2_rtns.length; i++) {
					JJCalls c = jj_2_rtns[i];
					while (c != null) {
						if (c.gen < jj_gen)
							c.first = null;
						c = c.next;
					}
				}
			}
			return token;
		}
		token = oldToken;
		jj_kind = kind;
		throw generateParseException();
	}

	static private final class LookaheadSuccess extends java.lang.Error {
	}

	final private LookaheadSuccess jj_ls = new LookaheadSuccess();

	private boolean jj_scan_token(int kind) {
		if (jj_scanpos == jj_lastpos) {
			jj_la--;
			if (jj_scanpos.next == null) {
				jj_lastpos = jj_scanpos = jj_scanpos.next = token_source
						.getNextToken();
			} else {
				jj_lastpos = jj_scanpos = jj_scanpos.next;
			}
		} else {
			jj_scanpos = jj_scanpos.next;
		}
		if (jj_rescan) {
			int i = 0;
			Token tok = token;
			while (tok != null && tok != jj_scanpos) {
				i++;
				tok = tok.next;
			}
			if (tok != null)
				jj_add_error_token(kind, i);
		}
		if (jj_scanpos.kind != kind)
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			throw jj_ls;
		return false;
	}

	/** Get the next Token. */
	final public Token getNextToken() {
		if (token.next != null)
			token = token.next;
		else
			token = token.next = token_source.getNextToken();
		jj_ntk = -1;
		jj_gen++;
		return token;
	}

	/** Get the specific Token. */
	final public Token getToken(int index) {
		Token t = token;
		for (int i = 0; i < index; i++) {
			if (t.next != null)
				t = t.next;
			else
				t = t.next = token_source.getNextToken();
		}
		return t;
	}

	private int jj_ntk() {
		if ((jj_nt = token.next) == null)
			return (jj_ntk = (token.next = token_source.getNextToken()).kind);
		else
			return (jj_ntk = jj_nt.kind);
	}

	private java.util.List jj_expentries = new java.util.ArrayList();
	private int[] jj_expentry;
	private int jj_kind = -1;
	private int[] jj_lasttokens = new int[100];
	private int jj_endpos;

	private void jj_add_error_token(int kind, int pos) {
		if (pos >= 100)
			return;
		if (pos == jj_endpos + 1) {
			jj_lasttokens[jj_endpos++] = kind;
		} else if (jj_endpos != 0) {
			jj_expentry = new int[jj_endpos];
			for (int i = 0; i < jj_endpos; i++) {
				jj_expentry[i] = jj_lasttokens[i];
			}
			jj_entries_loop: for (java.util.Iterator it = jj_expentries
					.iterator(); it.hasNext();) {
				int[] oldentry = (int[]) (it.next());
				if (oldentry.length == jj_expentry.length) {
					for (int i = 0; i < jj_expentry.length; i++) {
						if (oldentry[i] != jj_expentry[i]) {
							continue jj_entries_loop;
						}
					}
					jj_expentries.add(jj_expentry);
					break jj_entries_loop;
				}
			}
			if (pos != 0)
				jj_lasttokens[(jj_endpos = pos) - 1] = kind;
		}
	}

	/** Generate ParseException. */
	public ParseException generateParseException() {
		jj_expentries.clear();
		boolean[] la1tokens = new boolean[105];
		if (jj_kind >= 0) {
			la1tokens[jj_kind] = true;
			jj_kind = -1;
		}
		for (int i = 0; i < 41; i++) {
			if (jj_la1[i] == jj_gen) {
				for (int j = 0; j < 32; j++) {
					if ((jj_la1_0[i] & (1 << j)) != 0) {
						la1tokens[j] = true;
					}
					if ((jj_la1_1[i] & (1 << j)) != 0) {
						la1tokens[32 + j] = true;
					}
					if ((jj_la1_2[i] & (1 << j)) != 0) {
						la1tokens[64 + j] = true;
					}
					if ((jj_la1_3[i] & (1 << j)) != 0) {
						la1tokens[96 + j] = true;
					}
				}
			}
		}
		for (int i = 0; i < 105; i++) {
			if (la1tokens[i]) {
				jj_expentry = new int[1];
				jj_expentry[0] = i;
				jj_expentries.add(jj_expentry);
			}
		}
		jj_endpos = 0;
		jj_rescan_token();
		jj_add_error_token(0, 0);
		int[][] exptokseq = new int[jj_expentries.size()][];
		for (int i = 0; i < jj_expentries.size(); i++) {
			exptokseq[i] = (int[]) jj_expentries.get(i);
		}
		return new ParseException(token, exptokseq, tokenImage);
	}

	/** Enable tracing. */
	final public void enable_tracing() {
	}

	/** Disable tracing. */
	final public void disable_tracing() {
	}

	private void jj_rescan_token() {
		jj_rescan = true;
		for (int i = 0; i < 149; i++) {
			try {
				JJCalls p = jj_2_rtns[i];
				do {
					if (p.gen > jj_gen) {
						jj_la = p.arg;
						jj_lastpos = jj_scanpos = p.first;
						switch (i) {
						case 0:
							jj_3_1();
							break;
						case 1:
							jj_3_2();
							break;
						case 2:
							jj_3_3();
							break;
						case 3:
							jj_3_4();
							break;
						case 4:
							jj_3_5();
							break;
						case 5:
							jj_3_6();
							break;
						case 6:
							jj_3_7();
							break;
						case 7:
							jj_3_8();
							break;
						case 8:
							jj_3_9();
							break;
						case 9:
							jj_3_10();
							break;
						case 10:
							jj_3_11();
							break;
						case 11:
							jj_3_12();
							break;
						case 12:
							jj_3_13();
							break;
						case 13:
							jj_3_14();
							break;
						case 14:
							jj_3_15();
							break;
						case 15:
							jj_3_16();
							break;
						case 16:
							jj_3_17();
							break;
						case 17:
							jj_3_18();
							break;
						case 18:
							jj_3_19();
							break;
						case 19:
							jj_3_20();
							break;
						case 20:
							jj_3_21();
							break;
						case 21:
							jj_3_22();
							break;
						case 22:
							jj_3_23();
							break;
						case 23:
							jj_3_24();
							break;
						case 24:
							jj_3_25();
							break;
						case 25:
							jj_3_26();
							break;
						case 26:
							jj_3_27();
							break;
						case 27:
							jj_3_28();
							break;
						case 28:
							jj_3_29();
							break;
						case 29:
							jj_3_30();
							break;
						case 30:
							jj_3_31();
							break;
						case 31:
							jj_3_32();
							break;
						case 32:
							jj_3_33();
							break;
						case 33:
							jj_3_34();
							break;
						case 34:
							jj_3_35();
							break;
						case 35:
							jj_3_36();
							break;
						case 36:
							jj_3_37();
							break;
						case 37:
							jj_3_38();
							break;
						case 38:
							jj_3_39();
							break;
						case 39:
							jj_3_40();
							break;
						case 40:
							jj_3_41();
							break;
						case 41:
							jj_3_42();
							break;
						case 42:
							jj_3_43();
							break;
						case 43:
							jj_3_44();
							break;
						case 44:
							jj_3_45();
							break;
						case 45:
							jj_3_46();
							break;
						case 46:
							jj_3_47();
							break;
						case 47:
							jj_3_48();
							break;
						case 48:
							jj_3_49();
							break;
						case 49:
							jj_3_50();
							break;
						case 50:
							jj_3_51();
							break;
						case 51:
							jj_3_52();
							break;
						case 52:
							jj_3_53();
							break;
						case 53:
							jj_3_54();
							break;
						case 54:
							jj_3_55();
							break;
						case 55:
							jj_3_56();
							break;
						case 56:
							jj_3_57();
							break;
						case 57:
							jj_3_58();
							break;
						case 58:
							jj_3_59();
							break;
						case 59:
							jj_3_60();
							break;
						case 60:
							jj_3_61();
							break;
						case 61:
							jj_3_62();
							break;
						case 62:
							jj_3_63();
							break;
						case 63:
							jj_3_64();
							break;
						case 64:
							jj_3_65();
							break;
						case 65:
							jj_3_66();
							break;
						case 66:
							jj_3_67();
							break;
						case 67:
							jj_3_68();
							break;
						case 68:
							jj_3_69();
							break;
						case 69:
							jj_3_70();
							break;
						case 70:
							jj_3_71();
							break;
						case 71:
							jj_3_72();
							break;
						case 72:
							jj_3_73();
							break;
						case 73:
							jj_3_74();
							break;
						case 74:
							jj_3_75();
							break;
						case 75:
							jj_3_76();
							break;
						case 76:
							jj_3_77();
							break;
						case 77:
							jj_3_78();
							break;
						case 78:
							jj_3_79();
							break;
						case 79:
							jj_3_80();
							break;
						case 80:
							jj_3_81();
							break;
						case 81:
							jj_3_82();
							break;
						case 82:
							jj_3_83();
							break;
						case 83:
							jj_3_84();
							break;
						case 84:
							jj_3_85();
							break;
						case 85:
							jj_3_86();
							break;
						case 86:
							jj_3_87();
							break;
						case 87:
							jj_3_88();
							break;
						case 88:
							jj_3_89();
							break;
						case 89:
							jj_3_90();
							break;
						case 90:
							jj_3_91();
							break;
						case 91:
							jj_3_92();
							break;
						case 92:
							jj_3_93();
							break;
						case 93:
							jj_3_94();
							break;
						case 94:
							jj_3_95();
							break;
						case 95:
							jj_3_96();
							break;
						case 96:
							jj_3_97();
							break;
						case 97:
							jj_3_98();
							break;
						case 98:
							jj_3_99();
							break;
						case 99:
							jj_3_100();
							break;
						case 100:
							jj_3_101();
							break;
						case 101:
							jj_3_102();
							break;
						case 102:
							jj_3_103();
							break;
						case 103:
							jj_3_104();
							break;
						case 104:
							jj_3_105();
							break;
						case 105:
							jj_3_106();
							break;
						case 106:
							jj_3_107();
							break;
						case 107:
							jj_3_108();
							break;
						case 108:
							jj_3_109();
							break;
						case 109:
							jj_3_110();
							break;
						case 110:
							jj_3_111();
							break;
						case 111:
							jj_3_112();
							break;
						case 112:
							jj_3_113();
							break;
						case 113:
							jj_3_114();
							break;
						case 114:
							jj_3_115();
							break;
						case 115:
							jj_3_116();
							break;
						case 116:
							jj_3_117();
							break;
						case 117:
							jj_3_118();
							break;
						case 118:
							jj_3_119();
							break;
						case 119:
							jj_3_120();
							break;
						case 120:
							jj_3_121();
							break;
						case 121:
							jj_3_122();
							break;
						case 122:
							jj_3_123();
							break;
						case 123:
							jj_3_124();
							break;
						case 124:
							jj_3_125();
							break;
						case 125:
							jj_3_126();
							break;
						case 126:
							jj_3_127();
							break;
						case 127:
							jj_3_128();
							break;
						case 128:
							jj_3_129();
							break;
						case 129:
							jj_3_130();
							break;
						case 130:
							jj_3_131();
							break;
						case 131:
							jj_3_132();
							break;
						case 132:
							jj_3_133();
							break;
						case 133:
							jj_3_134();
							break;
						case 134:
							jj_3_135();
							break;
						case 135:
							jj_3_136();
							break;
						case 136:
							jj_3_137();
							break;
						case 137:
							jj_3_138();
							break;
						case 138:
							jj_3_139();
							break;
						case 139:
							jj_3_140();
							break;
						case 140:
							jj_3_141();
							break;
						case 141:
							jj_3_142();
							break;
						case 142:
							jj_3_143();
							break;
						case 143:
							jj_3_144();
							break;
						case 144:
							jj_3_145();
							break;
						case 145:
							jj_3_146();
							break;
						case 146:
							jj_3_147();
							break;
						case 147:
							jj_3_148();
							break;
						case 148:
							jj_3_149();
							break;
						}
					}
					p = p.next;
				} while (p != null);
			} catch (LookaheadSuccess ls) {
			}
		}
		jj_rescan = false;
	}

	private void jj_save(int index, int xla) {
		JJCalls p = jj_2_rtns[index];
		while (p.gen > jj_gen) {
			if (p.next == null) {
				p = p.next = new JJCalls();
				break;
			}
			p = p.next;
		}
		p.gen = jj_gen + xla - jj_la;
		p.first = token;
		p.arg = xla;
	}

	static final class JJCalls {
		int gen;
		Token first;
		int arg;
		JJCalls next;
	}

}