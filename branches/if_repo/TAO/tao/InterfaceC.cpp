/* -*- C++ -*- $Id$ */

// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO and the TAO IDL Compiler have been developed by the Center for
// Distributed Object Computing at Washington University, St. Louis.
//
// Information about TAO is available at:
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

#include "InterfaceC.h"
#include "tao/Stub.h"
#include "tao/Invocation.h"

#if (TAO_HAS_INTERFACE_REPOSITORY == 1)

#if !defined (__ACE_INLINE__)
#include "InterfaceC.i"
#endif /* !defined INLINE */

static const CORBA::Long _oc_IR_Identifier[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
  11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

};
static CORBA::TypeCode _tc_TAO_tc_IR_Identifier (CORBA::tk_alias, sizeof (_oc_IR_Identifier), (char *) &_oc_IR_Identifier, 0, sizeof (IR::Identifier));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Identifier, &_tc_TAO_tc_IR_Identifier)
TAO_NAMESPACE_END
static const CORBA::Long _oc_IR_ScopedName[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x636f7065), ACE_NTOHL (0x644e616d), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ScopedName:1.0
  11, ACE_NTOHL (0x53636f70), ACE_NTOHL (0x65644e61), ACE_NTOHL (0x6d650000),  // name = ScopedName
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5363), ACE_NTOHL (0x6f706564), ACE_NTOHL (0x4e616d65), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/ScopedName:1.0
    11, ACE_NTOHL (0x53636f70), ACE_NTOHL (0x65644e61), ACE_NTOHL (0x6d650000),  // name = ScopedName
    CORBA::tk_string, 
    0U, // string length

};
static CORBA::TypeCode _tc_TAO_tc_IR_ScopedName (CORBA::tk_alias, sizeof (_oc_IR_ScopedName), (char *) &_oc_IR_ScopedName, 0, sizeof (IR::ScopedName));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ScopedName, &_tc_TAO_tc_IR_ScopedName)
TAO_NAMESPACE_END
static const CORBA::Long _oc_IR_RepositoryId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
  13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

};
static CORBA::TypeCode _tc_TAO_tc_IR_RepositoryId (CORBA::tk_alias, sizeof (_oc_IR_RepositoryId), (char *) &_oc_IR_RepositoryId, 0, sizeof (IR::RepositoryId));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RepositoryId, &_tc_TAO_tc_IR_RepositoryId)
TAO_NAMESPACE_END
static const CORBA::Long _oc_IR_DefinitionKind[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f44), ACE_NTOHL (0x6566696e), ACE_NTOHL (0x6974696f), ACE_NTOHL (0x6e4b696e), ACE_NTOHL (0x643a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/DefinitionKind:1.0
  15, ACE_NTOHL (0x44656669), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x6f6e4b69), ACE_NTOHL (0x6e640000),  // name = DefinitionKind
  34, // member count
  8, ACE_NTOHL (0x646b5f6e), ACE_NTOHL (0x6f6e6500),  // name = dk_none
  7, ACE_NTOHL (0x646b5f61), ACE_NTOHL (0x6c6c0000),  // name = dk_all
  13, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x0),  // name = dk_Attribute
  12, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6e7374), ACE_NTOHL (0x616e7400),  // name = dk_Constant
  13, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Exception
  13, ACE_NTOHL (0x646b5f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x0),  // name = dk_Interface
  10, ACE_NTOHL (0x646b5f4d), ACE_NTOHL (0x6f64756c), ACE_NTOHL (0x65000000),  // name = dk_Module
  13, ACE_NTOHL (0x646b5f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Operation
  11, ACE_NTOHL (0x646b5f54), ACE_NTOHL (0x79706564), ACE_NTOHL (0x65660000),  // name = dk_Typedef
  9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x6c696173), ACE_NTOHL (0x0),  // name = dk_Alias
  10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x74000000),  // name = dk_Struct
  9, ACE_NTOHL (0x646b5f55), ACE_NTOHL (0x6e696f6e), ACE_NTOHL (0x0),  // name = dk_Union
  8, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x6e756d00),  // name = dk_Enum
  13, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x72696d69), ACE_NTOHL (0x74697665), ACE_NTOHL (0x0),  // name = dk_Primitive
  10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x7472696e), ACE_NTOHL (0x67000000),  // name = dk_String
  12, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x65717565), ACE_NTOHL (0x6e636500),  // name = dk_Sequence
  9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x72726179), ACE_NTOHL (0x0),  // name = dk_Array
  14, ACE_NTOHL (0x646b5f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79000000),  // name = dk_Repository
  11, ACE_NTOHL (0x646b5f57), ACE_NTOHL (0x73747269), ACE_NTOHL (0x6e670000),  // name = dk_Wstring
  9, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x69786564), ACE_NTOHL (0x0),  // name = dk_Fixed
  9, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x0),  // name = dk_Value
  12, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x426f7800),  // name = dk_ValueBox
  15, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65720000),  // name = dk_ValueMember
  10, ACE_NTOHL (0x646b5f4e), ACE_NTOHL (0x61746976), ACE_NTOHL (0x65000000),  // name = dk_Native
  13, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6d706f), ACE_NTOHL (0x6e656e74), ACE_NTOHL (0x0),  // name = dk_Component
  8, ACE_NTOHL (0x646b5f48), ACE_NTOHL (0x6f6d6500),  // name = dk_Home
  11, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x6163746f), ACE_NTOHL (0x72790000),  // name = dk_Factory
  10, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x696e6465), ACE_NTOHL (0x72000000),  // name = dk_Finder
  14, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x72696d61), ACE_NTOHL (0x72794b65), ACE_NTOHL (0x79000000),  // name = dk_PrimaryKey
  9, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x6d697473), ACE_NTOHL (0x0),  // name = dk_Emits
  13, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x75626c69), ACE_NTOHL (0x73686573), ACE_NTOHL (0x0),  // name = dk_Publishes
  12, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6e7375), ACE_NTOHL (0x6d657300),  // name = dk_Consumes
  12, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657300),  // name = dk_Provides
  8, ACE_NTOHL (0x646b5f55), ACE_NTOHL (0x73657300),  // name = dk_Uses
};
static CORBA::TypeCode _tc_TAO_tc_IR_DefinitionKind (CORBA::tk_enum, sizeof (_oc_IR_DefinitionKind), (char *) &_oc_IR_DefinitionKind, 0, sizeof (IR::DefinitionKind));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_DefinitionKind, &_tc_TAO_tc_IR_DefinitionKind)
TAO_NAMESPACE_END
void CORBA::IRObject::_tao_any_destructor (void *x)
{
  IRObject *tmp = ACE_static_cast (IRObject*,x);
  CORBA::release (tmp);
}

CORBA::IRObject_ptr CORBA::IRObject::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IRObject::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:CORBA/IRObject:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (IRObject::_nil ());
  if (is_a == 0)
    return IRObject::_nil ();
  return IRObject::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::IRObject_ptr CORBA::IRObject::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IRObject::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  IRObject_ptr default_proxy = IRObject::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_IRObject_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_CORBA_IRObject_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, IRObject (stub), IRObject::_nil ());
  return TAO_CORBA_IRObject_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

CORBA::IRObject_ptr 
CORBA::IRObject::_duplicate (IRObject_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::DefinitionKind CORBA::IRObject::def_kind (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::DefinitionKind _tao_retval = (CORBA::DefinitionKind)0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_def_kind",
      13,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN  (_tao_retval);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN  (_tao_retval);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_def_kind",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_retval)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_def_kind",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_def_kind",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN  (_tao_retval);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_retval;
}

void CORBA::IRObject::destroy (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "destroy",
      7,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "destroy",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "destroy",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "destroy",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::Boolean CORBA::IRObject::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA::IRObject::_interface_repository_id (void) const
{
  return "IDL:CORBA/IRObject:1.0";
}

CORBA::TAO_CORBA_IRObject_Default_Proxy_Factory::TAO_CORBA_IRObject_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_CORBA_IRObject_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

CORBA::TAO_CORBA_IRObject_Default_Proxy_Factory::~TAO_CORBA_IRObject_Default_Proxy_Factory (void)
{
}

CORBA::IRObject_ptr
CORBA::TAO_CORBA_IRObject_Default_Proxy_Factory::create_proxy (
    ::CORBA::IRObject_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

CORBA::TAO_CORBA_IRObject_Proxy_Factory_Adapter::TAO_CORBA_IRObject_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

CORBA::TAO_CORBA_IRObject_Proxy_Factory_Adapter::~TAO_CORBA_IRObject_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
CORBA::TAO_CORBA_IRObject_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_CORBA_IRObject_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
CORBA::TAO_CORBA_IRObject_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

CORBA::IRObject_ptr
CORBA::TAO_CORBA_IRObject_Proxy_Factory_Adapter::create_proxy (
    ::CORBA::IRObject_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_CORBA_IRObject_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

CORBA::TAO_CORBA_IRObject_Smart_Proxy_Base::TAO_CORBA_IRObject_Smart_Proxy_Base (::CORBA::IRObject_ptr proxy)
: base_proxy_ (proxy)
{
}

CORBA::TAO_CORBA_IRObject_Smart_Proxy_Base::~TAO_CORBA_IRObject_Smart_Proxy_Base (void)
{
}

TAO_Stub *
CORBA::TAO_CORBA_IRObject_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

CORBA::DefinitionKind CORBA::TAO_CORBA_IRObject_Smart_Proxy_Base::def_kind  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->def_kind (
      ACE_TRY_ENV
    );

}

void CORBA::TAO_CORBA_IRObject_Smart_Proxy_Base::destroy  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->destroy (
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<CORBA::TAO_CORBA_IRObject_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<CORBA::TAO_CORBA_IRObject_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_CORBA_IRObject[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4952), ACE_NTOHL (0x4f626a65), ACE_NTOHL (0x63743a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/IRObject:1.0
  9, ACE_NTOHL (0x49524f62), ACE_NTOHL (0x6a656374), ACE_NTOHL (0x0),  // name = IRObject
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_IRObject (CORBA::tk_objref, sizeof (_oc_CORBA_IRObject), (char *) &_oc_CORBA_IRObject, 0, sizeof (CORBA_IRObject));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_IRObject, &_tc_TAO_tc_CORBA_IRObject)
TAO_NAMESPACE_END
static const CORBA::Long _oc_IR_VersionSpec[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
  12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
  CORBA::tk_string, 
  0U, // string length
};
static CORBA::TypeCode _tc_TAO_tc_IR_VersionSpec (CORBA::tk_alias, sizeof (_oc_IR_VersionSpec), (char *) &_oc_IR_VersionSpec, 0, sizeof (IR::VersionSpec));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_VersionSpec, &_tc_TAO_tc_IR_VersionSpec)
TAO_NAMESPACE_END
void IR::Contained::_tao_any_destructor (void *x)
{
  Contained *tmp = ACE_static_cast (Contained*,x);
  CORBA::release (tmp);
}

IR::Contained_ptr IR::Contained::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return Contained::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/Contained:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (Contained::_nil ());
  if (is_a == 0)
    return Contained::_nil ();
  return Contained::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::Contained_ptr IR::Contained::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return Contained::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  Contained_ptr default_proxy = Contained::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_Contained_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_Contained_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, Contained (stub), Contained::_nil ());
  return TAO_IR_Contained_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::Contained_ptr 
IR::Contained::_duplicate (Contained_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

char * IR::Contained::id (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::String_var _tao_safe_retval;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_id",
      7,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_id",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_id",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_id",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

void IR::Contained::id (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_id",
      7,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_id",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_id",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_id",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

char * IR::Contained::name (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::String_var _tao_safe_retval;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_name",
      9,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_name",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_name",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_name",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

void IR::Contained::name (
    const char * name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_name",
      9,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_name",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << name)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_name",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_name",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

char * IR::Contained::version (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::String_var _tao_safe_retval;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_version",
      12,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_version",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_version",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_version",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

void IR::Contained::version (
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_version",
      12,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_version",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << version)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_version",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_version",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

IR::Container_ptr IR::Contained::defined_in (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::Container_ptr _tao_retval = IR::Container::_nil ();
  IR::Container_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_defined_in",
      15,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_defined_in",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_defined_in",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_defined_in",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

char * IR::Contained::absolute_name (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::String_var _tao_safe_retval;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_absolute_name",
      18,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_absolute_name",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_absolute_name",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_absolute_name",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::Repository_ptr IR::Contained::containing_repository (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::Repository_ptr _tao_retval = IR::Repository::_nil ();
  IR::Repository_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_containing_repository",
      26,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_containing_repository",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_containing_repository",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_containing_repository",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

static const CORBA::Long _oc_IR_Contained_Description[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  41, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7461), ACE_NTOHL (0x696e6564), ACE_NTOHL (0x2f446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/Contained/Description:1.0
  12, ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = Description
  2, // member count
  5, ACE_NTOHL (0x6b696e64), ACE_NTOHL (0x0),  // name = kind
  CORBA::tk_enum, // typecode kind
  632, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f44), ACE_NTOHL (0x6566696e), ACE_NTOHL (0x6974696f), ACE_NTOHL (0x6e4b696e), ACE_NTOHL (0x643a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/DefinitionKind:1.0
    15, ACE_NTOHL (0x44656669), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x6f6e4b69), ACE_NTOHL (0x6e640000),  // name = DefinitionKind
    34, // member count
    8, ACE_NTOHL (0x646b5f6e), ACE_NTOHL (0x6f6e6500),  // name = dk_none
    7, ACE_NTOHL (0x646b5f61), ACE_NTOHL (0x6c6c0000),  // name = dk_all
    13, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x0),  // name = dk_Attribute
    12, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6e7374), ACE_NTOHL (0x616e7400),  // name = dk_Constant
    13, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Exception
    13, ACE_NTOHL (0x646b5f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x0),  // name = dk_Interface
    10, ACE_NTOHL (0x646b5f4d), ACE_NTOHL (0x6f64756c), ACE_NTOHL (0x65000000),  // name = dk_Module
    13, ACE_NTOHL (0x646b5f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Operation
    11, ACE_NTOHL (0x646b5f54), ACE_NTOHL (0x79706564), ACE_NTOHL (0x65660000),  // name = dk_Typedef
    9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x6c696173), ACE_NTOHL (0x0),  // name = dk_Alias
    10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x74000000),  // name = dk_Struct
    9, ACE_NTOHL (0x646b5f55), ACE_NTOHL (0x6e696f6e), ACE_NTOHL (0x0),  // name = dk_Union
    8, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x6e756d00),  // name = dk_Enum
    13, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x72696d69), ACE_NTOHL (0x74697665), ACE_NTOHL (0x0),  // name = dk_Primitive
    10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x7472696e), ACE_NTOHL (0x67000000),  // name = dk_String
    12, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x65717565), ACE_NTOHL (0x6e636500),  // name = dk_Sequence
    9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x72726179), ACE_NTOHL (0x0),  // name = dk_Array
    14, ACE_NTOHL (0x646b5f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79000000),  // name = dk_Repository
    11, ACE_NTOHL (0x646b5f57), ACE_NTOHL (0x73747269), ACE_NTOHL (0x6e670000),  // name = dk_Wstring
    9, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x69786564), ACE_NTOHL (0x0),  // name = dk_Fixed
    9, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x0),  // name = dk_Value
    12, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x426f7800),  // name = dk_ValueBox
    15, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65720000),  // name = dk_ValueMember
    10, ACE_NTOHL (0x646b5f4e), ACE_NTOHL (0x61746976), ACE_NTOHL (0x65000000),  // name = dk_Native
    13, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6d706f), ACE_NTOHL (0x6e656e74), ACE_NTOHL (0x0),  // name = dk_Component
    8, ACE_NTOHL (0x646b5f48), ACE_NTOHL (0x6f6d6500),  // name = dk_Home
    11, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x6163746f), ACE_NTOHL (0x72790000),  // name = dk_Factory
    10, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x696e6465), ACE_NTOHL (0x72000000),  // name = dk_Finder
    14, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x72696d61), ACE_NTOHL (0x72794b65), ACE_NTOHL (0x79000000),  // name = dk_PrimaryKey
    9, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x6d697473), ACE_NTOHL (0x0),  // name = dk_Emits
    13, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x75626c69), ACE_NTOHL (0x73686573), ACE_NTOHL (0x0),  // name = dk_Publishes
    12, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6e7375), ACE_NTOHL (0x6d657300),  // name = dk_Consumes
    12, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657300),  // name = dk_Provides
    8, ACE_NTOHL (0x646b5f55), ACE_NTOHL (0x73657300),  // name = dk_Uses

  6, ACE_NTOHL (0x76616c75), ACE_NTOHL (0x65000000),  // name = value
  CORBA::tk_any,

};
static CORBA::TypeCode _tc_TAO_tc_IR_Contained_Description (CORBA::tk_struct, sizeof (_oc_IR_Contained_Description), (char *) &_oc_IR_Contained_Description, 0, sizeof (IR::Contained::Description));
CORBA::TypeCode_ptr IR::Contained::_tc_Description = &_tc_TAO_tc_IR_Contained_Description;

void IR::Contained::Description::_tao_any_destructor (void *x)
{
  Description *tmp = ACE_static_cast (Description*,x);
  delete tmp;
}

IR::Contained::Description * IR::Contained::describe (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::Contained::Description *_tao_retval = 0;
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR::Contained::Description, _tao_retval);
  IR::Contained::Description_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "describe",
      8,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "describe",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "describe",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "describe",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

void IR::Contained::move (
    IR::Container_ptr new_container,
    const char * new_name,
    const char * new_version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "move",
      4,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "move",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << new_container) &&
              (_tao_out << new_name) &&
              (_tao_out << new_version)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "move",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "move",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::Boolean IR::Contained::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::Contained::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/Contained:1.0";
}

IR::TAO_IR_Contained_Default_Proxy_Factory::TAO_IR_Contained_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_Contained_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_Contained_Default_Proxy_Factory::~TAO_IR_Contained_Default_Proxy_Factory (void)
{
}

IR::Contained_ptr
IR::TAO_IR_Contained_Default_Proxy_Factory::create_proxy (
    ::IR::Contained_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_Contained_Proxy_Factory_Adapter::TAO_IR_Contained_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_Contained_Proxy_Factory_Adapter::~TAO_IR_Contained_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_Contained_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_Contained_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_Contained_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::Contained_ptr
IR::TAO_IR_Contained_Proxy_Factory_Adapter::create_proxy (
    ::IR::Contained_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_Contained_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_Contained_Smart_Proxy_Base::TAO_IR_Contained_Smart_Proxy_Base (::IR::Contained_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_Contained_Smart_Proxy_Base::~TAO_IR_Contained_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_Contained_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

char * IR::TAO_IR_Contained_Smart_Proxy_Base::id  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->id (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_Contained_Smart_Proxy_Base::id  (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->id (
      id,
      ACE_TRY_ENV
    );

}

char * IR::TAO_IR_Contained_Smart_Proxy_Base::name  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->name (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_Contained_Smart_Proxy_Base::name  (
    const char * name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->name (
      name,
      ACE_TRY_ENV
    );

}

char * IR::TAO_IR_Contained_Smart_Proxy_Base::version  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->version (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_Contained_Smart_Proxy_Base::version  (
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->version (
      version,
      ACE_TRY_ENV
    );

}

IR::Container_ptr IR::TAO_IR_Contained_Smart_Proxy_Base::defined_in  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->defined_in (
      ACE_TRY_ENV
    );

}

char * IR::TAO_IR_Contained_Smart_Proxy_Base::absolute_name  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->absolute_name (
      ACE_TRY_ENV
    );

}

IR::Repository_ptr IR::TAO_IR_Contained_Smart_Proxy_Base::containing_repository  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->containing_repository (
      ACE_TRY_ENV
    );

}

IR::Contained::Description * IR::TAO_IR_Contained_Smart_Proxy_Base::describe  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->describe (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_Contained_Smart_Proxy_Base::move  (
    IR::Container_ptr new_container,
    const char * new_name,
    const char * new_version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->move (
      new_container,
      new_name,
      new_version,
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_Contained_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_Contained_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_Contained[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7461), ACE_NTOHL (0x696e6564), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/Contained:1.0
  10, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x64000000),  // name = Contained
};
static CORBA::TypeCode _tc_TAO_tc_IR_Contained (CORBA::tk_objref, sizeof (_oc_IR_Contained), (char *) &_oc_IR_Contained, 0, sizeof (IR::Contained));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Contained, &_tc_TAO_tc_IR_Contained)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_INTERFACEDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_INTERFACEDEFSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::InterfaceDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::InterfaceDef **old = ACE_reinterpret_cast (IR::InterfaceDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = IR::InterfaceDef::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR::InterfaceDef **tmp = ACE_reinterpret_cast (IR::InterfaceDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::InterfaceDef::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  IR::_TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::~_TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR::InterfaceDef **tmp = ACE_reinterpret_cast (IR::InterfaceDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::InterfaceDef::_nil ();
    }
  }
  void 
  IR::_TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR::InterfaceDef **tmp = ACE_static_cast (IR::InterfaceDef**, target);
    *tmp = IR::InterfaceDef::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  IR::_TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::_upcast (void *src) const
  {
    IR::InterfaceDef **tmp = ACE_static_cast (IR::InterfaceDef**, src);
    return *tmp;
  }
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_INTERFACEDEFSEQ_CS_)
#define _IR_INTERFACEDEFSEQ_CS_

// *************************************************************
// IR::InterfaceDefSeq
// *************************************************************

IR::InterfaceDefSeq::InterfaceDefSeq (void)
{}
IR::InterfaceDefSeq::InterfaceDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::InterfaceDef,IR::InterfaceDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::InterfaceDefSeq::InterfaceDefSeq (CORBA::ULong max, CORBA::ULong length, IR::InterfaceDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::InterfaceDef,IR::InterfaceDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::InterfaceDefSeq::InterfaceDefSeq (const InterfaceDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::InterfaceDef,IR::InterfaceDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::InterfaceDefSeq::~InterfaceDefSeq (void) // dtor
{}
void IR::InterfaceDefSeq::_tao_any_destructor (void *x)
{
  InterfaceDefSeq *tmp = ACE_static_cast (InterfaceDefSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_InterfaceDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/InterfaceDefSeq:1.0
  16, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x53657100),  // name = InterfaceDefSeq
  CORBA::tk_sequence, // typecode kind
  76, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    60, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/InterfaceDef:1.0
      13, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = InterfaceDef

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_InterfaceDefSeq (CORBA::tk_alias, sizeof (_oc_IR_InterfaceDefSeq), (char *) &_oc_IR_InterfaceDefSeq, 0, sizeof (IR::InterfaceDefSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_InterfaceDefSeq, &_tc_TAO_tc_IR_InterfaceDefSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_VALUEDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_VALUEDEFSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::ValueDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::ValueDef **old = ACE_reinterpret_cast (IR::ValueDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = IR::ValueDef::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR::ValueDef **tmp = ACE_reinterpret_cast (IR::ValueDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::ValueDef::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  IR::_TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::~_TAO_Unbounded_Object_Sequence_IR_ValueDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR::ValueDef **tmp = ACE_reinterpret_cast (IR::ValueDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::ValueDef::_nil ();
    }
  }
  void 
  IR::_TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR::ValueDef **tmp = ACE_static_cast (IR::ValueDef**, target);
    *tmp = IR::ValueDef::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  IR::_TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::_upcast (void *src) const
  {
    IR::ValueDef **tmp = ACE_static_cast (IR::ValueDef**, src);
    return *tmp;
  }
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_VALUEDEFSEQ_CS_)
#define _IR_VALUEDEFSEQ_CS_

// *************************************************************
// IR::ValueDefSeq
// *************************************************************

IR::ValueDefSeq::ValueDefSeq (void)
{}
IR::ValueDefSeq::ValueDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::ValueDef,IR::ValueDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::ValueDefSeq::ValueDefSeq (CORBA::ULong max, CORBA::ULong length, IR::ValueDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::ValueDef,IR::ValueDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::ValueDefSeq::ValueDefSeq (const ValueDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::ValueDef,IR::ValueDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::ValueDefSeq::~ValueDefSeq (void) // dtor
{}
void IR::ValueDefSeq::_tao_any_destructor (void *x)
{
  ValueDefSeq *tmp = ACE_static_cast (ValueDefSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_ValueDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ValueDefSeq:1.0
  12, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446566), ACE_NTOHL (0x53657100),  // name = ValueDefSeq
  CORBA::tk_sequence, // typecode kind
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    52, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ValueDef:1.0
      9, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = ValueDef

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_ValueDefSeq (CORBA::tk_alias, sizeof (_oc_IR_ValueDefSeq), (char *) &_oc_IR_ValueDefSeq, 0, sizeof (IR::ValueDefSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueDefSeq, &_tc_TAO_tc_IR_ValueDefSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_COMPONENTDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_COMPONENTDEFSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::ComponentDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::ComponentDef **old = ACE_reinterpret_cast (IR::ComponentDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = IR::ComponentDef::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR::ComponentDef **tmp = ACE_reinterpret_cast (IR::ComponentDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::ComponentDef::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::~_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR::ComponentDef **tmp = ACE_reinterpret_cast (IR::ComponentDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::ComponentDef::_nil ();
    }
  }
  void 
  IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR::ComponentDef **tmp = ACE_static_cast (IR::ComponentDef**, target);
    *tmp = IR::ComponentDef::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_upcast (void *src) const
  {
    IR::ComponentDef **tmp = ACE_static_cast (IR::ComponentDef**, src);
    return *tmp;
  }
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_COMPONENTDEFSEQ_CS_)
#define _IR_COMPONENTDEFSEQ_CS_

// *************************************************************
// IR::ComponentDefSeq
// *************************************************************

IR::ComponentDefSeq::ComponentDefSeq (void)
{}
IR::ComponentDefSeq::ComponentDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::ComponentDef,IR::ComponentDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::ComponentDefSeq::ComponentDefSeq (CORBA::ULong max, CORBA::ULong length, IR::ComponentDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::ComponentDef,IR::ComponentDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::ComponentDefSeq::ComponentDefSeq (const ComponentDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::ComponentDef,IR::ComponentDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::ComponentDefSeq::~ComponentDefSeq (void) // dtor
{}
void IR::ComponentDefSeq::_tao_any_destructor (void *x)
{
  ComponentDefSeq *tmp = ACE_static_cast (ComponentDefSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_ComponentDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6d706f), ACE_NTOHL (0x6e656e74), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ComponentDefSeq:1.0
  16, ACE_NTOHL (0x436f6d70), ACE_NTOHL (0x6f6e656e), ACE_NTOHL (0x74446566), ACE_NTOHL (0x53657100),  // name = ComponentDefSeq
  CORBA::tk_sequence, // typecode kind
  76, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    60, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6d706f), ACE_NTOHL (0x6e656e74), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ComponentDef:1.0
      13, ACE_NTOHL (0x436f6d70), ACE_NTOHL (0x6f6e656e), ACE_NTOHL (0x74446566), ACE_NTOHL (0x0),  // name = ComponentDef

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_ComponentDefSeq (CORBA::tk_alias, sizeof (_oc_IR_ComponentDefSeq), (char *) &_oc_IR_ComponentDefSeq, 0, sizeof (IR::ComponentDefSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ComponentDefSeq, &_tc_TAO_tc_IR_ComponentDefSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_PROVIDESDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_PROVIDESDEFSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::ProvidesDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::ProvidesDef **old = ACE_reinterpret_cast (IR::ProvidesDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = IR::ProvidesDef::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR::ProvidesDef **tmp = ACE_reinterpret_cast (IR::ProvidesDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::ProvidesDef::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::~_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR::ProvidesDef **tmp = ACE_reinterpret_cast (IR::ProvidesDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::ProvidesDef::_nil ();
    }
  }
  void 
  IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR::ProvidesDef **tmp = ACE_static_cast (IR::ProvidesDef**, target);
    *tmp = IR::ProvidesDef::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_upcast (void *src) const
  {
    IR::ProvidesDef **tmp = ACE_static_cast (IR::ProvidesDef**, src);
    return *tmp;
  }
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_PROVIDESDEFSEQ_CS_)
#define _IR_PROVIDESDEFSEQ_CS_

// *************************************************************
// IR::ProvidesDefSeq
// *************************************************************

IR::ProvidesDefSeq::ProvidesDefSeq (void)
{}
IR::ProvidesDefSeq::ProvidesDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::ProvidesDef,IR::ProvidesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::ProvidesDefSeq::ProvidesDefSeq (CORBA::ULong max, CORBA::ULong length, IR::ProvidesDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::ProvidesDef,IR::ProvidesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::ProvidesDefSeq::ProvidesDefSeq (const ProvidesDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::ProvidesDef,IR::ProvidesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::ProvidesDefSeq::~ProvidesDefSeq (void) // dtor
{}
void IR::ProvidesDefSeq::_tao_any_destructor (void *x)
{
  ProvidesDefSeq *tmp = ACE_static_cast (ProvidesDefSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_ProvidesDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657344), ACE_NTOHL (0x65665365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ProvidesDefSeq:1.0
  15, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65710000),  // name = ProvidesDefSeq
  CORBA::tk_sequence, // typecode kind
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    56, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDef:1.0
      12, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44656600),  // name = ProvidesDef

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_ProvidesDefSeq (CORBA::tk_alias, sizeof (_oc_IR_ProvidesDefSeq), (char *) &_oc_IR_ProvidesDefSeq, 0, sizeof (IR::ProvidesDefSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ProvidesDefSeq, &_tc_TAO_tc_IR_ProvidesDefSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_USESDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_USESDEFSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::UsesDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::UsesDef **old = ACE_reinterpret_cast (IR::UsesDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = IR::UsesDef::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR::UsesDef **tmp = ACE_reinterpret_cast (IR::UsesDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::UsesDef::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::~_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR::UsesDef **tmp = ACE_reinterpret_cast (IR::UsesDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::UsesDef::_nil ();
    }
  }
  void 
  IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR::UsesDef **tmp = ACE_static_cast (IR::UsesDef**, target);
    *tmp = IR::UsesDef::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_upcast (void *src) const
  {
    IR::UsesDef **tmp = ACE_static_cast (IR::UsesDef**, src);
    return *tmp;
  }
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_USESDEFSEQ_CS_)
#define _IR_USESDEFSEQ_CS_

// *************************************************************
// IR::UsesDefSeq
// *************************************************************

IR::UsesDefSeq::UsesDefSeq (void)
{}
IR::UsesDefSeq::UsesDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::UsesDef,IR::UsesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::UsesDefSeq::UsesDefSeq (CORBA::ULong max, CORBA::ULong length, IR::UsesDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::UsesDef,IR::UsesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::UsesDefSeq::UsesDefSeq (const UsesDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::UsesDef,IR::UsesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::UsesDefSeq::~UsesDefSeq (void) // dtor
{}
void IR::UsesDefSeq::_tao_any_destructor (void *x)
{
  UsesDefSeq *tmp = ACE_static_cast (UsesDefSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_UsesDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x73657344), ACE_NTOHL (0x65665365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/UsesDefSeq:1.0
  11, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65710000),  // name = UsesDefSeq
  CORBA::tk_sequence, // typecode kind
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    48, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x73657344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDef:1.0
      8, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44656600),  // name = UsesDef

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_UsesDefSeq (CORBA::tk_alias, sizeof (_oc_IR_UsesDefSeq), (char *) &_oc_IR_UsesDefSeq, 0, sizeof (IR::UsesDefSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UsesDefSeq, &_tc_TAO_tc_IR_UsesDefSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_HOMEDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_HOMEDEFSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::HomeDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::HomeDef **old = ACE_reinterpret_cast (IR::HomeDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = IR::HomeDef::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR::HomeDef **tmp = ACE_reinterpret_cast (IR::HomeDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::HomeDef::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::~_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR::HomeDef **tmp = ACE_reinterpret_cast (IR::HomeDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::HomeDef::_nil ();
    }
  }
  void 
  IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR::HomeDef **tmp = ACE_static_cast (IR::HomeDef**, target);
    *tmp = IR::HomeDef::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_upcast (void *src) const
  {
    IR::HomeDef **tmp = ACE_static_cast (IR::HomeDef**, src);
    return *tmp;
  }
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_HOMEDEFSEQ_CS_)
#define _IR_HOMEDEFSEQ_CS_

// *************************************************************
// IR::HomeDefSeq
// *************************************************************

IR::HomeDefSeq::HomeDefSeq (void)
{}
IR::HomeDefSeq::HomeDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::HomeDef,IR::HomeDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::HomeDefSeq::HomeDefSeq (CORBA::ULong max, CORBA::ULong length, IR::HomeDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::HomeDef,IR::HomeDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::HomeDefSeq::HomeDefSeq (const HomeDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::HomeDef,IR::HomeDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::HomeDefSeq::~HomeDefSeq (void) // dtor
{}
void IR::HomeDefSeq::_tao_any_destructor (void *x)
{
  HomeDefSeq *tmp = ACE_static_cast (HomeDefSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_HomeDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f48), ACE_NTOHL (0x6f6d6544), ACE_NTOHL (0x65665365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/HomeDefSeq:1.0
  11, ACE_NTOHL (0x486f6d65), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65710000),  // name = HomeDefSeq
  CORBA::tk_sequence, // typecode kind
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    48, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f48), ACE_NTOHL (0x6f6d6544), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/HomeDef:1.0
      8, ACE_NTOHL (0x486f6d65), ACE_NTOHL (0x44656600),  // name = HomeDef

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_HomeDefSeq (CORBA::tk_alias, sizeof (_oc_IR_HomeDefSeq), (char *) &_oc_IR_HomeDefSeq, 0, sizeof (IR::HomeDefSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_HomeDefSeq, &_tc_TAO_tc_IR_HomeDefSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_EMITSDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_EMITSDEFSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::EmitsDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::EmitsDef **old = ACE_reinterpret_cast (IR::EmitsDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = IR::EmitsDef::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR::EmitsDef **tmp = ACE_reinterpret_cast (IR::EmitsDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::EmitsDef::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::~_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR::EmitsDef **tmp = ACE_reinterpret_cast (IR::EmitsDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::EmitsDef::_nil ();
    }
  }
  void 
  IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR::EmitsDef **tmp = ACE_static_cast (IR::EmitsDef**, target);
    *tmp = IR::EmitsDef::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_upcast (void *src) const
  {
    IR::EmitsDef **tmp = ACE_static_cast (IR::EmitsDef**, src);
    return *tmp;
  }
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_EMITSDEFSEQ_CS_)
#define _IR_EMITSDEFSEQ_CS_

// *************************************************************
// IR::EmitsDefSeq
// *************************************************************

IR::EmitsDefSeq::EmitsDefSeq (void)
{}
IR::EmitsDefSeq::EmitsDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::EmitsDef,IR::EmitsDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::EmitsDefSeq::EmitsDefSeq (CORBA::ULong max, CORBA::ULong length, IR::EmitsDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::EmitsDef,IR::EmitsDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::EmitsDefSeq::EmitsDefSeq (const EmitsDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::EmitsDef,IR::EmitsDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::EmitsDefSeq::~EmitsDefSeq (void) // dtor
{}
void IR::EmitsDefSeq::_tao_any_destructor (void *x)
{
  EmitsDefSeq *tmp = ACE_static_cast (EmitsDefSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_EmitsDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x6d697473), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/EmitsDefSeq:1.0
  12, ACE_NTOHL (0x456d6974), ACE_NTOHL (0x73446566), ACE_NTOHL (0x53657100),  // name = EmitsDefSeq
  CORBA::tk_sequence, // typecode kind
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    52, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x6d697473), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/EmitsDef:1.0
      9, ACE_NTOHL (0x456d6974), ACE_NTOHL (0x73446566), ACE_NTOHL (0x0),  // name = EmitsDef

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_EmitsDefSeq (CORBA::tk_alias, sizeof (_oc_IR_EmitsDefSeq), (char *) &_oc_IR_EmitsDefSeq, 0, sizeof (IR::EmitsDefSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EmitsDefSeq, &_tc_TAO_tc_IR_EmitsDefSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_PUBLISHESDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_PUBLISHESDEFSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::PublishesDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::PublishesDef **old = ACE_reinterpret_cast (IR::PublishesDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = IR::PublishesDef::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR::PublishesDef **tmp = ACE_reinterpret_cast (IR::PublishesDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::PublishesDef::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::~_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR::PublishesDef **tmp = ACE_reinterpret_cast (IR::PublishesDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::PublishesDef::_nil ();
    }
  }
  void 
  IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR::PublishesDef **tmp = ACE_static_cast (IR::PublishesDef**, target);
    *tmp = IR::PublishesDef::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_upcast (void *src) const
  {
    IR::PublishesDef **tmp = ACE_static_cast (IR::PublishesDef**, src);
    return *tmp;
  }
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_PUBLISHESDEFSEQ_CS_)
#define _IR_PUBLISHESDEFSEQ_CS_

// *************************************************************
// IR::PublishesDefSeq
// *************************************************************

IR::PublishesDefSeq::PublishesDefSeq (void)
{}
IR::PublishesDefSeq::PublishesDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::PublishesDef,IR::PublishesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::PublishesDefSeq::PublishesDefSeq (CORBA::ULong max, CORBA::ULong length, IR::PublishesDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::PublishesDef,IR::PublishesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::PublishesDefSeq::PublishesDefSeq (const PublishesDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::PublishesDef,IR::PublishesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::PublishesDefSeq::~PublishesDefSeq (void) // dtor
{}
void IR::PublishesDefSeq::_tao_any_destructor (void *x)
{
  PublishesDefSeq *tmp = ACE_static_cast (PublishesDefSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_PublishesDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x75626c69), ACE_NTOHL (0x73686573), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/PublishesDefSeq:1.0
  16, ACE_NTOHL (0x5075626c), ACE_NTOHL (0x69736865), ACE_NTOHL (0x73446566), ACE_NTOHL (0x53657100),  // name = PublishesDefSeq
  CORBA::tk_sequence, // typecode kind
  76, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    60, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x75626c69), ACE_NTOHL (0x73686573), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/PublishesDef:1.0
      13, ACE_NTOHL (0x5075626c), ACE_NTOHL (0x69736865), ACE_NTOHL (0x73446566), ACE_NTOHL (0x0),  // name = PublishesDef

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_PublishesDefSeq (CORBA::tk_alias, sizeof (_oc_IR_PublishesDefSeq), (char *) &_oc_IR_PublishesDefSeq, 0, sizeof (IR::PublishesDefSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PublishesDefSeq, &_tc_TAO_tc_IR_PublishesDefSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_CONSUMESDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_CONSUMESDEFSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::ConsumesDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::ConsumesDef **old = ACE_reinterpret_cast (IR::ConsumesDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = IR::ConsumesDef::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR::ConsumesDef **tmp = ACE_reinterpret_cast (IR::ConsumesDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::ConsumesDef::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::~_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR::ConsumesDef **tmp = ACE_reinterpret_cast (IR::ConsumesDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::ConsumesDef::_nil ();
    }
  }
  void 
  IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR::ConsumesDef **tmp = ACE_static_cast (IR::ConsumesDef**, target);
    *tmp = IR::ConsumesDef::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_upcast (void *src) const
  {
    IR::ConsumesDef **tmp = ACE_static_cast (IR::ConsumesDef**, src);
    return *tmp;
  }
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_CONSUMESDEFSEQ_CS_)
#define _IR_CONSUMESDEFSEQ_CS_

// *************************************************************
// IR::ConsumesDefSeq
// *************************************************************

IR::ConsumesDefSeq::ConsumesDefSeq (void)
{}
IR::ConsumesDefSeq::ConsumesDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::ConsumesDef,IR::ConsumesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::ConsumesDefSeq::ConsumesDefSeq (CORBA::ULong max, CORBA::ULong length, IR::ConsumesDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::ConsumesDef,IR::ConsumesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::ConsumesDefSeq::ConsumesDefSeq (const ConsumesDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::ConsumesDef,IR::ConsumesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::ConsumesDefSeq::~ConsumesDefSeq (void) // dtor
{}
void IR::ConsumesDefSeq::_tao_any_destructor (void *x)
{
  ConsumesDefSeq *tmp = ACE_static_cast (ConsumesDefSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_ConsumesDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7375), ACE_NTOHL (0x6d657344), ACE_NTOHL (0x65665365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ConsumesDefSeq:1.0
  15, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x756d6573), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65710000),  // name = ConsumesDefSeq
  CORBA::tk_sequence, // typecode kind
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    56, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7375), ACE_NTOHL (0x6d657344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ConsumesDef:1.0
      12, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x756d6573), ACE_NTOHL (0x44656600),  // name = ConsumesDef

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_ConsumesDefSeq (CORBA::tk_alias, sizeof (_oc_IR_ConsumesDefSeq), (char *) &_oc_IR_ConsumesDefSeq, 0, sizeof (IR::ConsumesDefSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ConsumesDefSeq, &_tc_TAO_tc_IR_ConsumesDefSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_FACTORYDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_FACTORYDEFSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::FactoryDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::FactoryDef **old = ACE_reinterpret_cast (IR::FactoryDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = IR::FactoryDef::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR::FactoryDef **tmp = ACE_reinterpret_cast (IR::FactoryDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::FactoryDef::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::~_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR::FactoryDef **tmp = ACE_reinterpret_cast (IR::FactoryDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::FactoryDef::_nil ();
    }
  }
  void 
  IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR::FactoryDef **tmp = ACE_static_cast (IR::FactoryDef**, target);
    *tmp = IR::FactoryDef::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_upcast (void *src) const
  {
    IR::FactoryDef **tmp = ACE_static_cast (IR::FactoryDef**, src);
    return *tmp;
  }
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_FACTORYDEFSEQ_CS_)
#define _IR_FACTORYDEFSEQ_CS_

// *************************************************************
// IR::FactoryDefSeq
// *************************************************************

IR::FactoryDefSeq::FactoryDefSeq (void)
{}
IR::FactoryDefSeq::FactoryDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::FactoryDef,IR::FactoryDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::FactoryDefSeq::FactoryDefSeq (CORBA::ULong max, CORBA::ULong length, IR::FactoryDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::FactoryDef,IR::FactoryDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::FactoryDefSeq::FactoryDefSeq (const FactoryDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::FactoryDef,IR::FactoryDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::FactoryDefSeq::~FactoryDefSeq (void) // dtor
{}
void IR::FactoryDefSeq::_tao_any_destructor (void *x)
{
  FactoryDefSeq *tmp = ACE_static_cast (FactoryDefSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_FactoryDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x6163746f), ACE_NTOHL (0x72794465), ACE_NTOHL (0x66536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/FactoryDefSeq:1.0
  14, ACE_NTOHL (0x46616374), ACE_NTOHL (0x6f727944), ACE_NTOHL (0x65665365), ACE_NTOHL (0x71000000),  // name = FactoryDefSeq
  CORBA::tk_sequence, // typecode kind
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    56, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x6163746f), ACE_NTOHL (0x72794465), ACE_NTOHL (0x663a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/FactoryDef:1.0
      11, ACE_NTOHL (0x46616374), ACE_NTOHL (0x6f727944), ACE_NTOHL (0x65660000),  // name = FactoryDef

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_FactoryDefSeq (CORBA::tk_alias, sizeof (_oc_IR_FactoryDefSeq), (char *) &_oc_IR_FactoryDefSeq, 0, sizeof (IR::FactoryDefSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FactoryDefSeq, &_tc_TAO_tc_IR_FactoryDefSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_FINDERDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_FINDERDEFSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::FinderDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::FinderDef **old = ACE_reinterpret_cast (IR::FinderDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = IR::FinderDef::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR::FinderDef **tmp = ACE_reinterpret_cast (IR::FinderDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::FinderDef::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::~_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR::FinderDef **tmp = ACE_reinterpret_cast (IR::FinderDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::FinderDef::_nil ();
    }
  }
  void 
  IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR::FinderDef **tmp = ACE_static_cast (IR::FinderDef**, target);
    *tmp = IR::FinderDef::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_upcast (void *src) const
  {
    IR::FinderDef **tmp = ACE_static_cast (IR::FinderDef**, src);
    return *tmp;
  }
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_FINDERDEFSEQ_CS_)
#define _IR_FINDERDEFSEQ_CS_

// *************************************************************
// IR::FinderDefSeq
// *************************************************************

IR::FinderDefSeq::FinderDefSeq (void)
{}
IR::FinderDefSeq::FinderDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::FinderDef,IR::FinderDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::FinderDefSeq::FinderDefSeq (CORBA::ULong max, CORBA::ULong length, IR::FinderDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::FinderDef,IR::FinderDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::FinderDefSeq::FinderDefSeq (const FinderDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::FinderDef,IR::FinderDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::FinderDefSeq::~FinderDefSeq (void) // dtor
{}
void IR::FinderDefSeq::_tao_any_destructor (void *x)
{
  FinderDefSeq *tmp = ACE_static_cast (FinderDefSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_FinderDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x696e6465), ACE_NTOHL (0x72446566), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/FinderDefSeq:1.0
  13, ACE_NTOHL (0x46696e64), ACE_NTOHL (0x65724465), ACE_NTOHL (0x66536571), ACE_NTOHL (0x0),  // name = FinderDefSeq
  CORBA::tk_sequence, // typecode kind
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    56, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x696e6465), ACE_NTOHL (0x72446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/FinderDef:1.0
      10, ACE_NTOHL (0x46696e64), ACE_NTOHL (0x65724465), ACE_NTOHL (0x66000000),  // name = FinderDef

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_FinderDefSeq (CORBA::tk_alias, sizeof (_oc_IR_FinderDefSeq), (char *) &_oc_IR_FinderDefSeq, 0, sizeof (IR::FinderDefSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FinderDefSeq, &_tc_TAO_tc_IR_FinderDefSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_CONTAINEDSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_CONTAINEDSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_ContainedSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::Contained **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_ContainedSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::Contained **old = ACE_reinterpret_cast (IR::Contained**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = IR::Contained::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_ContainedSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR::Contained **tmp = ACE_reinterpret_cast (IR::Contained**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::Contained::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_IR_ContainedSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  IR::_TAO_Unbounded_Object_Sequence_IR_ContainedSeq::~_TAO_Unbounded_Object_Sequence_IR_ContainedSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_ContainedSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR::Contained **tmp = ACE_reinterpret_cast (IR::Contained**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::Contained::_nil ();
    }
  }
  void 
  IR::_TAO_Unbounded_Object_Sequence_IR_ContainedSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR::Contained **tmp = ACE_static_cast (IR::Contained**, target);
    *tmp = IR::Contained::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  IR::_TAO_Unbounded_Object_Sequence_IR_ContainedSeq::_upcast (void *src) const
  {
    IR::Contained **tmp = ACE_static_cast (IR::Contained**, src);
    return *tmp;
  }
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_CONTAINEDSEQ_CS_)
#define _IR_CONTAINEDSEQ_CS_

// *************************************************************
// IR::ContainedSeq
// *************************************************************

IR::ContainedSeq::ContainedSeq (void)
{}
IR::ContainedSeq::ContainedSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ContainedSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::Contained,IR::Contained_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::ContainedSeq::ContainedSeq (CORBA::ULong max, CORBA::ULong length, IR::Contained_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ContainedSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::Contained,IR::Contained_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::ContainedSeq::ContainedSeq (const ContainedSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ContainedSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::Contained,IR::Contained_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::ContainedSeq::~ContainedSeq (void) // dtor
{}
void IR::ContainedSeq::_tao_any_destructor (void *x)
{
  ContainedSeq *tmp = ACE_static_cast (ContainedSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_ContainedSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7461), ACE_NTOHL (0x696e6564), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ContainedSeq:1.0
  13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContainedSeq
  CORBA::tk_sequence, // typecode kind
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    56, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7461), ACE_NTOHL (0x696e6564), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/Contained:1.0
      10, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x64000000),  // name = Contained

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_ContainedSeq (CORBA::tk_alias, sizeof (_oc_IR_ContainedSeq), (char *) &_oc_IR_ContainedSeq, 0, sizeof (IR::ContainedSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ContainedSeq, &_tc_TAO_tc_IR_ContainedSeq)
TAO_NAMESPACE_END
static const CORBA::Long _oc_IR_StructMember[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x744d656d), ACE_NTOHL (0x6265723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/StructMember:1.0
  13, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x0),  // name = StructMember
  3, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  132, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_alias, // typecode kind for typedefs
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
      11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
      CORBA::tk_string, 
      0U, // string length


  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

  9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
  CORBA::tk_objref, // typecode kind
  48, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
    8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

};
static CORBA::TypeCode _tc_TAO_tc_IR_StructMember (CORBA::tk_struct, sizeof (_oc_IR_StructMember), (char *) &_oc_IR_StructMember, 0, sizeof (IR::StructMember));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_StructMember, &_tc_TAO_tc_IR_StructMember)
TAO_NAMESPACE_END
void IR::StructMember::_tao_any_destructor (void *x)
{
  StructMember *tmp = ACE_static_cast (StructMember*,x);
  delete tmp;
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_STRUCTMEMBERSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_IR_STRUCTMEMBERSEQ_CS_

  void
  IR::_TAO_Unbounded_Sequence_IR_StructMemberSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::StructMember* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_IR_StructMemberSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::StructMember *old = ACE_reinterpret_cast (IR::StructMember *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_IR_StructMemberSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Sequence_IR_StructMemberSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    IR::StructMember *tmp = ACE_reinterpret_cast (IR::StructMember *,this->buffer_);
    
    _TAO_Unbounded_Sequence_IR_StructMemberSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  IR::_TAO_Unbounded_Sequence_IR_StructMemberSeq::~_TAO_Unbounded_Sequence_IR_StructMemberSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_STRUCTMEMBERSEQ_CS_)
#define _IR_STRUCTMEMBERSEQ_CS_

// *************************************************************
// IR::StructMemberSeq
// *************************************************************

IR::StructMemberSeq::StructMemberSeq (void)
{}
IR::StructMemberSeq::StructMemberSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_StructMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::StructMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::StructMemberSeq::StructMemberSeq (CORBA::ULong max, CORBA::ULong length, IR::StructMember *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_StructMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::StructMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::StructMemberSeq::StructMemberSeq (const StructMemberSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_StructMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::StructMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::StructMemberSeq::~StructMemberSeq (void) // dtor
{}
void IR::StructMemberSeq::_tao_any_destructor (void *x)
{
  StructMemberSeq *tmp = ACE_static_cast (StructMemberSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_StructMemberSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x744d656d), ACE_NTOHL (0x62657253), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/StructMemberSeq:1.0
  16, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x53657100),  // name = StructMemberSeq
  CORBA::tk_sequence, // typecode kind
  320, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    304, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x744d656d), ACE_NTOHL (0x6265723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/StructMember:1.0
      13, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x0),  // name = StructMember
      3, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      132, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length


      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
      CORBA::tk_TypeCode,

      9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
      CORBA::tk_objref, // typecode kind
      48, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
        8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_StructMemberSeq (CORBA::tk_alias, sizeof (_oc_IR_StructMemberSeq), (char *) &_oc_IR_StructMemberSeq, 0, sizeof (IR::StructMemberSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_StructMemberSeq, &_tc_TAO_tc_IR_StructMemberSeq)
TAO_NAMESPACE_END
static const CORBA::Long _oc_IR_Initializer[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x616c697a), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/Initializer:1.0
  12, ACE_NTOHL (0x496e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657200),  // name = Initializer
  2, // member count
  8, ACE_NTOHL (0x6d656d62), ACE_NTOHL (0x65727300),  // name = members
  CORBA::tk_alias, // typecode kind for typedefs
  392, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x744d656d), ACE_NTOHL (0x62657253), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/StructMemberSeq:1.0
    16, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x53657100),  // name = StructMemberSeq
    CORBA::tk_sequence, // typecode kind
    320, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      304, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x744d656d), ACE_NTOHL (0x6265723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/StructMember:1.0
        13, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x0),  // name = StructMember
        3, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        132, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_alias, // typecode kind for typedefs
          68, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
            11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
            CORBA::tk_string, 
            0U, // string length


        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,

        9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
        CORBA::tk_objref, // typecode kind
        48, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
          8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType


      0U,


  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  132, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_alias, // typecode kind for typedefs
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
      11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
      CORBA::tk_string, 
      0U, // string length


};
static CORBA::TypeCode _tc_TAO_tc_IR_Initializer (CORBA::tk_struct, sizeof (_oc_IR_Initializer), (char *) &_oc_IR_Initializer, 0, sizeof (IR::Initializer));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Initializer, &_tc_TAO_tc_IR_Initializer)
TAO_NAMESPACE_END
void IR::Initializer::_tao_any_destructor (void *x)
{
  Initializer *tmp = ACE_static_cast (Initializer*,x);
  delete tmp;
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_INITIALIZERSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_IR_INITIALIZERSEQ_CS_

  void
  IR::_TAO_Unbounded_Sequence_IR_InitializerSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::Initializer* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_IR_InitializerSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::Initializer *old = ACE_reinterpret_cast (IR::Initializer *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_IR_InitializerSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Sequence_IR_InitializerSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    IR::Initializer *tmp = ACE_reinterpret_cast (IR::Initializer *,this->buffer_);
    
    _TAO_Unbounded_Sequence_IR_InitializerSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  IR::_TAO_Unbounded_Sequence_IR_InitializerSeq::~_TAO_Unbounded_Sequence_IR_InitializerSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_INITIALIZERSEQ_CS_)
#define _IR_INITIALIZERSEQ_CS_

// *************************************************************
// IR::InitializerSeq
// *************************************************************

IR::InitializerSeq::InitializerSeq (void)
{}
IR::InitializerSeq::InitializerSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_InitializerSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::Initializer>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::InitializerSeq::InitializerSeq (CORBA::ULong max, CORBA::ULong length, IR::Initializer *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_InitializerSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::Initializer>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::InitializerSeq::InitializerSeq (const InitializerSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_InitializerSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::Initializer>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::InitializerSeq::~InitializerSeq (void) // dtor
{}
void IR::InitializerSeq::_tao_any_destructor (void *x)
{
  InitializerSeq *tmp = ACE_static_cast (InitializerSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_InitializerSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x616c697a), ACE_NTOHL (0x65725365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/InitializerSeq:1.0
  15, ACE_NTOHL (0x496e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657253), ACE_NTOHL (0x65710000),  // name = InitializerSeq
  CORBA::tk_sequence, // typecode kind
  640, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    624, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x616c697a), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/Initializer:1.0
      12, ACE_NTOHL (0x496e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657200),  // name = Initializer
      2, // member count
      8, ACE_NTOHL (0x6d656d62), ACE_NTOHL (0x65727300),  // name = members
      CORBA::tk_alias, // typecode kind for typedefs
      392, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x744d656d), ACE_NTOHL (0x62657253), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/StructMemberSeq:1.0
        16, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x53657100),  // name = StructMemberSeq
        CORBA::tk_sequence, // typecode kind
        320, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          304, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x744d656d), ACE_NTOHL (0x6265723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/StructMember:1.0
            13, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x0),  // name = StructMember
            3, // member count
            5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
            CORBA::tk_alias, // typecode kind for typedefs
            132, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
              11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
                0U, // string length


            5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
            CORBA::tk_TypeCode,

            9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
            CORBA::tk_objref, // typecode kind
            48, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
              8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType


          0U,


      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      132, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length



    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_InitializerSeq (CORBA::tk_alias, sizeof (_oc_IR_InitializerSeq), (char *) &_oc_IR_InitializerSeq, 0, sizeof (IR::InitializerSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_InitializerSeq, &_tc_TAO_tc_IR_InitializerSeq)
TAO_NAMESPACE_END
static const CORBA::Long _oc_IR_UnionMember[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x6e696f6e), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UnionMember:1.0
  12, ACE_NTOHL (0x556e696f), ACE_NTOHL (0x6e4d656d), ACE_NTOHL (0x62657200),  // name = UnionMember
  4, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  132, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_alias, // typecode kind for typedefs
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
      11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
      CORBA::tk_string, 
      0U, // string length


  6, ACE_NTOHL (0x6c616265), ACE_NTOHL (0x6c000000),  // name = label
  CORBA::tk_any,

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

  9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
  CORBA::tk_objref, // typecode kind
  48, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
    8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

};
static CORBA::TypeCode _tc_TAO_tc_IR_UnionMember (CORBA::tk_struct, sizeof (_oc_IR_UnionMember), (char *) &_oc_IR_UnionMember, 0, sizeof (IR::UnionMember));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UnionMember, &_tc_TAO_tc_IR_UnionMember)
TAO_NAMESPACE_END
void IR::UnionMember::_tao_any_destructor (void *x)
{
  UnionMember *tmp = ACE_static_cast (UnionMember*,x);
  delete tmp;
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_UNIONMEMBERSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_IR_UNIONMEMBERSEQ_CS_

  void
  IR::_TAO_Unbounded_Sequence_IR_UnionMemberSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::UnionMember* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_IR_UnionMemberSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::UnionMember *old = ACE_reinterpret_cast (IR::UnionMember *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_IR_UnionMemberSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Sequence_IR_UnionMemberSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    IR::UnionMember *tmp = ACE_reinterpret_cast (IR::UnionMember *,this->buffer_);
    
    _TAO_Unbounded_Sequence_IR_UnionMemberSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  IR::_TAO_Unbounded_Sequence_IR_UnionMemberSeq::~_TAO_Unbounded_Sequence_IR_UnionMemberSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_UNIONMEMBERSEQ_CS_)
#define _IR_UNIONMEMBERSEQ_CS_

// *************************************************************
// IR::UnionMemberSeq
// *************************************************************

IR::UnionMemberSeq::UnionMemberSeq (void)
{}
IR::UnionMemberSeq::UnionMemberSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_UnionMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::UnionMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::UnionMemberSeq::UnionMemberSeq (CORBA::ULong max, CORBA::ULong length, IR::UnionMember *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_UnionMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::UnionMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::UnionMemberSeq::UnionMemberSeq (const UnionMemberSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_UnionMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::UnionMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::UnionMemberSeq::~UnionMemberSeq (void) // dtor
{}
void IR::UnionMemberSeq::_tao_any_destructor (void *x)
{
  UnionMemberSeq *tmp = ACE_static_cast (UnionMemberSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_UnionMemberSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x6e696f6e), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65725365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/UnionMemberSeq:1.0
  15, ACE_NTOHL (0x556e696f), ACE_NTOHL (0x6e4d656d), ACE_NTOHL (0x62657253), ACE_NTOHL (0x65710000),  // name = UnionMemberSeq
  CORBA::tk_sequence, // typecode kind
  332, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    316, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x6e696f6e), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UnionMember:1.0
      12, ACE_NTOHL (0x556e696f), ACE_NTOHL (0x6e4d656d), ACE_NTOHL (0x62657200),  // name = UnionMember
      4, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      132, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length


      6, ACE_NTOHL (0x6c616265), ACE_NTOHL (0x6c000000),  // name = label
      CORBA::tk_any,

      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
      CORBA::tk_TypeCode,

      9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
      CORBA::tk_objref, // typecode kind
      48, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
        8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_UnionMemberSeq (CORBA::tk_alias, sizeof (_oc_IR_UnionMemberSeq), (char *) &_oc_IR_UnionMemberSeq, 0, sizeof (IR::UnionMemberSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UnionMemberSeq, &_tc_TAO_tc_IR_UnionMemberSeq)
TAO_NAMESPACE_END

#if !defined (_IR_ENUMMEMBERSEQ_CS_)
#define _IR_ENUMMEMBERSEQ_CS_

// *************************************************************
// IR::EnumMemberSeq
// *************************************************************

IR::EnumMemberSeq::EnumMemberSeq (void)
{}
IR::EnumMemberSeq::EnumMemberSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::EnumMemberSeq::EnumMemberSeq (CORBA::ULong max, CORBA::ULong length, char * *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::EnumMemberSeq::EnumMemberSeq (const EnumMemberSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::EnumMemberSeq::~EnumMemberSeq (void) // dtor
{}
void IR::EnumMemberSeq::_tao_any_destructor (void *x)
{
  EnumMemberSeq *tmp = ACE_static_cast (EnumMemberSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_EnumMemberSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x6e756d4d), ACE_NTOHL (0x656d6265), ACE_NTOHL (0x72536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/EnumMemberSeq:1.0
  14, ACE_NTOHL (0x456e756d), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65725365), ACE_NTOHL (0x71000000),  // name = EnumMemberSeq
  CORBA::tk_sequence, // typecode kind
  148, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_alias, // typecode kind for typedefs
    132, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
      11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
        0U, // string length


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_EnumMemberSeq (CORBA::tk_alias, sizeof (_oc_IR_EnumMemberSeq), (char *) &_oc_IR_EnumMemberSeq, 0, sizeof (IR::EnumMemberSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EnumMemberSeq, &_tc_TAO_tc_IR_EnumMemberSeq)
TAO_NAMESPACE_END
void IR::Container::_tao_any_destructor (void *x)
{
  Container *tmp = ACE_static_cast (Container*,x);
  CORBA::release (tmp);
}

IR::Container_ptr IR::Container::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return Container::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/Container:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (Container::_nil ());
  if (is_a == 0)
    return Container::_nil ();
  return Container::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::Container_ptr IR::Container::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return Container::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  Container_ptr default_proxy = Container::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_Container_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_Container_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, Container (stub), Container::_nil ());
  return TAO_IR_Container_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::Container_ptr 
IR::Container::_duplicate (Container_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

IR::Contained_ptr IR::Container::lookup (
    const char * search_name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::Contained_ptr _tao_retval = IR::Contained::_nil ();
  IR::Contained_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "lookup",
      6,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "lookup",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << search_name)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "lookup",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "lookup",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::ContainedSeq * IR::Container::contents (
    IR::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::ContainedSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR::ContainedSeq, _tao_retval);
  IR::ContainedSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "contents",
      8,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "contents",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << limit_type) &&
              (_tao_out << CORBA::Any::from_boolean (exclude_inherited))
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "contents",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "contents",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::ContainedSeq * IR::Container::lookup_name (
    const char * search_name,
    CORBA::Long levels_to_search,
    IR::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::ContainedSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR::ContainedSeq, _tao_retval);
  IR::ContainedSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "lookup_name",
      11,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "lookup_name",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << search_name) &&
              (_tao_out << levels_to_search) &&
              (_tao_out << limit_type) &&
              (_tao_out << CORBA::Any::from_boolean (exclude_inherited))
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "lookup_name",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "lookup_name",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

static const CORBA::Long _oc_IR_Container_Description[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  41, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7461), ACE_NTOHL (0x696e6572), ACE_NTOHL (0x2f446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/Container/Description:1.0
  12, ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = Description
  3, // member count
  17, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x645f6f62), ACE_NTOHL (0x6a656374), ACE_NTOHL (0x0),  // name = contained_object
  CORBA::tk_objref, // typecode kind
  56, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7461), ACE_NTOHL (0x696e6564), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/Contained:1.0
    10, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x64000000),  // name = Contained

  5, ACE_NTOHL (0x6b696e64), ACE_NTOHL (0x0),  // name = kind
  CORBA::tk_enum, // typecode kind
  632, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f44), ACE_NTOHL (0x6566696e), ACE_NTOHL (0x6974696f), ACE_NTOHL (0x6e4b696e), ACE_NTOHL (0x643a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/DefinitionKind:1.0
    15, ACE_NTOHL (0x44656669), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x6f6e4b69), ACE_NTOHL (0x6e640000),  // name = DefinitionKind
    34, // member count
    8, ACE_NTOHL (0x646b5f6e), ACE_NTOHL (0x6f6e6500),  // name = dk_none
    7, ACE_NTOHL (0x646b5f61), ACE_NTOHL (0x6c6c0000),  // name = dk_all
    13, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x0),  // name = dk_Attribute
    12, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6e7374), ACE_NTOHL (0x616e7400),  // name = dk_Constant
    13, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Exception
    13, ACE_NTOHL (0x646b5f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x0),  // name = dk_Interface
    10, ACE_NTOHL (0x646b5f4d), ACE_NTOHL (0x6f64756c), ACE_NTOHL (0x65000000),  // name = dk_Module
    13, ACE_NTOHL (0x646b5f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Operation
    11, ACE_NTOHL (0x646b5f54), ACE_NTOHL (0x79706564), ACE_NTOHL (0x65660000),  // name = dk_Typedef
    9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x6c696173), ACE_NTOHL (0x0),  // name = dk_Alias
    10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x74000000),  // name = dk_Struct
    9, ACE_NTOHL (0x646b5f55), ACE_NTOHL (0x6e696f6e), ACE_NTOHL (0x0),  // name = dk_Union
    8, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x6e756d00),  // name = dk_Enum
    13, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x72696d69), ACE_NTOHL (0x74697665), ACE_NTOHL (0x0),  // name = dk_Primitive
    10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x7472696e), ACE_NTOHL (0x67000000),  // name = dk_String
    12, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x65717565), ACE_NTOHL (0x6e636500),  // name = dk_Sequence
    9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x72726179), ACE_NTOHL (0x0),  // name = dk_Array
    14, ACE_NTOHL (0x646b5f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79000000),  // name = dk_Repository
    11, ACE_NTOHL (0x646b5f57), ACE_NTOHL (0x73747269), ACE_NTOHL (0x6e670000),  // name = dk_Wstring
    9, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x69786564), ACE_NTOHL (0x0),  // name = dk_Fixed
    9, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x0),  // name = dk_Value
    12, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x426f7800),  // name = dk_ValueBox
    15, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65720000),  // name = dk_ValueMember
    10, ACE_NTOHL (0x646b5f4e), ACE_NTOHL (0x61746976), ACE_NTOHL (0x65000000),  // name = dk_Native
    13, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6d706f), ACE_NTOHL (0x6e656e74), ACE_NTOHL (0x0),  // name = dk_Component
    8, ACE_NTOHL (0x646b5f48), ACE_NTOHL (0x6f6d6500),  // name = dk_Home
    11, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x6163746f), ACE_NTOHL (0x72790000),  // name = dk_Factory
    10, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x696e6465), ACE_NTOHL (0x72000000),  // name = dk_Finder
    14, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x72696d61), ACE_NTOHL (0x72794b65), ACE_NTOHL (0x79000000),  // name = dk_PrimaryKey
    9, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x6d697473), ACE_NTOHL (0x0),  // name = dk_Emits
    13, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x75626c69), ACE_NTOHL (0x73686573), ACE_NTOHL (0x0),  // name = dk_Publishes
    12, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6e7375), ACE_NTOHL (0x6d657300),  // name = dk_Consumes
    12, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657300),  // name = dk_Provides
    8, ACE_NTOHL (0x646b5f55), ACE_NTOHL (0x73657300),  // name = dk_Uses

  6, ACE_NTOHL (0x76616c75), ACE_NTOHL (0x65000000),  // name = value
  CORBA::tk_any,

};
static CORBA::TypeCode _tc_TAO_tc_IR_Container_Description (CORBA::tk_struct, sizeof (_oc_IR_Container_Description), (char *) &_oc_IR_Container_Description, 0, sizeof (IR::Container::Description));
CORBA::TypeCode_ptr IR::Container::_tc_Description = &_tc_TAO_tc_IR_Container_Description;

void IR::Container::Description::_tao_any_destructor (void *x)
{
  Description *tmp = ACE_static_cast (Description*,x);
  delete tmp;
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_CONTAINER_DESCRIPTIONSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_IR_CONTAINER_DESCRIPTIONSEQ_CS_

  void
  IR::Container::_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::Container::Description* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::Container::Description *old = ACE_reinterpret_cast (IR::Container::Description *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::Container::_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    IR::Container::Description *tmp = ACE_reinterpret_cast (IR::Container::Description *,this->buffer_);
    
    _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  IR::Container::_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::~_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_CONTAINER_DESCRIPTIONSEQ_CS_)
#define _IR_CONTAINER_DESCRIPTIONSEQ_CS_

// *************************************************************
// IR::Container::DescriptionSeq
// *************************************************************

IR::Container::DescriptionSeq::DescriptionSeq (void)
{}
IR::Container::DescriptionSeq::DescriptionSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::Container::Description>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::Container::DescriptionSeq::DescriptionSeq (CORBA::ULong max, CORBA::ULong length, IR::Container::Description *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::Container::Description>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::Container::DescriptionSeq::DescriptionSeq (const DescriptionSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::Container::Description>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::Container::DescriptionSeq::~DescriptionSeq (void) // dtor
{}
void IR::Container::DescriptionSeq::_tao_any_destructor (void *x)
{
  DescriptionSeq *tmp = ACE_static_cast (DescriptionSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_Container_DescriptionSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  44, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7461), ACE_NTOHL (0x696e6572), ACE_NTOHL (0x2f446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/Container/DescriptionSeq:1.0
  15, ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65710000),  // name = DescriptionSeq
  CORBA::tk_sequence, // typecode kind
  844, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    828, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      41, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7461), ACE_NTOHL (0x696e6572), ACE_NTOHL (0x2f446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/Container/Description:1.0
      12, ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = Description
      3, // member count
      17, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x645f6f62), ACE_NTOHL (0x6a656374), ACE_NTOHL (0x0),  // name = contained_object
      CORBA::tk_objref, // typecode kind
      56, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7461), ACE_NTOHL (0x696e6564), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/Contained:1.0
        10, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x64000000),  // name = Contained

      5, ACE_NTOHL (0x6b696e64), ACE_NTOHL (0x0),  // name = kind
      CORBA::tk_enum, // typecode kind
      632, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f44), ACE_NTOHL (0x6566696e), ACE_NTOHL (0x6974696f), ACE_NTOHL (0x6e4b696e), ACE_NTOHL (0x643a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/DefinitionKind:1.0
        15, ACE_NTOHL (0x44656669), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x6f6e4b69), ACE_NTOHL (0x6e640000),  // name = DefinitionKind
        34, // member count
        8, ACE_NTOHL (0x646b5f6e), ACE_NTOHL (0x6f6e6500),  // name = dk_none
        7, ACE_NTOHL (0x646b5f61), ACE_NTOHL (0x6c6c0000),  // name = dk_all
        13, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x0),  // name = dk_Attribute
        12, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6e7374), ACE_NTOHL (0x616e7400),  // name = dk_Constant
        13, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Exception
        13, ACE_NTOHL (0x646b5f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x0),  // name = dk_Interface
        10, ACE_NTOHL (0x646b5f4d), ACE_NTOHL (0x6f64756c), ACE_NTOHL (0x65000000),  // name = dk_Module
        13, ACE_NTOHL (0x646b5f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Operation
        11, ACE_NTOHL (0x646b5f54), ACE_NTOHL (0x79706564), ACE_NTOHL (0x65660000),  // name = dk_Typedef
        9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x6c696173), ACE_NTOHL (0x0),  // name = dk_Alias
        10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x74000000),  // name = dk_Struct
        9, ACE_NTOHL (0x646b5f55), ACE_NTOHL (0x6e696f6e), ACE_NTOHL (0x0),  // name = dk_Union
        8, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x6e756d00),  // name = dk_Enum
        13, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x72696d69), ACE_NTOHL (0x74697665), ACE_NTOHL (0x0),  // name = dk_Primitive
        10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x7472696e), ACE_NTOHL (0x67000000),  // name = dk_String
        12, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x65717565), ACE_NTOHL (0x6e636500),  // name = dk_Sequence
        9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x72726179), ACE_NTOHL (0x0),  // name = dk_Array
        14, ACE_NTOHL (0x646b5f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79000000),  // name = dk_Repository
        11, ACE_NTOHL (0x646b5f57), ACE_NTOHL (0x73747269), ACE_NTOHL (0x6e670000),  // name = dk_Wstring
        9, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x69786564), ACE_NTOHL (0x0),  // name = dk_Fixed
        9, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x0),  // name = dk_Value
        12, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x426f7800),  // name = dk_ValueBox
        15, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65720000),  // name = dk_ValueMember
        10, ACE_NTOHL (0x646b5f4e), ACE_NTOHL (0x61746976), ACE_NTOHL (0x65000000),  // name = dk_Native
        13, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6d706f), ACE_NTOHL (0x6e656e74), ACE_NTOHL (0x0),  // name = dk_Component
        8, ACE_NTOHL (0x646b5f48), ACE_NTOHL (0x6f6d6500),  // name = dk_Home
        11, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x6163746f), ACE_NTOHL (0x72790000),  // name = dk_Factory
        10, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x696e6465), ACE_NTOHL (0x72000000),  // name = dk_Finder
        14, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x72696d61), ACE_NTOHL (0x72794b65), ACE_NTOHL (0x79000000),  // name = dk_PrimaryKey
        9, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x6d697473), ACE_NTOHL (0x0),  // name = dk_Emits
        13, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x75626c69), ACE_NTOHL (0x73686573), ACE_NTOHL (0x0),  // name = dk_Publishes
        12, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6e7375), ACE_NTOHL (0x6d657300),  // name = dk_Consumes
        12, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657300),  // name = dk_Provides
        8, ACE_NTOHL (0x646b5f55), ACE_NTOHL (0x73657300),  // name = dk_Uses

      6, ACE_NTOHL (0x76616c75), ACE_NTOHL (0x65000000),  // name = value
      CORBA::tk_any,


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_Container_DescriptionSeq (CORBA::tk_alias, sizeof (_oc_IR_Container_DescriptionSeq), (char *) &_oc_IR_Container_DescriptionSeq, 0, sizeof (IR::Container::DescriptionSeq));
CORBA::TypeCode_ptr IR::Container::_tc_DescriptionSeq = &_tc_TAO_tc_IR_Container_DescriptionSeq;

IR::Container::DescriptionSeq * IR::Container::describe_contents (
    IR::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Long max_returned_objs,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::Container::DescriptionSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR::Container::DescriptionSeq, _tao_retval);
  IR::Container::DescriptionSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "describe_contents",
      17,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "describe_contents",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << limit_type) &&
              (_tao_out << CORBA::Any::from_boolean (exclude_inherited)) &&
              (_tao_out << max_returned_objs)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "describe_contents",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "describe_contents",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::ModuleDef_ptr IR::Container::create_module (
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::ModuleDef_ptr _tao_retval = IR::ModuleDef::_nil ();
  IR::ModuleDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_module",
      13,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_module",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_module",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_module",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::ConstantDef_ptr IR::Container::create_constant (
    const char * id,
    const char * name,
    const char * version,
    IR::IDLType_ptr type,
    const CORBA::Any & value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::ConstantDef_ptr _tao_retval = IR::ConstantDef::_nil ();
  IR::ConstantDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_constant",
      15,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_constant",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << type) &&
              (_tao_out << value)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_constant",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_constant",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::StructDef_ptr IR::Container::create_struct (
    const char * id,
    const char * name,
    const char * version,
    const IR::StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::StructDef_ptr _tao_retval = IR::StructDef::_nil ();
  IR::StructDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_struct",
      13,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_struct",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << members)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_struct",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_struct",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::UnionDef_ptr IR::Container::create_union (
    const char * id,
    const char * name,
    const char * version,
    IR::IDLType_ptr discriminator_type,
    const IR::UnionMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::UnionDef_ptr _tao_retval = IR::UnionDef::_nil ();
  IR::UnionDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_union",
      12,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_union",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << discriminator_type) &&
              (_tao_out << members)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_union",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_union",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::EnumDef_ptr IR::Container::create_enum (
    const char * id,
    const char * name,
    const char * version,
    const IR::EnumMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::EnumDef_ptr _tao_retval = IR::EnumDef::_nil ();
  IR::EnumDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_enum",
      11,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_enum",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << members)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_enum",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_enum",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::AliasDef_ptr IR::Container::create_alias (
    const char * id,
    const char * name,
    const char * version,
    IR::IDLType_ptr original_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::AliasDef_ptr _tao_retval = IR::AliasDef::_nil ();
  IR::AliasDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_alias",
      12,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_alias",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << original_type)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_alias",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_alias",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::InterfaceDef_ptr IR::Container::create_interface (
    const char * id,
    const char * name,
    const char * version,
    const IR::InterfaceDefSeq & base_interfaces,
    CORBA::Boolean is_abstract,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::InterfaceDef_ptr _tao_retval = IR::InterfaceDef::_nil ();
  IR::InterfaceDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_interface",
      16,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_interface",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << base_interfaces) &&
              (_tao_out << CORBA::Any::from_boolean (is_abstract))
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_interface",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_interface",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::ValueDef_ptr IR::Container::create_value (
    const char * id,
    const char * name,
    const char * version,
    CORBA::Boolean is_custom,
    CORBA::Boolean is_abstract,
    IR::ValueDef_ptr base_value,
    CORBA::Boolean is_truncatable,
    const IR::ValueDefSeq & abstract_base_values,
    const IR::InterfaceDefSeq & supported_interfaces,
    const IR::InitializerSeq & initializers,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::ValueDef_ptr _tao_retval = IR::ValueDef::_nil ();
  IR::ValueDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_value",
      12,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_value",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << CORBA::Any::from_boolean (is_custom)) &&
              (_tao_out << CORBA::Any::from_boolean (is_abstract)) &&
              (_tao_out << base_value) &&
              (_tao_out << CORBA::Any::from_boolean (is_truncatable)) &&
              (_tao_out << abstract_base_values) &&
              (_tao_out << supported_interfaces) &&
              (_tao_out << initializers)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_value",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_value",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::ValueBoxDef_ptr IR::Container::create_value_box (
    const char * id,
    const char * name,
    const char * version,
    IR::IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::ValueBoxDef_ptr _tao_retval = IR::ValueBoxDef::_nil ();
  IR::ValueBoxDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_value_box",
      16,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_value_box",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << original_type_def)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_value_box",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_value_box",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::ExceptionDef_ptr IR::Container::create_exception (
    const char * id,
    const char * name,
    const char * version,
    const IR::StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::ExceptionDef_ptr _tao_retval = IR::ExceptionDef::_nil ();
  IR::ExceptionDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_exception",
      16,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_exception",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << members)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_exception",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_exception",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::NativeDef_ptr IR::Container::create_native (
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::NativeDef_ptr _tao_retval = IR::NativeDef::_nil ();
  IR::NativeDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_native",
      13,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_native",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_native",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_native",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::Boolean IR::Container::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::Container::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/Container:1.0";
}

IR::TAO_IR_Container_Default_Proxy_Factory::TAO_IR_Container_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_Container_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_Container_Default_Proxy_Factory::~TAO_IR_Container_Default_Proxy_Factory (void)
{
}

IR::Container_ptr
IR::TAO_IR_Container_Default_Proxy_Factory::create_proxy (
    ::IR::Container_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_Container_Proxy_Factory_Adapter::TAO_IR_Container_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_Container_Proxy_Factory_Adapter::~TAO_IR_Container_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_Container_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_Container_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_Container_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::Container_ptr
IR::TAO_IR_Container_Proxy_Factory_Adapter::create_proxy (
    ::IR::Container_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_Container_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_Container_Smart_Proxy_Base::TAO_IR_Container_Smart_Proxy_Base (::IR::Container_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_Container_Smart_Proxy_Base::~TAO_IR_Container_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_Container_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

IR::Contained_ptr IR::TAO_IR_Container_Smart_Proxy_Base::lookup  (
    const char * search_name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->lookup (
      search_name,
      ACE_TRY_ENV
    );

}

IR::ContainedSeq * IR::TAO_IR_Container_Smart_Proxy_Base::contents  (
    IR::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->contents (
      limit_type,
      exclude_inherited,
      ACE_TRY_ENV
    );

}

IR::ContainedSeq * IR::TAO_IR_Container_Smart_Proxy_Base::lookup_name  (
    const char * search_name,
    CORBA::Long levels_to_search,
    IR::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->lookup_name (
      search_name,
      levels_to_search,
      limit_type,
      exclude_inherited,
      ACE_TRY_ENV
    );

}

IR::Container::DescriptionSeq * IR::TAO_IR_Container_Smart_Proxy_Base::describe_contents  (
    IR::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Long max_returned_objs,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->describe_contents (
      limit_type,
      exclude_inherited,
      max_returned_objs,
      ACE_TRY_ENV
    );

}

IR::ModuleDef_ptr IR::TAO_IR_Container_Smart_Proxy_Base::create_module  (
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_module (
      id,
      name,
      version,
      ACE_TRY_ENV
    );

}

IR::ConstantDef_ptr IR::TAO_IR_Container_Smart_Proxy_Base::create_constant  (
    const char * id,
    const char * name,
    const char * version,
    IR::IDLType_ptr type,
    const CORBA::Any & value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_constant (
      id,
      name,
      version,
      type,
      value,
      ACE_TRY_ENV
    );

}

IR::StructDef_ptr IR::TAO_IR_Container_Smart_Proxy_Base::create_struct  (
    const char * id,
    const char * name,
    const char * version,
    const IR::StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_struct (
      id,
      name,
      version,
      members,
      ACE_TRY_ENV
    );

}

IR::UnionDef_ptr IR::TAO_IR_Container_Smart_Proxy_Base::create_union  (
    const char * id,
    const char * name,
    const char * version,
    IR::IDLType_ptr discriminator_type,
    const IR::UnionMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_union (
      id,
      name,
      version,
      discriminator_type,
      members,
      ACE_TRY_ENV
    );

}

IR::EnumDef_ptr IR::TAO_IR_Container_Smart_Proxy_Base::create_enum  (
    const char * id,
    const char * name,
    const char * version,
    const IR::EnumMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_enum (
      id,
      name,
      version,
      members,
      ACE_TRY_ENV
    );

}

IR::AliasDef_ptr IR::TAO_IR_Container_Smart_Proxy_Base::create_alias  (
    const char * id,
    const char * name,
    const char * version,
    IR::IDLType_ptr original_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_alias (
      id,
      name,
      version,
      original_type,
      ACE_TRY_ENV
    );

}

IR::InterfaceDef_ptr IR::TAO_IR_Container_Smart_Proxy_Base::create_interface  (
    const char * id,
    const char * name,
    const char * version,
    const IR::InterfaceDefSeq & base_interfaces,
    CORBA::Boolean is_abstract,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_interface (
      id,
      name,
      version,
      base_interfaces,
      is_abstract,
      ACE_TRY_ENV
    );

}

IR::ValueDef_ptr IR::TAO_IR_Container_Smart_Proxy_Base::create_value  (
    const char * id,
    const char * name,
    const char * version,
    CORBA::Boolean is_custom,
    CORBA::Boolean is_abstract,
    IR::ValueDef_ptr base_value,
    CORBA::Boolean is_truncatable,
    const IR::ValueDefSeq & abstract_base_values,
    const IR::InterfaceDefSeq & supported_interfaces,
    const IR::InitializerSeq & initializers,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_value (
      id,
      name,
      version,
      is_custom,
      is_abstract,
      base_value,
      is_truncatable,
      abstract_base_values,
      supported_interfaces,
      initializers,
      ACE_TRY_ENV
    );

}

IR::ValueBoxDef_ptr IR::TAO_IR_Container_Smart_Proxy_Base::create_value_box  (
    const char * id,
    const char * name,
    const char * version,
    IR::IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_value_box (
      id,
      name,
      version,
      original_type_def,
      ACE_TRY_ENV
    );

}

IR::ExceptionDef_ptr IR::TAO_IR_Container_Smart_Proxy_Base::create_exception  (
    const char * id,
    const char * name,
    const char * version,
    const IR::StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_exception (
      id,
      name,
      version,
      members,
      ACE_TRY_ENV
    );

}

IR::NativeDef_ptr IR::TAO_IR_Container_Smart_Proxy_Base::create_native  (
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_native (
      id,
      name,
      version,
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_Container_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_Container_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_Container[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7461), ACE_NTOHL (0x696e6572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/Container:1.0
  10, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x72000000),  // name = Container
};
static CORBA::TypeCode _tc_TAO_tc_IR_Container (CORBA::tk_objref, sizeof (_oc_IR_Container), (char *) &_oc_IR_Container, 0, sizeof (IR::Container));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Container, &_tc_TAO_tc_IR_Container)
TAO_NAMESPACE_END
void IR::IDLType::_tao_any_destructor (void *x)
{
  IDLType *tmp = ACE_static_cast (IDLType*,x);
  CORBA::release (tmp);
}

IR::IDLType_ptr IR::IDLType::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IDLType::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/IDLType:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (IDLType::_nil ());
  if (is_a == 0)
    return IDLType::_nil ();
  return IDLType::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::IDLType_ptr IR::IDLType::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IDLType::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  IDLType_ptr default_proxy = IDLType::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_IDLType_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_IDLType_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, IDLType (stub), IDLType::_nil ());
  return TAO_IR_IDLType_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::IDLType_ptr 
IR::IDLType::_duplicate (IDLType_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::TypeCode_ptr IR::IDLType::type (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_type",
      9,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_type",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_type",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_type",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::Boolean IR::IDLType::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::IDLType::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/IDLType:1.0";
}

IR::TAO_IR_IDLType_Default_Proxy_Factory::TAO_IR_IDLType_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_IDLType_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_IDLType_Default_Proxy_Factory::~TAO_IR_IDLType_Default_Proxy_Factory (void)
{
}

IR::IDLType_ptr
IR::TAO_IR_IDLType_Default_Proxy_Factory::create_proxy (
    ::IR::IDLType_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_IDLType_Proxy_Factory_Adapter::TAO_IR_IDLType_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_IDLType_Proxy_Factory_Adapter::~TAO_IR_IDLType_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_IDLType_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_IDLType_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_IDLType_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::IDLType_ptr
IR::TAO_IR_IDLType_Proxy_Factory_Adapter::create_proxy (
    ::IR::IDLType_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_IDLType_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_IDLType_Smart_Proxy_Base::TAO_IR_IDLType_Smart_Proxy_Base (::IR::IDLType_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_IDLType_Smart_Proxy_Base::~TAO_IR_IDLType_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_IDLType_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

CORBA::TypeCode_ptr IR::TAO_IR_IDLType_Smart_Proxy_Base::type  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->type (
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_IDLType_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_IDLType_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_IDLType[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
  8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType
};
static CORBA::TypeCode _tc_TAO_tc_IR_IDLType (CORBA::tk_objref, sizeof (_oc_IR_IDLType), (char *) &_oc_IR_IDLType, 0, sizeof (IR::IDLType));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_IDLType, &_tc_TAO_tc_IR_IDLType)
TAO_NAMESPACE_END
static const CORBA::Long _oc_IR_PrimitiveKind[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x72696d69), ACE_NTOHL (0x74697665), ACE_NTOHL (0x4b696e64), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/PrimitiveKind:1.0
  14, ACE_NTOHL (0x5072696d), ACE_NTOHL (0x69746976), ACE_NTOHL (0x654b696e), ACE_NTOHL (0x64000000),  // name = PrimitiveKind
  22, // member count
  8, ACE_NTOHL (0x706b5f6e), ACE_NTOHL (0x756c6c00),  // name = pk_null
  8, ACE_NTOHL (0x706b5f76), ACE_NTOHL (0x6f696400),  // name = pk_void
  9, ACE_NTOHL (0x706b5f73), ACE_NTOHL (0x686f7274), ACE_NTOHL (0x0),  // name = pk_short
  8, ACE_NTOHL (0x706b5f6c), ACE_NTOHL (0x6f6e6700),  // name = pk_long
  10, ACE_NTOHL (0x706b5f75), ACE_NTOHL (0x73686f72), ACE_NTOHL (0x74000000),  // name = pk_ushort
  9, ACE_NTOHL (0x706b5f75), ACE_NTOHL (0x6c6f6e67), ACE_NTOHL (0x0),  // name = pk_ulong
  9, ACE_NTOHL (0x706b5f66), ACE_NTOHL (0x6c6f6174), ACE_NTOHL (0x0),  // name = pk_float
  10, ACE_NTOHL (0x706b5f64), ACE_NTOHL (0x6f75626c), ACE_NTOHL (0x65000000),  // name = pk_double
  11, ACE_NTOHL (0x706b5f62), ACE_NTOHL (0x6f6f6c65), ACE_NTOHL (0x616e0000),  // name = pk_boolean
  8, ACE_NTOHL (0x706b5f63), ACE_NTOHL (0x68617200),  // name = pk_char
  9, ACE_NTOHL (0x706b5f6f), ACE_NTOHL (0x63746574), ACE_NTOHL (0x0),  // name = pk_octet
  7, ACE_NTOHL (0x706b5f61), ACE_NTOHL (0x6e790000),  // name = pk_any
  12, ACE_NTOHL (0x706b5f54), ACE_NTOHL (0x79706543), ACE_NTOHL (0x6f646500),  // name = pk_TypeCode
  13, ACE_NTOHL (0x706b5f50), ACE_NTOHL (0x72696e63), ACE_NTOHL (0x6970616c), ACE_NTOHL (0x0),  // name = pk_Principal
  10, ACE_NTOHL (0x706b5f73), ACE_NTOHL (0x7472696e), ACE_NTOHL (0x67000000),  // name = pk_string
  10, ACE_NTOHL (0x706b5f6f), ACE_NTOHL (0x626a7265), ACE_NTOHL (0x66000000),  // name = pk_objref
  12, ACE_NTOHL (0x706b5f6c), ACE_NTOHL (0x6f6e676c), ACE_NTOHL (0x6f6e6700),  // name = pk_longlong
  13, ACE_NTOHL (0x706b5f75), ACE_NTOHL (0x6c6f6e67), ACE_NTOHL (0x6c6f6e67), ACE_NTOHL (0x0),  // name = pk_ulonglong
  14, ACE_NTOHL (0x706b5f6c), ACE_NTOHL (0x6f6e6764), ACE_NTOHL (0x6f75626c), ACE_NTOHL (0x65000000),  // name = pk_longdouble
  9, ACE_NTOHL (0x706b5f77), ACE_NTOHL (0x63686172), ACE_NTOHL (0x0),  // name = pk_wchar
  11, ACE_NTOHL (0x706b5f77), ACE_NTOHL (0x73747269), ACE_NTOHL (0x6e670000),  // name = pk_wstring
  14, ACE_NTOHL (0x706b5f76), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x5f626173), ACE_NTOHL (0x65000000),  // name = pk_value_base
};
static CORBA::TypeCode _tc_TAO_tc_IR_PrimitiveKind (CORBA::tk_enum, sizeof (_oc_IR_PrimitiveKind), (char *) &_oc_IR_PrimitiveKind, 0, sizeof (IR::PrimitiveKind));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PrimitiveKind, &_tc_TAO_tc_IR_PrimitiveKind)
TAO_NAMESPACE_END
void IR::Repository::_tao_any_destructor (void *x)
{
  Repository *tmp = ACE_static_cast (Repository*,x);
  CORBA::release (tmp);
}

IR::Repository_ptr IR::Repository::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return Repository::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/Repository:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (Repository::_nil ());
  if (is_a == 0)
    return Repository::_nil ();
  return Repository::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::Repository_ptr IR::Repository::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return Repository::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  Repository_ptr default_proxy = Repository::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_Repository_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_Repository_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, Repository (stub), Repository::_nil ());
  return TAO_IR_Repository_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::Repository_ptr 
IR::Repository::_duplicate (Repository_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

IR::Contained_ptr IR::Repository::lookup_id (
    const char * search_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::Contained_ptr _tao_retval = IR::Contained::_nil ();
  IR::Contained_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "lookup_id",
      9,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "lookup_id",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << search_id)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "lookup_id",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "lookup_id",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::TypeCode_ptr IR::Repository::get_canonical_typecode (
    CORBA::TypeCode_ptr tc,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_canonical_typecode",
      22,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "get_canonical_typecode",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << tc)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "get_canonical_typecode",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "get_canonical_typecode",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::PrimitiveDef_ptr IR::Repository::get_primitive (
    IR::PrimitiveKind kind,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::PrimitiveDef_ptr _tao_retval = IR::PrimitiveDef::_nil ();
  IR::PrimitiveDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_primitive",
      13,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "get_primitive",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << kind)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "get_primitive",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "get_primitive",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::StringDef_ptr IR::Repository::create_string (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::StringDef_ptr _tao_retval = IR::StringDef::_nil ();
  IR::StringDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_string",
      13,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_string",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << bound)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_string",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_string",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::WstringDef_ptr IR::Repository::create_wstring (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::WstringDef_ptr _tao_retval = IR::WstringDef::_nil ();
  IR::WstringDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_wstring",
      14,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_wstring",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << bound)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_wstring",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_wstring",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::SequenceDef_ptr IR::Repository::create_sequence (
    CORBA::ULong bound,
    IR::IDLType_ptr element_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::SequenceDef_ptr _tao_retval = IR::SequenceDef::_nil ();
  IR::SequenceDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_sequence",
      15,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_sequence",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << bound) &&
              (_tao_out << element_type)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_sequence",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_sequence",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::ArrayDef_ptr IR::Repository::create_array (
    CORBA::ULong length,
    IR::IDLType_ptr element_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::ArrayDef_ptr _tao_retval = IR::ArrayDef::_nil ();
  IR::ArrayDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_array",
      12,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_array",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << length) &&
              (_tao_out << element_type)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_array",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_array",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::FixedDef_ptr IR::Repository::create_fixed (
    CORBA::UShort digits,
    CORBA::Short scale,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::FixedDef_ptr _tao_retval = IR::FixedDef::_nil ();
  IR::FixedDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_fixed",
      12,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_fixed",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << digits) &&
              (_tao_out << scale)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_fixed",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_fixed",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::Boolean IR::Repository::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Repository:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::Repository::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/Repository:1.0";
}

IR::TAO_IR_Repository_Default_Proxy_Factory::TAO_IR_Repository_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_Repository_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_Repository_Default_Proxy_Factory::~TAO_IR_Repository_Default_Proxy_Factory (void)
{
}

IR::Repository_ptr
IR::TAO_IR_Repository_Default_Proxy_Factory::create_proxy (
    ::IR::Repository_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_Repository_Proxy_Factory_Adapter::TAO_IR_Repository_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_Repository_Proxy_Factory_Adapter::~TAO_IR_Repository_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_Repository_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_Repository_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_Repository_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::Repository_ptr
IR::TAO_IR_Repository_Proxy_Factory_Adapter::create_proxy (
    ::IR::Repository_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_Repository_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_Repository_Smart_Proxy_Base::TAO_IR_Repository_Smart_Proxy_Base (::IR::Repository_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_Repository_Smart_Proxy_Base::~TAO_IR_Repository_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_Repository_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

IR::Contained_ptr IR::TAO_IR_Repository_Smart_Proxy_Base::lookup_id  (
    const char * search_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->lookup_id (
      search_id,
      ACE_TRY_ENV
    );

}

CORBA::TypeCode_ptr IR::TAO_IR_Repository_Smart_Proxy_Base::get_canonical_typecode  (
    CORBA::TypeCode_ptr tc,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->get_canonical_typecode (
      tc,
      ACE_TRY_ENV
    );

}

IR::PrimitiveDef_ptr IR::TAO_IR_Repository_Smart_Proxy_Base::get_primitive  (
    IR::PrimitiveKind kind,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->get_primitive (
      kind,
      ACE_TRY_ENV
    );

}

IR::StringDef_ptr IR::TAO_IR_Repository_Smart_Proxy_Base::create_string  (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_string (
      bound,
      ACE_TRY_ENV
    );

}

IR::WstringDef_ptr IR::TAO_IR_Repository_Smart_Proxy_Base::create_wstring  (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_wstring (
      bound,
      ACE_TRY_ENV
    );

}

IR::SequenceDef_ptr IR::TAO_IR_Repository_Smart_Proxy_Base::create_sequence  (
    CORBA::ULong bound,
    IR::IDLType_ptr element_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_sequence (
      bound,
      element_type,
      ACE_TRY_ENV
    );

}

IR::ArrayDef_ptr IR::TAO_IR_Repository_Smart_Proxy_Base::create_array  (
    CORBA::ULong length,
    IR::IDLType_ptr element_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_array (
      length,
      element_type,
      ACE_TRY_ENV
    );

}

IR::FixedDef_ptr IR::TAO_IR_Repository_Smart_Proxy_Base::create_fixed  (
    CORBA::UShort digits,
    CORBA::Short scale,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_fixed (
      digits,
      scale,
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_Repository_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_Repository_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_Repository[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x793a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Repository:1.0
  11, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72790000),  // name = Repository
};
static CORBA::TypeCode _tc_TAO_tc_IR_Repository (CORBA::tk_objref, sizeof (_oc_IR_Repository), (char *) &_oc_IR_Repository, 0, sizeof (IR::Repository));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Repository, &_tc_TAO_tc_IR_Repository)
TAO_NAMESPACE_END
void IR::ComponentRepository::_tao_any_destructor (void *x)
{
  ComponentRepository *tmp = ACE_static_cast (ComponentRepository*,x);
  CORBA::release (tmp);
}

IR::ComponentRepository_ptr IR::ComponentRepository::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return ComponentRepository::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ComponentRepository:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (ComponentRepository::_nil ());
  if (is_a == 0)
    return ComponentRepository::_nil ();
  return ComponentRepository::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::ComponentRepository_ptr IR::ComponentRepository::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return ComponentRepository::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  ComponentRepository_ptr default_proxy = ComponentRepository::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_ComponentRepository_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_ComponentRepository_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, ComponentRepository (stub), ComponentRepository::_nil ());
  return TAO_IR_ComponentRepository_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::ComponentRepository_ptr 
IR::ComponentRepository::_duplicate (ComponentRepository_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

IR::ComponentDef_ptr IR::ComponentRepository::create_component (
    const char * id,
    const char * name,
    const char * version,
    IR::ComponentDef_ptr base_component,
    const IR::InterfaceDefSeq & supports_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::ComponentDef_ptr _tao_retval = IR::ComponentDef::_nil ();
  IR::ComponentDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_component",
      16,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_component",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << base_component) &&
              (_tao_out << supports_interfaces)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_component",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_component",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::HomeDef_ptr IR::ComponentRepository::create_home (
    const char * id,
    const char * name,
    const char * version,
    IR::HomeDef_ptr base_home,
    IR::ComponentDef_ptr managed_component,
    IR::ValueDef_ptr primary_key,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::HomeDef_ptr _tao_retval = IR::HomeDef::_nil ();
  IR::HomeDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_home",
      11,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_home",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << base_home) &&
              (_tao_out << managed_component) &&
              (_tao_out << primary_key)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_home",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_home",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::Boolean IR::ComponentRepository::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ComponentRepository:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Repository:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::ComponentRepository::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ComponentRepository:1.0";
}

IR::TAO_IR_ComponentRepository_Default_Proxy_Factory::TAO_IR_ComponentRepository_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_ComponentRepository_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_ComponentRepository_Default_Proxy_Factory::~TAO_IR_ComponentRepository_Default_Proxy_Factory (void)
{
}

IR::ComponentRepository_ptr
IR::TAO_IR_ComponentRepository_Default_Proxy_Factory::create_proxy (
    ::IR::ComponentRepository_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_ComponentRepository_Proxy_Factory_Adapter::TAO_IR_ComponentRepository_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_ComponentRepository_Proxy_Factory_Adapter::~TAO_IR_ComponentRepository_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_ComponentRepository_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_ComponentRepository_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_ComponentRepository_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::ComponentRepository_ptr
IR::TAO_IR_ComponentRepository_Proxy_Factory_Adapter::create_proxy (
    ::IR::ComponentRepository_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_ComponentRepository_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_ComponentRepository_Smart_Proxy_Base::TAO_IR_ComponentRepository_Smart_Proxy_Base (::IR::ComponentRepository_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_ComponentRepository_Smart_Proxy_Base::~TAO_IR_ComponentRepository_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_ComponentRepository_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

IR::ComponentDef_ptr IR::TAO_IR_ComponentRepository_Smart_Proxy_Base::create_component  (
    const char * id,
    const char * name,
    const char * version,
    IR::ComponentDef_ptr base_component,
    const IR::InterfaceDefSeq & supports_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_component (
      id,
      name,
      version,
      base_component,
      supports_interfaces,
      ACE_TRY_ENV
    );

}

IR::HomeDef_ptr IR::TAO_IR_ComponentRepository_Smart_Proxy_Base::create_home  (
    const char * id,
    const char * name,
    const char * version,
    IR::HomeDef_ptr base_home,
    IR::ComponentDef_ptr managed_component,
    IR::ValueDef_ptr primary_key,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_home (
      id,
      name,
      version,
      base_home,
      managed_component,
      primary_key,
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_ComponentRepository_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_ComponentRepository_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_ComponentRepository[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6d706f), ACE_NTOHL (0x6e656e74), ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72793a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ComponentRepository:1.0
  20, ACE_NTOHL (0x436f6d70), ACE_NTOHL (0x6f6e656e), ACE_NTOHL (0x74526570), ACE_NTOHL (0x6f736974), ACE_NTOHL (0x6f727900),  // name = ComponentRepository
};
static CORBA::TypeCode _tc_TAO_tc_IR_ComponentRepository (CORBA::tk_objref, sizeof (_oc_IR_ComponentRepository), (char *) &_oc_IR_ComponentRepository, 0, sizeof (IR::ComponentRepository));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ComponentRepository, &_tc_TAO_tc_IR_ComponentRepository)
TAO_NAMESPACE_END
void IR::ModuleDef::_tao_any_destructor (void *x)
{
  ModuleDef *tmp = ACE_static_cast (ModuleDef*,x);
  CORBA::release (tmp);
}

IR::ModuleDef_ptr IR::ModuleDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return ModuleDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ModuleDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (ModuleDef::_nil ());
  if (is_a == 0)
    return ModuleDef::_nil ();
  return ModuleDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::ModuleDef_ptr IR::ModuleDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return ModuleDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  ModuleDef_ptr default_proxy = ModuleDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_ModuleDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_ModuleDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, ModuleDef (stub), ModuleDef::_nil ());
  return TAO_IR_ModuleDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::ModuleDef_ptr 
IR::ModuleDef::_duplicate (ModuleDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::Boolean IR::ModuleDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ModuleDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::ModuleDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ModuleDef:1.0";
}

IR::TAO_IR_ModuleDef_Default_Proxy_Factory::TAO_IR_ModuleDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_ModuleDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_ModuleDef_Default_Proxy_Factory::~TAO_IR_ModuleDef_Default_Proxy_Factory (void)
{
}

IR::ModuleDef_ptr
IR::TAO_IR_ModuleDef_Default_Proxy_Factory::create_proxy (
    ::IR::ModuleDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_ModuleDef_Proxy_Factory_Adapter::TAO_IR_ModuleDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_ModuleDef_Proxy_Factory_Adapter::~TAO_IR_ModuleDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_ModuleDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_ModuleDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_ModuleDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::ModuleDef_ptr
IR::TAO_IR_ModuleDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::ModuleDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_ModuleDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_ModuleDef_Smart_Proxy_Base::TAO_IR_ModuleDef_Smart_Proxy_Base (::IR::ModuleDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_ModuleDef_Smart_Proxy_Base::~TAO_IR_ModuleDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_ModuleDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_ModuleDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_ModuleDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_ModuleDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4d), ACE_NTOHL (0x6f64756c), ACE_NTOHL (0x65446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ModuleDef:1.0
  10, ACE_NTOHL (0x4d6f6475), ACE_NTOHL (0x6c654465), ACE_NTOHL (0x66000000),  // name = ModuleDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_ModuleDef (CORBA::tk_objref, sizeof (_oc_IR_ModuleDef), (char *) &_oc_IR_ModuleDef, 0, sizeof (IR::ModuleDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ModuleDef, &_tc_TAO_tc_IR_ModuleDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_IR_ModuleDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4d), ACE_NTOHL (0x6f64756c), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ModuleDescription:1.0
  18, ACE_NTOHL (0x4d6f6475), ACE_NTOHL (0x6c654465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e000000),  // name = ModuleDescription
  4, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  132, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_alias, // typecode kind for typedefs
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
      11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
      CORBA::tk_string, 
      0U, // string length


  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

};
static CORBA::TypeCode _tc_TAO_tc_IR_ModuleDescription (CORBA::tk_struct, sizeof (_oc_IR_ModuleDescription), (char *) &_oc_IR_ModuleDescription, 0, sizeof (IR::ModuleDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ModuleDescription, &_tc_TAO_tc_IR_ModuleDescription)
TAO_NAMESPACE_END
void IR::ModuleDescription::_tao_any_destructor (void *x)
{
  ModuleDescription *tmp = ACE_static_cast (ModuleDescription*,x);
  delete tmp;
}

void IR::ConstantDef::_tao_any_destructor (void *x)
{
  ConstantDef *tmp = ACE_static_cast (ConstantDef*,x);
  CORBA::release (tmp);
}

IR::ConstantDef_ptr IR::ConstantDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return ConstantDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ConstantDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (ConstantDef::_nil ());
  if (is_a == 0)
    return ConstantDef::_nil ();
  return ConstantDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::ConstantDef_ptr IR::ConstantDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return ConstantDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  ConstantDef_ptr default_proxy = ConstantDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_ConstantDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_ConstantDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, ConstantDef (stub), ConstantDef::_nil ());
  return TAO_IR_ConstantDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::ConstantDef_ptr 
IR::ConstantDef::_duplicate (ConstantDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::TypeCode_ptr IR::ConstantDef::type (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_type",
      9,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_type",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_type",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_type",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::IDLType_ptr IR::ConstantDef::type_def (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::IDLType_ptr _tao_retval = IR::IDLType::_nil ();
  IR::IDLType_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_type_def",
      13,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

void IR::ConstantDef::type_def (
    IR::IDLType_ptr type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_type_def",
      13,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << type_def)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::Any * IR::ConstantDef::value (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Any *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, CORBA::Any, _tao_retval);
  CORBA::Any_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_value",
      10,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_value",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_value",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_value",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

void IR::ConstantDef::value (
    const CORBA::Any & value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_value",
      10,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_value",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << value)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_value",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_value",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::Boolean IR::ConstantDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ConstantDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::ConstantDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ConstantDef:1.0";
}

IR::TAO_IR_ConstantDef_Default_Proxy_Factory::TAO_IR_ConstantDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_ConstantDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_ConstantDef_Default_Proxy_Factory::~TAO_IR_ConstantDef_Default_Proxy_Factory (void)
{
}

IR::ConstantDef_ptr
IR::TAO_IR_ConstantDef_Default_Proxy_Factory::create_proxy (
    ::IR::ConstantDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_ConstantDef_Proxy_Factory_Adapter::TAO_IR_ConstantDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_ConstantDef_Proxy_Factory_Adapter::~TAO_IR_ConstantDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_ConstantDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_ConstantDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_ConstantDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::ConstantDef_ptr
IR::TAO_IR_ConstantDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::ConstantDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_ConstantDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_ConstantDef_Smart_Proxy_Base::TAO_IR_ConstantDef_Smart_Proxy_Base (::IR::ConstantDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_ConstantDef_Smart_Proxy_Base::~TAO_IR_ConstantDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_ConstantDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

CORBA::TypeCode_ptr IR::TAO_IR_ConstantDef_Smart_Proxy_Base::type  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->type (
      ACE_TRY_ENV
    );

}

IR::IDLType_ptr IR::TAO_IR_ConstantDef_Smart_Proxy_Base::type_def  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->type_def (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_ConstantDef_Smart_Proxy_Base::type_def  (
    IR::IDLType_ptr type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->type_def (
      type_def,
      ACE_TRY_ENV
    );

}

CORBA::Any * IR::TAO_IR_ConstantDef_Smart_Proxy_Base::value  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->value (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_ConstantDef_Smart_Proxy_Base::value  (
    const CORBA::Any & value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->value (
      value,
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_ConstantDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_ConstantDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_ConstantDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7374), ACE_NTOHL (0x616e7444), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ConstantDef:1.0
  12, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x74616e74), ACE_NTOHL (0x44656600),  // name = ConstantDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_ConstantDef (CORBA::tk_objref, sizeof (_oc_IR_ConstantDef), (char *) &_oc_IR_ConstantDef, 0, sizeof (IR::ConstantDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ConstantDef, &_tc_TAO_tc_IR_ConstantDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_IR_ConstantDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7374), ACE_NTOHL (0x616e7444), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ConstantDescription:1.0
  20, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x74616e74), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = ConstantDescription
  6, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  132, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_alias, // typecode kind for typedefs
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
      11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
      CORBA::tk_string, 
      0U, // string length


  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

  6, ACE_NTOHL (0x76616c75), ACE_NTOHL (0x65000000),  // name = value
  CORBA::tk_any,

};
static CORBA::TypeCode _tc_TAO_tc_IR_ConstantDescription (CORBA::tk_struct, sizeof (_oc_IR_ConstantDescription), (char *) &_oc_IR_ConstantDescription, 0, sizeof (IR::ConstantDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ConstantDescription, &_tc_TAO_tc_IR_ConstantDescription)
TAO_NAMESPACE_END
void IR::ConstantDescription::_tao_any_destructor (void *x)
{
  ConstantDescription *tmp = ACE_static_cast (ConstantDescription*,x);
  delete tmp;
}

void IR::TypedefDef::_tao_any_destructor (void *x)
{
  TypedefDef *tmp = ACE_static_cast (TypedefDef*,x);
  CORBA::release (tmp);
}

IR::TypedefDef_ptr IR::TypedefDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return TypedefDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/TypedefDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (TypedefDef::_nil ());
  if (is_a == 0)
    return TypedefDef::_nil ();
  return TypedefDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::TypedefDef_ptr IR::TypedefDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return TypedefDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  TypedefDef_ptr default_proxy = TypedefDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_TypedefDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_TypedefDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, TypedefDef (stub), TypedefDef::_nil ());
  return TAO_IR_TypedefDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::TypedefDef_ptr 
IR::TypedefDef::_duplicate (TypedefDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::Boolean IR::TypedefDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::TypedefDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/TypedefDef:1.0";
}

IR::TAO_IR_TypedefDef_Default_Proxy_Factory::TAO_IR_TypedefDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_TypedefDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_TypedefDef_Default_Proxy_Factory::~TAO_IR_TypedefDef_Default_Proxy_Factory (void)
{
}

IR::TypedefDef_ptr
IR::TAO_IR_TypedefDef_Default_Proxy_Factory::create_proxy (
    ::IR::TypedefDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_TypedefDef_Proxy_Factory_Adapter::TAO_IR_TypedefDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_TypedefDef_Proxy_Factory_Adapter::~TAO_IR_TypedefDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_TypedefDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_TypedefDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_TypedefDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::TypedefDef_ptr
IR::TAO_IR_TypedefDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::TypedefDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_TypedefDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_TypedefDef_Smart_Proxy_Base::TAO_IR_TypedefDef_Smart_Proxy_Base (::IR::TypedefDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_TypedefDef_Smart_Proxy_Base::~TAO_IR_TypedefDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_TypedefDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_TypedefDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_TypedefDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_TypedefDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f54), ACE_NTOHL (0x79706564), ACE_NTOHL (0x65664465), ACE_NTOHL (0x663a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/TypedefDef:1.0
  11, ACE_NTOHL (0x54797065), ACE_NTOHL (0x64656644), ACE_NTOHL (0x65660000),  // name = TypedefDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_TypedefDef (CORBA::tk_objref, sizeof (_oc_IR_TypedefDef), (char *) &_oc_IR_TypedefDef, 0, sizeof (IR::TypedefDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_TypedefDef, &_tc_TAO_tc_IR_TypedefDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_IR_TypeDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f54), ACE_NTOHL (0x79706544), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/TypeDescription:1.0
  16, ACE_NTOHL (0x54797065), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = TypeDescription
  5, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  132, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_alias, // typecode kind for typedefs
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
      11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
      CORBA::tk_string, 
      0U, // string length


  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

};
static CORBA::TypeCode _tc_TAO_tc_IR_TypeDescription (CORBA::tk_struct, sizeof (_oc_IR_TypeDescription), (char *) &_oc_IR_TypeDescription, 0, sizeof (IR::TypeDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_TypeDescription, &_tc_TAO_tc_IR_TypeDescription)
TAO_NAMESPACE_END
void IR::TypeDescription::_tao_any_destructor (void *x)
{
  TypeDescription *tmp = ACE_static_cast (TypeDescription*,x);
  delete tmp;
}

void IR::StructDef::_tao_any_destructor (void *x)
{
  StructDef *tmp = ACE_static_cast (StructDef*,x);
  CORBA::release (tmp);
}

IR::StructDef_ptr IR::StructDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return StructDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/StructDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (StructDef::_nil ());
  if (is_a == 0)
    return StructDef::_nil ();
  return StructDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::StructDef_ptr IR::StructDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return StructDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  StructDef_ptr default_proxy = StructDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_StructDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_StructDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, StructDef (stub), StructDef::_nil ());
  return TAO_IR_StructDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::StructDef_ptr 
IR::StructDef::_duplicate (StructDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

IR::StructMemberSeq * IR::StructDef::members (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::StructMemberSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR::StructMemberSeq, _tao_retval);
  IR::StructMemberSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_members",
      12,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_members",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_members",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_members",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

void IR::StructDef::members (
    const IR::StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_members",
      12,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_members",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << members)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_members",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_members",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::Boolean IR::StructDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/StructDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::StructDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/StructDef:1.0";
}

IR::TAO_IR_StructDef_Default_Proxy_Factory::TAO_IR_StructDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_StructDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_StructDef_Default_Proxy_Factory::~TAO_IR_StructDef_Default_Proxy_Factory (void)
{
}

IR::StructDef_ptr
IR::TAO_IR_StructDef_Default_Proxy_Factory::create_proxy (
    ::IR::StructDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_StructDef_Proxy_Factory_Adapter::TAO_IR_StructDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_StructDef_Proxy_Factory_Adapter::~TAO_IR_StructDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_StructDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_StructDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_StructDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::StructDef_ptr
IR::TAO_IR_StructDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::StructDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_StructDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_StructDef_Smart_Proxy_Base::TAO_IR_StructDef_Smart_Proxy_Base (::IR::StructDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_StructDef_Smart_Proxy_Base::~TAO_IR_StructDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_StructDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

IR::StructMemberSeq * IR::TAO_IR_StructDef_Smart_Proxy_Base::members  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->members (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_StructDef_Smart_Proxy_Base::members  (
    const IR::StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->members (
      members,
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_StructDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_StructDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_StructDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x74446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/StructDef:1.0
  10, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744465), ACE_NTOHL (0x66000000),  // name = StructDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_StructDef (CORBA::tk_objref, sizeof (_oc_IR_StructDef), (char *) &_oc_IR_StructDef, 0, sizeof (IR::StructDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_StructDef, &_tc_TAO_tc_IR_StructDef)
TAO_NAMESPACE_END
void IR::UnionDef::_tao_any_destructor (void *x)
{
  UnionDef *tmp = ACE_static_cast (UnionDef*,x);
  CORBA::release (tmp);
}

IR::UnionDef_ptr IR::UnionDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return UnionDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/UnionDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (UnionDef::_nil ());
  if (is_a == 0)
    return UnionDef::_nil ();
  return UnionDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::UnionDef_ptr IR::UnionDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return UnionDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  UnionDef_ptr default_proxy = UnionDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_UnionDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_UnionDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, UnionDef (stub), UnionDef::_nil ());
  return TAO_IR_UnionDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::UnionDef_ptr 
IR::UnionDef::_duplicate (UnionDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::TypeCode_ptr IR::UnionDef::discriminator_type (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_discriminator_type",
      23,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_discriminator_type",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_discriminator_type",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_discriminator_type",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::IDLType_ptr IR::UnionDef::discriminator_type_def (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::IDLType_ptr _tao_retval = IR::IDLType::_nil ();
  IR::IDLType_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_discriminator_type_def",
      27,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_discriminator_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_discriminator_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_discriminator_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

void IR::UnionDef::discriminator_type_def (
    IR::IDLType_ptr discriminator_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_discriminator_type_def",
      27,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_discriminator_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << discriminator_type_def)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_discriminator_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_discriminator_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

IR::UnionMemberSeq * IR::UnionDef::members (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::UnionMemberSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR::UnionMemberSeq, _tao_retval);
  IR::UnionMemberSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_members",
      12,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_members",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_members",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_members",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

void IR::UnionDef::members (
    const IR::UnionMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_members",
      12,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_members",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << members)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_members",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_members",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::Boolean IR::UnionDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/UnionDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::UnionDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/UnionDef:1.0";
}

IR::TAO_IR_UnionDef_Default_Proxy_Factory::TAO_IR_UnionDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_UnionDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_UnionDef_Default_Proxy_Factory::~TAO_IR_UnionDef_Default_Proxy_Factory (void)
{
}

IR::UnionDef_ptr
IR::TAO_IR_UnionDef_Default_Proxy_Factory::create_proxy (
    ::IR::UnionDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_UnionDef_Proxy_Factory_Adapter::TAO_IR_UnionDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_UnionDef_Proxy_Factory_Adapter::~TAO_IR_UnionDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_UnionDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_UnionDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_UnionDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::UnionDef_ptr
IR::TAO_IR_UnionDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::UnionDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_UnionDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_UnionDef_Smart_Proxy_Base::TAO_IR_UnionDef_Smart_Proxy_Base (::IR::UnionDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_UnionDef_Smart_Proxy_Base::~TAO_IR_UnionDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_UnionDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

CORBA::TypeCode_ptr IR::TAO_IR_UnionDef_Smart_Proxy_Base::discriminator_type  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->discriminator_type (
      ACE_TRY_ENV
    );

}

IR::IDLType_ptr IR::TAO_IR_UnionDef_Smart_Proxy_Base::discriminator_type_def  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->discriminator_type_def (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_UnionDef_Smart_Proxy_Base::discriminator_type_def  (
    IR::IDLType_ptr discriminator_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->discriminator_type_def (
      discriminator_type_def,
      ACE_TRY_ENV
    );

}

IR::UnionMemberSeq * IR::TAO_IR_UnionDef_Smart_Proxy_Base::members  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->members (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_UnionDef_Smart_Proxy_Base::members  (
    const IR::UnionMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->members (
      members,
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_UnionDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_UnionDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_UnionDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x6e696f6e), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/UnionDef:1.0
  9, ACE_NTOHL (0x556e696f), ACE_NTOHL (0x6e446566), ACE_NTOHL (0x0),  // name = UnionDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_UnionDef (CORBA::tk_objref, sizeof (_oc_IR_UnionDef), (char *) &_oc_IR_UnionDef, 0, sizeof (IR::UnionDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UnionDef, &_tc_TAO_tc_IR_UnionDef)
TAO_NAMESPACE_END
void IR::EnumDef::_tao_any_destructor (void *x)
{
  EnumDef *tmp = ACE_static_cast (EnumDef*,x);
  CORBA::release (tmp);
}

IR::EnumDef_ptr IR::EnumDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return EnumDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/EnumDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (EnumDef::_nil ());
  if (is_a == 0)
    return EnumDef::_nil ();
  return EnumDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::EnumDef_ptr IR::EnumDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return EnumDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  EnumDef_ptr default_proxy = EnumDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_EnumDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_EnumDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, EnumDef (stub), EnumDef::_nil ());
  return TAO_IR_EnumDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::EnumDef_ptr 
IR::EnumDef::_duplicate (EnumDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

IR::EnumMemberSeq * IR::EnumDef::members (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::EnumMemberSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR::EnumMemberSeq, _tao_retval);
  IR::EnumMemberSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_members",
      12,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_members",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_members",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_members",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

void IR::EnumDef::members (
    const IR::EnumMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_members",
      12,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_members",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << members)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_members",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_members",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::Boolean IR::EnumDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EnumDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::EnumDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/EnumDef:1.0";
}

IR::TAO_IR_EnumDef_Default_Proxy_Factory::TAO_IR_EnumDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_EnumDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_EnumDef_Default_Proxy_Factory::~TAO_IR_EnumDef_Default_Proxy_Factory (void)
{
}

IR::EnumDef_ptr
IR::TAO_IR_EnumDef_Default_Proxy_Factory::create_proxy (
    ::IR::EnumDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_EnumDef_Proxy_Factory_Adapter::TAO_IR_EnumDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_EnumDef_Proxy_Factory_Adapter::~TAO_IR_EnumDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_EnumDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_EnumDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_EnumDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::EnumDef_ptr
IR::TAO_IR_EnumDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::EnumDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_EnumDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_EnumDef_Smart_Proxy_Base::TAO_IR_EnumDef_Smart_Proxy_Base (::IR::EnumDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_EnumDef_Smart_Proxy_Base::~TAO_IR_EnumDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_EnumDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

IR::EnumMemberSeq * IR::TAO_IR_EnumDef_Smart_Proxy_Base::members  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->members (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_EnumDef_Smart_Proxy_Base::members  (
    const IR::EnumMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->members (
      members,
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_EnumDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_EnumDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_EnumDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x6e756d44), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/EnumDef:1.0
  8, ACE_NTOHL (0x456e756d), ACE_NTOHL (0x44656600),  // name = EnumDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_EnumDef (CORBA::tk_objref, sizeof (_oc_IR_EnumDef), (char *) &_oc_IR_EnumDef, 0, sizeof (IR::EnumDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EnumDef, &_tc_TAO_tc_IR_EnumDef)
TAO_NAMESPACE_END
void IR::AliasDef::_tao_any_destructor (void *x)
{
  AliasDef *tmp = ACE_static_cast (AliasDef*,x);
  CORBA::release (tmp);
}

IR::AliasDef_ptr IR::AliasDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return AliasDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/AliasDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (AliasDef::_nil ());
  if (is_a == 0)
    return AliasDef::_nil ();
  return AliasDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::AliasDef_ptr IR::AliasDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return AliasDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  AliasDef_ptr default_proxy = AliasDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_AliasDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_AliasDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, AliasDef (stub), AliasDef::_nil ());
  return TAO_IR_AliasDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::AliasDef_ptr 
IR::AliasDef::_duplicate (AliasDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

IR::IDLType_ptr IR::AliasDef::original_type_def (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::IDLType_ptr _tao_retval = IR::IDLType::_nil ();
  IR::IDLType_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_original_type_def",
      22,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_original_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_original_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_original_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

void IR::AliasDef::original_type_def (
    IR::IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_original_type_def",
      22,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_original_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << original_type_def)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_original_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_original_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::Boolean IR::AliasDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/AliasDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::AliasDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/AliasDef:1.0";
}

IR::TAO_IR_AliasDef_Default_Proxy_Factory::TAO_IR_AliasDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_AliasDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_AliasDef_Default_Proxy_Factory::~TAO_IR_AliasDef_Default_Proxy_Factory (void)
{
}

IR::AliasDef_ptr
IR::TAO_IR_AliasDef_Default_Proxy_Factory::create_proxy (
    ::IR::AliasDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_AliasDef_Proxy_Factory_Adapter::TAO_IR_AliasDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_AliasDef_Proxy_Factory_Adapter::~TAO_IR_AliasDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_AliasDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_AliasDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_AliasDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::AliasDef_ptr
IR::TAO_IR_AliasDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::AliasDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_AliasDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_AliasDef_Smart_Proxy_Base::TAO_IR_AliasDef_Smart_Proxy_Base (::IR::AliasDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_AliasDef_Smart_Proxy_Base::~TAO_IR_AliasDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_AliasDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

IR::IDLType_ptr IR::TAO_IR_AliasDef_Smart_Proxy_Base::original_type_def  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->original_type_def (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_AliasDef_Smart_Proxy_Base::original_type_def  (
    IR::IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->original_type_def (
      original_type_def,
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_AliasDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_AliasDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_AliasDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x6c696173), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/AliasDef:1.0
  9, ACE_NTOHL (0x416c6961), ACE_NTOHL (0x73446566), ACE_NTOHL (0x0),  // name = AliasDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_AliasDef (CORBA::tk_objref, sizeof (_oc_IR_AliasDef), (char *) &_oc_IR_AliasDef, 0, sizeof (IR::AliasDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AliasDef, &_tc_TAO_tc_IR_AliasDef)
TAO_NAMESPACE_END
void IR::NativeDef::_tao_any_destructor (void *x)
{
  NativeDef *tmp = ACE_static_cast (NativeDef*,x);
  CORBA::release (tmp);
}

IR::NativeDef_ptr IR::NativeDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return NativeDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/NativeDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (NativeDef::_nil ());
  if (is_a == 0)
    return NativeDef::_nil ();
  return NativeDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::NativeDef_ptr IR::NativeDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return NativeDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  NativeDef_ptr default_proxy = NativeDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_NativeDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_NativeDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, NativeDef (stub), NativeDef::_nil ());
  return TAO_IR_NativeDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::NativeDef_ptr 
IR::NativeDef::_duplicate (NativeDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::Boolean IR::NativeDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/NativeDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::NativeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/NativeDef:1.0";
}

IR::TAO_IR_NativeDef_Default_Proxy_Factory::TAO_IR_NativeDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_NativeDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_NativeDef_Default_Proxy_Factory::~TAO_IR_NativeDef_Default_Proxy_Factory (void)
{
}

IR::NativeDef_ptr
IR::TAO_IR_NativeDef_Default_Proxy_Factory::create_proxy (
    ::IR::NativeDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_NativeDef_Proxy_Factory_Adapter::TAO_IR_NativeDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_NativeDef_Proxy_Factory_Adapter::~TAO_IR_NativeDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_NativeDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_NativeDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_NativeDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::NativeDef_ptr
IR::TAO_IR_NativeDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::NativeDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_NativeDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_NativeDef_Smart_Proxy_Base::TAO_IR_NativeDef_Smart_Proxy_Base (::IR::NativeDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_NativeDef_Smart_Proxy_Base::~TAO_IR_NativeDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_NativeDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_NativeDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_NativeDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_NativeDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4e), ACE_NTOHL (0x61746976), ACE_NTOHL (0x65446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/NativeDef:1.0
  10, ACE_NTOHL (0x4e617469), ACE_NTOHL (0x76654465), ACE_NTOHL (0x66000000),  // name = NativeDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_NativeDef (CORBA::tk_objref, sizeof (_oc_IR_NativeDef), (char *) &_oc_IR_NativeDef, 0, sizeof (IR::NativeDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_NativeDef, &_tc_TAO_tc_IR_NativeDef)
TAO_NAMESPACE_END
void IR::PrimitiveDef::_tao_any_destructor (void *x)
{
  PrimitiveDef *tmp = ACE_static_cast (PrimitiveDef*,x);
  CORBA::release (tmp);
}

IR::PrimitiveDef_ptr IR::PrimitiveDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return PrimitiveDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/PrimitiveDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (PrimitiveDef::_nil ());
  if (is_a == 0)
    return PrimitiveDef::_nil ();
  return PrimitiveDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::PrimitiveDef_ptr IR::PrimitiveDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return PrimitiveDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  PrimitiveDef_ptr default_proxy = PrimitiveDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_PrimitiveDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_PrimitiveDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, PrimitiveDef (stub), PrimitiveDef::_nil ());
  return TAO_IR_PrimitiveDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::PrimitiveDef_ptr 
IR::PrimitiveDef::_duplicate (PrimitiveDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

IR::PrimitiveKind IR::PrimitiveDef::kind (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::PrimitiveKind _tao_retval = (IR::PrimitiveKind)0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_kind",
      9,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN  (_tao_retval);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN  (_tao_retval);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_kind",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_retval)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_kind",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_kind",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN  (_tao_retval);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_retval;
}

CORBA::Boolean IR::PrimitiveDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/PrimitiveDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::PrimitiveDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/PrimitiveDef:1.0";
}

IR::TAO_IR_PrimitiveDef_Default_Proxy_Factory::TAO_IR_PrimitiveDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_PrimitiveDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_PrimitiveDef_Default_Proxy_Factory::~TAO_IR_PrimitiveDef_Default_Proxy_Factory (void)
{
}

IR::PrimitiveDef_ptr
IR::TAO_IR_PrimitiveDef_Default_Proxy_Factory::create_proxy (
    ::IR::PrimitiveDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_PrimitiveDef_Proxy_Factory_Adapter::TAO_IR_PrimitiveDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_PrimitiveDef_Proxy_Factory_Adapter::~TAO_IR_PrimitiveDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_PrimitiveDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_PrimitiveDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_PrimitiveDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::PrimitiveDef_ptr
IR::TAO_IR_PrimitiveDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::PrimitiveDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_PrimitiveDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_PrimitiveDef_Smart_Proxy_Base::TAO_IR_PrimitiveDef_Smart_Proxy_Base (::IR::PrimitiveDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_PrimitiveDef_Smart_Proxy_Base::~TAO_IR_PrimitiveDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_PrimitiveDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

IR::PrimitiveKind IR::TAO_IR_PrimitiveDef_Smart_Proxy_Base::kind  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->kind (
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_PrimitiveDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_PrimitiveDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_PrimitiveDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x72696d69), ACE_NTOHL (0x74697665), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/PrimitiveDef:1.0
  13, ACE_NTOHL (0x5072696d), ACE_NTOHL (0x69746976), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = PrimitiveDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_PrimitiveDef (CORBA::tk_objref, sizeof (_oc_IR_PrimitiveDef), (char *) &_oc_IR_PrimitiveDef, 0, sizeof (IR::PrimitiveDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PrimitiveDef, &_tc_TAO_tc_IR_PrimitiveDef)
TAO_NAMESPACE_END
void IR::StringDef::_tao_any_destructor (void *x)
{
  StringDef *tmp = ACE_static_cast (StringDef*,x);
  CORBA::release (tmp);
}

IR::StringDef_ptr IR::StringDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return StringDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/StringDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (StringDef::_nil ());
  if (is_a == 0)
    return StringDef::_nil ();
  return StringDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::StringDef_ptr IR::StringDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return StringDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  StringDef_ptr default_proxy = StringDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_StringDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_StringDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, StringDef (stub), StringDef::_nil ());
  return TAO_IR_StringDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::StringDef_ptr 
IR::StringDef::_duplicate (StringDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::ULong IR::StringDef::bound (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::ULong _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_bound",
      10,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN  (_tao_retval);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN  (_tao_retval);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_bound",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_retval)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_bound",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_bound",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN  (_tao_retval);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_retval;
}

void IR::StringDef::bound (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_bound",
      10,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_bound",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << bound)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_bound",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_bound",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::Boolean IR::StringDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/StringDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::StringDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/StringDef:1.0";
}

IR::TAO_IR_StringDef_Default_Proxy_Factory::TAO_IR_StringDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_StringDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_StringDef_Default_Proxy_Factory::~TAO_IR_StringDef_Default_Proxy_Factory (void)
{
}

IR::StringDef_ptr
IR::TAO_IR_StringDef_Default_Proxy_Factory::create_proxy (
    ::IR::StringDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_StringDef_Proxy_Factory_Adapter::TAO_IR_StringDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_StringDef_Proxy_Factory_Adapter::~TAO_IR_StringDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_StringDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_StringDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_StringDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::StringDef_ptr
IR::TAO_IR_StringDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::StringDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_StringDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_StringDef_Smart_Proxy_Base::TAO_IR_StringDef_Smart_Proxy_Base (::IR::StringDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_StringDef_Smart_Proxy_Base::~TAO_IR_StringDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_StringDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

CORBA::ULong IR::TAO_IR_StringDef_Smart_Proxy_Base::bound  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->bound (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_StringDef_Smart_Proxy_Base::bound  (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->bound (
      bound,
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_StringDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_StringDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_StringDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x7472696e), ACE_NTOHL (0x67446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/StringDef:1.0
  10, ACE_NTOHL (0x53747269), ACE_NTOHL (0x6e674465), ACE_NTOHL (0x66000000),  // name = StringDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_StringDef (CORBA::tk_objref, sizeof (_oc_IR_StringDef), (char *) &_oc_IR_StringDef, 0, sizeof (IR::StringDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_StringDef, &_tc_TAO_tc_IR_StringDef)
TAO_NAMESPACE_END
void IR::WstringDef::_tao_any_destructor (void *x)
{
  WstringDef *tmp = ACE_static_cast (WstringDef*,x);
  CORBA::release (tmp);
}

IR::WstringDef_ptr IR::WstringDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return WstringDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/WstringDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (WstringDef::_nil ());
  if (is_a == 0)
    return WstringDef::_nil ();
  return WstringDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::WstringDef_ptr IR::WstringDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return WstringDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  WstringDef_ptr default_proxy = WstringDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_WstringDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_WstringDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, WstringDef (stub), WstringDef::_nil ());
  return TAO_IR_WstringDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::WstringDef_ptr 
IR::WstringDef::_duplicate (WstringDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::ULong IR::WstringDef::bound (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::ULong _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_bound",
      10,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN  (_tao_retval);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN  (_tao_retval);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_bound",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_retval)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_bound",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_bound",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN  (_tao_retval);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_retval;
}

void IR::WstringDef::bound (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_bound",
      10,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_bound",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << bound)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_bound",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_bound",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::Boolean IR::WstringDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/WstringDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::WstringDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/WstringDef:1.0";
}

IR::TAO_IR_WstringDef_Default_Proxy_Factory::TAO_IR_WstringDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_WstringDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_WstringDef_Default_Proxy_Factory::~TAO_IR_WstringDef_Default_Proxy_Factory (void)
{
}

IR::WstringDef_ptr
IR::TAO_IR_WstringDef_Default_Proxy_Factory::create_proxy (
    ::IR::WstringDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_WstringDef_Proxy_Factory_Adapter::TAO_IR_WstringDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_WstringDef_Proxy_Factory_Adapter::~TAO_IR_WstringDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_WstringDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_WstringDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_WstringDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::WstringDef_ptr
IR::TAO_IR_WstringDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::WstringDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_WstringDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_WstringDef_Smart_Proxy_Base::TAO_IR_WstringDef_Smart_Proxy_Base (::IR::WstringDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_WstringDef_Smart_Proxy_Base::~TAO_IR_WstringDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_WstringDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

CORBA::ULong IR::TAO_IR_WstringDef_Smart_Proxy_Base::bound  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->bound (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_WstringDef_Smart_Proxy_Base::bound  (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->bound (
      bound,
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_WstringDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_WstringDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_WstringDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f57), ACE_NTOHL (0x73747269), ACE_NTOHL (0x6e674465), ACE_NTOHL (0x663a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/WstringDef:1.0
  11, ACE_NTOHL (0x57737472), ACE_NTOHL (0x696e6744), ACE_NTOHL (0x65660000),  // name = WstringDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_WstringDef (CORBA::tk_objref, sizeof (_oc_IR_WstringDef), (char *) &_oc_IR_WstringDef, 0, sizeof (IR::WstringDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_WstringDef, &_tc_TAO_tc_IR_WstringDef)
TAO_NAMESPACE_END
void IR::FixedDef::_tao_any_destructor (void *x)
{
  FixedDef *tmp = ACE_static_cast (FixedDef*,x);
  CORBA::release (tmp);
}

IR::FixedDef_ptr IR::FixedDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return FixedDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/FixedDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (FixedDef::_nil ());
  if (is_a == 0)
    return FixedDef::_nil ();
  return FixedDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::FixedDef_ptr IR::FixedDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return FixedDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  FixedDef_ptr default_proxy = FixedDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_FixedDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_FixedDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, FixedDef (stub), FixedDef::_nil ());
  return TAO_IR_FixedDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::FixedDef_ptr 
IR::FixedDef::_duplicate (FixedDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::UShort IR::FixedDef::digits (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::UShort _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_digits",
      11,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN  (_tao_retval);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN  (_tao_retval);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_digits",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_retval)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_digits",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_digits",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN  (_tao_retval);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_retval;
}

void IR::FixedDef::digits (
    CORBA::UShort digits,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_digits",
      11,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_digits",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << digits)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_digits",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_digits",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::Short IR::FixedDef::scale (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Short _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_scale",
      10,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN  (_tao_retval);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN  (_tao_retval);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_scale",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_retval)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_scale",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_scale",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN  (_tao_retval);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_retval;
}

void IR::FixedDef::scale (
    CORBA::Short scale,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_scale",
      10,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_scale",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << scale)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_scale",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_scale",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::Boolean IR::FixedDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/FixedDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::FixedDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/FixedDef:1.0";
}

IR::TAO_IR_FixedDef_Default_Proxy_Factory::TAO_IR_FixedDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_FixedDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_FixedDef_Default_Proxy_Factory::~TAO_IR_FixedDef_Default_Proxy_Factory (void)
{
}

IR::FixedDef_ptr
IR::TAO_IR_FixedDef_Default_Proxy_Factory::create_proxy (
    ::IR::FixedDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_FixedDef_Proxy_Factory_Adapter::TAO_IR_FixedDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_FixedDef_Proxy_Factory_Adapter::~TAO_IR_FixedDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_FixedDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_FixedDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_FixedDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::FixedDef_ptr
IR::TAO_IR_FixedDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::FixedDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_FixedDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_FixedDef_Smart_Proxy_Base::TAO_IR_FixedDef_Smart_Proxy_Base (::IR::FixedDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_FixedDef_Smart_Proxy_Base::~TAO_IR_FixedDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_FixedDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

CORBA::UShort IR::TAO_IR_FixedDef_Smart_Proxy_Base::digits  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->digits (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_FixedDef_Smart_Proxy_Base::digits  (
    CORBA::UShort digits,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->digits (
      digits,
      ACE_TRY_ENV
    );

}

CORBA::Short IR::TAO_IR_FixedDef_Smart_Proxy_Base::scale  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->scale (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_FixedDef_Smart_Proxy_Base::scale  (
    CORBA::Short scale,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->scale (
      scale,
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_FixedDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_FixedDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_FixedDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x69786564), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/FixedDef:1.0
  9, ACE_NTOHL (0x46697865), ACE_NTOHL (0x64446566), ACE_NTOHL (0x0),  // name = FixedDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_FixedDef (CORBA::tk_objref, sizeof (_oc_IR_FixedDef), (char *) &_oc_IR_FixedDef, 0, sizeof (IR::FixedDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FixedDef, &_tc_TAO_tc_IR_FixedDef)
TAO_NAMESPACE_END
void IR::SequenceDef::_tao_any_destructor (void *x)
{
  SequenceDef *tmp = ACE_static_cast (SequenceDef*,x);
  CORBA::release (tmp);
}

IR::SequenceDef_ptr IR::SequenceDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return SequenceDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/SequenceDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (SequenceDef::_nil ());
  if (is_a == 0)
    return SequenceDef::_nil ();
  return SequenceDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::SequenceDef_ptr IR::SequenceDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return SequenceDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  SequenceDef_ptr default_proxy = SequenceDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_SequenceDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_SequenceDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, SequenceDef (stub), SequenceDef::_nil ());
  return TAO_IR_SequenceDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::SequenceDef_ptr 
IR::SequenceDef::_duplicate (SequenceDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::ULong IR::SequenceDef::bound (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::ULong _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_bound",
      10,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN  (_tao_retval);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN  (_tao_retval);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_bound",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_retval)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_bound",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_bound",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN  (_tao_retval);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_retval;
}

void IR::SequenceDef::bound (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_bound",
      10,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_bound",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << bound)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_bound",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_bound",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::TypeCode_ptr IR::SequenceDef::element_type (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_element_type",
      17,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_element_type",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_element_type",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_element_type",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::IDLType_ptr IR::SequenceDef::element_type_def (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::IDLType_ptr _tao_retval = IR::IDLType::_nil ();
  IR::IDLType_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_element_type_def",
      21,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_element_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_element_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_element_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

void IR::SequenceDef::element_type_def (
    IR::IDLType_ptr element_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_element_type_def",
      21,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_element_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << element_type_def)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_element_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_element_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::Boolean IR::SequenceDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/SequenceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::SequenceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/SequenceDef:1.0";
}

IR::TAO_IR_SequenceDef_Default_Proxy_Factory::TAO_IR_SequenceDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_SequenceDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_SequenceDef_Default_Proxy_Factory::~TAO_IR_SequenceDef_Default_Proxy_Factory (void)
{
}

IR::SequenceDef_ptr
IR::TAO_IR_SequenceDef_Default_Proxy_Factory::create_proxy (
    ::IR::SequenceDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_SequenceDef_Proxy_Factory_Adapter::TAO_IR_SequenceDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_SequenceDef_Proxy_Factory_Adapter::~TAO_IR_SequenceDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_SequenceDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_SequenceDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_SequenceDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::SequenceDef_ptr
IR::TAO_IR_SequenceDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::SequenceDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_SequenceDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_SequenceDef_Smart_Proxy_Base::TAO_IR_SequenceDef_Smart_Proxy_Base (::IR::SequenceDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_SequenceDef_Smart_Proxy_Base::~TAO_IR_SequenceDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_SequenceDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

CORBA::ULong IR::TAO_IR_SequenceDef_Smart_Proxy_Base::bound  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->bound (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_SequenceDef_Smart_Proxy_Base::bound  (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->bound (
      bound,
      ACE_TRY_ENV
    );

}

CORBA::TypeCode_ptr IR::TAO_IR_SequenceDef_Smart_Proxy_Base::element_type  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->element_type (
      ACE_TRY_ENV
    );

}

IR::IDLType_ptr IR::TAO_IR_SequenceDef_Smart_Proxy_Base::element_type_def  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->element_type_def (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_SequenceDef_Smart_Proxy_Base::element_type_def  (
    IR::IDLType_ptr element_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->element_type_def (
      element_type_def,
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_SequenceDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_SequenceDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_SequenceDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x65717565), ACE_NTOHL (0x6e636544), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/SequenceDef:1.0
  12, ACE_NTOHL (0x53657175), ACE_NTOHL (0x656e6365), ACE_NTOHL (0x44656600),  // name = SequenceDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_SequenceDef (CORBA::tk_objref, sizeof (_oc_IR_SequenceDef), (char *) &_oc_IR_SequenceDef, 0, sizeof (IR::SequenceDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_SequenceDef, &_tc_TAO_tc_IR_SequenceDef)
TAO_NAMESPACE_END
void IR::ArrayDef::_tao_any_destructor (void *x)
{
  ArrayDef *tmp = ACE_static_cast (ArrayDef*,x);
  CORBA::release (tmp);
}

IR::ArrayDef_ptr IR::ArrayDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return ArrayDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ArrayDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (ArrayDef::_nil ());
  if (is_a == 0)
    return ArrayDef::_nil ();
  return ArrayDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::ArrayDef_ptr IR::ArrayDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return ArrayDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  ArrayDef_ptr default_proxy = ArrayDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_ArrayDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_ArrayDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, ArrayDef (stub), ArrayDef::_nil ());
  return TAO_IR_ArrayDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::ArrayDef_ptr 
IR::ArrayDef::_duplicate (ArrayDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::ULong IR::ArrayDef::length (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::ULong _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_length",
      11,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN  (_tao_retval);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN  (_tao_retval);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_length",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_retval)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_length",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_length",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN  (_tao_retval);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_retval;
}

void IR::ArrayDef::length (
    CORBA::ULong length,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_length",
      11,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_length",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << length)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_length",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_length",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::TypeCode_ptr IR::ArrayDef::element_type (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_element_type",
      17,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_element_type",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_element_type",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_element_type",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::IDLType_ptr IR::ArrayDef::element_type_def (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::IDLType_ptr _tao_retval = IR::IDLType::_nil ();
  IR::IDLType_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_element_type_def",
      21,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_element_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_element_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_element_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

void IR::ArrayDef::element_type_def (
    IR::IDLType_ptr element_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_element_type_def",
      21,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_element_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << element_type_def)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_element_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_element_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::Boolean IR::ArrayDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ArrayDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::ArrayDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ArrayDef:1.0";
}

IR::TAO_IR_ArrayDef_Default_Proxy_Factory::TAO_IR_ArrayDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_ArrayDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_ArrayDef_Default_Proxy_Factory::~TAO_IR_ArrayDef_Default_Proxy_Factory (void)
{
}

IR::ArrayDef_ptr
IR::TAO_IR_ArrayDef_Default_Proxy_Factory::create_proxy (
    ::IR::ArrayDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_ArrayDef_Proxy_Factory_Adapter::TAO_IR_ArrayDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_ArrayDef_Proxy_Factory_Adapter::~TAO_IR_ArrayDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_ArrayDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_ArrayDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_ArrayDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::ArrayDef_ptr
IR::TAO_IR_ArrayDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::ArrayDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_ArrayDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_ArrayDef_Smart_Proxy_Base::TAO_IR_ArrayDef_Smart_Proxy_Base (::IR::ArrayDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_ArrayDef_Smart_Proxy_Base::~TAO_IR_ArrayDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_ArrayDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

CORBA::ULong IR::TAO_IR_ArrayDef_Smart_Proxy_Base::length  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->length (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_ArrayDef_Smart_Proxy_Base::length  (
    CORBA::ULong length,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->length (
      length,
      ACE_TRY_ENV
    );

}

CORBA::TypeCode_ptr IR::TAO_IR_ArrayDef_Smart_Proxy_Base::element_type  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->element_type (
      ACE_TRY_ENV
    );

}

IR::IDLType_ptr IR::TAO_IR_ArrayDef_Smart_Proxy_Base::element_type_def  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->element_type_def (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_ArrayDef_Smart_Proxy_Base::element_type_def  (
    IR::IDLType_ptr element_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->element_type_def (
      element_type_def,
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_ArrayDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_ArrayDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_ArrayDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x72726179), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ArrayDef:1.0
  9, ACE_NTOHL (0x41727261), ACE_NTOHL (0x79446566), ACE_NTOHL (0x0),  // name = ArrayDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_ArrayDef (CORBA::tk_objref, sizeof (_oc_IR_ArrayDef), (char *) &_oc_IR_ArrayDef, 0, sizeof (IR::ArrayDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ArrayDef, &_tc_TAO_tc_IR_ArrayDef)
TAO_NAMESPACE_END
void IR::ExceptionDef::_tao_any_destructor (void *x)
{
  ExceptionDef *tmp = ACE_static_cast (ExceptionDef*,x);
  CORBA::release (tmp);
}

IR::ExceptionDef_ptr IR::ExceptionDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return ExceptionDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ExceptionDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (ExceptionDef::_nil ());
  if (is_a == 0)
    return ExceptionDef::_nil ();
  return ExceptionDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::ExceptionDef_ptr IR::ExceptionDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return ExceptionDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  ExceptionDef_ptr default_proxy = ExceptionDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_ExceptionDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_ExceptionDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, ExceptionDef (stub), ExceptionDef::_nil ());
  return TAO_IR_ExceptionDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::ExceptionDef_ptr 
IR::ExceptionDef::_duplicate (ExceptionDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::TypeCode_ptr IR::ExceptionDef::type (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_type",
      9,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_type",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_type",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_type",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::StructMemberSeq * IR::ExceptionDef::members (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::StructMemberSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR::StructMemberSeq, _tao_retval);
  IR::StructMemberSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_members",
      12,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_members",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_members",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_members",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

void IR::ExceptionDef::members (
    const IR::StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_members",
      12,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_members",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << members)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_members",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_members",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::Boolean IR::ExceptionDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ExceptionDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::ExceptionDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ExceptionDef:1.0";
}

IR::TAO_IR_ExceptionDef_Default_Proxy_Factory::TAO_IR_ExceptionDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_ExceptionDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_ExceptionDef_Default_Proxy_Factory::~TAO_IR_ExceptionDef_Default_Proxy_Factory (void)
{
}

IR::ExceptionDef_ptr
IR::TAO_IR_ExceptionDef_Default_Proxy_Factory::create_proxy (
    ::IR::ExceptionDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_ExceptionDef_Proxy_Factory_Adapter::TAO_IR_ExceptionDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_ExceptionDef_Proxy_Factory_Adapter::~TAO_IR_ExceptionDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_ExceptionDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_ExceptionDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_ExceptionDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::ExceptionDef_ptr
IR::TAO_IR_ExceptionDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::ExceptionDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_ExceptionDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_ExceptionDef_Smart_Proxy_Base::TAO_IR_ExceptionDef_Smart_Proxy_Base (::IR::ExceptionDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_ExceptionDef_Smart_Proxy_Base::~TAO_IR_ExceptionDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_ExceptionDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

CORBA::TypeCode_ptr IR::TAO_IR_ExceptionDef_Smart_Proxy_Base::type  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->type (
      ACE_TRY_ENV
    );

}

IR::StructMemberSeq * IR::TAO_IR_ExceptionDef_Smart_Proxy_Base::members  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->members (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_ExceptionDef_Smart_Proxy_Base::members  (
    const IR::StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->members (
      members,
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_ExceptionDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_ExceptionDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_ExceptionDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDef:1.0
  13, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446566), ACE_NTOHL (0x0),  // name = ExceptionDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_ExceptionDef (CORBA::tk_objref, sizeof (_oc_IR_ExceptionDef), (char *) &_oc_IR_ExceptionDef, 0, sizeof (IR::ExceptionDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ExceptionDef, &_tc_TAO_tc_IR_ExceptionDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_IR_ExceptionDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
  21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
  5, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  132, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_alias, // typecode kind for typedefs
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
      11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
      CORBA::tk_string, 
      0U, // string length


  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

};
static CORBA::TypeCode _tc_TAO_tc_IR_ExceptionDescription (CORBA::tk_struct, sizeof (_oc_IR_ExceptionDescription), (char *) &_oc_IR_ExceptionDescription, 0, sizeof (IR::ExceptionDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ExceptionDescription, &_tc_TAO_tc_IR_ExceptionDescription)
TAO_NAMESPACE_END
void IR::ExceptionDescription::_tao_any_destructor (void *x)
{
  ExceptionDescription *tmp = ACE_static_cast (ExceptionDescription*,x);
  delete tmp;
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_EXCEPTIONDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_EXCEPTIONDEFSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::ExceptionDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::ExceptionDef **old = ACE_reinterpret_cast (IR::ExceptionDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = IR::ExceptionDef::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR::ExceptionDef **tmp = ACE_reinterpret_cast (IR::ExceptionDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::ExceptionDef::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  IR::_TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::~_TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR::ExceptionDef **tmp = ACE_reinterpret_cast (IR::ExceptionDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::ExceptionDef::_nil ();
    }
  }
  void 
  IR::_TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR::ExceptionDef **tmp = ACE_static_cast (IR::ExceptionDef**, target);
    *tmp = IR::ExceptionDef::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  IR::_TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::_upcast (void *src) const
  {
    IR::ExceptionDef **tmp = ACE_static_cast (IR::ExceptionDef**, src);
    return *tmp;
  }
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_EXCEPTIONDEFSEQ_CS_)
#define _IR_EXCEPTIONDEFSEQ_CS_

// *************************************************************
// IR::ExceptionDefSeq
// *************************************************************

IR::ExceptionDefSeq::ExceptionDefSeq (void)
{}
IR::ExceptionDefSeq::ExceptionDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::ExceptionDef,IR::ExceptionDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::ExceptionDefSeq::ExceptionDefSeq (CORBA::ULong max, CORBA::ULong length, IR::ExceptionDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::ExceptionDef,IR::ExceptionDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::ExceptionDefSeq::ExceptionDefSeq (const ExceptionDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::ExceptionDef,IR::ExceptionDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::ExceptionDefSeq::~ExceptionDefSeq (void) // dtor
{}
void IR::ExceptionDefSeq::_tao_any_destructor (void *x)
{
  ExceptionDefSeq *tmp = ACE_static_cast (ExceptionDefSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_ExceptionDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ExceptionDefSeq:1.0
  16, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446566), ACE_NTOHL (0x53657100),  // name = ExceptionDefSeq
  CORBA::tk_sequence, // typecode kind
  76, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    60, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDef:1.0
      13, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446566), ACE_NTOHL (0x0),  // name = ExceptionDef

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_ExceptionDefSeq (CORBA::tk_alias, sizeof (_oc_IR_ExceptionDefSeq), (char *) &_oc_IR_ExceptionDefSeq, 0, sizeof (IR::ExceptionDefSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ExceptionDefSeq, &_tc_TAO_tc_IR_ExceptionDefSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_EXCDESCRIPTIONSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_IR_EXCDESCRIPTIONSEQ_CS_

  void
  IR::_TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::ExceptionDescription* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::ExceptionDescription *old = ACE_reinterpret_cast (IR::ExceptionDescription *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    IR::ExceptionDescription *tmp = ACE_reinterpret_cast (IR::ExceptionDescription *,this->buffer_);
    
    _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  IR::_TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::~_TAO_Unbounded_Sequence_IR_ExcDescriptionSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_EXCDESCRIPTIONSEQ_CS_)
#define _IR_EXCDESCRIPTIONSEQ_CS_

// *************************************************************
// IR::ExcDescriptionSeq
// *************************************************************

IR::ExcDescriptionSeq::ExcDescriptionSeq (void)
{}
IR::ExcDescriptionSeq::ExcDescriptionSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::ExceptionDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::ExcDescriptionSeq::ExcDescriptionSeq (CORBA::ULong max, CORBA::ULong length, IR::ExceptionDescription *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::ExceptionDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::ExcDescriptionSeq::ExcDescriptionSeq (const ExcDescriptionSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::ExceptionDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::ExcDescriptionSeq::~ExcDescriptionSeq (void) // dtor
{}
void IR::ExcDescriptionSeq::_tao_any_destructor (void *x)
{
  ExcDescriptionSeq *tmp = ACE_static_cast (ExcDescriptionSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_ExcDescriptionSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
  18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
  CORBA::tk_sequence, // typecode kind
  668, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    652, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
      21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
      5, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      132, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length


      3, ACE_NTOHL (0x69640000),  // name = id
      CORBA::tk_alias, // typecode kind for typedefs
      140, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length


      11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
      CORBA::tk_alias, // typecode kind for typedefs
      140, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length


      8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
        12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
        0U, // string length

      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
      CORBA::tk_TypeCode,


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_ExcDescriptionSeq (CORBA::tk_alias, sizeof (_oc_IR_ExcDescriptionSeq), (char *) &_oc_IR_ExcDescriptionSeq, 0, sizeof (IR::ExcDescriptionSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ExcDescriptionSeq, &_tc_TAO_tc_IR_ExcDescriptionSeq)
TAO_NAMESPACE_END
static const CORBA::Long _oc_IR_AttributeMode[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/AttributeMode:1.0
  14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
  2, // member count
  12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
  14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY
};
static CORBA::TypeCode _tc_TAO_tc_IR_AttributeMode (CORBA::tk_enum, sizeof (_oc_IR_AttributeMode), (char *) &_oc_IR_AttributeMode, 0, sizeof (IR::AttributeMode));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AttributeMode, &_tc_TAO_tc_IR_AttributeMode)
TAO_NAMESPACE_END
void IR::AttributeDef::_tao_any_destructor (void *x)
{
  AttributeDef *tmp = ACE_static_cast (AttributeDef*,x);
  CORBA::release (tmp);
}

IR::AttributeDef_ptr IR::AttributeDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return AttributeDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/AttributeDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (AttributeDef::_nil ());
  if (is_a == 0)
    return AttributeDef::_nil ();
  return AttributeDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::AttributeDef_ptr IR::AttributeDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return AttributeDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  AttributeDef_ptr default_proxy = AttributeDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_AttributeDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_AttributeDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, AttributeDef (stub), AttributeDef::_nil ());
  return TAO_IR_AttributeDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::AttributeDef_ptr 
IR::AttributeDef::_duplicate (AttributeDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::TypeCode_ptr IR::AttributeDef::type (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_type",
      9,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_type",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_type",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_type",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::IDLType_ptr IR::AttributeDef::type_def (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::IDLType_ptr _tao_retval = IR::IDLType::_nil ();
  IR::IDLType_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_type_def",
      13,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

void IR::AttributeDef::type_def (
    IR::IDLType_ptr type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_type_def",
      13,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << type_def)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

IR::AttributeMode IR::AttributeDef::mode (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::AttributeMode _tao_retval = (IR::AttributeMode)0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_mode",
      9,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN  (_tao_retval);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN  (_tao_retval);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_mode",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_retval)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_mode",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_mode",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN  (_tao_retval);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_retval;
}

void IR::AttributeDef::mode (
    IR::AttributeMode mode,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_mode",
      9,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_mode",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << mode)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_mode",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_mode",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::Boolean IR::AttributeDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/AttributeDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::AttributeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/AttributeDef:1.0";
}

IR::TAO_IR_AttributeDef_Default_Proxy_Factory::TAO_IR_AttributeDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_AttributeDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_AttributeDef_Default_Proxy_Factory::~TAO_IR_AttributeDef_Default_Proxy_Factory (void)
{
}

IR::AttributeDef_ptr
IR::TAO_IR_AttributeDef_Default_Proxy_Factory::create_proxy (
    ::IR::AttributeDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_AttributeDef_Proxy_Factory_Adapter::TAO_IR_AttributeDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_AttributeDef_Proxy_Factory_Adapter::~TAO_IR_AttributeDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_AttributeDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_AttributeDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_AttributeDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::AttributeDef_ptr
IR::TAO_IR_AttributeDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::AttributeDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_AttributeDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_AttributeDef_Smart_Proxy_Base::TAO_IR_AttributeDef_Smart_Proxy_Base (::IR::AttributeDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_AttributeDef_Smart_Proxy_Base::~TAO_IR_AttributeDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_AttributeDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

CORBA::TypeCode_ptr IR::TAO_IR_AttributeDef_Smart_Proxy_Base::type  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->type (
      ACE_TRY_ENV
    );

}

IR::IDLType_ptr IR::TAO_IR_AttributeDef_Smart_Proxy_Base::type_def  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->type_def (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_AttributeDef_Smart_Proxy_Base::type_def  (
    IR::IDLType_ptr type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->type_def (
      type_def,
      ACE_TRY_ENV
    );

}

IR::AttributeMode IR::TAO_IR_AttributeDef_Smart_Proxy_Base::mode  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->mode (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_AttributeDef_Smart_Proxy_Base::mode  (
    IR::AttributeMode mode,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->mode (
      mode,
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_AttributeDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_AttributeDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_AttributeDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/AttributeDef:1.0
  13, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = AttributeDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_AttributeDef (CORBA::tk_objref, sizeof (_oc_IR_AttributeDef), (char *) &_oc_IR_AttributeDef, 0, sizeof (IR::AttributeDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AttributeDef, &_tc_TAO_tc_IR_AttributeDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_IR_AttributeDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/AttributeDescription:1.0
  21, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = AttributeDescription
  8, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  132, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_alias, // typecode kind for typedefs
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
      11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
      CORBA::tk_string, 
      0U, // string length


  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

  5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
  CORBA::tk_enum, // typecode kind
  104, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/AttributeMode:1.0
    14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
    2, // member count
    12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
    14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY

  15, ACE_NTOHL (0x6765745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = get_exceptions
  CORBA::tk_alias, // typecode kind for typedefs
  748, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
    18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    668, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      652, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
        21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
        5, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        132, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_alias, // typecode kind for typedefs
          68, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
            11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
            CORBA::tk_string, 
            0U, // string length


        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        140, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_alias, // typecode kind for typedefs
          72, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
            13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
            CORBA::tk_string, 
            0U, // string length


        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        140, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_alias, // typecode kind for typedefs
          72, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
            13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
            CORBA::tk_string, 
            0U, // string length


        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string, 
          0U, // string length

        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,


      0U,


  15, ACE_NTOHL (0x7075745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = put_exceptions
  CORBA::tk_alias, // typecode kind for typedefs
  748, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
    18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    668, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      652, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
        21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
        5, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        132, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_alias, // typecode kind for typedefs
          68, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
            11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
            CORBA::tk_string, 
            0U, // string length


        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        140, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_alias, // typecode kind for typedefs
          72, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
            13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
            CORBA::tk_string, 
            0U, // string length


        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        140, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_alias, // typecode kind for typedefs
          72, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
            13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
            CORBA::tk_string, 
            0U, // string length


        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string, 
          0U, // string length

        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,


      0U,


};
static CORBA::TypeCode _tc_TAO_tc_IR_AttributeDescription (CORBA::tk_struct, sizeof (_oc_IR_AttributeDescription), (char *) &_oc_IR_AttributeDescription, 0, sizeof (IR::AttributeDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AttributeDescription, &_tc_TAO_tc_IR_AttributeDescription)
TAO_NAMESPACE_END
void IR::AttributeDescription::_tao_any_destructor (void *x)
{
  AttributeDescription *tmp = ACE_static_cast (AttributeDescription*,x);
  delete tmp;
}

static const CORBA::Long _oc_IR_OperationMode[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/OperationMode:1.0
  14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
  2, // member count
  10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
  10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY
};
static CORBA::TypeCode _tc_TAO_tc_IR_OperationMode (CORBA::tk_enum, sizeof (_oc_IR_OperationMode), (char *) &_oc_IR_OperationMode, 0, sizeof (IR::OperationMode));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_OperationMode, &_tc_TAO_tc_IR_OperationMode)
TAO_NAMESPACE_END
static const CORBA::Long _oc_IR_ParameterMode[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParameterMode:1.0
  14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
  3, // member count
  9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
  10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
  12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT
};
static CORBA::TypeCode _tc_TAO_tc_IR_ParameterMode (CORBA::tk_enum, sizeof (_oc_IR_ParameterMode), (char *) &_oc_IR_ParameterMode, 0, sizeof (IR::ParameterMode));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ParameterMode, &_tc_TAO_tc_IR_ParameterMode)
TAO_NAMESPACE_END
static const CORBA::Long _oc_IR_ParameterDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ParameterDescription:1.0
  21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
  4, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  132, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_alias, // typecode kind for typedefs
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
      11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
      CORBA::tk_string, 
      0U, // string length


  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

  9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
  CORBA::tk_objref, // typecode kind
  48, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
    8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

  5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
  CORBA::tk_enum, // typecode kind
  116, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParameterMode:1.0
    14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
    3, // member count
    9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
    10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
    12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT

};
static CORBA::TypeCode _tc_TAO_tc_IR_ParameterDescription (CORBA::tk_struct, sizeof (_oc_IR_ParameterDescription), (char *) &_oc_IR_ParameterDescription, 0, sizeof (IR::ParameterDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ParameterDescription, &_tc_TAO_tc_IR_ParameterDescription)
TAO_NAMESPACE_END
void IR::ParameterDescription::_tao_any_destructor (void *x)
{
  ParameterDescription *tmp = ACE_static_cast (ParameterDescription*,x);
  delete tmp;
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_PARDESCRIPTIONSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_IR_PARDESCRIPTIONSEQ_CS_

  void
  IR::_TAO_Unbounded_Sequence_IR_ParDescriptionSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::ParameterDescription* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_IR_ParDescriptionSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::ParameterDescription *old = ACE_reinterpret_cast (IR::ParameterDescription *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_IR_ParDescriptionSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Sequence_IR_ParDescriptionSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    IR::ParameterDescription *tmp = ACE_reinterpret_cast (IR::ParameterDescription *,this->buffer_);
    
    _TAO_Unbounded_Sequence_IR_ParDescriptionSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  IR::_TAO_Unbounded_Sequence_IR_ParDescriptionSeq::~_TAO_Unbounded_Sequence_IR_ParDescriptionSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_PARDESCRIPTIONSEQ_CS_)
#define _IR_PARDESCRIPTIONSEQ_CS_

// *************************************************************
// IR::ParDescriptionSeq
// *************************************************************

IR::ParDescriptionSeq::ParDescriptionSeq (void)
{}
IR::ParDescriptionSeq::ParDescriptionSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ParDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::ParameterDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::ParDescriptionSeq::ParDescriptionSeq (CORBA::ULong max, CORBA::ULong length, IR::ParameterDescription *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ParDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::ParameterDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::ParDescriptionSeq::ParDescriptionSeq (const ParDescriptionSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ParDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::ParameterDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::ParDescriptionSeq::~ParDescriptionSeq (void) // dtor
{}
void IR::ParDescriptionSeq::_tao_any_destructor (void *x)
{
  ParDescriptionSeq *tmp = ACE_static_cast (ParDescriptionSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_ParDescriptionSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x61724465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParDescriptionSeq:1.0
  18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
  CORBA::tk_sequence, // typecode kind
  472, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    456, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ParameterDescription:1.0
      21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
      4, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      132, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length


      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
      CORBA::tk_TypeCode,

      9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
      CORBA::tk_objref, // typecode kind
      48, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
        8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

      5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
      CORBA::tk_enum, // typecode kind
      116, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParameterMode:1.0
        14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
        3, // member count
        9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
        10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
        12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_ParDescriptionSeq (CORBA::tk_alias, sizeof (_oc_IR_ParDescriptionSeq), (char *) &_oc_IR_ParDescriptionSeq, 0, sizeof (IR::ParDescriptionSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ParDescriptionSeq, &_tc_TAO_tc_IR_ParDescriptionSeq)
TAO_NAMESPACE_END
static const CORBA::Long _oc_IR_ContextIdentifier[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ContextIdentifier:1.0
  18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
  CORBA::tk_alias, // typecode kind for typedefs
  132, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_alias, // typecode kind for typedefs
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
      11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
      CORBA::tk_string, 
      0U, // string length


};
static CORBA::TypeCode _tc_TAO_tc_IR_ContextIdentifier (CORBA::tk_alias, sizeof (_oc_IR_ContextIdentifier), (char *) &_oc_IR_ContextIdentifier, 0, sizeof (IR::ContextIdentifier));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ContextIdentifier, &_tc_TAO_tc_IR_ContextIdentifier)
TAO_NAMESPACE_END

#if !defined (_IR_CONTEXTIDSEQ_CS_)
#define _IR_CONTEXTIDSEQ_CS_

// *************************************************************
// IR::ContextIdSeq
// *************************************************************

IR::ContextIdSeq::ContextIdSeq (void)
{}
IR::ContextIdSeq::ContextIdSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::ContextIdSeq::ContextIdSeq (CORBA::ULong max, CORBA::ULong length, char * *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::ContextIdSeq::ContextIdSeq (const ContextIdSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::ContextIdSeq::~ContextIdSeq (void) // dtor
{}
void IR::ContextIdSeq::_tao_any_destructor (void *x)
{
  ContextIdSeq *tmp = ACE_static_cast (ContextIdSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_ContextIdSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ContextIdSeq:1.0
  13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
  CORBA::tk_sequence, // typecode kind
  228, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_alias, // typecode kind for typedefs
    212, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ContextIdentifier:1.0
      18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
      CORBA::tk_alias, // typecode kind for typedefs
      132, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length



    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_ContextIdSeq (CORBA::tk_alias, sizeof (_oc_IR_ContextIdSeq), (char *) &_oc_IR_ContextIdSeq, 0, sizeof (IR::ContextIdSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ContextIdSeq, &_tc_TAO_tc_IR_ContextIdSeq)
TAO_NAMESPACE_END
void IR::OperationDef::_tao_any_destructor (void *x)
{
  OperationDef *tmp = ACE_static_cast (OperationDef*,x);
  CORBA::release (tmp);
}

IR::OperationDef_ptr IR::OperationDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return OperationDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/OperationDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (OperationDef::_nil ());
  if (is_a == 0)
    return OperationDef::_nil ();
  return OperationDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::OperationDef_ptr IR::OperationDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return OperationDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  OperationDef_ptr default_proxy = OperationDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_OperationDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_OperationDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, OperationDef (stub), OperationDef::_nil ());
  return TAO_IR_OperationDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::OperationDef_ptr 
IR::OperationDef::_duplicate (OperationDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::TypeCode_ptr IR::OperationDef::result (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_result",
      11,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_result",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_result",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_result",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::IDLType_ptr IR::OperationDef::result_def (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::IDLType_ptr _tao_retval = IR::IDLType::_nil ();
  IR::IDLType_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_result_def",
      15,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_result_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_result_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_result_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

void IR::OperationDef::result_def (
    IR::IDLType_ptr result_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_result_def",
      15,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_result_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << result_def)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_result_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_result_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

IR::ParDescriptionSeq * IR::OperationDef::params (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::ParDescriptionSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR::ParDescriptionSeq, _tao_retval);
  IR::ParDescriptionSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_params",
      11,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_params",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_params",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_params",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

void IR::OperationDef::params (
    const IR::ParDescriptionSeq & params,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_params",
      11,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_params",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << params)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_params",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_params",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

IR::OperationMode IR::OperationDef::mode (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::OperationMode _tao_retval = (IR::OperationMode)0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_mode",
      9,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN  (_tao_retval);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN  (_tao_retval);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_mode",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_retval)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_mode",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_mode",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN  (_tao_retval);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_retval;
}

void IR::OperationDef::mode (
    IR::OperationMode mode,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_mode",
      9,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_mode",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << mode)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_mode",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_mode",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

IR::ContextIdSeq * IR::OperationDef::contexts (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::ContextIdSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR::ContextIdSeq, _tao_retval);
  IR::ContextIdSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_contexts",
      13,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_contexts",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_contexts",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_contexts",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

void IR::OperationDef::contexts (
    const IR::ContextIdSeq & contexts,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_contexts",
      13,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_contexts",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << contexts)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_contexts",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_contexts",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

IR::ExceptionDefSeq * IR::OperationDef::exceptions (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::ExceptionDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR::ExceptionDefSeq, _tao_retval);
  IR::ExceptionDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_exceptions",
      15,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_exceptions",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_exceptions",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_exceptions",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

void IR::OperationDef::exceptions (
    const IR::ExceptionDefSeq & exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_exceptions",
      15,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_exceptions",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << exceptions)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_exceptions",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_exceptions",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::Boolean IR::OperationDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/OperationDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::OperationDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/OperationDef:1.0";
}

IR::TAO_IR_OperationDef_Default_Proxy_Factory::TAO_IR_OperationDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_OperationDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_OperationDef_Default_Proxy_Factory::~TAO_IR_OperationDef_Default_Proxy_Factory (void)
{
}

IR::OperationDef_ptr
IR::TAO_IR_OperationDef_Default_Proxy_Factory::create_proxy (
    ::IR::OperationDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_OperationDef_Proxy_Factory_Adapter::TAO_IR_OperationDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_OperationDef_Proxy_Factory_Adapter::~TAO_IR_OperationDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_OperationDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_OperationDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_OperationDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::OperationDef_ptr
IR::TAO_IR_OperationDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::OperationDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_OperationDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_OperationDef_Smart_Proxy_Base::TAO_IR_OperationDef_Smart_Proxy_Base (::IR::OperationDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_OperationDef_Smart_Proxy_Base::~TAO_IR_OperationDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_OperationDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

CORBA::TypeCode_ptr IR::TAO_IR_OperationDef_Smart_Proxy_Base::result  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->result (
      ACE_TRY_ENV
    );

}

IR::IDLType_ptr IR::TAO_IR_OperationDef_Smart_Proxy_Base::result_def  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->result_def (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_OperationDef_Smart_Proxy_Base::result_def  (
    IR::IDLType_ptr result_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->result_def (
      result_def,
      ACE_TRY_ENV
    );

}

IR::ParDescriptionSeq * IR::TAO_IR_OperationDef_Smart_Proxy_Base::params  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->params (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_OperationDef_Smart_Proxy_Base::params  (
    const IR::ParDescriptionSeq & params,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->params (
      params,
      ACE_TRY_ENV
    );

}

IR::OperationMode IR::TAO_IR_OperationDef_Smart_Proxy_Base::mode  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->mode (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_OperationDef_Smart_Proxy_Base::mode  (
    IR::OperationMode mode,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->mode (
      mode,
      ACE_TRY_ENV
    );

}

IR::ContextIdSeq * IR::TAO_IR_OperationDef_Smart_Proxy_Base::contexts  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->contexts (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_OperationDef_Smart_Proxy_Base::contexts  (
    const IR::ContextIdSeq & contexts,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->contexts (
      contexts,
      ACE_TRY_ENV
    );

}

IR::ExceptionDefSeq * IR::TAO_IR_OperationDef_Smart_Proxy_Base::exceptions  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->exceptions (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_OperationDef_Smart_Proxy_Base::exceptions  (
    const IR::ExceptionDefSeq & exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->exceptions (
      exceptions,
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_OperationDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_OperationDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_OperationDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OperationDef:1.0
  13, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446566), ACE_NTOHL (0x0),  // name = OperationDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_OperationDef (CORBA::tk_objref, sizeof (_oc_IR_OperationDef), (char *) &_oc_IR_OperationDef, 0, sizeof (IR::OperationDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_OperationDef, &_tc_TAO_tc_IR_OperationDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_IR_OperationDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OperationDescription:1.0
  21, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = OperationDescription
  9, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  132, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_alias, // typecode kind for typedefs
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
      11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
      CORBA::tk_string, 
      0U, // string length


  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  7, ACE_NTOHL (0x72657375), ACE_NTOHL (0x6c740000),  // name = result
  CORBA::tk_TypeCode,

  5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
  CORBA::tk_enum, // typecode kind
  100, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/OperationMode:1.0
    14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
    2, // member count
    10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
    10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY

  9, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x65787473), ACE_NTOHL (0x0),  // name = contexts
  CORBA::tk_alias, // typecode kind for typedefs
  296, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ContextIdSeq:1.0
    13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
    CORBA::tk_sequence, // typecode kind
    228, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_alias, // typecode kind for typedefs
      212, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ContextIdentifier:1.0
        18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
        CORBA::tk_alias, // typecode kind for typedefs
        132, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_alias, // typecode kind for typedefs
          68, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
            11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
            CORBA::tk_string, 
            0U, // string length



      0U,


  11, ACE_NTOHL (0x70617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72730000),  // name = parameters
  CORBA::tk_alias, // typecode kind for typedefs
  552, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x61724465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParDescriptionSeq:1.0
    18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    472, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      456, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ParameterDescription:1.0
        21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
        4, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        132, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_alias, // typecode kind for typedefs
          68, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
            11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
            CORBA::tk_string, 
            0U, // string length


        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,

        9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
        CORBA::tk_objref, // typecode kind
        48, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
          8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        116, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParameterMode:1.0
          14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
          3, // member count
          9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
          10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
          12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT


      0U,


  11, ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = exceptions
  CORBA::tk_alias, // typecode kind for typedefs
  748, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
    18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    668, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      652, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
        21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
        5, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        132, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_alias, // typecode kind for typedefs
          68, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
            11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
            CORBA::tk_string, 
            0U, // string length


        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        140, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_alias, // typecode kind for typedefs
          72, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
            13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
            CORBA::tk_string, 
            0U, // string length


        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        140, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_alias, // typecode kind for typedefs
          72, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
            13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
            CORBA::tk_string, 
            0U, // string length


        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string, 
          0U, // string length

        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,


      0U,


};
static CORBA::TypeCode _tc_TAO_tc_IR_OperationDescription (CORBA::tk_struct, sizeof (_oc_IR_OperationDescription), (char *) &_oc_IR_OperationDescription, 0, sizeof (IR::OperationDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_OperationDescription, &_tc_TAO_tc_IR_OperationDescription)
TAO_NAMESPACE_END
void IR::OperationDescription::_tao_any_destructor (void *x)
{
  OperationDescription *tmp = ACE_static_cast (OperationDescription*,x);
  delete tmp;
}


#if !defined (_IR_REPOSITORYIDSEQ_CS_)
#define _IR_REPOSITORYIDSEQ_CS_

// *************************************************************
// IR::RepositoryIdSeq
// *************************************************************

IR::RepositoryIdSeq::RepositoryIdSeq (void)
{}
IR::RepositoryIdSeq::RepositoryIdSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::RepositoryIdSeq::RepositoryIdSeq (CORBA::ULong max, CORBA::ULong length, char * *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::RepositoryIdSeq::RepositoryIdSeq (const RepositoryIdSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::RepositoryIdSeq::~RepositoryIdSeq (void) // dtor
{}
void IR::RepositoryIdSeq::_tao_any_destructor (void *x)
{
  RepositoryIdSeq *tmp = ACE_static_cast (RepositoryIdSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_RepositoryIdSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79496453), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/RepositoryIdSeq:1.0
  16, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
  CORBA::tk_sequence, // typecode kind
  156, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_alias, // typecode kind for typedefs
    140, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_RepositoryIdSeq (CORBA::tk_alias, sizeof (_oc_IR_RepositoryIdSeq), (char *) &_oc_IR_RepositoryIdSeq, 0, sizeof (IR::RepositoryIdSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RepositoryIdSeq, &_tc_TAO_tc_IR_RepositoryIdSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_OPDESCRIPTIONSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_IR_OPDESCRIPTIONSEQ_CS_

  void
  IR::_TAO_Unbounded_Sequence_IR_OpDescriptionSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::OperationDescription* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_IR_OpDescriptionSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::OperationDescription *old = ACE_reinterpret_cast (IR::OperationDescription *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_IR_OpDescriptionSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Sequence_IR_OpDescriptionSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    IR::OperationDescription *tmp = ACE_reinterpret_cast (IR::OperationDescription *,this->buffer_);
    
    _TAO_Unbounded_Sequence_IR_OpDescriptionSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  IR::_TAO_Unbounded_Sequence_IR_OpDescriptionSeq::~_TAO_Unbounded_Sequence_IR_OpDescriptionSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_OPDESCRIPTIONSEQ_CS_)
#define _IR_OPDESCRIPTIONSEQ_CS_

// *************************************************************
// IR::OpDescriptionSeq
// *************************************************************

IR::OpDescriptionSeq::OpDescriptionSeq (void)
{}
IR::OpDescriptionSeq::OpDescriptionSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_OpDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::OperationDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::OpDescriptionSeq::OpDescriptionSeq (CORBA::ULong max, CORBA::ULong length, IR::OperationDescription *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_OpDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::OperationDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::OpDescriptionSeq::OpDescriptionSeq (const OpDescriptionSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_OpDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::OperationDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::OpDescriptionSeq::~OpDescriptionSeq (void) // dtor
{}
void IR::OpDescriptionSeq::_tao_any_destructor (void *x)
{
  OpDescriptionSeq *tmp = ACE_static_cast (OpDescriptionSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_OpDescriptionSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OpDescriptionSeq:1.0
  17, ACE_NTOHL (0x4f704465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x0),  // name = OpDescriptionSeq
  CORBA::tk_sequence, // typecode kind
  2456, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    2440, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OperationDescription:1.0
      21, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = OperationDescription
      9, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      132, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length


      3, ACE_NTOHL (0x69640000),  // name = id
      CORBA::tk_alias, // typecode kind for typedefs
      140, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length


      11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
      CORBA::tk_alias, // typecode kind for typedefs
      140, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length


      8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
        12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
        0U, // string length

      7, ACE_NTOHL (0x72657375), ACE_NTOHL (0x6c740000),  // name = result
      CORBA::tk_TypeCode,

      5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
      CORBA::tk_enum, // typecode kind
      100, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/OperationMode:1.0
        14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
        2, // member count
        10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
        10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY

      9, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x65787473), ACE_NTOHL (0x0),  // name = contexts
      CORBA::tk_alias, // typecode kind for typedefs
      296, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ContextIdSeq:1.0
        13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
        CORBA::tk_sequence, // typecode kind
        228, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_alias, // typecode kind for typedefs
          212, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ContextIdentifier:1.0
            18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
            CORBA::tk_alias, // typecode kind for typedefs
            132, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
              11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
                0U, // string length



          0U,


      11, ACE_NTOHL (0x70617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72730000),  // name = parameters
      CORBA::tk_alias, // typecode kind for typedefs
      552, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x61724465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParDescriptionSeq:1.0
        18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
        CORBA::tk_sequence, // typecode kind
        472, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          456, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ParameterDescription:1.0
            21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
            4, // member count
            5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
            CORBA::tk_alias, // typecode kind for typedefs
            132, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
              11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
                0U, // string length


            5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
            CORBA::tk_TypeCode,

            9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
            CORBA::tk_objref, // typecode kind
            48, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
              8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

            5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
            CORBA::tk_enum, // typecode kind
            116, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParameterMode:1.0
              14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
              3, // member count
              9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
              10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
              12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT


          0U,


      11, ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = exceptions
      CORBA::tk_alias, // typecode kind for typedefs
      748, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
        18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
        CORBA::tk_sequence, // typecode kind
        668, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          652, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
            21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
            5, // member count
            5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
            CORBA::tk_alias, // typecode kind for typedefs
            132, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
              11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
                0U, // string length


            3, ACE_NTOHL (0x69640000),  // name = id
            CORBA::tk_alias, // typecode kind for typedefs
            140, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
              13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
              CORBA::tk_alias, // typecode kind for typedefs
              72, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length


            11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
            CORBA::tk_alias, // typecode kind for typedefs
            140, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
              13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
              CORBA::tk_alias, // typecode kind for typedefs
              72, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length


            8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
            CORBA::tk_alias, // typecode kind for typedefs
            64, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
              12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
              CORBA::tk_string, 
              0U, // string length

            5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
            CORBA::tk_TypeCode,


          0U,



    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_OpDescriptionSeq (CORBA::tk_alias, sizeof (_oc_IR_OpDescriptionSeq), (char *) &_oc_IR_OpDescriptionSeq, 0, sizeof (IR::OpDescriptionSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_OpDescriptionSeq, &_tc_TAO_tc_IR_OpDescriptionSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_ATTRDESCRIPTIONSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_IR_ATTRDESCRIPTIONSEQ_CS_

  void
  IR::_TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::AttributeDescription* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::AttributeDescription *old = ACE_reinterpret_cast (IR::AttributeDescription *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    IR::AttributeDescription *tmp = ACE_reinterpret_cast (IR::AttributeDescription *,this->buffer_);
    
    _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  IR::_TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::~_TAO_Unbounded_Sequence_IR_AttrDescriptionSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_ATTRDESCRIPTIONSEQ_CS_)
#define _IR_ATTRDESCRIPTIONSEQ_CS_

// *************************************************************
// IR::AttrDescriptionSeq
// *************************************************************

IR::AttrDescriptionSeq::AttrDescriptionSeq (void)
{}
IR::AttrDescriptionSeq::AttrDescriptionSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::AttributeDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::AttrDescriptionSeq::AttrDescriptionSeq (CORBA::ULong max, CORBA::ULong length, IR::AttributeDescription *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::AttributeDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::AttrDescriptionSeq::AttrDescriptionSeq (const AttrDescriptionSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::AttributeDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::AttrDescriptionSeq::~AttrDescriptionSeq (void) // dtor
{}
void IR::AttrDescriptionSeq::_tao_any_destructor (void *x)
{
  AttrDescriptionSeq *tmp = ACE_static_cast (AttrDescriptionSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_AttrDescriptionSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/AttrDescriptionSeq:1.0
  19, ACE_NTOHL (0x41747472), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65710000),  // name = AttrDescriptionSeq
  CORBA::tk_sequence, // typecode kind
  2344, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    2328, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/AttributeDescription:1.0
      21, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = AttributeDescription
      8, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      132, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length


      3, ACE_NTOHL (0x69640000),  // name = id
      CORBA::tk_alias, // typecode kind for typedefs
      140, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length


      11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
      CORBA::tk_alias, // typecode kind for typedefs
      140, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length


      8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
        12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
        0U, // string length

      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
      CORBA::tk_TypeCode,

      5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
      CORBA::tk_enum, // typecode kind
      104, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/AttributeMode:1.0
        14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
        2, // member count
        12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
        14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY

      15, ACE_NTOHL (0x6765745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = get_exceptions
      CORBA::tk_alias, // typecode kind for typedefs
      748, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
        18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
        CORBA::tk_sequence, // typecode kind
        668, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          652, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
            21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
            5, // member count
            5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
            CORBA::tk_alias, // typecode kind for typedefs
            132, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
              11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
                0U, // string length


            3, ACE_NTOHL (0x69640000),  // name = id
            CORBA::tk_alias, // typecode kind for typedefs
            140, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
              13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
              CORBA::tk_alias, // typecode kind for typedefs
              72, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length


            11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
            CORBA::tk_alias, // typecode kind for typedefs
            140, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
              13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
              CORBA::tk_alias, // typecode kind for typedefs
              72, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length


            8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
            CORBA::tk_alias, // typecode kind for typedefs
            64, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
              12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
              CORBA::tk_string, 
              0U, // string length

            5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
            CORBA::tk_TypeCode,


          0U,


      15, ACE_NTOHL (0x7075745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = put_exceptions
      CORBA::tk_alias, // typecode kind for typedefs
      748, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
        18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
        CORBA::tk_sequence, // typecode kind
        668, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          652, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
            21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
            5, // member count
            5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
            CORBA::tk_alias, // typecode kind for typedefs
            132, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
              11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
                0U, // string length


            3, ACE_NTOHL (0x69640000),  // name = id
            CORBA::tk_alias, // typecode kind for typedefs
            140, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
              13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
              CORBA::tk_alias, // typecode kind for typedefs
              72, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length


            11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
            CORBA::tk_alias, // typecode kind for typedefs
            140, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
              13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
              CORBA::tk_alias, // typecode kind for typedefs
              72, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length


            8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
            CORBA::tk_alias, // typecode kind for typedefs
            64, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
              12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
              CORBA::tk_string, 
              0U, // string length

            5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
            CORBA::tk_TypeCode,


          0U,



    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_AttrDescriptionSeq (CORBA::tk_alias, sizeof (_oc_IR_AttrDescriptionSeq), (char *) &_oc_IR_AttrDescriptionSeq, 0, sizeof (IR::AttrDescriptionSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AttrDescriptionSeq, &_tc_TAO_tc_IR_AttrDescriptionSeq)
TAO_NAMESPACE_END
void IR::InterfaceDef::_tao_any_destructor (void *x)
{
  InterfaceDef *tmp = ACE_static_cast (InterfaceDef*,x);
  CORBA::release (tmp);
}

IR::InterfaceDef_ptr IR::InterfaceDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return InterfaceDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/InterfaceDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (InterfaceDef::_nil ());
  if (is_a == 0)
    return InterfaceDef::_nil ();
  return InterfaceDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::InterfaceDef_ptr IR::InterfaceDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return InterfaceDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  InterfaceDef_ptr default_proxy = InterfaceDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_InterfaceDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_InterfaceDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, InterfaceDef (stub), InterfaceDef::_nil ());
  return TAO_IR_InterfaceDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::InterfaceDef_ptr 
IR::InterfaceDef::_duplicate (InterfaceDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

IR::InterfaceDefSeq * IR::InterfaceDef::base_interfaces (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::InterfaceDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR::InterfaceDefSeq, _tao_retval);
  IR::InterfaceDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_base_interfaces",
      20,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_base_interfaces",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_base_interfaces",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_base_interfaces",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

void IR::InterfaceDef::base_interfaces (
    const IR::InterfaceDefSeq & base_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_base_interfaces",
      20,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_base_interfaces",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << base_interfaces)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_base_interfaces",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_base_interfaces",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::Boolean IR::InterfaceDef::is_abstract (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_is_abstract",
      16,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN  (_tao_retval);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN  (_tao_retval);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_is_abstract",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_is_abstract",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_is_abstract",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN  (_tao_retval);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_retval;
}

void IR::InterfaceDef::is_abstract (
    CORBA::Boolean is_abstract,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_is_abstract",
      16,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_is_abstract",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << CORBA::Any::from_boolean (is_abstract))
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_is_abstract",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_is_abstract",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::Boolean IR::InterfaceDef::is_local (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_is_local",
      13,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN  (_tao_retval);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN  (_tao_retval);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_is_local",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_is_local",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_is_local",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN  (_tao_retval);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_retval;
}

void IR::InterfaceDef::is_local (
    CORBA::Boolean is_local,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_is_local",
      13,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_is_local",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << CORBA::Any::from_boolean (is_local))
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_is_local",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_is_local",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::Boolean IR::InterfaceDef::is_a (
    const char * interface_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "is_a",
      4,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN  (_tao_retval);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN  (_tao_retval);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "is_a",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << interface_id)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "is_a",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "is_a",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN  (_tao_retval);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_retval;
}

IR::AttributeDef_ptr IR::InterfaceDef::create_attribute (
    const char * id,
    const char * name,
    const char * version,
    IR::IDLType_ptr type,
    IR::AttributeMode mode,
    const IR::ExceptionDefSeq & get_exceptions,
    const IR::ExceptionDefSeq & put_exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::AttributeDef_ptr _tao_retval = IR::AttributeDef::_nil ();
  IR::AttributeDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_attribute",
      16,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_attribute",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << type) &&
              (_tao_out << mode) &&
              (_tao_out << get_exceptions) &&
              (_tao_out << put_exceptions)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_attribute",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_attribute",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::OperationDef_ptr IR::InterfaceDef::create_operation (
    const char * id,
    const char * name,
    const char * version,
    IR::IDLType_ptr result,
    IR::OperationMode mode,
    const IR::ParDescriptionSeq & params,
    const IR::ExceptionDefSeq & exceptions,
    const IR::ContextIdSeq & contexts,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::OperationDef_ptr _tao_retval = IR::OperationDef::_nil ();
  IR::OperationDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_operation",
      16,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_operation",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << result) &&
              (_tao_out << mode) &&
              (_tao_out << params) &&
              (_tao_out << exceptions) &&
              (_tao_out << contexts)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_operation",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_operation",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::Boolean IR::InterfaceDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::InterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/InterfaceDef:1.0";
}

IR::TAO_IR_InterfaceDef_Default_Proxy_Factory::TAO_IR_InterfaceDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_InterfaceDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_InterfaceDef_Default_Proxy_Factory::~TAO_IR_InterfaceDef_Default_Proxy_Factory (void)
{
}

IR::InterfaceDef_ptr
IR::TAO_IR_InterfaceDef_Default_Proxy_Factory::create_proxy (
    ::IR::InterfaceDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_InterfaceDef_Proxy_Factory_Adapter::TAO_IR_InterfaceDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_InterfaceDef_Proxy_Factory_Adapter::~TAO_IR_InterfaceDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_InterfaceDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_InterfaceDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_InterfaceDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::InterfaceDef_ptr
IR::TAO_IR_InterfaceDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::InterfaceDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_InterfaceDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_InterfaceDef_Smart_Proxy_Base::TAO_IR_InterfaceDef_Smart_Proxy_Base (::IR::InterfaceDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_InterfaceDef_Smart_Proxy_Base::~TAO_IR_InterfaceDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_InterfaceDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

IR::InterfaceDefSeq * IR::TAO_IR_InterfaceDef_Smart_Proxy_Base::base_interfaces  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->base_interfaces (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_InterfaceDef_Smart_Proxy_Base::base_interfaces  (
    const IR::InterfaceDefSeq & base_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->base_interfaces (
      base_interfaces,
      ACE_TRY_ENV
    );

}

CORBA::Boolean IR::TAO_IR_InterfaceDef_Smart_Proxy_Base::is_abstract  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->is_abstract (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_InterfaceDef_Smart_Proxy_Base::is_abstract  (
    CORBA::Boolean is_abstract,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->is_abstract (
      is_abstract,
      ACE_TRY_ENV
    );

}

CORBA::Boolean IR::TAO_IR_InterfaceDef_Smart_Proxy_Base::is_local  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->is_local (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_InterfaceDef_Smart_Proxy_Base::is_local  (
    CORBA::Boolean is_local,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->is_local (
      is_local,
      ACE_TRY_ENV
    );

}

CORBA::Boolean IR::TAO_IR_InterfaceDef_Smart_Proxy_Base::is_a  (
    const char * interface_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->is_a (
      interface_id,
      ACE_TRY_ENV
    );

}

IR::AttributeDef_ptr IR::TAO_IR_InterfaceDef_Smart_Proxy_Base::create_attribute  (
    const char * id,
    const char * name,
    const char * version,
    IR::IDLType_ptr type,
    IR::AttributeMode mode,
    const IR::ExceptionDefSeq & get_exceptions,
    const IR::ExceptionDefSeq & put_exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_attribute (
      id,
      name,
      version,
      type,
      mode,
      get_exceptions,
      put_exceptions,
      ACE_TRY_ENV
    );

}

IR::OperationDef_ptr IR::TAO_IR_InterfaceDef_Smart_Proxy_Base::create_operation  (
    const char * id,
    const char * name,
    const char * version,
    IR::IDLType_ptr result,
    IR::OperationMode mode,
    const IR::ParDescriptionSeq & params,
    const IR::ExceptionDefSeq & exceptions,
    const IR::ContextIdSeq & contexts,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_operation (
      id,
      name,
      version,
      result,
      mode,
      params,
      exceptions,
      contexts,
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_InterfaceDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_InterfaceDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_InterfaceDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/InterfaceDef:1.0
  13, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = InterfaceDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_InterfaceDef (CORBA::tk_objref, sizeof (_oc_IR_InterfaceDef), (char *) &_oc_IR_InterfaceDef, 0, sizeof (IR::InterfaceDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_InterfaceDef, &_tc_TAO_tc_IR_InterfaceDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_IR_InterfaceDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/InterfaceDescription:1.0
  21, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = InterfaceDescription
  10, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  132, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_alias, // typecode kind for typedefs
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
      11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
      CORBA::tk_string, 
      0U, // string length


  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  11, ACE_NTOHL (0x6f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e730000),  // name = operations
  CORBA::tk_alias, // typecode kind for typedefs
  2532, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OpDescriptionSeq:1.0
    17, ACE_NTOHL (0x4f704465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x0),  // name = OpDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    2456, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      2440, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OperationDescription:1.0
        21, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = OperationDescription
        9, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        132, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_alias, // typecode kind for typedefs
          68, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
            11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
            CORBA::tk_string, 
            0U, // string length


        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        140, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_alias, // typecode kind for typedefs
          72, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
            13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
            CORBA::tk_string, 
            0U, // string length


        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        140, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_alias, // typecode kind for typedefs
          72, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
            13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
            CORBA::tk_string, 
            0U, // string length


        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string, 
          0U, // string length

        7, ACE_NTOHL (0x72657375), ACE_NTOHL (0x6c740000),  // name = result
        CORBA::tk_TypeCode,

        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        100, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/OperationMode:1.0
          14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
          2, // member count
          10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
          10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY

        9, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x65787473), ACE_NTOHL (0x0),  // name = contexts
        CORBA::tk_alias, // typecode kind for typedefs
        296, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ContextIdSeq:1.0
          13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
          CORBA::tk_sequence, // typecode kind
          228, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_alias, // typecode kind for typedefs
            212, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ContextIdentifier:1.0
              18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
              CORBA::tk_alias, // typecode kind for typedefs
              132, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_alias, // typecode kind for typedefs
                68, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                  11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                  CORBA::tk_string, 
                  0U, // string length



            0U,


        11, ACE_NTOHL (0x70617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72730000),  // name = parameters
        CORBA::tk_alias, // typecode kind for typedefs
        552, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x61724465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParDescriptionSeq:1.0
          18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          472, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            456, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ParameterDescription:1.0
              21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
              4, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              132, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_alias, // typecode kind for typedefs
                68, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                  11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                  CORBA::tk_string, 
                  0U, // string length


              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,

              9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
              CORBA::tk_objref, // typecode kind
              48, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
                8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

              5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
              CORBA::tk_enum, // typecode kind
              116, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParameterMode:1.0
                14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
                3, // member count
                9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
                10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
                12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT


            0U,


        11, ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = exceptions
        CORBA::tk_alias, // typecode kind for typedefs
        748, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          668, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            652, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              132, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_alias, // typecode kind for typedefs
                68, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                  11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                  CORBA::tk_string, 
                  0U, // string length


              3, ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              140, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_alias, // typecode kind for typedefs
                72, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                  13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                  CORBA::tk_string, 
                  0U, // string length


              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_alias, // typecode kind for typedefs
              140, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_alias, // typecode kind for typedefs
                72, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                  13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                  CORBA::tk_string, 
                  0U, // string length


              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string, 
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,



      0U,


  11, ACE_NTOHL (0x61747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65730000),  // name = attributes
  CORBA::tk_alias, // typecode kind for typedefs
  2424, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/AttrDescriptionSeq:1.0
    19, ACE_NTOHL (0x41747472), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65710000),  // name = AttrDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    2344, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      2328, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/AttributeDescription:1.0
        21, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = AttributeDescription
        8, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        132, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_alias, // typecode kind for typedefs
          68, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
            11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
            CORBA::tk_string, 
            0U, // string length


        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        140, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_alias, // typecode kind for typedefs
          72, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
            13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
            CORBA::tk_string, 
            0U, // string length


        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        140, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_alias, // typecode kind for typedefs
          72, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
            13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
            CORBA::tk_string, 
            0U, // string length


        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string, 
          0U, // string length

        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,

        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        104, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/AttributeMode:1.0
          14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
          2, // member count
          12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
          14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY

        15, ACE_NTOHL (0x6765745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = get_exceptions
        CORBA::tk_alias, // typecode kind for typedefs
        748, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          668, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            652, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              132, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_alias, // typecode kind for typedefs
                68, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                  11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                  CORBA::tk_string, 
                  0U, // string length


              3, ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              140, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_alias, // typecode kind for typedefs
                72, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                  13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                  CORBA::tk_string, 
                  0U, // string length


              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_alias, // typecode kind for typedefs
              140, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_alias, // typecode kind for typedefs
                72, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                  13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                  CORBA::tk_string, 
                  0U, // string length


              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string, 
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,


        15, ACE_NTOHL (0x7075745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = put_exceptions
        CORBA::tk_alias, // typecode kind for typedefs
        748, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          668, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            652, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              132, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_alias, // typecode kind for typedefs
                68, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                  11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                  CORBA::tk_string, 
                  0U, // string length


              3, ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              140, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_alias, // typecode kind for typedefs
                72, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                  13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                  CORBA::tk_string, 
                  0U, // string length


              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_alias, // typecode kind for typedefs
              140, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_alias, // typecode kind for typedefs
                72, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                  13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                  CORBA::tk_string, 
                  0U, // string length


              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string, 
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,



      0U,


  16, ACE_NTOHL (0x62617365), ACE_NTOHL (0x5f696e74), ACE_NTOHL (0x65726661), ACE_NTOHL (0x63657300),  // name = base_interfaces
  CORBA::tk_alias, // typecode kind for typedefs
  228, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79496453), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/RepositoryIdSeq:1.0
    16, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
    CORBA::tk_sequence, // typecode kind
    156, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_alias, // typecode kind for typedefs
      140, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length


      0U,


  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

  12, ACE_NTOHL (0x69735f61), ACE_NTOHL (0x62737472), ACE_NTOHL (0x61637400),  // name = is_abstract
  CORBA::tk_boolean,

  9, ACE_NTOHL (0x69735f6c), ACE_NTOHL (0x6f63616c), ACE_NTOHL (0x0),  // name = is_local
  CORBA::tk_boolean,

};
static CORBA::TypeCode _tc_TAO_tc_IR_InterfaceDescription (CORBA::tk_struct, sizeof (_oc_IR_InterfaceDescription), (char *) &_oc_IR_InterfaceDescription, 0, sizeof (IR::InterfaceDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_InterfaceDescription, &_tc_TAO_tc_IR_InterfaceDescription)
TAO_NAMESPACE_END
void IR::InterfaceDescription::_tao_any_destructor (void *x)
{
  InterfaceDescription *tmp = ACE_static_cast (InterfaceDescription*,x);
  delete tmp;
}

static const CORBA::Long _oc_IR_ValueMember[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ValueMember:1.0
  12, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657200),  // name = ValueMember
  7, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  132, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_alias, // typecode kind for typedefs
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
      11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
      CORBA::tk_string, 
      0U, // string length


  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

  9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
  CORBA::tk_objref, // typecode kind
  48, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
    8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

  7, ACE_NTOHL (0x61636365), ACE_NTOHL (0x73730000),  // name = access
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5669), ACE_NTOHL (0x73696269), ACE_NTOHL (0x6c697479), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Visibility:1.0
    11, ACE_NTOHL (0x56697369), ACE_NTOHL (0x62696c69), ACE_NTOHL (0x74790000),  // name = Visibility
    CORBA::tk_short,


};
static CORBA::TypeCode _tc_TAO_tc_IR_ValueMember (CORBA::tk_struct, sizeof (_oc_IR_ValueMember), (char *) &_oc_IR_ValueMember, 0, sizeof (IR::ValueMember));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueMember, &_tc_TAO_tc_IR_ValueMember)
TAO_NAMESPACE_END
void IR::ValueMember::_tao_any_destructor (void *x)
{
  ValueMember *tmp = ACE_static_cast (ValueMember*,x);
  delete tmp;
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_VALUEMEMBERSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_IR_VALUEMEMBERSEQ_CS_

  void
  IR::_TAO_Unbounded_Sequence_IR_ValueMemberSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::ValueMember* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_IR_ValueMemberSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::ValueMember *old = ACE_reinterpret_cast (IR::ValueMember *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_IR_ValueMemberSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Sequence_IR_ValueMemberSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    IR::ValueMember *tmp = ACE_reinterpret_cast (IR::ValueMember *,this->buffer_);
    
    _TAO_Unbounded_Sequence_IR_ValueMemberSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  IR::_TAO_Unbounded_Sequence_IR_ValueMemberSeq::~_TAO_Unbounded_Sequence_IR_ValueMemberSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_VALUEMEMBERSEQ_CS_)
#define _IR_VALUEMEMBERSEQ_CS_

// *************************************************************
// IR::ValueMemberSeq
// *************************************************************

IR::ValueMemberSeq::ValueMemberSeq (void)
{}
IR::ValueMemberSeq::ValueMemberSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ValueMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::ValueMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::ValueMemberSeq::ValueMemberSeq (CORBA::ULong max, CORBA::ULong length, IR::ValueMember *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ValueMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::ValueMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::ValueMemberSeq::ValueMemberSeq (const ValueMemberSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ValueMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::ValueMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::ValueMemberSeq::~ValueMemberSeq (void) // dtor
{}
void IR::ValueMemberSeq::_tao_any_destructor (void *x)
{
  ValueMemberSeq *tmp = ACE_static_cast (ValueMemberSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_ValueMemberSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65725365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ValueMemberSeq:1.0
  15, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657253), ACE_NTOHL (0x65710000),  // name = ValueMemberSeq
  CORBA::tk_sequence, // typecode kind
  804, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    788, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ValueMember:1.0
      12, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657200),  // name = ValueMember
      7, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      132, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length


      3, ACE_NTOHL (0x69640000),  // name = id
      CORBA::tk_alias, // typecode kind for typedefs
      140, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length


      11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
      CORBA::tk_alias, // typecode kind for typedefs
      140, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length


      8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
        12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
        0U, // string length

      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
      CORBA::tk_TypeCode,

      9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
      CORBA::tk_objref, // typecode kind
      48, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
        8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

      7, ACE_NTOHL (0x61636365), ACE_NTOHL (0x73730000),  // name = access
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5669), ACE_NTOHL (0x73696269), ACE_NTOHL (0x6c697479), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Visibility:1.0
        11, ACE_NTOHL (0x56697369), ACE_NTOHL (0x62696c69), ACE_NTOHL (0x74790000),  // name = Visibility
        CORBA::tk_short,



    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_ValueMemberSeq (CORBA::tk_alias, sizeof (_oc_IR_ValueMemberSeq), (char *) &_oc_IR_ValueMemberSeq, 0, sizeof (IR::ValueMemberSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueMemberSeq, &_tc_TAO_tc_IR_ValueMemberSeq)
TAO_NAMESPACE_END
void IR::ValueMemberDef::_tao_any_destructor (void *x)
{
  ValueMemberDef *tmp = ACE_static_cast (ValueMemberDef*,x);
  CORBA::release (tmp);
}

IR::ValueMemberDef_ptr IR::ValueMemberDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return ValueMemberDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ValueMemberDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (ValueMemberDef::_nil ());
  if (is_a == 0)
    return ValueMemberDef::_nil ();
  return ValueMemberDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::ValueMemberDef_ptr IR::ValueMemberDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return ValueMemberDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  ValueMemberDef_ptr default_proxy = ValueMemberDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_ValueMemberDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_ValueMemberDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, ValueMemberDef (stub), ValueMemberDef::_nil ());
  return TAO_IR_ValueMemberDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::ValueMemberDef_ptr 
IR::ValueMemberDef::_duplicate (ValueMemberDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::TypeCode_ptr IR::ValueMemberDef::type (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_type",
      9,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_type",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_type",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_type",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::IDLType_ptr IR::ValueMemberDef::type_def (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::IDLType_ptr _tao_retval = IR::IDLType::_nil ();
  IR::IDLType_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_type_def",
      13,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

void IR::ValueMemberDef::type_def (
    IR::IDLType_ptr type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_type_def",
      13,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << type_def)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::Visibility IR::ValueMemberDef::access (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Visibility _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_access",
      11,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN  (_tao_retval);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN  (_tao_retval);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_access",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_retval)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_access",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_access",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN  (_tao_retval);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_retval;
}

void IR::ValueMemberDef::access (
    CORBA::Visibility access,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_access",
      11,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_access",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << access)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_access",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_access",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::Boolean IR::ValueMemberDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ValueMemberDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::ValueMemberDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ValueMemberDef:1.0";
}

IR::TAO_IR_ValueMemberDef_Default_Proxy_Factory::TAO_IR_ValueMemberDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_ValueMemberDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_ValueMemberDef_Default_Proxy_Factory::~TAO_IR_ValueMemberDef_Default_Proxy_Factory (void)
{
}

IR::ValueMemberDef_ptr
IR::TAO_IR_ValueMemberDef_Default_Proxy_Factory::create_proxy (
    ::IR::ValueMemberDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_ValueMemberDef_Proxy_Factory_Adapter::TAO_IR_ValueMemberDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_ValueMemberDef_Proxy_Factory_Adapter::~TAO_IR_ValueMemberDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_ValueMemberDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_ValueMemberDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_ValueMemberDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::ValueMemberDef_ptr
IR::TAO_IR_ValueMemberDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::ValueMemberDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_ValueMemberDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_ValueMemberDef_Smart_Proxy_Base::TAO_IR_ValueMemberDef_Smart_Proxy_Base (::IR::ValueMemberDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_ValueMemberDef_Smart_Proxy_Base::~TAO_IR_ValueMemberDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_ValueMemberDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

CORBA::TypeCode_ptr IR::TAO_IR_ValueMemberDef_Smart_Proxy_Base::type  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->type (
      ACE_TRY_ENV
    );

}

IR::IDLType_ptr IR::TAO_IR_ValueMemberDef_Smart_Proxy_Base::type_def  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->type_def (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_ValueMemberDef_Smart_Proxy_Base::type_def  (
    IR::IDLType_ptr type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->type_def (
      type_def,
      ACE_TRY_ENV
    );

}

CORBA::Visibility IR::TAO_IR_ValueMemberDef_Smart_Proxy_Base::access  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->access (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_ValueMemberDef_Smart_Proxy_Base::access  (
    CORBA::Visibility access,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->access (
      access,
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_ValueMemberDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_ValueMemberDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_ValueMemberDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65724465), ACE_NTOHL (0x663a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ValueMemberDef:1.0
  15, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657244), ACE_NTOHL (0x65660000),  // name = ValueMemberDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_ValueMemberDef (CORBA::tk_objref, sizeof (_oc_IR_ValueMemberDef), (char *) &_oc_IR_ValueMemberDef, 0, sizeof (IR::ValueMemberDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueMemberDef, &_tc_TAO_tc_IR_ValueMemberDef)
TAO_NAMESPACE_END
void IR::ValueDef::_tao_any_destructor (void *x)
{
  ValueDef *tmp = ACE_static_cast (ValueDef*,x);
  CORBA::release (tmp);
}

IR::ValueDef_ptr IR::ValueDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return ValueDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ValueDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (ValueDef::_nil ());
  if (is_a == 0)
    return ValueDef::_nil ();
  return ValueDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::ValueDef_ptr IR::ValueDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return ValueDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  ValueDef_ptr default_proxy = ValueDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_ValueDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_ValueDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, ValueDef (stub), ValueDef::_nil ());
  return TAO_IR_ValueDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::ValueDef_ptr 
IR::ValueDef::_duplicate (ValueDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

IR::InterfaceDefSeq * IR::ValueDef::supported_interfaces (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::InterfaceDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR::InterfaceDefSeq, _tao_retval);
  IR::InterfaceDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_supported_interfaces",
      25,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_supported_interfaces",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_supported_interfaces",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_supported_interfaces",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

void IR::ValueDef::supported_interfaces (
    const IR::InterfaceDefSeq & supported_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_supported_interfaces",
      25,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_supported_interfaces",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << supported_interfaces)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_supported_interfaces",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_supported_interfaces",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

IR::InitializerSeq * IR::ValueDef::initializers (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::InitializerSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR::InitializerSeq, _tao_retval);
  IR::InitializerSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_initializers",
      17,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_initializers",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_initializers",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_initializers",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

void IR::ValueDef::initializers (
    const IR::InitializerSeq & initializers,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_initializers",
      17,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_initializers",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << initializers)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_initializers",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_initializers",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

IR::ValueDef_ptr IR::ValueDef::base_value (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::ValueDef_ptr _tao_retval = IR::ValueDef::_nil ();
  IR::ValueDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_base_value",
      15,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_base_value",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_base_value",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_base_value",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

void IR::ValueDef::base_value (
    IR::ValueDef_ptr base_value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_base_value",
      15,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_base_value",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << base_value)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_base_value",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_base_value",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

IR::ValueDefSeq * IR::ValueDef::abstract_base_values (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::ValueDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR::ValueDefSeq, _tao_retval);
  IR::ValueDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_abstract_base_values",
      25,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_abstract_base_values",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_abstract_base_values",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_abstract_base_values",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

void IR::ValueDef::abstract_base_values (
    const IR::ValueDefSeq & abstract_base_values,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_abstract_base_values",
      25,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_abstract_base_values",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << abstract_base_values)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_abstract_base_values",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_abstract_base_values",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::Boolean IR::ValueDef::is_abstract (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_is_abstract",
      16,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN  (_tao_retval);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN  (_tao_retval);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_is_abstract",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_is_abstract",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_is_abstract",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN  (_tao_retval);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_retval;
}

void IR::ValueDef::is_abstract (
    CORBA::Boolean is_abstract,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_is_abstract",
      16,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_is_abstract",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << CORBA::Any::from_boolean (is_abstract))
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_is_abstract",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_is_abstract",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::Boolean IR::ValueDef::is_custom (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_is_custom",
      14,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN  (_tao_retval);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN  (_tao_retval);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_is_custom",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_is_custom",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_is_custom",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN  (_tao_retval);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_retval;
}

void IR::ValueDef::is_custom (
    CORBA::Boolean is_custom,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_is_custom",
      14,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_is_custom",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << CORBA::Any::from_boolean (is_custom))
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_is_custom",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_is_custom",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::Boolean IR::ValueDef::is_truncatable (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_is_truncatable",
      19,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN  (_tao_retval);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN  (_tao_retval);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_is_truncatable",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_is_truncatable",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_is_truncatable",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN  (_tao_retval);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_retval;
}

void IR::ValueDef::is_truncatable (
    CORBA::Boolean is_truncatable,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_is_truncatable",
      19,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_is_truncatable",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << CORBA::Any::from_boolean (is_truncatable))
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_is_truncatable",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_is_truncatable",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::Boolean IR::ValueDef::is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "is_a",
      4,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN  (_tao_retval);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN  (_tao_retval);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "is_a",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "is_a",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "is_a",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN  (_tao_retval);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_retval;
}

IR::ValueMemberDef_ptr IR::ValueDef::create_value_member (
    const char * id,
    const char * name,
    const char * version,
    IR::IDLType_ptr type,
    CORBA::Visibility access,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::ValueMemberDef_ptr _tao_retval = IR::ValueMemberDef::_nil ();
  IR::ValueMemberDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_value_member",
      19,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_value_member",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << type) &&
              (_tao_out << access)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_value_member",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_value_member",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::AttributeDef_ptr IR::ValueDef::create_attribute (
    const char * id,
    const char * name,
    const char * version,
    IR::IDLType_ptr type,
    IR::AttributeMode mode,
    const IR::ExceptionDefSeq & get_exceptions,
    const IR::ExceptionDefSeq & put_exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::AttributeDef_ptr _tao_retval = IR::AttributeDef::_nil ();
  IR::AttributeDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_attribute",
      16,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_attribute",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << type) &&
              (_tao_out << mode) &&
              (_tao_out << get_exceptions) &&
              (_tao_out << put_exceptions)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_attribute",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_attribute",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::OperationDef_ptr IR::ValueDef::create_operation (
    const char * id,
    const char * name,
    const char * version,
    IR::IDLType_ptr result,
    IR::OperationMode mode,
    const IR::ParDescriptionSeq & params,
    const IR::ExceptionDefSeq & exceptions,
    const IR::ContextIdSeq & contexts,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::OperationDef_ptr _tao_retval = IR::OperationDef::_nil ();
  IR::OperationDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_operation",
      16,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_operation",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << result) &&
              (_tao_out << mode) &&
              (_tao_out << params) &&
              (_tao_out << exceptions) &&
              (_tao_out << contexts)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_operation",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_operation",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::Boolean IR::ValueDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ValueDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::ValueDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ValueDef:1.0";
}

IR::TAO_IR_ValueDef_Default_Proxy_Factory::TAO_IR_ValueDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_ValueDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_ValueDef_Default_Proxy_Factory::~TAO_IR_ValueDef_Default_Proxy_Factory (void)
{
}

IR::ValueDef_ptr
IR::TAO_IR_ValueDef_Default_Proxy_Factory::create_proxy (
    ::IR::ValueDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_ValueDef_Proxy_Factory_Adapter::TAO_IR_ValueDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_ValueDef_Proxy_Factory_Adapter::~TAO_IR_ValueDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_ValueDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_ValueDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_ValueDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::ValueDef_ptr
IR::TAO_IR_ValueDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::ValueDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_ValueDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_ValueDef_Smart_Proxy_Base::TAO_IR_ValueDef_Smart_Proxy_Base (::IR::ValueDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_ValueDef_Smart_Proxy_Base::~TAO_IR_ValueDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_ValueDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

IR::InterfaceDefSeq * IR::TAO_IR_ValueDef_Smart_Proxy_Base::supported_interfaces  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->supported_interfaces (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_ValueDef_Smart_Proxy_Base::supported_interfaces  (
    const IR::InterfaceDefSeq & supported_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->supported_interfaces (
      supported_interfaces,
      ACE_TRY_ENV
    );

}

IR::InitializerSeq * IR::TAO_IR_ValueDef_Smart_Proxy_Base::initializers  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->initializers (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_ValueDef_Smart_Proxy_Base::initializers  (
    const IR::InitializerSeq & initializers,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->initializers (
      initializers,
      ACE_TRY_ENV
    );

}

IR::ValueDef_ptr IR::TAO_IR_ValueDef_Smart_Proxy_Base::base_value  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->base_value (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_ValueDef_Smart_Proxy_Base::base_value  (
    IR::ValueDef_ptr base_value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->base_value (
      base_value,
      ACE_TRY_ENV
    );

}

IR::ValueDefSeq * IR::TAO_IR_ValueDef_Smart_Proxy_Base::abstract_base_values  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->abstract_base_values (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_ValueDef_Smart_Proxy_Base::abstract_base_values  (
    const IR::ValueDefSeq & abstract_base_values,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->abstract_base_values (
      abstract_base_values,
      ACE_TRY_ENV
    );

}

CORBA::Boolean IR::TAO_IR_ValueDef_Smart_Proxy_Base::is_abstract  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->is_abstract (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_ValueDef_Smart_Proxy_Base::is_abstract  (
    CORBA::Boolean is_abstract,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->is_abstract (
      is_abstract,
      ACE_TRY_ENV
    );

}

CORBA::Boolean IR::TAO_IR_ValueDef_Smart_Proxy_Base::is_custom  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->is_custom (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_ValueDef_Smart_Proxy_Base::is_custom  (
    CORBA::Boolean is_custom,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->is_custom (
      is_custom,
      ACE_TRY_ENV
    );

}

CORBA::Boolean IR::TAO_IR_ValueDef_Smart_Proxy_Base::is_truncatable  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->is_truncatable (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_ValueDef_Smart_Proxy_Base::is_truncatable  (
    CORBA::Boolean is_truncatable,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->is_truncatable (
      is_truncatable,
      ACE_TRY_ENV
    );

}

CORBA::Boolean IR::TAO_IR_ValueDef_Smart_Proxy_Base::is_a  (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->is_a (
      id,
      ACE_TRY_ENV
    );

}

IR::ValueMemberDef_ptr IR::TAO_IR_ValueDef_Smart_Proxy_Base::create_value_member  (
    const char * id,
    const char * name,
    const char * version,
    IR::IDLType_ptr type,
    CORBA::Visibility access,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_value_member (
      id,
      name,
      version,
      type,
      access,
      ACE_TRY_ENV
    );

}

IR::AttributeDef_ptr IR::TAO_IR_ValueDef_Smart_Proxy_Base::create_attribute  (
    const char * id,
    const char * name,
    const char * version,
    IR::IDLType_ptr type,
    IR::AttributeMode mode,
    const IR::ExceptionDefSeq & get_exceptions,
    const IR::ExceptionDefSeq & put_exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_attribute (
      id,
      name,
      version,
      type,
      mode,
      get_exceptions,
      put_exceptions,
      ACE_TRY_ENV
    );

}

IR::OperationDef_ptr IR::TAO_IR_ValueDef_Smart_Proxy_Base::create_operation  (
    const char * id,
    const char * name,
    const char * version,
    IR::IDLType_ptr result,
    IR::OperationMode mode,
    const IR::ParDescriptionSeq & params,
    const IR::ExceptionDefSeq & exceptions,
    const IR::ContextIdSeq & contexts,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_operation (
      id,
      name,
      version,
      result,
      mode,
      params,
      exceptions,
      contexts,
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_ValueDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_ValueDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_ValueDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ValueDef:1.0
  9, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = ValueDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_ValueDef (CORBA::tk_objref, sizeof (_oc_IR_ValueDef), (char *) &_oc_IR_ValueDef, 0, sizeof (IR::ValueDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueDef, &_tc_TAO_tc_IR_ValueDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_IR_ValueDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ValueDescription:1.0
  17, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ValueDescription
  15, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  132, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_alias, // typecode kind for typedefs
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
      11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
      CORBA::tk_string, 
      0U, // string length


  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  12, ACE_NTOHL (0x69735f61), ACE_NTOHL (0x62737472), ACE_NTOHL (0x61637400),  // name = is_abstract
  CORBA::tk_boolean,

  10, ACE_NTOHL (0x69735f63), ACE_NTOHL (0x7573746f), ACE_NTOHL (0x6d000000),  // name = is_custom
  CORBA::tk_boolean,

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  11, ACE_NTOHL (0x6f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e730000),  // name = operations
  CORBA::tk_alias, // typecode kind for typedefs
  2532, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OpDescriptionSeq:1.0
    17, ACE_NTOHL (0x4f704465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x0),  // name = OpDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    2456, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      2440, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OperationDescription:1.0
        21, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = OperationDescription
        9, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        132, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_alias, // typecode kind for typedefs
          68, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
            11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
            CORBA::tk_string, 
            0U, // string length


        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        140, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_alias, // typecode kind for typedefs
          72, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
            13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
            CORBA::tk_string, 
            0U, // string length


        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        140, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_alias, // typecode kind for typedefs
          72, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
            13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
            CORBA::tk_string, 
            0U, // string length


        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string, 
          0U, // string length

        7, ACE_NTOHL (0x72657375), ACE_NTOHL (0x6c740000),  // name = result
        CORBA::tk_TypeCode,

        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        100, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/OperationMode:1.0
          14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
          2, // member count
          10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
          10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY

        9, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x65787473), ACE_NTOHL (0x0),  // name = contexts
        CORBA::tk_alias, // typecode kind for typedefs
        296, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ContextIdSeq:1.0
          13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
          CORBA::tk_sequence, // typecode kind
          228, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_alias, // typecode kind for typedefs
            212, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ContextIdentifier:1.0
              18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
              CORBA::tk_alias, // typecode kind for typedefs
              132, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_alias, // typecode kind for typedefs
                68, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                  11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                  CORBA::tk_string, 
                  0U, // string length



            0U,


        11, ACE_NTOHL (0x70617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72730000),  // name = parameters
        CORBA::tk_alias, // typecode kind for typedefs
        552, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x61724465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParDescriptionSeq:1.0
          18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          472, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            456, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ParameterDescription:1.0
              21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
              4, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              132, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_alias, // typecode kind for typedefs
                68, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                  11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                  CORBA::tk_string, 
                  0U, // string length


              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,

              9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
              CORBA::tk_objref, // typecode kind
              48, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
                8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

              5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
              CORBA::tk_enum, // typecode kind
              116, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParameterMode:1.0
                14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
                3, // member count
                9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
                10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
                12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT


            0U,


        11, ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = exceptions
        CORBA::tk_alias, // typecode kind for typedefs
        748, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          668, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            652, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              132, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_alias, // typecode kind for typedefs
                68, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                  11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                  CORBA::tk_string, 
                  0U, // string length


              3, ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              140, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_alias, // typecode kind for typedefs
                72, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                  13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                  CORBA::tk_string, 
                  0U, // string length


              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_alias, // typecode kind for typedefs
              140, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_alias, // typecode kind for typedefs
                72, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                  13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                  CORBA::tk_string, 
                  0U, // string length


              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string, 
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,



      0U,


  11, ACE_NTOHL (0x61747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65730000),  // name = attributes
  CORBA::tk_alias, // typecode kind for typedefs
  2424, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/AttrDescriptionSeq:1.0
    19, ACE_NTOHL (0x41747472), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65710000),  // name = AttrDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    2344, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      2328, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/AttributeDescription:1.0
        21, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = AttributeDescription
        8, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        132, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_alias, // typecode kind for typedefs
          68, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
            11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
            CORBA::tk_string, 
            0U, // string length


        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        140, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_alias, // typecode kind for typedefs
          72, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
            13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
            CORBA::tk_string, 
            0U, // string length


        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        140, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_alias, // typecode kind for typedefs
          72, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
            13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
            CORBA::tk_string, 
            0U, // string length


        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string, 
          0U, // string length

        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,

        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        104, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/AttributeMode:1.0
          14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
          2, // member count
          12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
          14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY

        15, ACE_NTOHL (0x6765745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = get_exceptions
        CORBA::tk_alias, // typecode kind for typedefs
        748, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          668, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            652, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              132, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_alias, // typecode kind for typedefs
                68, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                  11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                  CORBA::tk_string, 
                  0U, // string length


              3, ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              140, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_alias, // typecode kind for typedefs
                72, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                  13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                  CORBA::tk_string, 
                  0U, // string length


              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_alias, // typecode kind for typedefs
              140, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_alias, // typecode kind for typedefs
                72, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                  13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                  CORBA::tk_string, 
                  0U, // string length


              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string, 
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,


        15, ACE_NTOHL (0x7075745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = put_exceptions
        CORBA::tk_alias, // typecode kind for typedefs
        748, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          668, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            652, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              132, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_alias, // typecode kind for typedefs
                68, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                  11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                  CORBA::tk_string, 
                  0U, // string length


              3, ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              140, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_alias, // typecode kind for typedefs
                72, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                  13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                  CORBA::tk_string, 
                  0U, // string length


              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_alias, // typecode kind for typedefs
              140, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_alias, // typecode kind for typedefs
                72, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                  13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                  CORBA::tk_string, 
                  0U, // string length


              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string, 
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,



      0U,


  8, ACE_NTOHL (0x6d656d62), ACE_NTOHL (0x65727300),  // name = members
  CORBA::tk_alias, // typecode kind for typedefs
  876, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65725365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ValueMemberSeq:1.0
    15, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657253), ACE_NTOHL (0x65710000),  // name = ValueMemberSeq
    CORBA::tk_sequence, // typecode kind
    804, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      788, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ValueMember:1.0
        12, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657200),  // name = ValueMember
        7, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        132, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_alias, // typecode kind for typedefs
          68, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
            11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
            CORBA::tk_string, 
            0U, // string length


        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        140, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_alias, // typecode kind for typedefs
          72, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
            13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
            CORBA::tk_string, 
            0U, // string length


        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        140, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_alias, // typecode kind for typedefs
          72, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
            13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
            CORBA::tk_string, 
            0U, // string length


        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string, 
          0U, // string length

        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,

        9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
        CORBA::tk_objref, // typecode kind
        48, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
          8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

        7, ACE_NTOHL (0x61636365), ACE_NTOHL (0x73730000),  // name = access
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5669), ACE_NTOHL (0x73696269), ACE_NTOHL (0x6c697479), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Visibility:1.0
          11, ACE_NTOHL (0x56697369), ACE_NTOHL (0x62696c69), ACE_NTOHL (0x74790000),  // name = Visibility
          CORBA::tk_short,



      0U,


  13, ACE_NTOHL (0x696e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657273), ACE_NTOHL (0x0),  // name = initializers
  CORBA::tk_alias, // typecode kind for typedefs
  712, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x616c697a), ACE_NTOHL (0x65725365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/InitializerSeq:1.0
    15, ACE_NTOHL (0x496e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657253), ACE_NTOHL (0x65710000),  // name = InitializerSeq
    CORBA::tk_sequence, // typecode kind
    640, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      624, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x616c697a), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/Initializer:1.0
        12, ACE_NTOHL (0x496e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657200),  // name = Initializer
        2, // member count
        8, ACE_NTOHL (0x6d656d62), ACE_NTOHL (0x65727300),  // name = members
        CORBA::tk_alias, // typecode kind for typedefs
        392, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x744d656d), ACE_NTOHL (0x62657253), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/StructMemberSeq:1.0
          16, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x53657100),  // name = StructMemberSeq
          CORBA::tk_sequence, // typecode kind
          320, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            304, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x744d656d), ACE_NTOHL (0x6265723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/StructMember:1.0
              13, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x0),  // name = StructMember
              3, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              132, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_alias, // typecode kind for typedefs
                68, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                  11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                  CORBA::tk_string, 
                  0U, // string length


              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,

              9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
              CORBA::tk_objref, // typecode kind
              48, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
                8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType


            0U,


        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        132, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_alias, // typecode kind for typedefs
          68, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
            11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
            CORBA::tk_string, 
            0U, // string length



      0U,


  21, ACE_NTOHL (0x73757070), ACE_NTOHL (0x6f727465), ACE_NTOHL (0x645f696e), ACE_NTOHL (0x74657266), ACE_NTOHL (0x61636573), ACE_NTOHL (0x0),  // name = supported_interfaces
  CORBA::tk_alias, // typecode kind for typedefs
  228, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79496453), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/RepositoryIdSeq:1.0
    16, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
    CORBA::tk_sequence, // typecode kind
    156, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_alias, // typecode kind for typedefs
      140, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length


      0U,


  21, ACE_NTOHL (0x61627374), ACE_NTOHL (0x72616374), ACE_NTOHL (0x5f626173), ACE_NTOHL (0x655f7661), ACE_NTOHL (0x6c756573), ACE_NTOHL (0x0),  // name = abstract_base_values
  CORBA::tk_alias, // typecode kind for typedefs
  228, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79496453), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/RepositoryIdSeq:1.0
    16, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
    CORBA::tk_sequence, // typecode kind
    156, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_alias, // typecode kind for typedefs
      140, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length


      0U,


  15, ACE_NTOHL (0x69735f74), ACE_NTOHL (0x72756e63), ACE_NTOHL (0x61746162), ACE_NTOHL (0x6c650000),  // name = is_truncatable
  CORBA::tk_boolean,

  11, ACE_NTOHL (0x62617365), ACE_NTOHL (0x5f76616c), ACE_NTOHL (0x75650000),  // name = base_value
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

};
static CORBA::TypeCode _tc_TAO_tc_IR_ValueDescription (CORBA::tk_struct, sizeof (_oc_IR_ValueDescription), (char *) &_oc_IR_ValueDescription, 0, sizeof (IR::ValueDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueDescription, &_tc_TAO_tc_IR_ValueDescription)
TAO_NAMESPACE_END
void IR::ValueDescription::_tao_any_destructor (void *x)
{
  ValueDescription *tmp = ACE_static_cast (ValueDescription*,x);
  delete tmp;
}

void IR::ValueBoxDef::_tao_any_destructor (void *x)
{
  ValueBoxDef *tmp = ACE_static_cast (ValueBoxDef*,x);
  CORBA::release (tmp);
}

IR::ValueBoxDef_ptr IR::ValueBoxDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return ValueBoxDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ValueBoxDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (ValueBoxDef::_nil ());
  if (is_a == 0)
    return ValueBoxDef::_nil ();
  return ValueBoxDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::ValueBoxDef_ptr IR::ValueBoxDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return ValueBoxDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  ValueBoxDef_ptr default_proxy = ValueBoxDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_ValueBoxDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_ValueBoxDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, ValueBoxDef (stub), ValueBoxDef::_nil ());
  return TAO_IR_ValueBoxDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::ValueBoxDef_ptr 
IR::ValueBoxDef::_duplicate (ValueBoxDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

IR::IDLType_ptr IR::ValueBoxDef::original_type_def (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::IDLType_ptr _tao_retval = IR::IDLType::_nil ();
  IR::IDLType_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_original_type_def",
      22,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_original_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_original_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_original_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

void IR::ValueBoxDef::original_type_def (
    IR::IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_original_type_def",
      22,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_original_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << original_type_def)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_original_type_def",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_original_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::Boolean IR::ValueBoxDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ValueBoxDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::ValueBoxDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ValueBoxDef:1.0";
}

IR::TAO_IR_ValueBoxDef_Default_Proxy_Factory::TAO_IR_ValueBoxDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_ValueBoxDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_ValueBoxDef_Default_Proxy_Factory::~TAO_IR_ValueBoxDef_Default_Proxy_Factory (void)
{
}

IR::ValueBoxDef_ptr
IR::TAO_IR_ValueBoxDef_Default_Proxy_Factory::create_proxy (
    ::IR::ValueBoxDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_ValueBoxDef_Proxy_Factory_Adapter::TAO_IR_ValueBoxDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_ValueBoxDef_Proxy_Factory_Adapter::~TAO_IR_ValueBoxDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_ValueBoxDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_ValueBoxDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_ValueBoxDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::ValueBoxDef_ptr
IR::TAO_IR_ValueBoxDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::ValueBoxDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_ValueBoxDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_ValueBoxDef_Smart_Proxy_Base::TAO_IR_ValueBoxDef_Smart_Proxy_Base (::IR::ValueBoxDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_ValueBoxDef_Smart_Proxy_Base::~TAO_IR_ValueBoxDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_ValueBoxDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

IR::IDLType_ptr IR::TAO_IR_ValueBoxDef_Smart_Proxy_Base::original_type_def  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->original_type_def (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_ValueBoxDef_Smart_Proxy_Base::original_type_def  (
    IR::IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->original_type_def (
      original_type_def,
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_ValueBoxDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_ValueBoxDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_ValueBoxDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x426f7844), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ValueBoxDef:1.0
  12, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65426f78), ACE_NTOHL (0x44656600),  // name = ValueBoxDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_ValueBoxDef (CORBA::tk_objref, sizeof (_oc_IR_ValueBoxDef), (char *) &_oc_IR_ValueBoxDef, 0, sizeof (IR::ValueBoxDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueBoxDef, &_tc_TAO_tc_IR_ValueBoxDef)
TAO_NAMESPACE_END
void IR::ProvidesDef::_tao_any_destructor (void *x)
{
  ProvidesDef *tmp = ACE_static_cast (ProvidesDef*,x);
  CORBA::release (tmp);
}

IR::ProvidesDef_ptr IR::ProvidesDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return ProvidesDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ProvidesDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (ProvidesDef::_nil ());
  if (is_a == 0)
    return ProvidesDef::_nil ();
  return ProvidesDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::ProvidesDef_ptr IR::ProvidesDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return ProvidesDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  ProvidesDef_ptr default_proxy = ProvidesDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_ProvidesDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_ProvidesDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, ProvidesDef (stub), ProvidesDef::_nil ());
  return TAO_IR_ProvidesDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::ProvidesDef_ptr 
IR::ProvidesDef::_duplicate (ProvidesDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

IR::InterfaceDef_ptr IR::ProvidesDef::interface_type (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::InterfaceDef_ptr _tao_retval = IR::InterfaceDef::_nil ();
  IR::InterfaceDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_interface_type",
      19,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_interface_type",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_interface_type",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_interface_type",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::Boolean IR::ProvidesDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ProvidesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::ProvidesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ProvidesDef:1.0";
}

IR::TAO_IR_ProvidesDef_Default_Proxy_Factory::TAO_IR_ProvidesDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_ProvidesDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_ProvidesDef_Default_Proxy_Factory::~TAO_IR_ProvidesDef_Default_Proxy_Factory (void)
{
}

IR::ProvidesDef_ptr
IR::TAO_IR_ProvidesDef_Default_Proxy_Factory::create_proxy (
    ::IR::ProvidesDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_ProvidesDef_Proxy_Factory_Adapter::TAO_IR_ProvidesDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_ProvidesDef_Proxy_Factory_Adapter::~TAO_IR_ProvidesDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_ProvidesDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_ProvidesDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_ProvidesDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::ProvidesDef_ptr
IR::TAO_IR_ProvidesDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::ProvidesDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_ProvidesDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_ProvidesDef_Smart_Proxy_Base::TAO_IR_ProvidesDef_Smart_Proxy_Base (::IR::ProvidesDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_ProvidesDef_Smart_Proxy_Base::~TAO_IR_ProvidesDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_ProvidesDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

IR::InterfaceDef_ptr IR::TAO_IR_ProvidesDef_Smart_Proxy_Base::interface_type  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->interface_type (
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_ProvidesDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_ProvidesDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_ProvidesDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDef:1.0
  12, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44656600),  // name = ProvidesDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_ProvidesDef (CORBA::tk_objref, sizeof (_oc_IR_ProvidesDef), (char *) &_oc_IR_ProvidesDef, 0, sizeof (IR::ProvidesDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ProvidesDef, &_tc_TAO_tc_IR_ProvidesDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_IR_ProvidesDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDescription:1.0
  20, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = ProvidesDescription
  5, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  132, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_alias, // typecode kind for typedefs
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
      11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
      CORBA::tk_string, 
      0U, // string length


  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  15, ACE_NTOHL (0x696e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x655f7479), ACE_NTOHL (0x70650000),  // name = interface_type
  CORBA::tk_objref, // typecode kind
  60, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/InterfaceDef:1.0
    13, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = InterfaceDef

};
static CORBA::TypeCode _tc_TAO_tc_IR_ProvidesDescription (CORBA::tk_struct, sizeof (_oc_IR_ProvidesDescription), (char *) &_oc_IR_ProvidesDescription, 0, sizeof (IR::ProvidesDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ProvidesDescription, &_tc_TAO_tc_IR_ProvidesDescription)
TAO_NAMESPACE_END
void IR::ProvidesDescription::_tao_any_destructor (void *x)
{
  ProvidesDescription *tmp = ACE_static_cast (ProvidesDescription*,x);
  delete tmp;
}

void IR::UsesDef::_tao_any_destructor (void *x)
{
  UsesDef *tmp = ACE_static_cast (UsesDef*,x);
  CORBA::release (tmp);
}

IR::UsesDef_ptr IR::UsesDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return UsesDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/UsesDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (UsesDef::_nil ());
  if (is_a == 0)
    return UsesDef::_nil ();
  return UsesDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::UsesDef_ptr IR::UsesDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return UsesDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  UsesDef_ptr default_proxy = UsesDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_UsesDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_UsesDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, UsesDef (stub), UsesDef::_nil ());
  return TAO_IR_UsesDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::UsesDef_ptr 
IR::UsesDef::_duplicate (UsesDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

IR::InterfaceDef_ptr IR::UsesDef::interface_type (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::InterfaceDef_ptr _tao_retval = IR::InterfaceDef::_nil ();
  IR::InterfaceDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_interface_type",
      19,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_interface_type",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_interface_type",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_interface_type",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::Boolean IR::UsesDef::is_multiple (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_is_multiple",
      16,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN  (_tao_retval);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN  (_tao_retval);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_is_multiple",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_is_multiple",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_is_multiple",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN  (_tao_retval);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_retval;
}

CORBA::Boolean IR::UsesDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/UsesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::UsesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/UsesDef:1.0";
}

IR::TAO_IR_UsesDef_Default_Proxy_Factory::TAO_IR_UsesDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_UsesDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_UsesDef_Default_Proxy_Factory::~TAO_IR_UsesDef_Default_Proxy_Factory (void)
{
}

IR::UsesDef_ptr
IR::TAO_IR_UsesDef_Default_Proxy_Factory::create_proxy (
    ::IR::UsesDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_UsesDef_Proxy_Factory_Adapter::TAO_IR_UsesDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_UsesDef_Proxy_Factory_Adapter::~TAO_IR_UsesDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_UsesDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_UsesDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_UsesDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::UsesDef_ptr
IR::TAO_IR_UsesDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::UsesDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_UsesDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_UsesDef_Smart_Proxy_Base::TAO_IR_UsesDef_Smart_Proxy_Base (::IR::UsesDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_UsesDef_Smart_Proxy_Base::~TAO_IR_UsesDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_UsesDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

IR::InterfaceDef_ptr IR::TAO_IR_UsesDef_Smart_Proxy_Base::interface_type  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->interface_type (
      ACE_TRY_ENV
    );

}

CORBA::Boolean IR::TAO_IR_UsesDef_Smart_Proxy_Base::is_multiple  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->is_multiple (
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_UsesDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_UsesDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_UsesDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x73657344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDef:1.0
  8, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44656600),  // name = UsesDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_UsesDef (CORBA::tk_objref, sizeof (_oc_IR_UsesDef), (char *) &_oc_IR_UsesDef, 0, sizeof (IR::UsesDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UsesDef, &_tc_TAO_tc_IR_UsesDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_IR_UsesDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x73657344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDescription:1.0
  16, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = UsesDescription
  6, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  132, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_alias, // typecode kind for typedefs
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
      11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
      CORBA::tk_string, 
      0U, // string length


  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  15, ACE_NTOHL (0x696e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x655f7479), ACE_NTOHL (0x70650000),  // name = interface_type
  CORBA::tk_objref, // typecode kind
  60, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/InterfaceDef:1.0
    13, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = InterfaceDef

  12, ACE_NTOHL (0x69735f6d), ACE_NTOHL (0x756c7469), ACE_NTOHL (0x706c6500),  // name = is_multiple
  CORBA::tk_boolean,

};
static CORBA::TypeCode _tc_TAO_tc_IR_UsesDescription (CORBA::tk_struct, sizeof (_oc_IR_UsesDescription), (char *) &_oc_IR_UsesDescription, 0, sizeof (IR::UsesDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UsesDescription, &_tc_TAO_tc_IR_UsesDescription)
TAO_NAMESPACE_END
void IR::UsesDescription::_tao_any_destructor (void *x)
{
  UsesDescription *tmp = ACE_static_cast (UsesDescription*,x);
  delete tmp;
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_PROVIDESDESCSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_IR_PROVIDESDESCSEQ_CS_

  void
  IR::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::ProvidesDescription* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::ProvidesDescription *old = ACE_reinterpret_cast (IR::ProvidesDescription *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    IR::ProvidesDescription *tmp = ACE_reinterpret_cast (IR::ProvidesDescription *,this->buffer_);
    
    _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  IR::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq::~_TAO_Unbounded_Sequence_IR_ProvidesDescSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_PROVIDESDESCSEQ_CS_)
#define _IR_PROVIDESDESCSEQ_CS_

// *************************************************************
// IR::ProvidesDescSeq
// *************************************************************

IR::ProvidesDescSeq::ProvidesDescSeq (void)
{}
IR::ProvidesDescSeq::ProvidesDescSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ProvidesDescSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::ProvidesDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::ProvidesDescSeq::ProvidesDescSeq (CORBA::ULong max, CORBA::ULong length, IR::ProvidesDescription *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ProvidesDescSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::ProvidesDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::ProvidesDescSeq::ProvidesDescSeq (const ProvidesDescSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ProvidesDescSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::ProvidesDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::ProvidesDescSeq::~ProvidesDescSeq (void) // dtor
{}
void IR::ProvidesDescSeq::_tao_any_destructor (void *x)
{
  ProvidesDescSeq *tmp = ACE_static_cast (ProvidesDescSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_ProvidesDescSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657344), ACE_NTOHL (0x65736353), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDescSeq:1.0
  16, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44657363), ACE_NTOHL (0x53657100),  // name = ProvidesDescSeq
  CORBA::tk_sequence, // typecode kind
  736, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    720, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      39, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDescription:1.0
      20, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = ProvidesDescription
      5, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      132, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length


      3, ACE_NTOHL (0x69640000),  // name = id
      CORBA::tk_alias, // typecode kind for typedefs
      140, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length


      11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
      CORBA::tk_alias, // typecode kind for typedefs
      140, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length


      8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
        12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
        0U, // string length

      15, ACE_NTOHL (0x696e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x655f7479), ACE_NTOHL (0x70650000),  // name = interface_type
      CORBA::tk_objref, // typecode kind
      60, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/InterfaceDef:1.0
        13, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = InterfaceDef


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_ProvidesDescSeq (CORBA::tk_alias, sizeof (_oc_IR_ProvidesDescSeq), (char *) &_oc_IR_ProvidesDescSeq, 0, sizeof (IR::ProvidesDescSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ProvidesDescSeq, &_tc_TAO_tc_IR_ProvidesDescSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_USESDESCSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_IR_USESDESCSEQ_CS_

  void
  IR::_TAO_Unbounded_Sequence_IR_UsesDescSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::UsesDescription* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_IR_UsesDescSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::UsesDescription *old = ACE_reinterpret_cast (IR::UsesDescription *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_IR_UsesDescSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Sequence_IR_UsesDescSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    IR::UsesDescription *tmp = ACE_reinterpret_cast (IR::UsesDescription *,this->buffer_);
    
    _TAO_Unbounded_Sequence_IR_UsesDescSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  IR::_TAO_Unbounded_Sequence_IR_UsesDescSeq::~_TAO_Unbounded_Sequence_IR_UsesDescSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_USESDESCSEQ_CS_)
#define _IR_USESDESCSEQ_CS_

// *************************************************************
// IR::UsesDescSeq
// *************************************************************

IR::UsesDescSeq::UsesDescSeq (void)
{}
IR::UsesDescSeq::UsesDescSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_UsesDescSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::UsesDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::UsesDescSeq::UsesDescSeq (CORBA::ULong max, CORBA::ULong length, IR::UsesDescription *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_UsesDescSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::UsesDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::UsesDescSeq::UsesDescSeq (const UsesDescSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_UsesDescSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::UsesDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::UsesDescSeq::~UsesDescSeq (void) // dtor
{}
void IR::UsesDescSeq::_tao_any_destructor (void *x)
{
  UsesDescSeq *tmp = ACE_static_cast (UsesDescSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_UsesDescSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x73657344), ACE_NTOHL (0x65736353), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDescSeq:1.0
  12, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44657363), ACE_NTOHL (0x53657100),  // name = UsesDescSeq
  CORBA::tk_sequence, // typecode kind
  748, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    732, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x73657344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDescription:1.0
      16, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = UsesDescription
      6, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      132, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length


      3, ACE_NTOHL (0x69640000),  // name = id
      CORBA::tk_alias, // typecode kind for typedefs
      140, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length


      11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
      CORBA::tk_alias, // typecode kind for typedefs
      140, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length


      8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
        12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
        0U, // string length

      15, ACE_NTOHL (0x696e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x655f7479), ACE_NTOHL (0x70650000),  // name = interface_type
      CORBA::tk_objref, // typecode kind
      60, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/InterfaceDef:1.0
        13, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = InterfaceDef

      12, ACE_NTOHL (0x69735f6d), ACE_NTOHL (0x756c7469), ACE_NTOHL (0x706c6500),  // name = is_multiple
      CORBA::tk_boolean,


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_UsesDescSeq (CORBA::tk_alias, sizeof (_oc_IR_UsesDescSeq), (char *) &_oc_IR_UsesDescSeq, 0, sizeof (IR::UsesDescSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UsesDescSeq, &_tc_TAO_tc_IR_UsesDescSeq)
TAO_NAMESPACE_END
void IR::EventDef::_tao_any_destructor (void *x)
{
  EventDef *tmp = ACE_static_cast (EventDef*,x);
  CORBA::release (tmp);
}

IR::EventDef_ptr IR::EventDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return EventDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/EventDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (EventDef::_nil ());
  if (is_a == 0)
    return EventDef::_nil ();
  return EventDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::EventDef_ptr IR::EventDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return EventDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  EventDef_ptr default_proxy = EventDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_EventDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_EventDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, EventDef (stub), EventDef::_nil ());
  return TAO_IR_EventDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::EventDef_ptr 
IR::EventDef::_duplicate (EventDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::Boolean IR::EventDef::is_a (
    const char * event_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "is_a",
      4,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN  (_tao_retval);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN  (_tao_retval);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "is_a",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << event_id)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "is_a",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "is_a",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN  (_tao_retval);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_retval;
}

IR::ValueDef_ptr IR::EventDef::event (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::ValueDef_ptr _tao_retval = IR::ValueDef::_nil ();
  IR::ValueDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_event",
      10,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_event",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_event",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_event",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::Boolean IR::EventDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::EventDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/EventDef:1.0";
}

IR::TAO_IR_EventDef_Default_Proxy_Factory::TAO_IR_EventDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_EventDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_EventDef_Default_Proxy_Factory::~TAO_IR_EventDef_Default_Proxy_Factory (void)
{
}

IR::EventDef_ptr
IR::TAO_IR_EventDef_Default_Proxy_Factory::create_proxy (
    ::IR::EventDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_EventDef_Proxy_Factory_Adapter::TAO_IR_EventDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_EventDef_Proxy_Factory_Adapter::~TAO_IR_EventDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_EventDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_EventDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_EventDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::EventDef_ptr
IR::TAO_IR_EventDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::EventDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_EventDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_EventDef_Smart_Proxy_Base::TAO_IR_EventDef_Smart_Proxy_Base (::IR::EventDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_EventDef_Smart_Proxy_Base::~TAO_IR_EventDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_EventDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

CORBA::Boolean IR::TAO_IR_EventDef_Smart_Proxy_Base::is_a  (
    const char * event_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->is_a (
      event_id,
      ACE_TRY_ENV
    );

}

IR::ValueDef_ptr IR::TAO_IR_EventDef_Smart_Proxy_Base::event  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->event (
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_EventDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_EventDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_EventDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x76656e74), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/EventDef:1.0
  9, ACE_NTOHL (0x4576656e), ACE_NTOHL (0x74446566), ACE_NTOHL (0x0),  // name = EventDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_EventDef (CORBA::tk_objref, sizeof (_oc_IR_EventDef), (char *) &_oc_IR_EventDef, 0, sizeof (IR::EventDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EventDef, &_tc_TAO_tc_IR_EventDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_IR_EventDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x76656e74), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/EventDescription:1.0
  17, ACE_NTOHL (0x4576656e), ACE_NTOHL (0x74446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = EventDescription
  5, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  132, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_alias, // typecode kind for typedefs
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
      11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
      CORBA::tk_string, 
      0U, // string length


  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  6, ACE_NTOHL (0x76616c75), ACE_NTOHL (0x65000000),  // name = value
  CORBA::tk_objref, // typecode kind
  52, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ValueDef:1.0
    9, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = ValueDef

};
static CORBA::TypeCode _tc_TAO_tc_IR_EventDescription (CORBA::tk_struct, sizeof (_oc_IR_EventDescription), (char *) &_oc_IR_EventDescription, 0, sizeof (IR::EventDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EventDescription, &_tc_TAO_tc_IR_EventDescription)
TAO_NAMESPACE_END
void IR::EventDescription::_tao_any_destructor (void *x)
{
  EventDescription *tmp = ACE_static_cast (EventDescription*,x);
  delete tmp;
}

void IR::EmitsDef::_tao_any_destructor (void *x)
{
  EmitsDef *tmp = ACE_static_cast (EmitsDef*,x);
  CORBA::release (tmp);
}

IR::EmitsDef_ptr IR::EmitsDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return EmitsDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/EmitsDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (EmitsDef::_nil ());
  if (is_a == 0)
    return EmitsDef::_nil ();
  return EmitsDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::EmitsDef_ptr IR::EmitsDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return EmitsDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  EmitsDef_ptr default_proxy = EmitsDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_EmitsDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_EmitsDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, EmitsDef (stub), EmitsDef::_nil ());
  return TAO_IR_EmitsDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::EmitsDef_ptr 
IR::EmitsDef::_duplicate (EmitsDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::Boolean IR::EmitsDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EmitsDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::EmitsDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/EmitsDef:1.0";
}

IR::TAO_IR_EmitsDef_Default_Proxy_Factory::TAO_IR_EmitsDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_EmitsDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_EmitsDef_Default_Proxy_Factory::~TAO_IR_EmitsDef_Default_Proxy_Factory (void)
{
}

IR::EmitsDef_ptr
IR::TAO_IR_EmitsDef_Default_Proxy_Factory::create_proxy (
    ::IR::EmitsDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_EmitsDef_Proxy_Factory_Adapter::TAO_IR_EmitsDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_EmitsDef_Proxy_Factory_Adapter::~TAO_IR_EmitsDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_EmitsDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_EmitsDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_EmitsDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::EmitsDef_ptr
IR::TAO_IR_EmitsDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::EmitsDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_EmitsDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_EmitsDef_Smart_Proxy_Base::TAO_IR_EmitsDef_Smart_Proxy_Base (::IR::EmitsDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_EmitsDef_Smart_Proxy_Base::~TAO_IR_EmitsDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_EmitsDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_EmitsDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_EmitsDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_EmitsDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x6d697473), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/EmitsDef:1.0
  9, ACE_NTOHL (0x456d6974), ACE_NTOHL (0x73446566), ACE_NTOHL (0x0),  // name = EmitsDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_EmitsDef (CORBA::tk_objref, sizeof (_oc_IR_EmitsDef), (char *) &_oc_IR_EmitsDef, 0, sizeof (IR::EmitsDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EmitsDef, &_tc_TAO_tc_IR_EmitsDef)
TAO_NAMESPACE_END
void IR::PublishesDef::_tao_any_destructor (void *x)
{
  PublishesDef *tmp = ACE_static_cast (PublishesDef*,x);
  CORBA::release (tmp);
}

IR::PublishesDef_ptr IR::PublishesDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return PublishesDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/PublishesDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (PublishesDef::_nil ());
  if (is_a == 0)
    return PublishesDef::_nil ();
  return PublishesDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::PublishesDef_ptr IR::PublishesDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return PublishesDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  PublishesDef_ptr default_proxy = PublishesDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_PublishesDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_PublishesDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, PublishesDef (stub), PublishesDef::_nil ());
  return TAO_IR_PublishesDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::PublishesDef_ptr 
IR::PublishesDef::_duplicate (PublishesDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::Boolean IR::PublishesDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/PublishesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::PublishesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/PublishesDef:1.0";
}

IR::TAO_IR_PublishesDef_Default_Proxy_Factory::TAO_IR_PublishesDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_PublishesDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_PublishesDef_Default_Proxy_Factory::~TAO_IR_PublishesDef_Default_Proxy_Factory (void)
{
}

IR::PublishesDef_ptr
IR::TAO_IR_PublishesDef_Default_Proxy_Factory::create_proxy (
    ::IR::PublishesDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_PublishesDef_Proxy_Factory_Adapter::TAO_IR_PublishesDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_PublishesDef_Proxy_Factory_Adapter::~TAO_IR_PublishesDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_PublishesDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_PublishesDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_PublishesDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::PublishesDef_ptr
IR::TAO_IR_PublishesDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::PublishesDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_PublishesDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_PublishesDef_Smart_Proxy_Base::TAO_IR_PublishesDef_Smart_Proxy_Base (::IR::PublishesDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_PublishesDef_Smart_Proxy_Base::~TAO_IR_PublishesDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_PublishesDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_PublishesDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_PublishesDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_PublishesDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x75626c69), ACE_NTOHL (0x73686573), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/PublishesDef:1.0
  13, ACE_NTOHL (0x5075626c), ACE_NTOHL (0x69736865), ACE_NTOHL (0x73446566), ACE_NTOHL (0x0),  // name = PublishesDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_PublishesDef (CORBA::tk_objref, sizeof (_oc_IR_PublishesDef), (char *) &_oc_IR_PublishesDef, 0, sizeof (IR::PublishesDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PublishesDef, &_tc_TAO_tc_IR_PublishesDef)
TAO_NAMESPACE_END
void IR::ConsumesDef::_tao_any_destructor (void *x)
{
  ConsumesDef *tmp = ACE_static_cast (ConsumesDef*,x);
  CORBA::release (tmp);
}

IR::ConsumesDef_ptr IR::ConsumesDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return ConsumesDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ConsumesDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (ConsumesDef::_nil ());
  if (is_a == 0)
    return ConsumesDef::_nil ();
  return ConsumesDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::ConsumesDef_ptr IR::ConsumesDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return ConsumesDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  ConsumesDef_ptr default_proxy = ConsumesDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_ConsumesDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_ConsumesDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, ConsumesDef (stub), ConsumesDef::_nil ());
  return TAO_IR_ConsumesDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::ConsumesDef_ptr 
IR::ConsumesDef::_duplicate (ConsumesDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::Boolean IR::ConsumesDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ConsumesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::ConsumesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ConsumesDef:1.0";
}

IR::TAO_IR_ConsumesDef_Default_Proxy_Factory::TAO_IR_ConsumesDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_ConsumesDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_ConsumesDef_Default_Proxy_Factory::~TAO_IR_ConsumesDef_Default_Proxy_Factory (void)
{
}

IR::ConsumesDef_ptr
IR::TAO_IR_ConsumesDef_Default_Proxy_Factory::create_proxy (
    ::IR::ConsumesDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_ConsumesDef_Proxy_Factory_Adapter::TAO_IR_ConsumesDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_ConsumesDef_Proxy_Factory_Adapter::~TAO_IR_ConsumesDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_ConsumesDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_ConsumesDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_ConsumesDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::ConsumesDef_ptr
IR::TAO_IR_ConsumesDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::ConsumesDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_ConsumesDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_ConsumesDef_Smart_Proxy_Base::TAO_IR_ConsumesDef_Smart_Proxy_Base (::IR::ConsumesDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_ConsumesDef_Smart_Proxy_Base::~TAO_IR_ConsumesDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_ConsumesDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_ConsumesDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_ConsumesDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_ConsumesDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7375), ACE_NTOHL (0x6d657344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ConsumesDef:1.0
  12, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x756d6573), ACE_NTOHL (0x44656600),  // name = ConsumesDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_ConsumesDef (CORBA::tk_objref, sizeof (_oc_IR_ConsumesDef), (char *) &_oc_IR_ConsumesDef, 0, sizeof (IR::ConsumesDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ConsumesDef, &_tc_TAO_tc_IR_ConsumesDef)
TAO_NAMESPACE_END
void IR::ComponentDef::_tao_any_destructor (void *x)
{
  ComponentDef *tmp = ACE_static_cast (ComponentDef*,x);
  CORBA::release (tmp);
}

IR::ComponentDef_ptr IR::ComponentDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return ComponentDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ComponentDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (ComponentDef::_nil ());
  if (is_a == 0)
    return ComponentDef::_nil ();
  return ComponentDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::ComponentDef_ptr IR::ComponentDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return ComponentDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  ComponentDef_ptr default_proxy = ComponentDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_ComponentDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_ComponentDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, ComponentDef (stub), ComponentDef::_nil ());
  return TAO_IR_ComponentDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::ComponentDef_ptr 
IR::ComponentDef::_duplicate (ComponentDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

IR::InterfaceDefSeq * IR::ComponentDef::supported_interfaces (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::InterfaceDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR::InterfaceDefSeq, _tao_retval);
  IR::InterfaceDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_supported_interfaces",
      25,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_supported_interfaces",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_supported_interfaces",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_supported_interfaces",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

void IR::ComponentDef::supported_interfaces (
    const IR::InterfaceDefSeq & supported_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_supported_interfaces",
      25,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_supported_interfaces",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << supported_interfaces)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_set_supported_interfaces",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_set_supported_interfaces",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

IR::ComponentDef_ptr IR::ComponentDef::base_component (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::ComponentDef_ptr _tao_retval = IR::ComponentDef::_nil ();
  IR::ComponentDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_base_component",
      19,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_base_component",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_base_component",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_base_component",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::ProvidesDefSeq * IR::ComponentDef::provides_interfaces (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::ProvidesDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR::ProvidesDefSeq, _tao_retval);
  IR::ProvidesDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_provides_interfaces",
      24,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_provides_interfaces",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_provides_interfaces",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_provides_interfaces",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::UsesDefSeq * IR::ComponentDef::uses_interfaces (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::UsesDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR::UsesDefSeq, _tao_retval);
  IR::UsesDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_uses_interfaces",
      20,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_uses_interfaces",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_uses_interfaces",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_uses_interfaces",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::EmitsDefSeq * IR::ComponentDef::emits_events (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::EmitsDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR::EmitsDefSeq, _tao_retval);
  IR::EmitsDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_emits_events",
      17,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_emits_events",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_emits_events",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_emits_events",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::PublishesDefSeq * IR::ComponentDef::publishes_events (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::PublishesDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR::PublishesDefSeq, _tao_retval);
  IR::PublishesDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_publishes_events",
      21,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_publishes_events",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_publishes_events",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_publishes_events",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::ConsumesDefSeq * IR::ComponentDef::consumes_events (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::ConsumesDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR::ConsumesDefSeq, _tao_retval);
  IR::ConsumesDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_consumes_events",
      20,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_consumes_events",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_consumes_events",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_consumes_events",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::Boolean IR::ComponentDef::is_basic (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_is_basic",
      13,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN  (_tao_retval);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN  (_tao_retval);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_is_basic",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_is_basic",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_is_basic",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN  (_tao_retval);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_retval;
}

IR::ProvidesDef_ptr IR::ComponentDef::create_provides (
    const char * id,
    const char * name,
    const char * version,
    IR::InterfaceDef_ptr interface_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::ProvidesDef_ptr _tao_retval = IR::ProvidesDef::_nil ();
  IR::ProvidesDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_provides",
      15,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_provides",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << interface_type)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_provides",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_provides",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::UsesDef_ptr IR::ComponentDef::create_uses (
    const char * id,
    const char * name,
    const char * version,
    IR::InterfaceDef_ptr interface_type,
    CORBA::Boolean is_multiple,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::UsesDef_ptr _tao_retval = IR::UsesDef::_nil ();
  IR::UsesDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_uses",
      11,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_uses",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << interface_type) &&
              (_tao_out << CORBA::Any::from_boolean (is_multiple))
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_uses",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_uses",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::EmitsDef_ptr IR::ComponentDef::create_emits (
    const char * id,
    const char * name,
    const char * version,
    IR::ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::EmitsDef_ptr _tao_retval = IR::EmitsDef::_nil ();
  IR::EmitsDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_emits",
      12,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_emits",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << value)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_emits",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_emits",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::PublishesDef_ptr IR::ComponentDef::create_publishes (
    const char * id,
    const char * name,
    const char * version,
    IR::ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::PublishesDef_ptr _tao_retval = IR::PublishesDef::_nil ();
  IR::PublishesDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_publishes",
      16,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_publishes",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << value)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_publishes",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_publishes",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::ConsumesDef_ptr IR::ComponentDef::create_consumes (
    const char * id,
    const char * name,
    const char * version,
    IR::ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::ConsumesDef_ptr _tao_retval = IR::ConsumesDef::_nil ();
  IR::ConsumesDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_consumes",
      15,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_consumes",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << value)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_consumes",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_consumes",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::Boolean IR::ComponentDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ComponentDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::ComponentDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ComponentDef:1.0";
}

IR::TAO_IR_ComponentDef_Default_Proxy_Factory::TAO_IR_ComponentDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_ComponentDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_ComponentDef_Default_Proxy_Factory::~TAO_IR_ComponentDef_Default_Proxy_Factory (void)
{
}

IR::ComponentDef_ptr
IR::TAO_IR_ComponentDef_Default_Proxy_Factory::create_proxy (
    ::IR::ComponentDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_ComponentDef_Proxy_Factory_Adapter::TAO_IR_ComponentDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_ComponentDef_Proxy_Factory_Adapter::~TAO_IR_ComponentDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_ComponentDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_ComponentDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_ComponentDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::ComponentDef_ptr
IR::TAO_IR_ComponentDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::ComponentDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_ComponentDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_ComponentDef_Smart_Proxy_Base::TAO_IR_ComponentDef_Smart_Proxy_Base (::IR::ComponentDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_ComponentDef_Smart_Proxy_Base::~TAO_IR_ComponentDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_ComponentDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

IR::InterfaceDefSeq * IR::TAO_IR_ComponentDef_Smart_Proxy_Base::supported_interfaces  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->supported_interfaces (
      ACE_TRY_ENV
    );

}

void IR::TAO_IR_ComponentDef_Smart_Proxy_Base::supported_interfaces  (
    const IR::InterfaceDefSeq & supported_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->supported_interfaces (
      supported_interfaces,
      ACE_TRY_ENV
    );

}

IR::ComponentDef_ptr IR::TAO_IR_ComponentDef_Smart_Proxy_Base::base_component  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->base_component (
      ACE_TRY_ENV
    );

}

IR::ProvidesDefSeq * IR::TAO_IR_ComponentDef_Smart_Proxy_Base::provides_interfaces  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->provides_interfaces (
      ACE_TRY_ENV
    );

}

IR::UsesDefSeq * IR::TAO_IR_ComponentDef_Smart_Proxy_Base::uses_interfaces  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->uses_interfaces (
      ACE_TRY_ENV
    );

}

IR::EmitsDefSeq * IR::TAO_IR_ComponentDef_Smart_Proxy_Base::emits_events  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->emits_events (
      ACE_TRY_ENV
    );

}

IR::PublishesDefSeq * IR::TAO_IR_ComponentDef_Smart_Proxy_Base::publishes_events  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->publishes_events (
      ACE_TRY_ENV
    );

}

IR::ConsumesDefSeq * IR::TAO_IR_ComponentDef_Smart_Proxy_Base::consumes_events  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->consumes_events (
      ACE_TRY_ENV
    );

}

CORBA::Boolean IR::TAO_IR_ComponentDef_Smart_Proxy_Base::is_basic  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->is_basic (
      ACE_TRY_ENV
    );

}

IR::ProvidesDef_ptr IR::TAO_IR_ComponentDef_Smart_Proxy_Base::create_provides  (
    const char * id,
    const char * name,
    const char * version,
    IR::InterfaceDef_ptr interface_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_provides (
      id,
      name,
      version,
      interface_type,
      ACE_TRY_ENV
    );

}

IR::UsesDef_ptr IR::TAO_IR_ComponentDef_Smart_Proxy_Base::create_uses  (
    const char * id,
    const char * name,
    const char * version,
    IR::InterfaceDef_ptr interface_type,
    CORBA::Boolean is_multiple,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_uses (
      id,
      name,
      version,
      interface_type,
      is_multiple,
      ACE_TRY_ENV
    );

}

IR::EmitsDef_ptr IR::TAO_IR_ComponentDef_Smart_Proxy_Base::create_emits  (
    const char * id,
    const char * name,
    const char * version,
    IR::ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_emits (
      id,
      name,
      version,
      value,
      ACE_TRY_ENV
    );

}

IR::PublishesDef_ptr IR::TAO_IR_ComponentDef_Smart_Proxy_Base::create_publishes  (
    const char * id,
    const char * name,
    const char * version,
    IR::ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_publishes (
      id,
      name,
      version,
      value,
      ACE_TRY_ENV
    );

}

IR::ConsumesDef_ptr IR::TAO_IR_ComponentDef_Smart_Proxy_Base::create_consumes  (
    const char * id,
    const char * name,
    const char * version,
    IR::ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_consumes (
      id,
      name,
      version,
      value,
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_ComponentDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_ComponentDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_ComponentDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6d706f), ACE_NTOHL (0x6e656e74), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ComponentDef:1.0
  13, ACE_NTOHL (0x436f6d70), ACE_NTOHL (0x6f6e656e), ACE_NTOHL (0x74446566), ACE_NTOHL (0x0),  // name = ComponentDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_ComponentDef (CORBA::tk_objref, sizeof (_oc_IR_ComponentDef), (char *) &_oc_IR_ComponentDef, 0, sizeof (IR::ComponentDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ComponentDef, &_tc_TAO_tc_IR_ComponentDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_IR_ComponentDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6d706f), ACE_NTOHL (0x6e656e74), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ComponentDescription:1.0
  21, ACE_NTOHL (0x436f6d70), ACE_NTOHL (0x6f6e656e), ACE_NTOHL (0x74446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ComponentDescription
  13, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  132, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_alias, // typecode kind for typedefs
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
      11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
      CORBA::tk_string, 
      0U, // string length


  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  15, ACE_NTOHL (0x62617365), ACE_NTOHL (0x5f636f6d), ACE_NTOHL (0x706f6e65), ACE_NTOHL (0x6e740000),  // name = base_component
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  20, ACE_NTOHL (0x73757070), ACE_NTOHL (0x6f727473), ACE_NTOHL (0x5f696e74), ACE_NTOHL (0x65726661), ACE_NTOHL (0x63657300),  // name = supports_interfaces
  CORBA::tk_alias, // typecode kind for typedefs
  228, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79496453), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/RepositoryIdSeq:1.0
    16, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
    CORBA::tk_sequence, // typecode kind
    156, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_alias, // typecode kind for typedefs
      140, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length


      0U,


  20, ACE_NTOHL (0x70726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x5f696e74), ACE_NTOHL (0x65726661), ACE_NTOHL (0x63657300),  // name = provides_interfaces
  CORBA::tk_alias, // typecode kind for typedefs
  144, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657344), ACE_NTOHL (0x65665365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ProvidesDefSeq:1.0
    15, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65710000),  // name = ProvidesDefSeq
    CORBA::tk_sequence, // typecode kind
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      56, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDef:1.0
        12, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44656600),  // name = ProvidesDef

      0U,


  16, ACE_NTOHL (0x75736573), ACE_NTOHL (0x5f696e74), ACE_NTOHL (0x65726661), ACE_NTOHL (0x63657300),  // name = uses_interfaces
  CORBA::tk_alias, // typecode kind for typedefs
  128, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x73657344), ACE_NTOHL (0x65665365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/UsesDefSeq:1.0
    11, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65710000),  // name = UsesDefSeq
    CORBA::tk_sequence, // typecode kind
    64, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      48, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x73657344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDef:1.0
        8, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44656600),  // name = UsesDef

      0U,


  11, ACE_NTOHL (0x61747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65730000),  // name = attributes
  CORBA::tk_alias, // typecode kind for typedefs
  2424, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/AttrDescriptionSeq:1.0
    19, ACE_NTOHL (0x41747472), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65710000),  // name = AttrDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    2344, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      2328, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/AttributeDescription:1.0
        21, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = AttributeDescription
        8, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        132, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_alias, // typecode kind for typedefs
          68, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
            11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
            CORBA::tk_string, 
            0U, // string length


        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        140, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_alias, // typecode kind for typedefs
          72, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
            13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
            CORBA::tk_string, 
            0U, // string length


        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        140, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_alias, // typecode kind for typedefs
          72, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
            13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
            CORBA::tk_string, 
            0U, // string length


        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string, 
          0U, // string length

        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,

        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        104, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/AttributeMode:1.0
          14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
          2, // member count
          12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
          14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY

        15, ACE_NTOHL (0x6765745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = get_exceptions
        CORBA::tk_alias, // typecode kind for typedefs
        748, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          668, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            652, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              132, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_alias, // typecode kind for typedefs
                68, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                  11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                  CORBA::tk_string, 
                  0U, // string length


              3, ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              140, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_alias, // typecode kind for typedefs
                72, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                  13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                  CORBA::tk_string, 
                  0U, // string length


              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_alias, // typecode kind for typedefs
              140, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_alias, // typecode kind for typedefs
                72, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                  13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                  CORBA::tk_string, 
                  0U, // string length


              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string, 
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,


        15, ACE_NTOHL (0x7075745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = put_exceptions
        CORBA::tk_alias, // typecode kind for typedefs
        748, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          668, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            652, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              132, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_alias, // typecode kind for typedefs
                68, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                  11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                  CORBA::tk_string, 
                  0U, // string length


              3, ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              140, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_alias, // typecode kind for typedefs
                72, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                  13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                  CORBA::tk_string, 
                  0U, // string length


              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_alias, // typecode kind for typedefs
              140, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_alias, // typecode kind for typedefs
                72, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                  13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                  CORBA::tk_string, 
                  0U, // string length


              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string, 
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,



      0U,


  13, ACE_NTOHL (0x656d6974), ACE_NTOHL (0x735f6576), ACE_NTOHL (0x656e7473), ACE_NTOHL (0x0),  // name = emits_events
  CORBA::tk_alias, // typecode kind for typedefs
  132, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x6d697473), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/EmitsDefSeq:1.0
    12, ACE_NTOHL (0x456d6974), ACE_NTOHL (0x73446566), ACE_NTOHL (0x53657100),  // name = EmitsDefSeq
    CORBA::tk_sequence, // typecode kind
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      52, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x6d697473), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/EmitsDef:1.0
        9, ACE_NTOHL (0x456d6974), ACE_NTOHL (0x73446566), ACE_NTOHL (0x0),  // name = EmitsDef

      0U,


  17, ACE_NTOHL (0x7075626c), ACE_NTOHL (0x69736865), ACE_NTOHL (0x735f6576), ACE_NTOHL (0x656e7473), ACE_NTOHL (0x0),  // name = publishes_events
  CORBA::tk_alias, // typecode kind for typedefs
  148, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x75626c69), ACE_NTOHL (0x73686573), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/PublishesDefSeq:1.0
    16, ACE_NTOHL (0x5075626c), ACE_NTOHL (0x69736865), ACE_NTOHL (0x73446566), ACE_NTOHL (0x53657100),  // name = PublishesDefSeq
    CORBA::tk_sequence, // typecode kind
    76, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      60, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x75626c69), ACE_NTOHL (0x73686573), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/PublishesDef:1.0
        13, ACE_NTOHL (0x5075626c), ACE_NTOHL (0x69736865), ACE_NTOHL (0x73446566), ACE_NTOHL (0x0),  // name = PublishesDef

      0U,


  16, ACE_NTOHL (0x636f6e73), ACE_NTOHL (0x756d6573), ACE_NTOHL (0x5f657665), ACE_NTOHL (0x6e747300),  // name = consumes_events
  CORBA::tk_alias, // typecode kind for typedefs
  144, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7375), ACE_NTOHL (0x6d657344), ACE_NTOHL (0x65665365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ConsumesDefSeq:1.0
    15, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x756d6573), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65710000),  // name = ConsumesDefSeq
    CORBA::tk_sequence, // typecode kind
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      56, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7375), ACE_NTOHL (0x6d657344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ConsumesDef:1.0
        12, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x756d6573), ACE_NTOHL (0x44656600),  // name = ConsumesDef

      0U,


  9, ACE_NTOHL (0x69735f62), ACE_NTOHL (0x61736963), ACE_NTOHL (0x0),  // name = is_basic
  CORBA::tk_boolean,

};
static CORBA::TypeCode _tc_TAO_tc_IR_ComponentDescription (CORBA::tk_struct, sizeof (_oc_IR_ComponentDescription), (char *) &_oc_IR_ComponentDescription, 0, sizeof (IR::ComponentDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ComponentDescription, &_tc_TAO_tc_IR_ComponentDescription)
TAO_NAMESPACE_END
void IR::ComponentDescription::_tao_any_destructor (void *x)
{
  ComponentDescription *tmp = ACE_static_cast (ComponentDescription*,x);
  delete tmp;
}

void IR::PrimaryKeyDef::_tao_any_destructor (void *x)
{
  PrimaryKeyDef *tmp = ACE_static_cast (PrimaryKeyDef*,x);
  CORBA::release (tmp);
}

IR::PrimaryKeyDef_ptr IR::PrimaryKeyDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return PrimaryKeyDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/PrimaryKeyDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (PrimaryKeyDef::_nil ());
  if (is_a == 0)
    return PrimaryKeyDef::_nil ();
  return PrimaryKeyDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::PrimaryKeyDef_ptr IR::PrimaryKeyDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return PrimaryKeyDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  PrimaryKeyDef_ptr default_proxy = PrimaryKeyDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_PrimaryKeyDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_PrimaryKeyDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, PrimaryKeyDef (stub), PrimaryKeyDef::_nil ());
  return TAO_IR_PrimaryKeyDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::PrimaryKeyDef_ptr 
IR::PrimaryKeyDef::_duplicate (PrimaryKeyDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::Boolean IR::PrimaryKeyDef::is_a (
    const char * primary_key_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "is_a",
      4,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN  (_tao_retval);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN  (_tao_retval);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "is_a",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << primary_key_id)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "is_a",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "is_a",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN  (_tao_retval);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_retval;
}

IR::ValueDef_ptr IR::PrimaryKeyDef::primary_key (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::ValueDef_ptr _tao_retval = IR::ValueDef::_nil ();
  IR::ValueDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_primary_key",
      16,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_primary_key",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_primary_key",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_primary_key",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::Boolean IR::PrimaryKeyDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/PrimaryKeyDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::PrimaryKeyDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/PrimaryKeyDef:1.0";
}

IR::TAO_IR_PrimaryKeyDef_Default_Proxy_Factory::TAO_IR_PrimaryKeyDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_PrimaryKeyDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_PrimaryKeyDef_Default_Proxy_Factory::~TAO_IR_PrimaryKeyDef_Default_Proxy_Factory (void)
{
}

IR::PrimaryKeyDef_ptr
IR::TAO_IR_PrimaryKeyDef_Default_Proxy_Factory::create_proxy (
    ::IR::PrimaryKeyDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_PrimaryKeyDef_Proxy_Factory_Adapter::TAO_IR_PrimaryKeyDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_PrimaryKeyDef_Proxy_Factory_Adapter::~TAO_IR_PrimaryKeyDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_PrimaryKeyDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_PrimaryKeyDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_PrimaryKeyDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::PrimaryKeyDef_ptr
IR::TAO_IR_PrimaryKeyDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::PrimaryKeyDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_PrimaryKeyDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_PrimaryKeyDef_Smart_Proxy_Base::TAO_IR_PrimaryKeyDef_Smart_Proxy_Base (::IR::PrimaryKeyDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_PrimaryKeyDef_Smart_Proxy_Base::~TAO_IR_PrimaryKeyDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_PrimaryKeyDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

CORBA::Boolean IR::TAO_IR_PrimaryKeyDef_Smart_Proxy_Base::is_a  (
    const char * primary_key_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->is_a (
      primary_key_id,
      ACE_TRY_ENV
    );

}

IR::ValueDef_ptr IR::TAO_IR_PrimaryKeyDef_Smart_Proxy_Base::primary_key  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->primary_key (
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_PrimaryKeyDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_PrimaryKeyDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_PrimaryKeyDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x72696d61), ACE_NTOHL (0x72794b65), ACE_NTOHL (0x79446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/PrimaryKeyDef:1.0
  14, ACE_NTOHL (0x5072696d), ACE_NTOHL (0x6172794b), ACE_NTOHL (0x65794465), ACE_NTOHL (0x66000000),  // name = PrimaryKeyDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_PrimaryKeyDef (CORBA::tk_objref, sizeof (_oc_IR_PrimaryKeyDef), (char *) &_oc_IR_PrimaryKeyDef, 0, sizeof (IR::PrimaryKeyDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PrimaryKeyDef, &_tc_TAO_tc_IR_PrimaryKeyDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_IR_PrimaryKeyDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  41, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x72696d61), ACE_NTOHL (0x72794b65), ACE_NTOHL (0x79446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/PrimaryKeyDescription:1.0
  22, ACE_NTOHL (0x5072696d), ACE_NTOHL (0x6172794b), ACE_NTOHL (0x65794465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e000000),  // name = PrimaryKeyDescription
  5, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  132, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_alias, // typecode kind for typedefs
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
      11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
      CORBA::tk_string, 
      0U, // string length


  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  12, ACE_NTOHL (0x7072696d), ACE_NTOHL (0x6172795f), ACE_NTOHL (0x6b657900),  // name = primary_key
  CORBA::tk_objref, // typecode kind
  52, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ValueDef:1.0
    9, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = ValueDef

};
static CORBA::TypeCode _tc_TAO_tc_IR_PrimaryKeyDescription (CORBA::tk_struct, sizeof (_oc_IR_PrimaryKeyDescription), (char *) &_oc_IR_PrimaryKeyDescription, 0, sizeof (IR::PrimaryKeyDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PrimaryKeyDescription, &_tc_TAO_tc_IR_PrimaryKeyDescription)
TAO_NAMESPACE_END
void IR::PrimaryKeyDescription::_tao_any_destructor (void *x)
{
  PrimaryKeyDescription *tmp = ACE_static_cast (PrimaryKeyDescription*,x);
  delete tmp;
}

void IR::FactoryDef::_tao_any_destructor (void *x)
{
  FactoryDef *tmp = ACE_static_cast (FactoryDef*,x);
  CORBA::release (tmp);
}

IR::FactoryDef_ptr IR::FactoryDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return FactoryDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/FactoryDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (FactoryDef::_nil ());
  if (is_a == 0)
    return FactoryDef::_nil ();
  return FactoryDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::FactoryDef_ptr IR::FactoryDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return FactoryDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  FactoryDef_ptr default_proxy = FactoryDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_FactoryDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_FactoryDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, FactoryDef (stub), FactoryDef::_nil ());
  return TAO_IR_FactoryDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::FactoryDef_ptr 
IR::FactoryDef::_duplicate (FactoryDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::Boolean IR::FactoryDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/FactoryDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/OperationDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::FactoryDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/FactoryDef:1.0";
}

IR::TAO_IR_FactoryDef_Default_Proxy_Factory::TAO_IR_FactoryDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_FactoryDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_FactoryDef_Default_Proxy_Factory::~TAO_IR_FactoryDef_Default_Proxy_Factory (void)
{
}

IR::FactoryDef_ptr
IR::TAO_IR_FactoryDef_Default_Proxy_Factory::create_proxy (
    ::IR::FactoryDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_FactoryDef_Proxy_Factory_Adapter::TAO_IR_FactoryDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_FactoryDef_Proxy_Factory_Adapter::~TAO_IR_FactoryDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_FactoryDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_FactoryDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_FactoryDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::FactoryDef_ptr
IR::TAO_IR_FactoryDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::FactoryDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_FactoryDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_FactoryDef_Smart_Proxy_Base::TAO_IR_FactoryDef_Smart_Proxy_Base (::IR::FactoryDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_FactoryDef_Smart_Proxy_Base::~TAO_IR_FactoryDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_FactoryDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_FactoryDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_FactoryDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_FactoryDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x6163746f), ACE_NTOHL (0x72794465), ACE_NTOHL (0x663a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/FactoryDef:1.0
  11, ACE_NTOHL (0x46616374), ACE_NTOHL (0x6f727944), ACE_NTOHL (0x65660000),  // name = FactoryDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_FactoryDef (CORBA::tk_objref, sizeof (_oc_IR_FactoryDef), (char *) &_oc_IR_FactoryDef, 0, sizeof (IR::FactoryDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FactoryDef, &_tc_TAO_tc_IR_FactoryDef)
TAO_NAMESPACE_END
void IR::FinderDef::_tao_any_destructor (void *x)
{
  FinderDef *tmp = ACE_static_cast (FinderDef*,x);
  CORBA::release (tmp);
}

IR::FinderDef_ptr IR::FinderDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return FinderDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/FinderDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (FinderDef::_nil ());
  if (is_a == 0)
    return FinderDef::_nil ();
  return FinderDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::FinderDef_ptr IR::FinderDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return FinderDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  FinderDef_ptr default_proxy = FinderDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_FinderDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_FinderDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, FinderDef (stub), FinderDef::_nil ());
  return TAO_IR_FinderDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::FinderDef_ptr 
IR::FinderDef::_duplicate (FinderDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::Boolean IR::FinderDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/FinderDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/OperationDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::FinderDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/FinderDef:1.0";
}

IR::TAO_IR_FinderDef_Default_Proxy_Factory::TAO_IR_FinderDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_FinderDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_FinderDef_Default_Proxy_Factory::~TAO_IR_FinderDef_Default_Proxy_Factory (void)
{
}

IR::FinderDef_ptr
IR::TAO_IR_FinderDef_Default_Proxy_Factory::create_proxy (
    ::IR::FinderDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_FinderDef_Proxy_Factory_Adapter::TAO_IR_FinderDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_FinderDef_Proxy_Factory_Adapter::~TAO_IR_FinderDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_FinderDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_FinderDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_FinderDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::FinderDef_ptr
IR::TAO_IR_FinderDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::FinderDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_FinderDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_FinderDef_Smart_Proxy_Base::TAO_IR_FinderDef_Smart_Proxy_Base (::IR::FinderDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_FinderDef_Smart_Proxy_Base::~TAO_IR_FinderDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_FinderDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_FinderDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_FinderDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_FinderDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x696e6465), ACE_NTOHL (0x72446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/FinderDef:1.0
  10, ACE_NTOHL (0x46696e64), ACE_NTOHL (0x65724465), ACE_NTOHL (0x66000000),  // name = FinderDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_FinderDef (CORBA::tk_objref, sizeof (_oc_IR_FinderDef), (char *) &_oc_IR_FinderDef, 0, sizeof (IR::FinderDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FinderDef, &_tc_TAO_tc_IR_FinderDef)
TAO_NAMESPACE_END
void IR::HomeDef::_tao_any_destructor (void *x)
{
  HomeDef *tmp = ACE_static_cast (HomeDef*,x);
  CORBA::release (tmp);
}

IR::HomeDef_ptr IR::HomeDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return HomeDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/HomeDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (HomeDef::_nil ());
  if (is_a == 0)
    return HomeDef::_nil ();
  return HomeDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::HomeDef_ptr IR::HomeDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return HomeDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  HomeDef_ptr default_proxy = HomeDef::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_IR_HomeDef_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_IR_HomeDef_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, HomeDef (stub), HomeDef::_nil ());
  return TAO_IR_HomeDef_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

IR::HomeDef_ptr 
IR::HomeDef::_duplicate (HomeDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

IR::HomeDef_ptr IR::HomeDef::base_home (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::HomeDef_ptr _tao_retval = IR::HomeDef::_nil ();
  IR::HomeDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_base_home",
      14,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_base_home",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_base_home",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_base_home",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::ComponentDef_ptr IR::HomeDef::managed_component (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::ComponentDef_ptr _tao_retval = IR::ComponentDef::_nil ();
  IR::ComponentDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_managed_component",
      22,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_managed_component",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_managed_component",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_managed_component",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::PrimaryKeyDef_ptr IR::HomeDef::primary_key (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::PrimaryKeyDef_ptr _tao_retval = IR::PrimaryKeyDef::_nil ();
  IR::PrimaryKeyDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_primary_key",
      16,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_primary_key",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_primary_key",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_primary_key",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::FactoryDefSeq * IR::HomeDef::factories (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::FactoryDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR::FactoryDefSeq, _tao_retval);
  IR::FactoryDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_factories",
      14,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_factories",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_factories",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_factories",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::FinderDefSeq * IR::HomeDef::finders (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::FinderDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR::FinderDefSeq, _tao_retval);
  IR::FinderDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_finders",
      12,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_finders",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_finders",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_finders",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::Boolean IR::HomeDef::is_basic (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_is_basic",
      13,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN  (_tao_retval);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN  (_tao_retval);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_is_basic",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "_get_is_basic",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "_get_is_basic",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN  (_tao_retval);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_retval;
}

IR::PrimaryKeyDef_ptr IR::HomeDef::create_primary_key (
    const char * id,
    const char * name,
    const char * version,
    IR::ValueDef_ptr primary_key,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::PrimaryKeyDef_ptr _tao_retval = IR::PrimaryKeyDef::_nil ();
  IR::PrimaryKeyDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_primary_key",
      18,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_primary_key",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << primary_key)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_primary_key",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_primary_key",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::FactoryDef_ptr IR::HomeDef::create_factory (
    const char * id,
    const char * name,
    const char * version,
    const IR::ParDescriptionSeq & params,
    const IR::ExceptionDefSeq & exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::FactoryDef_ptr _tao_retval = IR::FactoryDef::_nil ();
  IR::FactoryDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_factory",
      14,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_factory",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << params) &&
              (_tao_out << exceptions)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_factory",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_factory",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

IR::FinderDef_ptr IR::HomeDef::create_finder (
    const char * id,
    const char * name,
    const char * version,
    const IR::ParDescriptionSeq & params,
    const IR::ExceptionDefSeq & exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::FinderDef_ptr _tao_retval = IR::FinderDef::_nil ();
  IR::FinderDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_finder",
      13,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_finder",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << params) &&
              (_tao_out << exceptions)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_finder",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_finder",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::Boolean IR::HomeDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/HomeDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* IR::HomeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/HomeDef:1.0";
}

IR::TAO_IR_HomeDef_Default_Proxy_Factory::TAO_IR_HomeDef_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_IR_HomeDef_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

IR::TAO_IR_HomeDef_Default_Proxy_Factory::~TAO_IR_HomeDef_Default_Proxy_Factory (void)
{
}

IR::HomeDef_ptr
IR::TAO_IR_HomeDef_Default_Proxy_Factory::create_proxy (
    ::IR::HomeDef_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

IR::TAO_IR_HomeDef_Proxy_Factory_Adapter::TAO_IR_HomeDef_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

IR::TAO_IR_HomeDef_Proxy_Factory_Adapter::~TAO_IR_HomeDef_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
IR::TAO_IR_HomeDef_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_IR_HomeDef_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
IR::TAO_IR_HomeDef_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

IR::HomeDef_ptr
IR::TAO_IR_HomeDef_Proxy_Factory_Adapter::create_proxy (
    ::IR::HomeDef_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_IR_HomeDef_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

IR::TAO_IR_HomeDef_Smart_Proxy_Base::TAO_IR_HomeDef_Smart_Proxy_Base (::IR::HomeDef_ptr proxy)
: base_proxy_ (proxy)
{
}

IR::TAO_IR_HomeDef_Smart_Proxy_Base::~TAO_IR_HomeDef_Smart_Proxy_Base (void)
{
}

TAO_Stub *
IR::TAO_IR_HomeDef_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

IR::HomeDef_ptr IR::TAO_IR_HomeDef_Smart_Proxy_Base::base_home  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->base_home (
      ACE_TRY_ENV
    );

}

IR::ComponentDef_ptr IR::TAO_IR_HomeDef_Smart_Proxy_Base::managed_component  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->managed_component (
      ACE_TRY_ENV
    );

}

IR::PrimaryKeyDef_ptr IR::TAO_IR_HomeDef_Smart_Proxy_Base::primary_key  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->primary_key (
      ACE_TRY_ENV
    );

}

IR::FactoryDefSeq * IR::TAO_IR_HomeDef_Smart_Proxy_Base::factories  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->factories (
      ACE_TRY_ENV
    );

}

IR::FinderDefSeq * IR::TAO_IR_HomeDef_Smart_Proxy_Base::finders  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->finders (
      ACE_TRY_ENV
    );

}

CORBA::Boolean IR::TAO_IR_HomeDef_Smart_Proxy_Base::is_basic  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->is_basic (
      ACE_TRY_ENV
    );

}

IR::PrimaryKeyDef_ptr IR::TAO_IR_HomeDef_Smart_Proxy_Base::create_primary_key  (
    const char * id,
    const char * name,
    const char * version,
    IR::ValueDef_ptr primary_key,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_primary_key (
      id,
      name,
      version,
      primary_key,
      ACE_TRY_ENV
    );

}

IR::FactoryDef_ptr IR::TAO_IR_HomeDef_Smart_Proxy_Base::create_factory  (
    const char * id,
    const char * name,
    const char * version,
    const IR::ParDescriptionSeq & params,
    const IR::ExceptionDefSeq & exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_factory (
      id,
      name,
      version,
      params,
      exceptions,
      ACE_TRY_ENV
    );

}

IR::FinderDef_ptr IR::TAO_IR_HomeDef_Smart_Proxy_Base::create_finder  (
    const char * id,
    const char * name,
    const char * version,
    const IR::ParDescriptionSeq & params,
    const IR::ExceptionDefSeq & exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_finder (
      id,
      name,
      version,
      params,
      exceptions,
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<IR::TAO_IR_HomeDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<IR::TAO_IR_HomeDef_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_IR_HomeDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f48), ACE_NTOHL (0x6f6d6544), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/HomeDef:1.0
  8, ACE_NTOHL (0x486f6d65), ACE_NTOHL (0x44656600),  // name = HomeDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_HomeDef (CORBA::tk_objref, sizeof (_oc_IR_HomeDef), (char *) &_oc_IR_HomeDef, 0, sizeof (IR::HomeDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_HomeDef, &_tc_TAO_tc_IR_HomeDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_IR_HomeDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f48), ACE_NTOHL (0x6f6d6544), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/HomeDescription:1.0
  16, ACE_NTOHL (0x486f6d65), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = HomeDescription
  12, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  132, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_alias, // typecode kind for typedefs
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
      11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
      CORBA::tk_string, 
      0U, // string length


  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  10, ACE_NTOHL (0x62617365), ACE_NTOHL (0x5f686f6d), ACE_NTOHL (0x65000000),  // name = base_home
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  18, ACE_NTOHL (0x6d616e61), ACE_NTOHL (0x6765645f), ACE_NTOHL (0x636f6d70), ACE_NTOHL (0x6f6e656e), ACE_NTOHL (0x74000000),  // name = managed_component
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


  16, ACE_NTOHL (0x7072696d), ACE_NTOHL (0x6172795f), ACE_NTOHL (0x6b65795f), ACE_NTOHL (0x64656600),  // name = primary_key_def
  CORBA::tk_objref, // typecode kind
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x72696d61), ACE_NTOHL (0x72794b65), ACE_NTOHL (0x79446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/PrimaryKeyDef:1.0
    14, ACE_NTOHL (0x5072696d), ACE_NTOHL (0x6172794b), ACE_NTOHL (0x65794465), ACE_NTOHL (0x66000000),  // name = PrimaryKeyDef

  10, ACE_NTOHL (0x66616374), ACE_NTOHL (0x6f726965), ACE_NTOHL (0x73000000),  // name = factories
  CORBA::tk_alias, // typecode kind for typedefs
  144, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x6163746f), ACE_NTOHL (0x72794465), ACE_NTOHL (0x66536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/FactoryDefSeq:1.0
    14, ACE_NTOHL (0x46616374), ACE_NTOHL (0x6f727944), ACE_NTOHL (0x65665365), ACE_NTOHL (0x71000000),  // name = FactoryDefSeq
    CORBA::tk_sequence, // typecode kind
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      56, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x6163746f), ACE_NTOHL (0x72794465), ACE_NTOHL (0x663a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/FactoryDef:1.0
        11, ACE_NTOHL (0x46616374), ACE_NTOHL (0x6f727944), ACE_NTOHL (0x65660000),  // name = FactoryDef

      0U,


  8, ACE_NTOHL (0x66696e64), ACE_NTOHL (0x65727300),  // name = finders
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x696e6465), ACE_NTOHL (0x72446566), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/FinderDefSeq:1.0
    13, ACE_NTOHL (0x46696e64), ACE_NTOHL (0x65724465), ACE_NTOHL (0x66536571), ACE_NTOHL (0x0),  // name = FinderDefSeq
    CORBA::tk_sequence, // typecode kind
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      56, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x696e6465), ACE_NTOHL (0x72446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/FinderDef:1.0
        10, ACE_NTOHL (0x46696e64), ACE_NTOHL (0x65724465), ACE_NTOHL (0x66000000),  // name = FinderDef

      0U,


  11, ACE_NTOHL (0x6f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e730000),  // name = operations
  CORBA::tk_alias, // typecode kind for typedefs
  2532, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OpDescriptionSeq:1.0
    17, ACE_NTOHL (0x4f704465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x0),  // name = OpDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    2456, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      2440, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OperationDescription:1.0
        21, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = OperationDescription
        9, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        132, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_alias, // typecode kind for typedefs
          68, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
            11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
            CORBA::tk_string, 
            0U, // string length


        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        140, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_alias, // typecode kind for typedefs
          72, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
            13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
            CORBA::tk_string, 
            0U, // string length


        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        140, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_alias, // typecode kind for typedefs
          72, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
            13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
            CORBA::tk_string, 
            0U, // string length


        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string, 
          0U, // string length

        7, ACE_NTOHL (0x72657375), ACE_NTOHL (0x6c740000),  // name = result
        CORBA::tk_TypeCode,

        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        100, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/OperationMode:1.0
          14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
          2, // member count
          10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
          10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY

        9, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x65787473), ACE_NTOHL (0x0),  // name = contexts
        CORBA::tk_alias, // typecode kind for typedefs
        296, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ContextIdSeq:1.0
          13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
          CORBA::tk_sequence, // typecode kind
          228, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_alias, // typecode kind for typedefs
            212, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ContextIdentifier:1.0
              18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
              CORBA::tk_alias, // typecode kind for typedefs
              132, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_alias, // typecode kind for typedefs
                68, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                  11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                  CORBA::tk_string, 
                  0U, // string length



            0U,


        11, ACE_NTOHL (0x70617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72730000),  // name = parameters
        CORBA::tk_alias, // typecode kind for typedefs
        552, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x61724465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParDescriptionSeq:1.0
          18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          472, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            456, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ParameterDescription:1.0
              21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
              4, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              132, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_alias, // typecode kind for typedefs
                68, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                  11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                  CORBA::tk_string, 
                  0U, // string length


              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,

              9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
              CORBA::tk_objref, // typecode kind
              48, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
                8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

              5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
              CORBA::tk_enum, // typecode kind
              116, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParameterMode:1.0
                14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
                3, // member count
                9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
                10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
                12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT


            0U,


        11, ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = exceptions
        CORBA::tk_alias, // typecode kind for typedefs
        748, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          668, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            652, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              132, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_alias, // typecode kind for typedefs
                68, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                  11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                  CORBA::tk_string, 
                  0U, // string length


              3, ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              140, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_alias, // typecode kind for typedefs
                72, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                  13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                  CORBA::tk_string, 
                  0U, // string length


              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_alias, // typecode kind for typedefs
              140, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_alias, // typecode kind for typedefs
                72, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                  13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                  CORBA::tk_string, 
                  0U, // string length


              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string, 
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,



      0U,


  11, ACE_NTOHL (0x61747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65730000),  // name = attributes
  CORBA::tk_alias, // typecode kind for typedefs
  2424, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/AttrDescriptionSeq:1.0
    19, ACE_NTOHL (0x41747472), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65710000),  // name = AttrDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    2344, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      2328, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/AttributeDescription:1.0
        21, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = AttributeDescription
        8, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        132, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_alias, // typecode kind for typedefs
          68, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
            11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
            CORBA::tk_string, 
            0U, // string length


        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        140, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_alias, // typecode kind for typedefs
          72, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
            13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
            CORBA::tk_string, 
            0U, // string length


        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        140, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_alias, // typecode kind for typedefs
          72, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
            13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
            CORBA::tk_string, 
            0U, // string length


        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string, 
          0U, // string length

        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,

        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        104, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/AttributeMode:1.0
          14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
          2, // member count
          12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
          14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY

        15, ACE_NTOHL (0x6765745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = get_exceptions
        CORBA::tk_alias, // typecode kind for typedefs
        748, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          668, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            652, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              132, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_alias, // typecode kind for typedefs
                68, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                  11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                  CORBA::tk_string, 
                  0U, // string length


              3, ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              140, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_alias, // typecode kind for typedefs
                72, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                  13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                  CORBA::tk_string, 
                  0U, // string length


              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_alias, // typecode kind for typedefs
              140, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_alias, // typecode kind for typedefs
                72, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                  13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                  CORBA::tk_string, 
                  0U, // string length


              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string, 
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,


        15, ACE_NTOHL (0x7075745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = put_exceptions
        CORBA::tk_alias, // typecode kind for typedefs
        748, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          668, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            652, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              132, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_alias, // typecode kind for typedefs
                68, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                  11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                  CORBA::tk_string, 
                  0U, // string length


              3, ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              140, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_alias, // typecode kind for typedefs
                72, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                  13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                  CORBA::tk_string, 
                  0U, // string length


              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_alias, // typecode kind for typedefs
              140, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_alias, // typecode kind for typedefs
                72, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                  13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                  CORBA::tk_string, 
                  0U, // string length


              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string, 
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,



      0U,


  9, ACE_NTOHL (0x69735f62), ACE_NTOHL (0x61736963), ACE_NTOHL (0x0),  // name = is_basic
  CORBA::tk_boolean,

};
static CORBA::TypeCode _tc_TAO_tc_IR_HomeDescription (CORBA::tk_struct, sizeof (_oc_IR_HomeDescription), (char *) &_oc_IR_HomeDescription, 0, sizeof (IR::HomeDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_HomeDescription, &_tc_TAO_tc_IR_HomeDescription)
TAO_NAMESPACE_END
void IR::HomeDescription::_tao_any_destructor (void *x)
{
  HomeDescription *tmp = ACE_static_cast (HomeDescription*,x);
  delete tmp;
}

void CORBA::TypeCodeFactory::_tao_any_destructor (void *x)
{
  TypeCodeFactory *tmp = ACE_static_cast (TypeCodeFactory*,x);
  CORBA::release (tmp);
}

CORBA::TypeCodeFactory_ptr CORBA::TypeCodeFactory::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return TypeCodeFactory::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/TypeCodeFactory:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (TypeCodeFactory::_nil ());
  if (is_a == 0)
    return TypeCodeFactory::_nil ();
  return TypeCodeFactory::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::TypeCodeFactory_ptr CORBA::TypeCodeFactory::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return TypeCodeFactory::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  if (stub)
    stub->_incr_refcnt ();
  TypeCodeFactory_ptr default_proxy = TypeCodeFactory::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_TypeCodeFactory_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_CORBA_TypeCodeFactory_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, TypeCodeFactory (stub), TypeCodeFactory::_nil ());
  return TAO_CORBA_TypeCodeFactory_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

CORBA::TypeCodeFactory_ptr 
CORBA::TypeCodeFactory::_duplicate (TypeCodeFactory_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::TypeCode_ptr CORBA::TypeCodeFactory::create_struct_tc (
    const char * id,
    const char * name,
    const IR::StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_struct_tc",
      16,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_struct_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << members)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_struct_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_struct_tc",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::TypeCode_ptr CORBA::TypeCodeFactory::create_union_tc (
    const char * id,
    const char * name,
    CORBA::TypeCode_ptr discriminator_type,
    const IR::UnionMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_union_tc",
      15,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_union_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << discriminator_type) &&
              (_tao_out << members)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_union_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_union_tc",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::TypeCode_ptr CORBA::TypeCodeFactory::create_enum_tc (
    const char * id,
    const char * name,
    const IR::EnumMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_enum_tc",
      14,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_enum_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << members)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_enum_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_enum_tc",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::TypeCode_ptr CORBA::TypeCodeFactory::create_alias_tc (
    const char * id,
    const char * name,
    CORBA::TypeCode_ptr original_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_alias_tc",
      15,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_alias_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << original_type)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_alias_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_alias_tc",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::TypeCode_ptr CORBA::TypeCodeFactory::create_exception_tc (
    const char * id,
    const char * name,
    const IR::StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_exception_tc",
      19,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_exception_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << members)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_exception_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_exception_tc",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::TypeCode_ptr CORBA::TypeCodeFactory::create_interface_tc (
    const char * id,
    const char * name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_interface_tc",
      19,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_interface_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_interface_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_interface_tc",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::TypeCode_ptr CORBA::TypeCodeFactory::create_string_tc (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_string_tc",
      16,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_string_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << bound)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_string_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_string_tc",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::TypeCode_ptr CORBA::TypeCodeFactory::create_wstring_tc (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_wstring_tc",
      17,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_wstring_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << bound)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_wstring_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_wstring_tc",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::TypeCode_ptr CORBA::TypeCodeFactory::create_fixed_tc (
    CORBA::UShort digits,
    CORBA::UShort scale,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_fixed_tc",
      15,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_fixed_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << digits) &&
              (_tao_out << scale)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_fixed_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_fixed_tc",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::TypeCode_ptr CORBA::TypeCodeFactory::create_sequence_tc (
    CORBA::ULong bound,
    CORBA::TypeCode_ptr element_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_sequence_tc",
      18,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_sequence_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << bound) &&
              (_tao_out << element_type)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_sequence_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_sequence_tc",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::TypeCode_ptr CORBA::TypeCodeFactory::create_array_tc (
    CORBA::ULong length,
    CORBA::TypeCode_ptr element_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_array_tc",
      15,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_array_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << length) &&
              (_tao_out << element_type)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_array_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_array_tc",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::TypeCode_ptr CORBA::TypeCodeFactory::create_value_tc (
    const char * id,
    const char * name,
    CORBA::ValueModifier type_modifier,
    CORBA::TypeCode_ptr concrete_base,
    const IR::ValueMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_value_tc",
      15,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_value_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << type_modifier) &&
              (_tao_out << concrete_base) &&
              (_tao_out << members)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_value_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_value_tc",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::TypeCode_ptr CORBA::TypeCodeFactory::create_value_box_tc (
    const char * id,
    const char * name,
    CORBA::TypeCode_ptr boxed_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_value_box_tc",
      19,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_value_box_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << boxed_type)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_value_box_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_value_box_tc",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::TypeCode_ptr CORBA::TypeCodeFactory::create_native_tc (
    const char * id,
    const char * name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_native_tc",
      16,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_native_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_native_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_native_tc",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::TypeCode_ptr CORBA::TypeCodeFactory::create_recursive_tc (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_recursive_tc",
      19,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_recursive_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_recursive_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_recursive_tc",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::TypeCode_ptr CORBA::TypeCodeFactory::create_abstract_interface_tc (
    const char * id,
    const char * name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_abstract_interface_tc",
      28,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_abstract_interface_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_abstract_interface_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_abstract_interface_tc",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::TypeCode_ptr CORBA::TypeCodeFactory::create_component_tc (
    const char * id,
    const char * name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_component_tc",
      19,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_component_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_component_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_component_tc",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::TypeCode_ptr CORBA::TypeCodeFactory::create_home_tc (
    const char * id,
    const char * name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_home_tc",
      14,
      istub->orb_core ()
    );

#if defined (TAO_HAS_INTERCEPTORS)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK_RETURN (0);
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_home_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << id) &&
              (_tao_out << name)
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          TAO_INTERCEPTOR_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "create_home_tc",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK_RETURN (0);
        break;
        
      }
#if defined (TAO_HAS_INTERCEPTORS)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "create_home_tc",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK_RETURN (0);
#endif /* TAO_HAS_INTERCEPTORS */
  return _tao_safe_retval._retn ();
}

CORBA::Boolean CORBA::TypeCodeFactory::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/TypeCodeFactory:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA::TypeCodeFactory::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/TypeCodeFactory:1.0";
}

CORBA::TAO_CORBA_TypeCodeFactory_Default_Proxy_Factory::TAO_CORBA_TypeCodeFactory_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_CORBA_TypeCodeFactory_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

CORBA::TAO_CORBA_TypeCodeFactory_Default_Proxy_Factory::~TAO_CORBA_TypeCodeFactory_Default_Proxy_Factory (void)
{
}

CORBA::TypeCodeFactory_ptr
CORBA::TAO_CORBA_TypeCodeFactory_Default_Proxy_Factory::create_proxy (
    ::CORBA::TypeCodeFactory_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

CORBA::TAO_CORBA_TypeCodeFactory_Proxy_Factory_Adapter::TAO_CORBA_TypeCodeFactory_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

CORBA::TAO_CORBA_TypeCodeFactory_Proxy_Factory_Adapter::~TAO_CORBA_TypeCodeFactory_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
CORBA::TAO_CORBA_TypeCodeFactory_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_CORBA_TypeCodeFactory_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
CORBA::TAO_CORBA_TypeCodeFactory_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

CORBA::TypeCodeFactory_ptr
CORBA::TAO_CORBA_TypeCodeFactory_Proxy_Factory_Adapter::create_proxy (
    ::CORBA::TypeCodeFactory_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_CORBA_TypeCodeFactory_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

CORBA::TAO_CORBA_TypeCodeFactory_Smart_Proxy_Base::TAO_CORBA_TypeCodeFactory_Smart_Proxy_Base (::CORBA::TypeCodeFactory_ptr proxy)
: base_proxy_ (proxy)
{
}

CORBA::TAO_CORBA_TypeCodeFactory_Smart_Proxy_Base::~TAO_CORBA_TypeCodeFactory_Smart_Proxy_Base (void)
{
}

TAO_Stub *
CORBA::TAO_CORBA_TypeCodeFactory_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

CORBA::TypeCode_ptr CORBA::TAO_CORBA_TypeCodeFactory_Smart_Proxy_Base::create_struct_tc  (
    const char * id,
    const char * name,
    const IR::StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_struct_tc (
      id,
      name,
      members,
      ACE_TRY_ENV
    );

}

CORBA::TypeCode_ptr CORBA::TAO_CORBA_TypeCodeFactory_Smart_Proxy_Base::create_union_tc  (
    const char * id,
    const char * name,
    CORBA::TypeCode_ptr discriminator_type,
    const IR::UnionMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_union_tc (
      id,
      name,
      discriminator_type,
      members,
      ACE_TRY_ENV
    );

}

CORBA::TypeCode_ptr CORBA::TAO_CORBA_TypeCodeFactory_Smart_Proxy_Base::create_enum_tc  (
    const char * id,
    const char * name,
    const IR::EnumMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_enum_tc (
      id,
      name,
      members,
      ACE_TRY_ENV
    );

}

CORBA::TypeCode_ptr CORBA::TAO_CORBA_TypeCodeFactory_Smart_Proxy_Base::create_alias_tc  (
    const char * id,
    const char * name,
    CORBA::TypeCode_ptr original_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_alias_tc (
      id,
      name,
      original_type,
      ACE_TRY_ENV
    );

}

CORBA::TypeCode_ptr CORBA::TAO_CORBA_TypeCodeFactory_Smart_Proxy_Base::create_exception_tc  (
    const char * id,
    const char * name,
    const IR::StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_exception_tc (
      id,
      name,
      members,
      ACE_TRY_ENV
    );

}

CORBA::TypeCode_ptr CORBA::TAO_CORBA_TypeCodeFactory_Smart_Proxy_Base::create_interface_tc  (
    const char * id,
    const char * name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_interface_tc (
      id,
      name,
      ACE_TRY_ENV
    );

}

CORBA::TypeCode_ptr CORBA::TAO_CORBA_TypeCodeFactory_Smart_Proxy_Base::create_string_tc  (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_string_tc (
      bound,
      ACE_TRY_ENV
    );

}

CORBA::TypeCode_ptr CORBA::TAO_CORBA_TypeCodeFactory_Smart_Proxy_Base::create_wstring_tc  (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_wstring_tc (
      bound,
      ACE_TRY_ENV
    );

}

CORBA::TypeCode_ptr CORBA::TAO_CORBA_TypeCodeFactory_Smart_Proxy_Base::create_fixed_tc  (
    CORBA::UShort digits,
    CORBA::UShort scale,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_fixed_tc (
      digits,
      scale,
      ACE_TRY_ENV
    );

}

CORBA::TypeCode_ptr CORBA::TAO_CORBA_TypeCodeFactory_Smart_Proxy_Base::create_sequence_tc  (
    CORBA::ULong bound,
    CORBA::TypeCode_ptr element_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_sequence_tc (
      bound,
      element_type,
      ACE_TRY_ENV
    );

}

CORBA::TypeCode_ptr CORBA::TAO_CORBA_TypeCodeFactory_Smart_Proxy_Base::create_array_tc  (
    CORBA::ULong length,
    CORBA::TypeCode_ptr element_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_array_tc (
      length,
      element_type,
      ACE_TRY_ENV
    );

}

CORBA::TypeCode_ptr CORBA::TAO_CORBA_TypeCodeFactory_Smart_Proxy_Base::create_value_tc  (
    const char * id,
    const char * name,
    CORBA::ValueModifier type_modifier,
    CORBA::TypeCode_ptr concrete_base,
    const IR::ValueMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_value_tc (
      id,
      name,
      type_modifier,
      concrete_base,
      members,
      ACE_TRY_ENV
    );

}

CORBA::TypeCode_ptr CORBA::TAO_CORBA_TypeCodeFactory_Smart_Proxy_Base::create_value_box_tc  (
    const char * id,
    const char * name,
    CORBA::TypeCode_ptr boxed_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_value_box_tc (
      id,
      name,
      boxed_type,
      ACE_TRY_ENV
    );

}

CORBA::TypeCode_ptr CORBA::TAO_CORBA_TypeCodeFactory_Smart_Proxy_Base::create_native_tc  (
    const char * id,
    const char * name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_native_tc (
      id,
      name,
      ACE_TRY_ENV
    );

}

CORBA::TypeCode_ptr CORBA::TAO_CORBA_TypeCodeFactory_Smart_Proxy_Base::create_recursive_tc  (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_recursive_tc (
      id,
      ACE_TRY_ENV
    );

}

CORBA::TypeCode_ptr CORBA::TAO_CORBA_TypeCodeFactory_Smart_Proxy_Base::create_abstract_interface_tc  (
    const char * id,
    const char * name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_abstract_interface_tc (
      id,
      name,
      ACE_TRY_ENV
    );

}

CORBA::TypeCode_ptr CORBA::TAO_CORBA_TypeCodeFactory_Smart_Proxy_Base::create_component_tc  (
    const char * id,
    const char * name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_component_tc (
      id,
      name,
      ACE_TRY_ENV
    );

}

CORBA::TypeCode_ptr CORBA::TAO_CORBA_TypeCodeFactory_Smart_Proxy_Base::create_home_tc  (
    const char * id,
    const char * name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->create_home_tc (
      id,
      name,
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class ACE_Singleton<CORBA::TAO_CORBA_TypeCodeFactory_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Singleton<CORBA::TAO_CORBA_TypeCodeFactory_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_CORBA_TypeCodeFactory[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5479), ACE_NTOHL (0x7065436f), ACE_NTOHL (0x64654661), ACE_NTOHL (0x63746f72), ACE_NTOHL (0x793a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/TypeCodeFactory:1.0
  16, ACE_NTOHL (0x54797065), ACE_NTOHL (0x436f6465), ACE_NTOHL (0x46616374), ACE_NTOHL (0x6f727900),  // name = TypeCodeFactory
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_TypeCodeFactory (CORBA::tk_objref, sizeof (_oc_CORBA_TypeCodeFactory), (char *) &_oc_CORBA_TypeCodeFactory, 0, sizeof (CORBA::TypeCodeFactory));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_TypeCodeFactory, &_tc_TAO_tc_CORBA_TypeCodeFactory)
TAO_NAMESPACE_END
void operator<<= (CORBA::Any &_tao_any, IR::DefinitionKind _tao_elem)
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_DefinitionKind,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::DefinitionKind &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_DefinitionKind, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

IR::Contained_ptr (*_TAO_collocation_IR_Contained_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::Contained_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_Contained, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::Contained::_duplicate (_tao_elem),
        IR::Contained::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::Contained_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::Contained::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_Contained, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::Contained::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_Contained,
          1,
          _tao_elem,
          IR::Contained::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::Contained::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::Contained::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::Contained,IR::Contained_var>;
  template class TAO_Object_Manager<IR::Contained,IR::Contained_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::Contained,IR::Contained_var>
#  pragma instantiate TAO_Object_Manager<IR::Contained,IR::Contained_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR::Contained::Description &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::Contained::_tc_Description,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::Contained::Description *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::Contained::_tc_Description,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::Contained::Description::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::Contained::Description *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::Contained::Description*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::Contained::Description *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::Contained::_tc_Description, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::Contained::Description*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::Contained::Description *tmp;
      ACE_NEW_RETURN (tmp, IR::Contained::Description, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::Contained::_tc_Description,
            1,
            ACE_static_cast (void *, tmp),
            IR::Contained::Description::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::InterfaceDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_InterfaceDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::InterfaceDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_InterfaceDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::InterfaceDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::InterfaceDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::InterfaceDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::InterfaceDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_InterfaceDefSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::InterfaceDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::InterfaceDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::InterfaceDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_InterfaceDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::InterfaceDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::ValueDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ValueDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::ValueDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ValueDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::ValueDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ValueDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::ValueDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ValueDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ValueDefSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::ValueDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::ValueDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::ValueDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ValueDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::ValueDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::ComponentDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ComponentDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::ComponentDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ComponentDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::ComponentDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ComponentDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::ComponentDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ComponentDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ComponentDefSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::ComponentDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::ComponentDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::ComponentDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ComponentDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::ComponentDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::ProvidesDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ProvidesDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::ProvidesDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ProvidesDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::ProvidesDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ProvidesDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::ProvidesDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ProvidesDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ProvidesDefSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::ProvidesDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::ProvidesDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::ProvidesDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ProvidesDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::ProvidesDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::UsesDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_UsesDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::UsesDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_UsesDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::UsesDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::UsesDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::UsesDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::UsesDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_UsesDefSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::UsesDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::UsesDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::UsesDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_UsesDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::UsesDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::HomeDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_HomeDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::HomeDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_HomeDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::HomeDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::HomeDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::HomeDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::HomeDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_HomeDefSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::HomeDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::HomeDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::HomeDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_HomeDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::HomeDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::EmitsDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_EmitsDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::EmitsDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_EmitsDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::EmitsDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::EmitsDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::EmitsDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::EmitsDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_EmitsDefSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::EmitsDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::EmitsDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::EmitsDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_EmitsDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::EmitsDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::PublishesDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_PublishesDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::PublishesDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_PublishesDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::PublishesDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::PublishesDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::PublishesDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::PublishesDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_PublishesDefSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::PublishesDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::PublishesDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::PublishesDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_PublishesDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::PublishesDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::ConsumesDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ConsumesDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::ConsumesDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ConsumesDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::ConsumesDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ConsumesDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::ConsumesDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ConsumesDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ConsumesDefSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::ConsumesDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::ConsumesDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::ConsumesDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ConsumesDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::ConsumesDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::FactoryDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_FactoryDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::FactoryDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_FactoryDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::FactoryDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::FactoryDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::FactoryDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::FactoryDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_FactoryDefSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::FactoryDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::FactoryDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::FactoryDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_FactoryDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::FactoryDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::FinderDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_FinderDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::FinderDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_FinderDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::FinderDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::FinderDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::FinderDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::FinderDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_FinderDefSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::FinderDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::FinderDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::FinderDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_FinderDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::FinderDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::ContainedSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ContainedSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::ContainedSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ContainedSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::ContainedSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ContainedSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::ContainedSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ContainedSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ContainedSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::ContainedSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::ContainedSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::ContainedSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ContainedSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::ContainedSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const IR::StructMember &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_StructMember,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::StructMember *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_StructMember,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::StructMember::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::StructMember *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::StructMember*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::StructMember *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_StructMember, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::StructMember*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::StructMember *tmp;
      ACE_NEW_RETURN (tmp, IR::StructMember, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_StructMember,
            1,
            ACE_static_cast (void *, tmp),
            IR::StructMember::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::StructMemberSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_StructMemberSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::StructMemberSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_StructMemberSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::StructMemberSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::StructMemberSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::StructMemberSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::StructMemberSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_StructMemberSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::StructMemberSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::StructMemberSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::StructMemberSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_StructMemberSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::StructMemberSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const IR::Initializer &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_Initializer,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::Initializer *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_Initializer,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::Initializer::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::Initializer *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::Initializer*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::Initializer *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_Initializer, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::Initializer*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::Initializer *tmp;
      ACE_NEW_RETURN (tmp, IR::Initializer, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_Initializer,
            1,
            ACE_static_cast (void *, tmp),
            IR::Initializer::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::InitializerSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_InitializerSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::InitializerSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_InitializerSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::InitializerSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::InitializerSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::InitializerSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::InitializerSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_InitializerSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::InitializerSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::InitializerSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::InitializerSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_InitializerSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::InitializerSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const IR::UnionMember &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_UnionMember,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::UnionMember *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_UnionMember,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::UnionMember::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::UnionMember *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::UnionMember*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::UnionMember *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_UnionMember, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::UnionMember*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::UnionMember *tmp;
      ACE_NEW_RETURN (tmp, IR::UnionMember, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_UnionMember,
            1,
            ACE_static_cast (void *, tmp),
            IR::UnionMember::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::UnionMemberSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_UnionMemberSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::UnionMemberSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_UnionMemberSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::UnionMemberSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::UnionMemberSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::UnionMemberSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::UnionMemberSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_UnionMemberSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::UnionMemberSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::UnionMemberSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::UnionMemberSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_UnionMemberSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::UnionMemberSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::EnumMemberSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_EnumMemberSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::EnumMemberSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_EnumMemberSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::EnumMemberSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::EnumMemberSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::EnumMemberSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::EnumMemberSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_EnumMemberSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::EnumMemberSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::EnumMemberSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::EnumMemberSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_EnumMemberSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::EnumMemberSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

IR::Container_ptr (*_TAO_collocation_IR_Container_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::Container_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_Container, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::Container::_duplicate (_tao_elem),
        IR::Container::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::Container_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::Container::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_Container, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::Container::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_Container,
          1,
          _tao_elem,
          IR::Container::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::Container::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::Container::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::Container,IR::Container_var>;
  template class TAO_Object_Manager<IR::Container,IR::Container_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::Container,IR::Container_var>
#  pragma instantiate TAO_Object_Manager<IR::Container,IR::Container_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR::Container::Description &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::Container::_tc_Description,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::Container::Description *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::Container::_tc_Description,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::Container::Description::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::Container::Description *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::Container::Description*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::Container::Description *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::Container::_tc_Description, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::Container::Description*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::Container::Description *tmp;
      ACE_NEW_RETURN (tmp, IR::Container::Description, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::Container::_tc_Description,
            1,
            ACE_static_cast (void *, tmp),
            IR::Container::Description::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::Container::DescriptionSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::Container::_tc_DescriptionSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::Container::DescriptionSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::Container::_tc_DescriptionSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::Container::DescriptionSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::Container::DescriptionSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::Container::DescriptionSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::Container::DescriptionSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::Container::_tc_DescriptionSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::Container::DescriptionSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::Container::DescriptionSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::Container::DescriptionSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::Container::_tc_DescriptionSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::Container::DescriptionSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

IR::IDLType_ptr (*_TAO_collocation_IR_IDLType_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::IDLType_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_IDLType, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::IDLType::_duplicate (_tao_elem),
        IR::IDLType::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::IDLType_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::IDLType::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_IDLType, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::IDLType::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_IDLType,
          1,
          _tao_elem,
          IR::IDLType::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::IDLType::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::IDLType::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::IDLType,IR::IDLType_var>;
  template class TAO_Object_Manager<IR::IDLType,IR::IDLType_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::IDLType,IR::IDLType_var>
#  pragma instantiate TAO_Object_Manager<IR::IDLType,IR::IDLType_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR::PrimitiveKind _tao_elem)
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_PrimitiveKind,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::PrimitiveKind &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_PrimitiveKind, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

IR::Repository_ptr (*_TAO_collocation_IR_Repository_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::Repository_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_Repository, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::Repository::_duplicate (_tao_elem),
        IR::Repository::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::Repository_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::Repository::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_Repository, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::Repository::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_Repository,
          1,
          _tao_elem,
          IR::Repository::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::Repository::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::Repository::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::Repository,IR::Repository_var>;
  template class TAO_Object_Manager<IR::Repository,IR::Repository_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::Repository,IR::Repository_var>
#  pragma instantiate TAO_Object_Manager<IR::Repository,IR::Repository_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

IR::ComponentRepository_ptr (*_TAO_collocation_IR_ComponentRepository_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::ComponentRepository_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ComponentRepository, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::ComponentRepository::_duplicate (_tao_elem),
        IR::ComponentRepository::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ComponentRepository_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::ComponentRepository::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ComponentRepository, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::ComponentRepository::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_ComponentRepository,
          1,
          _tao_elem,
          IR::ComponentRepository::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::ComponentRepository::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::ComponentRepository::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::ComponentRepository,IR::ComponentRepository_var>;
  template class TAO_Object_Manager<IR::ComponentRepository,IR::ComponentRepository_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::ComponentRepository,IR::ComponentRepository_var>
#  pragma instantiate TAO_Object_Manager<IR::ComponentRepository,IR::ComponentRepository_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

IR::ModuleDef_ptr (*_TAO_collocation_IR_ModuleDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::ModuleDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ModuleDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::ModuleDef::_duplicate (_tao_elem),
        IR::ModuleDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ModuleDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::ModuleDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ModuleDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::ModuleDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_ModuleDef,
          1,
          _tao_elem,
          IR::ModuleDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::ModuleDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::ModuleDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::ModuleDef,IR::ModuleDef_var>;
  template class TAO_Object_Manager<IR::ModuleDef,IR::ModuleDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::ModuleDef,IR::ModuleDef_var>
#  pragma instantiate TAO_Object_Manager<IR::ModuleDef,IR::ModuleDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR::ModuleDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ModuleDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::ModuleDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ModuleDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::ModuleDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ModuleDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::ModuleDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ModuleDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ModuleDescription, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::ModuleDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::ModuleDescription *tmp;
      ACE_NEW_RETURN (tmp, IR::ModuleDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ModuleDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR::ModuleDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

IR::ConstantDef_ptr (*_TAO_collocation_IR_ConstantDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::ConstantDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ConstantDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::ConstantDef::_duplicate (_tao_elem),
        IR::ConstantDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ConstantDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::ConstantDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ConstantDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::ConstantDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_ConstantDef,
          1,
          _tao_elem,
          IR::ConstantDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::ConstantDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::ConstantDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::ConstantDef,IR::ConstantDef_var>;
  template class TAO_Object_Manager<IR::ConstantDef,IR::ConstantDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::ConstantDef,IR::ConstantDef_var>
#  pragma instantiate TAO_Object_Manager<IR::ConstantDef,IR::ConstantDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR::ConstantDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ConstantDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::ConstantDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ConstantDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::ConstantDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ConstantDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::ConstantDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ConstantDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ConstantDescription, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::ConstantDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::ConstantDescription *tmp;
      ACE_NEW_RETURN (tmp, IR::ConstantDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ConstantDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR::ConstantDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

IR::TypedefDef_ptr (*_TAO_collocation_IR_TypedefDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::TypedefDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_TypedefDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::TypedefDef::_duplicate (_tao_elem),
        IR::TypedefDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::TypedefDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::TypedefDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_TypedefDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::TypedefDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_TypedefDef,
          1,
          _tao_elem,
          IR::TypedefDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::TypedefDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::TypedefDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::TypedefDef,IR::TypedefDef_var>;
  template class TAO_Object_Manager<IR::TypedefDef,IR::TypedefDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::TypedefDef,IR::TypedefDef_var>
#  pragma instantiate TAO_Object_Manager<IR::TypedefDef,IR::TypedefDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR::TypeDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_TypeDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::TypeDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_TypeDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::TypeDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::TypeDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::TypeDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::TypeDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_TypeDescription, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::TypeDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::TypeDescription *tmp;
      ACE_NEW_RETURN (tmp, IR::TypeDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_TypeDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR::TypeDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

IR::StructDef_ptr (*_TAO_collocation_IR_StructDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::StructDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_StructDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::StructDef::_duplicate (_tao_elem),
        IR::StructDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::StructDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::StructDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_StructDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::StructDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_StructDef,
          1,
          _tao_elem,
          IR::StructDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::StructDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::StructDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::StructDef,IR::StructDef_var>;
  template class TAO_Object_Manager<IR::StructDef,IR::StructDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::StructDef,IR::StructDef_var>
#  pragma instantiate TAO_Object_Manager<IR::StructDef,IR::StructDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

IR::UnionDef_ptr (*_TAO_collocation_IR_UnionDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::UnionDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_UnionDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::UnionDef::_duplicate (_tao_elem),
        IR::UnionDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::UnionDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::UnionDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_UnionDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::UnionDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_UnionDef,
          1,
          _tao_elem,
          IR::UnionDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::UnionDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::UnionDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::UnionDef,IR::UnionDef_var>;
  template class TAO_Object_Manager<IR::UnionDef,IR::UnionDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::UnionDef,IR::UnionDef_var>
#  pragma instantiate TAO_Object_Manager<IR::UnionDef,IR::UnionDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

IR::EnumDef_ptr (*_TAO_collocation_IR_EnumDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::EnumDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_EnumDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::EnumDef::_duplicate (_tao_elem),
        IR::EnumDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::EnumDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::EnumDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_EnumDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::EnumDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_EnumDef,
          1,
          _tao_elem,
          IR::EnumDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::EnumDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::EnumDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::EnumDef,IR::EnumDef_var>;
  template class TAO_Object_Manager<IR::EnumDef,IR::EnumDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::EnumDef,IR::EnumDef_var>
#  pragma instantiate TAO_Object_Manager<IR::EnumDef,IR::EnumDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

IR::AliasDef_ptr (*_TAO_collocation_IR_AliasDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::AliasDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_AliasDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::AliasDef::_duplicate (_tao_elem),
        IR::AliasDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::AliasDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::AliasDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_AliasDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::AliasDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_AliasDef,
          1,
          _tao_elem,
          IR::AliasDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::AliasDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::AliasDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::AliasDef,IR::AliasDef_var>;
  template class TAO_Object_Manager<IR::AliasDef,IR::AliasDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::AliasDef,IR::AliasDef_var>
#  pragma instantiate TAO_Object_Manager<IR::AliasDef,IR::AliasDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

IR::NativeDef_ptr (*_TAO_collocation_IR_NativeDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::NativeDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_NativeDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::NativeDef::_duplicate (_tao_elem),
        IR::NativeDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::NativeDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::NativeDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_NativeDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::NativeDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_NativeDef,
          1,
          _tao_elem,
          IR::NativeDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::NativeDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::NativeDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::NativeDef,IR::NativeDef_var>;
  template class TAO_Object_Manager<IR::NativeDef,IR::NativeDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::NativeDef,IR::NativeDef_var>
#  pragma instantiate TAO_Object_Manager<IR::NativeDef,IR::NativeDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

IR::PrimitiveDef_ptr (*_TAO_collocation_IR_PrimitiveDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::PrimitiveDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_PrimitiveDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::PrimitiveDef::_duplicate (_tao_elem),
        IR::PrimitiveDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::PrimitiveDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::PrimitiveDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_PrimitiveDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::PrimitiveDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_PrimitiveDef,
          1,
          _tao_elem,
          IR::PrimitiveDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::PrimitiveDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::PrimitiveDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::PrimitiveDef,IR::PrimitiveDef_var>;
  template class TAO_Object_Manager<IR::PrimitiveDef,IR::PrimitiveDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::PrimitiveDef,IR::PrimitiveDef_var>
#  pragma instantiate TAO_Object_Manager<IR::PrimitiveDef,IR::PrimitiveDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

IR::StringDef_ptr (*_TAO_collocation_IR_StringDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::StringDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_StringDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::StringDef::_duplicate (_tao_elem),
        IR::StringDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::StringDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::StringDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_StringDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::StringDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_StringDef,
          1,
          _tao_elem,
          IR::StringDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::StringDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::StringDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::StringDef,IR::StringDef_var>;
  template class TAO_Object_Manager<IR::StringDef,IR::StringDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::StringDef,IR::StringDef_var>
#  pragma instantiate TAO_Object_Manager<IR::StringDef,IR::StringDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

IR::WstringDef_ptr (*_TAO_collocation_IR_WstringDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::WstringDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_WstringDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::WstringDef::_duplicate (_tao_elem),
        IR::WstringDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::WstringDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::WstringDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_WstringDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::WstringDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_WstringDef,
          1,
          _tao_elem,
          IR::WstringDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::WstringDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::WstringDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::WstringDef,IR::WstringDef_var>;
  template class TAO_Object_Manager<IR::WstringDef,IR::WstringDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::WstringDef,IR::WstringDef_var>
#  pragma instantiate TAO_Object_Manager<IR::WstringDef,IR::WstringDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

IR::FixedDef_ptr (*_TAO_collocation_IR_FixedDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::FixedDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_FixedDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::FixedDef::_duplicate (_tao_elem),
        IR::FixedDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::FixedDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::FixedDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_FixedDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::FixedDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_FixedDef,
          1,
          _tao_elem,
          IR::FixedDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::FixedDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::FixedDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::FixedDef,IR::FixedDef_var>;
  template class TAO_Object_Manager<IR::FixedDef,IR::FixedDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::FixedDef,IR::FixedDef_var>
#  pragma instantiate TAO_Object_Manager<IR::FixedDef,IR::FixedDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

IR::SequenceDef_ptr (*_TAO_collocation_IR_SequenceDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::SequenceDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_SequenceDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::SequenceDef::_duplicate (_tao_elem),
        IR::SequenceDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::SequenceDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::SequenceDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_SequenceDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::SequenceDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_SequenceDef,
          1,
          _tao_elem,
          IR::SequenceDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::SequenceDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::SequenceDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::SequenceDef,IR::SequenceDef_var>;
  template class TAO_Object_Manager<IR::SequenceDef,IR::SequenceDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::SequenceDef,IR::SequenceDef_var>
#  pragma instantiate TAO_Object_Manager<IR::SequenceDef,IR::SequenceDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

IR::ArrayDef_ptr (*_TAO_collocation_IR_ArrayDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::ArrayDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ArrayDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::ArrayDef::_duplicate (_tao_elem),
        IR::ArrayDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ArrayDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::ArrayDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ArrayDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::ArrayDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_ArrayDef,
          1,
          _tao_elem,
          IR::ArrayDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::ArrayDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::ArrayDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::ArrayDef,IR::ArrayDef_var>;
  template class TAO_Object_Manager<IR::ArrayDef,IR::ArrayDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::ArrayDef,IR::ArrayDef_var>
#  pragma instantiate TAO_Object_Manager<IR::ArrayDef,IR::ArrayDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

IR::ExceptionDef_ptr (*_TAO_collocation_IR_ExceptionDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::ExceptionDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ExceptionDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::ExceptionDef::_duplicate (_tao_elem),
        IR::ExceptionDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ExceptionDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::ExceptionDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ExceptionDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::ExceptionDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_ExceptionDef,
          1,
          _tao_elem,
          IR::ExceptionDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::ExceptionDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::ExceptionDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::ExceptionDef,IR::ExceptionDef_var>;
  template class TAO_Object_Manager<IR::ExceptionDef,IR::ExceptionDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::ExceptionDef,IR::ExceptionDef_var>
#  pragma instantiate TAO_Object_Manager<IR::ExceptionDef,IR::ExceptionDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR::ExceptionDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ExceptionDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::ExceptionDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ExceptionDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::ExceptionDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ExceptionDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::ExceptionDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ExceptionDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ExceptionDescription, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::ExceptionDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::ExceptionDescription *tmp;
      ACE_NEW_RETURN (tmp, IR::ExceptionDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ExceptionDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR::ExceptionDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::ExceptionDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ExceptionDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::ExceptionDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ExceptionDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::ExceptionDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ExceptionDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::ExceptionDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ExceptionDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ExceptionDefSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::ExceptionDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::ExceptionDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::ExceptionDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ExceptionDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::ExceptionDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::ExcDescriptionSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ExcDescriptionSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::ExcDescriptionSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ExcDescriptionSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::ExcDescriptionSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ExcDescriptionSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::ExcDescriptionSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ExcDescriptionSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ExcDescriptionSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::ExcDescriptionSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::ExcDescriptionSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::ExcDescriptionSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ExcDescriptionSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::ExcDescriptionSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR::AttributeMode _tao_elem)
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_AttributeMode,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::AttributeMode &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_AttributeMode, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

IR::AttributeDef_ptr (*_TAO_collocation_IR_AttributeDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::AttributeDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_AttributeDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::AttributeDef::_duplicate (_tao_elem),
        IR::AttributeDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::AttributeDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::AttributeDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_AttributeDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::AttributeDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_AttributeDef,
          1,
          _tao_elem,
          IR::AttributeDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::AttributeDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::AttributeDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::AttributeDef,IR::AttributeDef_var>;
  template class TAO_Object_Manager<IR::AttributeDef,IR::AttributeDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::AttributeDef,IR::AttributeDef_var>
#  pragma instantiate TAO_Object_Manager<IR::AttributeDef,IR::AttributeDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR::AttributeDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_AttributeDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::AttributeDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_AttributeDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::AttributeDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::AttributeDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::AttributeDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::AttributeDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_AttributeDescription, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::AttributeDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::AttributeDescription *tmp;
      ACE_NEW_RETURN (tmp, IR::AttributeDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_AttributeDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR::AttributeDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR::OperationMode _tao_elem)
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_OperationMode,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::OperationMode &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_OperationMode, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR::ParameterMode _tao_elem)
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ParameterMode,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ParameterMode &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ParameterMode, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const IR::ParameterDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ParameterDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::ParameterDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ParameterDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::ParameterDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ParameterDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::ParameterDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ParameterDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ParameterDescription, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::ParameterDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::ParameterDescription *tmp;
      ACE_NEW_RETURN (tmp, IR::ParameterDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ParameterDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR::ParameterDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::ParDescriptionSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ParDescriptionSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::ParDescriptionSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ParDescriptionSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::ParDescriptionSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ParDescriptionSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::ParDescriptionSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ParDescriptionSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ParDescriptionSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::ParDescriptionSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::ParDescriptionSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::ParDescriptionSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ParDescriptionSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::ParDescriptionSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::ContextIdSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ContextIdSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::ContextIdSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ContextIdSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::ContextIdSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ContextIdSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::ContextIdSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ContextIdSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ContextIdSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::ContextIdSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::ContextIdSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::ContextIdSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ContextIdSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::ContextIdSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

IR::OperationDef_ptr (*_TAO_collocation_IR_OperationDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::OperationDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_OperationDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::OperationDef::_duplicate (_tao_elem),
        IR::OperationDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::OperationDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::OperationDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_OperationDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::OperationDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_OperationDef,
          1,
          _tao_elem,
          IR::OperationDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::OperationDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::OperationDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::OperationDef,IR::OperationDef_var>;
  template class TAO_Object_Manager<IR::OperationDef,IR::OperationDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::OperationDef,IR::OperationDef_var>
#  pragma instantiate TAO_Object_Manager<IR::OperationDef,IR::OperationDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR::OperationDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_OperationDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::OperationDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_OperationDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::OperationDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::OperationDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::OperationDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::OperationDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_OperationDescription, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::OperationDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::OperationDescription *tmp;
      ACE_NEW_RETURN (tmp, IR::OperationDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_OperationDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR::OperationDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::RepositoryIdSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_RepositoryIdSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::RepositoryIdSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_RepositoryIdSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::RepositoryIdSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::RepositoryIdSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::RepositoryIdSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::RepositoryIdSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_RepositoryIdSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::RepositoryIdSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::RepositoryIdSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::RepositoryIdSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_RepositoryIdSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::RepositoryIdSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::OpDescriptionSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_OpDescriptionSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::OpDescriptionSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_OpDescriptionSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::OpDescriptionSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::OpDescriptionSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::OpDescriptionSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::OpDescriptionSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_OpDescriptionSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::OpDescriptionSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::OpDescriptionSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::OpDescriptionSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_OpDescriptionSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::OpDescriptionSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::AttrDescriptionSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_AttrDescriptionSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::AttrDescriptionSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_AttrDescriptionSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::AttrDescriptionSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::AttrDescriptionSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::AttrDescriptionSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::AttrDescriptionSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_AttrDescriptionSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::AttrDescriptionSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::AttrDescriptionSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::AttrDescriptionSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_AttrDescriptionSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::AttrDescriptionSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

IR::InterfaceDef_ptr (*_TAO_collocation_IR_InterfaceDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::InterfaceDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_InterfaceDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::InterfaceDef::_duplicate (_tao_elem),
        IR::InterfaceDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::InterfaceDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::InterfaceDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_InterfaceDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::InterfaceDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_InterfaceDef,
          1,
          _tao_elem,
          IR::InterfaceDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::InterfaceDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::InterfaceDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::InterfaceDef,IR::InterfaceDef_var>;
  template class TAO_Object_Manager<IR::InterfaceDef,IR::InterfaceDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::InterfaceDef,IR::InterfaceDef_var>
#  pragma instantiate TAO_Object_Manager<IR::InterfaceDef,IR::InterfaceDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR::InterfaceDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_InterfaceDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::InterfaceDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_InterfaceDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::InterfaceDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::InterfaceDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::InterfaceDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::InterfaceDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_InterfaceDescription, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::InterfaceDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::InterfaceDescription *tmp;
      ACE_NEW_RETURN (tmp, IR::InterfaceDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_InterfaceDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR::InterfaceDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const IR::ValueMember &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ValueMember,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::ValueMember *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ValueMember,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::ValueMember::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ValueMember *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::ValueMember*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ValueMember *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ValueMember, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::ValueMember*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::ValueMember *tmp;
      ACE_NEW_RETURN (tmp, IR::ValueMember, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ValueMember,
            1,
            ACE_static_cast (void *, tmp),
            IR::ValueMember::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::ValueMemberSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ValueMemberSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::ValueMemberSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ValueMemberSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::ValueMemberSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ValueMemberSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::ValueMemberSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ValueMemberSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ValueMemberSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::ValueMemberSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::ValueMemberSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::ValueMemberSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ValueMemberSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::ValueMemberSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

IR::ValueMemberDef_ptr (*_TAO_collocation_IR_ValueMemberDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::ValueMemberDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ValueMemberDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::ValueMemberDef::_duplicate (_tao_elem),
        IR::ValueMemberDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ValueMemberDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::ValueMemberDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ValueMemberDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::ValueMemberDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_ValueMemberDef,
          1,
          _tao_elem,
          IR::ValueMemberDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::ValueMemberDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::ValueMemberDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::ValueMemberDef,IR::ValueMemberDef_var>;
  template class TAO_Object_Manager<IR::ValueMemberDef,IR::ValueMemberDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::ValueMemberDef,IR::ValueMemberDef_var>
#  pragma instantiate TAO_Object_Manager<IR::ValueMemberDef,IR::ValueMemberDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

IR::ValueDef_ptr (*_TAO_collocation_IR_ValueDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::ValueDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ValueDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::ValueDef::_duplicate (_tao_elem),
        IR::ValueDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ValueDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::ValueDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ValueDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::ValueDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_ValueDef,
          1,
          _tao_elem,
          IR::ValueDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::ValueDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::ValueDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::ValueDef,IR::ValueDef_var>;
  template class TAO_Object_Manager<IR::ValueDef,IR::ValueDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::ValueDef,IR::ValueDef_var>
#  pragma instantiate TAO_Object_Manager<IR::ValueDef,IR::ValueDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR::ValueDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ValueDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::ValueDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ValueDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::ValueDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ValueDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::ValueDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ValueDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ValueDescription, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::ValueDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::ValueDescription *tmp;
      ACE_NEW_RETURN (tmp, IR::ValueDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ValueDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR::ValueDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

IR::ValueBoxDef_ptr (*_TAO_collocation_IR_ValueBoxDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::ValueBoxDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ValueBoxDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::ValueBoxDef::_duplicate (_tao_elem),
        IR::ValueBoxDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ValueBoxDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::ValueBoxDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ValueBoxDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::ValueBoxDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_ValueBoxDef,
          1,
          _tao_elem,
          IR::ValueBoxDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::ValueBoxDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::ValueBoxDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::ValueBoxDef,IR::ValueBoxDef_var>;
  template class TAO_Object_Manager<IR::ValueBoxDef,IR::ValueBoxDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::ValueBoxDef,IR::ValueBoxDef_var>
#  pragma instantiate TAO_Object_Manager<IR::ValueBoxDef,IR::ValueBoxDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

IR::ProvidesDef_ptr (*_TAO_collocation_IR_ProvidesDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::ProvidesDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ProvidesDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::ProvidesDef::_duplicate (_tao_elem),
        IR::ProvidesDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ProvidesDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::ProvidesDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ProvidesDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::ProvidesDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_ProvidesDef,
          1,
          _tao_elem,
          IR::ProvidesDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::ProvidesDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::ProvidesDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::ProvidesDef,IR::ProvidesDef_var>;
  template class TAO_Object_Manager<IR::ProvidesDef,IR::ProvidesDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::ProvidesDef,IR::ProvidesDef_var>
#  pragma instantiate TAO_Object_Manager<IR::ProvidesDef,IR::ProvidesDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR::ProvidesDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ProvidesDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::ProvidesDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ProvidesDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::ProvidesDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ProvidesDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::ProvidesDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ProvidesDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ProvidesDescription, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::ProvidesDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::ProvidesDescription *tmp;
      ACE_NEW_RETURN (tmp, IR::ProvidesDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ProvidesDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR::ProvidesDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

IR::UsesDef_ptr (*_TAO_collocation_IR_UsesDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::UsesDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_UsesDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::UsesDef::_duplicate (_tao_elem),
        IR::UsesDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::UsesDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::UsesDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_UsesDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::UsesDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_UsesDef,
          1,
          _tao_elem,
          IR::UsesDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::UsesDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::UsesDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::UsesDef,IR::UsesDef_var>;
  template class TAO_Object_Manager<IR::UsesDef,IR::UsesDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::UsesDef,IR::UsesDef_var>
#  pragma instantiate TAO_Object_Manager<IR::UsesDef,IR::UsesDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR::UsesDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_UsesDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::UsesDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_UsesDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::UsesDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::UsesDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::UsesDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::UsesDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_UsesDescription, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::UsesDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::UsesDescription *tmp;
      ACE_NEW_RETURN (tmp, IR::UsesDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_UsesDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR::UsesDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::ProvidesDescSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ProvidesDescSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::ProvidesDescSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ProvidesDescSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::ProvidesDescSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ProvidesDescSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::ProvidesDescSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ProvidesDescSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ProvidesDescSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::ProvidesDescSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::ProvidesDescSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::ProvidesDescSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ProvidesDescSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::ProvidesDescSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::UsesDescSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_UsesDescSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::UsesDescSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_UsesDescSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::UsesDescSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::UsesDescSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::UsesDescSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::UsesDescSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_UsesDescSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::UsesDescSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::UsesDescSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::UsesDescSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_UsesDescSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::UsesDescSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

IR::EventDef_ptr (*_TAO_collocation_IR_EventDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::EventDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_EventDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::EventDef::_duplicate (_tao_elem),
        IR::EventDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::EventDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::EventDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_EventDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::EventDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_EventDef,
          1,
          _tao_elem,
          IR::EventDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::EventDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::EventDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::EventDef,IR::EventDef_var>;
  template class TAO_Object_Manager<IR::EventDef,IR::EventDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::EventDef,IR::EventDef_var>
#  pragma instantiate TAO_Object_Manager<IR::EventDef,IR::EventDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR::EventDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_EventDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::EventDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_EventDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::EventDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::EventDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::EventDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::EventDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_EventDescription, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::EventDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::EventDescription *tmp;
      ACE_NEW_RETURN (tmp, IR::EventDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_EventDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR::EventDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

IR::EmitsDef_ptr (*_TAO_collocation_IR_EmitsDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::EmitsDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_EmitsDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::EmitsDef::_duplicate (_tao_elem),
        IR::EmitsDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::EmitsDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::EmitsDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_EmitsDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::EmitsDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_EmitsDef,
          1,
          _tao_elem,
          IR::EmitsDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::EmitsDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::EmitsDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::EmitsDef,IR::EmitsDef_var>;
  template class TAO_Object_Manager<IR::EmitsDef,IR::EmitsDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::EmitsDef,IR::EmitsDef_var>
#  pragma instantiate TAO_Object_Manager<IR::EmitsDef,IR::EmitsDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

IR::PublishesDef_ptr (*_TAO_collocation_IR_PublishesDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::PublishesDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_PublishesDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::PublishesDef::_duplicate (_tao_elem),
        IR::PublishesDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::PublishesDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::PublishesDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_PublishesDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::PublishesDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_PublishesDef,
          1,
          _tao_elem,
          IR::PublishesDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::PublishesDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::PublishesDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::PublishesDef,IR::PublishesDef_var>;
  template class TAO_Object_Manager<IR::PublishesDef,IR::PublishesDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::PublishesDef,IR::PublishesDef_var>
#  pragma instantiate TAO_Object_Manager<IR::PublishesDef,IR::PublishesDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

IR::ConsumesDef_ptr (*_TAO_collocation_IR_ConsumesDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::ConsumesDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ConsumesDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::ConsumesDef::_duplicate (_tao_elem),
        IR::ConsumesDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ConsumesDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::ConsumesDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ConsumesDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::ConsumesDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_ConsumesDef,
          1,
          _tao_elem,
          IR::ConsumesDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::ConsumesDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::ConsumesDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::ConsumesDef,IR::ConsumesDef_var>;
  template class TAO_Object_Manager<IR::ConsumesDef,IR::ConsumesDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::ConsumesDef,IR::ConsumesDef_var>
#  pragma instantiate TAO_Object_Manager<IR::ConsumesDef,IR::ConsumesDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

IR::ComponentDef_ptr (*_TAO_collocation_IR_ComponentDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::ComponentDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ComponentDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::ComponentDef::_duplicate (_tao_elem),
        IR::ComponentDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ComponentDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::ComponentDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ComponentDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::ComponentDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_ComponentDef,
          1,
          _tao_elem,
          IR::ComponentDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::ComponentDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::ComponentDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::ComponentDef,IR::ComponentDef_var>;
  template class TAO_Object_Manager<IR::ComponentDef,IR::ComponentDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::ComponentDef,IR::ComponentDef_var>
#  pragma instantiate TAO_Object_Manager<IR::ComponentDef,IR::ComponentDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR::ComponentDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ComponentDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::ComponentDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ComponentDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::ComponentDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ComponentDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::ComponentDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ComponentDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ComponentDescription, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::ComponentDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::ComponentDescription *tmp;
      ACE_NEW_RETURN (tmp, IR::ComponentDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ComponentDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR::ComponentDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

IR::PrimaryKeyDef_ptr (*_TAO_collocation_IR_PrimaryKeyDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::PrimaryKeyDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_PrimaryKeyDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::PrimaryKeyDef::_duplicate (_tao_elem),
        IR::PrimaryKeyDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::PrimaryKeyDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::PrimaryKeyDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_PrimaryKeyDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::PrimaryKeyDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_PrimaryKeyDef,
          1,
          _tao_elem,
          IR::PrimaryKeyDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::PrimaryKeyDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::PrimaryKeyDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::PrimaryKeyDef,IR::PrimaryKeyDef_var>;
  template class TAO_Object_Manager<IR::PrimaryKeyDef,IR::PrimaryKeyDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::PrimaryKeyDef,IR::PrimaryKeyDef_var>
#  pragma instantiate TAO_Object_Manager<IR::PrimaryKeyDef,IR::PrimaryKeyDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR::PrimaryKeyDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_PrimaryKeyDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::PrimaryKeyDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_PrimaryKeyDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::PrimaryKeyDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::PrimaryKeyDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::PrimaryKeyDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::PrimaryKeyDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_PrimaryKeyDescription, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::PrimaryKeyDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::PrimaryKeyDescription *tmp;
      ACE_NEW_RETURN (tmp, IR::PrimaryKeyDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_PrimaryKeyDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR::PrimaryKeyDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

IR::FactoryDef_ptr (*_TAO_collocation_IR_FactoryDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::FactoryDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_FactoryDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::FactoryDef::_duplicate (_tao_elem),
        IR::FactoryDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::FactoryDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::FactoryDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_FactoryDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::FactoryDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_FactoryDef,
          1,
          _tao_elem,
          IR::FactoryDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::FactoryDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::FactoryDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::FactoryDef,IR::FactoryDef_var>;
  template class TAO_Object_Manager<IR::FactoryDef,IR::FactoryDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::FactoryDef,IR::FactoryDef_var>
#  pragma instantiate TAO_Object_Manager<IR::FactoryDef,IR::FactoryDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

IR::FinderDef_ptr (*_TAO_collocation_IR_FinderDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::FinderDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_FinderDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::FinderDef::_duplicate (_tao_elem),
        IR::FinderDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::FinderDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::FinderDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_FinderDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::FinderDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_FinderDef,
          1,
          _tao_elem,
          IR::FinderDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::FinderDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::FinderDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::FinderDef,IR::FinderDef_var>;
  template class TAO_Object_Manager<IR::FinderDef,IR::FinderDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::FinderDef,IR::FinderDef_var>
#  pragma instantiate TAO_Object_Manager<IR::FinderDef,IR::FinderDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

IR::HomeDef_ptr (*_TAO_collocation_IR_HomeDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, IR::HomeDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_HomeDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::HomeDef::_duplicate (_tao_elem),
        IR::HomeDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::HomeDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::HomeDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_HomeDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = IR::HomeDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_HomeDef,
          1,
          _tao_elem,
          IR::HomeDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::HomeDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::HomeDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<IR::HomeDef,IR::HomeDef_var>;
  template class TAO_Object_Manager<IR::HomeDef,IR::HomeDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<IR::HomeDef,IR::HomeDef_var>
#  pragma instantiate TAO_Object_Manager<IR::HomeDef,IR::HomeDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR::HomeDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_HomeDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::HomeDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_HomeDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::HomeDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::HomeDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::HomeDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::HomeDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_HomeDescription, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::HomeDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::HomeDescription *tmp;
      ACE_NEW_RETURN (tmp, IR::HomeDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_HomeDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR::HomeDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::IRObject_ptr (*_TAO_collocation_CORBA_IRObject_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::IRObject_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_IRObject, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        CORBA::IRObject::_duplicate (_tao_elem),
        CORBA::IRObject::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::IRObject_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::IRObject::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_IRObject, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = CORBA::IRObject::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_IRObject,
          1,
          _tao_elem,
          CORBA::IRObject::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA::IRObject::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::IRObject::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<CORBA::IRObject,CORBA::IRObject_var>;
  template class TAO_Object_Manager<CORBA::IRObject,CORBA::IRObject_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::IRObject,CORBA::IRObject_var>
#  pragma instantiate TAO_Object_Manager<CORBA::IRObject,CORBA::IRObject_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::TypeCodeFactory_ptr (*_TAO_collocation_CORBA_TypeCodeFactory_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::TypeCodeFactory_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_TypeCodeFactory, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        CORBA::TypeCodeFactory::_duplicate (_tao_elem),
        CORBA::TypeCodeFactory::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::TypeCodeFactory_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::TypeCodeFactory::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_TypeCodeFactory, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = CORBA::TypeCodeFactory::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_TypeCodeFactory,
          1,
          _tao_elem,
          CORBA::TypeCodeFactory::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA::TypeCodeFactory::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::TypeCodeFactory::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<CORBA::TypeCodeFactory,CORBA::TypeCodeFactory_var>;
  template class TAO_Object_Manager<CORBA::TypeCodeFactory,CORBA::TypeCodeFactory_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::TypeCodeFactory,CORBA::TypeCodeFactory_var>
#  pragma instantiate TAO_Object_Manager<CORBA::TypeCodeFactory,CORBA::TypeCodeFactory_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::InterfaceDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::InterfaceDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::ValueDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::ValueDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::ComponentDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::ComponentDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::ProvidesDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::ProvidesDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::UsesDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::UsesDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::HomeDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::HomeDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::EmitsDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::EmitsDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::PublishesDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::PublishesDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::ConsumesDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::ConsumesDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::FactoryDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::FactoryDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::FinderDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::FinderDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::ContainedSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::ContainedSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::StructMemberSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::StructMemberSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::InitializerSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::InitializerSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::UnionMemberSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::UnionMemberSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::EnumMemberSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::EnumMemberSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::Container::DescriptionSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::Container::DescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::ExceptionDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::ExceptionDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::ExcDescriptionSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::ExcDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::ParDescriptionSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::ParDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::ContextIdSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::ContextIdSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::RepositoryIdSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::RepositoryIdSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::OpDescriptionSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::OpDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::AttrDescriptionSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::AttrDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::ValueMemberSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::ValueMemberSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::ProvidesDescSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::ProvidesDescSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::UsesDescSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::UsesDescSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

#endif /* TAO_HAS_INTERFACE_REPOSITORY == 1 */
