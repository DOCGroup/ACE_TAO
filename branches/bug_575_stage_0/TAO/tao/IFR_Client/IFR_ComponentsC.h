// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#ifndef _TAO_IDL_IFR_COMPONENTSC_H_
#define _TAO_IDL_IFR_COMPONENTSC_H_

#include "ace/pre.h"
#include "ifr_client_export.h"

#if !defined (ACE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */

#include "IFR_ExtendedC.h"

#if defined (TAO_EXPORT_MACRO)
#undef TAO_EXPORT_MACRO
#endif
#define TAO_EXPORT_MACRO TAO_IFR_Client_Export

#if defined (TAO_EXPORT_NESTED_CLASSES)
#  if defined (TAO_EXPORT_NESTED_MACRO)
#    undef TAO_EXPORT_NESTED_MACRO
#  endif /* defined (TAO_EXPORT_NESTED_MACRO) */
#  define TAO_EXPORT_NESTED_MACRO TAO_IFR_Client_Export
#endif /* TAO_EXPORT_NESTED_CLASSES */

#if defined(_MSC_VER)
#if (_MSC_VER >= 1200)
#pragma warning(push)
#endif /* _MSC_VER >= 1200 */
#pragma warning(disable:4250)
#endif /* _MSC_VER */

#if defined (__BORLANDC__)
#pragma option push -w-rvl -w-rch -w-ccc -w-inl
#endif /* __BORLANDC__ */

TAO_NAMESPACE  IR
{
  typedef char * Identifier;
  typedef CORBA::String_var Identifier_var;
  typedef CORBA::String_out Identifier_out;
  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Identifier;
  
  typedef char * ScopedName;
  typedef CORBA::String_var ScopedName_var;
  typedef CORBA::String_out ScopedName_out;
  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ScopedName;
  
  typedef char * RepositoryId;
  typedef CORBA::String_var RepositoryId_var;
  typedef CORBA::String_out RepositoryId_out;
  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_RepositoryId;
  
  
#if !defined (_IR_REPOSITORYIDSEQ_CH_)
#define _IR_REPOSITORYIDSEQ_CH_
  
  class RepositoryIdSeq;
  class RepositoryIdSeq_var;
  
  // *************************************************************
  // RepositoryIdSeq
  // *************************************************************
  
  class TAO_IFR_Client_Export RepositoryIdSeq : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  {
  public:
    RepositoryIdSeq (void); // default ctor
    RepositoryIdSeq (CORBA::ULong max); // uses max size
    RepositoryIdSeq (
        CORBA::ULong max, 
        CORBA::ULong length, 
        char * *buffer, 
        CORBA::Boolean release = 0
      );
    RepositoryIdSeq (const RepositoryIdSeq &); // copy ctor
    ~RepositoryIdSeq (void);
    static void _tao_any_destructor (void*);
    
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef RepositoryIdSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */
    
    
  };
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_REPOSITORYIDSEQ___VAR_CH_)
#define _IR_REPOSITORYIDSEQ___VAR_CH_
  
  // *************************************************************
  // class IR::RepositoryIdSeq_var
  // *************************************************************
  
  class TAO_IFR_Client_Export RepositoryIdSeq_var
  {
  public:
    RepositoryIdSeq_var (void);
    RepositoryIdSeq_var (RepositoryIdSeq *);
    RepositoryIdSeq_var (const RepositoryIdSeq_var &);
    ~RepositoryIdSeq_var (void);
    
    RepositoryIdSeq_var &operator= (RepositoryIdSeq *);
    RepositoryIdSeq_var &operator= (const RepositoryIdSeq_var &);
    RepositoryIdSeq *operator-> (void);
    const RepositoryIdSeq *operator-> (void) const;
    
    operator const RepositoryIdSeq &() const;
    operator RepositoryIdSeq &();
    operator RepositoryIdSeq &() const;
    operator RepositoryIdSeq *&(); // variable-size base types only
    
    TAO_SeqElem_String_Manager operator[] (CORBA::ULong index);
    
    // in, inout, out, _retn 
    const RepositoryIdSeq &in (void) const;
    RepositoryIdSeq &inout (void);
    RepositoryIdSeq *&out (void);
    RepositoryIdSeq *_retn (void);
    RepositoryIdSeq *ptr (void) const;
  
  private:
    RepositoryIdSeq *ptr_;
  };
  
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_REPOSITORYIDSEQ___OUT_CH_)
#define _IR_REPOSITORYIDSEQ___OUT_CH_
  
  class TAO_IFR_Client_Export RepositoryIdSeq_out
  {
  public:
    RepositoryIdSeq_out (RepositoryIdSeq *&);
    RepositoryIdSeq_out (RepositoryIdSeq_var &);
    RepositoryIdSeq_out (const RepositoryIdSeq_out &);
    RepositoryIdSeq_out &operator= (const RepositoryIdSeq_out &);
    RepositoryIdSeq_out &operator= (RepositoryIdSeq *);
    operator RepositoryIdSeq *&();
    RepositoryIdSeq *&ptr (void);
    RepositoryIdSeq *operator-> (void);
    TAO_SeqElem_String_Manager operator[] (CORBA::ULong index);
  
  private:
    RepositoryIdSeq *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const RepositoryIdSeq_var &);
  };
  
  
#endif /* end #if !defined */
  
  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_RepositoryIdSeq;
  
  typedef char * VersionSpec;
  typedef CORBA::String_var VersionSpec_var;
  typedef CORBA::String_out VersionSpec_out;
  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_VersionSpec;
  
  class ComponentDef;
  
#if !defined (_IR_COMPONENTDEF___PTR_CH_)
#define _IR_COMPONENTDEF___PTR_CH_
  
  typedef ComponentDef *ComponentDef_ptr;
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_COMPONENTDEF___VAR_CH_)
#define _IR_COMPONENTDEF___VAR_CH_
  
  class TAO_IFR_Client_Export ComponentDef_var : public TAO_Base_var
  {
  public:
    ComponentDef_var (void); // default constructor
    ComponentDef_var (ComponentDef_ptr p) : ptr_ (p) {} 
    ComponentDef_var (const ComponentDef_var &); // copy constructor
    ~ComponentDef_var (void); // destructor
    
    ComponentDef_var &operator= (ComponentDef_ptr);
    ComponentDef_var &operator= (const ComponentDef_var &);
    ComponentDef_ptr operator-> (void) const;
    
    operator const ComponentDef_ptr &() const;
    operator ComponentDef_ptr &();
    // in, inout, out, _retn 
    ComponentDef_ptr in (void) const;
    ComponentDef_ptr &inout (void);
    ComponentDef_ptr &out (void);
    ComponentDef_ptr _retn (void);
    ComponentDef_ptr ptr (void) const;
    
    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static ComponentDef_ptr duplicate (ComponentDef_ptr);
    static void release (ComponentDef_ptr);
    static ComponentDef_ptr nil (void);
    static ComponentDef_ptr narrow (
        CORBA::Object *,
        CORBA::Environment &
      );
    static CORBA::Object * upcast (void *);
  
  private:
    ComponentDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    ComponentDef_var (const TAO_Base_var &rhs);
    ComponentDef_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */
  
  
#if !defined (_IR_COMPONENTDEF___OUT_CH_)
#define _IR_COMPONENTDEF___OUT_CH_
  
  class TAO_IFR_Client_Export ComponentDef_out
  {
  public:
    ComponentDef_out (ComponentDef_ptr &);
    ComponentDef_out (ComponentDef_var &);
    ComponentDef_out (const ComponentDef_out &);
    ComponentDef_out &operator= (const ComponentDef_out &);
    ComponentDef_out &operator= (const ComponentDef_var &);
    ComponentDef_out &operator= (ComponentDef_ptr);
    operator ComponentDef_ptr &();
    ComponentDef_ptr &ptr (void);
    ComponentDef_ptr operator-> (void);
  
  private:
    ComponentDef_ptr &ptr_;
  };
  
  
#endif /* end #if !defined */
  
  
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_COMPONENTDEFSEQ_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_COMPONENTDEFSEQ_CH_
  
  class _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq
    : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.
    _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq (
        CORBA::ULong maximum,
        CORBA::ULong length,
        ComponentDef* *value,
        CORBA::Boolean release = 0
      );
    _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq (
        const _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq &rhs
      );
    _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq &operator= (
        const _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq &rhs
      );
    virtual ~_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq (void);
    
    // = Accessors.
    TAO_Object_Manager<IR::ComponentDef,IR::ComponentDef_var> operator[] (CORBA::ULong index) const;
    
    // = Static operations.
    static ComponentDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (ComponentDef **buffer);
    
    // Implement the TAO_Base_Sequence methods (see Sequence.h)
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    ComponentDef* *get_buffer (CORBA::Boolean orphan = 0);
    const ComponentDef* *get_buffer (void) const;
    virtual void _shrink_buffer (
        CORBA::ULong nl,
        CORBA::ULong ol
      );
    
    virtual void _downcast (
        void* target,
        CORBA_Object *src,
        CORBA_Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      );
    virtual CORBA_Object* _upcast (void *src) const;
  };
  
#endif /* end #if !defined */
  
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  
#if !defined (_IR_COMPONENTDEFSEQ_CH_)
#define _IR_COMPONENTDEFSEQ_CH_
  
  class ComponentDefSeq;
  class ComponentDefSeq_var;
  
  // *************************************************************
  // ComponentDefSeq
  // *************************************************************
  
  class TAO_IFR_Client_Export ComponentDefSeq : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<ComponentDef,ComponentDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  {
  public:
    ComponentDefSeq (void); // default ctor
    ComponentDefSeq (CORBA::ULong max); // uses max size
    ComponentDefSeq (
        CORBA::ULong max, 
        CORBA::ULong length, 
        ComponentDef_ptr *buffer, 
        CORBA::Boolean release = 0
      );
    ComponentDefSeq (const ComponentDefSeq &); // copy ctor
    ~ComponentDefSeq (void);
    static void _tao_any_destructor (void*);
    
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef ComponentDefSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */
    
    
  };
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_COMPONENTDEFSEQ___VAR_CH_)
#define _IR_COMPONENTDEFSEQ___VAR_CH_
  
  // *************************************************************
  // class IR::ComponentDefSeq_var
  // *************************************************************
  
  class TAO_IFR_Client_Export ComponentDefSeq_var
  {
  public:
    ComponentDefSeq_var (void);
    ComponentDefSeq_var (ComponentDefSeq *);
    ComponentDefSeq_var (const ComponentDefSeq_var &);
    ~ComponentDefSeq_var (void);
    
    ComponentDefSeq_var &operator= (ComponentDefSeq *);
    ComponentDefSeq_var &operator= (const ComponentDefSeq_var &);
    ComponentDefSeq *operator-> (void);
    const ComponentDefSeq *operator-> (void) const;
    
    operator const ComponentDefSeq &() const;
    operator ComponentDefSeq &();
    operator ComponentDefSeq &() const;
    operator ComponentDefSeq *&(); // variable-size base types only
    
    TAO_Object_Manager<ComponentDef, ComponentDef_var> operator[] (CORBA::ULong index);
    
    // in, inout, out, _retn 
    const ComponentDefSeq &in (void) const;
    ComponentDefSeq &inout (void);
    ComponentDefSeq *&out (void);
    ComponentDefSeq *_retn (void);
    ComponentDefSeq *ptr (void) const;
  
  private:
    ComponentDefSeq *ptr_;
  };
  
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_COMPONENTDEFSEQ___OUT_CH_)
#define _IR_COMPONENTDEFSEQ___OUT_CH_
  
  class TAO_IFR_Client_Export ComponentDefSeq_out
  {
  public:
    ComponentDefSeq_out (ComponentDefSeq *&);
    ComponentDefSeq_out (ComponentDefSeq_var &);
    ComponentDefSeq_out (const ComponentDefSeq_out &);
    ComponentDefSeq_out &operator= (const ComponentDefSeq_out &);
    ComponentDefSeq_out &operator= (ComponentDefSeq *);
    operator ComponentDefSeq *&();
    ComponentDefSeq *&ptr (void);
    ComponentDefSeq *operator-> (void);
    TAO_Object_Manager<ComponentDef, ComponentDef_var> operator[] (CORBA::ULong index);
  
  private:
    ComponentDefSeq *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const ComponentDefSeq_var &);
  };
  
  
#endif /* end #if !defined */
  
  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ComponentDefSeq;
  
  class ProvidesDef;
  
#if !defined (_IR_PROVIDESDEF___PTR_CH_)
#define _IR_PROVIDESDEF___PTR_CH_
  
  typedef ProvidesDef *ProvidesDef_ptr;
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_PROVIDESDEF___VAR_CH_)
#define _IR_PROVIDESDEF___VAR_CH_
  
  class TAO_IFR_Client_Export ProvidesDef_var : public TAO_Base_var
  {
  public:
    ProvidesDef_var (void); // default constructor
    ProvidesDef_var (ProvidesDef_ptr p) : ptr_ (p) {} 
    ProvidesDef_var (const ProvidesDef_var &); // copy constructor
    ~ProvidesDef_var (void); // destructor
    
    ProvidesDef_var &operator= (ProvidesDef_ptr);
    ProvidesDef_var &operator= (const ProvidesDef_var &);
    ProvidesDef_ptr operator-> (void) const;
    
    operator const ProvidesDef_ptr &() const;
    operator ProvidesDef_ptr &();
    // in, inout, out, _retn 
    ProvidesDef_ptr in (void) const;
    ProvidesDef_ptr &inout (void);
    ProvidesDef_ptr &out (void);
    ProvidesDef_ptr _retn (void);
    ProvidesDef_ptr ptr (void) const;
    
    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static ProvidesDef_ptr duplicate (ProvidesDef_ptr);
    static void release (ProvidesDef_ptr);
    static ProvidesDef_ptr nil (void);
    static ProvidesDef_ptr narrow (
        CORBA::Object *,
        CORBA::Environment &
      );
    static CORBA::Object * upcast (void *);
  
  private:
    ProvidesDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    ProvidesDef_var (const TAO_Base_var &rhs);
    ProvidesDef_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */
  
  
#if !defined (_IR_PROVIDESDEF___OUT_CH_)
#define _IR_PROVIDESDEF___OUT_CH_
  
  class TAO_IFR_Client_Export ProvidesDef_out
  {
  public:
    ProvidesDef_out (ProvidesDef_ptr &);
    ProvidesDef_out (ProvidesDef_var &);
    ProvidesDef_out (const ProvidesDef_out &);
    ProvidesDef_out &operator= (const ProvidesDef_out &);
    ProvidesDef_out &operator= (const ProvidesDef_var &);
    ProvidesDef_out &operator= (ProvidesDef_ptr);
    operator ProvidesDef_ptr &();
    ProvidesDef_ptr &ptr (void);
    ProvidesDef_ptr operator-> (void);
  
  private:
    ProvidesDef_ptr &ptr_;
  };
  
  
#endif /* end #if !defined */
  
  
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_PROVIDESDEFSEQ_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_PROVIDESDEFSEQ_CH_
  
  class _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq
    : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.
    _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq (
        CORBA::ULong maximum,
        CORBA::ULong length,
        ProvidesDef* *value,
        CORBA::Boolean release = 0
      );
    _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq (
        const _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq &rhs
      );
    _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq &operator= (
        const _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq &rhs
      );
    virtual ~_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq (void);
    
    // = Accessors.
    TAO_Object_Manager<IR::ProvidesDef,IR::ProvidesDef_var> operator[] (CORBA::ULong index) const;
    
    // = Static operations.
    static ProvidesDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (ProvidesDef **buffer);
    
    // Implement the TAO_Base_Sequence methods (see Sequence.h)
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    ProvidesDef* *get_buffer (CORBA::Boolean orphan = 0);
    const ProvidesDef* *get_buffer (void) const;
    virtual void _shrink_buffer (
        CORBA::ULong nl,
        CORBA::ULong ol
      );
    
    virtual void _downcast (
        void* target,
        CORBA_Object *src,
        CORBA_Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      );
    virtual CORBA_Object* _upcast (void *src) const;
  };
  
#endif /* end #if !defined */
  
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  
#if !defined (_IR_PROVIDESDEFSEQ_CH_)
#define _IR_PROVIDESDEFSEQ_CH_
  
  class ProvidesDefSeq;
  class ProvidesDefSeq_var;
  
  // *************************************************************
  // ProvidesDefSeq
  // *************************************************************
  
  class TAO_IFR_Client_Export ProvidesDefSeq : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<ProvidesDef,ProvidesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  {
  public:
    ProvidesDefSeq (void); // default ctor
    ProvidesDefSeq (CORBA::ULong max); // uses max size
    ProvidesDefSeq (
        CORBA::ULong max, 
        CORBA::ULong length, 
        ProvidesDef_ptr *buffer, 
        CORBA::Boolean release = 0
      );
    ProvidesDefSeq (const ProvidesDefSeq &); // copy ctor
    ~ProvidesDefSeq (void);
    static void _tao_any_destructor (void*);
    
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef ProvidesDefSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */
    
    
  };
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_PROVIDESDEFSEQ___VAR_CH_)
#define _IR_PROVIDESDEFSEQ___VAR_CH_
  
  // *************************************************************
  // class IR::ProvidesDefSeq_var
  // *************************************************************
  
  class TAO_IFR_Client_Export ProvidesDefSeq_var
  {
  public:
    ProvidesDefSeq_var (void);
    ProvidesDefSeq_var (ProvidesDefSeq *);
    ProvidesDefSeq_var (const ProvidesDefSeq_var &);
    ~ProvidesDefSeq_var (void);
    
    ProvidesDefSeq_var &operator= (ProvidesDefSeq *);
    ProvidesDefSeq_var &operator= (const ProvidesDefSeq_var &);
    ProvidesDefSeq *operator-> (void);
    const ProvidesDefSeq *operator-> (void) const;
    
    operator const ProvidesDefSeq &() const;
    operator ProvidesDefSeq &();
    operator ProvidesDefSeq &() const;
    operator ProvidesDefSeq *&(); // variable-size base types only
    
    TAO_Object_Manager<ProvidesDef, ProvidesDef_var> operator[] (CORBA::ULong index);
    
    // in, inout, out, _retn 
    const ProvidesDefSeq &in (void) const;
    ProvidesDefSeq &inout (void);
    ProvidesDefSeq *&out (void);
    ProvidesDefSeq *_retn (void);
    ProvidesDefSeq *ptr (void) const;
  
  private:
    ProvidesDefSeq *ptr_;
  };
  
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_PROVIDESDEFSEQ___OUT_CH_)
#define _IR_PROVIDESDEFSEQ___OUT_CH_
  
  class TAO_IFR_Client_Export ProvidesDefSeq_out
  {
  public:
    ProvidesDefSeq_out (ProvidesDefSeq *&);
    ProvidesDefSeq_out (ProvidesDefSeq_var &);
    ProvidesDefSeq_out (const ProvidesDefSeq_out &);
    ProvidesDefSeq_out &operator= (const ProvidesDefSeq_out &);
    ProvidesDefSeq_out &operator= (ProvidesDefSeq *);
    operator ProvidesDefSeq *&();
    ProvidesDefSeq *&ptr (void);
    ProvidesDefSeq *operator-> (void);
    TAO_Object_Manager<ProvidesDef, ProvidesDef_var> operator[] (CORBA::ULong index);
  
  private:
    ProvidesDefSeq *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const ProvidesDefSeq_var &);
  };
  
  
#endif /* end #if !defined */
  
  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ProvidesDefSeq;
  
  class UsesDef;
  
#if !defined (_IR_USESDEF___PTR_CH_)
#define _IR_USESDEF___PTR_CH_
  
  typedef UsesDef *UsesDef_ptr;
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_USESDEF___VAR_CH_)
#define _IR_USESDEF___VAR_CH_
  
  class TAO_IFR_Client_Export UsesDef_var : public TAO_Base_var
  {
  public:
    UsesDef_var (void); // default constructor
    UsesDef_var (UsesDef_ptr p) : ptr_ (p) {} 
    UsesDef_var (const UsesDef_var &); // copy constructor
    ~UsesDef_var (void); // destructor
    
    UsesDef_var &operator= (UsesDef_ptr);
    UsesDef_var &operator= (const UsesDef_var &);
    UsesDef_ptr operator-> (void) const;
    
    operator const UsesDef_ptr &() const;
    operator UsesDef_ptr &();
    // in, inout, out, _retn 
    UsesDef_ptr in (void) const;
    UsesDef_ptr &inout (void);
    UsesDef_ptr &out (void);
    UsesDef_ptr _retn (void);
    UsesDef_ptr ptr (void) const;
    
    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static UsesDef_ptr duplicate (UsesDef_ptr);
    static void release (UsesDef_ptr);
    static UsesDef_ptr nil (void);
    static UsesDef_ptr narrow (
        CORBA::Object *,
        CORBA::Environment &
      );
    static CORBA::Object * upcast (void *);
  
  private:
    UsesDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    UsesDef_var (const TAO_Base_var &rhs);
    UsesDef_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */
  
  
#if !defined (_IR_USESDEF___OUT_CH_)
#define _IR_USESDEF___OUT_CH_
  
  class TAO_IFR_Client_Export UsesDef_out
  {
  public:
    UsesDef_out (UsesDef_ptr &);
    UsesDef_out (UsesDef_var &);
    UsesDef_out (const UsesDef_out &);
    UsesDef_out &operator= (const UsesDef_out &);
    UsesDef_out &operator= (const UsesDef_var &);
    UsesDef_out &operator= (UsesDef_ptr);
    operator UsesDef_ptr &();
    UsesDef_ptr &ptr (void);
    UsesDef_ptr operator-> (void);
  
  private:
    UsesDef_ptr &ptr_;
  };
  
  
#endif /* end #if !defined */
  
  
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_USESDEFSEQ_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_USESDEFSEQ_CH_
  
  class _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq
    : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.
    _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq (
        CORBA::ULong maximum,
        CORBA::ULong length,
        UsesDef* *value,
        CORBA::Boolean release = 0
      );
    _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq (
        const _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq &rhs
      );
    _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq &operator= (
        const _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq &rhs
      );
    virtual ~_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq (void);
    
    // = Accessors.
    TAO_Object_Manager<IR::UsesDef,IR::UsesDef_var> operator[] (CORBA::ULong index) const;
    
    // = Static operations.
    static UsesDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (UsesDef **buffer);
    
    // Implement the TAO_Base_Sequence methods (see Sequence.h)
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    UsesDef* *get_buffer (CORBA::Boolean orphan = 0);
    const UsesDef* *get_buffer (void) const;
    virtual void _shrink_buffer (
        CORBA::ULong nl,
        CORBA::ULong ol
      );
    
    virtual void _downcast (
        void* target,
        CORBA_Object *src,
        CORBA_Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      );
    virtual CORBA_Object* _upcast (void *src) const;
  };
  
#endif /* end #if !defined */
  
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  
#if !defined (_IR_USESDEFSEQ_CH_)
#define _IR_USESDEFSEQ_CH_
  
  class UsesDefSeq;
  class UsesDefSeq_var;
  
  // *************************************************************
  // UsesDefSeq
  // *************************************************************
  
  class TAO_IFR_Client_Export UsesDefSeq : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<UsesDef,UsesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  {
  public:
    UsesDefSeq (void); // default ctor
    UsesDefSeq (CORBA::ULong max); // uses max size
    UsesDefSeq (
        CORBA::ULong max, 
        CORBA::ULong length, 
        UsesDef_ptr *buffer, 
        CORBA::Boolean release = 0
      );
    UsesDefSeq (const UsesDefSeq &); // copy ctor
    ~UsesDefSeq (void);
    static void _tao_any_destructor (void*);
    
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef UsesDefSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */
    
    
  };
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_USESDEFSEQ___VAR_CH_)
#define _IR_USESDEFSEQ___VAR_CH_
  
  // *************************************************************
  // class IR::UsesDefSeq_var
  // *************************************************************
  
  class TAO_IFR_Client_Export UsesDefSeq_var
  {
  public:
    UsesDefSeq_var (void);
    UsesDefSeq_var (UsesDefSeq *);
    UsesDefSeq_var (const UsesDefSeq_var &);
    ~UsesDefSeq_var (void);
    
    UsesDefSeq_var &operator= (UsesDefSeq *);
    UsesDefSeq_var &operator= (const UsesDefSeq_var &);
    UsesDefSeq *operator-> (void);
    const UsesDefSeq *operator-> (void) const;
    
    operator const UsesDefSeq &() const;
    operator UsesDefSeq &();
    operator UsesDefSeq &() const;
    operator UsesDefSeq *&(); // variable-size base types only
    
    TAO_Object_Manager<UsesDef, UsesDef_var> operator[] (CORBA::ULong index);
    
    // in, inout, out, _retn 
    const UsesDefSeq &in (void) const;
    UsesDefSeq &inout (void);
    UsesDefSeq *&out (void);
    UsesDefSeq *_retn (void);
    UsesDefSeq *ptr (void) const;
  
  private:
    UsesDefSeq *ptr_;
  };
  
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_USESDEFSEQ___OUT_CH_)
#define _IR_USESDEFSEQ___OUT_CH_
  
  class TAO_IFR_Client_Export UsesDefSeq_out
  {
  public:
    UsesDefSeq_out (UsesDefSeq *&);
    UsesDefSeq_out (UsesDefSeq_var &);
    UsesDefSeq_out (const UsesDefSeq_out &);
    UsesDefSeq_out &operator= (const UsesDefSeq_out &);
    UsesDefSeq_out &operator= (UsesDefSeq *);
    operator UsesDefSeq *&();
    UsesDefSeq *&ptr (void);
    UsesDefSeq *operator-> (void);
    TAO_Object_Manager<UsesDef, UsesDef_var> operator[] (CORBA::ULong index);
  
  private:
    UsesDefSeq *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const UsesDefSeq_var &);
  };
  
  
#endif /* end #if !defined */
  
  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_UsesDefSeq;
  
  class HomeDef;
  
#if !defined (_IR_HOMEDEF___PTR_CH_)
#define _IR_HOMEDEF___PTR_CH_
  
  typedef HomeDef *HomeDef_ptr;
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_HOMEDEF___VAR_CH_)
#define _IR_HOMEDEF___VAR_CH_
  
  class TAO_IFR_Client_Export HomeDef_var : public TAO_Base_var
  {
  public:
    HomeDef_var (void); // default constructor
    HomeDef_var (HomeDef_ptr p) : ptr_ (p) {} 
    HomeDef_var (const HomeDef_var &); // copy constructor
    ~HomeDef_var (void); // destructor
    
    HomeDef_var &operator= (HomeDef_ptr);
    HomeDef_var &operator= (const HomeDef_var &);
    HomeDef_ptr operator-> (void) const;
    
    operator const HomeDef_ptr &() const;
    operator HomeDef_ptr &();
    // in, inout, out, _retn 
    HomeDef_ptr in (void) const;
    HomeDef_ptr &inout (void);
    HomeDef_ptr &out (void);
    HomeDef_ptr _retn (void);
    HomeDef_ptr ptr (void) const;
    
    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static HomeDef_ptr duplicate (HomeDef_ptr);
    static void release (HomeDef_ptr);
    static HomeDef_ptr nil (void);
    static HomeDef_ptr narrow (
        CORBA::Object *,
        CORBA::Environment &
      );
    static CORBA::Object * upcast (void *);
  
  private:
    HomeDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    HomeDef_var (const TAO_Base_var &rhs);
    HomeDef_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */
  
  
#if !defined (_IR_HOMEDEF___OUT_CH_)
#define _IR_HOMEDEF___OUT_CH_
  
  class TAO_IFR_Client_Export HomeDef_out
  {
  public:
    HomeDef_out (HomeDef_ptr &);
    HomeDef_out (HomeDef_var &);
    HomeDef_out (const HomeDef_out &);
    HomeDef_out &operator= (const HomeDef_out &);
    HomeDef_out &operator= (const HomeDef_var &);
    HomeDef_out &operator= (HomeDef_ptr);
    operator HomeDef_ptr &();
    HomeDef_ptr &ptr (void);
    HomeDef_ptr operator-> (void);
  
  private:
    HomeDef_ptr &ptr_;
  };
  
  
#endif /* end #if !defined */
  
  
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_HOMEDEFSEQ_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_HOMEDEFSEQ_CH_
  
  class _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq
    : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.
    _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq (
        CORBA::ULong maximum,
        CORBA::ULong length,
        HomeDef* *value,
        CORBA::Boolean release = 0
      );
    _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq (
        const _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq &rhs
      );
    _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq &operator= (
        const _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq &rhs
      );
    virtual ~_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq (void);
    
    // = Accessors.
    TAO_Object_Manager<IR::HomeDef,IR::HomeDef_var> operator[] (CORBA::ULong index) const;
    
    // = Static operations.
    static HomeDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (HomeDef **buffer);
    
    // Implement the TAO_Base_Sequence methods (see Sequence.h)
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    HomeDef* *get_buffer (CORBA::Boolean orphan = 0);
    const HomeDef* *get_buffer (void) const;
    virtual void _shrink_buffer (
        CORBA::ULong nl,
        CORBA::ULong ol
      );
    
    virtual void _downcast (
        void* target,
        CORBA_Object *src,
        CORBA_Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      );
    virtual CORBA_Object* _upcast (void *src) const;
  };
  
#endif /* end #if !defined */
  
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  
#if !defined (_IR_HOMEDEFSEQ_CH_)
#define _IR_HOMEDEFSEQ_CH_
  
  class HomeDefSeq;
  class HomeDefSeq_var;
  
  // *************************************************************
  // HomeDefSeq
  // *************************************************************
  
  class TAO_IFR_Client_Export HomeDefSeq : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<HomeDef,HomeDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  {
  public:
    HomeDefSeq (void); // default ctor
    HomeDefSeq (CORBA::ULong max); // uses max size
    HomeDefSeq (
        CORBA::ULong max, 
        CORBA::ULong length, 
        HomeDef_ptr *buffer, 
        CORBA::Boolean release = 0
      );
    HomeDefSeq (const HomeDefSeq &); // copy ctor
    ~HomeDefSeq (void);
    static void _tao_any_destructor (void*);
    
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef HomeDefSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */
    
    
  };
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_HOMEDEFSEQ___VAR_CH_)
#define _IR_HOMEDEFSEQ___VAR_CH_
  
  // *************************************************************
  // class IR::HomeDefSeq_var
  // *************************************************************
  
  class TAO_IFR_Client_Export HomeDefSeq_var
  {
  public:
    HomeDefSeq_var (void);
    HomeDefSeq_var (HomeDefSeq *);
    HomeDefSeq_var (const HomeDefSeq_var &);
    ~HomeDefSeq_var (void);
    
    HomeDefSeq_var &operator= (HomeDefSeq *);
    HomeDefSeq_var &operator= (const HomeDefSeq_var &);
    HomeDefSeq *operator-> (void);
    const HomeDefSeq *operator-> (void) const;
    
    operator const HomeDefSeq &() const;
    operator HomeDefSeq &();
    operator HomeDefSeq &() const;
    operator HomeDefSeq *&(); // variable-size base types only
    
    TAO_Object_Manager<HomeDef, HomeDef_var> operator[] (CORBA::ULong index);
    
    // in, inout, out, _retn 
    const HomeDefSeq &in (void) const;
    HomeDefSeq &inout (void);
    HomeDefSeq *&out (void);
    HomeDefSeq *_retn (void);
    HomeDefSeq *ptr (void) const;
  
  private:
    HomeDefSeq *ptr_;
  };
  
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_HOMEDEFSEQ___OUT_CH_)
#define _IR_HOMEDEFSEQ___OUT_CH_
  
  class TAO_IFR_Client_Export HomeDefSeq_out
  {
  public:
    HomeDefSeq_out (HomeDefSeq *&);
    HomeDefSeq_out (HomeDefSeq_var &);
    HomeDefSeq_out (const HomeDefSeq_out &);
    HomeDefSeq_out &operator= (const HomeDefSeq_out &);
    HomeDefSeq_out &operator= (HomeDefSeq *);
    operator HomeDefSeq *&();
    HomeDefSeq *&ptr (void);
    HomeDefSeq *operator-> (void);
    TAO_Object_Manager<HomeDef, HomeDef_var> operator[] (CORBA::ULong index);
  
  private:
    HomeDefSeq *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const HomeDefSeq_var &);
  };
  
  
#endif /* end #if !defined */
  
  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_HomeDefSeq;
  
  class EventDef;
  
#if !defined (_IR_EVENTDEF___PTR_CH_)
#define _IR_EVENTDEF___PTR_CH_
  
  typedef EventDef *EventDef_ptr;
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_EVENTDEF___VAR_CH_)
#define _IR_EVENTDEF___VAR_CH_
  
  class TAO_IFR_Client_Export EventDef_var : public TAO_Base_var
  {
  public:
    EventDef_var (void); // default constructor
    EventDef_var (EventDef_ptr p) : ptr_ (p) {} 
    EventDef_var (const EventDef_var &); // copy constructor
    ~EventDef_var (void); // destructor
    
    EventDef_var &operator= (EventDef_ptr);
    EventDef_var &operator= (const EventDef_var &);
    EventDef_ptr operator-> (void) const;
    
    operator const EventDef_ptr &() const;
    operator EventDef_ptr &();
    // in, inout, out, _retn 
    EventDef_ptr in (void) const;
    EventDef_ptr &inout (void);
    EventDef_ptr &out (void);
    EventDef_ptr _retn (void);
    EventDef_ptr ptr (void) const;
    
    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static EventDef_ptr duplicate (EventDef_ptr);
    static void release (EventDef_ptr);
    static EventDef_ptr nil (void);
    static EventDef_ptr narrow (
        CORBA::Object *,
        CORBA::Environment &
      );
    static CORBA::Object * upcast (void *);
  
  private:
    EventDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    EventDef_var (const TAO_Base_var &rhs);
    EventDef_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */
  
  
#if !defined (_IR_EVENTDEF___OUT_CH_)
#define _IR_EVENTDEF___OUT_CH_
  
  class TAO_IFR_Client_Export EventDef_out
  {
  public:
    EventDef_out (EventDef_ptr &);
    EventDef_out (EventDef_var &);
    EventDef_out (const EventDef_out &);
    EventDef_out &operator= (const EventDef_out &);
    EventDef_out &operator= (const EventDef_var &);
    EventDef_out &operator= (EventDef_ptr);
    operator EventDef_ptr &();
    EventDef_ptr &ptr (void);
    EventDef_ptr operator-> (void);
  
  private:
    EventDef_ptr &ptr_;
  };
  
  
#endif /* end #if !defined */
  
  class EmitsDef;
  
#if !defined (_IR_EMITSDEF___PTR_CH_)
#define _IR_EMITSDEF___PTR_CH_
  
  typedef EmitsDef *EmitsDef_ptr;
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_EMITSDEF___VAR_CH_)
#define _IR_EMITSDEF___VAR_CH_
  
  class TAO_IFR_Client_Export EmitsDef_var : public TAO_Base_var
  {
  public:
    EmitsDef_var (void); // default constructor
    EmitsDef_var (EmitsDef_ptr p) : ptr_ (p) {} 
    EmitsDef_var (const EmitsDef_var &); // copy constructor
    ~EmitsDef_var (void); // destructor
    
    EmitsDef_var &operator= (EmitsDef_ptr);
    EmitsDef_var &operator= (const EmitsDef_var &);
    EmitsDef_ptr operator-> (void) const;
    
    operator const EmitsDef_ptr &() const;
    operator EmitsDef_ptr &();
    // in, inout, out, _retn 
    EmitsDef_ptr in (void) const;
    EmitsDef_ptr &inout (void);
    EmitsDef_ptr &out (void);
    EmitsDef_ptr _retn (void);
    EmitsDef_ptr ptr (void) const;
    
    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static EmitsDef_ptr duplicate (EmitsDef_ptr);
    static void release (EmitsDef_ptr);
    static EmitsDef_ptr nil (void);
    static EmitsDef_ptr narrow (
        CORBA::Object *,
        CORBA::Environment &
      );
    static CORBA::Object * upcast (void *);
  
  private:
    EmitsDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    EmitsDef_var (const TAO_Base_var &rhs);
    EmitsDef_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */
  
  
#if !defined (_IR_EMITSDEF___OUT_CH_)
#define _IR_EMITSDEF___OUT_CH_
  
  class TAO_IFR_Client_Export EmitsDef_out
  {
  public:
    EmitsDef_out (EmitsDef_ptr &);
    EmitsDef_out (EmitsDef_var &);
    EmitsDef_out (const EmitsDef_out &);
    EmitsDef_out &operator= (const EmitsDef_out &);
    EmitsDef_out &operator= (const EmitsDef_var &);
    EmitsDef_out &operator= (EmitsDef_ptr);
    operator EmitsDef_ptr &();
    EmitsDef_ptr &ptr (void);
    EmitsDef_ptr operator-> (void);
  
  private:
    EmitsDef_ptr &ptr_;
  };
  
  
#endif /* end #if !defined */
  
  
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_EMITSDEFSEQ_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_EMITSDEFSEQ_CH_
  
  class _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq
    : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.
    _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq (
        CORBA::ULong maximum,
        CORBA::ULong length,
        EmitsDef* *value,
        CORBA::Boolean release = 0
      );
    _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq (
        const _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq &rhs
      );
    _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq &operator= (
        const _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq &rhs
      );
    virtual ~_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq (void);
    
    // = Accessors.
    TAO_Object_Manager<IR::EmitsDef,IR::EmitsDef_var> operator[] (CORBA::ULong index) const;
    
    // = Static operations.
    static EmitsDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (EmitsDef **buffer);
    
    // Implement the TAO_Base_Sequence methods (see Sequence.h)
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    EmitsDef* *get_buffer (CORBA::Boolean orphan = 0);
    const EmitsDef* *get_buffer (void) const;
    virtual void _shrink_buffer (
        CORBA::ULong nl,
        CORBA::ULong ol
      );
    
    virtual void _downcast (
        void* target,
        CORBA_Object *src,
        CORBA_Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      );
    virtual CORBA_Object* _upcast (void *src) const;
  };
  
#endif /* end #if !defined */
  
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  
#if !defined (_IR_EMITSDEFSEQ_CH_)
#define _IR_EMITSDEFSEQ_CH_
  
  class EmitsDefSeq;
  class EmitsDefSeq_var;
  
  // *************************************************************
  // EmitsDefSeq
  // *************************************************************
  
  class TAO_IFR_Client_Export EmitsDefSeq : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<EmitsDef,EmitsDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  {
  public:
    EmitsDefSeq (void); // default ctor
    EmitsDefSeq (CORBA::ULong max); // uses max size
    EmitsDefSeq (
        CORBA::ULong max, 
        CORBA::ULong length, 
        EmitsDef_ptr *buffer, 
        CORBA::Boolean release = 0
      );
    EmitsDefSeq (const EmitsDefSeq &); // copy ctor
    ~EmitsDefSeq (void);
    static void _tao_any_destructor (void*);
    
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef EmitsDefSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */
    
    
  };
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_EMITSDEFSEQ___VAR_CH_)
#define _IR_EMITSDEFSEQ___VAR_CH_
  
  // *************************************************************
  // class IR::EmitsDefSeq_var
  // *************************************************************
  
  class TAO_IFR_Client_Export EmitsDefSeq_var
  {
  public:
    EmitsDefSeq_var (void);
    EmitsDefSeq_var (EmitsDefSeq *);
    EmitsDefSeq_var (const EmitsDefSeq_var &);
    ~EmitsDefSeq_var (void);
    
    EmitsDefSeq_var &operator= (EmitsDefSeq *);
    EmitsDefSeq_var &operator= (const EmitsDefSeq_var &);
    EmitsDefSeq *operator-> (void);
    const EmitsDefSeq *operator-> (void) const;
    
    operator const EmitsDefSeq &() const;
    operator EmitsDefSeq &();
    operator EmitsDefSeq &() const;
    operator EmitsDefSeq *&(); // variable-size base types only
    
    TAO_Object_Manager<EmitsDef, EmitsDef_var> operator[] (CORBA::ULong index);
    
    // in, inout, out, _retn 
    const EmitsDefSeq &in (void) const;
    EmitsDefSeq &inout (void);
    EmitsDefSeq *&out (void);
    EmitsDefSeq *_retn (void);
    EmitsDefSeq *ptr (void) const;
  
  private:
    EmitsDefSeq *ptr_;
  };
  
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_EMITSDEFSEQ___OUT_CH_)
#define _IR_EMITSDEFSEQ___OUT_CH_
  
  class TAO_IFR_Client_Export EmitsDefSeq_out
  {
  public:
    EmitsDefSeq_out (EmitsDefSeq *&);
    EmitsDefSeq_out (EmitsDefSeq_var &);
    EmitsDefSeq_out (const EmitsDefSeq_out &);
    EmitsDefSeq_out &operator= (const EmitsDefSeq_out &);
    EmitsDefSeq_out &operator= (EmitsDefSeq *);
    operator EmitsDefSeq *&();
    EmitsDefSeq *&ptr (void);
    EmitsDefSeq *operator-> (void);
    TAO_Object_Manager<EmitsDef, EmitsDef_var> operator[] (CORBA::ULong index);
  
  private:
    EmitsDefSeq *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const EmitsDefSeq_var &);
  };
  
  
#endif /* end #if !defined */
  
  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_EmitsDefSeq;
  
  class PublishesDef;
  
#if !defined (_IR_PUBLISHESDEF___PTR_CH_)
#define _IR_PUBLISHESDEF___PTR_CH_
  
  typedef PublishesDef *PublishesDef_ptr;
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_PUBLISHESDEF___VAR_CH_)
#define _IR_PUBLISHESDEF___VAR_CH_
  
  class TAO_IFR_Client_Export PublishesDef_var : public TAO_Base_var
  {
  public:
    PublishesDef_var (void); // default constructor
    PublishesDef_var (PublishesDef_ptr p) : ptr_ (p) {} 
    PublishesDef_var (const PublishesDef_var &); // copy constructor
    ~PublishesDef_var (void); // destructor
    
    PublishesDef_var &operator= (PublishesDef_ptr);
    PublishesDef_var &operator= (const PublishesDef_var &);
    PublishesDef_ptr operator-> (void) const;
    
    operator const PublishesDef_ptr &() const;
    operator PublishesDef_ptr &();
    // in, inout, out, _retn 
    PublishesDef_ptr in (void) const;
    PublishesDef_ptr &inout (void);
    PublishesDef_ptr &out (void);
    PublishesDef_ptr _retn (void);
    PublishesDef_ptr ptr (void) const;
    
    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static PublishesDef_ptr duplicate (PublishesDef_ptr);
    static void release (PublishesDef_ptr);
    static PublishesDef_ptr nil (void);
    static PublishesDef_ptr narrow (
        CORBA::Object *,
        CORBA::Environment &
      );
    static CORBA::Object * upcast (void *);
  
  private:
    PublishesDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    PublishesDef_var (const TAO_Base_var &rhs);
    PublishesDef_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */
  
  
#if !defined (_IR_PUBLISHESDEF___OUT_CH_)
#define _IR_PUBLISHESDEF___OUT_CH_
  
  class TAO_IFR_Client_Export PublishesDef_out
  {
  public:
    PublishesDef_out (PublishesDef_ptr &);
    PublishesDef_out (PublishesDef_var &);
    PublishesDef_out (const PublishesDef_out &);
    PublishesDef_out &operator= (const PublishesDef_out &);
    PublishesDef_out &operator= (const PublishesDef_var &);
    PublishesDef_out &operator= (PublishesDef_ptr);
    operator PublishesDef_ptr &();
    PublishesDef_ptr &ptr (void);
    PublishesDef_ptr operator-> (void);
  
  private:
    PublishesDef_ptr &ptr_;
  };
  
  
#endif /* end #if !defined */
  
  
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_PUBLISHESDEFSEQ_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_PUBLISHESDEFSEQ_CH_
  
  class _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq
    : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.
    _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq (
        CORBA::ULong maximum,
        CORBA::ULong length,
        PublishesDef* *value,
        CORBA::Boolean release = 0
      );
    _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq (
        const _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq &rhs
      );
    _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq &operator= (
        const _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq &rhs
      );
    virtual ~_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq (void);
    
    // = Accessors.
    TAO_Object_Manager<IR::PublishesDef,IR::PublishesDef_var> operator[] (CORBA::ULong index) const;
    
    // = Static operations.
    static PublishesDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (PublishesDef **buffer);
    
    // Implement the TAO_Base_Sequence methods (see Sequence.h)
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    PublishesDef* *get_buffer (CORBA::Boolean orphan = 0);
    const PublishesDef* *get_buffer (void) const;
    virtual void _shrink_buffer (
        CORBA::ULong nl,
        CORBA::ULong ol
      );
    
    virtual void _downcast (
        void* target,
        CORBA_Object *src,
        CORBA_Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      );
    virtual CORBA_Object* _upcast (void *src) const;
  };
  
#endif /* end #if !defined */
  
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  
#if !defined (_IR_PUBLISHESDEFSEQ_CH_)
#define _IR_PUBLISHESDEFSEQ_CH_
  
  class PublishesDefSeq;
  class PublishesDefSeq_var;
  
  // *************************************************************
  // PublishesDefSeq
  // *************************************************************
  
  class TAO_IFR_Client_Export PublishesDefSeq : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<PublishesDef,PublishesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  {
  public:
    PublishesDefSeq (void); // default ctor
    PublishesDefSeq (CORBA::ULong max); // uses max size
    PublishesDefSeq (
        CORBA::ULong max, 
        CORBA::ULong length, 
        PublishesDef_ptr *buffer, 
        CORBA::Boolean release = 0
      );
    PublishesDefSeq (const PublishesDefSeq &); // copy ctor
    ~PublishesDefSeq (void);
    static void _tao_any_destructor (void*);
    
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef PublishesDefSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */
    
    
  };
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_PUBLISHESDEFSEQ___VAR_CH_)
#define _IR_PUBLISHESDEFSEQ___VAR_CH_
  
  // *************************************************************
  // class IR::PublishesDefSeq_var
  // *************************************************************
  
  class TAO_IFR_Client_Export PublishesDefSeq_var
  {
  public:
    PublishesDefSeq_var (void);
    PublishesDefSeq_var (PublishesDefSeq *);
    PublishesDefSeq_var (const PublishesDefSeq_var &);
    ~PublishesDefSeq_var (void);
    
    PublishesDefSeq_var &operator= (PublishesDefSeq *);
    PublishesDefSeq_var &operator= (const PublishesDefSeq_var &);
    PublishesDefSeq *operator-> (void);
    const PublishesDefSeq *operator-> (void) const;
    
    operator const PublishesDefSeq &() const;
    operator PublishesDefSeq &();
    operator PublishesDefSeq &() const;
    operator PublishesDefSeq *&(); // variable-size base types only
    
    TAO_Object_Manager<PublishesDef, PublishesDef_var> operator[] (CORBA::ULong index);
    
    // in, inout, out, _retn 
    const PublishesDefSeq &in (void) const;
    PublishesDefSeq &inout (void);
    PublishesDefSeq *&out (void);
    PublishesDefSeq *_retn (void);
    PublishesDefSeq *ptr (void) const;
  
  private:
    PublishesDefSeq *ptr_;
  };
  
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_PUBLISHESDEFSEQ___OUT_CH_)
#define _IR_PUBLISHESDEFSEQ___OUT_CH_
  
  class TAO_IFR_Client_Export PublishesDefSeq_out
  {
  public:
    PublishesDefSeq_out (PublishesDefSeq *&);
    PublishesDefSeq_out (PublishesDefSeq_var &);
    PublishesDefSeq_out (const PublishesDefSeq_out &);
    PublishesDefSeq_out &operator= (const PublishesDefSeq_out &);
    PublishesDefSeq_out &operator= (PublishesDefSeq *);
    operator PublishesDefSeq *&();
    PublishesDefSeq *&ptr (void);
    PublishesDefSeq *operator-> (void);
    TAO_Object_Manager<PublishesDef, PublishesDef_var> operator[] (CORBA::ULong index);
  
  private:
    PublishesDefSeq *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const PublishesDefSeq_var &);
  };
  
  
#endif /* end #if !defined */
  
  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_PublishesDefSeq;
  
  class ConsumesDef;
  
#if !defined (_IR_CONSUMESDEF___PTR_CH_)
#define _IR_CONSUMESDEF___PTR_CH_
  
  typedef ConsumesDef *ConsumesDef_ptr;
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_CONSUMESDEF___VAR_CH_)
#define _IR_CONSUMESDEF___VAR_CH_
  
  class TAO_IFR_Client_Export ConsumesDef_var : public TAO_Base_var
  {
  public:
    ConsumesDef_var (void); // default constructor
    ConsumesDef_var (ConsumesDef_ptr p) : ptr_ (p) {} 
    ConsumesDef_var (const ConsumesDef_var &); // copy constructor
    ~ConsumesDef_var (void); // destructor
    
    ConsumesDef_var &operator= (ConsumesDef_ptr);
    ConsumesDef_var &operator= (const ConsumesDef_var &);
    ConsumesDef_ptr operator-> (void) const;
    
    operator const ConsumesDef_ptr &() const;
    operator ConsumesDef_ptr &();
    // in, inout, out, _retn 
    ConsumesDef_ptr in (void) const;
    ConsumesDef_ptr &inout (void);
    ConsumesDef_ptr &out (void);
    ConsumesDef_ptr _retn (void);
    ConsumesDef_ptr ptr (void) const;
    
    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static ConsumesDef_ptr duplicate (ConsumesDef_ptr);
    static void release (ConsumesDef_ptr);
    static ConsumesDef_ptr nil (void);
    static ConsumesDef_ptr narrow (
        CORBA::Object *,
        CORBA::Environment &
      );
    static CORBA::Object * upcast (void *);
  
  private:
    ConsumesDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    ConsumesDef_var (const TAO_Base_var &rhs);
    ConsumesDef_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */
  
  
#if !defined (_IR_CONSUMESDEF___OUT_CH_)
#define _IR_CONSUMESDEF___OUT_CH_
  
  class TAO_IFR_Client_Export ConsumesDef_out
  {
  public:
    ConsumesDef_out (ConsumesDef_ptr &);
    ConsumesDef_out (ConsumesDef_var &);
    ConsumesDef_out (const ConsumesDef_out &);
    ConsumesDef_out &operator= (const ConsumesDef_out &);
    ConsumesDef_out &operator= (const ConsumesDef_var &);
    ConsumesDef_out &operator= (ConsumesDef_ptr);
    operator ConsumesDef_ptr &();
    ConsumesDef_ptr &ptr (void);
    ConsumesDef_ptr operator-> (void);
  
  private:
    ConsumesDef_ptr &ptr_;
  };
  
  
#endif /* end #if !defined */
  
  
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_CONSUMESDEFSEQ_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_CONSUMESDEFSEQ_CH_
  
  class _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq
    : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.
    _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq (
        CORBA::ULong maximum,
        CORBA::ULong length,
        ConsumesDef* *value,
        CORBA::Boolean release = 0
      );
    _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq (
        const _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq &rhs
      );
    _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq &operator= (
        const _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq &rhs
      );
    virtual ~_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq (void);
    
    // = Accessors.
    TAO_Object_Manager<IR::ConsumesDef,IR::ConsumesDef_var> operator[] (CORBA::ULong index) const;
    
    // = Static operations.
    static ConsumesDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (ConsumesDef **buffer);
    
    // Implement the TAO_Base_Sequence methods (see Sequence.h)
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    ConsumesDef* *get_buffer (CORBA::Boolean orphan = 0);
    const ConsumesDef* *get_buffer (void) const;
    virtual void _shrink_buffer (
        CORBA::ULong nl,
        CORBA::ULong ol
      );
    
    virtual void _downcast (
        void* target,
        CORBA_Object *src,
        CORBA_Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      );
    virtual CORBA_Object* _upcast (void *src) const;
  };
  
#endif /* end #if !defined */
  
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  
#if !defined (_IR_CONSUMESDEFSEQ_CH_)
#define _IR_CONSUMESDEFSEQ_CH_
  
  class ConsumesDefSeq;
  class ConsumesDefSeq_var;
  
  // *************************************************************
  // ConsumesDefSeq
  // *************************************************************
  
  class TAO_IFR_Client_Export ConsumesDefSeq : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<ConsumesDef,ConsumesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  {
  public:
    ConsumesDefSeq (void); // default ctor
    ConsumesDefSeq (CORBA::ULong max); // uses max size
    ConsumesDefSeq (
        CORBA::ULong max, 
        CORBA::ULong length, 
        ConsumesDef_ptr *buffer, 
        CORBA::Boolean release = 0
      );
    ConsumesDefSeq (const ConsumesDefSeq &); // copy ctor
    ~ConsumesDefSeq (void);
    static void _tao_any_destructor (void*);
    
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef ConsumesDefSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */
    
    
  };
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_CONSUMESDEFSEQ___VAR_CH_)
#define _IR_CONSUMESDEFSEQ___VAR_CH_
  
  // *************************************************************
  // class IR::ConsumesDefSeq_var
  // *************************************************************
  
  class TAO_IFR_Client_Export ConsumesDefSeq_var
  {
  public:
    ConsumesDefSeq_var (void);
    ConsumesDefSeq_var (ConsumesDefSeq *);
    ConsumesDefSeq_var (const ConsumesDefSeq_var &);
    ~ConsumesDefSeq_var (void);
    
    ConsumesDefSeq_var &operator= (ConsumesDefSeq *);
    ConsumesDefSeq_var &operator= (const ConsumesDefSeq_var &);
    ConsumesDefSeq *operator-> (void);
    const ConsumesDefSeq *operator-> (void) const;
    
    operator const ConsumesDefSeq &() const;
    operator ConsumesDefSeq &();
    operator ConsumesDefSeq &() const;
    operator ConsumesDefSeq *&(); // variable-size base types only
    
    TAO_Object_Manager<ConsumesDef, ConsumesDef_var> operator[] (CORBA::ULong index);
    
    // in, inout, out, _retn 
    const ConsumesDefSeq &in (void) const;
    ConsumesDefSeq &inout (void);
    ConsumesDefSeq *&out (void);
    ConsumesDefSeq *_retn (void);
    ConsumesDefSeq *ptr (void) const;
  
  private:
    ConsumesDefSeq *ptr_;
  };
  
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_CONSUMESDEFSEQ___OUT_CH_)
#define _IR_CONSUMESDEFSEQ___OUT_CH_
  
  class TAO_IFR_Client_Export ConsumesDefSeq_out
  {
  public:
    ConsumesDefSeq_out (ConsumesDefSeq *&);
    ConsumesDefSeq_out (ConsumesDefSeq_var &);
    ConsumesDefSeq_out (const ConsumesDefSeq_out &);
    ConsumesDefSeq_out &operator= (const ConsumesDefSeq_out &);
    ConsumesDefSeq_out &operator= (ConsumesDefSeq *);
    operator ConsumesDefSeq *&();
    ConsumesDefSeq *&ptr (void);
    ConsumesDefSeq *operator-> (void);
    TAO_Object_Manager<ConsumesDef, ConsumesDef_var> operator[] (CORBA::ULong index);
  
  private:
    ConsumesDefSeq *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const ConsumesDefSeq_var &);
  };
  
  
#endif /* end #if !defined */
  
  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ConsumesDefSeq;
  
  class FactoryDef;
  
#if !defined (_IR_FACTORYDEF___PTR_CH_)
#define _IR_FACTORYDEF___PTR_CH_
  
  typedef FactoryDef *FactoryDef_ptr;
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_FACTORYDEF___VAR_CH_)
#define _IR_FACTORYDEF___VAR_CH_
  
  class TAO_IFR_Client_Export FactoryDef_var : public TAO_Base_var
  {
  public:
    FactoryDef_var (void); // default constructor
    FactoryDef_var (FactoryDef_ptr p) : ptr_ (p) {} 
    FactoryDef_var (const FactoryDef_var &); // copy constructor
    ~FactoryDef_var (void); // destructor
    
    FactoryDef_var &operator= (FactoryDef_ptr);
    FactoryDef_var &operator= (const FactoryDef_var &);
    FactoryDef_ptr operator-> (void) const;
    
    operator const FactoryDef_ptr &() const;
    operator FactoryDef_ptr &();
    // in, inout, out, _retn 
    FactoryDef_ptr in (void) const;
    FactoryDef_ptr &inout (void);
    FactoryDef_ptr &out (void);
    FactoryDef_ptr _retn (void);
    FactoryDef_ptr ptr (void) const;
    
    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static FactoryDef_ptr duplicate (FactoryDef_ptr);
    static void release (FactoryDef_ptr);
    static FactoryDef_ptr nil (void);
    static FactoryDef_ptr narrow (
        CORBA::Object *,
        CORBA::Environment &
      );
    static CORBA::Object * upcast (void *);
  
  private:
    FactoryDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    FactoryDef_var (const TAO_Base_var &rhs);
    FactoryDef_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */
  
  
#if !defined (_IR_FACTORYDEF___OUT_CH_)
#define _IR_FACTORYDEF___OUT_CH_
  
  class TAO_IFR_Client_Export FactoryDef_out
  {
  public:
    FactoryDef_out (FactoryDef_ptr &);
    FactoryDef_out (FactoryDef_var &);
    FactoryDef_out (const FactoryDef_out &);
    FactoryDef_out &operator= (const FactoryDef_out &);
    FactoryDef_out &operator= (const FactoryDef_var &);
    FactoryDef_out &operator= (FactoryDef_ptr);
    operator FactoryDef_ptr &();
    FactoryDef_ptr &ptr (void);
    FactoryDef_ptr operator-> (void);
  
  private:
    FactoryDef_ptr &ptr_;
  };
  
  
#endif /* end #if !defined */
  
  
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_FACTORYDEFSEQ_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_FACTORYDEFSEQ_CH_
  
  class _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq
    : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.
    _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq (
        CORBA::ULong maximum,
        CORBA::ULong length,
        FactoryDef* *value,
        CORBA::Boolean release = 0
      );
    _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq (
        const _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq &rhs
      );
    _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq &operator= (
        const _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq &rhs
      );
    virtual ~_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq (void);
    
    // = Accessors.
    TAO_Object_Manager<IR::FactoryDef,IR::FactoryDef_var> operator[] (CORBA::ULong index) const;
    
    // = Static operations.
    static FactoryDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (FactoryDef **buffer);
    
    // Implement the TAO_Base_Sequence methods (see Sequence.h)
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    FactoryDef* *get_buffer (CORBA::Boolean orphan = 0);
    const FactoryDef* *get_buffer (void) const;
    virtual void _shrink_buffer (
        CORBA::ULong nl,
        CORBA::ULong ol
      );
    
    virtual void _downcast (
        void* target,
        CORBA_Object *src,
        CORBA_Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      );
    virtual CORBA_Object* _upcast (void *src) const;
  };
  
#endif /* end #if !defined */
  
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  
#if !defined (_IR_FACTORYDEFSEQ_CH_)
#define _IR_FACTORYDEFSEQ_CH_
  
  class FactoryDefSeq;
  class FactoryDefSeq_var;
  
  // *************************************************************
  // FactoryDefSeq
  // *************************************************************
  
  class TAO_IFR_Client_Export FactoryDefSeq : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<FactoryDef,FactoryDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  {
  public:
    FactoryDefSeq (void); // default ctor
    FactoryDefSeq (CORBA::ULong max); // uses max size
    FactoryDefSeq (
        CORBA::ULong max, 
        CORBA::ULong length, 
        FactoryDef_ptr *buffer, 
        CORBA::Boolean release = 0
      );
    FactoryDefSeq (const FactoryDefSeq &); // copy ctor
    ~FactoryDefSeq (void);
    static void _tao_any_destructor (void*);
    
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef FactoryDefSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */
    
    
  };
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_FACTORYDEFSEQ___VAR_CH_)
#define _IR_FACTORYDEFSEQ___VAR_CH_
  
  // *************************************************************
  // class IR::FactoryDefSeq_var
  // *************************************************************
  
  class TAO_IFR_Client_Export FactoryDefSeq_var
  {
  public:
    FactoryDefSeq_var (void);
    FactoryDefSeq_var (FactoryDefSeq *);
    FactoryDefSeq_var (const FactoryDefSeq_var &);
    ~FactoryDefSeq_var (void);
    
    FactoryDefSeq_var &operator= (FactoryDefSeq *);
    FactoryDefSeq_var &operator= (const FactoryDefSeq_var &);
    FactoryDefSeq *operator-> (void);
    const FactoryDefSeq *operator-> (void) const;
    
    operator const FactoryDefSeq &() const;
    operator FactoryDefSeq &();
    operator FactoryDefSeq &() const;
    operator FactoryDefSeq *&(); // variable-size base types only
    
    TAO_Object_Manager<FactoryDef, FactoryDef_var> operator[] (CORBA::ULong index);
    
    // in, inout, out, _retn 
    const FactoryDefSeq &in (void) const;
    FactoryDefSeq &inout (void);
    FactoryDefSeq *&out (void);
    FactoryDefSeq *_retn (void);
    FactoryDefSeq *ptr (void) const;
  
  private:
    FactoryDefSeq *ptr_;
  };
  
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_FACTORYDEFSEQ___OUT_CH_)
#define _IR_FACTORYDEFSEQ___OUT_CH_
  
  class TAO_IFR_Client_Export FactoryDefSeq_out
  {
  public:
    FactoryDefSeq_out (FactoryDefSeq *&);
    FactoryDefSeq_out (FactoryDefSeq_var &);
    FactoryDefSeq_out (const FactoryDefSeq_out &);
    FactoryDefSeq_out &operator= (const FactoryDefSeq_out &);
    FactoryDefSeq_out &operator= (FactoryDefSeq *);
    operator FactoryDefSeq *&();
    FactoryDefSeq *&ptr (void);
    FactoryDefSeq *operator-> (void);
    TAO_Object_Manager<FactoryDef, FactoryDef_var> operator[] (CORBA::ULong index);
  
  private:
    FactoryDefSeq *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const FactoryDefSeq_var &);
  };
  
  
#endif /* end #if !defined */
  
  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_FactoryDefSeq;
  
  class FinderDef;
  
#if !defined (_IR_FINDERDEF___PTR_CH_)
#define _IR_FINDERDEF___PTR_CH_
  
  typedef FinderDef *FinderDef_ptr;
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_FINDERDEF___VAR_CH_)
#define _IR_FINDERDEF___VAR_CH_
  
  class TAO_IFR_Client_Export FinderDef_var : public TAO_Base_var
  {
  public:
    FinderDef_var (void); // default constructor
    FinderDef_var (FinderDef_ptr p) : ptr_ (p) {} 
    FinderDef_var (const FinderDef_var &); // copy constructor
    ~FinderDef_var (void); // destructor
    
    FinderDef_var &operator= (FinderDef_ptr);
    FinderDef_var &operator= (const FinderDef_var &);
    FinderDef_ptr operator-> (void) const;
    
    operator const FinderDef_ptr &() const;
    operator FinderDef_ptr &();
    // in, inout, out, _retn 
    FinderDef_ptr in (void) const;
    FinderDef_ptr &inout (void);
    FinderDef_ptr &out (void);
    FinderDef_ptr _retn (void);
    FinderDef_ptr ptr (void) const;
    
    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static FinderDef_ptr duplicate (FinderDef_ptr);
    static void release (FinderDef_ptr);
    static FinderDef_ptr nil (void);
    static FinderDef_ptr narrow (
        CORBA::Object *,
        CORBA::Environment &
      );
    static CORBA::Object * upcast (void *);
  
  private:
    FinderDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    FinderDef_var (const TAO_Base_var &rhs);
    FinderDef_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */
  
  
#if !defined (_IR_FINDERDEF___OUT_CH_)
#define _IR_FINDERDEF___OUT_CH_
  
  class TAO_IFR_Client_Export FinderDef_out
  {
  public:
    FinderDef_out (FinderDef_ptr &);
    FinderDef_out (FinderDef_var &);
    FinderDef_out (const FinderDef_out &);
    FinderDef_out &operator= (const FinderDef_out &);
    FinderDef_out &operator= (const FinderDef_var &);
    FinderDef_out &operator= (FinderDef_ptr);
    operator FinderDef_ptr &();
    FinderDef_ptr &ptr (void);
    FinderDef_ptr operator-> (void);
  
  private:
    FinderDef_ptr &ptr_;
  };
  
  
#endif /* end #if !defined */
  
  
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_FINDERDEFSEQ_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_FINDERDEFSEQ_CH_
  
  class _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq
    : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.
    _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq (
        CORBA::ULong maximum,
        CORBA::ULong length,
        FinderDef* *value,
        CORBA::Boolean release = 0
      );
    _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq (
        const _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq &rhs
      );
    _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq &operator= (
        const _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq &rhs
      );
    virtual ~_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq (void);
    
    // = Accessors.
    TAO_Object_Manager<IR::FinderDef,IR::FinderDef_var> operator[] (CORBA::ULong index) const;
    
    // = Static operations.
    static FinderDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (FinderDef **buffer);
    
    // Implement the TAO_Base_Sequence methods (see Sequence.h)
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    FinderDef* *get_buffer (CORBA::Boolean orphan = 0);
    const FinderDef* *get_buffer (void) const;
    virtual void _shrink_buffer (
        CORBA::ULong nl,
        CORBA::ULong ol
      );
    
    virtual void _downcast (
        void* target,
        CORBA_Object *src,
        CORBA_Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      );
    virtual CORBA_Object* _upcast (void *src) const;
  };
  
#endif /* end #if !defined */
  
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  
#if !defined (_IR_FINDERDEFSEQ_CH_)
#define _IR_FINDERDEFSEQ_CH_
  
  class FinderDefSeq;
  class FinderDefSeq_var;
  
  // *************************************************************
  // FinderDefSeq
  // *************************************************************
  
  class TAO_IFR_Client_Export FinderDefSeq : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<FinderDef,FinderDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  {
  public:
    FinderDefSeq (void); // default ctor
    FinderDefSeq (CORBA::ULong max); // uses max size
    FinderDefSeq (
        CORBA::ULong max, 
        CORBA::ULong length, 
        FinderDef_ptr *buffer, 
        CORBA::Boolean release = 0
      );
    FinderDefSeq (const FinderDefSeq &); // copy ctor
    ~FinderDefSeq (void);
    static void _tao_any_destructor (void*);
    
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef FinderDefSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */
    
    
  };
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_FINDERDEFSEQ___VAR_CH_)
#define _IR_FINDERDEFSEQ___VAR_CH_
  
  // *************************************************************
  // class IR::FinderDefSeq_var
  // *************************************************************
  
  class TAO_IFR_Client_Export FinderDefSeq_var
  {
  public:
    FinderDefSeq_var (void);
    FinderDefSeq_var (FinderDefSeq *);
    FinderDefSeq_var (const FinderDefSeq_var &);
    ~FinderDefSeq_var (void);
    
    FinderDefSeq_var &operator= (FinderDefSeq *);
    FinderDefSeq_var &operator= (const FinderDefSeq_var &);
    FinderDefSeq *operator-> (void);
    const FinderDefSeq *operator-> (void) const;
    
    operator const FinderDefSeq &() const;
    operator FinderDefSeq &();
    operator FinderDefSeq &() const;
    operator FinderDefSeq *&(); // variable-size base types only
    
    TAO_Object_Manager<FinderDef, FinderDef_var> operator[] (CORBA::ULong index);
    
    // in, inout, out, _retn 
    const FinderDefSeq &in (void) const;
    FinderDefSeq &inout (void);
    FinderDefSeq *&out (void);
    FinderDefSeq *_retn (void);
    FinderDefSeq *ptr (void) const;
  
  private:
    FinderDefSeq *ptr_;
  };
  
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_FINDERDEFSEQ___OUT_CH_)
#define _IR_FINDERDEFSEQ___OUT_CH_
  
  class TAO_IFR_Client_Export FinderDefSeq_out
  {
  public:
    FinderDefSeq_out (FinderDefSeq *&);
    FinderDefSeq_out (FinderDefSeq_var &);
    FinderDefSeq_out (const FinderDefSeq_out &);
    FinderDefSeq_out &operator= (const FinderDefSeq_out &);
    FinderDefSeq_out &operator= (FinderDefSeq *);
    operator FinderDefSeq *&();
    FinderDefSeq *&ptr (void);
    FinderDefSeq *operator-> (void);
    TAO_Object_Manager<FinderDef, FinderDef_var> operator[] (CORBA::ULong index);
  
  private:
    FinderDefSeq *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const FinderDefSeq_var &);
  };
  
  
#endif /* end #if !defined */
  
  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_FinderDefSeq;
  
  class PrimaryKeyDef;
  
#if !defined (_IR_PRIMARYKEYDEF___PTR_CH_)
#define _IR_PRIMARYKEYDEF___PTR_CH_
  
  typedef PrimaryKeyDef *PrimaryKeyDef_ptr;
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_PRIMARYKEYDEF___VAR_CH_)
#define _IR_PRIMARYKEYDEF___VAR_CH_
  
  class TAO_IFR_Client_Export PrimaryKeyDef_var : public TAO_Base_var
  {
  public:
    PrimaryKeyDef_var (void); // default constructor
    PrimaryKeyDef_var (PrimaryKeyDef_ptr p) : ptr_ (p) {} 
    PrimaryKeyDef_var (const PrimaryKeyDef_var &); // copy constructor
    ~PrimaryKeyDef_var (void); // destructor
    
    PrimaryKeyDef_var &operator= (PrimaryKeyDef_ptr);
    PrimaryKeyDef_var &operator= (const PrimaryKeyDef_var &);
    PrimaryKeyDef_ptr operator-> (void) const;
    
    operator const PrimaryKeyDef_ptr &() const;
    operator PrimaryKeyDef_ptr &();
    // in, inout, out, _retn 
    PrimaryKeyDef_ptr in (void) const;
    PrimaryKeyDef_ptr &inout (void);
    PrimaryKeyDef_ptr &out (void);
    PrimaryKeyDef_ptr _retn (void);
    PrimaryKeyDef_ptr ptr (void) const;
    
    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static PrimaryKeyDef_ptr duplicate (PrimaryKeyDef_ptr);
    static void release (PrimaryKeyDef_ptr);
    static PrimaryKeyDef_ptr nil (void);
    static PrimaryKeyDef_ptr narrow (
        CORBA::Object *,
        CORBA::Environment &
      );
    static CORBA::Object * upcast (void *);
  
  private:
    PrimaryKeyDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    PrimaryKeyDef_var (const TAO_Base_var &rhs);
    PrimaryKeyDef_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */
  
  
#if !defined (_IR_PRIMARYKEYDEF___OUT_CH_)
#define _IR_PRIMARYKEYDEF___OUT_CH_
  
  class TAO_IFR_Client_Export PrimaryKeyDef_out
  {
  public:
    PrimaryKeyDef_out (PrimaryKeyDef_ptr &);
    PrimaryKeyDef_out (PrimaryKeyDef_var &);
    PrimaryKeyDef_out (const PrimaryKeyDef_out &);
    PrimaryKeyDef_out &operator= (const PrimaryKeyDef_out &);
    PrimaryKeyDef_out &operator= (const PrimaryKeyDef_var &);
    PrimaryKeyDef_out &operator= (PrimaryKeyDef_ptr);
    operator PrimaryKeyDef_ptr &();
    PrimaryKeyDef_ptr &ptr (void);
    PrimaryKeyDef_ptr operator-> (void);
  
  private:
    PrimaryKeyDef_ptr &ptr_;
  };
  
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_COMPONENTREPOSITORY___PTR_CH_)
#define _IR_COMPONENTREPOSITORY___PTR_CH_
  
  class ComponentRepository;
  typedef ComponentRepository *ComponentRepository_ptr;
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_COMPONENTREPOSITORY___VAR_CH_)
#define _IR_COMPONENTREPOSITORY___VAR_CH_
  
  class TAO_IFR_Client_Export ComponentRepository_var : public TAO_Base_var
  {
  public:
    ComponentRepository_var (void); // default constructor
    ComponentRepository_var (ComponentRepository_ptr p) : ptr_ (p) {} 
    ComponentRepository_var (const ComponentRepository_var &); // copy constructor
    ~ComponentRepository_var (void); // destructor
    
    ComponentRepository_var &operator= (ComponentRepository_ptr);
    ComponentRepository_var &operator= (const ComponentRepository_var &);
    ComponentRepository_ptr operator-> (void) const;
    
    operator const ComponentRepository_ptr &() const;
    operator ComponentRepository_ptr &();
    // in, inout, out, _retn 
    ComponentRepository_ptr in (void) const;
    ComponentRepository_ptr &inout (void);
    ComponentRepository_ptr &out (void);
    ComponentRepository_ptr _retn (void);
    ComponentRepository_ptr ptr (void) const;
    
    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static ComponentRepository_ptr duplicate (ComponentRepository_ptr);
    static void release (ComponentRepository_ptr);
    static ComponentRepository_ptr nil (void);
    static ComponentRepository_ptr narrow (
        CORBA::Object *,
        CORBA::Environment &
      );
    static CORBA::Object * upcast (void *);
  
  private:
    ComponentRepository_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    ComponentRepository_var (const TAO_Base_var &rhs);
    ComponentRepository_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */
  
  
#if !defined (_IR_COMPONENTREPOSITORY___OUT_CH_)
#define _IR_COMPONENTREPOSITORY___OUT_CH_
  
  class TAO_IFR_Client_Export ComponentRepository_out
  {
  public:
    ComponentRepository_out (ComponentRepository_ptr &);
    ComponentRepository_out (ComponentRepository_var &);
    ComponentRepository_out (const ComponentRepository_out &);
    ComponentRepository_out &operator= (const ComponentRepository_out &);
    ComponentRepository_out &operator= (const ComponentRepository_var &);
    ComponentRepository_out &operator= (ComponentRepository_ptr);
    operator ComponentRepository_ptr &();
    ComponentRepository_ptr &ptr (void);
    ComponentRepository_ptr operator-> (void);
  
  private:
    ComponentRepository_ptr &ptr_;
  };
  
  
#endif /* end #if !defined */
  
  
#if !defined (_IR_COMPONENTREPOSITORY_CH_)
#define _IR_COMPONENTREPOSITORY_CH_
  
  // Forward Classes Declaration
  class _TAO_ComponentRepository_Proxy_Impl;
  class _TAO_ComponentRepository_Remote_Proxy_Impl;
  class _TAO_ComponentRepository_Proxy_Broker;
  class _TAO_ComponentRepository_Remote_Proxy_Broker;
  
  class TAO_IFR_Client_Export ComponentRepository
    : public virtual CORBA_Repository
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef ComponentRepository_ptr _ptr_type;
    typedef ComponentRepository_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

    // the static operations
    static ComponentRepository_ptr _duplicate (ComponentRepository_ptr obj);
    
    static ComponentRepository_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      );
    
    static ComponentRepository_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      );
    
    static ComponentRepository_ptr _nil (void)
      {
        return (ComponentRepository_ptr)0;
      }
    
    static void _tao_any_destructor (void*);
    
    virtual IR::ComponentDef_ptr create_component (
        const char * id,
        const char * name,
        const char * version,
        IR::ComponentDef_ptr base_component,
        const CORBA_InterfaceDefSeq & supports_interfaces,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
    
    virtual IR::HomeDef_ptr create_home (
        const char * id,
        const char * name,
        const char * version,
        IR::HomeDef_ptr base_home,
        IR::ComponentDef_ptr managed_component,
        CORBA_ValueDef_ptr primary_key,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
    
    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id, 
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      );
    
    virtual void *_tao_QueryInterface (ptr_arith_t type);
    
    virtual const char* _interface_repository_id (void) const;

  private:
    _TAO_ComponentRepository_Proxy_Broker *the_TAO_ComponentRepository_Proxy_Broker_;
    
  protected:
    ComponentRepository (int collocated = 0);
    
    // This methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode
    virtual void IR_ComponentRepository_setup_collocation (int collocated);
    
    ComponentRepository (
        TAO_Stub *objref, 
        CORBA::Boolean _tao_collocated = 0,
        TAO_Abstract_ServantBase *servant = 0
      );
    
    friend class _TAO_ComponentRepository_Remote_Proxy_Impl;
    friend class _TAO_ComponentRepository_ThruPOA_Proxy_Impl;
    friend class _TAO_ComponentRepository_Direct_Proxy_Impl;
    
    virtual ~ComponentRepository (void);
  
  private:
    ComponentRepository (const ComponentRepository &);
    void operator= (const ComponentRepository &);
  };
  
  // The Proxy Implementations are used by each interface to
  // perform a call. Each different implementation encapsulate
  // an invocation logics.
  
  
  ///////////////////////////////////////////////////////////////////////
  //                    Base Proxy Impl. Declaration
  //
  
  class TAO_IFR_Client_Export _TAO_ComponentRepository_Proxy_Impl
    : public virtual _TAO_CORBA_Repository_Proxy_Impl
  {
  public:
    virtual ~_TAO_ComponentRepository_Proxy_Impl (void) { }
    virtual IR::ComponentDef_ptr create_component (
        CORBA_Object *_collocated_tao_target_,
        const char * id,
        const char * name,
        const char * version,
        IR::ComponentDef_ptr base_component,
        const CORBA_InterfaceDefSeq & supports_interfaces,
        CORBA::Environment &ACE_TRY_ENV
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;
    
    virtual IR::HomeDef_ptr create_home (
        CORBA_Object *_collocated_tao_target_,
        const char * id,
        const char * name,
        const char * version,
        IR::HomeDef_ptr base_home,
        IR::ComponentDef_ptr managed_component,
        CORBA_ValueDef_ptr primary_key,
        CORBA::Environment &ACE_TRY_ENV
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;
    
    
  protected:
    _TAO_ComponentRepository_Proxy_Impl (void);
  };
  
  //
  //               End Base Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////
  
  
  ///////////////////////////////////////////////////////////////////////
  //                Remote Proxy Impl. Declaration
  //
  
  class TAO_IFR_Client_Export _TAO_ComponentRepository_Remote_Proxy_Impl
    : public virtual _TAO_ComponentRepository_Proxy_Impl,
      public virtual TAO_Remote_Object_Proxy_Impl,
      public virtual _TAO_CORBA_Repository_Remote_Proxy_Impl
  {
  public:
    _TAO_ComponentRepository_Remote_Proxy_Impl (void);
    
    virtual ~_TAO_ComponentRepository_Remote_Proxy_Impl (void) { }
    virtual IR::ComponentDef_ptr create_component (
        CORBA_Object *_collocated_tao_target_,
        const char * id,
        const char * name,
        const char * version,
        IR::ComponentDef_ptr base_component,
        const CORBA_InterfaceDefSeq & supports_interfaces,
        CORBA::Environment &ACE_TRY_ENV
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
    
    virtual IR::HomeDef_ptr create_home (
        CORBA_Object *_collocated_tao_target_,
        const char * id,
        const char * name,
        const char * version,
        IR::HomeDef_ptr base_home,
        IR::ComponentDef_ptr managed_component,
        CORBA_ValueDef_ptr primary_key,
        CORBA::Environment &ACE_TRY_ENV
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
    
    
  };
  
  //
  //             End Remote Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////
  
  // The Proxy Brokers are used by each interface to get
  // the right proxy for performing a call. In the new 
  // collocation scheme, the proxy to be used can vary on
  // a call by call basis.
  
  
  ///////////////////////////////////////////////////////////////////////
  //                 Base Proxy Broker Declaration 
  //
  
    class TAO_IFR_Client_Export _TAO_ComponentRepository_Proxy_Broker
  {
  public:
    virtual ~_TAO_ComponentRepository_Proxy_Broker (void);
    virtual _TAO_ComponentRepository_Proxy_Impl &select_proxy (
        ComponentRepository *object,
        CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
      ) = 0;
    
  protected:
    _TAO_ComponentRepository_Proxy_Broker (void);
    
  };
  
  //
  //              End Base Proxy Broker Declaration 
  ///////////////////////////////////////////////////////////////////////
  
    
  ///////////////////////////////////////////////////////////////////////
  //                 Remote Proxy Broker Declaration 
  //
  
  class TAO_IFR_Client_Export _TAO_ComponentRepository_Remote_Proxy_Broker
    : public virtual _TAO_ComponentRepository_Proxy_Broker
  {
  public: 
    _TAO_ComponentRepository_Remote_Proxy_Broker (void);
    
    virtual ~_TAO_ComponentRepository_Remote_Proxy_Broker (void);
    
    virtual _TAO_ComponentRepository_Proxy_Impl &select_proxy (
        ComponentRepository *object,
        CORBA_Environment &ACE_TRY_ENV
      );
    
    private:
      _TAO_ComponentRepository_Remote_Proxy_Impl remote_proxy_impl_;
    
    public:
      // This member function is used to get an handle to the unique instance
      // of the Remote Proxy Broker that is available for a given
      // interface.
      static _TAO_ComponentRepository_Remote_Proxy_Broker *the_TAO_ComponentRepository_Remote_Proxy_Broker (void);
    };
    
    //
    //              End Remote Proxy Broker Declaration 
    ///////////////////////////////////////////////////////////////////////
    
    
#endif /* end #if !defined */
    
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ComponentRepository;
    
    
#if !defined (_IR_PROVIDESDEF_CH_)
#define _IR_PROVIDESDEF_CH_
    
    // Forward Classes Declaration
    class _TAO_ProvidesDef_Proxy_Impl;
    class _TAO_ProvidesDef_Remote_Proxy_Impl;
    class _TAO_ProvidesDef_Proxy_Broker;
    class _TAO_ProvidesDef_Remote_Proxy_Broker;
    
    class TAO_IFR_Client_Export ProvidesDef
      : public virtual CORBA_Contained
    {
    public:
    #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
      typedef ProvidesDef_ptr _ptr_type;
      typedef ProvidesDef_var _var_type;
    #endif /* ! __GNUC__ || g++ >= 2.8 */

      // the static operations
      static ProvidesDef_ptr _duplicate (ProvidesDef_ptr obj);
      
      static ProvidesDef_ptr _narrow (
          CORBA::Object_ptr obj,
          CORBA::Environment &ACE_TRY_ENV = 
            TAO_default_environment ()
        );
      
      static ProvidesDef_ptr _unchecked_narrow (
          CORBA::Object_ptr obj,
          CORBA::Environment &ACE_TRY_ENV = 
            TAO_default_environment ()
        );
      
      static ProvidesDef_ptr _nil (void)
        {
          return (ProvidesDef_ptr)0;
        }
      
      static void _tao_any_destructor (void*);
      
      virtual CORBA_InterfaceDef_ptr interface_type (
          CORBA::Environment &ACE_TRY_ENV = 
            TAO_default_environment ()
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));
      
      virtual CORBA::Boolean _is_a (
          const CORBA::Char *type_id, 
          CORBA::Environment &ACE_TRY_ENV = 
            TAO_default_environment ()
        );
      
      virtual void *_tao_QueryInterface (ptr_arith_t type);
      
      virtual const char* _interface_repository_id (void) const;

    private:
      _TAO_ProvidesDef_Proxy_Broker *the_TAO_ProvidesDef_Proxy_Broker_;
      
    protected:
      ProvidesDef (int collocated = 0);
      
      // This methods travese the inheritance tree and set the
      // parents piece of the given class in the right mode
      virtual void IR_ProvidesDef_setup_collocation (int collocated);
      
      ProvidesDef (
          TAO_Stub *objref, 
          CORBA::Boolean _tao_collocated = 0,
          TAO_Abstract_ServantBase *servant = 0
        );
      
      friend class _TAO_ProvidesDef_Remote_Proxy_Impl;
      friend class _TAO_ProvidesDef_ThruPOA_Proxy_Impl;
      friend class _TAO_ProvidesDef_Direct_Proxy_Impl;
      
      virtual ~ProvidesDef (void);
    
    private:
      ProvidesDef (const ProvidesDef &);
      void operator= (const ProvidesDef &);
    };
    
    // The Proxy Implementations are used by each interface to
    // perform a call. Each different implementation encapsulate
    // an invocation logics.
    
    
    ///////////////////////////////////////////////////////////////////////
    //                    Base Proxy Impl. Declaration
    //
    
    class TAO_IFR_Client_Export _TAO_ProvidesDef_Proxy_Impl
      : public virtual _TAO_CORBA_Contained_Proxy_Impl
    {
    public:
      virtual ~_TAO_ProvidesDef_Proxy_Impl (void) { }
      virtual CORBA_InterfaceDef_ptr interface_type (
          CORBA_Object *_collocated_tao_target_,
          CORBA::Environment &ACE_TRY_ENV
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;
      
      
    protected:
      _TAO_ProvidesDef_Proxy_Impl (void);
    };
    
    //
    //               End Base Proxy Impl. Declaration
    ///////////////////////////////////////////////////////////////////////
    
    
    ///////////////////////////////////////////////////////////////////////
    //                Remote Proxy Impl. Declaration
    //
    
    class TAO_IFR_Client_Export _TAO_ProvidesDef_Remote_Proxy_Impl
      : public virtual _TAO_ProvidesDef_Proxy_Impl,
        public virtual TAO_Remote_Object_Proxy_Impl,
        public virtual _TAO_CORBA_Contained_Remote_Proxy_Impl
    {
    public:
      _TAO_ProvidesDef_Remote_Proxy_Impl (void);
      
      virtual ~_TAO_ProvidesDef_Remote_Proxy_Impl (void) { }
      virtual CORBA_InterfaceDef_ptr interface_type (
          CORBA_Object *_collocated_tao_target_,
          CORBA::Environment &ACE_TRY_ENV
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));
      
      
    };
    
    //
    //             End Remote Proxy Impl. Declaration
    ///////////////////////////////////////////////////////////////////////
    
    // The Proxy Brokers are used by each interface to get
    // the right proxy for performing a call. In the new 
    // collocation scheme, the proxy to be used can vary on
    // a call by call basis.
    
    
    ///////////////////////////////////////////////////////////////////////
    //                 Base Proxy Broker Declaration 
    //
    
        class TAO_IFR_Client_Export _TAO_ProvidesDef_Proxy_Broker
    {
    public:
      virtual ~_TAO_ProvidesDef_Proxy_Broker (void);
      virtual _TAO_ProvidesDef_Proxy_Impl &select_proxy (
          ProvidesDef *object,
          CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
        ) = 0;
      
    protected:
      _TAO_ProvidesDef_Proxy_Broker (void);
      
    };
    
    //
    //              End Base Proxy Broker Declaration 
    ///////////////////////////////////////////////////////////////////////
    
        
    ///////////////////////////////////////////////////////////////////////
    //                 Remote Proxy Broker Declaration 
    //
    
    class TAO_IFR_Client_Export _TAO_ProvidesDef_Remote_Proxy_Broker
      : public virtual _TAO_ProvidesDef_Proxy_Broker
    {
    public: 
      _TAO_ProvidesDef_Remote_Proxy_Broker (void);
      
      virtual ~_TAO_ProvidesDef_Remote_Proxy_Broker (void);
      
      virtual _TAO_ProvidesDef_Proxy_Impl &select_proxy (
          ProvidesDef *object,
          CORBA_Environment &ACE_TRY_ENV
        );
      
      private:
        _TAO_ProvidesDef_Remote_Proxy_Impl remote_proxy_impl_;
      
      public:
        // This member function is used to get an handle to the unique instance
        // of the Remote Proxy Broker that is available for a given
        // interface.
        static _TAO_ProvidesDef_Remote_Proxy_Broker *the_TAO_ProvidesDef_Remote_Proxy_Broker (void);
      };
      
      //
      //              End Remote Proxy Broker Declaration 
      ///////////////////////////////////////////////////////////////////////
      
      
#endif /* end #if !defined */
      
      TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ProvidesDef;
      
      struct ProvidesDescription;
      class ProvidesDescription_var;
      
      struct TAO_IFR_Client_Export ProvidesDescription
      {
        
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
        typedef ProvidesDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

        static void _tao_any_destructor (void*);
        
        TAO_String_Manager name;
        TAO_String_Manager id;
        TAO_String_Manager defined_in;
        TAO_String_Manager version;
        CORBA_InterfaceDef_var interface_type;
        
      };
      
      class TAO_IFR_Client_Export ProvidesDescription_var
      {
      public:
        ProvidesDescription_var (void);
        ProvidesDescription_var (ProvidesDescription *);
        ProvidesDescription_var (const ProvidesDescription_var &);
        ~ProvidesDescription_var (void);
        
        ProvidesDescription_var &operator= (ProvidesDescription *);
        ProvidesDescription_var &operator= (const ProvidesDescription_var &);
        ProvidesDescription *operator-> (void);
        const ProvidesDescription *operator-> (void) const;
        
        operator const ProvidesDescription &() const;
        operator ProvidesDescription &();
        operator ProvidesDescription &() const;
        // Variable-size types only.
        operator ProvidesDescription *&();
        
        // in, inout, out, _retn 
        const ProvidesDescription &in (void) const;
        ProvidesDescription &inout (void);
        ProvidesDescription *&out (void);
        ProvidesDescription *_retn (void);
        ProvidesDescription *ptr (void) const;
      
      private:
        ProvidesDescription *ptr_;
      };
      
      class TAO_IFR_Client_Export ProvidesDescription_out
      {
      public:
        ProvidesDescription_out (ProvidesDescription *&);
        ProvidesDescription_out (ProvidesDescription_var &);
        ProvidesDescription_out (const ProvidesDescription_out &);
        ProvidesDescription_out &operator= (const ProvidesDescription_out &);
        ProvidesDescription_out &operator= (ProvidesDescription *);
        operator ProvidesDescription *&();
        ProvidesDescription *&ptr (void);
        ProvidesDescription *operator-> (void);
        
      private:
        ProvidesDescription *&ptr_;
        // Assignment from T_var not allowed.
        void operator= (const ProvidesDescription_var &);
      };
      
      TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ProvidesDescription;
      
      
#if !defined (_IR_USESDEF_CH_)
#define _IR_USESDEF_CH_
      
      // Forward Classes Declaration
      class _TAO_UsesDef_Proxy_Impl;
      class _TAO_UsesDef_Remote_Proxy_Impl;
      class _TAO_UsesDef_Proxy_Broker;
      class _TAO_UsesDef_Remote_Proxy_Broker;
      
      class TAO_IFR_Client_Export UsesDef
        : public virtual CORBA_Contained
      {
      public:
      #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
        typedef UsesDef_ptr _ptr_type;
        typedef UsesDef_var _var_type;
      #endif /* ! __GNUC__ || g++ >= 2.8 */

        // the static operations
        static UsesDef_ptr _duplicate (UsesDef_ptr obj);
        
        static UsesDef_ptr _narrow (
            CORBA::Object_ptr obj,
            CORBA::Environment &ACE_TRY_ENV = 
              TAO_default_environment ()
          );
        
        static UsesDef_ptr _unchecked_narrow (
            CORBA::Object_ptr obj,
            CORBA::Environment &ACE_TRY_ENV = 
              TAO_default_environment ()
          );
        
        static UsesDef_ptr _nil (void)
          {
            return (UsesDef_ptr)0;
          }
        
        static void _tao_any_destructor (void*);
        
        virtual CORBA_InterfaceDef_ptr interface_type (
            CORBA::Environment &ACE_TRY_ENV = 
              TAO_default_environment ()
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        virtual CORBA::Boolean is_multiple (
            CORBA::Environment &ACE_TRY_ENV = 
              TAO_default_environment ()
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        virtual CORBA::Boolean _is_a (
            const CORBA::Char *type_id, 
            CORBA::Environment &ACE_TRY_ENV = 
              TAO_default_environment ()
          );
        
        virtual void *_tao_QueryInterface (ptr_arith_t type);
        
        virtual const char* _interface_repository_id (void) const;

      private:
        _TAO_UsesDef_Proxy_Broker *the_TAO_UsesDef_Proxy_Broker_;
        
      protected:
        UsesDef (int collocated = 0);
        
        // This methods travese the inheritance tree and set the
        // parents piece of the given class in the right mode
        virtual void IR_UsesDef_setup_collocation (int collocated);
        
        UsesDef (
            TAO_Stub *objref, 
            CORBA::Boolean _tao_collocated = 0,
            TAO_Abstract_ServantBase *servant = 0
          );
        
        friend class _TAO_UsesDef_Remote_Proxy_Impl;
        friend class _TAO_UsesDef_ThruPOA_Proxy_Impl;
        friend class _TAO_UsesDef_Direct_Proxy_Impl;
        
        virtual ~UsesDef (void);
      
      private:
        UsesDef (const UsesDef &);
        void operator= (const UsesDef &);
      };
      
      // The Proxy Implementations are used by each interface to
      // perform a call. Each different implementation encapsulate
      // an invocation logics.
      
      
      ///////////////////////////////////////////////////////////////////////
      //                    Base Proxy Impl. Declaration
      //
      
      class TAO_IFR_Client_Export _TAO_UsesDef_Proxy_Impl
        : public virtual _TAO_CORBA_Contained_Proxy_Impl
      {
      public:
        virtual ~_TAO_UsesDef_Proxy_Impl (void) { }
        virtual CORBA_InterfaceDef_ptr interface_type (
            CORBA_Object *_collocated_tao_target_,
            CORBA::Environment &ACE_TRY_ENV
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          )) = 0;
        
        virtual CORBA::Boolean is_multiple (
            CORBA_Object *_collocated_tao_target_,
            CORBA::Environment &ACE_TRY_ENV
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          )) = 0;
        
        
      protected:
        _TAO_UsesDef_Proxy_Impl (void);
      };
      
      //
      //               End Base Proxy Impl. Declaration
      ///////////////////////////////////////////////////////////////////////
      
      
      ///////////////////////////////////////////////////////////////////////
      //                Remote Proxy Impl. Declaration
      //
      
      class TAO_IFR_Client_Export _TAO_UsesDef_Remote_Proxy_Impl
        : public virtual _TAO_UsesDef_Proxy_Impl,
          public virtual TAO_Remote_Object_Proxy_Impl,
          public virtual _TAO_CORBA_Contained_Remote_Proxy_Impl
      {
      public:
        _TAO_UsesDef_Remote_Proxy_Impl (void);
        
        virtual ~_TAO_UsesDef_Remote_Proxy_Impl (void) { }
        virtual CORBA_InterfaceDef_ptr interface_type (
            CORBA_Object *_collocated_tao_target_,
            CORBA::Environment &ACE_TRY_ENV
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        virtual CORBA::Boolean is_multiple (
            CORBA_Object *_collocated_tao_target_,
            CORBA::Environment &ACE_TRY_ENV
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        
      };
      
      //
      //             End Remote Proxy Impl. Declaration
      ///////////////////////////////////////////////////////////////////////
      
      // The Proxy Brokers are used by each interface to get
      // the right proxy for performing a call. In the new 
      // collocation scheme, the proxy to be used can vary on
      // a call by call basis.
      
      
      ///////////////////////////////////////////////////////////////////////
      //                 Base Proxy Broker Declaration 
      //
      
            class TAO_IFR_Client_Export _TAO_UsesDef_Proxy_Broker
      {
      public:
        virtual ~_TAO_UsesDef_Proxy_Broker (void);
        virtual _TAO_UsesDef_Proxy_Impl &select_proxy (
            UsesDef *object,
            CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
          ) = 0;
        
      protected:
        _TAO_UsesDef_Proxy_Broker (void);
        
      };
      
      //
      //              End Base Proxy Broker Declaration 
      ///////////////////////////////////////////////////////////////////////
      
            
      ///////////////////////////////////////////////////////////////////////
      //                 Remote Proxy Broker Declaration 
      //
      
      class TAO_IFR_Client_Export _TAO_UsesDef_Remote_Proxy_Broker
        : public virtual _TAO_UsesDef_Proxy_Broker
      {
      public: 
        _TAO_UsesDef_Remote_Proxy_Broker (void);
        
        virtual ~_TAO_UsesDef_Remote_Proxy_Broker (void);
        
        virtual _TAO_UsesDef_Proxy_Impl &select_proxy (
            UsesDef *object,
            CORBA_Environment &ACE_TRY_ENV
          );
        
        private:
          _TAO_UsesDef_Remote_Proxy_Impl remote_proxy_impl_;
        
        public:
          // This member function is used to get an handle to the unique instance
          // of the Remote Proxy Broker that is available for a given
          // interface.
          static _TAO_UsesDef_Remote_Proxy_Broker *the_TAO_UsesDef_Remote_Proxy_Broker (void);
        };
        
        //
        //              End Remote Proxy Broker Declaration 
        ///////////////////////////////////////////////////////////////////////
        
        
#endif /* end #if !defined */
        
        TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_UsesDef;
        
        struct UsesDescription;
        class UsesDescription_var;
        
        struct TAO_IFR_Client_Export UsesDescription
        {
          
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
          typedef UsesDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

          static void _tao_any_destructor (void*);
          
          TAO_String_Manager name;
          TAO_String_Manager id;
          TAO_String_Manager defined_in;
          TAO_String_Manager version;
          CORBA_InterfaceDef_var interface_type;
          CORBA::Boolean is_multiple;
          
        };
        
        class TAO_IFR_Client_Export UsesDescription_var
        {
        public:
          UsesDescription_var (void);
          UsesDescription_var (UsesDescription *);
          UsesDescription_var (const UsesDescription_var &);
          ~UsesDescription_var (void);
          
          UsesDescription_var &operator= (UsesDescription *);
          UsesDescription_var &operator= (const UsesDescription_var &);
          UsesDescription *operator-> (void);
          const UsesDescription *operator-> (void) const;
          
          operator const UsesDescription &() const;
          operator UsesDescription &();
          operator UsesDescription &() const;
          // Variable-size types only.
          operator UsesDescription *&();
          
          // in, inout, out, _retn 
          const UsesDescription &in (void) const;
          UsesDescription &inout (void);
          UsesDescription *&out (void);
          UsesDescription *_retn (void);
          UsesDescription *ptr (void) const;
        
        private:
          UsesDescription *ptr_;
        };
        
        class TAO_IFR_Client_Export UsesDescription_out
        {
        public:
          UsesDescription_out (UsesDescription *&);
          UsesDescription_out (UsesDescription_var &);
          UsesDescription_out (const UsesDescription_out &);
          UsesDescription_out &operator= (const UsesDescription_out &);
          UsesDescription_out &operator= (UsesDescription *);
          operator UsesDescription *&();
          UsesDescription *&ptr (void);
          UsesDescription *operator-> (void);
          
        private:
          UsesDescription *&ptr_;
          // Assignment from T_var not allowed.
          void operator= (const UsesDescription_var &);
        };
        
        TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_UsesDescription;
        
        
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
        
#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_PROVIDESDESCSEQ_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_IR_PROVIDESDESCSEQ_CH_
        
        class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_IR_ProvidesDescSeq
          : public TAO_Unbounded_Base_Sequence
        {
        public:
          // = Initialization and termination methods.
          _TAO_Unbounded_Sequence_IR_ProvidesDescSeq (void);
          _TAO_Unbounded_Sequence_IR_ProvidesDescSeq (CORBA::ULong maximum); 
          _TAO_Unbounded_Sequence_IR_ProvidesDescSeq (
              CORBA::ULong maximum,
              CORBA::ULong length,
              ProvidesDescription *data,
              CORBA::Boolean release = 0
            );
          _TAO_Unbounded_Sequence_IR_ProvidesDescSeq (
              const _TAO_Unbounded_Sequence_IR_ProvidesDescSeq &rhs
            );
          _TAO_Unbounded_Sequence_IR_ProvidesDescSeq &operator= (
              const _TAO_Unbounded_Sequence_IR_ProvidesDescSeq &rhs
            );
          virtual ~_TAO_Unbounded_Sequence_IR_ProvidesDescSeq (void);
          
          // = Accessors.
          ProvidesDescription &operator[] (CORBA::ULong i);
          const ProvidesDescription &operator[] (CORBA::ULong i) const;
          
          // = Static operations.
          static ProvidesDescription *allocbuf (CORBA::ULong size);
          static void freebuf (ProvidesDescription *buffer);
          
          // Implement the TAO_Base_Sequence methods (see Sequence.h)
          virtual void _allocate_buffer (CORBA::ULong length);
          virtual void _deallocate_buffer (void);
          ProvidesDescription *get_buffer (CORBA::Boolean orphan = 0);
          const ProvidesDescription *get_buffer (void) const;
          void replace (
              CORBA::ULong max,
              CORBA::ULong length,
              ProvidesDescription *data,
              CORBA::Boolean release
            );
        };
        
#endif /* end #if !defined */
        
        
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
        
#if !defined (_IR_PROVIDESDESCSEQ_CH_)
#define _IR_PROVIDESDESCSEQ_CH_
        
        class ProvidesDescSeq;
        class ProvidesDescSeq_var;
        
        // *************************************************************
        // ProvidesDescSeq
        // *************************************************************
        
        class TAO_IFR_Client_Export ProvidesDescSeq : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
        _TAO_Unbounded_Sequence_IR_ProvidesDescSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
        TAO_Unbounded_Sequence<ProvidesDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
        {
        public:
          ProvidesDescSeq (void); // default ctor
          ProvidesDescSeq (CORBA::ULong max); // uses max size
          ProvidesDescSeq (
              CORBA::ULong max, 
              CORBA::ULong length, 
              ProvidesDescription *buffer, 
              CORBA::Boolean release = 0
            );
          ProvidesDescSeq (const ProvidesDescSeq &); // copy ctor
          ~ProvidesDescSeq (void);
          static void _tao_any_destructor (void*);
          
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
          typedef ProvidesDescSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */
          
          
        };
        
#endif /* end #if !defined */
        
        
#if !defined (_IR_PROVIDESDESCSEQ___VAR_CH_)
#define _IR_PROVIDESDESCSEQ___VAR_CH_
        
        // *************************************************************
        // class IR::ProvidesDescSeq_var
        // *************************************************************
        
        class TAO_IFR_Client_Export ProvidesDescSeq_var
        {
        public:
          ProvidesDescSeq_var (void);
          ProvidesDescSeq_var (ProvidesDescSeq *);
          ProvidesDescSeq_var (const ProvidesDescSeq_var &);
          ~ProvidesDescSeq_var (void);
          
          ProvidesDescSeq_var &operator= (ProvidesDescSeq *);
          ProvidesDescSeq_var &operator= (const ProvidesDescSeq_var &);
          ProvidesDescSeq *operator-> (void);
          const ProvidesDescSeq *operator-> (void) const;
          
          operator const ProvidesDescSeq &() const;
          operator ProvidesDescSeq &();
          operator ProvidesDescSeq &() const;
          operator ProvidesDescSeq *&(); // variable-size base types only
          
          ProvidesDescription & operator[] (CORBA::ULong index);
          const ProvidesDescription & operator[] (CORBA::ULong index) const;
          
          // in, inout, out, _retn 
          const ProvidesDescSeq &in (void) const;
          ProvidesDescSeq &inout (void);
          ProvidesDescSeq *&out (void);
          ProvidesDescSeq *_retn (void);
          ProvidesDescSeq *ptr (void) const;
        
        private:
          ProvidesDescSeq *ptr_;
        };
        
        
#endif /* end #if !defined */
        
        
#if !defined (_IR_PROVIDESDESCSEQ___OUT_CH_)
#define _IR_PROVIDESDESCSEQ___OUT_CH_
        
        class TAO_IFR_Client_Export ProvidesDescSeq_out
        {
        public:
          ProvidesDescSeq_out (ProvidesDescSeq *&);
          ProvidesDescSeq_out (ProvidesDescSeq_var &);
          ProvidesDescSeq_out (const ProvidesDescSeq_out &);
          ProvidesDescSeq_out &operator= (const ProvidesDescSeq_out &);
          ProvidesDescSeq_out &operator= (ProvidesDescSeq *);
          operator ProvidesDescSeq *&();
          ProvidesDescSeq *&ptr (void);
          ProvidesDescSeq *operator-> (void);
          ProvidesDescription & operator[] (CORBA::ULong index);
        
        private:
          ProvidesDescSeq *&ptr_;
          // Assignment from T_var not allowed.
          void operator= (const ProvidesDescSeq_var &);
        };
        
        
#endif /* end #if !defined */
        
        TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ProvidesDescSeq;
        
        
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
        
#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_USESDESCSEQ_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_IR_USESDESCSEQ_CH_
        
        class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_IR_UsesDescSeq
          : public TAO_Unbounded_Base_Sequence
        {
        public:
          // = Initialization and termination methods.
          _TAO_Unbounded_Sequence_IR_UsesDescSeq (void);
          _TAO_Unbounded_Sequence_IR_UsesDescSeq (CORBA::ULong maximum); 
          _TAO_Unbounded_Sequence_IR_UsesDescSeq (
              CORBA::ULong maximum,
              CORBA::ULong length,
              UsesDescription *data,
              CORBA::Boolean release = 0
            );
          _TAO_Unbounded_Sequence_IR_UsesDescSeq (
              const _TAO_Unbounded_Sequence_IR_UsesDescSeq &rhs
            );
          _TAO_Unbounded_Sequence_IR_UsesDescSeq &operator= (
              const _TAO_Unbounded_Sequence_IR_UsesDescSeq &rhs
            );
          virtual ~_TAO_Unbounded_Sequence_IR_UsesDescSeq (void);
          
          // = Accessors.
          UsesDescription &operator[] (CORBA::ULong i);
          const UsesDescription &operator[] (CORBA::ULong i) const;
          
          // = Static operations.
          static UsesDescription *allocbuf (CORBA::ULong size);
          static void freebuf (UsesDescription *buffer);
          
          // Implement the TAO_Base_Sequence methods (see Sequence.h)
          virtual void _allocate_buffer (CORBA::ULong length);
          virtual void _deallocate_buffer (void);
          UsesDescription *get_buffer (CORBA::Boolean orphan = 0);
          const UsesDescription *get_buffer (void) const;
          void replace (
              CORBA::ULong max,
              CORBA::ULong length,
              UsesDescription *data,
              CORBA::Boolean release
            );
        };
        
#endif /* end #if !defined */
        
        
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
        
#if !defined (_IR_USESDESCSEQ_CH_)
#define _IR_USESDESCSEQ_CH_
        
        class UsesDescSeq;
        class UsesDescSeq_var;
        
        // *************************************************************
        // UsesDescSeq
        // *************************************************************
        
        class TAO_IFR_Client_Export UsesDescSeq : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
        _TAO_Unbounded_Sequence_IR_UsesDescSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
        TAO_Unbounded_Sequence<UsesDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
        {
        public:
          UsesDescSeq (void); // default ctor
          UsesDescSeq (CORBA::ULong max); // uses max size
          UsesDescSeq (
              CORBA::ULong max, 
              CORBA::ULong length, 
              UsesDescription *buffer, 
              CORBA::Boolean release = 0
            );
          UsesDescSeq (const UsesDescSeq &); // copy ctor
          ~UsesDescSeq (void);
          static void _tao_any_destructor (void*);
          
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
          typedef UsesDescSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */
          
          
        };
        
#endif /* end #if !defined */
        
        
#if !defined (_IR_USESDESCSEQ___VAR_CH_)
#define _IR_USESDESCSEQ___VAR_CH_
        
        // *************************************************************
        // class IR::UsesDescSeq_var
        // *************************************************************
        
        class TAO_IFR_Client_Export UsesDescSeq_var
        {
        public:
          UsesDescSeq_var (void);
          UsesDescSeq_var (UsesDescSeq *);
          UsesDescSeq_var (const UsesDescSeq_var &);
          ~UsesDescSeq_var (void);
          
          UsesDescSeq_var &operator= (UsesDescSeq *);
          UsesDescSeq_var &operator= (const UsesDescSeq_var &);
          UsesDescSeq *operator-> (void);
          const UsesDescSeq *operator-> (void) const;
          
          operator const UsesDescSeq &() const;
          operator UsesDescSeq &();
          operator UsesDescSeq &() const;
          operator UsesDescSeq *&(); // variable-size base types only
          
          UsesDescription & operator[] (CORBA::ULong index);
          const UsesDescription & operator[] (CORBA::ULong index) const;
          
          // in, inout, out, _retn 
          const UsesDescSeq &in (void) const;
          UsesDescSeq &inout (void);
          UsesDescSeq *&out (void);
          UsesDescSeq *_retn (void);
          UsesDescSeq *ptr (void) const;
        
        private:
          UsesDescSeq *ptr_;
        };
        
        
#endif /* end #if !defined */
        
        
#if !defined (_IR_USESDESCSEQ___OUT_CH_)
#define _IR_USESDESCSEQ___OUT_CH_
        
        class TAO_IFR_Client_Export UsesDescSeq_out
        {
        public:
          UsesDescSeq_out (UsesDescSeq *&);
          UsesDescSeq_out (UsesDescSeq_var &);
          UsesDescSeq_out (const UsesDescSeq_out &);
          UsesDescSeq_out &operator= (const UsesDescSeq_out &);
          UsesDescSeq_out &operator= (UsesDescSeq *);
          operator UsesDescSeq *&();
          UsesDescSeq *&ptr (void);
          UsesDescSeq *operator-> (void);
          UsesDescription & operator[] (CORBA::ULong index);
        
        private:
          UsesDescSeq *&ptr_;
          // Assignment from T_var not allowed.
          void operator= (const UsesDescSeq_var &);
        };
        
        
#endif /* end #if !defined */
        
        TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_UsesDescSeq;
        
        
#if !defined (_IR_EVENTDEF_CH_)
#define _IR_EVENTDEF_CH_
        
        // Forward Classes Declaration
        class _TAO_EventDef_Proxy_Impl;
        class _TAO_EventDef_Remote_Proxy_Impl;
        class _TAO_EventDef_Proxy_Broker;
        class _TAO_EventDef_Remote_Proxy_Broker;
        
        class TAO_IFR_Client_Export EventDef
          : public virtual CORBA_Contained
        {
        public:
        #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
          typedef EventDef_ptr _ptr_type;
          typedef EventDef_var _var_type;
        #endif /* ! __GNUC__ || g++ >= 2.8 */

          // the static operations
          static EventDef_ptr _duplicate (EventDef_ptr obj);
          
          static EventDef_ptr _narrow (
              CORBA::Object_ptr obj,
              CORBA::Environment &ACE_TRY_ENV = 
                TAO_default_environment ()
            );
          
          static EventDef_ptr _unchecked_narrow (
              CORBA::Object_ptr obj,
              CORBA::Environment &ACE_TRY_ENV = 
                TAO_default_environment ()
            );
          
          static EventDef_ptr _nil (void)
            {
              return (EventDef_ptr)0;
            }
          
          static void _tao_any_destructor (void*);
          
          virtual CORBA::Boolean is_a (
              const char * event_id,
              CORBA::Environment &ACE_TRY_ENV = 
                TAO_default_environment ()
            )
            ACE_THROW_SPEC ((
              CORBA::SystemException
            ));
          
          virtual CORBA_ValueDef_ptr event (
              CORBA::Environment &ACE_TRY_ENV = 
                TAO_default_environment ()
            )
            ACE_THROW_SPEC ((
              CORBA::SystemException
            ));
          
          virtual CORBA::Boolean _is_a (
              const CORBA::Char *type_id, 
              CORBA::Environment &ACE_TRY_ENV = 
                TAO_default_environment ()
            );
          
          virtual void *_tao_QueryInterface (ptr_arith_t type);
          
          virtual const char* _interface_repository_id (void) const;

        private:
          _TAO_EventDef_Proxy_Broker *the_TAO_EventDef_Proxy_Broker_;
          
        protected:
          EventDef (int collocated = 0);
          
          // This methods travese the inheritance tree and set the
          // parents piece of the given class in the right mode
          virtual void IR_EventDef_setup_collocation (int collocated);
          
          EventDef (
              TAO_Stub *objref, 
              CORBA::Boolean _tao_collocated = 0,
              TAO_Abstract_ServantBase *servant = 0
            );
          
          friend class _TAO_EventDef_Remote_Proxy_Impl;
          friend class _TAO_EventDef_ThruPOA_Proxy_Impl;
          friend class _TAO_EventDef_Direct_Proxy_Impl;
          
          virtual ~EventDef (void);
        
        private:
          EventDef (const EventDef &);
          void operator= (const EventDef &);
        };
        
        // The Proxy Implementations are used by each interface to
        // perform a call. Each different implementation encapsulate
        // an invocation logics.
        
        
        ///////////////////////////////////////////////////////////////////////
        //                    Base Proxy Impl. Declaration
        //
        
        class TAO_IFR_Client_Export _TAO_EventDef_Proxy_Impl
          : public virtual _TAO_CORBA_Contained_Proxy_Impl
        {
        public:
          virtual ~_TAO_EventDef_Proxy_Impl (void) { }
          virtual CORBA::Boolean is_a (
              CORBA_Object *_collocated_tao_target_,
              const char * event_id,
              CORBA::Environment &ACE_TRY_ENV
            )
            ACE_THROW_SPEC ((
              CORBA::SystemException
            )) = 0;
          
          virtual CORBA_ValueDef_ptr event (
              CORBA_Object *_collocated_tao_target_,
              CORBA::Environment &ACE_TRY_ENV
            )
            ACE_THROW_SPEC ((
              CORBA::SystemException
            )) = 0;
          
          
        protected:
          _TAO_EventDef_Proxy_Impl (void);
        };
        
        //
        //               End Base Proxy Impl. Declaration
        ///////////////////////////////////////////////////////////////////////
        
        
        ///////////////////////////////////////////////////////////////////////
        //                Remote Proxy Impl. Declaration
        //
        
        class TAO_IFR_Client_Export _TAO_EventDef_Remote_Proxy_Impl
          : public virtual _TAO_EventDef_Proxy_Impl,
            public virtual TAO_Remote_Object_Proxy_Impl,
            public virtual _TAO_CORBA_Contained_Remote_Proxy_Impl
        {
        public:
          _TAO_EventDef_Remote_Proxy_Impl (void);
          
          virtual ~_TAO_EventDef_Remote_Proxy_Impl (void) { }
          virtual CORBA::Boolean is_a (
              CORBA_Object *_collocated_tao_target_,
              const char * event_id,
              CORBA::Environment &ACE_TRY_ENV
            )
            ACE_THROW_SPEC ((
              CORBA::SystemException
            ));
          
          virtual CORBA_ValueDef_ptr event (
              CORBA_Object *_collocated_tao_target_,
              CORBA::Environment &ACE_TRY_ENV
            )
            ACE_THROW_SPEC ((
              CORBA::SystemException
            ));
          
          
        };
        
        //
        //             End Remote Proxy Impl. Declaration
        ///////////////////////////////////////////////////////////////////////
        
        // The Proxy Brokers are used by each interface to get
        // the right proxy for performing a call. In the new 
        // collocation scheme, the proxy to be used can vary on
        // a call by call basis.
        
        
        ///////////////////////////////////////////////////////////////////////
        //                 Base Proxy Broker Declaration 
        //
        
                class TAO_IFR_Client_Export _TAO_EventDef_Proxy_Broker
        {
        public:
          virtual ~_TAO_EventDef_Proxy_Broker (void);
          virtual _TAO_EventDef_Proxy_Impl &select_proxy (
              EventDef *object,
              CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
            ) = 0;
          
        protected:
          _TAO_EventDef_Proxy_Broker (void);
          
        };
        
        //
        //              End Base Proxy Broker Declaration 
        ///////////////////////////////////////////////////////////////////////
        
                
        ///////////////////////////////////////////////////////////////////////
        //                 Remote Proxy Broker Declaration 
        //
        
        class TAO_IFR_Client_Export _TAO_EventDef_Remote_Proxy_Broker
          : public virtual _TAO_EventDef_Proxy_Broker
        {
        public: 
          _TAO_EventDef_Remote_Proxy_Broker (void);
          
          virtual ~_TAO_EventDef_Remote_Proxy_Broker (void);
          
          virtual _TAO_EventDef_Proxy_Impl &select_proxy (
              EventDef *object,
              CORBA_Environment &ACE_TRY_ENV
            );
          
          private:
            _TAO_EventDef_Remote_Proxy_Impl remote_proxy_impl_;
          
          public:
            // This member function is used to get an handle to the unique instance
            // of the Remote Proxy Broker that is available for a given
            // interface.
            static _TAO_EventDef_Remote_Proxy_Broker *the_TAO_EventDef_Remote_Proxy_Broker (void);
          };
          
          //
          //              End Remote Proxy Broker Declaration 
          ///////////////////////////////////////////////////////////////////////
          
          
#endif /* end #if !defined */
          
          TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_EventDef;
          
          struct EventDescription;
          class EventDescription_var;
          
          struct TAO_IFR_Client_Export EventDescription
          {
            
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
            typedef EventDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

            static void _tao_any_destructor (void*);
            
            TAO_String_Manager name;
            TAO_String_Manager id;
            TAO_String_Manager defined_in;
            TAO_String_Manager version;
            CORBA_ValueDef_var value;
            
          };
          
          class TAO_IFR_Client_Export EventDescription_var
          {
          public:
            EventDescription_var (void);
            EventDescription_var (EventDescription *);
            EventDescription_var (const EventDescription_var &);
            ~EventDescription_var (void);
            
            EventDescription_var &operator= (EventDescription *);
            EventDescription_var &operator= (const EventDescription_var &);
            EventDescription *operator-> (void);
            const EventDescription *operator-> (void) const;
            
            operator const EventDescription &() const;
            operator EventDescription &();
            operator EventDescription &() const;
            // Variable-size types only.
            operator EventDescription *&();
            
            // in, inout, out, _retn 
            const EventDescription &in (void) const;
            EventDescription &inout (void);
            EventDescription *&out (void);
            EventDescription *_retn (void);
            EventDescription *ptr (void) const;
          
          private:
            EventDescription *ptr_;
          };
          
          class TAO_IFR_Client_Export EventDescription_out
          {
          public:
            EventDescription_out (EventDescription *&);
            EventDescription_out (EventDescription_var &);
            EventDescription_out (const EventDescription_out &);
            EventDescription_out &operator= (const EventDescription_out &);
            EventDescription_out &operator= (EventDescription *);
            operator EventDescription *&();
            EventDescription *&ptr (void);
            EventDescription *operator-> (void);
            
          private:
            EventDescription *&ptr_;
            // Assignment from T_var not allowed.
            void operator= (const EventDescription_var &);
          };
          
          TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_EventDescription;
          
          
#if !defined (_IR_EMITSDEF_CH_)
#define _IR_EMITSDEF_CH_
          
          // Forward Classes Declaration
          class _TAO_EmitsDef_Proxy_Impl;
          class _TAO_EmitsDef_Remote_Proxy_Impl;
          class _TAO_EmitsDef_Proxy_Broker;
          class _TAO_EmitsDef_Remote_Proxy_Broker;
          
          class TAO_IFR_Client_Export EmitsDef
            : public virtual EventDef
          {
          public:
          #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
            typedef EmitsDef_ptr _ptr_type;
            typedef EmitsDef_var _var_type;
          #endif /* ! __GNUC__ || g++ >= 2.8 */

            // the static operations
            static EmitsDef_ptr _duplicate (EmitsDef_ptr obj);
            
            static EmitsDef_ptr _narrow (
                CORBA::Object_ptr obj,
                CORBA::Environment &ACE_TRY_ENV = 
                  TAO_default_environment ()
              );
            
            static EmitsDef_ptr _unchecked_narrow (
                CORBA::Object_ptr obj,
                CORBA::Environment &ACE_TRY_ENV = 
                  TAO_default_environment ()
              );
            
            static EmitsDef_ptr _nil (void)
              {
                return (EmitsDef_ptr)0;
              }
            
            static void _tao_any_destructor (void*);
            
            virtual CORBA::Boolean _is_a (
                const CORBA::Char *type_id, 
                CORBA::Environment &ACE_TRY_ENV = 
                  TAO_default_environment ()
              );
            
            virtual void *_tao_QueryInterface (ptr_arith_t type);
            
            virtual const char* _interface_repository_id (void) const;

          private:
            _TAO_EmitsDef_Proxy_Broker *the_TAO_EmitsDef_Proxy_Broker_;
            
          protected:
            EmitsDef (int collocated = 0);
            
            // This methods travese the inheritance tree and set the
            // parents piece of the given class in the right mode
            virtual void IR_EmitsDef_setup_collocation (int collocated);
            
            EmitsDef (
                TAO_Stub *objref, 
                CORBA::Boolean _tao_collocated = 0,
                TAO_Abstract_ServantBase *servant = 0
              );
            
            friend class _TAO_EmitsDef_Remote_Proxy_Impl;
            friend class _TAO_EmitsDef_ThruPOA_Proxy_Impl;
            friend class _TAO_EmitsDef_Direct_Proxy_Impl;
            
            virtual ~EmitsDef (void);
          
          private:
            EmitsDef (const EmitsDef &);
            void operator= (const EmitsDef &);
          };
          
          // The Proxy Implementations are used by each interface to
          // perform a call. Each different implementation encapsulate
          // an invocation logics.
          
          
          ///////////////////////////////////////////////////////////////////////
          //                    Base Proxy Impl. Declaration
          //
          
          class TAO_IFR_Client_Export _TAO_EmitsDef_Proxy_Impl
            : public virtual IR::_TAO_EventDef_Proxy_Impl
          {
          public:
            virtual ~_TAO_EmitsDef_Proxy_Impl (void) { }
            
          protected:
            _TAO_EmitsDef_Proxy_Impl (void);
          };
          
          //
          //               End Base Proxy Impl. Declaration
          ///////////////////////////////////////////////////////////////////////
          
          
          ///////////////////////////////////////////////////////////////////////
          //                Remote Proxy Impl. Declaration
          //
          
          class TAO_IFR_Client_Export _TAO_EmitsDef_Remote_Proxy_Impl
            : public virtual _TAO_EmitsDef_Proxy_Impl,
              public virtual TAO_Remote_Object_Proxy_Impl,
              public virtual IR::_TAO_EventDef_Remote_Proxy_Impl
          {
          public:
            _TAO_EmitsDef_Remote_Proxy_Impl (void);
            
            virtual ~_TAO_EmitsDef_Remote_Proxy_Impl (void) { }
            
          };
          
          //
          //             End Remote Proxy Impl. Declaration
          ///////////////////////////////////////////////////////////////////////
          
          // The Proxy Brokers are used by each interface to get
          // the right proxy for performing a call. In the new 
          // collocation scheme, the proxy to be used can vary on
          // a call by call basis.
          
          
          ///////////////////////////////////////////////////////////////////////
          //                 Base Proxy Broker Declaration 
          //
          
                    class TAO_IFR_Client_Export _TAO_EmitsDef_Proxy_Broker
          {
          public:
            virtual ~_TAO_EmitsDef_Proxy_Broker (void);
            virtual _TAO_EmitsDef_Proxy_Impl &select_proxy (
                EmitsDef *object,
                CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
              ) = 0;
            
          protected:
            _TAO_EmitsDef_Proxy_Broker (void);
            
          };
          
          //
          //              End Base Proxy Broker Declaration 
          ///////////////////////////////////////////////////////////////////////
          
                    
          ///////////////////////////////////////////////////////////////////////
          //                 Remote Proxy Broker Declaration 
          //
          
          class TAO_IFR_Client_Export _TAO_EmitsDef_Remote_Proxy_Broker
            : public virtual _TAO_EmitsDef_Proxy_Broker
          {
          public: 
            _TAO_EmitsDef_Remote_Proxy_Broker (void);
            
            virtual ~_TAO_EmitsDef_Remote_Proxy_Broker (void);
            
            virtual _TAO_EmitsDef_Proxy_Impl &select_proxy (
                EmitsDef *object,
                CORBA_Environment &ACE_TRY_ENV
              );
            
            private:
              _TAO_EmitsDef_Remote_Proxy_Impl remote_proxy_impl_;
            
            public:
              // This member function is used to get an handle to the unique instance
              // of the Remote Proxy Broker that is available for a given
              // interface.
              static _TAO_EmitsDef_Remote_Proxy_Broker *the_TAO_EmitsDef_Remote_Proxy_Broker (void);
            };
            
            //
            //              End Remote Proxy Broker Declaration 
            ///////////////////////////////////////////////////////////////////////
            
            
#endif /* end #if !defined */
            
            TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_EmitsDef;
            
            
#if !defined (_IR_PUBLISHESDEF_CH_)
#define _IR_PUBLISHESDEF_CH_
            
            // Forward Classes Declaration
            class _TAO_PublishesDef_Proxy_Impl;
            class _TAO_PublishesDef_Remote_Proxy_Impl;
            class _TAO_PublishesDef_Proxy_Broker;
            class _TAO_PublishesDef_Remote_Proxy_Broker;
            
            class TAO_IFR_Client_Export PublishesDef
              : public virtual EventDef
            {
            public:
            #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
              typedef PublishesDef_ptr _ptr_type;
              typedef PublishesDef_var _var_type;
            #endif /* ! __GNUC__ || g++ >= 2.8 */

              // the static operations
              static PublishesDef_ptr _duplicate (PublishesDef_ptr obj);
              
              static PublishesDef_ptr _narrow (
                  CORBA::Object_ptr obj,
                  CORBA::Environment &ACE_TRY_ENV = 
                    TAO_default_environment ()
                );
              
              static PublishesDef_ptr _unchecked_narrow (
                  CORBA::Object_ptr obj,
                  CORBA::Environment &ACE_TRY_ENV = 
                    TAO_default_environment ()
                );
              
              static PublishesDef_ptr _nil (void)
                {
                  return (PublishesDef_ptr)0;
                }
              
              static void _tao_any_destructor (void*);
              
              virtual CORBA::Boolean _is_a (
                  const CORBA::Char *type_id, 
                  CORBA::Environment &ACE_TRY_ENV = 
                    TAO_default_environment ()
                );
              
              virtual void *_tao_QueryInterface (ptr_arith_t type);
              
              virtual const char* _interface_repository_id (void) const;

            private:
              _TAO_PublishesDef_Proxy_Broker *the_TAO_PublishesDef_Proxy_Broker_;
              
            protected:
              PublishesDef (int collocated = 0);
              
              // This methods travese the inheritance tree and set the
              // parents piece of the given class in the right mode
              virtual void IR_PublishesDef_setup_collocation (int collocated);
              
              PublishesDef (
                  TAO_Stub *objref, 
                  CORBA::Boolean _tao_collocated = 0,
                  TAO_Abstract_ServantBase *servant = 0
                );
              
              friend class _TAO_PublishesDef_Remote_Proxy_Impl;
              friend class _TAO_PublishesDef_ThruPOA_Proxy_Impl;
              friend class _TAO_PublishesDef_Direct_Proxy_Impl;
              
              virtual ~PublishesDef (void);
            
            private:
              PublishesDef (const PublishesDef &);
              void operator= (const PublishesDef &);
            };
            
            // The Proxy Implementations are used by each interface to
            // perform a call. Each different implementation encapsulate
            // an invocation logics.
            
            
            ///////////////////////////////////////////////////////////////////////
            //                    Base Proxy Impl. Declaration
            //
            
            class TAO_IFR_Client_Export _TAO_PublishesDef_Proxy_Impl
              : public virtual IR::_TAO_EventDef_Proxy_Impl
            {
            public:
              virtual ~_TAO_PublishesDef_Proxy_Impl (void) { }
              
            protected:
              _TAO_PublishesDef_Proxy_Impl (void);
            };
            
            //
            //               End Base Proxy Impl. Declaration
            ///////////////////////////////////////////////////////////////////////
            
            
            ///////////////////////////////////////////////////////////////////////
            //                Remote Proxy Impl. Declaration
            //
            
            class TAO_IFR_Client_Export _TAO_PublishesDef_Remote_Proxy_Impl
              : public virtual _TAO_PublishesDef_Proxy_Impl,
                public virtual TAO_Remote_Object_Proxy_Impl,
                public virtual IR::_TAO_EventDef_Remote_Proxy_Impl
            {
            public:
              _TAO_PublishesDef_Remote_Proxy_Impl (void);
              
              virtual ~_TAO_PublishesDef_Remote_Proxy_Impl (void) { }
              
            };
            
            //
            //             End Remote Proxy Impl. Declaration
            ///////////////////////////////////////////////////////////////////////
            
            // The Proxy Brokers are used by each interface to get
            // the right proxy for performing a call. In the new 
            // collocation scheme, the proxy to be used can vary on
            // a call by call basis.
            
            
            ///////////////////////////////////////////////////////////////////////
            //                 Base Proxy Broker Declaration 
            //
            
                        class TAO_IFR_Client_Export _TAO_PublishesDef_Proxy_Broker
            {
            public:
              virtual ~_TAO_PublishesDef_Proxy_Broker (void);
              virtual _TAO_PublishesDef_Proxy_Impl &select_proxy (
                  PublishesDef *object,
                  CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
                ) = 0;
              
            protected:
              _TAO_PublishesDef_Proxy_Broker (void);
              
            };
            
            //
            //              End Base Proxy Broker Declaration 
            ///////////////////////////////////////////////////////////////////////
            
                        
            ///////////////////////////////////////////////////////////////////////
            //                 Remote Proxy Broker Declaration 
            //
            
            class TAO_IFR_Client_Export _TAO_PublishesDef_Remote_Proxy_Broker
              : public virtual _TAO_PublishesDef_Proxy_Broker
            {
            public: 
              _TAO_PublishesDef_Remote_Proxy_Broker (void);
              
              virtual ~_TAO_PublishesDef_Remote_Proxy_Broker (void);
              
              virtual _TAO_PublishesDef_Proxy_Impl &select_proxy (
                  PublishesDef *object,
                  CORBA_Environment &ACE_TRY_ENV
                );
              
              private:
                _TAO_PublishesDef_Remote_Proxy_Impl remote_proxy_impl_;
              
              public:
                // This member function is used to get an handle to the unique instance
                // of the Remote Proxy Broker that is available for a given
                // interface.
                static _TAO_PublishesDef_Remote_Proxy_Broker *the_TAO_PublishesDef_Remote_Proxy_Broker (void);
              };
              
              //
              //              End Remote Proxy Broker Declaration 
              ///////////////////////////////////////////////////////////////////////
              
              
#endif /* end #if !defined */
              
              TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_PublishesDef;
              
              
#if !defined (_IR_CONSUMESDEF_CH_)
#define _IR_CONSUMESDEF_CH_
              
              // Forward Classes Declaration
              class _TAO_ConsumesDef_Proxy_Impl;
              class _TAO_ConsumesDef_Remote_Proxy_Impl;
              class _TAO_ConsumesDef_Proxy_Broker;
              class _TAO_ConsumesDef_Remote_Proxy_Broker;
              
              class TAO_IFR_Client_Export ConsumesDef
                : public virtual EventDef
              {
              public:
              #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
                typedef ConsumesDef_ptr _ptr_type;
                typedef ConsumesDef_var _var_type;
              #endif /* ! __GNUC__ || g++ >= 2.8 */

                // the static operations
                static ConsumesDef_ptr _duplicate (ConsumesDef_ptr obj);
                
                static ConsumesDef_ptr _narrow (
                    CORBA::Object_ptr obj,
                    CORBA::Environment &ACE_TRY_ENV = 
                      TAO_default_environment ()
                  );
                
                static ConsumesDef_ptr _unchecked_narrow (
                    CORBA::Object_ptr obj,
                    CORBA::Environment &ACE_TRY_ENV = 
                      TAO_default_environment ()
                  );
                
                static ConsumesDef_ptr _nil (void)
                  {
                    return (ConsumesDef_ptr)0;
                  }
                
                static void _tao_any_destructor (void*);
                
                virtual CORBA::Boolean _is_a (
                    const CORBA::Char *type_id, 
                    CORBA::Environment &ACE_TRY_ENV = 
                      TAO_default_environment ()
                  );
                
                virtual void *_tao_QueryInterface (ptr_arith_t type);
                
                virtual const char* _interface_repository_id (void) const;

              private:
                _TAO_ConsumesDef_Proxy_Broker *the_TAO_ConsumesDef_Proxy_Broker_;
                
              protected:
                ConsumesDef (int collocated = 0);
                
                // This methods travese the inheritance tree and set the
                // parents piece of the given class in the right mode
                virtual void IR_ConsumesDef_setup_collocation (int collocated);
                
                ConsumesDef (
                    TAO_Stub *objref, 
                    CORBA::Boolean _tao_collocated = 0,
                    TAO_Abstract_ServantBase *servant = 0
                  );
                
                friend class _TAO_ConsumesDef_Remote_Proxy_Impl;
                friend class _TAO_ConsumesDef_ThruPOA_Proxy_Impl;
                friend class _TAO_ConsumesDef_Direct_Proxy_Impl;
                
                virtual ~ConsumesDef (void);
              
              private:
                ConsumesDef (const ConsumesDef &);
                void operator= (const ConsumesDef &);
              };
              
              // The Proxy Implementations are used by each interface to
              // perform a call. Each different implementation encapsulate
              // an invocation logics.
              
              
              ///////////////////////////////////////////////////////////////////////
              //                    Base Proxy Impl. Declaration
              //
              
              class TAO_IFR_Client_Export _TAO_ConsumesDef_Proxy_Impl
                : public virtual IR::_TAO_EventDef_Proxy_Impl
              {
              public:
                virtual ~_TAO_ConsumesDef_Proxy_Impl (void) { }
                
              protected:
                _TAO_ConsumesDef_Proxy_Impl (void);
              };
              
              //
              //               End Base Proxy Impl. Declaration
              ///////////////////////////////////////////////////////////////////////
              
              
              ///////////////////////////////////////////////////////////////////////
              //                Remote Proxy Impl. Declaration
              //
              
              class TAO_IFR_Client_Export _TAO_ConsumesDef_Remote_Proxy_Impl
                : public virtual _TAO_ConsumesDef_Proxy_Impl,
                  public virtual TAO_Remote_Object_Proxy_Impl,
                  public virtual IR::_TAO_EventDef_Remote_Proxy_Impl
              {
              public:
                _TAO_ConsumesDef_Remote_Proxy_Impl (void);
                
                virtual ~_TAO_ConsumesDef_Remote_Proxy_Impl (void) { }
                
              };
              
              //
              //             End Remote Proxy Impl. Declaration
              ///////////////////////////////////////////////////////////////////////
              
              // The Proxy Brokers are used by each interface to get
              // the right proxy for performing a call. In the new 
              // collocation scheme, the proxy to be used can vary on
              // a call by call basis.
              
              
              ///////////////////////////////////////////////////////////////////////
              //                 Base Proxy Broker Declaration 
              //
              
                            class TAO_IFR_Client_Export _TAO_ConsumesDef_Proxy_Broker
              {
              public:
                virtual ~_TAO_ConsumesDef_Proxy_Broker (void);
                virtual _TAO_ConsumesDef_Proxy_Impl &select_proxy (
                    ConsumesDef *object,
                    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
                  ) = 0;
                
              protected:
                _TAO_ConsumesDef_Proxy_Broker (void);
                
              };
              
              //
              //              End Base Proxy Broker Declaration 
              ///////////////////////////////////////////////////////////////////////
              
                            
              ///////////////////////////////////////////////////////////////////////
              //                 Remote Proxy Broker Declaration 
              //
              
              class TAO_IFR_Client_Export _TAO_ConsumesDef_Remote_Proxy_Broker
                : public virtual _TAO_ConsumesDef_Proxy_Broker
              {
              public: 
                _TAO_ConsumesDef_Remote_Proxy_Broker (void);
                
                virtual ~_TAO_ConsumesDef_Remote_Proxy_Broker (void);
                
                virtual _TAO_ConsumesDef_Proxy_Impl &select_proxy (
                    ConsumesDef *object,
                    CORBA_Environment &ACE_TRY_ENV
                  );
                
                private:
                  _TAO_ConsumesDef_Remote_Proxy_Impl remote_proxy_impl_;
                
                public:
                  // This member function is used to get an handle to the unique instance
                  // of the Remote Proxy Broker that is available for a given
                  // interface.
                  static _TAO_ConsumesDef_Remote_Proxy_Broker *the_TAO_ConsumesDef_Remote_Proxy_Broker (void);
                };
                
                //
                //              End Remote Proxy Broker Declaration 
                ///////////////////////////////////////////////////////////////////////
                
                
#endif /* end #if !defined */
                
                TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ConsumesDef;
                
                
#if !defined (_IR_COMPONENTDEF_CH_)
#define _IR_COMPONENTDEF_CH_
                
                // Forward Classes Declaration
                class _TAO_ComponentDef_Proxy_Impl;
                class _TAO_ComponentDef_Remote_Proxy_Impl;
                class _TAO_ComponentDef_Proxy_Broker;
                class _TAO_ComponentDef_Remote_Proxy_Broker;
                
                class TAO_IFR_Client_Export ComponentDef
                  : public virtual CORBA_InterfaceDef
                {
                public:
                #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
                  typedef ComponentDef_ptr _ptr_type;
                  typedef ComponentDef_var _var_type;
                #endif /* ! __GNUC__ || g++ >= 2.8 */

                  // the static operations
                  static ComponentDef_ptr _duplicate (ComponentDef_ptr obj);
                  
                  static ComponentDef_ptr _narrow (
                      CORBA::Object_ptr obj,
                      CORBA::Environment &ACE_TRY_ENV = 
                        TAO_default_environment ()
                    );
                  
                  static ComponentDef_ptr _unchecked_narrow (
                      CORBA::Object_ptr obj,
                      CORBA::Environment &ACE_TRY_ENV = 
                        TAO_default_environment ()
                    );
                  
                  static ComponentDef_ptr _nil (void)
                    {
                      return (ComponentDef_ptr)0;
                    }
                  
                  static void _tao_any_destructor (void*);
                  
                  virtual CORBA_InterfaceDefSeq * supported_interfaces (
                      CORBA::Environment &ACE_TRY_ENV = 
                        TAO_default_environment ()
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    ));
                  
                  virtual void supported_interfaces (
                      const CORBA_InterfaceDefSeq & supported_interfaces,
                      CORBA::Environment &ACE_TRY_ENV = 
                        TAO_default_environment ()
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    ));
                  
                  virtual IR::ComponentDef_ptr base_component (
                      CORBA::Environment &ACE_TRY_ENV = 
                        TAO_default_environment ()
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    ));
                  
                  virtual IR::ProvidesDefSeq * provides_interfaces (
                      CORBA::Environment &ACE_TRY_ENV = 
                        TAO_default_environment ()
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    ));
                  
                  virtual IR::UsesDefSeq * uses_interfaces (
                      CORBA::Environment &ACE_TRY_ENV = 
                        TAO_default_environment ()
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    ));
                  
                  virtual IR::EmitsDefSeq * emits_events (
                      CORBA::Environment &ACE_TRY_ENV = 
                        TAO_default_environment ()
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    ));
                  
                  virtual IR::PublishesDefSeq * publishes_events (
                      CORBA::Environment &ACE_TRY_ENV = 
                        TAO_default_environment ()
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    ));
                  
                  virtual IR::ConsumesDefSeq * consumes_events (
                      CORBA::Environment &ACE_TRY_ENV = 
                        TAO_default_environment ()
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    ));
                  
                  virtual CORBA::Boolean is_basic (
                      CORBA::Environment &ACE_TRY_ENV = 
                        TAO_default_environment ()
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    ));
                  
                  virtual IR::ProvidesDef_ptr create_provides (
                      const char * id,
                      const char * name,
                      const char * version,
                      CORBA_InterfaceDef_ptr interface_type,
                      CORBA::Environment &ACE_TRY_ENV = 
                        TAO_default_environment ()
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    ));
                  
                  virtual IR::UsesDef_ptr create_uses (
                      const char * id,
                      const char * name,
                      const char * version,
                      CORBA_InterfaceDef_ptr interface_type,
                      CORBA::Boolean is_multiple,
                      CORBA::Environment &ACE_TRY_ENV = 
                        TAO_default_environment ()
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    ));
                  
                  virtual IR::EmitsDef_ptr create_emits (
                      const char * id,
                      const char * name,
                      const char * version,
                      CORBA_ValueDef_ptr value,
                      CORBA::Environment &ACE_TRY_ENV = 
                        TAO_default_environment ()
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    ));
                  
                  virtual IR::PublishesDef_ptr create_publishes (
                      const char * id,
                      const char * name,
                      const char * version,
                      CORBA_ValueDef_ptr value,
                      CORBA::Environment &ACE_TRY_ENV = 
                        TAO_default_environment ()
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    ));
                  
                  virtual IR::ConsumesDef_ptr create_consumes (
                      const char * id,
                      const char * name,
                      const char * version,
                      CORBA_ValueDef_ptr value,
                      CORBA::Environment &ACE_TRY_ENV = 
                        TAO_default_environment ()
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    ));
                  
                  virtual CORBA::Boolean _is_a (
                      const CORBA::Char *type_id, 
                      CORBA::Environment &ACE_TRY_ENV = 
                        TAO_default_environment ()
                    );
                  
                  virtual void *_tao_QueryInterface (ptr_arith_t type);
                  
                  virtual const char* _interface_repository_id (void) const;

                private:
                  _TAO_ComponentDef_Proxy_Broker *the_TAO_ComponentDef_Proxy_Broker_;
                  
                protected:
                  ComponentDef (int collocated = 0);
                  
                  // This methods travese the inheritance tree and set the
                  // parents piece of the given class in the right mode
                  virtual void IR_ComponentDef_setup_collocation (int collocated);
                  
                  ComponentDef (
                      TAO_Stub *objref, 
                      CORBA::Boolean _tao_collocated = 0,
                      TAO_Abstract_ServantBase *servant = 0
                    );
                  
                  friend class _TAO_ComponentDef_Remote_Proxy_Impl;
                  friend class _TAO_ComponentDef_ThruPOA_Proxy_Impl;
                  friend class _TAO_ComponentDef_Direct_Proxy_Impl;
                  
                  virtual ~ComponentDef (void);
                
                private:
                  ComponentDef (const ComponentDef &);
                  void operator= (const ComponentDef &);
                };
                
                // The Proxy Implementations are used by each interface to
                // perform a call. Each different implementation encapsulate
                // an invocation logics.
                
                
                ///////////////////////////////////////////////////////////////////////
                //                    Base Proxy Impl. Declaration
                //
                
                class TAO_IFR_Client_Export _TAO_ComponentDef_Proxy_Impl
                  : public virtual _TAO_CORBA_InterfaceDef_Proxy_Impl
                {
                public:
                  virtual ~_TAO_ComponentDef_Proxy_Impl (void) { }
                  virtual CORBA_InterfaceDefSeq * supported_interfaces (
                      CORBA_Object *_collocated_tao_target_,
                      CORBA::Environment &ACE_TRY_ENV
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    )) = 0;
                  
                  virtual void supported_interfaces (
                      CORBA_Object *_collocated_tao_target_,
                      const CORBA_InterfaceDefSeq & supported_interfaces,
                      CORBA::Environment &ACE_TRY_ENV
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    )) = 0;
                  
                  virtual IR::ComponentDef_ptr base_component (
                      CORBA_Object *_collocated_tao_target_,
                      CORBA::Environment &ACE_TRY_ENV
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    )) = 0;
                  
                  virtual IR::ProvidesDefSeq * provides_interfaces (
                      CORBA_Object *_collocated_tao_target_,
                      CORBA::Environment &ACE_TRY_ENV
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    )) = 0;
                  
                  virtual IR::UsesDefSeq * uses_interfaces (
                      CORBA_Object *_collocated_tao_target_,
                      CORBA::Environment &ACE_TRY_ENV
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    )) = 0;
                  
                  virtual IR::EmitsDefSeq * emits_events (
                      CORBA_Object *_collocated_tao_target_,
                      CORBA::Environment &ACE_TRY_ENV
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    )) = 0;
                  
                  virtual IR::PublishesDefSeq * publishes_events (
                      CORBA_Object *_collocated_tao_target_,
                      CORBA::Environment &ACE_TRY_ENV
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    )) = 0;
                  
                  virtual IR::ConsumesDefSeq * consumes_events (
                      CORBA_Object *_collocated_tao_target_,
                      CORBA::Environment &ACE_TRY_ENV
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    )) = 0;
                  
                  virtual CORBA::Boolean is_basic (
                      CORBA_Object *_collocated_tao_target_,
                      CORBA::Environment &ACE_TRY_ENV
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    )) = 0;
                  
                  virtual IR::ProvidesDef_ptr create_provides (
                      CORBA_Object *_collocated_tao_target_,
                      const char * id,
                      const char * name,
                      const char * version,
                      CORBA_InterfaceDef_ptr interface_type,
                      CORBA::Environment &ACE_TRY_ENV
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    )) = 0;
                  
                  virtual IR::UsesDef_ptr create_uses (
                      CORBA_Object *_collocated_tao_target_,
                      const char * id,
                      const char * name,
                      const char * version,
                      CORBA_InterfaceDef_ptr interface_type,
                      CORBA::Boolean is_multiple,
                      CORBA::Environment &ACE_TRY_ENV
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    )) = 0;
                  
                  virtual IR::EmitsDef_ptr create_emits (
                      CORBA_Object *_collocated_tao_target_,
                      const char * id,
                      const char * name,
                      const char * version,
                      CORBA_ValueDef_ptr value,
                      CORBA::Environment &ACE_TRY_ENV
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    )) = 0;
                  
                  virtual IR::PublishesDef_ptr create_publishes (
                      CORBA_Object *_collocated_tao_target_,
                      const char * id,
                      const char * name,
                      const char * version,
                      CORBA_ValueDef_ptr value,
                      CORBA::Environment &ACE_TRY_ENV
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    )) = 0;
                  
                  virtual IR::ConsumesDef_ptr create_consumes (
                      CORBA_Object *_collocated_tao_target_,
                      const char * id,
                      const char * name,
                      const char * version,
                      CORBA_ValueDef_ptr value,
                      CORBA::Environment &ACE_TRY_ENV
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    )) = 0;
                  
                  
                protected:
                  _TAO_ComponentDef_Proxy_Impl (void);
                };
                
                //
                //               End Base Proxy Impl. Declaration
                ///////////////////////////////////////////////////////////////////////
                
                
                ///////////////////////////////////////////////////////////////////////
                //                Remote Proxy Impl. Declaration
                //
                
                class TAO_IFR_Client_Export _TAO_ComponentDef_Remote_Proxy_Impl
                  : public virtual _TAO_ComponentDef_Proxy_Impl,
                    public virtual TAO_Remote_Object_Proxy_Impl,
                    public virtual _TAO_CORBA_InterfaceDef_Remote_Proxy_Impl
                {
                public:
                  _TAO_ComponentDef_Remote_Proxy_Impl (void);
                  
                  virtual ~_TAO_ComponentDef_Remote_Proxy_Impl (void) { }
                  virtual CORBA_InterfaceDefSeq * supported_interfaces (
                      CORBA_Object *_collocated_tao_target_,
                      CORBA::Environment &ACE_TRY_ENV
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    ));
                  
                  virtual void supported_interfaces (
                      CORBA_Object *_collocated_tao_target_,
                      const CORBA_InterfaceDefSeq & supported_interfaces,
                      CORBA::Environment &ACE_TRY_ENV
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    ));
                  
                  virtual IR::ComponentDef_ptr base_component (
                      CORBA_Object *_collocated_tao_target_,
                      CORBA::Environment &ACE_TRY_ENV
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    ));
                  
                  virtual IR::ProvidesDefSeq * provides_interfaces (
                      CORBA_Object *_collocated_tao_target_,
                      CORBA::Environment &ACE_TRY_ENV
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    ));
                  
                  virtual IR::UsesDefSeq * uses_interfaces (
                      CORBA_Object *_collocated_tao_target_,
                      CORBA::Environment &ACE_TRY_ENV
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    ));
                  
                  virtual IR::EmitsDefSeq * emits_events (
                      CORBA_Object *_collocated_tao_target_,
                      CORBA::Environment &ACE_TRY_ENV
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    ));
                  
                  virtual IR::PublishesDefSeq * publishes_events (
                      CORBA_Object *_collocated_tao_target_,
                      CORBA::Environment &ACE_TRY_ENV
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    ));
                  
                  virtual IR::ConsumesDefSeq * consumes_events (
                      CORBA_Object *_collocated_tao_target_,
                      CORBA::Environment &ACE_TRY_ENV
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    ));
                  
                  virtual CORBA::Boolean is_basic (
                      CORBA_Object *_collocated_tao_target_,
                      CORBA::Environment &ACE_TRY_ENV
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    ));
                  
                  virtual IR::ProvidesDef_ptr create_provides (
                      CORBA_Object *_collocated_tao_target_,
                      const char * id,
                      const char * name,
                      const char * version,
                      CORBA_InterfaceDef_ptr interface_type,
                      CORBA::Environment &ACE_TRY_ENV
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    ));
                  
                  virtual IR::UsesDef_ptr create_uses (
                      CORBA_Object *_collocated_tao_target_,
                      const char * id,
                      const char * name,
                      const char * version,
                      CORBA_InterfaceDef_ptr interface_type,
                      CORBA::Boolean is_multiple,
                      CORBA::Environment &ACE_TRY_ENV
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    ));
                  
                  virtual IR::EmitsDef_ptr create_emits (
                      CORBA_Object *_collocated_tao_target_,
                      const char * id,
                      const char * name,
                      const char * version,
                      CORBA_ValueDef_ptr value,
                      CORBA::Environment &ACE_TRY_ENV
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    ));
                  
                  virtual IR::PublishesDef_ptr create_publishes (
                      CORBA_Object *_collocated_tao_target_,
                      const char * id,
                      const char * name,
                      const char * version,
                      CORBA_ValueDef_ptr value,
                      CORBA::Environment &ACE_TRY_ENV
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    ));
                  
                  virtual IR::ConsumesDef_ptr create_consumes (
                      CORBA_Object *_collocated_tao_target_,
                      const char * id,
                      const char * name,
                      const char * version,
                      CORBA_ValueDef_ptr value,
                      CORBA::Environment &ACE_TRY_ENV
                    )
                    ACE_THROW_SPEC ((
                      CORBA::SystemException
                    ));
                  
                  
                };
                
                //
                //             End Remote Proxy Impl. Declaration
                ///////////////////////////////////////////////////////////////////////
                
                // The Proxy Brokers are used by each interface to get
                // the right proxy for performing a call. In the new 
                // collocation scheme, the proxy to be used can vary on
                // a call by call basis.
                
                
                ///////////////////////////////////////////////////////////////////////
                //                 Base Proxy Broker Declaration 
                //
                
                                class TAO_IFR_Client_Export _TAO_ComponentDef_Proxy_Broker
                {
                public:
                  virtual ~_TAO_ComponentDef_Proxy_Broker (void);
                  virtual _TAO_ComponentDef_Proxy_Impl &select_proxy (
                      ComponentDef *object,
                      CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
                    ) = 0;
                  
                protected:
                  _TAO_ComponentDef_Proxy_Broker (void);
                  
                };
                
                //
                //              End Base Proxy Broker Declaration 
                ///////////////////////////////////////////////////////////////////////
                
                                
                ///////////////////////////////////////////////////////////////////////
                //                 Remote Proxy Broker Declaration 
                //
                
                class TAO_IFR_Client_Export _TAO_ComponentDef_Remote_Proxy_Broker
                  : public virtual _TAO_ComponentDef_Proxy_Broker
                {
                public: 
                  _TAO_ComponentDef_Remote_Proxy_Broker (void);
                  
                  virtual ~_TAO_ComponentDef_Remote_Proxy_Broker (void);
                  
                  virtual _TAO_ComponentDef_Proxy_Impl &select_proxy (
                      ComponentDef *object,
                      CORBA_Environment &ACE_TRY_ENV
                    );
                  
                  private:
                    _TAO_ComponentDef_Remote_Proxy_Impl remote_proxy_impl_;
                  
                  public:
                    // This member function is used to get an handle to the unique instance
                    // of the Remote Proxy Broker that is available for a given
                    // interface.
                    static _TAO_ComponentDef_Remote_Proxy_Broker *the_TAO_ComponentDef_Remote_Proxy_Broker (void);
                  };
                  
                  //
                  //              End Remote Proxy Broker Declaration 
                  ///////////////////////////////////////////////////////////////////////
                  
                  
#endif /* end #if !defined */
                  
                  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ComponentDef;
                  
                  struct ComponentDescription;
                  class ComponentDescription_var;
                  
                  struct TAO_IFR_Client_Export ComponentDescription
                  {
                    
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
                    typedef ComponentDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

                    static void _tao_any_destructor (void*);
                    
                    TAO_String_Manager name;
                    TAO_String_Manager id;
                    TAO_String_Manager defined_in;
                    TAO_String_Manager version;
                    TAO_String_Manager base_component;
                    ACE_NESTED_CLASS (IR, RepositoryIdSeq) supports_interfaces;
                    ACE_NESTED_CLASS (IR, ProvidesDefSeq) provides_interfaces;
                    ACE_NESTED_CLASS (IR, UsesDefSeq) uses_interfaces;
                    CORBA_AttrDescriptionSeq attributes;
                    ACE_NESTED_CLASS (IR, EmitsDefSeq) emits_events;
                    ACE_NESTED_CLASS (IR, PublishesDefSeq) publishes_events;
                    ACE_NESTED_CLASS (IR, ConsumesDefSeq) consumes_events;
                    CORBA::Boolean is_basic;
                    
                  };
                  
                  class TAO_IFR_Client_Export ComponentDescription_var
                  {
                  public:
                    ComponentDescription_var (void);
                    ComponentDescription_var (ComponentDescription *);
                    ComponentDescription_var (const ComponentDescription_var &);
                    ~ComponentDescription_var (void);
                    
                    ComponentDescription_var &operator= (ComponentDescription *);
                    ComponentDescription_var &operator= (const ComponentDescription_var &);
                    ComponentDescription *operator-> (void);
                    const ComponentDescription *operator-> (void) const;
                    
                    operator const ComponentDescription &() const;
                    operator ComponentDescription &();
                    operator ComponentDescription &() const;
                    // Variable-size types only.
                    operator ComponentDescription *&();
                    
                    // in, inout, out, _retn 
                    const ComponentDescription &in (void) const;
                    ComponentDescription &inout (void);
                    ComponentDescription *&out (void);
                    ComponentDescription *_retn (void);
                    ComponentDescription *ptr (void) const;
                  
                  private:
                    ComponentDescription *ptr_;
                  };
                  
                  class TAO_IFR_Client_Export ComponentDescription_out
                  {
                  public:
                    ComponentDescription_out (ComponentDescription *&);
                    ComponentDescription_out (ComponentDescription_var &);
                    ComponentDescription_out (const ComponentDescription_out &);
                    ComponentDescription_out &operator= (const ComponentDescription_out &);
                    ComponentDescription_out &operator= (ComponentDescription *);
                    operator ComponentDescription *&();
                    ComponentDescription *&ptr (void);
                    ComponentDescription *operator-> (void);
                    
                  private:
                    ComponentDescription *&ptr_;
                    // Assignment from T_var not allowed.
                    void operator= (const ComponentDescription_var &);
                  };
                  
                  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ComponentDescription;
                  
                  
#if !defined (_IR_PRIMARYKEYDEF_CH_)
#define _IR_PRIMARYKEYDEF_CH_
                  
                  // Forward Classes Declaration
                  class _TAO_PrimaryKeyDef_Proxy_Impl;
                  class _TAO_PrimaryKeyDef_Remote_Proxy_Impl;
                  class _TAO_PrimaryKeyDef_Proxy_Broker;
                  class _TAO_PrimaryKeyDef_Remote_Proxy_Broker;
                  
                  class TAO_IFR_Client_Export PrimaryKeyDef
                    : public virtual CORBA_Contained
                  {
                  public:
                  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
                    typedef PrimaryKeyDef_ptr _ptr_type;
                    typedef PrimaryKeyDef_var _var_type;
                  #endif /* ! __GNUC__ || g++ >= 2.8 */

                    // the static operations
                    static PrimaryKeyDef_ptr _duplicate (PrimaryKeyDef_ptr obj);
                    
                    static PrimaryKeyDef_ptr _narrow (
                        CORBA::Object_ptr obj,
                        CORBA::Environment &ACE_TRY_ENV = 
                          TAO_default_environment ()
                      );
                    
                    static PrimaryKeyDef_ptr _unchecked_narrow (
                        CORBA::Object_ptr obj,
                        CORBA::Environment &ACE_TRY_ENV = 
                          TAO_default_environment ()
                      );
                    
                    static PrimaryKeyDef_ptr _nil (void)
                      {
                        return (PrimaryKeyDef_ptr)0;
                      }
                    
                    static void _tao_any_destructor (void*);
                    
                    virtual CORBA::Boolean is_a (
                        const char * primary_key_id,
                        CORBA::Environment &ACE_TRY_ENV = 
                          TAO_default_environment ()
                      )
                      ACE_THROW_SPEC ((
                        CORBA::SystemException
                      ));
                    
                    virtual CORBA_ValueDef_ptr primary_key (
                        CORBA::Environment &ACE_TRY_ENV = 
                          TAO_default_environment ()
                      )
                      ACE_THROW_SPEC ((
                        CORBA::SystemException
                      ));
                    
                    virtual CORBA::Boolean _is_a (
                        const CORBA::Char *type_id, 
                        CORBA::Environment &ACE_TRY_ENV = 
                          TAO_default_environment ()
                      );
                    
                    virtual void *_tao_QueryInterface (ptr_arith_t type);
                    
                    virtual const char* _interface_repository_id (void) const;

                  private:
                    _TAO_PrimaryKeyDef_Proxy_Broker *the_TAO_PrimaryKeyDef_Proxy_Broker_;
                    
                  protected:
                    PrimaryKeyDef (int collocated = 0);
                    
                    // This methods travese the inheritance tree and set the
                    // parents piece of the given class in the right mode
                    virtual void IR_PrimaryKeyDef_setup_collocation (int collocated);
                    
                    PrimaryKeyDef (
                        TAO_Stub *objref, 
                        CORBA::Boolean _tao_collocated = 0,
                        TAO_Abstract_ServantBase *servant = 0
                      );
                    
                    friend class _TAO_PrimaryKeyDef_Remote_Proxy_Impl;
                    friend class _TAO_PrimaryKeyDef_ThruPOA_Proxy_Impl;
                    friend class _TAO_PrimaryKeyDef_Direct_Proxy_Impl;
                    
                    virtual ~PrimaryKeyDef (void);
                  
                  private:
                    PrimaryKeyDef (const PrimaryKeyDef &);
                    void operator= (const PrimaryKeyDef &);
                  };
                  
                  // The Proxy Implementations are used by each interface to
                  // perform a call. Each different implementation encapsulate
                  // an invocation logics.
                  
                  
                  ///////////////////////////////////////////////////////////////////////
                  //                    Base Proxy Impl. Declaration
                  //
                  
                  class TAO_IFR_Client_Export _TAO_PrimaryKeyDef_Proxy_Impl
                    : public virtual _TAO_CORBA_Contained_Proxy_Impl
                  {
                  public:
                    virtual ~_TAO_PrimaryKeyDef_Proxy_Impl (void) { }
                    virtual CORBA::Boolean is_a (
                        CORBA_Object *_collocated_tao_target_,
                        const char * primary_key_id,
                        CORBA::Environment &ACE_TRY_ENV
                      )
                      ACE_THROW_SPEC ((
                        CORBA::SystemException
                      )) = 0;
                    
                    virtual CORBA_ValueDef_ptr primary_key (
                        CORBA_Object *_collocated_tao_target_,
                        CORBA::Environment &ACE_TRY_ENV
                      )
                      ACE_THROW_SPEC ((
                        CORBA::SystemException
                      )) = 0;
                    
                    
                  protected:
                    _TAO_PrimaryKeyDef_Proxy_Impl (void);
                  };
                  
                  //
                  //               End Base Proxy Impl. Declaration
                  ///////////////////////////////////////////////////////////////////////
                  
                  
                  ///////////////////////////////////////////////////////////////////////
                  //                Remote Proxy Impl. Declaration
                  //
                  
                  class TAO_IFR_Client_Export _TAO_PrimaryKeyDef_Remote_Proxy_Impl
                    : public virtual _TAO_PrimaryKeyDef_Proxy_Impl,
                      public virtual TAO_Remote_Object_Proxy_Impl,
                      public virtual _TAO_CORBA_Contained_Remote_Proxy_Impl
                  {
                  public:
                    _TAO_PrimaryKeyDef_Remote_Proxy_Impl (void);
                    
                    virtual ~_TAO_PrimaryKeyDef_Remote_Proxy_Impl (void) { }
                    virtual CORBA::Boolean is_a (
                        CORBA_Object *_collocated_tao_target_,
                        const char * primary_key_id,
                        CORBA::Environment &ACE_TRY_ENV
                      )
                      ACE_THROW_SPEC ((
                        CORBA::SystemException
                      ));
                    
                    virtual CORBA_ValueDef_ptr primary_key (
                        CORBA_Object *_collocated_tao_target_,
                        CORBA::Environment &ACE_TRY_ENV
                      )
                      ACE_THROW_SPEC ((
                        CORBA::SystemException
                      ));
                    
                    
                  };
                  
                  //
                  //             End Remote Proxy Impl. Declaration
                  ///////////////////////////////////////////////////////////////////////
                  
                  // The Proxy Brokers are used by each interface to get
                  // the right proxy for performing a call. In the new 
                  // collocation scheme, the proxy to be used can vary on
                  // a call by call basis.
                  
                  
                  ///////////////////////////////////////////////////////////////////////
                  //                 Base Proxy Broker Declaration 
                  //
                  
                                    class TAO_IFR_Client_Export _TAO_PrimaryKeyDef_Proxy_Broker
                  {
                  public:
                    virtual ~_TAO_PrimaryKeyDef_Proxy_Broker (void);
                    virtual _TAO_PrimaryKeyDef_Proxy_Impl &select_proxy (
                        PrimaryKeyDef *object,
                        CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
                      ) = 0;
                    
                  protected:
                    _TAO_PrimaryKeyDef_Proxy_Broker (void);
                    
                  };
                  
                  //
                  //              End Base Proxy Broker Declaration 
                  ///////////////////////////////////////////////////////////////////////
                  
                                    
                  ///////////////////////////////////////////////////////////////////////
                  //                 Remote Proxy Broker Declaration 
                  //
                  
                  class TAO_IFR_Client_Export _TAO_PrimaryKeyDef_Remote_Proxy_Broker
                    : public virtual _TAO_PrimaryKeyDef_Proxy_Broker
                  {
                  public: 
                    _TAO_PrimaryKeyDef_Remote_Proxy_Broker (void);
                    
                    virtual ~_TAO_PrimaryKeyDef_Remote_Proxy_Broker (void);
                    
                    virtual _TAO_PrimaryKeyDef_Proxy_Impl &select_proxy (
                        PrimaryKeyDef *object,
                        CORBA_Environment &ACE_TRY_ENV
                      );
                    
                    private:
                      _TAO_PrimaryKeyDef_Remote_Proxy_Impl remote_proxy_impl_;
                    
                    public:
                      // This member function is used to get an handle to the unique instance
                      // of the Remote Proxy Broker that is available for a given
                      // interface.
                      static _TAO_PrimaryKeyDef_Remote_Proxy_Broker *the_TAO_PrimaryKeyDef_Remote_Proxy_Broker (void);
                    };
                    
                    //
                    //              End Remote Proxy Broker Declaration 
                    ///////////////////////////////////////////////////////////////////////
                    
                    
#endif /* end #if !defined */
                    
                    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_PrimaryKeyDef;
                    
                    struct PrimaryKeyDescription;
                    class PrimaryKeyDescription_var;
                    
                    struct TAO_IFR_Client_Export PrimaryKeyDescription
                    {
                      
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
                      typedef PrimaryKeyDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

                      static void _tao_any_destructor (void*);
                      
                      TAO_String_Manager name;
                      TAO_String_Manager id;
                      TAO_String_Manager defined_in;
                      TAO_String_Manager version;
                      CORBA_ValueDef_var primary_key;
                      
                    };
                    
                    class TAO_IFR_Client_Export PrimaryKeyDescription_var
                    {
                    public:
                      PrimaryKeyDescription_var (void);
                      PrimaryKeyDescription_var (PrimaryKeyDescription *);
                      PrimaryKeyDescription_var (const PrimaryKeyDescription_var &);
                      ~PrimaryKeyDescription_var (void);
                      
                      PrimaryKeyDescription_var &operator= (PrimaryKeyDescription *);
                      PrimaryKeyDescription_var &operator= (const PrimaryKeyDescription_var &);
                      PrimaryKeyDescription *operator-> (void);
                      const PrimaryKeyDescription *operator-> (void) const;
                      
                      operator const PrimaryKeyDescription &() const;
                      operator PrimaryKeyDescription &();
                      operator PrimaryKeyDescription &() const;
                      // Variable-size types only.
                      operator PrimaryKeyDescription *&();
                      
                      // in, inout, out, _retn 
                      const PrimaryKeyDescription &in (void) const;
                      PrimaryKeyDescription &inout (void);
                      PrimaryKeyDescription *&out (void);
                      PrimaryKeyDescription *_retn (void);
                      PrimaryKeyDescription *ptr (void) const;
                    
                    private:
                      PrimaryKeyDescription *ptr_;
                    };
                    
                    class TAO_IFR_Client_Export PrimaryKeyDescription_out
                    {
                    public:
                      PrimaryKeyDescription_out (PrimaryKeyDescription *&);
                      PrimaryKeyDescription_out (PrimaryKeyDescription_var &);
                      PrimaryKeyDescription_out (const PrimaryKeyDescription_out &);
                      PrimaryKeyDescription_out &operator= (const PrimaryKeyDescription_out &);
                      PrimaryKeyDescription_out &operator= (PrimaryKeyDescription *);
                      operator PrimaryKeyDescription *&();
                      PrimaryKeyDescription *&ptr (void);
                      PrimaryKeyDescription *operator-> (void);
                      
                    private:
                      PrimaryKeyDescription *&ptr_;
                      // Assignment from T_var not allowed.
                      void operator= (const PrimaryKeyDescription_var &);
                    };
                    
                    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_PrimaryKeyDescription;
                    
                    
#if !defined (_IR_FACTORYDEF_CH_)
#define _IR_FACTORYDEF_CH_
                    
                    // Forward Classes Declaration
                    class _TAO_FactoryDef_Proxy_Impl;
                    class _TAO_FactoryDef_Remote_Proxy_Impl;
                    class _TAO_FactoryDef_Proxy_Broker;
                    class _TAO_FactoryDef_Remote_Proxy_Broker;
                    
                    class TAO_IFR_Client_Export FactoryDef
                      : public virtual CORBA_OperationDef
                    {
                    public:
                    #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
                      typedef FactoryDef_ptr _ptr_type;
                      typedef FactoryDef_var _var_type;
                    #endif /* ! __GNUC__ || g++ >= 2.8 */

                      // the static operations
                      static FactoryDef_ptr _duplicate (FactoryDef_ptr obj);
                      
                      static FactoryDef_ptr _narrow (
                          CORBA::Object_ptr obj,
                          CORBA::Environment &ACE_TRY_ENV = 
                            TAO_default_environment ()
                        );
                      
                      static FactoryDef_ptr _unchecked_narrow (
                          CORBA::Object_ptr obj,
                          CORBA::Environment &ACE_TRY_ENV = 
                            TAO_default_environment ()
                        );
                      
                      static FactoryDef_ptr _nil (void)
                        {
                          return (FactoryDef_ptr)0;
                        }
                      
                      static void _tao_any_destructor (void*);
                      
                      virtual CORBA::Boolean _is_a (
                          const CORBA::Char *type_id, 
                          CORBA::Environment &ACE_TRY_ENV = 
                            TAO_default_environment ()
                        );
                      
                      virtual void *_tao_QueryInterface (ptr_arith_t type);
                      
                      virtual const char* _interface_repository_id (void) const;

                    private:
                      _TAO_FactoryDef_Proxy_Broker *the_TAO_FactoryDef_Proxy_Broker_;
                      
                    protected:
                      FactoryDef (int collocated = 0);
                      
                      // This methods travese the inheritance tree and set the
                      // parents piece of the given class in the right mode
                      virtual void IR_FactoryDef_setup_collocation (int collocated);
                      
                      FactoryDef (
                          TAO_Stub *objref, 
                          CORBA::Boolean _tao_collocated = 0,
                          TAO_Abstract_ServantBase *servant = 0
                        );
                      
                      friend class _TAO_FactoryDef_Remote_Proxy_Impl;
                      friend class _TAO_FactoryDef_ThruPOA_Proxy_Impl;
                      friend class _TAO_FactoryDef_Direct_Proxy_Impl;
                      
                      virtual ~FactoryDef (void);
                    
                    private:
                      FactoryDef (const FactoryDef &);
                      void operator= (const FactoryDef &);
                    };
                    
                    // The Proxy Implementations are used by each interface to
                    // perform a call. Each different implementation encapsulate
                    // an invocation logics.
                    
                    
                    ///////////////////////////////////////////////////////////////////////
                    //                    Base Proxy Impl. Declaration
                    //
                    
                    class TAO_IFR_Client_Export _TAO_FactoryDef_Proxy_Impl
                      : public virtual _TAO_CORBA_OperationDef_Proxy_Impl
                    {
                    public:
                      virtual ~_TAO_FactoryDef_Proxy_Impl (void) { }
                      
                    protected:
                      _TAO_FactoryDef_Proxy_Impl (void);
                    };
                    
                    //
                    //               End Base Proxy Impl. Declaration
                    ///////////////////////////////////////////////////////////////////////
                    
                    
                    ///////////////////////////////////////////////////////////////////////
                    //                Remote Proxy Impl. Declaration
                    //
                    
                    class TAO_IFR_Client_Export _TAO_FactoryDef_Remote_Proxy_Impl
                      : public virtual _TAO_FactoryDef_Proxy_Impl,
                        public virtual TAO_Remote_Object_Proxy_Impl,
                        public virtual _TAO_CORBA_OperationDef_Remote_Proxy_Impl
                    {
                    public:
                      _TAO_FactoryDef_Remote_Proxy_Impl (void);
                      
                      virtual ~_TAO_FactoryDef_Remote_Proxy_Impl (void) { }
                      
                    };
                    
                    //
                    //             End Remote Proxy Impl. Declaration
                    ///////////////////////////////////////////////////////////////////////
                    
                    // The Proxy Brokers are used by each interface to get
                    // the right proxy for performing a call. In the new 
                    // collocation scheme, the proxy to be used can vary on
                    // a call by call basis.
                    
                    
                    ///////////////////////////////////////////////////////////////////////
                    //                 Base Proxy Broker Declaration 
                    //
                    
                                        class TAO_IFR_Client_Export _TAO_FactoryDef_Proxy_Broker
                    {
                    public:
                      virtual ~_TAO_FactoryDef_Proxy_Broker (void);
                      virtual _TAO_FactoryDef_Proxy_Impl &select_proxy (
                          FactoryDef *object,
                          CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
                        ) = 0;
                      
                    protected:
                      _TAO_FactoryDef_Proxy_Broker (void);
                      
                    };
                    
                    //
                    //              End Base Proxy Broker Declaration 
                    ///////////////////////////////////////////////////////////////////////
                    
                                        
                    ///////////////////////////////////////////////////////////////////////
                    //                 Remote Proxy Broker Declaration 
                    //
                    
                    class TAO_IFR_Client_Export _TAO_FactoryDef_Remote_Proxy_Broker
                      : public virtual _TAO_FactoryDef_Proxy_Broker
                    {
                    public: 
                      _TAO_FactoryDef_Remote_Proxy_Broker (void);
                      
                      virtual ~_TAO_FactoryDef_Remote_Proxy_Broker (void);
                      
                      virtual _TAO_FactoryDef_Proxy_Impl &select_proxy (
                          FactoryDef *object,
                          CORBA_Environment &ACE_TRY_ENV
                        );
                      
                      private:
                        _TAO_FactoryDef_Remote_Proxy_Impl remote_proxy_impl_;
                      
                      public:
                        // This member function is used to get an handle to the unique instance
                        // of the Remote Proxy Broker that is available for a given
                        // interface.
                        static _TAO_FactoryDef_Remote_Proxy_Broker *the_TAO_FactoryDef_Remote_Proxy_Broker (void);
                      };
                      
                      //
                      //              End Remote Proxy Broker Declaration 
                      ///////////////////////////////////////////////////////////////////////
                      
                      
#endif /* end #if !defined */
                      
                      TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_FactoryDef;
                      
                      
#if !defined (_IR_FINDERDEF_CH_)
#define _IR_FINDERDEF_CH_
                      
                      // Forward Classes Declaration
                      class _TAO_FinderDef_Proxy_Impl;
                      class _TAO_FinderDef_Remote_Proxy_Impl;
                      class _TAO_FinderDef_Proxy_Broker;
                      class _TAO_FinderDef_Remote_Proxy_Broker;
                      
                      class TAO_IFR_Client_Export FinderDef
                        : public virtual CORBA_OperationDef
                      {
                      public:
                      #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
                        typedef FinderDef_ptr _ptr_type;
                        typedef FinderDef_var _var_type;
                      #endif /* ! __GNUC__ || g++ >= 2.8 */

                        // the static operations
                        static FinderDef_ptr _duplicate (FinderDef_ptr obj);
                        
                        static FinderDef_ptr _narrow (
                            CORBA::Object_ptr obj,
                            CORBA::Environment &ACE_TRY_ENV = 
                              TAO_default_environment ()
                          );
                        
                        static FinderDef_ptr _unchecked_narrow (
                            CORBA::Object_ptr obj,
                            CORBA::Environment &ACE_TRY_ENV = 
                              TAO_default_environment ()
                          );
                        
                        static FinderDef_ptr _nil (void)
                          {
                            return (FinderDef_ptr)0;
                          }
                        
                        static void _tao_any_destructor (void*);
                        
                        virtual CORBA::Boolean _is_a (
                            const CORBA::Char *type_id, 
                            CORBA::Environment &ACE_TRY_ENV = 
                              TAO_default_environment ()
                          );
                        
                        virtual void *_tao_QueryInterface (ptr_arith_t type);
                        
                        virtual const char* _interface_repository_id (void) const;

                      private:
                        _TAO_FinderDef_Proxy_Broker *the_TAO_FinderDef_Proxy_Broker_;
                        
                      protected:
                        FinderDef (int collocated = 0);
                        
                        // This methods travese the inheritance tree and set the
                        // parents piece of the given class in the right mode
                        virtual void IR_FinderDef_setup_collocation (int collocated);
                        
                        FinderDef (
                            TAO_Stub *objref, 
                            CORBA::Boolean _tao_collocated = 0,
                            TAO_Abstract_ServantBase *servant = 0
                          );
                        
                        friend class _TAO_FinderDef_Remote_Proxy_Impl;
                        friend class _TAO_FinderDef_ThruPOA_Proxy_Impl;
                        friend class _TAO_FinderDef_Direct_Proxy_Impl;
                        
                        virtual ~FinderDef (void);
                      
                      private:
                        FinderDef (const FinderDef &);
                        void operator= (const FinderDef &);
                      };
                      
                      // The Proxy Implementations are used by each interface to
                      // perform a call. Each different implementation encapsulate
                      // an invocation logics.
                      
                      
                      ///////////////////////////////////////////////////////////////////////
                      //                    Base Proxy Impl. Declaration
                      //
                      
                      class TAO_IFR_Client_Export _TAO_FinderDef_Proxy_Impl
                        : public virtual _TAO_CORBA_OperationDef_Proxy_Impl
                      {
                      public:
                        virtual ~_TAO_FinderDef_Proxy_Impl (void) { }
                        
                      protected:
                        _TAO_FinderDef_Proxy_Impl (void);
                      };
                      
                      //
                      //               End Base Proxy Impl. Declaration
                      ///////////////////////////////////////////////////////////////////////
                      
                      
                      ///////////////////////////////////////////////////////////////////////
                      //                Remote Proxy Impl. Declaration
                      //
                      
                      class TAO_IFR_Client_Export _TAO_FinderDef_Remote_Proxy_Impl
                        : public virtual _TAO_FinderDef_Proxy_Impl,
                          public virtual TAO_Remote_Object_Proxy_Impl,
                          public virtual _TAO_CORBA_OperationDef_Remote_Proxy_Impl
                      {
                      public:
                        _TAO_FinderDef_Remote_Proxy_Impl (void);
                        
                        virtual ~_TAO_FinderDef_Remote_Proxy_Impl (void) { }
                        
                      };
                      
                      //
                      //             End Remote Proxy Impl. Declaration
                      ///////////////////////////////////////////////////////////////////////
                      
                      // The Proxy Brokers are used by each interface to get
                      // the right proxy for performing a call. In the new 
                      // collocation scheme, the proxy to be used can vary on
                      // a call by call basis.
                      
                      
                      ///////////////////////////////////////////////////////////////////////
                      //                 Base Proxy Broker Declaration 
                      //
                      
                                            class TAO_IFR_Client_Export _TAO_FinderDef_Proxy_Broker
                      {
                      public:
                        virtual ~_TAO_FinderDef_Proxy_Broker (void);
                        virtual _TAO_FinderDef_Proxy_Impl &select_proxy (
                            FinderDef *object,
                            CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
                          ) = 0;
                        
                      protected:
                        _TAO_FinderDef_Proxy_Broker (void);
                        
                      };
                      
                      //
                      //              End Base Proxy Broker Declaration 
                      ///////////////////////////////////////////////////////////////////////
                      
                                            
                      ///////////////////////////////////////////////////////////////////////
                      //                 Remote Proxy Broker Declaration 
                      //
                      
                      class TAO_IFR_Client_Export _TAO_FinderDef_Remote_Proxy_Broker
                        : public virtual _TAO_FinderDef_Proxy_Broker
                      {
                      public: 
                        _TAO_FinderDef_Remote_Proxy_Broker (void);
                        
                        virtual ~_TAO_FinderDef_Remote_Proxy_Broker (void);
                        
                        virtual _TAO_FinderDef_Proxy_Impl &select_proxy (
                            FinderDef *object,
                            CORBA_Environment &ACE_TRY_ENV
                          );
                        
                        private:
                          _TAO_FinderDef_Remote_Proxy_Impl remote_proxy_impl_;
                        
                        public:
                          // This member function is used to get an handle to the unique instance
                          // of the Remote Proxy Broker that is available for a given
                          // interface.
                          static _TAO_FinderDef_Remote_Proxy_Broker *the_TAO_FinderDef_Remote_Proxy_Broker (void);
                        };
                        
                        //
                        //              End Remote Proxy Broker Declaration 
                        ///////////////////////////////////////////////////////////////////////
                        
                        
#endif /* end #if !defined */
                        
                        TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_FinderDef;
                        
                        
#if !defined (_IR_HOMEDEF_CH_)
#define _IR_HOMEDEF_CH_
                        
                        // Forward Classes Declaration
                        class _TAO_HomeDef_Proxy_Impl;
                        class _TAO_HomeDef_Remote_Proxy_Impl;
                        class _TAO_HomeDef_Proxy_Broker;
                        class _TAO_HomeDef_Remote_Proxy_Broker;
                        
                        class TAO_IFR_Client_Export HomeDef
                          : public virtual CORBA_InterfaceDef
                        {
                        public:
                        #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
                          typedef HomeDef_ptr _ptr_type;
                          typedef HomeDef_var _var_type;
                        #endif /* ! __GNUC__ || g++ >= 2.8 */

                          // the static operations
                          static HomeDef_ptr _duplicate (HomeDef_ptr obj);
                          
                          static HomeDef_ptr _narrow (
                              CORBA::Object_ptr obj,
                              CORBA::Environment &ACE_TRY_ENV = 
                                TAO_default_environment ()
                            );
                          
                          static HomeDef_ptr _unchecked_narrow (
                              CORBA::Object_ptr obj,
                              CORBA::Environment &ACE_TRY_ENV = 
                                TAO_default_environment ()
                            );
                          
                          static HomeDef_ptr _nil (void)
                            {
                              return (HomeDef_ptr)0;
                            }
                          
                          static void _tao_any_destructor (void*);
                          
                          virtual IR::HomeDef_ptr base_home (
                              CORBA::Environment &ACE_TRY_ENV = 
                                TAO_default_environment ()
                            )
                            ACE_THROW_SPEC ((
                              CORBA::SystemException
                            ));
                          
                          virtual IR::ComponentDef_ptr managed_component (
                              CORBA::Environment &ACE_TRY_ENV = 
                                TAO_default_environment ()
                            )
                            ACE_THROW_SPEC ((
                              CORBA::SystemException
                            ));
                          
                          virtual IR::PrimaryKeyDef_ptr primary_key (
                              CORBA::Environment &ACE_TRY_ENV = 
                                TAO_default_environment ()
                            )
                            ACE_THROW_SPEC ((
                              CORBA::SystemException
                            ));
                          
                          virtual IR::FactoryDefSeq * factories (
                              CORBA::Environment &ACE_TRY_ENV = 
                                TAO_default_environment ()
                            )
                            ACE_THROW_SPEC ((
                              CORBA::SystemException
                            ));
                          
                          virtual IR::FinderDefSeq * finders (
                              CORBA::Environment &ACE_TRY_ENV = 
                                TAO_default_environment ()
                            )
                            ACE_THROW_SPEC ((
                              CORBA::SystemException
                            ));
                          
                          virtual CORBA::Boolean is_basic (
                              CORBA::Environment &ACE_TRY_ENV = 
                                TAO_default_environment ()
                            )
                            ACE_THROW_SPEC ((
                              CORBA::SystemException
                            ));
                          
                          virtual IR::PrimaryKeyDef_ptr create_primary_key (
                              const char * id,
                              const char * name,
                              const char * version,
                              CORBA_ValueDef_ptr primary_key,
                              CORBA::Environment &ACE_TRY_ENV = 
                                TAO_default_environment ()
                            )
                            ACE_THROW_SPEC ((
                              CORBA::SystemException
                            ));
                          
                          virtual IR::FactoryDef_ptr create_factory (
                              const char * id,
                              const char * name,
                              const char * version,
                              const CORBA_ParDescriptionSeq & params,
                              const CORBA_ExceptionDefSeq & exceptions,
                              CORBA::Environment &ACE_TRY_ENV = 
                                TAO_default_environment ()
                            )
                            ACE_THROW_SPEC ((
                              CORBA::SystemException
                            ));
                          
                          virtual IR::FinderDef_ptr create_finder (
                              const char * id,
                              const char * name,
                              const char * version,
                              const CORBA_ParDescriptionSeq & params,
                              const CORBA_ExceptionDefSeq & exceptions,
                              CORBA::Environment &ACE_TRY_ENV = 
                                TAO_default_environment ()
                            )
                            ACE_THROW_SPEC ((
                              CORBA::SystemException
                            ));
                          
                          virtual CORBA::Boolean _is_a (
                              const CORBA::Char *type_id, 
                              CORBA::Environment &ACE_TRY_ENV = 
                                TAO_default_environment ()
                            );
                          
                          virtual void *_tao_QueryInterface (ptr_arith_t type);
                          
                          virtual const char* _interface_repository_id (void) const;

                        private:
                          _TAO_HomeDef_Proxy_Broker *the_TAO_HomeDef_Proxy_Broker_;
                          
                        protected:
                          HomeDef (int collocated = 0);
                          
                          // This methods travese the inheritance tree and set the
                          // parents piece of the given class in the right mode
                          virtual void IR_HomeDef_setup_collocation (int collocated);
                          
                          HomeDef (
                              TAO_Stub *objref, 
                              CORBA::Boolean _tao_collocated = 0,
                              TAO_Abstract_ServantBase *servant = 0
                            );
                          
                          friend class _TAO_HomeDef_Remote_Proxy_Impl;
                          friend class _TAO_HomeDef_ThruPOA_Proxy_Impl;
                          friend class _TAO_HomeDef_Direct_Proxy_Impl;
                          
                          virtual ~HomeDef (void);
                        
                        private:
                          HomeDef (const HomeDef &);
                          void operator= (const HomeDef &);
                        };
                        
                        // The Proxy Implementations are used by each interface to
                        // perform a call. Each different implementation encapsulate
                        // an invocation logics.
                        
                        
                        ///////////////////////////////////////////////////////////////////////
                        //                    Base Proxy Impl. Declaration
                        //
                        
                        class TAO_IFR_Client_Export _TAO_HomeDef_Proxy_Impl
                          : public virtual _TAO_CORBA_InterfaceDef_Proxy_Impl
                        {
                        public:
                          virtual ~_TAO_HomeDef_Proxy_Impl (void) { }
                          virtual IR::HomeDef_ptr base_home (
                              CORBA_Object *_collocated_tao_target_,
                              CORBA::Environment &ACE_TRY_ENV
                            )
                            ACE_THROW_SPEC ((
                              CORBA::SystemException
                            )) = 0;
                          
                          virtual IR::ComponentDef_ptr managed_component (
                              CORBA_Object *_collocated_tao_target_,
                              CORBA::Environment &ACE_TRY_ENV
                            )
                            ACE_THROW_SPEC ((
                              CORBA::SystemException
                            )) = 0;
                          
                          virtual IR::PrimaryKeyDef_ptr primary_key (
                              CORBA_Object *_collocated_tao_target_,
                              CORBA::Environment &ACE_TRY_ENV
                            )
                            ACE_THROW_SPEC ((
                              CORBA::SystemException
                            )) = 0;
                          
                          virtual IR::FactoryDefSeq * factories (
                              CORBA_Object *_collocated_tao_target_,
                              CORBA::Environment &ACE_TRY_ENV
                            )
                            ACE_THROW_SPEC ((
                              CORBA::SystemException
                            )) = 0;
                          
                          virtual IR::FinderDefSeq * finders (
                              CORBA_Object *_collocated_tao_target_,
                              CORBA::Environment &ACE_TRY_ENV
                            )
                            ACE_THROW_SPEC ((
                              CORBA::SystemException
                            )) = 0;
                          
                          virtual CORBA::Boolean is_basic (
                              CORBA_Object *_collocated_tao_target_,
                              CORBA::Environment &ACE_TRY_ENV
                            )
                            ACE_THROW_SPEC ((
                              CORBA::SystemException
                            )) = 0;
                          
                          virtual IR::PrimaryKeyDef_ptr create_primary_key (
                              CORBA_Object *_collocated_tao_target_,
                              const char * id,
                              const char * name,
                              const char * version,
                              CORBA_ValueDef_ptr primary_key,
                              CORBA::Environment &ACE_TRY_ENV
                            )
                            ACE_THROW_SPEC ((
                              CORBA::SystemException
                            )) = 0;
                          
                          virtual IR::FactoryDef_ptr create_factory (
                              CORBA_Object *_collocated_tao_target_,
                              const char * id,
                              const char * name,
                              const char * version,
                              const CORBA_ParDescriptionSeq & params,
                              const CORBA_ExceptionDefSeq & exceptions,
                              CORBA::Environment &ACE_TRY_ENV
                            )
                            ACE_THROW_SPEC ((
                              CORBA::SystemException
                            )) = 0;
                          
                          virtual IR::FinderDef_ptr create_finder (
                              CORBA_Object *_collocated_tao_target_,
                              const char * id,
                              const char * name,
                              const char * version,
                              const CORBA_ParDescriptionSeq & params,
                              const CORBA_ExceptionDefSeq & exceptions,
                              CORBA::Environment &ACE_TRY_ENV
                            )
                            ACE_THROW_SPEC ((
                              CORBA::SystemException
                            )) = 0;
                          
                          
                        protected:
                          _TAO_HomeDef_Proxy_Impl (void);
                        };
                        
                        //
                        //               End Base Proxy Impl. Declaration
                        ///////////////////////////////////////////////////////////////////////
                        
                        
                        ///////////////////////////////////////////////////////////////////////
                        //                Remote Proxy Impl. Declaration
                        //
                        
                        class TAO_IFR_Client_Export _TAO_HomeDef_Remote_Proxy_Impl
                          : public virtual _TAO_HomeDef_Proxy_Impl,
                            public virtual TAO_Remote_Object_Proxy_Impl,
                            public virtual _TAO_CORBA_InterfaceDef_Remote_Proxy_Impl
                        {
                        public:
                          _TAO_HomeDef_Remote_Proxy_Impl (void);
                          
                          virtual ~_TAO_HomeDef_Remote_Proxy_Impl (void) { }
                          virtual IR::HomeDef_ptr base_home (
                              CORBA_Object *_collocated_tao_target_,
                              CORBA::Environment &ACE_TRY_ENV
                            )
                            ACE_THROW_SPEC ((
                              CORBA::SystemException
                            ));
                          
                          virtual IR::ComponentDef_ptr managed_component (
                              CORBA_Object *_collocated_tao_target_,
                              CORBA::Environment &ACE_TRY_ENV
                            )
                            ACE_THROW_SPEC ((
                              CORBA::SystemException
                            ));
                          
                          virtual IR::PrimaryKeyDef_ptr primary_key (
                              CORBA_Object *_collocated_tao_target_,
                              CORBA::Environment &ACE_TRY_ENV
                            )
                            ACE_THROW_SPEC ((
                              CORBA::SystemException
                            ));
                          
                          virtual IR::FactoryDefSeq * factories (
                              CORBA_Object *_collocated_tao_target_,
                              CORBA::Environment &ACE_TRY_ENV
                            )
                            ACE_THROW_SPEC ((
                              CORBA::SystemException
                            ));
                          
                          virtual IR::FinderDefSeq * finders (
                              CORBA_Object *_collocated_tao_target_,
                              CORBA::Environment &ACE_TRY_ENV
                            )
                            ACE_THROW_SPEC ((
                              CORBA::SystemException
                            ));
                          
                          virtual CORBA::Boolean is_basic (
                              CORBA_Object *_collocated_tao_target_,
                              CORBA::Environment &ACE_TRY_ENV
                            )
                            ACE_THROW_SPEC ((
                              CORBA::SystemException
                            ));
                          
                          virtual IR::PrimaryKeyDef_ptr create_primary_key (
                              CORBA_Object *_collocated_tao_target_,
                              const char * id,
                              const char * name,
                              const char * version,
                              CORBA_ValueDef_ptr primary_key,
                              CORBA::Environment &ACE_TRY_ENV
                            )
                            ACE_THROW_SPEC ((
                              CORBA::SystemException
                            ));
                          
                          virtual IR::FactoryDef_ptr create_factory (
                              CORBA_Object *_collocated_tao_target_,
                              const char * id,
                              const char * name,
                              const char * version,
                              const CORBA_ParDescriptionSeq & params,
                              const CORBA_ExceptionDefSeq & exceptions,
                              CORBA::Environment &ACE_TRY_ENV
                            )
                            ACE_THROW_SPEC ((
                              CORBA::SystemException
                            ));
                          
                          virtual IR::FinderDef_ptr create_finder (
                              CORBA_Object *_collocated_tao_target_,
                              const char * id,
                              const char * name,
                              const char * version,
                              const CORBA_ParDescriptionSeq & params,
                              const CORBA_ExceptionDefSeq & exceptions,
                              CORBA::Environment &ACE_TRY_ENV
                            )
                            ACE_THROW_SPEC ((
                              CORBA::SystemException
                            ));
                          
                          
                        };
                        
                        //
                        //             End Remote Proxy Impl. Declaration
                        ///////////////////////////////////////////////////////////////////////
                        
                        // The Proxy Brokers are used by each interface to get
                        // the right proxy for performing a call. In the new 
                        // collocation scheme, the proxy to be used can vary on
                        // a call by call basis.
                        
                        
                        ///////////////////////////////////////////////////////////////////////
                        //                 Base Proxy Broker Declaration 
                        //
                        
                                                class TAO_IFR_Client_Export _TAO_HomeDef_Proxy_Broker
                        {
                        public:
                          virtual ~_TAO_HomeDef_Proxy_Broker (void);
                          virtual _TAO_HomeDef_Proxy_Impl &select_proxy (
                              HomeDef *object,
                              CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
                            ) = 0;
                          
                        protected:
                          _TAO_HomeDef_Proxy_Broker (void);
                          
                        };
                        
                        //
                        //              End Base Proxy Broker Declaration 
                        ///////////////////////////////////////////////////////////////////////
                        
                                                
                        ///////////////////////////////////////////////////////////////////////
                        //                 Remote Proxy Broker Declaration 
                        //
                        
                        class TAO_IFR_Client_Export _TAO_HomeDef_Remote_Proxy_Broker
                          : public virtual _TAO_HomeDef_Proxy_Broker
                        {
                        public: 
                          _TAO_HomeDef_Remote_Proxy_Broker (void);
                          
                          virtual ~_TAO_HomeDef_Remote_Proxy_Broker (void);
                          
                          virtual _TAO_HomeDef_Proxy_Impl &select_proxy (
                              HomeDef *object,
                              CORBA_Environment &ACE_TRY_ENV
                            );
                          
                          private:
                            _TAO_HomeDef_Remote_Proxy_Impl remote_proxy_impl_;
                          
                          public:
                            // This member function is used to get an handle to the unique instance
                            // of the Remote Proxy Broker that is available for a given
                            // interface.
                            static _TAO_HomeDef_Remote_Proxy_Broker *the_TAO_HomeDef_Remote_Proxy_Broker (void);
                          };
                          
                          //
                          //              End Remote Proxy Broker Declaration 
                          ///////////////////////////////////////////////////////////////////////
                          
                          
#endif /* end #if !defined */
                          
                          TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_HomeDef;
                          
                          struct HomeDescription;
                          class HomeDescription_var;
                          
                          struct TAO_IFR_Client_Export HomeDescription
                          {
                            
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
                            typedef HomeDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

                            static void _tao_any_destructor (void*);
                            
                            TAO_String_Manager name;
                            TAO_String_Manager id;
                            TAO_String_Manager defined_in;
                            TAO_String_Manager version;
                            TAO_String_Manager base_home;
                            TAO_String_Manager managed_component;
                            ACE_NESTED_CLASS (IR, PrimaryKeyDef_var) primary_key_def;
                            ACE_NESTED_CLASS (IR, FactoryDefSeq) factories;
                            ACE_NESTED_CLASS (IR, FinderDefSeq) finders;
                            CORBA_OpDescriptionSeq operations;
                            CORBA_AttrDescriptionSeq attributes;
                            CORBA::Boolean is_basic;
                            
                          };
                          
                          class TAO_IFR_Client_Export HomeDescription_var
                          {
                          public:
                            HomeDescription_var (void);
                            HomeDescription_var (HomeDescription *);
                            HomeDescription_var (const HomeDescription_var &);
                            ~HomeDescription_var (void);
                            
                            HomeDescription_var &operator= (HomeDescription *);
                            HomeDescription_var &operator= (const HomeDescription_var &);
                            HomeDescription *operator-> (void);
                            const HomeDescription *operator-> (void) const;
                            
                            operator const HomeDescription &() const;
                            operator HomeDescription &();
                            operator HomeDescription &() const;
                            // Variable-size types only.
                            operator HomeDescription *&();
                            
                            // in, inout, out, _retn 
                            const HomeDescription &in (void) const;
                            HomeDescription &inout (void);
                            HomeDescription *&out (void);
                            HomeDescription *_retn (void);
                            HomeDescription *ptr (void) const;
                          
                          private:
                            HomeDescription *ptr_;
                          };
                          
                          class TAO_IFR_Client_Export HomeDescription_out
                          {
                          public:
                            HomeDescription_out (HomeDescription *&);
                            HomeDescription_out (HomeDescription_var &);
                            HomeDescription_out (const HomeDescription_out &);
                            HomeDescription_out &operator= (const HomeDescription_out &);
                            HomeDescription_out &operator= (HomeDescription *);
                            operator HomeDescription *&();
                            HomeDescription *&ptr (void);
                            HomeDescription *operator-> (void);
                            
                          private:
                            HomeDescription *&ptr_;
                            // Assignment from T_var not allowed.
                            void operator= (const HomeDescription_var &);
                          };
                          
                          TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_HomeDescription;
                          
                          
                        }
TAO_NAMESPACE_CLOSE // module IR

// Proxy Broker Factory function pointer declarations.
                        
                        extern TAO_IFR_Client_Export
                        IR::_TAO_ComponentRepository_Proxy_Broker *
                        (*IR__TAO_ComponentRepository_Proxy_Broker_Factory_function_pointer) (
                            CORBA::Object_ptr obj
                          );
                        
                        extern TAO_IFR_Client_Export
                        IR::_TAO_ProvidesDef_Proxy_Broker *
                        (*IR__TAO_ProvidesDef_Proxy_Broker_Factory_function_pointer) (
                            CORBA::Object_ptr obj
                          );
                        
                        extern TAO_IFR_Client_Export
                        IR::_TAO_UsesDef_Proxy_Broker *
                        (*IR__TAO_UsesDef_Proxy_Broker_Factory_function_pointer) (
                            CORBA::Object_ptr obj
                          );
                        
                        extern TAO_IFR_Client_Export
                        IR::_TAO_EventDef_Proxy_Broker *
                        (*IR__TAO_EventDef_Proxy_Broker_Factory_function_pointer) (
                            CORBA::Object_ptr obj
                          );
                        
                        extern TAO_IFR_Client_Export
                        IR::_TAO_EmitsDef_Proxy_Broker *
                        (*IR__TAO_EmitsDef_Proxy_Broker_Factory_function_pointer) (
                            CORBA::Object_ptr obj
                          );
                        
                        extern TAO_IFR_Client_Export
                        IR::_TAO_PublishesDef_Proxy_Broker *
                        (*IR__TAO_PublishesDef_Proxy_Broker_Factory_function_pointer) (
                            CORBA::Object_ptr obj
                          );
                        
                        extern TAO_IFR_Client_Export
                        IR::_TAO_ConsumesDef_Proxy_Broker *
                        (*IR__TAO_ConsumesDef_Proxy_Broker_Factory_function_pointer) (
                            CORBA::Object_ptr obj
                          );
                        
                        extern TAO_IFR_Client_Export
                        IR::_TAO_ComponentDef_Proxy_Broker *
                        (*IR__TAO_ComponentDef_Proxy_Broker_Factory_function_pointer) (
                            CORBA::Object_ptr obj
                          );
                        
                        extern TAO_IFR_Client_Export
                        IR::_TAO_PrimaryKeyDef_Proxy_Broker *
                        (*IR__TAO_PrimaryKeyDef_Proxy_Broker_Factory_function_pointer) (
                            CORBA::Object_ptr obj
                          );
                        
                        extern TAO_IFR_Client_Export
                        IR::_TAO_FactoryDef_Proxy_Broker *
                        (*IR__TAO_FactoryDef_Proxy_Broker_Factory_function_pointer) (
                            CORBA::Object_ptr obj
                          );
                        
                        extern TAO_IFR_Client_Export
                        IR::_TAO_FinderDef_Proxy_Broker *
                        (*IR__TAO_FinderDef_Proxy_Broker_Factory_function_pointer) (
                            CORBA::Object_ptr obj
                          );
                        
                        extern TAO_IFR_Client_Export
                        IR::_TAO_HomeDef_Proxy_Broker *
                        (*IR__TAO_HomeDef_Proxy_Broker_Factory_function_pointer) (
                            CORBA::Object_ptr obj
                          );
                        
                                                                                                                                                TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::RepositoryIdSeq &); // copying version
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::RepositoryIdSeq*); // noncopying version
                        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::RepositoryIdSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::RepositoryIdSeq *&);
                                                                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::ComponentDefSeq &); // copying version
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::ComponentDefSeq*); // noncopying version
                        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::ComponentDefSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::ComponentDefSeq *&);
                                                TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::ProvidesDefSeq &); // copying version
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::ProvidesDefSeq*); // noncopying version
                        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::ProvidesDefSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::ProvidesDefSeq *&);
                                                TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::UsesDefSeq &); // copying version
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::UsesDefSeq*); // noncopying version
                        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::UsesDefSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::UsesDefSeq *&);
                                                TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::HomeDefSeq &); // copying version
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::HomeDefSeq*); // noncopying version
                        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::HomeDefSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::HomeDefSeq *&);
                                                TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::EmitsDefSeq &); // copying version
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::EmitsDefSeq*); // noncopying version
                        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::EmitsDefSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::EmitsDefSeq *&);
                                                TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::PublishesDefSeq &); // copying version
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::PublishesDefSeq*); // noncopying version
                        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::PublishesDefSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::PublishesDefSeq *&);
                                                TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::ConsumesDefSeq &); // copying version
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::ConsumesDefSeq*); // noncopying version
                        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::ConsumesDefSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::ConsumesDefSeq *&);
                                                TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::FactoryDefSeq &); // copying version
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::FactoryDefSeq*); // noncopying version
                        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::FactoryDefSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::FactoryDefSeq *&);
                                                TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::FinderDefSeq &); // copying version
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::FinderDefSeq*); // noncopying version
                        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::FinderDefSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::FinderDefSeq *&);
                        // Any operators for interface IR::ComponentRepository
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::ComponentRepository_ptr);
                        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::ComponentRepository *&);
                        // Any operators for interface IR::ProvidesDef
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::ProvidesDef_ptr);
                        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::ProvidesDef *&);
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::ProvidesDescription &); // copying version
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::ProvidesDescription*); // noncopying version
                        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::ProvidesDescription *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::ProvidesDescription *&);
                        // Any operators for interface IR::UsesDef
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::UsesDef_ptr);
                        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::UsesDef *&);
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::UsesDescription &); // copying version
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::UsesDescription*); // noncopying version
                        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::UsesDescription *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::UsesDescription *&);
                                                TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::ProvidesDescSeq &); // copying version
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::ProvidesDescSeq*); // noncopying version
                        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::ProvidesDescSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::ProvidesDescSeq *&);
                                                TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::UsesDescSeq &); // copying version
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::UsesDescSeq*); // noncopying version
                        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::UsesDescSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::UsesDescSeq *&);
                        // Any operators for interface IR::EventDef
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::EventDef_ptr);
                        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::EventDef *&);
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::EventDescription &); // copying version
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::EventDescription*); // noncopying version
                        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::EventDescription *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::EventDescription *&);
                        // Any operators for interface IR::EmitsDef
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::EmitsDef_ptr);
                        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::EmitsDef *&);
                        // Any operators for interface IR::PublishesDef
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::PublishesDef_ptr);
                        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::PublishesDef *&);
                        // Any operators for interface IR::ConsumesDef
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::ConsumesDef_ptr);
                        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::ConsumesDef *&);
                        // Any operators for interface IR::ComponentDef
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::ComponentDef_ptr);
                        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::ComponentDef *&);
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::ComponentDescription &); // copying version
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::ComponentDescription*); // noncopying version
                        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::ComponentDescription *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::ComponentDescription *&);
                        // Any operators for interface IR::PrimaryKeyDef
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::PrimaryKeyDef_ptr);
                        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::PrimaryKeyDef *&);
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::PrimaryKeyDescription &); // copying version
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::PrimaryKeyDescription*); // noncopying version
                        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::PrimaryKeyDescription *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::PrimaryKeyDescription *&);
                        // Any operators for interface IR::FactoryDef
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::FactoryDef_ptr);
                        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::FactoryDef *&);
                        // Any operators for interface IR::FinderDef
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::FinderDef_ptr);
                        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::FinderDef *&);
                        // Any operators for interface IR::HomeDef
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::HomeDef_ptr);
                        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::HomeDef *&);
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::HomeDescription &); // copying version
                        TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::HomeDescription*); // noncopying version
                        TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::HomeDescription *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::HomeDescription *&);

                        #ifndef __ACE_INLINE__

                                                                                                
#if !defined _TAO_CDR_OP_IR_RepositoryIdSeq_H_
                        #define _TAO_CDR_OP_IR_RepositoryIdSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
                            TAO_OutputCDR &,
                            const IR::RepositoryIdSeq &
                          );
                        TAO_IFR_Client_Export CORBA::Boolean operator>> (
                            TAO_InputCDR &,
                            IR::RepositoryIdSeq &
                          );

#endif /* _TAO_CDR_OP_IR_RepositoryIdSeq_H_ */

                                                
#if !defined _TAO_CDR_OP_IR_ComponentDefSeq_H_
                        #define _TAO_CDR_OP_IR_ComponentDefSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
                            TAO_OutputCDR &,
                            const IR::ComponentDefSeq &
                          );
                        TAO_IFR_Client_Export CORBA::Boolean operator>> (
                            TAO_InputCDR &,
                            IR::ComponentDefSeq &
                          );

#endif /* _TAO_CDR_OP_IR_ComponentDefSeq_H_ */

                        
#if !defined _TAO_CDR_OP_IR_ProvidesDefSeq_H_
                        #define _TAO_CDR_OP_IR_ProvidesDefSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
                            TAO_OutputCDR &,
                            const IR::ProvidesDefSeq &
                          );
                        TAO_IFR_Client_Export CORBA::Boolean operator>> (
                            TAO_InputCDR &,
                            IR::ProvidesDefSeq &
                          );

#endif /* _TAO_CDR_OP_IR_ProvidesDefSeq_H_ */

                        
#if !defined _TAO_CDR_OP_IR_UsesDefSeq_H_
                        #define _TAO_CDR_OP_IR_UsesDefSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
                            TAO_OutputCDR &,
                            const IR::UsesDefSeq &
                          );
                        TAO_IFR_Client_Export CORBA::Boolean operator>> (
                            TAO_InputCDR &,
                            IR::UsesDefSeq &
                          );

#endif /* _TAO_CDR_OP_IR_UsesDefSeq_H_ */

                        
#if !defined _TAO_CDR_OP_IR_HomeDefSeq_H_
                        #define _TAO_CDR_OP_IR_HomeDefSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
                            TAO_OutputCDR &,
                            const IR::HomeDefSeq &
                          );
                        TAO_IFR_Client_Export CORBA::Boolean operator>> (
                            TAO_InputCDR &,
                            IR::HomeDefSeq &
                          );

#endif /* _TAO_CDR_OP_IR_HomeDefSeq_H_ */

                        
#if !defined _TAO_CDR_OP_IR_EmitsDefSeq_H_
                        #define _TAO_CDR_OP_IR_EmitsDefSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
                            TAO_OutputCDR &,
                            const IR::EmitsDefSeq &
                          );
                        TAO_IFR_Client_Export CORBA::Boolean operator>> (
                            TAO_InputCDR &,
                            IR::EmitsDefSeq &
                          );

#endif /* _TAO_CDR_OP_IR_EmitsDefSeq_H_ */

                        
#if !defined _TAO_CDR_OP_IR_PublishesDefSeq_H_
                        #define _TAO_CDR_OP_IR_PublishesDefSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
                            TAO_OutputCDR &,
                            const IR::PublishesDefSeq &
                          );
                        TAO_IFR_Client_Export CORBA::Boolean operator>> (
                            TAO_InputCDR &,
                            IR::PublishesDefSeq &
                          );

#endif /* _TAO_CDR_OP_IR_PublishesDefSeq_H_ */

                        
#if !defined _TAO_CDR_OP_IR_ConsumesDefSeq_H_
                        #define _TAO_CDR_OP_IR_ConsumesDefSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
                            TAO_OutputCDR &,
                            const IR::ConsumesDefSeq &
                          );
                        TAO_IFR_Client_Export CORBA::Boolean operator>> (
                            TAO_InputCDR &,
                            IR::ConsumesDefSeq &
                          );

#endif /* _TAO_CDR_OP_IR_ConsumesDefSeq_H_ */

                        
#if !defined _TAO_CDR_OP_IR_FactoryDefSeq_H_
                        #define _TAO_CDR_OP_IR_FactoryDefSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
                            TAO_OutputCDR &,
                            const IR::FactoryDefSeq &
                          );
                        TAO_IFR_Client_Export CORBA::Boolean operator>> (
                            TAO_InputCDR &,
                            IR::FactoryDefSeq &
                          );

#endif /* _TAO_CDR_OP_IR_FactoryDefSeq_H_ */

                        
#if !defined _TAO_CDR_OP_IR_FinderDefSeq_H_
                        #define _TAO_CDR_OP_IR_FinderDefSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
                            TAO_OutputCDR &,
                            const IR::FinderDefSeq &
                          );
                        TAO_IFR_Client_Export CORBA::Boolean operator>> (
                            TAO_InputCDR &,
                            IR::FinderDefSeq &
                          );

#endif /* _TAO_CDR_OP_IR_FinderDefSeq_H_ */

                        TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::ComponentRepository_ptr );
                        TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::ComponentRepository_ptr &);
                        TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::ProvidesDef_ptr );
                        TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::ProvidesDef_ptr &);
                        TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::ProvidesDescription &);
                        TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::ProvidesDescription &);
                        TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::UsesDef_ptr );
                        TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::UsesDef_ptr &);
                        TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::UsesDescription &);
                        TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::UsesDescription &);
                        
#if !defined _TAO_CDR_OP_IR_ProvidesDescSeq_H_
                        #define _TAO_CDR_OP_IR_ProvidesDescSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
                            TAO_OutputCDR &,
                            const IR::ProvidesDescSeq &
                          );
                        TAO_IFR_Client_Export CORBA::Boolean operator>> (
                            TAO_InputCDR &,
                            IR::ProvidesDescSeq &
                          );

#endif /* _TAO_CDR_OP_IR_ProvidesDescSeq_H_ */

                        
#if !defined _TAO_CDR_OP_IR_UsesDescSeq_H_
                        #define _TAO_CDR_OP_IR_UsesDescSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
                            TAO_OutputCDR &,
                            const IR::UsesDescSeq &
                          );
                        TAO_IFR_Client_Export CORBA::Boolean operator>> (
                            TAO_InputCDR &,
                            IR::UsesDescSeq &
                          );

#endif /* _TAO_CDR_OP_IR_UsesDescSeq_H_ */

                        TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::EventDef_ptr );
                        TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::EventDef_ptr &);
                        TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::EventDescription &);
                        TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::EventDescription &);
                        TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::EmitsDef_ptr );
                        TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::EmitsDef_ptr &);
                        TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::PublishesDef_ptr );
                        TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::PublishesDef_ptr &);
                        TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::ConsumesDef_ptr );
                        TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::ConsumesDef_ptr &);
                        TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::ComponentDef_ptr );
                        TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::ComponentDef_ptr &);
                        TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::ComponentDescription &);
                        TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::ComponentDescription &);
                        TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::PrimaryKeyDef_ptr );
                        TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::PrimaryKeyDef_ptr &);
                        TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::PrimaryKeyDescription &);
                        TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::PrimaryKeyDescription &);
                        TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::FactoryDef_ptr );
                        TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::FactoryDef_ptr &);
                        TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::FinderDef_ptr );
                        TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::FinderDef_ptr &);
                        TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::HomeDef_ptr );
                        TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::HomeDef_ptr &);
                        TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::HomeDescription &);
                        TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::HomeDescription &);

                        #endif /* __ACE_INLINE__ */


#if defined (__ACE_INLINE__)
#include "IFR_ComponentsC.i"
#endif /* defined INLINE */

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(pop)
#endif /* _MSC_VER */

#if defined (__BORLANDC__)
#pragma option pop
#endif /* __BORLANDC__ */

#include "ace/post.h"
#endif /* ifndef */
