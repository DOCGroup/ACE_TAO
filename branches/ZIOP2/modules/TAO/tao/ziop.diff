Index: CDR.cpp
===================================================================
--- CDR.cpp	(revision 73868)
+++ CDR.cpp	(working copy)
@@ -73,6 +73,7 @@
                    minor_version)
   , fragmentation_strategy_ (0)
   , more_fragments_ (false)
+  , compressed_ (false)
   , request_id_ (0)
   , stub_ (0)
   , message_semantics_ (-1)
@@ -101,6 +102,7 @@
                    minor_version)
   , fragmentation_strategy_ (0)
   , more_fragments_ (false)
+  , compressed_ (false)
   , request_id_ (0)
   , stub_ (0)
   , message_semantics_ (-1)
@@ -130,6 +132,7 @@
                    minor_version)
   , fragmentation_strategy_ (fs)
   , more_fragments_ (false)
+  , compressed_ (false)
   , request_id_ (0)
   , stub_ (0)
   , message_semantics_ (-1)
@@ -150,6 +153,7 @@
                    minor_version)
   , fragmentation_strategy_ (0)
   , more_fragments_ (false)
+  , compressed_ (false)
   , request_id_ (0)
   , stub_ (0)
   , message_semantics_ (-1)
@@ -173,6 +177,7 @@
                     minor_version)
   , fragmentation_strategy_ (fs)
   , more_fragments_ (false)
+  , compressed_ (false)
   , request_id_ (0)
   , stub_ (0)
   , message_semantics_ (-1)
Index: ORB_Core.cpp
===================================================================
--- ORB_Core.cpp	(revision 73868)
+++ ORB_Core.cpp	(working copy)
@@ -277,7 +277,8 @@
     bidir_adapter_ (0),
     bidir_giop_policy_ (0),
     flushing_strategy_ (0),
-    codeset_manager_ (0)
+    codeset_manager_ (0),
+    compression_enabled_ (true)
 {
 #if (TAO_HAS_BUFFERING_CONSTRAINT_POLICY == 1)

Index: GIOP_Message_Base.cpp
===================================================================
--- GIOP_Message_Base.cpp	(revision 73868)
+++ GIOP_Message_Base.cpp	(working copy)
@@ -13,6 +13,10 @@
 #include "tao/Codeset_Manager.h"
 #include "tao/SystemException.h"

+#if !defined (__BORLANDC__)
+#include "zlib.h"
+#endif
+
 /*
  * Hook to add additional include files during specializations.
  */
@@ -964,23 +968,39 @@
       parse_error =
         parser->parse_request_header (request);

-      TAO_Codeset_Manager *csm = request.orb_core ()->codeset_manager ();
+      // Throw an exception if the
+      if (parse_error != 0)
+        ACE_TRY_THROW (CORBA::MARSHAL (0,
+                                       CORBA::COMPLETED_NO));
+
+	  TAO_Codeset_Manager *csm = request.orb_core ()->codeset_manager ();
       if (csm)
         {
           csm->process_service_context (request);
           transport->assign_translators (&cdr, &output);
         }
+
+	  request_id = request.request_id ();

-      // Throw an exception if the
-      if (parse_error != 0)
-        ACE_TRY_THROW (CORBA::MARSHAL (0,
-                                       CORBA::COMPLETED_NO));
-      request_id = request.request_id ();
-
       response_required = request.response_expected ();

       CORBA::Object_var forward_to;
+//if (request.compressed_)
+//{
+#if !defined (__BORLANDC__)
+            Bytef* LargBuffer = new Bytef [request.original_message_length_ * 2];
+			uLongf length = request.original_message_length_ * 2;
+            int retval = uncompress (LargBuffer,   &length,
+				(const Bytef*)cdr.rd_ptr(), cdr.length ());
+                          //       reinterpret_cast <const Bytef*>(compression_stream.buffer ()), compression_stream.total_length ());
+			char* buf = (char*)LargBuffer;

+TAO_InputCDR* newstream = new TAO_InputCDR (buf, (size_t)length);
+request.incoming_ = newstream;
+#endif
+
+	// do decompression
+//}
       /*
        * Hook to specialize request processing within TAO
        * This hook will be replaced by specialized request
@@ -1595,6 +1615,9 @@
       // Byte order.
       int byte_order = ptr[TAO_GIOP_MESSAGE_FLAGS_OFFSET] & 0x01;

+      // Compressed.
+      int compressed = (ptr[TAO_GIOP_MESSAGE_FLAGS_OFFSET] & 0x04) >> 2;
+
       // Get the version info
       CORBA::Octet major = ptr[TAO_GIOP_VERSION_MAJOR_OFFSET];
       CORBA::Octet minor = ptr[TAO_GIOP_VERSION_MINOR_OFFSET];
@@ -1635,13 +1658,14 @@
       // Print.
       ACE_DEBUG ((LM_DEBUG,
                   "TAO (%P|%t) - GIOP_Message_Base::dump_msg, "
-                  "%s GIOP v%c.%c msg, %d data bytes, %s endian, "
+                  "%s GIOP v%c.%c msg, %d data bytes, %s endian, %s compressed, "
                   "Type %s[%u]\n",
                   ACE_TEXT_CHAR_TO_TCHAR (label),
                   digits[ptr[TAO_GIOP_VERSION_MAJOR_OFFSET]],
                   digits[ptr[TAO_GIOP_VERSION_MINOR_OFFSET]],
                   len - TAO_GIOP_MESSAGE_HEADER_LEN ,
                   (byte_order == TAO_ENCAP_BYTE_ORDER) ? ACE_TEXT("my") : ACE_TEXT("other"),
+                  (compressed == 1) ? ACE_TEXT("is") : ACE_TEXT("not"),
                   ACE_TEXT_CHAR_TO_TCHAR(message_name),
                   *id));

@@ -2102,6 +2126,11 @@
   // Only supported in GIOP 1.1 or better.
   if (!(major <= 1 && minor == 0))
     ACE_SET_BITS (flags, msg.more_fragments () << 1);
+
+  // Set the compression flag
+  // Only supported in GIOP 1.2 or better.
+  if (!(major <= 1 && minor <= 1))
+     ACE_SET_BITS (flags, msg.compressed () << 2);
 }

 TAO_END_VERSIONED_NAMESPACE_DECL
Index: CDR.inl
===================================================================
--- CDR.inl	(revision 73868)
+++ CDR.inl	(working copy)
@@ -22,6 +22,18 @@
 }

 ACE_INLINE void
+TAO_OutputCDR::compressed (bool set_compressed)
+{
+  this->compressed_ = set_compressed;
+}
+
+ACE_INLINE bool
+TAO_OutputCDR::compressed (void) const
+{
+  return this->compressed_;
+}
+
+ACE_INLINE void
 TAO_OutputCDR::message_attributes (CORBA::ULong request_id,
                                    TAO_Stub * stub,
                                    int message_semantics,
Index: ORB_Core.inl
===================================================================
--- ORB_Core.inl	(revision 73868)
+++ ORB_Core.inl	(working copy)
@@ -46,6 +46,18 @@
 }

 ACE_INLINE void
+TAO_ORB_Core::compression_enabled (CORBA::Boolean val)
+{
+  this->compression_enabled_ = val;
+}
+
+ACE_INLINE CORBA::Boolean
+TAO_ORB_Core::compression_enabled (void)
+{
+  return this->compression_enabled_;
+}
+
+ACE_INLINE void
 TAO_ORB_Core::bidir_giop_policy (CORBA::Boolean val)
 {
   this->bidir_giop_policy_ = val;
Index: TAO_Server_Request.cpp
===================================================================
--- TAO_Server_Request.cpp	(revision 73868)
+++ TAO_Server_Request.cpp	(working copy)
@@ -53,7 +53,10 @@
                                       TAO_OutputCDR &output,
                                       TAO_Transport *transport,
                                       TAO_ORB_Core *orb_core)
-  : mesg_base_ (mesg_base),
+  :
+                                      compressed_ (false),
+                                      original_message_length_ (0),
+                                      mesg_base_ (mesg_base),
     operation_ (0),
     operation_len_ (0),
     release_operation_ (false),
Index: ORB_Core.h
===================================================================
--- ORB_Core.h	(revision 73868)
+++ ORB_Core.h	(working copy)
@@ -863,6 +863,12 @@
   CORBA::Boolean bidir_giop_policy (void);
   void bidir_giop_policy (CORBA::Boolean);

+  /// Get whether compression is enabled or not
+  CORBA::Boolean compression_enabled (void);
+
+  /// Set whether compression is enabled or not
+  void compression_enabled (CORBA::Boolean);
+
   /// Return the table that maps object key/name to de-stringified
   /// object reference.  It is needed for supporting local objects in
   /// the resolve_initial_references() mechanism.
@@ -1266,6 +1272,9 @@

   /// ORB's service configuration
   ACE_Service_Gestalt *config_;
+
+  /// Compression enabled?
+  CORBA::Boolean compression_enabled_;
 };

 // ****************************************************************
Index: CDR.h
===================================================================
--- CDR.h	(revision 73868)
+++ CDR.h	(working copy)
@@ -191,6 +191,12 @@
   /// Specify whether there are more data fragments to come.
   void more_fragments (bool more);

+  /// Do we contain compressed data
+  bool compressed (void) const;
+
+  /// Specify whether we have compressed data or not
+  void compressed (bool set_compressed);
+
   /// Set fragmented message attributes.
   void message_attributes (CORBA::ULong request_id,
                            TAO_Stub * stub,
@@ -232,6 +238,9 @@
   /// Are there more data fragments to come?
   bool more_fragments_;

+  /// Do we contain compressed data
+  bool compressed_;
+
   /// Request ID for the request currently being marshaled.
   CORBA::ULong request_id_;

Index: TAO_Server_Request.h
===================================================================
--- TAO_Server_Request.h	(revision 73868)
+++ TAO_Server_Request.h	(working copy)
@@ -278,6 +278,9 @@

 #endif  /* TAO_HAS_INTERCEPTORS == 1 */

+  CORBA::Boolean compressed_;
+  CORBA::ULong original_message_length_;
+
 private:
   /// Default ctor only used to create a TAO_ServerRequest that is about
   /// to be the target of a clone operation.
@@ -295,10 +298,10 @@
   bool release_operation_;

   CORBA::Object_var forward_location_;
-
+public:
   /// Incoming stream.
   TAO_InputCDR *incoming_;
-
+private:
   /// Outgoing stream.
   TAO_OutputCDR *outgoing_;

Index: GIOP_Message_Generator_Parser_12.h
===================================================================
--- GIOP_Message_Generator_Parser_12.h	(revision 73868)
+++ GIOP_Message_Generator_Parser_12.h	(working copy)
@@ -114,11 +114,17 @@
   /// initiate action.
   /// @note At somepoint this may be needed for future versions of
   /// GIOP and we may have to share this
-  int check_bidirectional_context (TAO_ServerRequest &);
+  int check_bidirectional_context (TAO_ServerRequest &request);

+  int check_compression_context (TAO_ServerRequest &request);
+
   /// Process the BiDirContext info that we have received.
   int process_bidir_context (TAO_Service_Context &,
                              TAO_Transport *transport);
+
+  int process_compression_context (TAO_ServerRequest &request,
+                                   TAO_Service_Context &,
+                                   TAO_Transport *transport);
 };

 TAO_END_VERSIONED_NAMESPACE_DECL
Index: ZIOP/ZIOP.pidl
===================================================================
--- ZIOP/ZIOP.pidl	(revision 0)
+++ ZIOP/ZIOP.pidl	(revision 76020)
@@ -0,0 +1,190 @@
+#include <orb.idl>
+#include "tao/Policy.pidl"
+
+module ZIOP
+{
+    /**
+     * Exception thrown when an error occurs during a compress or decompress
+     * operation.
+     */
+    exception CompressionException
+    {
+        string reason;
+    };
+
+    /**
+     * Exception thrown if a CompressorFactory with the same CompressorId is
+     * already registered with the CompressionManager.
+     */
+    exception FactoryAlreadyRegistered
+    {
+    };
+
+    /**
+     * Exception thrown if a CompressorId is not known.
+     */
+    exception UnknownCompressorId
+    {
+    };
+
+    /**
+     * CompressorId type.
+     */
+    typedef unsigned long CompressorId;
+
+    /**
+     * CompressionLevel type.
+     */
+    typedef unsigned long CompressionLevel;
+
+    /**
+     * The ZIOP IOR Component Tag Id
+     */
+    const unsigned long TAG_IONA_ZIOP_COMPONENT = 1230266182;
+
+    /**
+     * Tag Id for CompressionEnablingPolicy
+     */
+    const CORBA::PolicyType COMPRESSION_ENABLING_POLICY_ID = 1230266247;
+
+    /**
+     * Tag Id for CompressorIdPolicy
+     */
+    const CORBA::PolicyType COMPRESSOR_ID_POLICY_ID = 1230266248;
+
+    local interface CompressorFactory;
+    /**
+     * Compressor - abstraction of a GIOP message level compressor and
+     * decompressor.
+     */
+    local interface Compressor
+    {
+        /**
+         * Operation that compresses data contained in the source Buffer into
+         * the target Buffer. If an error occurs during the compression, it
+         * throws CompressionException
+         */
+        void compress(in CORBA::OctetSeq source, inout CORBA::OctetSeq target) raises(    ZIOP::CompressionException);
+        /**
+         * Operation that decompresses data contained in the source Buffer into
+         * the target Buffer. If an error occurs during the decompression, it
+         * throws CompressionException
+         */
+        void decompress(in CORBA::OctetSeq source, inout CORBA::OctetSeq target) raises(    ZIOP::CompressionException);
+        /**
+         * The CompressorFactory associated with this Compressor.
+         */
+        readonly attribute CompressorFactory compressor_factory;
+        /**
+         * The (implementation and algorithm specific) compression level
+         * associated with this Compressor.
+         */
+        readonly attribute CompressionLevel compression_level;
+    };
+
+    local interface CompressorFactory
+    {
+        /**
+         * The CompressorId associated with this CompressorFactory
+         */
+        readonly attribute CompressorId compressor_id;
+        /**
+         * The total number of compressed bytes read and written by Compressors
+         * that were created by this CompressorFactory
+         * (i.e. the "target" side of Compressor::compress and
+         * the "source" side of Compressor::decompress operations).
+         */
+        readonly attribute unsigned long long compressed_bytes;
+        /**
+         * The total number of uncompressed bytes read and written by
+         * Compressors that were created by this CompressorFactory
+         * (i.e. the "source" side of Compressor::compress and
+         * the "target" side of Compressor::decompress operations).
+         */
+        readonly attribute unsigned long long uncompressed_bytes;
+        /**
+         * The average compression achieved by Compressors that were created by
+         * this CompressorFactory, usually a value between 0 and >=1.
+         * (i.e. compressed_bytes divided by uncompressed_bytes).
+         */
+        readonly attribute double average_compression;
+        /**
+         * Create a Compressor instance with the given compression level.
+         */
+                Compressor get_compressor(in CompressionLevel compression_level);
+        /**
+         * Add a sample of compressed and uncompressed bytes.
+         */
+                void add_sample(in unsigned long long compressed_bytes, in unsigned long long uncompressed_bytes);
+    };
+
+    typedef sequence<ZIOP::CompressorFactory> CompressorFactorySeq;
+
+    /**
+     * Per-ORB interface to register and unregister CompressorFactories.
+     * Initial reference: "IT_CompressionManager"
+     */
+    local interface CompressionManager
+    {
+        /**
+         * Register a new CompressorFactory
+         */
+        void register_factory(    in CompressorFactory compressor_factory)raises(FactoryAlreadyRegistered);
+        /**
+         * Unregister a CompressorFactory with the given CompressorId from the
+         * CompressionManager
+         */
+        void unregister_factory(    in CompressorId compressor_id) raises (    UnknownCompressorId);
+        /**
+         * Retrieve a CompressorFactory with the given CompressorId from the
+         * CompressionManager
+         */
+        CompressorFactory get_factory(    in ZIOP::CompressorId compressor_id)raises(    ZIOP::UnknownCompressorId);
+        /**
+         * Create a Compressor with the given compression_level from the
+         * CompressorFactory with the given CompressorId
+         */
+        ZIOP::Compressor get_compressor(    in ZIOP::CompressorId compressor_id,    in CompressionLevel compression_level)raises(    ZIOP::UnknownCompressorId);
+        /**
+         * List all registered CompressorFactories
+         */
+        CompressorFactorySeq get_factories();
+    };
+
+
+    /**
+     * The ZIOP IOR Component. Has an CompressorId attribute indicating the
+     * compression algorithm supported by the server side.
+     */
+    interface CompressionComponent //: IOR::Component
+    {
+       readonly attribute ZIOP::CompressorId compressor_id;
+    };
+
+    /**
+     * Factory for ZIOP IOR Components
+     */
+        interface CompressionComponentFactory
+        {
+                ZIOP::CompressionComponent get_compression_component(    in ZIOP::CompressorId compressor_id);
+        };
+
+    /**
+     * The ZIOP CompressionEnablingPolicy. Has an boolean attribute indicating
+     * if compression is enabled or not.
+     */
+        local interface CompressionEnablingPolicy : CORBA::Policy
+        {
+                readonly attribute boolean compression_enabled;
+        };
+
+    /**
+     * The ZIOP CompressorIdPolicy. Has an CompressorId attribute indicating
+     * the compression algorithm to be used.
+     */
+        local interface CompressorIdPolicy : CORBA::Policy
+        {
+                readonly attribute ZIOP::CompressorId compressor_id;
+        };
+
+};

Property changes on: ZIOP\ZIOP.pidl
___________________________________________________________________
Name: svn:keywords
   + Author Date Id Revision
Name: svn:eol-style
   + native

Index: GIOP_Message_Generator_Parser_12.cpp
===================================================================
--- GIOP_Message_Generator_Parser_12.cpp	(revision 73868)
+++ GIOP_Message_Generator_Parser_12.cpp	(working copy)
@@ -35,7 +35,6 @@

   const CORBA::Octet response_flags = opdetails.response_flags ();

-
   // Here are the Octet values for different policies
   // '00000000' for SYNC_NONE
   // '00000000' for SYNC_WITH_TRANSPORT
@@ -328,6 +327,10 @@
   if (request.orb_core ()->bidir_giop_policy ())
     this->check_bidirectional_context (request);

+  // Check an process if compression contexts are available
+  if (request.orb_core ()->compression_enabled ())
+    this->check_compression_context (request);
+
   if (input.length () > 0)
     {
       // Reset the read_ptr to an 8-byte boundary.
@@ -554,6 +557,25 @@
 }

 int
+TAO_GIOP_Message_Generator_Parser_12::check_compression_context (
+    TAO_ServerRequest &request)
+{
+  TAO_Service_Context &service_context = request.request_service_context ();
+
+  // Check whether we have the Compression service context info available in
+  // the ServiceContextList
+  if (service_context.is_service_id (1230266182)
+      == 1)
+    {
+      return this->process_compression_context (request, service_context,
+                                                request.transport ());
+    }
+
+  return 0;
+}
+
+
+int
 TAO_GIOP_Message_Generator_Parser_12::process_bidir_context (
     TAO_Service_Context &service_context,
     TAO_Transport *transport)
@@ -574,6 +596,45 @@
   return transport->tear_listen_point_list (cdr);
 }

+int
+TAO_GIOP_Message_Generator_Parser_12::process_compression_context (
+	TAO_ServerRequest &request,
+    TAO_Service_Context &service_context,
+    TAO_Transport *transport)
+{
+  // Get the context info
+  IOP::ServiceContext context;
+  context.context_id = 1230266182;
+
+  if (service_context.get_context (context) != 1)
+      ACE_ERROR_RETURN ((LM_ERROR,
+                         ACE_TEXT ("(%P|%t) Context info not found \n")),
+                        -1);
+
+  TAO_InputCDR cdr (reinterpret_cast<const char*> (
+                      context.context_data.get_buffer ()),
+                    context.context_data.length ());
+
+  CORBA::Boolean byte_order;
+  if ((cdr >> ACE_InputCDR::to_boolean (byte_order)) == 0)
+    return -1;
+
+  cdr.reset_byte_order (static_cast<int> (byte_order));
+
+  CORBA::ULong message_length;
+  if (!(cdr >> message_length))
+    return -1;
+
+  request.compressed_ = true;
+  request.original_message_length_ = message_length;
+
+  // Do decompression, the original data is accessed
+  // as following stream: *request.incoming (), decompress
+  // the stream
+  ACE_DEBUG ((LM_DEBUG, "Message %d\n",message_length));
+  return 0;
+}
+
 size_t
 TAO_GIOP_Message_Generator_Parser_12::fragment_header_length (void) const
 {
Index: Synch_Invocation.cpp
===================================================================
--- Synch_Invocation.cpp	(revision 73868)
+++ Synch_Invocation.cpp	(working copy)
@@ -23,6 +23,10 @@
 #include "ace/OS_NS_string.h"
 #include "ace/Countdown_Time.h"

+#if !defined (__BORLANDC__)
+#include "zlib.h"
+#endif
+
 #if !defined (__ACE_INLINE__)
 # include "tao/Synch_Invocation.inl"
 #endif /* __ACE_INLINE__ */
@@ -87,14 +91,50 @@
                                 TAO_Transport::TAO_TWOWAY_REQUEST,
                                 max_wait_time);

-        this->write_header (tspec,
+        // If the ORB has compression enabled and we do have arguments
+	//	if (false)
+        if (this->orb_core ()->compression_enabled ())// && this->details_.argument_flag ())
+          {
+// @todo We marshal the data here, so we should compress here
+            TAO_OutputCDR compression_stream;
+            this->marshal_data (compression_stream);
+
+
+#if !defined (__BORLANDC__)
+            Bytef* LargBuffer = new Bytef [1000];
+			uLongf length = 100;
+            int retval = compress (LargBuffer,   &length,
+                                 reinterpret_cast <const Bytef*>(compression_stream.buffer ()), compression_stream.total_length ());
+#endif
+            // Compress stream, dependent on bigger or smaller we use
+            // the compressed stream or the non compressed
+            this->details_.compressed (true);
+            cdr.compressed (true);
+
+            /// @todo write length of original data in the service context list
+			this->details_.uncompressed_size_ = compression_stream.total_length();
+            this->write_header (tspec,
+                                cdr
+                                ACE_ENV_ARG_PARAMETER);
+            ACE_TRY_CHECK;
+ACE_Message_Block *newblock = new ACE_Message_Block ((const char*)LargBuffer, (size_t)length);
+newblock->wr_ptr ((size_t)length);
+            cdr.write_octet_array_mb (newblock);
+
+//            const_cast <ACE_Message_Block*>(cdr.begin ())->next (const_cast <ACE_Message_Block*>(compression_stream.begin ()));
+            //const_cast <ACE_Message_Block*>(cdr.begin ())->cont (newblock);
+          }
+        else
+          {
+            this->write_header (tspec,
                             cdr
                             ACE_ENV_ARG_PARAMETER);
-        ACE_TRY_CHECK;
+            ACE_TRY_CHECK;

-        this->marshal_data (cdr
-                            ACE_ENV_ARG_PARAMETER);
-        ACE_TRY_CHECK;
+            this->marshal_data (cdr
+                                ACE_ENV_ARG_PARAMETER);
+            ACE_TRY_CHECK;
+          }

         // Register a reply dispatcher for this invocation. Use the
         // preallocated reply dispatcher.
