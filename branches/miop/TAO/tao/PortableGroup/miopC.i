// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_BOUNDED_SEQUENCE_MIOP_UNIQUEID_252_CI_)
#define __TAO_BOUNDED_SEQUENCE_MIOP_UNIQUEID_252_CI_

  // = Static operations.
  ACE_INLINE CORBA::Octet *
  MIOP::_TAO_Bounded_Sequence_MIOP_UniqueId_252::allocbuf (CORBA::ULong) // Allocate storage for the sequence.
  {
    CORBA::Octet *retval = 0;
    ACE_NEW_RETURN (retval, CORBA::Octet[252U], 0);
    return retval;
  }

  ACE_INLINE void
  MIOP::_TAO_Bounded_Sequence_MIOP_UniqueId_252::freebuf (CORBA::Octet *buffer) // Free the sequence.
  {
    delete [] buffer;
  }

  ACE_INLINE
  MIOP::_TAO_Bounded_Sequence_MIOP_UniqueId_252::_TAO_Bounded_Sequence_MIOP_UniqueId_252 (void)
  // Default constructor.
    : TAO_Bounded_Base_Sequence (252U, 0)
  {
  }

  ACE_INLINE
  MIOP::_TAO_Bounded_Sequence_MIOP_UniqueId_252::_TAO_Bounded_Sequence_MIOP_UniqueId_252 (CORBA::ULong length,
    CORBA::Octet *data,
    CORBA::Boolean release)
  // Constructor using the data and memory management flag.
    : TAO_Bounded_Base_Sequence (252U, length, data, release)
  {
  }

  ACE_INLINE
  MIOP::_TAO_Bounded_Sequence_MIOP_UniqueId_252::_TAO_Bounded_Sequence_MIOP_UniqueId_252 (const _TAO_Bounded_Sequence_MIOP_UniqueId_252 &rhs)
  // Copy constructor.
    : TAO_Bounded_Base_Sequence (rhs)
  {
    if (rhs.buffer_ != 0)
    {
      CORBA::Octet *tmp1 = _TAO_Bounded_Sequence_MIOP_UniqueId_252::allocbuf (252U);

      CORBA::Octet * const tmp2 = ACE_reinterpret_cast (CORBA::Octet * ACE_CAST_CONST, rhs.buffer_);

      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp1[i] = tmp2[i];

      this->buffer_ = tmp1;
    }
    else
    {
      this->buffer_ = 0;
    }
  }

  ACE_INLINE MIOP::_TAO_Bounded_Sequence_MIOP_UniqueId_252 &
  MIOP::_TAO_Bounded_Sequence_MIOP_UniqueId_252::operator= (const _TAO_Bounded_Sequence_MIOP_UniqueId_252 &rhs)
  // Assignment operator.
  {
    if (this == &rhs)
      return *this;

    if (this->release_ && this->buffer_ != 0)
    {
    }
    else
      this->buffer_ = _TAO_Bounded_Sequence_MIOP_UniqueId_252::allocbuf (rhs.maximum_);

    TAO_Bounded_Base_Sequence::operator= (rhs);

    CORBA::Octet* tmp1 = ACE_reinterpret_cast (CORBA::Octet *, this->buffer_);
    CORBA::Octet* const tmp2 = ACE_reinterpret_cast (CORBA::Octet * ACE_CAST_CONST, rhs.buffer_);

    for (CORBA::ULong i = 0; i < this->length_; ++i)
      tmp1[i] = tmp2[i];

    return *this;
  }

  // = Accessors.
  ACE_INLINE CORBA::Octet &
  MIOP::_TAO_Bounded_Sequence_MIOP_UniqueId_252::operator[] (CORBA::ULong i)// operator []
  {
    ACE_ASSERT (i < this->maximum_);
    CORBA::Octet *tmp = ACE_reinterpret_cast (CORBA::Octet*,this->buffer_);
    return tmp[i];
  }
  ACE_INLINE const CORBA::Octet &
  MIOP::_TAO_Bounded_Sequence_MIOP_UniqueId_252::operator[] (CORBA::ULong i) const// operator []
  {
    ACE_ASSERT (i < this->maximum_);
    const CORBA::Octet* tmp = ACE_reinterpret_cast (const CORBA::Octet* ACE_CAST_CONST,this->buffer_);
    return tmp[i];
  }

  ACE_INLINE CORBA::Octet *
  MIOP::_TAO_Bounded_Sequence_MIOP_UniqueId_252::get_buffer (CORBA::Boolean orphan)
  {
    CORBA::Octet *result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = _TAO_Bounded_Sequence_MIOP_UniqueId_252::allocbuf (this->maximum_);
        this->buffer_ = result;
        this->release_ = 1;
      }
      else
      {
        result = ACE_reinterpret_cast (CORBA::Octet*, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(CORBA::Octet*,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }

  ACE_INLINE const CORBA::Octet *
  MIOP::_TAO_Bounded_Sequence_MIOP_UniqueId_252::get_buffer (void) const
  {
    return ACE_reinterpret_cast(const CORBA::Octet * ACE_CAST_CONST, this->buffer_);
  }

  ACE_INLINE void
  MIOP::_TAO_Bounded_Sequence_MIOP_UniqueId_252::replace (CORBA::ULong max,
    CORBA::ULong length,
    CORBA::Octet *data,
    CORBA::Boolean release)
  {
    this->maximum_ = max;
    this->length_ = length;
    if (this->buffer_ && this->release_ == 1)
    {
      CORBA::Octet* tmp = ACE_reinterpret_cast(CORBA::Octet* ACE_CAST_CONST, this->buffer_);
      _TAO_Bounded_Sequence_MIOP_UniqueId_252::freebuf (tmp);
    }
    this->buffer_ = data;
    this->release_ = release;
  }

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_MIOP_UNIQUEID_CI_)
#define _MIOP_UNIQUEID_CI_

// *************************************************************
// Inline operations for class MIOP::UniqueId_var
// *************************************************************

ACE_INLINE
MIOP::UniqueId_var::UniqueId_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
MIOP::UniqueId_var::UniqueId_var (UniqueId *p)
  : ptr_ (p)
{}

ACE_INLINE
MIOP::UniqueId_var::UniqueId_var (const ::MIOP::UniqueId_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::MIOP::UniqueId (*p.ptr_));
  else
    this->ptr_ = 0;
}

// fixed-size base types only
ACE_INLINE
MIOP::UniqueId_var::UniqueId_var (const ::MIOP::UniqueId &p)
{
  ACE_NEW (this->ptr_, ::MIOP::UniqueId (p));
}

ACE_INLINE
MIOP::UniqueId_var::~UniqueId_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE MIOP::UniqueId_var &
MIOP::UniqueId_var::operator= (UniqueId *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::MIOP::UniqueId_var &
MIOP::UniqueId_var::operator= (const ::MIOP::UniqueId_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          UniqueId *deep_copy =
            new UniqueId (*p.ptr_);

          if (deep_copy != 0)
            {
              UniqueId *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }

  return *this;
}

// fixed-size types only
ACE_INLINE ::MIOP::UniqueId_var &
MIOP::UniqueId_var::operator= (const ::MIOP::UniqueId &p)
{
  if (this->ptr_ != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::MIOP::UniqueId (p), *this);
  }
  return *this;
}

ACE_INLINE const ::MIOP::UniqueId *
MIOP::UniqueId_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::MIOP::UniqueId *
MIOP::UniqueId_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
MIOP::UniqueId_var::operator const ::MIOP::UniqueId &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
MIOP::UniqueId_var::operator ::MIOP::UniqueId &() // cast
{
  return *this->ptr_;
}

ACE_INLINE
MIOP::UniqueId_var::operator ::MIOP::UniqueId &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE CORBA::Octet &
MIOP::UniqueId_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const CORBA::Octet &
MIOP::UniqueId_var::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const CORBA::Octet &, this->ptr_->operator[] (index));
}

ACE_INLINE const ::MIOP::UniqueId &
MIOP::UniqueId_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::MIOP::UniqueId &
MIOP::UniqueId_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size
ACE_INLINE ::MIOP::UniqueId *&
MIOP::UniqueId_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::MIOP::UniqueId *
MIOP::UniqueId_var::_retn (void)
{
  ::MIOP::UniqueId *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::MIOP::UniqueId *
MIOP::UniqueId_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class MIOP::UniqueId_out
// *************************************************************

ACE_INLINE
MIOP::UniqueId_out::UniqueId_out (UniqueId *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
MIOP::UniqueId_out::UniqueId_out (UniqueId_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
MIOP::UniqueId_out::UniqueId_out (const ::MIOP::UniqueId_out &p) // copy constructor
  : ptr_ (ACE_const_cast (UniqueId_out&, p).ptr_)
{}

ACE_INLINE ::MIOP::UniqueId_out &
MIOP::UniqueId_out::operator= (const ::MIOP::UniqueId_out &p)
{
  this->ptr_ = ACE_const_cast (UniqueId_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::MIOP::UniqueId_out &
MIOP::UniqueId_out::operator= (UniqueId *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
MIOP::UniqueId_out::operator ::MIOP::UniqueId *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::MIOP::UniqueId *&
MIOP::UniqueId_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::MIOP::UniqueId *
MIOP::UniqueId_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE CORBA::Octet &
MIOP::UniqueId_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */

// *************************************************************
// Inline operations for class MIOP::PacketHeader_1_0_var
// *************************************************************

ACE_INLINE
MIOP::PacketHeader_1_0_var::PacketHeader_1_0_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
MIOP::PacketHeader_1_0_var::PacketHeader_1_0_var (PacketHeader_1_0 *p)
  : ptr_ (p)
{}

ACE_INLINE
MIOP::PacketHeader_1_0_var::PacketHeader_1_0_var (const ::MIOP::PacketHeader_1_0_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::MIOP::PacketHeader_1_0 (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
MIOP::PacketHeader_1_0_var::~PacketHeader_1_0_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE MIOP::PacketHeader_1_0_var &
MIOP::PacketHeader_1_0_var::operator= (PacketHeader_1_0 *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::MIOP::PacketHeader_1_0_var &
MIOP::PacketHeader_1_0_var::operator= (const ::MIOP::PacketHeader_1_0_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          PacketHeader_1_0 *deep_copy =
            new PacketHeader_1_0 (*p.ptr_);

          if (deep_copy != 0)
            {
              PacketHeader_1_0 *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }

  return *this;
}

ACE_INLINE const ::MIOP::PacketHeader_1_0 *
MIOP::PacketHeader_1_0_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::MIOP::PacketHeader_1_0 *
MIOP::PacketHeader_1_0_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
MIOP::PacketHeader_1_0_var::operator const ::MIOP::PacketHeader_1_0 &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
MIOP::PacketHeader_1_0_var::operator ::MIOP::PacketHeader_1_0 &() // cast
{
  return *this->ptr_;
}

ACE_INLINE
MIOP::PacketHeader_1_0_var::operator ::MIOP::PacketHeader_1_0 &() const // cast
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
MIOP::PacketHeader_1_0_var::operator ::MIOP::PacketHeader_1_0 *&() // cast
{
  return this->ptr_;
}

ACE_INLINE const ::MIOP::PacketHeader_1_0 &
MIOP::PacketHeader_1_0_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::MIOP::PacketHeader_1_0 &
MIOP::PacketHeader_1_0_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size
ACE_INLINE ::MIOP::PacketHeader_1_0 *&
MIOP::PacketHeader_1_0_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::MIOP::PacketHeader_1_0 *
MIOP::PacketHeader_1_0_var::_retn (void)
{
  ::MIOP::PacketHeader_1_0 *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::MIOP::PacketHeader_1_0 *
MIOP::PacketHeader_1_0_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class MIOP::PacketHeader_1_0_out
// *************************************************************

ACE_INLINE
MIOP::PacketHeader_1_0_out::PacketHeader_1_0_out (::MIOP::PacketHeader_1_0 *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
MIOP::PacketHeader_1_0_out::PacketHeader_1_0_out (PacketHeader_1_0_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
MIOP::PacketHeader_1_0_out::PacketHeader_1_0_out (const ::MIOP::PacketHeader_1_0_out &p) // copy constructor
  : ptr_ (ACE_const_cast (PacketHeader_1_0_out&, p).ptr_)
{}

ACE_INLINE MIOP::PacketHeader_1_0_out &
MIOP::PacketHeader_1_0_out::operator= (const ::MIOP::PacketHeader_1_0_out &p)
{
  this->ptr_ = ACE_const_cast (PacketHeader_1_0_out&, p).ptr_;
  return *this;
}

ACE_INLINE MIOP::PacketHeader_1_0_out &
MIOP::PacketHeader_1_0_out::operator= (PacketHeader_1_0 *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
MIOP::PacketHeader_1_0_out::operator ::MIOP::PacketHeader_1_0 *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::MIOP::PacketHeader_1_0 *&
MIOP::PacketHeader_1_0_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::MIOP::PacketHeader_1_0 *
MIOP::PacketHeader_1_0_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class MIOP::PacketHeader_1_0::_magic_forany
// *************************************************************

ACE_INLINE
MIOP::PacketHeader_1_0::_magic_forany::_magic_forany (void) // default constructor
  : ptr_ (0),
    nocopy_ (0)
{}

ACE_INLINE
MIOP::PacketHeader_1_0::_magic_forany::_magic_forany (MIOP::PacketHeader_1_0::_magic_slice *p, CORBA::Boolean nocopy)
  : ptr_ (p),
    nocopy_ (nocopy)
{}

ACE_INLINE
MIOP::PacketHeader_1_0::_magic_forany::_magic_forany (const MIOP::PacketHeader_1_0::_magic_forany &p) // copy constructor
{
  this->ptr_ = MIOP::PacketHeader_1_0::_magic_dup (ACE_const_cast (const MIOP::PacketHeader_1_0::_magic_slice *, p.ptr_));
  this->nocopy_ = p.nocopy_;
}

ACE_INLINE
MIOP::PacketHeader_1_0::_magic_forany::~_magic_forany (void) // destructor
{
   // don't do anything
}

ACE_INLINE MIOP::PacketHeader_1_0::_magic_forany &
MIOP::PacketHeader_1_0::_magic_forany::operator= (MIOP::PacketHeader_1_0::_magic_slice *p)
{
  // is what we own the same that is being assigned to us?
  if (this->ptr_ != p)
  {
    // delete our stuff and assume ownership of p
    MIOP::PacketHeader_1_0::_magic_free (this->ptr_);
    this->ptr_ = p;
  }
  return *this;
}

ACE_INLINE MIOP::PacketHeader_1_0::_magic_forany &
MIOP::PacketHeader_1_0::_magic_forany::operator= (const MIOP::PacketHeader_1_0::_magic_forany &p)
{
  if (this != &p)
  {
    // not assigning to ourselves
    MIOP::PacketHeader_1_0::_magic_free (this->ptr_); // free old stuff
    // deep copy
    this->ptr_ = MIOP::PacketHeader_1_0::_magic_dup (ACE_const_cast (const MIOP::PacketHeader_1_0::_magic_slice *, p.ptr_));
    this->nocopy_ = p.nocopy_;
  }
  return *this;
}

ACE_INLINE
MIOP::PacketHeader_1_0::_magic_forany::operator MIOP::PacketHeader_1_0::_magic_slice * const &() const // cast
{
  return this->ptr_;
}

ACE_INLINE
MIOP::PacketHeader_1_0::_magic_forany::operator MIOP::PacketHeader_1_0::_magic_slice *&() // cast
{
  return this->ptr_;
}

ACE_INLINE
const MIOP::PacketHeader_1_0::_magic_slice &
MIOP::PacketHeader_1_0::_magic_forany::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const MIOP::PacketHeader_1_0::_magic_slice &, this->ptr_[index]);
}

ACE_INLINE
MIOP::PacketHeader_1_0::_magic_slice &
MIOP::PacketHeader_1_0::_magic_forany::operator[] (CORBA::ULong index)
{
  return this->ptr_[index];
}

ACE_INLINE const MIOP::PacketHeader_1_0::_magic_slice *
MIOP::PacketHeader_1_0::_magic_forany::in (void) const
{
  return ACE_const_cast (const MIOP::PacketHeader_1_0::_magic_slice *, this->ptr_);
}

ACE_INLINE MIOP::PacketHeader_1_0::_magic_slice *
MIOP::PacketHeader_1_0::_magic_forany::inout (void)
{
  return this->ptr_;
}

ACE_INLINE MIOP::PacketHeader_1_0::_magic_slice * &
MIOP::PacketHeader_1_0::_magic_forany::out (void)
{
  return this->ptr_;
}

ACE_INLINE MIOP::PacketHeader_1_0::_magic_slice *
MIOP::PacketHeader_1_0::_magic_forany::_retn (void)
{
  return this->ptr_;
}

ACE_INLINE MIOP::PacketHeader_1_0::_magic_slice *
MIOP::PacketHeader_1_0::_magic_forany::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE CORBA::Boolean
MIOP::PacketHeader_1_0::_magic_forany::nocopy (void) const
{
  return this->nocopy_;
}

// *************************************************************
// Inline operations for class MIOP::Version_var
// *************************************************************

ACE_INLINE
MIOP::Version_var::Version_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
MIOP::Version_var::Version_var (Version *p)
  : ptr_ (p)
{}

ACE_INLINE
MIOP::Version_var::Version_var (const ::MIOP::Version_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::MIOP::Version (*p.ptr_));
  else
    this->ptr_ = 0;
}

// fixed-size types only
ACE_INLINE
MIOP::Version_var::Version_var (const ::MIOP::Version &p)
{
  ACE_NEW (this->ptr_, ::MIOP::Version (p));
}

ACE_INLINE
MIOP::Version_var::~Version_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE MIOP::Version_var &
MIOP::Version_var::operator= (Version *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::MIOP::Version_var &
MIOP::Version_var::operator= (const ::MIOP::Version_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          Version *deep_copy =
            new Version (*p.ptr_);

          if (deep_copy != 0)
            {
              Version *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }

  return *this;
}

// fixed-size types only
ACE_INLINE MIOP::Version_var &
MIOP::Version_var::operator= (const ::MIOP::Version &p)
{
  if (this->ptr_ != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::MIOP::Version (p), *this);
  }
  return *this;
}

ACE_INLINE const ::MIOP::Version *
MIOP::Version_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::MIOP::Version *
MIOP::Version_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
MIOP::Version_var::operator const ::MIOP::Version &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
MIOP::Version_var::operator ::MIOP::Version &() // cast
{
  return *this->ptr_;
}

ACE_INLINE
MIOP::Version_var::operator ::MIOP::Version &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE const ::MIOP::Version &
MIOP::Version_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::MIOP::Version &
MIOP::Version_var::inout (void)
{
  return *this->ptr_;
}

// mapping for fixed size
ACE_INLINE ::MIOP::Version &
MIOP::Version_var::out (void)
{
  return *this->ptr_;
}

ACE_INLINE ::MIOP::Version
MIOP::Version_var::_retn (void)
{
  return *this->ptr_;
}

ACE_INLINE ::MIOP::Version *
MIOP::Version_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class MIOP::UsingIpv4_var
// *************************************************************

ACE_INLINE
MIOP::UsingIpv4_var::UsingIpv4_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
MIOP::UsingIpv4_var::UsingIpv4_var (UsingIpv4 *p)
  : ptr_ (p)
{}

ACE_INLINE
MIOP::UsingIpv4_var::UsingIpv4_var (const ::MIOP::UsingIpv4_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::MIOP::UsingIpv4 (*p.ptr_));
  else
    this->ptr_ = 0;
}

// fixed-size types only
ACE_INLINE
MIOP::UsingIpv4_var::UsingIpv4_var (const ::MIOP::UsingIpv4 &p)
{
  ACE_NEW (this->ptr_, ::MIOP::UsingIpv4 (p));
}

ACE_INLINE
MIOP::UsingIpv4_var::~UsingIpv4_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE MIOP::UsingIpv4_var &
MIOP::UsingIpv4_var::operator= (UsingIpv4 *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::MIOP::UsingIpv4_var &
MIOP::UsingIpv4_var::operator= (const ::MIOP::UsingIpv4_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          UsingIpv4 *deep_copy =
            new UsingIpv4 (*p.ptr_);

          if (deep_copy != 0)
            {
              UsingIpv4 *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }

  return *this;
}

// fixed-size types only
ACE_INLINE MIOP::UsingIpv4_var &
MIOP::UsingIpv4_var::operator= (const ::MIOP::UsingIpv4 &p)
{
  if (this->ptr_ != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::MIOP::UsingIpv4 (p), *this);
  }
  return *this;
}

ACE_INLINE const ::MIOP::UsingIpv4 *
MIOP::UsingIpv4_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::MIOP::UsingIpv4 *
MIOP::UsingIpv4_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
MIOP::UsingIpv4_var::operator const ::MIOP::UsingIpv4 &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
MIOP::UsingIpv4_var::operator ::MIOP::UsingIpv4 &() // cast
{
  return *this->ptr_;
}

ACE_INLINE
MIOP::UsingIpv4_var::operator ::MIOP::UsingIpv4 &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE const ::MIOP::UsingIpv4 &
MIOP::UsingIpv4_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::MIOP::UsingIpv4 &
MIOP::UsingIpv4_var::inout (void)
{
  return *this->ptr_;
}

// mapping for fixed size
ACE_INLINE ::MIOP::UsingIpv4 &
MIOP::UsingIpv4_var::out (void)
{
  return *this->ptr_;
}

ACE_INLINE ::MIOP::UsingIpv4
MIOP::UsingIpv4_var::_retn (void)
{
  return *this->ptr_;
}

ACE_INLINE ::MIOP::UsingIpv4 *
MIOP::UsingIpv4_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class MIOP::UsingIpv4::_class_d_address_forany
// *************************************************************

ACE_INLINE
MIOP::UsingIpv4::_class_d_address_forany::_class_d_address_forany (void) // default constructor
  : ptr_ (0),
    nocopy_ (0)
{}

ACE_INLINE
MIOP::UsingIpv4::_class_d_address_forany::_class_d_address_forany (MIOP::UsingIpv4::_class_d_address_slice *p, CORBA::Boolean nocopy)
  : ptr_ (p),
    nocopy_ (nocopy)
{}

ACE_INLINE
MIOP::UsingIpv4::_class_d_address_forany::_class_d_address_forany (const MIOP::UsingIpv4::_class_d_address_forany &p) // copy constructor
{
  this->ptr_ = MIOP::UsingIpv4::_class_d_address_dup (ACE_const_cast (const MIOP::UsingIpv4::_class_d_address_slice *, p.ptr_));
  this->nocopy_ = p.nocopy_;
}

ACE_INLINE
MIOP::UsingIpv4::_class_d_address_forany::~_class_d_address_forany (void) // destructor
{
   // don't do anything
}

ACE_INLINE MIOP::UsingIpv4::_class_d_address_forany &
MIOP::UsingIpv4::_class_d_address_forany::operator= (MIOP::UsingIpv4::_class_d_address_slice *p)
{
  // is what we own the same that is being assigned to us?
  if (this->ptr_ != p)
  {
    // delete our stuff and assume ownership of p
    MIOP::UsingIpv4::_class_d_address_free (this->ptr_);
    this->ptr_ = p;
  }
  return *this;
}

ACE_INLINE MIOP::UsingIpv4::_class_d_address_forany &
MIOP::UsingIpv4::_class_d_address_forany::operator= (const MIOP::UsingIpv4::_class_d_address_forany &p)
{
  if (this != &p)
  {
    // not assigning to ourselves
    MIOP::UsingIpv4::_class_d_address_free (this->ptr_); // free old stuff
    // deep copy
    this->ptr_ = MIOP::UsingIpv4::_class_d_address_dup (ACE_const_cast (const MIOP::UsingIpv4::_class_d_address_slice *, p.ptr_));
    this->nocopy_ = p.nocopy_;
  }
  return *this;
}

ACE_INLINE
MIOP::UsingIpv4::_class_d_address_forany::operator MIOP::UsingIpv4::_class_d_address_slice * const &() const // cast
{
  return this->ptr_;
}

ACE_INLINE
MIOP::UsingIpv4::_class_d_address_forany::operator MIOP::UsingIpv4::_class_d_address_slice *&() // cast
{
  return this->ptr_;
}

ACE_INLINE
const MIOP::UsingIpv4::_class_d_address_slice &
MIOP::UsingIpv4::_class_d_address_forany::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const MIOP::UsingIpv4::_class_d_address_slice &, this->ptr_[index]);
}

ACE_INLINE
MIOP::UsingIpv4::_class_d_address_slice &
MIOP::UsingIpv4::_class_d_address_forany::operator[] (CORBA::ULong index)
{
  return this->ptr_[index];
}

ACE_INLINE const MIOP::UsingIpv4::_class_d_address_slice *
MIOP::UsingIpv4::_class_d_address_forany::in (void) const
{
  return ACE_const_cast (const MIOP::UsingIpv4::_class_d_address_slice *, this->ptr_);
}

ACE_INLINE MIOP::UsingIpv4::_class_d_address_slice *
MIOP::UsingIpv4::_class_d_address_forany::inout (void)
{
  return this->ptr_;
}

ACE_INLINE MIOP::UsingIpv4::_class_d_address_slice * &
MIOP::UsingIpv4::_class_d_address_forany::out (void)
{
  return this->ptr_;
}

ACE_INLINE MIOP::UsingIpv4::_class_d_address_slice *
MIOP::UsingIpv4::_class_d_address_forany::_retn (void)
{
  return this->ptr_;
}

ACE_INLINE MIOP::UsingIpv4::_class_d_address_slice *
MIOP::UsingIpv4::_class_d_address_forany::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE CORBA::Boolean
MIOP::UsingIpv4::_class_d_address_forany::nocopy (void) const
{
  return this->nocopy_;
}

// *************************************************************
// Inline operations for class MIOP::UsingIpv6_var
// *************************************************************

ACE_INLINE
MIOP::UsingIpv6_var::UsingIpv6_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
MIOP::UsingIpv6_var::UsingIpv6_var (UsingIpv6 *p)
  : ptr_ (p)
{}

ACE_INLINE
MIOP::UsingIpv6_var::UsingIpv6_var (const ::MIOP::UsingIpv6_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::MIOP::UsingIpv6 (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
MIOP::UsingIpv6_var::~UsingIpv6_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE MIOP::UsingIpv6_var &
MIOP::UsingIpv6_var::operator= (UsingIpv6 *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::MIOP::UsingIpv6_var &
MIOP::UsingIpv6_var::operator= (const ::MIOP::UsingIpv6_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          UsingIpv6 *deep_copy =
            new UsingIpv6 (*p.ptr_);

          if (deep_copy != 0)
            {
              UsingIpv6 *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }

  return *this;
}

ACE_INLINE const ::MIOP::UsingIpv6 *
MIOP::UsingIpv6_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::MIOP::UsingIpv6 *
MIOP::UsingIpv6_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
MIOP::UsingIpv6_var::operator const ::MIOP::UsingIpv6 &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
MIOP::UsingIpv6_var::operator ::MIOP::UsingIpv6 &() // cast
{
  return *this->ptr_;
}

ACE_INLINE
MIOP::UsingIpv6_var::operator ::MIOP::UsingIpv6 &() const // cast
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
MIOP::UsingIpv6_var::operator ::MIOP::UsingIpv6 *&() // cast
{
  return this->ptr_;
}

ACE_INLINE const ::MIOP::UsingIpv6 &
MIOP::UsingIpv6_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::MIOP::UsingIpv6 &
MIOP::UsingIpv6_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size
ACE_INLINE ::MIOP::UsingIpv6 *&
MIOP::UsingIpv6_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::MIOP::UsingIpv6 *
MIOP::UsingIpv6_var::_retn (void)
{
  ::MIOP::UsingIpv6 *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::MIOP::UsingIpv6 *
MIOP::UsingIpv6_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class MIOP::UsingIpv6_out
// *************************************************************

ACE_INLINE
MIOP::UsingIpv6_out::UsingIpv6_out (::MIOP::UsingIpv6 *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
MIOP::UsingIpv6_out::UsingIpv6_out (UsingIpv6_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
MIOP::UsingIpv6_out::UsingIpv6_out (const ::MIOP::UsingIpv6_out &p) // copy constructor
  : ptr_ (ACE_const_cast (UsingIpv6_out&, p).ptr_)
{}

ACE_INLINE MIOP::UsingIpv6_out &
MIOP::UsingIpv6_out::operator= (const ::MIOP::UsingIpv6_out &p)
{
  this->ptr_ = ACE_const_cast (UsingIpv6_out&, p).ptr_;
  return *this;
}

ACE_INLINE MIOP::UsingIpv6_out &
MIOP::UsingIpv6_out::operator= (UsingIpv6 *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
MIOP::UsingIpv6_out::operator ::MIOP::UsingIpv6 *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::MIOP::UsingIpv6 *&
MIOP::UsingIpv6_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::MIOP::UsingIpv6 *
MIOP::UsingIpv6_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for union MIOP::IPEndpoints
// *************************************************************

// this reset method is used by the decoding engine
ACE_INLINE void
MIOP::IPEndpoints::_reset (void)
{
  this->_reset (this->disc_, 1);
  ACE_OS::memcpy (&this->u_, 0, sizeof (this->u_));
}

// the implicit _default () method
ACE_INLINE void
MIOP::IPEndpoints::_default ()
{
  this->disc_ = -32768;
}

// accessor to set the discriminant
ACE_INLINE void
MIOP::IPEndpoints::_d (CORBA::Short discval)
{
  this->disc_ = discval;
}
// accessor to get the discriminant
ACE_INLINE CORBA::Short
MIOP::IPEndpoints::_d (void) const
{
  return this->disc_;
}

// accessor to set the member
ACE_INLINE void
MIOP::IPEndpoints::ipv4_endpoints (const MIOP::UsingIpv4 &val)
{
  // set the discriminant val
  this->_reset (0, 0);
  this->disc_ = 0;
  this->u_.ipv4_endpoints_ = val;
}

// readonly get method
ACE_INLINE const MIOP::UsingIpv4 &
MIOP::IPEndpoints::ipv4_endpoints (void) const
{
  return this->u_.ipv4_endpoints_;
}

// read/write get method
ACE_INLINE MIOP::UsingIpv4 &
MIOP::IPEndpoints::ipv4_endpoints (void)
{
  return this->u_.ipv4_endpoints_;
}

// accessor to set the member
ACE_INLINE void
MIOP::IPEndpoints::ipv6_endpoints (const MIOP::UsingIpv6 &val)
{
  // set the discriminant val
  this->_reset (1, 0);
  this->disc_ = 1;
  ACE_NEW (
      this->u_.ipv6_endpoints_,
      MIOP::UsingIpv6 (val)
    );
}

// readonly get method
ACE_INLINE const MIOP::UsingIpv6 &
MIOP::IPEndpoints::ipv6_endpoints (void) const
{
  return *this->u_.ipv6_endpoints_;
}

// read/write get method
ACE_INLINE MIOP::UsingIpv6 &
MIOP::IPEndpoints::ipv6_endpoints (void)
{
  return *this->u_.ipv6_endpoints_;
}


#if !defined (_MIOP_IPENDPOINTS___VAR_CI_)
#define _MIOP_IPENDPOINTS___VAR_CI_

// *************************************************************
// Inline operations for class MIOP::IPEndpoints_var
// *************************************************************

ACE_INLINE
MIOP::IPEndpoints_var::IPEndpoints_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
MIOP::IPEndpoints_var::IPEndpoints_var (IPEndpoints *p)
  : ptr_ (p)
{}

ACE_INLINE
MIOP::IPEndpoints_var::IPEndpoints_var (const ::MIOP::IPEndpoints_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::MIOP::IPEndpoints (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
MIOP::IPEndpoints_var::~IPEndpoints_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE ::MIOP::IPEndpoints_var &
MIOP::IPEndpoints_var::operator= (IPEndpoints *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::MIOP::IPEndpoints_var &
MIOP::IPEndpoints_var::operator= (const ::MIOP::IPEndpoints_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          IPEndpoints *deep_copy =
            new IPEndpoints (*p.ptr_);

          if (deep_copy != 0)
            {
              IPEndpoints *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }

  return *this;
}

ACE_INLINE const ::MIOP::IPEndpoints *
MIOP::IPEndpoints_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::MIOP::IPEndpoints *
MIOP::IPEndpoints_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
MIOP::IPEndpoints_var::operator const ::MIOP::IPEndpoints &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
MIOP::IPEndpoints_var::operator ::MIOP::IPEndpoints &() // cast
{
  return *this->ptr_;
}

ACE_INLINE
MIOP::IPEndpoints_var::operator ::MIOP::IPEndpoints &() const// cast
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
MIOP::IPEndpoints_var::operator ::MIOP::IPEndpoints *&() // cast
{
  return this->ptr_;
}

ACE_INLINE const ::MIOP::IPEndpoints &
MIOP::IPEndpoints_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::MIOP::IPEndpoints &
MIOP::IPEndpoints_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size
ACE_INLINE ::MIOP::IPEndpoints *&
MIOP::IPEndpoints_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::MIOP::IPEndpoints *
MIOP::IPEndpoints_var::_retn (void)
{
  ::MIOP::IPEndpoints *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::MIOP::IPEndpoints *
MIOP::IPEndpoints_var::ptr (void) const
{
  return this->ptr_;
}


#endif /* end #if !defined */


#if !defined (_MIOP_IPENDPOINTS___OUT_CI_)
#define _MIOP_IPENDPOINTS___OUT_CI_

// *************************************************************
// Inline operations for class MIOP::IPEndpoints_out
// *************************************************************

ACE_INLINE
MIOP::IPEndpoints_out::IPEndpoints_out (IPEndpoints *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
MIOP::IPEndpoints_out::IPEndpoints_out (IPEndpoints_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
MIOP::IPEndpoints_out::IPEndpoints_out (const ::MIOP::IPEndpoints_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IPEndpoints_out&, p).ptr_)
{}

ACE_INLINE ::MIOP::IPEndpoints_out &
MIOP::IPEndpoints_out::operator= (const ::MIOP::IPEndpoints_out &p)
{
  this->ptr_ = ACE_const_cast (IPEndpoints_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::MIOP::IPEndpoints_out &
MIOP::IPEndpoints_out::operator= (IPEndpoints *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
MIOP::IPEndpoints_out::operator ::MIOP::IPEndpoints *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::MIOP::IPEndpoints *&
MIOP::IPEndpoints_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::MIOP::IPEndpoints *
MIOP::IPEndpoints_out::operator-> (void)
{
  return this->ptr_;
}


#endif /* end #if !defined */

// *************************************************************
// Inline operations for class MIOP::UIPMC_ProfileBody_var
// *************************************************************

ACE_INLINE
MIOP::UIPMC_ProfileBody_var::UIPMC_ProfileBody_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
MIOP::UIPMC_ProfileBody_var::UIPMC_ProfileBody_var (UIPMC_ProfileBody *p)
  : ptr_ (p)
{}

ACE_INLINE
MIOP::UIPMC_ProfileBody_var::UIPMC_ProfileBody_var (const ::MIOP::UIPMC_ProfileBody_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::MIOP::UIPMC_ProfileBody (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
MIOP::UIPMC_ProfileBody_var::~UIPMC_ProfileBody_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE MIOP::UIPMC_ProfileBody_var &
MIOP::UIPMC_ProfileBody_var::operator= (UIPMC_ProfileBody *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::MIOP::UIPMC_ProfileBody_var &
MIOP::UIPMC_ProfileBody_var::operator= (const ::MIOP::UIPMC_ProfileBody_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          UIPMC_ProfileBody *deep_copy =
            new UIPMC_ProfileBody (*p.ptr_);

          if (deep_copy != 0)
            {
              UIPMC_ProfileBody *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }

  return *this;
}

ACE_INLINE const ::MIOP::UIPMC_ProfileBody *
MIOP::UIPMC_ProfileBody_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::MIOP::UIPMC_ProfileBody *
MIOP::UIPMC_ProfileBody_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
MIOP::UIPMC_ProfileBody_var::operator const ::MIOP::UIPMC_ProfileBody &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
MIOP::UIPMC_ProfileBody_var::operator ::MIOP::UIPMC_ProfileBody &() // cast
{
  return *this->ptr_;
}

ACE_INLINE
MIOP::UIPMC_ProfileBody_var::operator ::MIOP::UIPMC_ProfileBody &() const // cast
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
MIOP::UIPMC_ProfileBody_var::operator ::MIOP::UIPMC_ProfileBody *&() // cast
{
  return this->ptr_;
}

ACE_INLINE const ::MIOP::UIPMC_ProfileBody &
MIOP::UIPMC_ProfileBody_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::MIOP::UIPMC_ProfileBody &
MIOP::UIPMC_ProfileBody_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size
ACE_INLINE ::MIOP::UIPMC_ProfileBody *&
MIOP::UIPMC_ProfileBody_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::MIOP::UIPMC_ProfileBody *
MIOP::UIPMC_ProfileBody_var::_retn (void)
{
  ::MIOP::UIPMC_ProfileBody *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::MIOP::UIPMC_ProfileBody *
MIOP::UIPMC_ProfileBody_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class MIOP::UIPMC_ProfileBody_out
// *************************************************************

ACE_INLINE
MIOP::UIPMC_ProfileBody_out::UIPMC_ProfileBody_out (::MIOP::UIPMC_ProfileBody *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
MIOP::UIPMC_ProfileBody_out::UIPMC_ProfileBody_out (UIPMC_ProfileBody_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
MIOP::UIPMC_ProfileBody_out::UIPMC_ProfileBody_out (const ::MIOP::UIPMC_ProfileBody_out &p) // copy constructor
  : ptr_ (ACE_const_cast (UIPMC_ProfileBody_out&, p).ptr_)
{}

ACE_INLINE MIOP::UIPMC_ProfileBody_out &
MIOP::UIPMC_ProfileBody_out::operator= (const ::MIOP::UIPMC_ProfileBody_out &p)
{
  this->ptr_ = ACE_const_cast (UIPMC_ProfileBody_out&, p).ptr_;
  return *this;
}

ACE_INLINE MIOP::UIPMC_ProfileBody_out &
MIOP::UIPMC_ProfileBody_out::operator= (UIPMC_ProfileBody *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
MIOP::UIPMC_ProfileBody_out::operator ::MIOP::UIPMC_ProfileBody *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::MIOP::UIPMC_ProfileBody *&
MIOP::UIPMC_ProfileBody_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::MIOP::UIPMC_ProfileBody *
MIOP::UIPMC_ProfileBody_out::operator-> (void)
{
  return this->ptr_;
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_MIOP_UIPMC_PROFILEBODY__TAO_SEQ_TAGGEDCOMPONENT_CI_)
#define __TAO_UNBOUNDED_SEQUENCE_MIOP_UIPMC_PROFILEBODY__TAO_SEQ_TAGGEDCOMPONENT_CI_

  // = Static operations.
  ACE_INLINE IOP::TaggedComponent *
  MIOP::UIPMC_ProfileBody::_TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent::allocbuf (CORBA::ULong size)
  // Allocate storage for the sequence.
  {
    IOP::TaggedComponent *retval = 0;
    ACE_NEW_RETURN (retval, IOP::TaggedComponent[size], 0);
    return retval;
  }

  ACE_INLINE void MIOP::UIPMC_ProfileBody::_TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent::freebuf (IOP::TaggedComponent *buffer)
  // Free the sequence.
  {
    delete [] buffer;
  }

  ACE_INLINE
  MIOP::UIPMC_ProfileBody::_TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent::_TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent (void) // Default constructor.
  {
  }

  ACE_INLINE
  MIOP::UIPMC_ProfileBody::_TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent::_TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent (CORBA::ULong maximum) // Constructor using a maximum length value.
    : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent::allocbuf (maximum))
  {
  }

  ACE_INLINE
  MIOP::UIPMC_ProfileBody::_TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent::_TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent (CORBA::ULong maximum,
    CORBA::ULong length,
    IOP::TaggedComponent *data,
    CORBA::Boolean release)
  : TAO_Unbounded_Base_Sequence (maximum, length, data, release)
  {
  }

  ACE_INLINE
  MIOP::UIPMC_ProfileBody::_TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent::_TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent (const _TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent &rhs)
  // Copy constructor.
    : TAO_Unbounded_Base_Sequence (rhs)
  {
    if (rhs.buffer_ != 0)
    {
      IOP::TaggedComponent *tmp1 = _TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent::allocbuf (this->maximum_);
      IOP::TaggedComponent * const tmp2 = ACE_reinterpret_cast (IOP::TaggedComponent * ACE_CAST_CONST, rhs.buffer_);

      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp1[i] = tmp2[i];

      this->buffer_ = tmp1;
    }
    else
    {
      this->buffer_ = 0;
    }
  }

  ACE_INLINE MIOP::UIPMC_ProfileBody::_TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent &
  MIOP::UIPMC_ProfileBody::_TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent::operator= (const _TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent &rhs)
  // Assignment operator.
  {
    if (this == &rhs)
      return *this;

    if (this->release_)
    {
      if (this->maximum_ < rhs.maximum_)
      {
        // free the old buffer
        IOP::TaggedComponent *tmp = ACE_reinterpret_cast (IOP::TaggedComponent *, this->buffer_);
        _TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent::freebuf (tmp);
        this->buffer_ = _TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent::allocbuf (rhs.maximum_);
      }
    }
    else
      this->buffer_ = _TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent::allocbuf (rhs.maximum_);

    TAO_Unbounded_Base_Sequence::operator= (rhs);

    IOP::TaggedComponent *tmp1 = ACE_reinterpret_cast (IOP::TaggedComponent *, this->buffer_);
    IOP::TaggedComponent * const tmp2 = ACE_reinterpret_cast (IOP::TaggedComponent * ACE_CAST_CONST, rhs.buffer_);

    for (CORBA::ULong i = 0; i < this->length_; ++i)
      tmp1[i] = tmp2[i];

    return *this;
  }

  // = Accessors.
  ACE_INLINE IOP::TaggedComponent &
  MIOP::UIPMC_ProfileBody::_TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent::operator[] (CORBA::ULong i)
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    IOP::TaggedComponent* tmp = ACE_reinterpret_cast(IOP::TaggedComponent*,this->buffer_);
    return tmp[i];
  }

  ACE_INLINE const IOP::TaggedComponent &
  MIOP::UIPMC_ProfileBody::_TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent::operator[] (CORBA::ULong i) const
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    IOP::TaggedComponent * const tmp = ACE_reinterpret_cast (IOP::TaggedComponent* ACE_CAST_CONST, this->buffer_);
    return tmp[i];
  }

  // Implement the TAO_Base_Sequence methods (see Sequence.h)

  ACE_INLINE IOP::TaggedComponent *
  MIOP::UIPMC_ProfileBody::_TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent::get_buffer (CORBA::Boolean orphan)
  {
    IOP::TaggedComponent *result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = _TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent::allocbuf (this->length_);
        this->buffer_ = result;
        this->release_ = 1;
      }
      else
      {
        result = ACE_reinterpret_cast (IOP::TaggedComponent*, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(IOP::TaggedComponent*,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }

  ACE_INLINE const IOP::TaggedComponent *
  MIOP::UIPMC_ProfileBody::_TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent::get_buffer (void) const
  {
    return ACE_reinterpret_cast(const IOP::TaggedComponent * ACE_CAST_CONST, this->buffer_);
  }

  ACE_INLINE void
  MIOP::UIPMC_ProfileBody::_TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent::replace (CORBA::ULong max,
  CORBA::ULong length,
  IOP::TaggedComponent *data,
  CORBA::Boolean release)
  {
    this->maximum_ = max;
    this->length_ = length;
    if (this->buffer_ && this->release_ == 1)
    {
      IOP::TaggedComponent *tmp = ACE_reinterpret_cast(IOP::TaggedComponent*,this->buffer_);
      _TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent::freebuf (tmp);
    }
    this->buffer_ = data;
    this->release_ = release;
  }

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
// *************************************************************
// Inline operations for class MIOP::MulticastObjectGroupFactory::ipaddr_var
// *************************************************************

ACE_INLINE
MIOP::MulticastObjectGroupFactory::ipaddr_var::ipaddr_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
MIOP::MulticastObjectGroupFactory::ipaddr_var::ipaddr_var (MIOP::MulticastObjectGroupFactory::ipaddr_slice *p)
  : ptr_ (p)
{}

ACE_INLINE
MIOP::MulticastObjectGroupFactory::ipaddr_var::ipaddr_var (const MIOP::MulticastObjectGroupFactory::ipaddr_var &p) // copy constructor
{
  this->ptr_ = MIOP::MulticastObjectGroupFactory::ipaddr_dup (ACE_const_cast (const MIOP::MulticastObjectGroupFactory::ipaddr_slice *, p.ptr_));
}

ACE_INLINE
MIOP::MulticastObjectGroupFactory::ipaddr_var::~ipaddr_var (void) // destructor
{
  MIOP::MulticastObjectGroupFactory::ipaddr_free (this->ptr_);
}

ACE_INLINE MIOP::MulticastObjectGroupFactory::ipaddr_var &
MIOP::MulticastObjectGroupFactory::ipaddr_var::operator= (MIOP::MulticastObjectGroupFactory::ipaddr_slice *p)
{
  // is what we own the same that is being assigned to us?
  if (this->ptr_ != p)
  {
    // delete our stuff and assume ownership of p
    MIOP::MulticastObjectGroupFactory::ipaddr_free (this->ptr_);
    this->ptr_ = p;
  }
  return *this;
}

ACE_INLINE MIOP::MulticastObjectGroupFactory::ipaddr_var &
MIOP::MulticastObjectGroupFactory::ipaddr_var::operator= (const MIOP::MulticastObjectGroupFactory::ipaddr_var &p)
{
  if (this != &p)
  {
    // not assigning to ourselves
    MIOP::MulticastObjectGroupFactory::ipaddr_free (this->ptr_); // free old stuff
    // deep copy
    this->ptr_ = MIOP::MulticastObjectGroupFactory::ipaddr_dup (ACE_const_cast (const MIOP::MulticastObjectGroupFactory::ipaddr_slice *, p.ptr_));
  }
  return *this;
}

ACE_INLINE
MIOP::MulticastObjectGroupFactory::ipaddr_var::operator MIOP::MulticastObjectGroupFactory::ipaddr_slice * const &() const // cast
{
  return this->ptr_;
}

ACE_INLINE
const MIOP::MulticastObjectGroupFactory::ipaddr_slice &
MIOP::MulticastObjectGroupFactory::ipaddr_var::operator[] (CORBA::ULong index) const
{
#if defined (ACE_HAS_BROKEN_IMPLICIT_CONST_CAST)
  return ACE_const_cast (const MIOP::MulticastObjectGroupFactory::ipaddr_slice &, this->ptr_[index]);
#else
  const MIOP::MulticastObjectGroupFactory::ipaddr_slice &tmp = this->ptr_[index];
  return tmp;
#endif /* ACE_HAS_BROKEN_IMPLICIT_CONST_CAST */
}

ACE_INLINE
MIOP::MulticastObjectGroupFactory::ipaddr_slice &
MIOP::MulticastObjectGroupFactory::ipaddr_var::operator[] (CORBA::ULong index)
{
  return this->ptr_[index];
}

ACE_INLINE void
MIOP::MulticastObjectGroupFactory::ipaddr_var::copy (MIOP::MulticastObjectGroupFactory::ipaddr_slice *_tao_to, const MIOP::MulticastObjectGroupFactory::ipaddr_slice *_tao_from)
{
  MIOP::MulticastObjectGroupFactory::ipaddr_copy (_tao_to, _tao_from);
}

ACE_INLINE const MIOP::MulticastObjectGroupFactory::ipaddr_slice *
MIOP::MulticastObjectGroupFactory::ipaddr_var::in (void) const
{
  return ACE_const_cast (const MIOP::MulticastObjectGroupFactory::ipaddr_slice *, this->ptr_);
}

ACE_INLINE MIOP::MulticastObjectGroupFactory::ipaddr_slice *
MIOP::MulticastObjectGroupFactory::ipaddr_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE MIOP::MulticastObjectGroupFactory::ipaddr_slice * &
MIOP::MulticastObjectGroupFactory::ipaddr_var::out (void)
{
  MIOP::MulticastObjectGroupFactory::ipaddr_free (this->ptr_);
  this->ptr_ = (MIOP::MulticastObjectGroupFactory::ipaddr_slice *)0;
  return this->ptr_;
}

ACE_INLINE MIOP::MulticastObjectGroupFactory::ipaddr_slice *
MIOP::MulticastObjectGroupFactory::ipaddr_var::_retn (void)
{
  MIOP::MulticastObjectGroupFactory::ipaddr_slice *tmp = this->ptr_;
  this->ptr_ = (MIOP::MulticastObjectGroupFactory::ipaddr_slice *)0;
  return tmp;
}

ACE_INLINE MIOP::MulticastObjectGroupFactory::ipaddr_slice *
MIOP::MulticastObjectGroupFactory::ipaddr_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class MIOP::MulticastObjectGroupFactory::ipaddr_forany
// *************************************************************

ACE_INLINE
MIOP::MulticastObjectGroupFactory::ipaddr_forany::ipaddr_forany (void) // default constructor
  : ptr_ (0),
    nocopy_ (0)
{}

ACE_INLINE
MIOP::MulticastObjectGroupFactory::ipaddr_forany::ipaddr_forany (MIOP::MulticastObjectGroupFactory::ipaddr_slice *p, CORBA::Boolean nocopy)
  : ptr_ (p),
    nocopy_ (nocopy)
{}

ACE_INLINE
MIOP::MulticastObjectGroupFactory::ipaddr_forany::ipaddr_forany (const MIOP::MulticastObjectGroupFactory::ipaddr_forany &p) // copy constructor
{
  this->ptr_ = MIOP::MulticastObjectGroupFactory::ipaddr_dup (ACE_const_cast (const MIOP::MulticastObjectGroupFactory::ipaddr_slice *, p.ptr_));
  this->nocopy_ = p.nocopy_;
}

ACE_INLINE
MIOP::MulticastObjectGroupFactory::ipaddr_forany::~ipaddr_forany (void) // destructor
{
   // don't do anything
}

ACE_INLINE MIOP::MulticastObjectGroupFactory::ipaddr_forany &
MIOP::MulticastObjectGroupFactory::ipaddr_forany::operator= (MIOP::MulticastObjectGroupFactory::ipaddr_slice *p)
{
  // is what we own the same that is being assigned to us?
  if (this->ptr_ != p)
  {
    // delete our stuff and assume ownership of p
    MIOP::MulticastObjectGroupFactory::ipaddr_free (this->ptr_);
    this->ptr_ = p;
  }
  return *this;
}

ACE_INLINE MIOP::MulticastObjectGroupFactory::ipaddr_forany &
MIOP::MulticastObjectGroupFactory::ipaddr_forany::operator= (const MIOP::MulticastObjectGroupFactory::ipaddr_forany &p)
{
  if (this != &p)
  {
    // not assigning to ourselves
    MIOP::MulticastObjectGroupFactory::ipaddr_free (this->ptr_); // free old stuff
    // deep copy
    this->ptr_ = MIOP::MulticastObjectGroupFactory::ipaddr_dup (ACE_const_cast (const MIOP::MulticastObjectGroupFactory::ipaddr_slice *, p.ptr_));
    this->nocopy_ = p.nocopy_;
  }
  return *this;
}

ACE_INLINE
MIOP::MulticastObjectGroupFactory::ipaddr_forany::operator MIOP::MulticastObjectGroupFactory::ipaddr_slice * const &() const // cast
{
  return this->ptr_;
}

ACE_INLINE
MIOP::MulticastObjectGroupFactory::ipaddr_forany::operator MIOP::MulticastObjectGroupFactory::ipaddr_slice *&() // cast
{
  return this->ptr_;
}

ACE_INLINE
const MIOP::MulticastObjectGroupFactory::ipaddr_slice &
MIOP::MulticastObjectGroupFactory::ipaddr_forany::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const MIOP::MulticastObjectGroupFactory::ipaddr_slice &, this->ptr_[index]);
}

ACE_INLINE
MIOP::MulticastObjectGroupFactory::ipaddr_slice &
MIOP::MulticastObjectGroupFactory::ipaddr_forany::operator[] (CORBA::ULong index)
{
  return this->ptr_[index];
}

ACE_INLINE const MIOP::MulticastObjectGroupFactory::ipaddr_slice *
MIOP::MulticastObjectGroupFactory::ipaddr_forany::in (void) const
{
  return ACE_const_cast (const MIOP::MulticastObjectGroupFactory::ipaddr_slice *, this->ptr_);
}

ACE_INLINE MIOP::MulticastObjectGroupFactory::ipaddr_slice *
MIOP::MulticastObjectGroupFactory::ipaddr_forany::inout (void)
{
  return this->ptr_;
}

ACE_INLINE MIOP::MulticastObjectGroupFactory::ipaddr_slice * &
MIOP::MulticastObjectGroupFactory::ipaddr_forany::out (void)
{
  return this->ptr_;
}

ACE_INLINE MIOP::MulticastObjectGroupFactory::ipaddr_slice *
MIOP::MulticastObjectGroupFactory::ipaddr_forany::_retn (void)
{
  return this->ptr_;
}

ACE_INLINE MIOP::MulticastObjectGroupFactory::ipaddr_slice *
MIOP::MulticastObjectGroupFactory::ipaddr_forany::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE CORBA::Boolean
MIOP::MulticastObjectGroupFactory::ipaddr_forany::nocopy (void) const
{
  return this->nocopy_;
}


#if !defined (_MIOP_MULTICASTOBJECTGROUPFACTORY___CI_)
#define _MIOP_MULTICASTOBJECTGROUPFACTORY___CI_


#endif /* end #if !defined */


#if !defined _TAO_CDR_OP_MIOP_UniqueId_I_
#define _TAO_CDR_OP_MIOP_UniqueId_I_

CORBA::Boolean TAO_PortableGroup_Export operator<< (
    TAO_OutputCDR &,
    const MIOP::UniqueId &
  );
CORBA::Boolean TAO_PortableGroup_Export operator>> (
    TAO_InputCDR &,
    MIOP::UniqueId &
  );

#endif /* _TAO_CDR_OP_MIOP_UniqueId_I_ */

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const MIOP::PacketHeader_1_0::_magic_forany &_tao_array)
{
   return strm.write_char_array ((const ACE_CDR::Char *)_tao_array.in (), 4);
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, MIOP::PacketHeader_1_0::_magic_forany &_tao_array)
{
   return strm.read_char_array ((ACE_CDR::Char *) _tao_array.out (), 4);
}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const MIOP::PacketHeader_1_0 &_tao_aggregate)
{
  MIOP::PacketHeader_1_0::_magic_forany _tao_aggregate_magic
      (ACE_const_cast (
          MIOP::PacketHeader_1_0::_magic_slice*,
          _tao_aggregate.magic
        )
    );
  if (
    (strm << _tao_aggregate_magic) &&
    (strm << CORBA::Any::from_octet (_tao_aggregate.hdr_version)) &&
    (strm << CORBA::Any::from_octet (_tao_aggregate.flags)) &&
    (strm << _tao_aggregate.packet_length) &&
    (strm << _tao_aggregate.packet_number) &&
    (strm << _tao_aggregate.number_of_packets) &&
    (strm << _tao_aggregate.Id)
  )
    return 1;
  else
    return 0;

}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, MIOP::PacketHeader_1_0 &_tao_aggregate)
{
  MIOP::PacketHeader_1_0::_magic_forany _tao_aggregate_magic
      (ACE_const_cast (
          MIOP::PacketHeader_1_0::_magic_slice*,
          _tao_aggregate.magic
        )
    );
  if (
    (strm >> _tao_aggregate_magic) &&
    (strm >> CORBA::Any::to_octet (_tao_aggregate.hdr_version)) &&
    (strm >> CORBA::Any::to_octet (_tao_aggregate.flags)) &&
    (strm >> _tao_aggregate.packet_length) &&
    (strm >> _tao_aggregate.packet_number) &&
    (strm >> _tao_aggregate.number_of_packets) &&
    (strm >> _tao_aggregate.Id)
  )
    return 1;
  else
    return 0;

}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const MIOP::Version &_tao_aggregate)
{
  if (
    (strm << CORBA::Any::from_octet (_tao_aggregate.major)) &&
    (strm << CORBA::Any::from_octet (_tao_aggregate.minor))
  )
    return 1;
  else
    return 0;

}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, MIOP::Version &_tao_aggregate)
{
  if (
    (strm >> CORBA::Any::to_octet (_tao_aggregate.major)) &&
    (strm >> CORBA::Any::to_octet (_tao_aggregate.minor))
  )
    return 1;
  else
    return 0;

}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const MIOP::UsingIpv4::_class_d_address_forany &_tao_array)
{
   return strm.write_octet_array ((const ACE_CDR::Octet *)_tao_array.in (), 4);
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, MIOP::UsingIpv4::_class_d_address_forany &_tao_array)
{
   return strm.read_octet_array ((ACE_CDR::Octet *) _tao_array.out (), 4);
}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const MIOP::UsingIpv4 &_tao_aggregate)
{
  MIOP::UsingIpv4::_class_d_address_forany _tao_aggregate_class_d_address
      (ACE_const_cast (
          MIOP::UsingIpv4::_class_d_address_slice*,
          _tao_aggregate.class_d_address
        )
    );
  if (
    (strm << _tao_aggregate.port) &&
    (strm << _tao_aggregate_class_d_address)
  )
    return 1;
  else
    return 0;

}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, MIOP::UsingIpv4 &_tao_aggregate)
{
  MIOP::UsingIpv4::_class_d_address_forany _tao_aggregate_class_d_address
      (ACE_const_cast (
          MIOP::UsingIpv4::_class_d_address_slice*,
          _tao_aggregate.class_d_address
        )
    );
  if (
    (strm >> _tao_aggregate.port) &&
    (strm >> _tao_aggregate_class_d_address)
  )
    return 1;
  else
    return 0;

}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const MIOP::UsingIpv6 &_tao_aggregate)
{
  if (
    (strm << _tao_aggregate.port) &&
    (strm << _tao_aggregate.address.in ())
  )
    return 1;
  else
    return 0;

}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, MIOP::UsingIpv6 &_tao_aggregate)
{
  if (
    (strm >> _tao_aggregate.port) &&
    (strm >> _tao_aggregate.address.out ())
  )
    return 1;
  else
    return 0;

}

ACE_INLINE CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const MIOP::IPEndpoints &_tao_union
  )
{
  if ( !(strm << _tao_union._d ()) )
    {
      return 0;
    }
  CORBA::Boolean result = 1;
  switch (_tao_union._d ())
  {
    case 0:
      {
        result = strm << _tao_union.ipv4_endpoints ();
      }
      break;
    case 1:
      {
        result = strm << _tao_union.ipv6_endpoints ();
      }
      break;
    default:
      break;
  }
  return result;
}

ACE_INLINE CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    MIOP::IPEndpoints &_tao_union
  )
{
  CORBA::Short _tao_discriminant;
  if ( !(strm >> _tao_discriminant) )
    {
      return 0;
    }
  CORBA::Boolean result = 1;
  switch (_tao_discriminant)
  {
    case 0:
      {
        MIOP::UsingIpv4 _tao_union_tmp;
        result = strm >> _tao_union_tmp;
        if (result)
          {
            _tao_union.ipv4_endpoints (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 1:
      {
        MIOP::UsingIpv6 _tao_union_tmp;
        result = strm >> _tao_union_tmp;
        if (result)
          {
            _tao_union.ipv6_endpoints (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      _tao_union._d (_tao_discriminant);
      break;
  }
  return result;
}


#if !defined _TAO_CDR_OP_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent_I_
#define _TAO_CDR_OP_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent_I_

CORBA::Boolean TAO_PortableGroup_Export operator<< (
    TAO_OutputCDR &,
    const MIOP::UIPMC_ProfileBody::_tao_seq_TaggedComponent &
  );
CORBA::Boolean TAO_PortableGroup_Export operator>> (
    TAO_InputCDR &,
    MIOP::UIPMC_ProfileBody::_tao_seq_TaggedComponent &
  );

#endif /* _TAO_CDR_OP_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent_I_ */

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const MIOP::UIPMC_ProfileBody &_tao_aggregate)
{
  if (
    (strm << _tao_aggregate.miop_version) &&
    (strm << _tao_aggregate.endpoints) &&
    (strm << _tao_aggregate.components)
  )
    return 1;
  else
    return 0;

}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, MIOP::UIPMC_ProfileBody &_tao_aggregate)
{
  if (
    (strm >> _tao_aggregate.miop_version) &&
    (strm >> _tao_aggregate.endpoints) &&
    (strm >> _tao_aggregate.components)
  )
    return 1;
  else
    return 0;

}

