// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#include "PortableGroupC.h"

#include "tao/Stub.h"
#include "tao/Invocation.h"
#include "tao/ClientRequestInfo.h"
#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */

#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "PortableGroupC.i"
#endif /* !defined INLINE */

static const CORBA::Long _oc_PortableGroup_GroupDomainId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  44,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x702f4772), 
  ACE_NTOHL (0x6f757044), 
  ACE_NTOHL (0x6f6d6169), 
  ACE_NTOHL (0x6e49643a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/PortableGroup/GroupDomainId:1.0
  14,
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x70446f6d), 
  ACE_NTOHL (0x61696e49), 
  ACE_NTOHL (0x64000000),  // name = GroupDomainId
  CORBA::tk_string, 
  0U, // string length
};

static CORBA::TypeCode _tc_TAO_tc_PortableGroup_GroupDomainId (
    CORBA::tk_alias,
    sizeof (_oc_PortableGroup_GroupDomainId),
    (char *) &_oc_PortableGroup_GroupDomainId,
    0,
    sizeof (PortableGroup::GroupDomainId)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_GroupDomainId, &_tc_TAO_tc_PortableGroup_GroupDomainId)
TAO_NAMESPACE_END

static const CORBA::Long _oc_PortableGroup_ObjectGroupId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  44,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x702f4f62), 
  ACE_NTOHL (0x6a656374), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x7049643a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/PortableGroup/ObjectGroupId:1.0
  14,
  ACE_NTOHL (0x4f626a65), 
  ACE_NTOHL (0x63744772), 
  ACE_NTOHL (0x6f757049), 
  ACE_NTOHL (0x64000000),  // name = ObjectGroupId
  CORBA::tk_ulonglong,

};

static CORBA::TypeCode _tc_TAO_tc_PortableGroup_ObjectGroupId (
    CORBA::tk_alias,
    sizeof (_oc_PortableGroup_ObjectGroupId),
    (char *) &_oc_PortableGroup_ObjectGroupId,
    0,
    sizeof (PortableGroup::ObjectGroupId)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ObjectGroupId, &_tc_TAO_tc_PortableGroup_ObjectGroupId)
TAO_NAMESPACE_END

static const CORBA::Long _oc_PortableGroup_ObjectGroupRefVersion[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  52,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x702f4f62), 
  ACE_NTOHL (0x6a656374), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x70526566), 
  ACE_NTOHL (0x56657273), 
  ACE_NTOHL (0x696f6e3a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/PortableGroup/ObjectGroupRefVersion:1.0
  22,
  ACE_NTOHL (0x4f626a65), 
  ACE_NTOHL (0x63744772), 
  ACE_NTOHL (0x6f757052), 
  ACE_NTOHL (0x65665665), 
  ACE_NTOHL (0x7273696f), 
  ACE_NTOHL (0x6e000000),  // name = ObjectGroupRefVersion
  CORBA::tk_ulong,

};

static CORBA::TypeCode _tc_TAO_tc_PortableGroup_ObjectGroupRefVersion (
    CORBA::tk_alias,
    sizeof (_oc_PortableGroup_ObjectGroupRefVersion),
    (char *) &_oc_PortableGroup_ObjectGroupRefVersion,
    0,
    sizeof (PortableGroup::ObjectGroupRefVersion)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ObjectGroupRefVersion, &_tc_TAO_tc_PortableGroup_ObjectGroupRefVersion)
TAO_NAMESPACE_END

static const CORBA::Long _oc_PortableGroup_Version[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  38,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x702f5665), 
  ACE_NTOHL (0x7273696f), 
  ACE_NTOHL (0x6e3a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/PortableGroup/Version:1.0
  8,
  ACE_NTOHL (0x56657273), 
  ACE_NTOHL (0x696f6e00),  // name = Version
  CORBA::tk_struct, // typecode kind
  88, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    29,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x47494f50), 
    ACE_NTOHL (0x2f566572), 
    ACE_NTOHL (0x73696f6e), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/GIOP/Version:1.0
    8,
    ACE_NTOHL (0x56657273), 
    ACE_NTOHL (0x696f6e00),  // name = Version
    2, // member count
    6,
    ACE_NTOHL (0x6d616a6f), 
    ACE_NTOHL (0x72000000),  // name = major
    CORBA::tk_octet,

    6,
    ACE_NTOHL (0x6d696e6f), 
    ACE_NTOHL (0x72000000),  // name = minor
    CORBA::tk_octet,


};

static CORBA::TypeCode _tc_TAO_tc_PortableGroup_Version (
    CORBA::tk_alias,
    sizeof (_oc_PortableGroup_Version),
    (char *) &_oc_PortableGroup_Version,
    0,
    sizeof (PortableGroup::Version)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Version, &_tc_TAO_tc_PortableGroup_Version)
TAO_NAMESPACE_END

static const CORBA::Long _oc_PortableGroup_TagGroupTaggedComponent[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  54,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x702f5461), 
  ACE_NTOHL (0x6747726f), 
  ACE_NTOHL (0x75705461), 
  ACE_NTOHL (0x67676564), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x743a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/PortableGroup/TagGroupTaggedComponent:1.0
  24,
  ACE_NTOHL (0x54616747), 
  ACE_NTOHL (0x726f7570), 
  ACE_NTOHL (0x54616767), 
  ACE_NTOHL (0x6564436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7400),  // name = TagGroupTaggedComponent
  4, // member count
  18,
  ACE_NTOHL (0x636f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x745f7665), 
  ACE_NTOHL (0x7273696f), 
  ACE_NTOHL (0x6e000000),  // name = component_version
  CORBA::tk_alias, // typecode kind for typedefs
  156, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    38,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x506f7274), 
    ACE_NTOHL (0x61626c65), 
    ACE_NTOHL (0x47726f75), 
    ACE_NTOHL (0x702f5665), 
    ACE_NTOHL (0x7273696f), 
    ACE_NTOHL (0x6e3a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/PortableGroup/Version:1.0
    8,
    ACE_NTOHL (0x56657273), 
    ACE_NTOHL (0x696f6e00),  // name = Version
    CORBA::tk_struct, // typecode kind
    88, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      29,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x47494f50), 
      ACE_NTOHL (0x2f566572), 
      ACE_NTOHL (0x73696f6e), 
      ACE_NTOHL (0x3a312e30), 
      ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/GIOP/Version:1.0
      8,
      ACE_NTOHL (0x56657273), 
      ACE_NTOHL (0x696f6e00),  // name = Version
      2, // member count
      6,
      ACE_NTOHL (0x6d616a6f), 
      ACE_NTOHL (0x72000000),  // name = major
      CORBA::tk_octet,

      6,
      ACE_NTOHL (0x6d696e6f), 
      ACE_NTOHL (0x72000000),  // name = minor
      CORBA::tk_octet,



  16,
  ACE_NTOHL (0x67726f75), 
  ACE_NTOHL (0x705f646f), 
  ACE_NTOHL (0x6d61696e), 
  ACE_NTOHL (0x5f696400),  // name = group_domain_id
  CORBA::tk_alias, // typecode kind for typedefs
  80, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    44,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x506f7274), 
    ACE_NTOHL (0x61626c65), 
    ACE_NTOHL (0x47726f75), 
    ACE_NTOHL (0x702f4772), 
    ACE_NTOHL (0x6f757044), 
    ACE_NTOHL (0x6f6d6169), 
    ACE_NTOHL (0x6e49643a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/PortableGroup/GroupDomainId:1.0
    14,
    ACE_NTOHL (0x47726f75), 
    ACE_NTOHL (0x70446f6d), 
    ACE_NTOHL (0x61696e49), 
    ACE_NTOHL (0x64000000),  // name = GroupDomainId
    CORBA::tk_string, 
    0U, // string length

  16,
  ACE_NTOHL (0x6f626a65), 
  ACE_NTOHL (0x63745f67), 
  ACE_NTOHL (0x726f7570), 
  ACE_NTOHL (0x5f696400),  // name = object_group_id
  CORBA::tk_alias, // typecode kind for typedefs
  76, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    44,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x506f7274), 
    ACE_NTOHL (0x61626c65), 
    ACE_NTOHL (0x47726f75), 
    ACE_NTOHL (0x702f4f62), 
    ACE_NTOHL (0x6a656374), 
    ACE_NTOHL (0x47726f75), 
    ACE_NTOHL (0x7049643a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/PortableGroup/ObjectGroupId:1.0
    14,
    ACE_NTOHL (0x4f626a65), 
    ACE_NTOHL (0x63744772), 
    ACE_NTOHL (0x6f757049), 
    ACE_NTOHL (0x64000000),  // name = ObjectGroupId
    CORBA::tk_ulonglong,


  25,
  ACE_NTOHL (0x6f626a65), 
  ACE_NTOHL (0x63745f67), 
  ACE_NTOHL (0x726f7570), 
  ACE_NTOHL (0x5f726566), 
  ACE_NTOHL (0x5f766572), 
  ACE_NTOHL (0x73696f6e), 
  ACE_NTOHL (0x0),  // name = object_group_ref_version
  CORBA::tk_alias, // typecode kind for typedefs
  92, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    52,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x506f7274), 
    ACE_NTOHL (0x61626c65), 
    ACE_NTOHL (0x47726f75), 
    ACE_NTOHL (0x702f4f62), 
    ACE_NTOHL (0x6a656374), 
    ACE_NTOHL (0x47726f75), 
    ACE_NTOHL (0x70526566), 
    ACE_NTOHL (0x56657273), 
    ACE_NTOHL (0x696f6e3a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/PortableGroup/ObjectGroupRefVersion:1.0
    22,
    ACE_NTOHL (0x4f626a65), 
    ACE_NTOHL (0x63744772), 
    ACE_NTOHL (0x6f757052), 
    ACE_NTOHL (0x65665665), 
    ACE_NTOHL (0x7273696f), 
    ACE_NTOHL (0x6e000000),  // name = ObjectGroupRefVersion
    CORBA::tk_ulong,


};

static CORBA::TypeCode _tc_TAO_tc_PortableGroup_TagGroupTaggedComponent (
    CORBA::tk_struct,
    sizeof (_oc_PortableGroup_TagGroupTaggedComponent),
    (char *) &_oc_PortableGroup_TagGroupTaggedComponent,
    0,
    sizeof (PortableGroup::TagGroupTaggedComponent)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_TagGroupTaggedComponent, &_tc_TAO_tc_PortableGroup_TagGroupTaggedComponent)
TAO_NAMESPACE_END

void PortableGroup::TagGroupTaggedComponent::_tao_any_destructor (void *x)
{
  TagGroupTaggedComponent *tmp = ACE_static_cast (TagGroupTaggedComponent*,x);
  delete tmp;
}


#if !defined (_PORTABLEGROUP_GROUPIIOPPROFILE_CS_)
#define _PORTABLEGROUP_GROUPIIOPPROFILE_CS_

// *************************************************************
// PortableGroup::GroupIIOPProfile
// *************************************************************

PortableGroup::GroupIIOPProfile::GroupIIOPProfile (void)
{}
PortableGroup::GroupIIOPProfile::GroupIIOPProfile (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::Octet>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
PortableGroup::GroupIIOPProfile::GroupIIOPProfile (CORBA::ULong max, CORBA::ULong length, CORBA::Octet *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::Octet>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
PortableGroup::GroupIIOPProfile::GroupIIOPProfile (const GroupIIOPProfile &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::Octet>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
PortableGroup::GroupIIOPProfile::~GroupIIOPProfile (void) // dtor
{}
void PortableGroup::GroupIIOPProfile::_tao_any_destructor (void *x)
{
  GroupIIOPProfile *tmp = ACE_static_cast (GroupIIOPProfile*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_PortableGroup_GroupIIOPProfile[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  47,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x702f4772), 
  ACE_NTOHL (0x6f757049), 
  ACE_NTOHL (0x494f5050), 
  ACE_NTOHL (0x726f6669), 
  ACE_NTOHL (0x6c653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableGroup/GroupIIOPProfile:1.0
  17,
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x7049494f), 
  ACE_NTOHL (0x5050726f), 
  ACE_NTOHL (0x66696c65), 
  ACE_NTOHL (0x0),  // name = GroupIIOPProfile
  CORBA::tk_sequence, // typecode kind
  12, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_octet,

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_PortableGroup_GroupIIOPProfile (
    CORBA::tk_alias,
    sizeof (_oc_PortableGroup_GroupIIOPProfile),
    (char *) &_oc_PortableGroup_GroupIIOPProfile,
    0,
    sizeof (PortableGroup::GroupIIOPProfile)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_GroupIIOPProfile, &_tc_TAO_tc_PortableGroup_GroupIIOPProfile)
TAO_NAMESPACE_END

static const CORBA::Long _oc_PortableGroup_TypeId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  37,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x702f5479), 
  ACE_NTOHL (0x70654964), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/PortableGroup/TypeId:1.0
  7,
  ACE_NTOHL (0x54797065), 
  ACE_NTOHL (0x49640000),  // name = TypeId
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5265), 
    ACE_NTOHL (0x706f7369), 
    ACE_NTOHL (0x746f7279), 
    ACE_NTOHL (0x49643a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

};

static CORBA::TypeCode _tc_TAO_tc_PortableGroup_TypeId (
    CORBA::tk_alias,
    sizeof (_oc_PortableGroup_TypeId),
    (char *) &_oc_PortableGroup_TypeId,
    0,
    sizeof (PortableGroup::TypeId)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_TypeId, &_tc_TAO_tc_PortableGroup_TypeId)
TAO_NAMESPACE_END

static const CORBA::Long _oc_PortableGroup_ObjectGroup[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  42,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x702f4f62), 
  ACE_NTOHL (0x6a656374), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x703a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/PortableGroup/ObjectGroup:1.0
  12,
  ACE_NTOHL (0x4f626a65), 
  ACE_NTOHL (0x63744772), 
  ACE_NTOHL (0x6f757000),  // name = ObjectGroup
  CORBA::tk_objref,
  52, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    29,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4f62), 
    ACE_NTOHL (0x6a656374), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Object:1.0
    7,
    ACE_NTOHL (0x4f626a65), 
    ACE_NTOHL (0x63740000),  // name = Object

};

static CORBA::TypeCode _tc_TAO_tc_PortableGroup_ObjectGroup (
    CORBA::tk_alias,
    sizeof (_oc_PortableGroup_ObjectGroup),
    (char *) &_oc_PortableGroup_ObjectGroup,
    0,
    sizeof (PortableGroup::ObjectGroup)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ObjectGroup, &_tc_TAO_tc_PortableGroup_ObjectGroup)
TAO_NAMESPACE_END

static const CORBA::Long _oc_PortableGroup_Name[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x702f4e61), 
  ACE_NTOHL (0x6d653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableGroup/Name:1.0
  5,
  ACE_NTOHL (0x4e616d65), 
  ACE_NTOHL (0x0),  // name = Name
  CORBA::tk_alias, // typecode kind for typedefs
  312, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f734e), 
    ACE_NTOHL (0x616d696e), 
    ACE_NTOHL (0x672f4e61), 
    ACE_NTOHL (0x6d653a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CosNaming/Name:1.0
    5,
    ACE_NTOHL (0x4e616d65), 
    ACE_NTOHL (0x0),  // name = Name
    CORBA::tk_sequence, // typecode kind
    252, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      236, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f734e), 
        ACE_NTOHL (0x616d696e), 
        ACE_NTOHL (0x672f4e61), 
        ACE_NTOHL (0x6d65436f), 
        ACE_NTOHL (0x6d706f6e), 
        ACE_NTOHL (0x656e743a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CosNaming/NameComponent:1.0
        14,
        ACE_NTOHL (0x4e616d65), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74000000),  // name = NameComponent
        2, // member count
        3,
        ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          34,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f734e), 
          ACE_NTOHL (0x616d696e), 
          ACE_NTOHL (0x672f4973), 
          ACE_NTOHL (0x7472696e), 
          ACE_NTOHL (0x673a312e), 
          ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CosNaming/Istring:1.0
          8,
          ACE_NTOHL (0x49737472), 
          ACE_NTOHL (0x696e6700),  // name = Istring
          CORBA::tk_string, 
          0U, // string length

        5,
        ACE_NTOHL (0x6b696e64), 
        ACE_NTOHL (0x0),  // name = kind
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          34,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f734e), 
          ACE_NTOHL (0x616d696e), 
          ACE_NTOHL (0x672f4973), 
          ACE_NTOHL (0x7472696e), 
          ACE_NTOHL (0x673a312e), 
          ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CosNaming/Istring:1.0
          8,
          ACE_NTOHL (0x49737472), 
          ACE_NTOHL (0x696e6700),  // name = Istring
          CORBA::tk_string, 
          0U, // string length


      0U,


};

static CORBA::TypeCode _tc_TAO_tc_PortableGroup_Name (
    CORBA::tk_alias,
    sizeof (_oc_PortableGroup_Name),
    (char *) &_oc_PortableGroup_Name,
    0,
    sizeof (PortableGroup::Name)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Name, &_tc_TAO_tc_PortableGroup_Name)
TAO_NAMESPACE_END

static const CORBA::Long _oc_PortableGroup_Value[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  36,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x702f5661), 
  ACE_NTOHL (0x6c75653a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/PortableGroup/Value:1.0
  6,
  ACE_NTOHL (0x56616c75), 
  ACE_NTOHL (0x65000000),  // name = Value
  CORBA::tk_any,

};

static CORBA::TypeCode _tc_TAO_tc_PortableGroup_Value (
    CORBA::tk_alias,
    sizeof (_oc_PortableGroup_Value),
    (char *) &_oc_PortableGroup_Value,
    0,
    sizeof (PortableGroup::Value)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Value, &_tc_TAO_tc_PortableGroup_Value)
TAO_NAMESPACE_END

static const CORBA::Long _oc_PortableGroup_Property[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x702f5072), 
  ACE_NTOHL (0x6f706572), 
  ACE_NTOHL (0x74793a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableGroup/Property:1.0
  9,
  ACE_NTOHL (0x50726f70), 
  ACE_NTOHL (0x65727479), 
  ACE_NTOHL (0x0),  // name = Property
  2, // member count
  4,
  ACE_NTOHL (0x6e616d00),  // name = nam
  CORBA::tk_alias, // typecode kind for typedefs
  376, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x506f7274), 
    ACE_NTOHL (0x61626c65), 
    ACE_NTOHL (0x47726f75), 
    ACE_NTOHL (0x702f4e61), 
    ACE_NTOHL (0x6d653a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableGroup/Name:1.0
    5,
    ACE_NTOHL (0x4e616d65), 
    ACE_NTOHL (0x0),  // name = Name
    CORBA::tk_alias, // typecode kind for typedefs
    312, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      31,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f734e), 
      ACE_NTOHL (0x616d696e), 
      ACE_NTOHL (0x672f4e61), 
      ACE_NTOHL (0x6d653a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CosNaming/Name:1.0
      5,
      ACE_NTOHL (0x4e616d65), 
      ACE_NTOHL (0x0),  // name = Name
      CORBA::tk_sequence, // typecode kind
      252, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        CORBA::tk_struct, // typecode kind
        236, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          40,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f734e), 
          ACE_NTOHL (0x616d696e), 
          ACE_NTOHL (0x672f4e61), 
          ACE_NTOHL (0x6d65436f), 
          ACE_NTOHL (0x6d706f6e), 
          ACE_NTOHL (0x656e743a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CosNaming/NameComponent:1.0
          14,
          ACE_NTOHL (0x4e616d65), 
          ACE_NTOHL (0x436f6d70), 
          ACE_NTOHL (0x6f6e656e), 
          ACE_NTOHL (0x74000000),  // name = NameComponent
          2, // member count
          3,
          ACE_NTOHL (0x69640000),  // name = id
          CORBA::tk_alias, // typecode kind for typedefs
          64, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            34,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x6f6d672e), 
            ACE_NTOHL (0x6f72672f), 
            ACE_NTOHL (0x436f734e), 
            ACE_NTOHL (0x616d696e), 
            ACE_NTOHL (0x672f4973), 
            ACE_NTOHL (0x7472696e), 
            ACE_NTOHL (0x673a312e), 
            ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CosNaming/Istring:1.0
            8,
            ACE_NTOHL (0x49737472), 
            ACE_NTOHL (0x696e6700),  // name = Istring
            CORBA::tk_string, 
            0U, // string length

          5,
          ACE_NTOHL (0x6b696e64), 
          ACE_NTOHL (0x0),  // name = kind
          CORBA::tk_alias, // typecode kind for typedefs
          64, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            34,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x6f6d672e), 
            ACE_NTOHL (0x6f72672f), 
            ACE_NTOHL (0x436f734e), 
            ACE_NTOHL (0x616d696e), 
            ACE_NTOHL (0x672f4973), 
            ACE_NTOHL (0x7472696e), 
            ACE_NTOHL (0x673a312e), 
            ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CosNaming/Istring:1.0
            8,
            ACE_NTOHL (0x49737472), 
            ACE_NTOHL (0x696e6700),  // name = Istring
            CORBA::tk_string, 
            0U, // string length


        0U,



  4,
  ACE_NTOHL (0x76616c00),  // name = val
  CORBA::tk_alias, // typecode kind for typedefs
  60, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    36,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x506f7274), 
    ACE_NTOHL (0x61626c65), 
    ACE_NTOHL (0x47726f75), 
    ACE_NTOHL (0x702f5661), 
    ACE_NTOHL (0x6c75653a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/PortableGroup/Value:1.0
    6,
    ACE_NTOHL (0x56616c75), 
    ACE_NTOHL (0x65000000),  // name = Value
    CORBA::tk_any,


};

static CORBA::TypeCode _tc_TAO_tc_PortableGroup_Property (
    CORBA::tk_struct,
    sizeof (_oc_PortableGroup_Property),
    (char *) &_oc_PortableGroup_Property,
    0,
    sizeof (PortableGroup::Property)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Property, &_tc_TAO_tc_PortableGroup_Property)
TAO_NAMESPACE_END

void PortableGroup::Property::_tao_any_destructor (void *x)
{
  Property *tmp = ACE_static_cast (Property*,x);
  delete tmp;
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_PORTABLEGROUP_PROPERTIES_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_PORTABLEGROUP_PROPERTIES_CS_

  void
  PortableGroup::_TAO_Unbounded_Sequence_PortableGroup_Properties::_allocate_buffer (CORBA::ULong length)
  {
    PortableGroup::Property* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_PortableGroup_Properties::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      PortableGroup::Property *old = ACE_reinterpret_cast (PortableGroup::Property *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_PortableGroup_Properties::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  PortableGroup::_TAO_Unbounded_Sequence_PortableGroup_Properties::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    PortableGroup::Property *tmp = ACE_reinterpret_cast (PortableGroup::Property *,this->buffer_);
    
    _TAO_Unbounded_Sequence_PortableGroup_Properties::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  PortableGroup::_TAO_Unbounded_Sequence_PortableGroup_Properties::~_TAO_Unbounded_Sequence_PortableGroup_Properties (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_PORTABLEGROUP_PROPERTIES_CS_)
#define _PORTABLEGROUP_PROPERTIES_CS_

// *************************************************************
// PortableGroup::Properties
// *************************************************************

PortableGroup::Properties::Properties (void)
{}
PortableGroup::Properties::Properties (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_PortableGroup_Properties
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<PortableGroup::Property>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
PortableGroup::Properties::Properties (CORBA::ULong max, CORBA::ULong length, PortableGroup::Property *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_PortableGroup_Properties
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<PortableGroup::Property>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
PortableGroup::Properties::Properties (const Properties &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_PortableGroup_Properties
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<PortableGroup::Property>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
PortableGroup::Properties::~Properties (void) // dtor
{}
void PortableGroup::Properties::_tao_any_destructor (void *x)
{
  Properties *tmp = ACE_static_cast (Properties*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_PortableGroup_Properties[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  41,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x702f5072), 
  ACE_NTOHL (0x6f706572), 
  ACE_NTOHL (0x74696573), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/PortableGroup/Properties:1.0
  11,
  ACE_NTOHL (0x50726f70), 
  ACE_NTOHL (0x65727469), 
  ACE_NTOHL (0x65730000),  // name = Properties
  CORBA::tk_sequence, // typecode kind
  552, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    536, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      39,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x506f7274), 
      ACE_NTOHL (0x61626c65), 
      ACE_NTOHL (0x47726f75), 
      ACE_NTOHL (0x702f5072), 
      ACE_NTOHL (0x6f706572), 
      ACE_NTOHL (0x74793a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableGroup/Property:1.0
      9,
      ACE_NTOHL (0x50726f70), 
      ACE_NTOHL (0x65727479), 
      ACE_NTOHL (0x0),  // name = Property
      2, // member count
      4,
      ACE_NTOHL (0x6e616d00),  // name = nam
      CORBA::tk_alias, // typecode kind for typedefs
      376, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x506f7274), 
        ACE_NTOHL (0x61626c65), 
        ACE_NTOHL (0x47726f75), 
        ACE_NTOHL (0x702f4e61), 
        ACE_NTOHL (0x6d653a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableGroup/Name:1.0
        5,
        ACE_NTOHL (0x4e616d65), 
        ACE_NTOHL (0x0),  // name = Name
        CORBA::tk_alias, // typecode kind for typedefs
        312, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f734e), 
          ACE_NTOHL (0x616d696e), 
          ACE_NTOHL (0x672f4e61), 
          ACE_NTOHL (0x6d653a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CosNaming/Name:1.0
          5,
          ACE_NTOHL (0x4e616d65), 
          ACE_NTOHL (0x0),  // name = Name
          CORBA::tk_sequence, // typecode kind
          252, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            236, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x436f734e), 
              ACE_NTOHL (0x616d696e), 
              ACE_NTOHL (0x672f4e61), 
              ACE_NTOHL (0x6d65436f), 
              ACE_NTOHL (0x6d706f6e), 
              ACE_NTOHL (0x656e743a), 
              ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CosNaming/NameComponent:1.0
              14,
              ACE_NTOHL (0x4e616d65), 
              ACE_NTOHL (0x436f6d70), 
              ACE_NTOHL (0x6f6e656e), 
              ACE_NTOHL (0x74000000),  // name = NameComponent
              2, // member count
              3,
              ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                34,
                ACE_NTOHL (0x49444c3a), 
                ACE_NTOHL (0x6f6d672e), 
                ACE_NTOHL (0x6f72672f), 
                ACE_NTOHL (0x436f734e), 
                ACE_NTOHL (0x616d696e), 
                ACE_NTOHL (0x672f4973), 
                ACE_NTOHL (0x7472696e), 
                ACE_NTOHL (0x673a312e), 
                ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CosNaming/Istring:1.0
                8,
                ACE_NTOHL (0x49737472), 
                ACE_NTOHL (0x696e6700),  // name = Istring
                CORBA::tk_string, 
                0U, // string length

              5,
              ACE_NTOHL (0x6b696e64), 
              ACE_NTOHL (0x0),  // name = kind
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                34,
                ACE_NTOHL (0x49444c3a), 
                ACE_NTOHL (0x6f6d672e), 
                ACE_NTOHL (0x6f72672f), 
                ACE_NTOHL (0x436f734e), 
                ACE_NTOHL (0x616d696e), 
                ACE_NTOHL (0x672f4973), 
                ACE_NTOHL (0x7472696e), 
                ACE_NTOHL (0x673a312e), 
                ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CosNaming/Istring:1.0
                8,
                ACE_NTOHL (0x49737472), 
                ACE_NTOHL (0x696e6700),  // name = Istring
                CORBA::tk_string, 
                0U, // string length


            0U,



      4,
      ACE_NTOHL (0x76616c00),  // name = val
      CORBA::tk_alias, // typecode kind for typedefs
      60, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        36,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x506f7274), 
        ACE_NTOHL (0x61626c65), 
        ACE_NTOHL (0x47726f75), 
        ACE_NTOHL (0x702f5661), 
        ACE_NTOHL (0x6c75653a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/PortableGroup/Value:1.0
        6,
        ACE_NTOHL (0x56616c75), 
        ACE_NTOHL (0x65000000),  // name = Value
        CORBA::tk_any,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_PortableGroup_Properties (
    CORBA::tk_alias,
    sizeof (_oc_PortableGroup_Properties),
    (char *) &_oc_PortableGroup_Properties,
    0,
    sizeof (PortableGroup::Properties)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Properties, &_tc_TAO_tc_PortableGroup_Properties)
TAO_NAMESPACE_END

static const CORBA::Long _oc_PortableGroup_Location[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x702f4c6f), 
  ACE_NTOHL (0x63617469), 
  ACE_NTOHL (0x6f6e3a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableGroup/Location:1.0
  9,
  ACE_NTOHL (0x4c6f6361), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x0),  // name = Location
  CORBA::tk_alias, // typecode kind for typedefs
  376, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x506f7274), 
    ACE_NTOHL (0x61626c65), 
    ACE_NTOHL (0x47726f75), 
    ACE_NTOHL (0x702f4e61), 
    ACE_NTOHL (0x6d653a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableGroup/Name:1.0
    5,
    ACE_NTOHL (0x4e616d65), 
    ACE_NTOHL (0x0),  // name = Name
    CORBA::tk_alias, // typecode kind for typedefs
    312, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      31,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f734e), 
      ACE_NTOHL (0x616d696e), 
      ACE_NTOHL (0x672f4e61), 
      ACE_NTOHL (0x6d653a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CosNaming/Name:1.0
      5,
      ACE_NTOHL (0x4e616d65), 
      ACE_NTOHL (0x0),  // name = Name
      CORBA::tk_sequence, // typecode kind
      252, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        CORBA::tk_struct, // typecode kind
        236, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          40,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f734e), 
          ACE_NTOHL (0x616d696e), 
          ACE_NTOHL (0x672f4e61), 
          ACE_NTOHL (0x6d65436f), 
          ACE_NTOHL (0x6d706f6e), 
          ACE_NTOHL (0x656e743a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CosNaming/NameComponent:1.0
          14,
          ACE_NTOHL (0x4e616d65), 
          ACE_NTOHL (0x436f6d70), 
          ACE_NTOHL (0x6f6e656e), 
          ACE_NTOHL (0x74000000),  // name = NameComponent
          2, // member count
          3,
          ACE_NTOHL (0x69640000),  // name = id
          CORBA::tk_alias, // typecode kind for typedefs
          64, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            34,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x6f6d672e), 
            ACE_NTOHL (0x6f72672f), 
            ACE_NTOHL (0x436f734e), 
            ACE_NTOHL (0x616d696e), 
            ACE_NTOHL (0x672f4973), 
            ACE_NTOHL (0x7472696e), 
            ACE_NTOHL (0x673a312e), 
            ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CosNaming/Istring:1.0
            8,
            ACE_NTOHL (0x49737472), 
            ACE_NTOHL (0x696e6700),  // name = Istring
            CORBA::tk_string, 
            0U, // string length

          5,
          ACE_NTOHL (0x6b696e64), 
          ACE_NTOHL (0x0),  // name = kind
          CORBA::tk_alias, // typecode kind for typedefs
          64, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            34,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x6f6d672e), 
            ACE_NTOHL (0x6f72672f), 
            ACE_NTOHL (0x436f734e), 
            ACE_NTOHL (0x616d696e), 
            ACE_NTOHL (0x672f4973), 
            ACE_NTOHL (0x7472696e), 
            ACE_NTOHL (0x673a312e), 
            ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CosNaming/Istring:1.0
            8,
            ACE_NTOHL (0x49737472), 
            ACE_NTOHL (0x696e6700),  // name = Istring
            CORBA::tk_string, 
            0U, // string length


        0U,



};

static CORBA::TypeCode _tc_TAO_tc_PortableGroup_Location (
    CORBA::tk_alias,
    sizeof (_oc_PortableGroup_Location),
    (char *) &_oc_PortableGroup_Location,
    0,
    sizeof (PortableGroup::Location)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Location, &_tc_TAO_tc_PortableGroup_Location)
TAO_NAMESPACE_END


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_PORTABLEGROUP_LOCATIONS_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_PORTABLEGROUP_LOCATIONS_CS_

  void
  PortableGroup::_TAO_Unbounded_Sequence_PortableGroup_Locations::_allocate_buffer (CORBA::ULong length)
  {
    PortableGroup::Location* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_PortableGroup_Locations::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      PortableGroup::Location *old = ACE_reinterpret_cast (PortableGroup::Location *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_PortableGroup_Locations::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  PortableGroup::_TAO_Unbounded_Sequence_PortableGroup_Locations::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    PortableGroup::Location *tmp = ACE_reinterpret_cast (PortableGroup::Location *,this->buffer_);
    
    _TAO_Unbounded_Sequence_PortableGroup_Locations::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  PortableGroup::_TAO_Unbounded_Sequence_PortableGroup_Locations::~_TAO_Unbounded_Sequence_PortableGroup_Locations (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_PORTABLEGROUP_LOCATIONS_CS_)
#define _PORTABLEGROUP_LOCATIONS_CS_

// *************************************************************
// PortableGroup::Locations
// *************************************************************

PortableGroup::Locations::Locations (void)
{}
PortableGroup::Locations::Locations (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_PortableGroup_Locations
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<PortableGroup::Location>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
PortableGroup::Locations::Locations (CORBA::ULong max, CORBA::ULong length, PortableGroup::Location *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_PortableGroup_Locations
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<PortableGroup::Location>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
PortableGroup::Locations::Locations (const Locations &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_PortableGroup_Locations
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<PortableGroup::Location>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
PortableGroup::Locations::~Locations (void) // dtor
{}
void PortableGroup::Locations::_tao_any_destructor (void *x)
{
  Locations *tmp = ACE_static_cast (Locations*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_PortableGroup_Locations[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x702f4c6f), 
  ACE_NTOHL (0x63617469), 
  ACE_NTOHL (0x6f6e733a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/PortableGroup/Locations:1.0
  10,
  ACE_NTOHL (0x4c6f6361), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x73000000),  // name = Locations
  CORBA::tk_sequence, // typecode kind
  464, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_alias, // typecode kind for typedefs
    448, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      39,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x506f7274), 
      ACE_NTOHL (0x61626c65), 
      ACE_NTOHL (0x47726f75), 
      ACE_NTOHL (0x702f4c6f), 
      ACE_NTOHL (0x63617469), 
      ACE_NTOHL (0x6f6e3a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableGroup/Location:1.0
      9,
      ACE_NTOHL (0x4c6f6361), 
      ACE_NTOHL (0x74696f6e), 
      ACE_NTOHL (0x0),  // name = Location
      CORBA::tk_alias, // typecode kind for typedefs
      376, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x506f7274), 
        ACE_NTOHL (0x61626c65), 
        ACE_NTOHL (0x47726f75), 
        ACE_NTOHL (0x702f4e61), 
        ACE_NTOHL (0x6d653a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableGroup/Name:1.0
        5,
        ACE_NTOHL (0x4e616d65), 
        ACE_NTOHL (0x0),  // name = Name
        CORBA::tk_alias, // typecode kind for typedefs
        312, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f734e), 
          ACE_NTOHL (0x616d696e), 
          ACE_NTOHL (0x672f4e61), 
          ACE_NTOHL (0x6d653a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CosNaming/Name:1.0
          5,
          ACE_NTOHL (0x4e616d65), 
          ACE_NTOHL (0x0),  // name = Name
          CORBA::tk_sequence, // typecode kind
          252, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            236, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x436f734e), 
              ACE_NTOHL (0x616d696e), 
              ACE_NTOHL (0x672f4e61), 
              ACE_NTOHL (0x6d65436f), 
              ACE_NTOHL (0x6d706f6e), 
              ACE_NTOHL (0x656e743a), 
              ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CosNaming/NameComponent:1.0
              14,
              ACE_NTOHL (0x4e616d65), 
              ACE_NTOHL (0x436f6d70), 
              ACE_NTOHL (0x6f6e656e), 
              ACE_NTOHL (0x74000000),  // name = NameComponent
              2, // member count
              3,
              ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                34,
                ACE_NTOHL (0x49444c3a), 
                ACE_NTOHL (0x6f6d672e), 
                ACE_NTOHL (0x6f72672f), 
                ACE_NTOHL (0x436f734e), 
                ACE_NTOHL (0x616d696e), 
                ACE_NTOHL (0x672f4973), 
                ACE_NTOHL (0x7472696e), 
                ACE_NTOHL (0x673a312e), 
                ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CosNaming/Istring:1.0
                8,
                ACE_NTOHL (0x49737472), 
                ACE_NTOHL (0x696e6700),  // name = Istring
                CORBA::tk_string, 
                0U, // string length

              5,
              ACE_NTOHL (0x6b696e64), 
              ACE_NTOHL (0x0),  // name = kind
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                34,
                ACE_NTOHL (0x49444c3a), 
                ACE_NTOHL (0x6f6d672e), 
                ACE_NTOHL (0x6f72672f), 
                ACE_NTOHL (0x436f734e), 
                ACE_NTOHL (0x616d696e), 
                ACE_NTOHL (0x672f4973), 
                ACE_NTOHL (0x7472696e), 
                ACE_NTOHL (0x673a312e), 
                ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CosNaming/Istring:1.0
                8,
                ACE_NTOHL (0x49737472), 
                ACE_NTOHL (0x696e6700),  // name = Istring
                CORBA::tk_string, 
                0U, // string length


            0U,




    0U,

};

static CORBA::TypeCode _tc_TAO_tc_PortableGroup_Locations (
    CORBA::tk_alias,
    sizeof (_oc_PortableGroup_Locations),
    (char *) &_oc_PortableGroup_Locations,
    0,
    sizeof (PortableGroup::Locations)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Locations, &_tc_TAO_tc_PortableGroup_Locations)
TAO_NAMESPACE_END

static const CORBA::Long _oc_PortableGroup_Criteria[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x702f4372), 
  ACE_NTOHL (0x69746572), 
  ACE_NTOHL (0x69613a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableGroup/Criteria:1.0
  9,
  ACE_NTOHL (0x43726974), 
  ACE_NTOHL (0x65726961), 
  ACE_NTOHL (0x0),  // name = Criteria
  CORBA::tk_alias, // typecode kind for typedefs
  628, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    41,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x506f7274), 
    ACE_NTOHL (0x61626c65), 
    ACE_NTOHL (0x47726f75), 
    ACE_NTOHL (0x702f5072), 
    ACE_NTOHL (0x6f706572), 
    ACE_NTOHL (0x74696573), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/PortableGroup/Properties:1.0
    11,
    ACE_NTOHL (0x50726f70), 
    ACE_NTOHL (0x65727469), 
    ACE_NTOHL (0x65730000),  // name = Properties
    CORBA::tk_sequence, // typecode kind
    552, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      536, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        39,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x506f7274), 
        ACE_NTOHL (0x61626c65), 
        ACE_NTOHL (0x47726f75), 
        ACE_NTOHL (0x702f5072), 
        ACE_NTOHL (0x6f706572), 
        ACE_NTOHL (0x74793a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableGroup/Property:1.0
        9,
        ACE_NTOHL (0x50726f70), 
        ACE_NTOHL (0x65727479), 
        ACE_NTOHL (0x0),  // name = Property
        2, // member count
        4,
        ACE_NTOHL (0x6e616d00),  // name = nam
        CORBA::tk_alias, // typecode kind for typedefs
        376, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x506f7274), 
          ACE_NTOHL (0x61626c65), 
          ACE_NTOHL (0x47726f75), 
          ACE_NTOHL (0x702f4e61), 
          ACE_NTOHL (0x6d653a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableGroup/Name:1.0
          5,
          ACE_NTOHL (0x4e616d65), 
          ACE_NTOHL (0x0),  // name = Name
          CORBA::tk_alias, // typecode kind for typedefs
          312, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            31,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x6f6d672e), 
            ACE_NTOHL (0x6f72672f), 
            ACE_NTOHL (0x436f734e), 
            ACE_NTOHL (0x616d696e), 
            ACE_NTOHL (0x672f4e61), 
            ACE_NTOHL (0x6d653a31), 
            ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CosNaming/Name:1.0
            5,
            ACE_NTOHL (0x4e616d65), 
            ACE_NTOHL (0x0),  // name = Name
            CORBA::tk_sequence, // typecode kind
            252, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              CORBA::tk_struct, // typecode kind
              236, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                40,
                ACE_NTOHL (0x49444c3a), 
                ACE_NTOHL (0x6f6d672e), 
                ACE_NTOHL (0x6f72672f), 
                ACE_NTOHL (0x436f734e), 
                ACE_NTOHL (0x616d696e), 
                ACE_NTOHL (0x672f4e61), 
                ACE_NTOHL (0x6d65436f), 
                ACE_NTOHL (0x6d706f6e), 
                ACE_NTOHL (0x656e743a), 
                ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CosNaming/NameComponent:1.0
                14,
                ACE_NTOHL (0x4e616d65), 
                ACE_NTOHL (0x436f6d70), 
                ACE_NTOHL (0x6f6e656e), 
                ACE_NTOHL (0x74000000),  // name = NameComponent
                2, // member count
                3,
                ACE_NTOHL (0x69640000),  // name = id
                CORBA::tk_alias, // typecode kind for typedefs
                64, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  34,
                  ACE_NTOHL (0x49444c3a), 
                  ACE_NTOHL (0x6f6d672e), 
                  ACE_NTOHL (0x6f72672f), 
                  ACE_NTOHL (0x436f734e), 
                  ACE_NTOHL (0x616d696e), 
                  ACE_NTOHL (0x672f4973), 
                  ACE_NTOHL (0x7472696e), 
                  ACE_NTOHL (0x673a312e), 
                  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CosNaming/Istring:1.0
                  8,
                  ACE_NTOHL (0x49737472), 
                  ACE_NTOHL (0x696e6700),  // name = Istring
                  CORBA::tk_string, 
                  0U, // string length

                5,
                ACE_NTOHL (0x6b696e64), 
                ACE_NTOHL (0x0),  // name = kind
                CORBA::tk_alias, // typecode kind for typedefs
                64, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  34,
                  ACE_NTOHL (0x49444c3a), 
                  ACE_NTOHL (0x6f6d672e), 
                  ACE_NTOHL (0x6f72672f), 
                  ACE_NTOHL (0x436f734e), 
                  ACE_NTOHL (0x616d696e), 
                  ACE_NTOHL (0x672f4973), 
                  ACE_NTOHL (0x7472696e), 
                  ACE_NTOHL (0x673a312e), 
                  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CosNaming/Istring:1.0
                  8,
                  ACE_NTOHL (0x49737472), 
                  ACE_NTOHL (0x696e6700),  // name = Istring
                  CORBA::tk_string, 
                  0U, // string length


              0U,



        4,
        ACE_NTOHL (0x76616c00),  // name = val
        CORBA::tk_alias, // typecode kind for typedefs
        60, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          36,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x506f7274), 
          ACE_NTOHL (0x61626c65), 
          ACE_NTOHL (0x47726f75), 
          ACE_NTOHL (0x702f5661), 
          ACE_NTOHL (0x6c75653a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/PortableGroup/Value:1.0
          6,
          ACE_NTOHL (0x56616c75), 
          ACE_NTOHL (0x65000000),  // name = Value
          CORBA::tk_any,



      0U,


};

static CORBA::TypeCode _tc_TAO_tc_PortableGroup_Criteria (
    CORBA::tk_alias,
    sizeof (_oc_PortableGroup_Criteria),
    (char *) &_oc_PortableGroup_Criteria,
    0,
    sizeof (PortableGroup::Criteria)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Criteria, &_tc_TAO_tc_PortableGroup_Criteria)
TAO_NAMESPACE_END


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_PORTABLEGROUP_FACTORYINFOS_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_PORTABLEGROUP_FACTORYINFOS_CS_

  void
  PortableGroup::_TAO_Unbounded_Sequence_PortableGroup_FactoryInfos::_allocate_buffer (CORBA::ULong length)
  {
    PortableGroup::FactoryInfo* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_PortableGroup_FactoryInfos::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      PortableGroup::FactoryInfo *old = ACE_reinterpret_cast (PortableGroup::FactoryInfo *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_PortableGroup_FactoryInfos::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  PortableGroup::_TAO_Unbounded_Sequence_PortableGroup_FactoryInfos::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    PortableGroup::FactoryInfo *tmp = ACE_reinterpret_cast (PortableGroup::FactoryInfo *,this->buffer_);
    
    _TAO_Unbounded_Sequence_PortableGroup_FactoryInfos::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  PortableGroup::_TAO_Unbounded_Sequence_PortableGroup_FactoryInfos::~_TAO_Unbounded_Sequence_PortableGroup_FactoryInfos (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_PORTABLEGROUP_FACTORYINFOS_CS_)
#define _PORTABLEGROUP_FACTORYINFOS_CS_

// *************************************************************
// PortableGroup::FactoryInfos
// *************************************************************

PortableGroup::FactoryInfos::FactoryInfos (void)
{}
PortableGroup::FactoryInfos::FactoryInfos (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_PortableGroup_FactoryInfos
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<PortableGroup::FactoryInfo>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
PortableGroup::FactoryInfos::FactoryInfos (CORBA::ULong max, CORBA::ULong length, PortableGroup::FactoryInfo *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_PortableGroup_FactoryInfos
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<PortableGroup::FactoryInfo>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
PortableGroup::FactoryInfos::FactoryInfos (const FactoryInfos &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_PortableGroup_FactoryInfos
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<PortableGroup::FactoryInfo>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
PortableGroup::FactoryInfos::~FactoryInfos (void) // dtor
{}
void PortableGroup::FactoryInfos::_tao_any_destructor (void *x)
{
  FactoryInfos *tmp = ACE_static_cast (FactoryInfos*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_PortableGroup_MembershipStyleValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  51,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x702f4d65), 
  ACE_NTOHL (0x6d626572), 
  ACE_NTOHL (0x73686970), 
  ACE_NTOHL (0x5374796c), 
  ACE_NTOHL (0x6556616c), 
  ACE_NTOHL (0x75653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableGroup/MembershipStyleValue:1.0
  21,
  ACE_NTOHL (0x4d656d62), 
  ACE_NTOHL (0x65727368), 
  ACE_NTOHL (0x69705374), 
  ACE_NTOHL (0x796c6556), 
  ACE_NTOHL (0x616c7565), 
  ACE_NTOHL (0x0),  // name = MembershipStyleValue
  CORBA::tk_long,

};

static CORBA::TypeCode _tc_TAO_tc_PortableGroup_MembershipStyleValue (
    CORBA::tk_alias,
    sizeof (_oc_PortableGroup_MembershipStyleValue),
    (char *) &_oc_PortableGroup_MembershipStyleValue,
    0,
    sizeof (PortableGroup::MembershipStyleValue)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_MembershipStyleValue, &_tc_TAO_tc_PortableGroup_MembershipStyleValue)
TAO_NAMESPACE_END

TAO_NAMESPACE_TYPE (const CORBA::Long)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (const CORBA::Long, MEMB_APP_CTRL, 0)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Long)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (const CORBA::Long, MEMB_INF_CTRL, 1)
TAO_NAMESPACE_END
static const CORBA::Long _oc_PortableGroup_InitialNumberReplicasValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  57,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x702f496e), 
  ACE_NTOHL (0x69746961), 
  ACE_NTOHL (0x6c4e756d), 
  ACE_NTOHL (0x62657252), 
  ACE_NTOHL (0x65706c69), 
  ACE_NTOHL (0x63617356), 
  ACE_NTOHL (0x616c7565), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/PortableGroup/InitialNumberReplicasValue:1.0
  27,
  ACE_NTOHL (0x496e6974), 
  ACE_NTOHL (0x69616c4e), 
  ACE_NTOHL (0x756d6265), 
  ACE_NTOHL (0x72526570), 
  ACE_NTOHL (0x6c696361), 
  ACE_NTOHL (0x7356616c), 
  ACE_NTOHL (0x75650000),  // name = InitialNumberReplicasValue
  CORBA::tk_ushort,

};

static CORBA::TypeCode _tc_TAO_tc_PortableGroup_InitialNumberReplicasValue (
    CORBA::tk_alias,
    sizeof (_oc_PortableGroup_InitialNumberReplicasValue),
    (char *) &_oc_PortableGroup_InitialNumberReplicasValue,
    0,
    sizeof (PortableGroup::InitialNumberReplicasValue)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_InitialNumberReplicasValue, &_tc_TAO_tc_PortableGroup_InitialNumberReplicasValue)
TAO_NAMESPACE_END

static const CORBA::Long _oc_PortableGroup_MinimumNumberReplicasValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  57,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x702f4d69), 
  ACE_NTOHL (0x6e696d75), 
  ACE_NTOHL (0x6d4e756d), 
  ACE_NTOHL (0x62657252), 
  ACE_NTOHL (0x65706c69), 
  ACE_NTOHL (0x63617356), 
  ACE_NTOHL (0x616c7565), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/PortableGroup/MinimumNumberReplicasValue:1.0
  27,
  ACE_NTOHL (0x4d696e69), 
  ACE_NTOHL (0x6d756d4e), 
  ACE_NTOHL (0x756d6265), 
  ACE_NTOHL (0x72526570), 
  ACE_NTOHL (0x6c696361), 
  ACE_NTOHL (0x7356616c), 
  ACE_NTOHL (0x75650000),  // name = MinimumNumberReplicasValue
  CORBA::tk_ushort,

};

static CORBA::TypeCode _tc_TAO_tc_PortableGroup_MinimumNumberReplicasValue (
    CORBA::tk_alias,
    sizeof (_oc_PortableGroup_MinimumNumberReplicasValue),
    (char *) &_oc_PortableGroup_MinimumNumberReplicasValue,
    0,
    sizeof (PortableGroup::MinimumNumberReplicasValue)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_MinimumNumberReplicasValue, &_tc_TAO_tc_PortableGroup_MinimumNumberReplicasValue)
TAO_NAMESPACE_END

// Default constructor.
PortableGroup::InterfaceNotFound::InterfaceNotFound (void)
  : CORBA_UserException ("IDL:omg.org/PortableGroup/InterfaceNotFound:1.0")
{
}

// Destructor - all members are of self managing types.
PortableGroup::InterfaceNotFound::~InterfaceNotFound (void)
{
}

void PortableGroup::InterfaceNotFound::_tao_any_destructor (void *x)
{
  InterfaceNotFound *tmp = ACE_static_cast (InterfaceNotFound*,x);
  delete tmp;
}

// Copy constructor.
PortableGroup::InterfaceNotFound::InterfaceNotFound (const ::PortableGroup::InterfaceNotFound &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
}

// Assignment operator.
PortableGroup::InterfaceNotFound&
PortableGroup::InterfaceNotFound::operator= (const ::PortableGroup::InterfaceNotFound &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// Narrow.
PortableGroup::InterfaceNotFound *
PortableGroup::InterfaceNotFound::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableGroup/InterfaceNotFound:1.0", exc->_id ()))
    {
      return ACE_dynamic_cast (InterfaceNotFound *, exc);
    }
  else
    {
      return 0;
    }
}

void PortableGroup::InterfaceNotFound::_raise ()
{
  TAO_RAISE (*this);
}

void PortableGroup::InterfaceNotFound::_tao_encode (
    TAO_OutputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableGroup::InterfaceNotFound::_tao_decode (
    TAO_InputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method.
CORBA::Exception *PortableGroup::InterfaceNotFound::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableGroup::InterfaceNotFound, 0);
  return retval;
}

static const CORBA::Long _oc_PortableGroup_InterfaceNotFound[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  48,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x702f496e), 
  ACE_NTOHL (0x74657266), 
  ACE_NTOHL (0x6163654e), 
  ACE_NTOHL (0x6f74466f), 
  ACE_NTOHL (0x756e643a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/PortableGroup/InterfaceNotFound:1.0
  18,
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72666163), 
  ACE_NTOHL (0x654e6f74), 
  ACE_NTOHL (0x466f756e), 
  ACE_NTOHL (0x64000000),  // name = InterfaceNotFound
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_PortableGroup_InterfaceNotFound (
    CORBA::tk_except,
    sizeof (_oc_PortableGroup_InterfaceNotFound),
    (char *) &_oc_PortableGroup_InterfaceNotFound,
    0,
    sizeof (PortableGroup::InterfaceNotFound)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_InterfaceNotFound, &_tc_TAO_tc_PortableGroup_InterfaceNotFound)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr PortableGroup::InterfaceNotFound::_type (void) const
{
  return ::PortableGroup::_tc_InterfaceNotFound;
}

// Default constructor.
PortableGroup::ObjectGroupNotFound::ObjectGroupNotFound (void)
  : CORBA_UserException ("IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0")
{
}

// Destructor - all members are of self managing types.
PortableGroup::ObjectGroupNotFound::~ObjectGroupNotFound (void)
{
}

void PortableGroup::ObjectGroupNotFound::_tao_any_destructor (void *x)
{
  ObjectGroupNotFound *tmp = ACE_static_cast (ObjectGroupNotFound*,x);
  delete tmp;
}

// Copy constructor.
PortableGroup::ObjectGroupNotFound::ObjectGroupNotFound (const ::PortableGroup::ObjectGroupNotFound &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
}

// Assignment operator.
PortableGroup::ObjectGroupNotFound&
PortableGroup::ObjectGroupNotFound::operator= (const ::PortableGroup::ObjectGroupNotFound &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// Narrow.
PortableGroup::ObjectGroupNotFound *
PortableGroup::ObjectGroupNotFound::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0", exc->_id ()))
    {
      return ACE_dynamic_cast (ObjectGroupNotFound *, exc);
    }
  else
    {
      return 0;
    }
}

void PortableGroup::ObjectGroupNotFound::_raise ()
{
  TAO_RAISE (*this);
}

void PortableGroup::ObjectGroupNotFound::_tao_encode (
    TAO_OutputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableGroup::ObjectGroupNotFound::_tao_decode (
    TAO_InputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method.
CORBA::Exception *PortableGroup::ObjectGroupNotFound::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableGroup::ObjectGroupNotFound, 0);
  return retval;
}

static const CORBA::Long _oc_PortableGroup_ObjectGroupNotFound[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  50,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x702f4f62), 
  ACE_NTOHL (0x6a656374), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x704e6f74), 
  ACE_NTOHL (0x466f756e), 
  ACE_NTOHL (0x643a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0
  20,
  ACE_NTOHL (0x4f626a65), 
  ACE_NTOHL (0x63744772), 
  ACE_NTOHL (0x6f75704e), 
  ACE_NTOHL (0x6f74466f), 
  ACE_NTOHL (0x756e6400),  // name = ObjectGroupNotFound
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_PortableGroup_ObjectGroupNotFound (
    CORBA::tk_except,
    sizeof (_oc_PortableGroup_ObjectGroupNotFound),
    (char *) &_oc_PortableGroup_ObjectGroupNotFound,
    0,
    sizeof (PortableGroup::ObjectGroupNotFound)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ObjectGroupNotFound, &_tc_TAO_tc_PortableGroup_ObjectGroupNotFound)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr PortableGroup::ObjectGroupNotFound::_type (void) const
{
  return ::PortableGroup::_tc_ObjectGroupNotFound;
}

// Default constructor.
PortableGroup::MemberNotFound::MemberNotFound (void)
  : CORBA_UserException ("IDL:omg.org/PortableGroup/MemberNotFound:1.0")
{
}

// Destructor - all members are of self managing types.
PortableGroup::MemberNotFound::~MemberNotFound (void)
{
}

void PortableGroup::MemberNotFound::_tao_any_destructor (void *x)
{
  MemberNotFound *tmp = ACE_static_cast (MemberNotFound*,x);
  delete tmp;
}

// Copy constructor.
PortableGroup::MemberNotFound::MemberNotFound (const ::PortableGroup::MemberNotFound &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
}

// Assignment operator.
PortableGroup::MemberNotFound&
PortableGroup::MemberNotFound::operator= (const ::PortableGroup::MemberNotFound &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// Narrow.
PortableGroup::MemberNotFound *
PortableGroup::MemberNotFound::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableGroup/MemberNotFound:1.0", exc->_id ()))
    {
      return ACE_dynamic_cast (MemberNotFound *, exc);
    }
  else
    {
      return 0;
    }
}

void PortableGroup::MemberNotFound::_raise ()
{
  TAO_RAISE (*this);
}

void PortableGroup::MemberNotFound::_tao_encode (
    TAO_OutputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableGroup::MemberNotFound::_tao_decode (
    TAO_InputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method.
CORBA::Exception *PortableGroup::MemberNotFound::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableGroup::MemberNotFound, 0);
  return retval;
}

static const CORBA::Long _oc_PortableGroup_MemberNotFound[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  45,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x702f4d65), 
  ACE_NTOHL (0x6d626572), 
  ACE_NTOHL (0x4e6f7446), 
  ACE_NTOHL (0x6f756e64), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/PortableGroup/MemberNotFound:1.0
  15,
  ACE_NTOHL (0x4d656d62), 
  ACE_NTOHL (0x65724e6f), 
  ACE_NTOHL (0x74466f75), 
  ACE_NTOHL (0x6e640000),  // name = MemberNotFound
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_PortableGroup_MemberNotFound (
    CORBA::tk_except,
    sizeof (_oc_PortableGroup_MemberNotFound),
    (char *) &_oc_PortableGroup_MemberNotFound,
    0,
    sizeof (PortableGroup::MemberNotFound)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_MemberNotFound, &_tc_TAO_tc_PortableGroup_MemberNotFound)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr PortableGroup::MemberNotFound::_type (void) const
{
  return ::PortableGroup::_tc_MemberNotFound;
}

// Default constructor.
PortableGroup::ObjectNotFound::ObjectNotFound (void)
  : CORBA_UserException ("IDL:omg.org/PortableGroup/ObjectNotFound:1.0")
{
}

// Destructor - all members are of self managing types.
PortableGroup::ObjectNotFound::~ObjectNotFound (void)
{
}

void PortableGroup::ObjectNotFound::_tao_any_destructor (void *x)
{
  ObjectNotFound *tmp = ACE_static_cast (ObjectNotFound*,x);
  delete tmp;
}

// Copy constructor.
PortableGroup::ObjectNotFound::ObjectNotFound (const ::PortableGroup::ObjectNotFound &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
}

// Assignment operator.
PortableGroup::ObjectNotFound&
PortableGroup::ObjectNotFound::operator= (const ::PortableGroup::ObjectNotFound &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// Narrow.
PortableGroup::ObjectNotFound *
PortableGroup::ObjectNotFound::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableGroup/ObjectNotFound:1.0", exc->_id ()))
    {
      return ACE_dynamic_cast (ObjectNotFound *, exc);
    }
  else
    {
      return 0;
    }
}

void PortableGroup::ObjectNotFound::_raise ()
{
  TAO_RAISE (*this);
}

void PortableGroup::ObjectNotFound::_tao_encode (
    TAO_OutputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableGroup::ObjectNotFound::_tao_decode (
    TAO_InputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method.
CORBA::Exception *PortableGroup::ObjectNotFound::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableGroup::ObjectNotFound, 0);
  return retval;
}

static const CORBA::Long _oc_PortableGroup_ObjectNotFound[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  45,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x702f4f62), 
  ACE_NTOHL (0x6a656374), 
  ACE_NTOHL (0x4e6f7446), 
  ACE_NTOHL (0x6f756e64), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/PortableGroup/ObjectNotFound:1.0
  15,
  ACE_NTOHL (0x4f626a65), 
  ACE_NTOHL (0x63744e6f), 
  ACE_NTOHL (0x74466f75), 
  ACE_NTOHL (0x6e640000),  // name = ObjectNotFound
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_PortableGroup_ObjectNotFound (
    CORBA::tk_except,
    sizeof (_oc_PortableGroup_ObjectNotFound),
    (char *) &_oc_PortableGroup_ObjectNotFound,
    0,
    sizeof (PortableGroup::ObjectNotFound)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ObjectNotFound, &_tc_TAO_tc_PortableGroup_ObjectNotFound)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr PortableGroup::ObjectNotFound::_type (void) const
{
  return ::PortableGroup::_tc_ObjectNotFound;
}

// Default constructor.
PortableGroup::MemberAlreadyPresent::MemberAlreadyPresent (void)
  : CORBA_UserException ("IDL:omg.org/PortableGroup/MemberAlreadyPresent:1.0")
{
}

// Destructor - all members are of self managing types.
PortableGroup::MemberAlreadyPresent::~MemberAlreadyPresent (void)
{
}

void PortableGroup::MemberAlreadyPresent::_tao_any_destructor (void *x)
{
  MemberAlreadyPresent *tmp = ACE_static_cast (MemberAlreadyPresent*,x);
  delete tmp;
}

// Copy constructor.
PortableGroup::MemberAlreadyPresent::MemberAlreadyPresent (const ::PortableGroup::MemberAlreadyPresent &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
}

// Assignment operator.
PortableGroup::MemberAlreadyPresent&
PortableGroup::MemberAlreadyPresent::operator= (const ::PortableGroup::MemberAlreadyPresent &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// Narrow.
PortableGroup::MemberAlreadyPresent *
PortableGroup::MemberAlreadyPresent::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableGroup/MemberAlreadyPresent:1.0", exc->_id ()))
    {
      return ACE_dynamic_cast (MemberAlreadyPresent *, exc);
    }
  else
    {
      return 0;
    }
}

void PortableGroup::MemberAlreadyPresent::_raise ()
{
  TAO_RAISE (*this);
}

void PortableGroup::MemberAlreadyPresent::_tao_encode (
    TAO_OutputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableGroup::MemberAlreadyPresent::_tao_decode (
    TAO_InputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method.
CORBA::Exception *PortableGroup::MemberAlreadyPresent::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableGroup::MemberAlreadyPresent, 0);
  return retval;
}

static const CORBA::Long _oc_PortableGroup_MemberAlreadyPresent[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  51,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x702f4d65), 
  ACE_NTOHL (0x6d626572), 
  ACE_NTOHL (0x416c7265), 
  ACE_NTOHL (0x61647950), 
  ACE_NTOHL (0x72657365), 
  ACE_NTOHL (0x6e743a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableGroup/MemberAlreadyPresent:1.0
  21,
  ACE_NTOHL (0x4d656d62), 
  ACE_NTOHL (0x6572416c), 
  ACE_NTOHL (0x72656164), 
  ACE_NTOHL (0x79507265), 
  ACE_NTOHL (0x73656e74), 
  ACE_NTOHL (0x0),  // name = MemberAlreadyPresent
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_PortableGroup_MemberAlreadyPresent (
    CORBA::tk_except,
    sizeof (_oc_PortableGroup_MemberAlreadyPresent),
    (char *) &_oc_PortableGroup_MemberAlreadyPresent,
    0,
    sizeof (PortableGroup::MemberAlreadyPresent)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_MemberAlreadyPresent, &_tc_TAO_tc_PortableGroup_MemberAlreadyPresent)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr PortableGroup::MemberAlreadyPresent::_type (void) const
{
  return ::PortableGroup::_tc_MemberAlreadyPresent;
}

// Default constructor.
PortableGroup::BadReplicationStyle::BadReplicationStyle (void)
  : CORBA_UserException ("IDL:omg.org/PortableGroup/BadReplicationStyle:1.0")
{
}

// Destructor - all members are of self managing types.
PortableGroup::BadReplicationStyle::~BadReplicationStyle (void)
{
}

void PortableGroup::BadReplicationStyle::_tao_any_destructor (void *x)
{
  BadReplicationStyle *tmp = ACE_static_cast (BadReplicationStyle*,x);
  delete tmp;
}

// Copy constructor.
PortableGroup::BadReplicationStyle::BadReplicationStyle (const ::PortableGroup::BadReplicationStyle &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
}

// Assignment operator.
PortableGroup::BadReplicationStyle&
PortableGroup::BadReplicationStyle::operator= (const ::PortableGroup::BadReplicationStyle &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// Narrow.
PortableGroup::BadReplicationStyle *
PortableGroup::BadReplicationStyle::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableGroup/BadReplicationStyle:1.0", exc->_id ()))
    {
      return ACE_dynamic_cast (BadReplicationStyle *, exc);
    }
  else
    {
      return 0;
    }
}

void PortableGroup::BadReplicationStyle::_raise ()
{
  TAO_RAISE (*this);
}

void PortableGroup::BadReplicationStyle::_tao_encode (
    TAO_OutputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableGroup::BadReplicationStyle::_tao_decode (
    TAO_InputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method.
CORBA::Exception *PortableGroup::BadReplicationStyle::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableGroup::BadReplicationStyle, 0);
  return retval;
}

static const CORBA::Long _oc_PortableGroup_BadReplicationStyle[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  50,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x702f4261), 
  ACE_NTOHL (0x64526570), 
  ACE_NTOHL (0x6c696361), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x5374796c), 
  ACE_NTOHL (0x653a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/PortableGroup/BadReplicationStyle:1.0
  20,
  ACE_NTOHL (0x42616452), 
  ACE_NTOHL (0x65706c69), 
  ACE_NTOHL (0x63617469), 
  ACE_NTOHL (0x6f6e5374), 
  ACE_NTOHL (0x796c6500),  // name = BadReplicationStyle
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_PortableGroup_BadReplicationStyle (
    CORBA::tk_except,
    sizeof (_oc_PortableGroup_BadReplicationStyle),
    (char *) &_oc_PortableGroup_BadReplicationStyle,
    0,
    sizeof (PortableGroup::BadReplicationStyle)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_BadReplicationStyle, &_tc_TAO_tc_PortableGroup_BadReplicationStyle)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr PortableGroup::BadReplicationStyle::_type (void) const
{
  return ::PortableGroup::_tc_BadReplicationStyle;
}

// Default constructor.
PortableGroup::ObjectNotCreated::ObjectNotCreated (void)
  : CORBA_UserException ("IDL:omg.org/PortableGroup/ObjectNotCreated:1.0")
{
}

// Destructor - all members are of self managing types.
PortableGroup::ObjectNotCreated::~ObjectNotCreated (void)
{
}

void PortableGroup::ObjectNotCreated::_tao_any_destructor (void *x)
{
  ObjectNotCreated *tmp = ACE_static_cast (ObjectNotCreated*,x);
  delete tmp;
}

// Copy constructor.
PortableGroup::ObjectNotCreated::ObjectNotCreated (const ::PortableGroup::ObjectNotCreated &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
}

// Assignment operator.
PortableGroup::ObjectNotCreated&
PortableGroup::ObjectNotCreated::operator= (const ::PortableGroup::ObjectNotCreated &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// Narrow.
PortableGroup::ObjectNotCreated *
PortableGroup::ObjectNotCreated::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableGroup/ObjectNotCreated:1.0", exc->_id ()))
    {
      return ACE_dynamic_cast (ObjectNotCreated *, exc);
    }
  else
    {
      return 0;
    }
}

void PortableGroup::ObjectNotCreated::_raise ()
{
  TAO_RAISE (*this);
}

void PortableGroup::ObjectNotCreated::_tao_encode (
    TAO_OutputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableGroup::ObjectNotCreated::_tao_decode (
    TAO_InputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method.
CORBA::Exception *PortableGroup::ObjectNotCreated::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableGroup::ObjectNotCreated, 0);
  return retval;
}

static const CORBA::Long _oc_PortableGroup_ObjectNotCreated[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  47,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x702f4f62), 
  ACE_NTOHL (0x6a656374), 
  ACE_NTOHL (0x4e6f7443), 
  ACE_NTOHL (0x72656174), 
  ACE_NTOHL (0x65643a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableGroup/ObjectNotCreated:1.0
  17,
  ACE_NTOHL (0x4f626a65), 
  ACE_NTOHL (0x63744e6f), 
  ACE_NTOHL (0x74437265), 
  ACE_NTOHL (0x61746564), 
  ACE_NTOHL (0x0),  // name = ObjectNotCreated
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_PortableGroup_ObjectNotCreated (
    CORBA::tk_except,
    sizeof (_oc_PortableGroup_ObjectNotCreated),
    (char *) &_oc_PortableGroup_ObjectNotCreated,
    0,
    sizeof (PortableGroup::ObjectNotCreated)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ObjectNotCreated, &_tc_TAO_tc_PortableGroup_ObjectNotCreated)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr PortableGroup::ObjectNotCreated::_type (void) const
{
  return ::PortableGroup::_tc_ObjectNotCreated;
}

// Default constructor.
PortableGroup::ObjectNotAdded::ObjectNotAdded (void)
  : CORBA_UserException ("IDL:omg.org/PortableGroup/ObjectNotAdded:1.0")
{
}

// Destructor - all members are of self managing types.
PortableGroup::ObjectNotAdded::~ObjectNotAdded (void)
{
}

void PortableGroup::ObjectNotAdded::_tao_any_destructor (void *x)
{
  ObjectNotAdded *tmp = ACE_static_cast (ObjectNotAdded*,x);
  delete tmp;
}

// Copy constructor.
PortableGroup::ObjectNotAdded::ObjectNotAdded (const ::PortableGroup::ObjectNotAdded &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
}

// Assignment operator.
PortableGroup::ObjectNotAdded&
PortableGroup::ObjectNotAdded::operator= (const ::PortableGroup::ObjectNotAdded &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// Narrow.
PortableGroup::ObjectNotAdded *
PortableGroup::ObjectNotAdded::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableGroup/ObjectNotAdded:1.0", exc->_id ()))
    {
      return ACE_dynamic_cast (ObjectNotAdded *, exc);
    }
  else
    {
      return 0;
    }
}

void PortableGroup::ObjectNotAdded::_raise ()
{
  TAO_RAISE (*this);
}

void PortableGroup::ObjectNotAdded::_tao_encode (
    TAO_OutputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableGroup::ObjectNotAdded::_tao_decode (
    TAO_InputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method.
CORBA::Exception *PortableGroup::ObjectNotAdded::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableGroup::ObjectNotAdded, 0);
  return retval;
}

static const CORBA::Long _oc_PortableGroup_ObjectNotAdded[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  45,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x702f4f62), 
  ACE_NTOHL (0x6a656374), 
  ACE_NTOHL (0x4e6f7441), 
  ACE_NTOHL (0x64646564), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/PortableGroup/ObjectNotAdded:1.0
  15,
  ACE_NTOHL (0x4f626a65), 
  ACE_NTOHL (0x63744e6f), 
  ACE_NTOHL (0x74416464), 
  ACE_NTOHL (0x65640000),  // name = ObjectNotAdded
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_PortableGroup_ObjectNotAdded (
    CORBA::tk_except,
    sizeof (_oc_PortableGroup_ObjectNotAdded),
    (char *) &_oc_PortableGroup_ObjectNotAdded,
    0,
    sizeof (PortableGroup::ObjectNotAdded)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ObjectNotAdded, &_tc_TAO_tc_PortableGroup_ObjectNotAdded)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr PortableGroup::ObjectNotAdded::_type (void) const
{
  return ::PortableGroup::_tc_ObjectNotAdded;
}

// Default constructor.
PortableGroup::UnsupportedProperty::UnsupportedProperty (void)
  : CORBA_UserException ("IDL:omg.org/PortableGroup/UnsupportedProperty:1.0")
{
}

// Destructor - all members are of self managing types.
PortableGroup::UnsupportedProperty::~UnsupportedProperty (void)
{
}

void PortableGroup::UnsupportedProperty::_tao_any_destructor (void *x)
{
  UnsupportedProperty *tmp = ACE_static_cast (UnsupportedProperty*,x);
  delete tmp;
}

// Copy constructor.
PortableGroup::UnsupportedProperty::UnsupportedProperty (const ::PortableGroup::UnsupportedProperty &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
  this->nam = _tao_excp.nam;
}

// Assignment operator.
PortableGroup::UnsupportedProperty&
PortableGroup::UnsupportedProperty::operator= (const ::PortableGroup::UnsupportedProperty &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  this->nam = _tao_excp.nam;
  return *this;
}

// Narrow.
PortableGroup::UnsupportedProperty *
PortableGroup::UnsupportedProperty::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableGroup/UnsupportedProperty:1.0", exc->_id ()))
    {
      return ACE_dynamic_cast (UnsupportedProperty *, exc);
    }
  else
    {
      return 0;
    }
}

void PortableGroup::UnsupportedProperty::_raise ()
{
  TAO_RAISE (*this);
}

void PortableGroup::UnsupportedProperty::_tao_encode (
    TAO_OutputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableGroup::UnsupportedProperty::_tao_decode (
    TAO_InputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method.
CORBA::Exception *PortableGroup::UnsupportedProperty::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableGroup::UnsupportedProperty, 0);
  return retval;
}

PortableGroup::UnsupportedProperty::UnsupportedProperty (
    const PortableGroup::Name & _tao_nam
  )
  : CORBA_UserException ("IDL:omg.org/PortableGroup/UnsupportedProperty:1.0")
{
  this->nam = _tao_nam;
}

static const CORBA::Long _oc_PortableGroup_UnsupportedProperty[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  50,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x702f556e), 
  ACE_NTOHL (0x73757070), 
  ACE_NTOHL (0x6f727465), 
  ACE_NTOHL (0x6450726f), 
  ACE_NTOHL (0x70657274), 
  ACE_NTOHL (0x793a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/PortableGroup/UnsupportedProperty:1.0
  20,
  ACE_NTOHL (0x556e7375), 
  ACE_NTOHL (0x70706f72), 
  ACE_NTOHL (0x74656450), 
  ACE_NTOHL (0x726f7065), 
  ACE_NTOHL (0x72747900),  // name = UnsupportedProperty
  1, // member count
  4,
  ACE_NTOHL (0x6e616d00),  // name = nam
  CORBA::tk_alias, // typecode kind for typedefs
  376, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x506f7274), 
    ACE_NTOHL (0x61626c65), 
    ACE_NTOHL (0x47726f75), 
    ACE_NTOHL (0x702f4e61), 
    ACE_NTOHL (0x6d653a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableGroup/Name:1.0
    5,
    ACE_NTOHL (0x4e616d65), 
    ACE_NTOHL (0x0),  // name = Name
    CORBA::tk_alias, // typecode kind for typedefs
    312, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      31,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f734e), 
      ACE_NTOHL (0x616d696e), 
      ACE_NTOHL (0x672f4e61), 
      ACE_NTOHL (0x6d653a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CosNaming/Name:1.0
      5,
      ACE_NTOHL (0x4e616d65), 
      ACE_NTOHL (0x0),  // name = Name
      CORBA::tk_sequence, // typecode kind
      252, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        CORBA::tk_struct, // typecode kind
        236, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          40,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f734e), 
          ACE_NTOHL (0x616d696e), 
          ACE_NTOHL (0x672f4e61), 
          ACE_NTOHL (0x6d65436f), 
          ACE_NTOHL (0x6d706f6e), 
          ACE_NTOHL (0x656e743a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CosNaming/NameComponent:1.0
          14,
          ACE_NTOHL (0x4e616d65), 
          ACE_NTOHL (0x436f6d70), 
          ACE_NTOHL (0x6f6e656e), 
          ACE_NTOHL (0x74000000),  // name = NameComponent
          2, // member count
          3,
          ACE_NTOHL (0x69640000),  // name = id
          CORBA::tk_alias, // typecode kind for typedefs
          64, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            34,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x6f6d672e), 
            ACE_NTOHL (0x6f72672f), 
            ACE_NTOHL (0x436f734e), 
            ACE_NTOHL (0x616d696e), 
            ACE_NTOHL (0x672f4973), 
            ACE_NTOHL (0x7472696e), 
            ACE_NTOHL (0x673a312e), 
            ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CosNaming/Istring:1.0
            8,
            ACE_NTOHL (0x49737472), 
            ACE_NTOHL (0x696e6700),  // name = Istring
            CORBA::tk_string, 
            0U, // string length

          5,
          ACE_NTOHL (0x6b696e64), 
          ACE_NTOHL (0x0),  // name = kind
          CORBA::tk_alias, // typecode kind for typedefs
          64, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            34,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x6f6d672e), 
            ACE_NTOHL (0x6f72672f), 
            ACE_NTOHL (0x436f734e), 
            ACE_NTOHL (0x616d696e), 
            ACE_NTOHL (0x672f4973), 
            ACE_NTOHL (0x7472696e), 
            ACE_NTOHL (0x673a312e), 
            ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CosNaming/Istring:1.0
            8,
            ACE_NTOHL (0x49737472), 
            ACE_NTOHL (0x696e6700),  // name = Istring
            CORBA::tk_string, 
            0U, // string length


        0U,



};

static CORBA::TypeCode _tc_TAO_tc_PortableGroup_UnsupportedProperty (
    CORBA::tk_except,
    sizeof (_oc_PortableGroup_UnsupportedProperty),
    (char *) &_oc_PortableGroup_UnsupportedProperty,
    0,
    sizeof (PortableGroup::UnsupportedProperty)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UnsupportedProperty, &_tc_TAO_tc_PortableGroup_UnsupportedProperty)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr PortableGroup::UnsupportedProperty::_type (void) const
{
  return ::PortableGroup::_tc_UnsupportedProperty;
}

// Default constructor.
PortableGroup::InvalidProperty::InvalidProperty (void)
  : CORBA_UserException ("IDL:omg.org/PortableGroup/InvalidProperty:1.0")
{
}

// Destructor - all members are of self managing types.
PortableGroup::InvalidProperty::~InvalidProperty (void)
{
}

void PortableGroup::InvalidProperty::_tao_any_destructor (void *x)
{
  InvalidProperty *tmp = ACE_static_cast (InvalidProperty*,x);
  delete tmp;
}

// Copy constructor.
PortableGroup::InvalidProperty::InvalidProperty (const ::PortableGroup::InvalidProperty &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
  this->nam = _tao_excp.nam;
  this->val = _tao_excp.val;
}

// Assignment operator.
PortableGroup::InvalidProperty&
PortableGroup::InvalidProperty::operator= (const ::PortableGroup::InvalidProperty &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  this->nam = _tao_excp.nam;
  this->val = _tao_excp.val;
  return *this;
}

// Narrow.
PortableGroup::InvalidProperty *
PortableGroup::InvalidProperty::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableGroup/InvalidProperty:1.0", exc->_id ()))
    {
      return ACE_dynamic_cast (InvalidProperty *, exc);
    }
  else
    {
      return 0;
    }
}

void PortableGroup::InvalidProperty::_raise ()
{
  TAO_RAISE (*this);
}

void PortableGroup::InvalidProperty::_tao_encode (
    TAO_OutputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableGroup::InvalidProperty::_tao_decode (
    TAO_InputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method.
CORBA::Exception *PortableGroup::InvalidProperty::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableGroup::InvalidProperty, 0);
  return retval;
}

PortableGroup::InvalidProperty::InvalidProperty (
    const PortableGroup::Name & _tao_nam,
    const PortableGroup::Value & _tao_val
  )
  : CORBA_UserException ("IDL:omg.org/PortableGroup/InvalidProperty:1.0")
{
  this->nam = _tao_nam;
  this->val = _tao_val;
}

static const CORBA::Long _oc_PortableGroup_InvalidProperty[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  46,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x702f496e), 
  ACE_NTOHL (0x76616c69), 
  ACE_NTOHL (0x6450726f), 
  ACE_NTOHL (0x70657274), 
  ACE_NTOHL (0x793a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/PortableGroup/InvalidProperty:1.0
  16,
  ACE_NTOHL (0x496e7661), 
  ACE_NTOHL (0x6c696450), 
  ACE_NTOHL (0x726f7065), 
  ACE_NTOHL (0x72747900),  // name = InvalidProperty
  2, // member count
  4,
  ACE_NTOHL (0x6e616d00),  // name = nam
  CORBA::tk_alias, // typecode kind for typedefs
  376, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x506f7274), 
    ACE_NTOHL (0x61626c65), 
    ACE_NTOHL (0x47726f75), 
    ACE_NTOHL (0x702f4e61), 
    ACE_NTOHL (0x6d653a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableGroup/Name:1.0
    5,
    ACE_NTOHL (0x4e616d65), 
    ACE_NTOHL (0x0),  // name = Name
    CORBA::tk_alias, // typecode kind for typedefs
    312, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      31,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f734e), 
      ACE_NTOHL (0x616d696e), 
      ACE_NTOHL (0x672f4e61), 
      ACE_NTOHL (0x6d653a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CosNaming/Name:1.0
      5,
      ACE_NTOHL (0x4e616d65), 
      ACE_NTOHL (0x0),  // name = Name
      CORBA::tk_sequence, // typecode kind
      252, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        CORBA::tk_struct, // typecode kind
        236, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          40,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f734e), 
          ACE_NTOHL (0x616d696e), 
          ACE_NTOHL (0x672f4e61), 
          ACE_NTOHL (0x6d65436f), 
          ACE_NTOHL (0x6d706f6e), 
          ACE_NTOHL (0x656e743a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CosNaming/NameComponent:1.0
          14,
          ACE_NTOHL (0x4e616d65), 
          ACE_NTOHL (0x436f6d70), 
          ACE_NTOHL (0x6f6e656e), 
          ACE_NTOHL (0x74000000),  // name = NameComponent
          2, // member count
          3,
          ACE_NTOHL (0x69640000),  // name = id
          CORBA::tk_alias, // typecode kind for typedefs
          64, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            34,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x6f6d672e), 
            ACE_NTOHL (0x6f72672f), 
            ACE_NTOHL (0x436f734e), 
            ACE_NTOHL (0x616d696e), 
            ACE_NTOHL (0x672f4973), 
            ACE_NTOHL (0x7472696e), 
            ACE_NTOHL (0x673a312e), 
            ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CosNaming/Istring:1.0
            8,
            ACE_NTOHL (0x49737472), 
            ACE_NTOHL (0x696e6700),  // name = Istring
            CORBA::tk_string, 
            0U, // string length

          5,
          ACE_NTOHL (0x6b696e64), 
          ACE_NTOHL (0x0),  // name = kind
          CORBA::tk_alias, // typecode kind for typedefs
          64, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            34,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x6f6d672e), 
            ACE_NTOHL (0x6f72672f), 
            ACE_NTOHL (0x436f734e), 
            ACE_NTOHL (0x616d696e), 
            ACE_NTOHL (0x672f4973), 
            ACE_NTOHL (0x7472696e), 
            ACE_NTOHL (0x673a312e), 
            ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CosNaming/Istring:1.0
            8,
            ACE_NTOHL (0x49737472), 
            ACE_NTOHL (0x696e6700),  // name = Istring
            CORBA::tk_string, 
            0U, // string length


        0U,



  4,
  ACE_NTOHL (0x76616c00),  // name = val
  CORBA::tk_alias, // typecode kind for typedefs
  60, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    36,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x506f7274), 
    ACE_NTOHL (0x61626c65), 
    ACE_NTOHL (0x47726f75), 
    ACE_NTOHL (0x702f5661), 
    ACE_NTOHL (0x6c75653a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/PortableGroup/Value:1.0
    6,
    ACE_NTOHL (0x56616c75), 
    ACE_NTOHL (0x65000000),  // name = Value
    CORBA::tk_any,


};

static CORBA::TypeCode _tc_TAO_tc_PortableGroup_InvalidProperty (
    CORBA::tk_except,
    sizeof (_oc_PortableGroup_InvalidProperty),
    (char *) &_oc_PortableGroup_InvalidProperty,
    0,
    sizeof (PortableGroup::InvalidProperty)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_InvalidProperty, &_tc_TAO_tc_PortableGroup_InvalidProperty)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr PortableGroup::InvalidProperty::_type (void) const
{
  return ::PortableGroup::_tc_InvalidProperty;
}

// Default constructor.
PortableGroup::NoFactory::NoFactory (void)
  : CORBA_UserException ("IDL:omg.org/PortableGroup/NoFactory:1.0")
{
}

// Destructor - all members are of self managing types.
PortableGroup::NoFactory::~NoFactory (void)
{
}

void PortableGroup::NoFactory::_tao_any_destructor (void *x)
{
  NoFactory *tmp = ACE_static_cast (NoFactory*,x);
  delete tmp;
}

// Copy constructor.
PortableGroup::NoFactory::NoFactory (const ::PortableGroup::NoFactory &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
  this->the_location = _tao_excp.the_location;
  this->type_id = CORBA::string_dup (_tao_excp.type_id.in ());
}

// Assignment operator.
PortableGroup::NoFactory&
PortableGroup::NoFactory::operator= (const ::PortableGroup::NoFactory &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  this->the_location = _tao_excp.the_location;
  this->type_id = CORBA::string_dup (_tao_excp.type_id.in ());
  return *this;
}

// Narrow.
PortableGroup::NoFactory *
PortableGroup::NoFactory::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableGroup/NoFactory:1.0", exc->_id ()))
    {
      return ACE_dynamic_cast (NoFactory *, exc);
    }
  else
    {
      return 0;
    }
}

void PortableGroup::NoFactory::_raise ()
{
  TAO_RAISE (*this);
}

void PortableGroup::NoFactory::_tao_encode (
    TAO_OutputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableGroup::NoFactory::_tao_decode (
    TAO_InputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method.
CORBA::Exception *PortableGroup::NoFactory::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableGroup::NoFactory, 0);
  return retval;
}

PortableGroup::NoFactory::NoFactory (
    const PortableGroup::Location & _tao_the_location,
    const char * _tao_type_id
  )
  : CORBA_UserException ("IDL:omg.org/PortableGroup/NoFactory:1.0")
{
  this->the_location = _tao_the_location;
  this->type_id = CORBA::string_dup (_tao_type_id);
}

static const CORBA::Long _oc_PortableGroup_NoFactory[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x702f4e6f), 
  ACE_NTOHL (0x46616374), 
  ACE_NTOHL (0x6f72793a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/PortableGroup/NoFactory:1.0
  10,
  ACE_NTOHL (0x4e6f4661), 
  ACE_NTOHL (0x63746f72), 
  ACE_NTOHL (0x79000000),  // name = NoFactory
  2, // member count
  13,
  ACE_NTOHL (0x7468655f), 
  ACE_NTOHL (0x6c6f6361), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x0),  // name = the_location
  CORBA::tk_alias, // typecode kind for typedefs
  448, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    39,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x506f7274), 
    ACE_NTOHL (0x61626c65), 
    ACE_NTOHL (0x47726f75), 
    ACE_NTOHL (0x702f4c6f), 
    ACE_NTOHL (0x63617469), 
    ACE_NTOHL (0x6f6e3a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableGroup/Location:1.0
    9,
    ACE_NTOHL (0x4c6f6361), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x0),  // name = Location
    CORBA::tk_alias, // typecode kind for typedefs
    376, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x506f7274), 
      ACE_NTOHL (0x61626c65), 
      ACE_NTOHL (0x47726f75), 
      ACE_NTOHL (0x702f4e61), 
      ACE_NTOHL (0x6d653a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableGroup/Name:1.0
      5,
      ACE_NTOHL (0x4e616d65), 
      ACE_NTOHL (0x0),  // name = Name
      CORBA::tk_alias, // typecode kind for typedefs
      312, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f734e), 
        ACE_NTOHL (0x616d696e), 
        ACE_NTOHL (0x672f4e61), 
        ACE_NTOHL (0x6d653a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CosNaming/Name:1.0
        5,
        ACE_NTOHL (0x4e616d65), 
        ACE_NTOHL (0x0),  // name = Name
        CORBA::tk_sequence, // typecode kind
        252, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          236, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            40,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x6f6d672e), 
            ACE_NTOHL (0x6f72672f), 
            ACE_NTOHL (0x436f734e), 
            ACE_NTOHL (0x616d696e), 
            ACE_NTOHL (0x672f4e61), 
            ACE_NTOHL (0x6d65436f), 
            ACE_NTOHL (0x6d706f6e), 
            ACE_NTOHL (0x656e743a), 
            ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CosNaming/NameComponent:1.0
            14,
            ACE_NTOHL (0x4e616d65), 
            ACE_NTOHL (0x436f6d70), 
            ACE_NTOHL (0x6f6e656e), 
            ACE_NTOHL (0x74000000),  // name = NameComponent
            2, // member count
            3,
            ACE_NTOHL (0x69640000),  // name = id
            CORBA::tk_alias, // typecode kind for typedefs
            64, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              34,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x436f734e), 
              ACE_NTOHL (0x616d696e), 
              ACE_NTOHL (0x672f4973), 
              ACE_NTOHL (0x7472696e), 
              ACE_NTOHL (0x673a312e), 
              ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CosNaming/Istring:1.0
              8,
              ACE_NTOHL (0x49737472), 
              ACE_NTOHL (0x696e6700),  // name = Istring
              CORBA::tk_string, 
              0U, // string length

            5,
            ACE_NTOHL (0x6b696e64), 
            ACE_NTOHL (0x0),  // name = kind
            CORBA::tk_alias, // typecode kind for typedefs
            64, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              34,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x436f734e), 
              ACE_NTOHL (0x616d696e), 
              ACE_NTOHL (0x672f4973), 
              ACE_NTOHL (0x7472696e), 
              ACE_NTOHL (0x673a312e), 
              ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CosNaming/Istring:1.0
              8,
              ACE_NTOHL (0x49737472), 
              ACE_NTOHL (0x696e6700),  // name = Istring
              CORBA::tk_string, 
              0U, // string length


          0U,




  8,
  ACE_NTOHL (0x74797065), 
  ACE_NTOHL (0x5f696400),  // name = type_id
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    37,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x506f7274), 
    ACE_NTOHL (0x61626c65), 
    ACE_NTOHL (0x47726f75), 
    ACE_NTOHL (0x702f5479), 
    ACE_NTOHL (0x70654964), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/PortableGroup/TypeId:1.0
    7,
    ACE_NTOHL (0x54797065), 
    ACE_NTOHL (0x49640000),  // name = TypeId
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f5265), 
      ACE_NTOHL (0x706f7369), 
      ACE_NTOHL (0x746f7279), 
      ACE_NTOHL (0x49643a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13,
      ACE_NTOHL (0x5265706f), 
      ACE_NTOHL (0x7369746f), 
      ACE_NTOHL (0x72794964), 
      ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length


};

static CORBA::TypeCode _tc_TAO_tc_PortableGroup_NoFactory (
    CORBA::tk_except,
    sizeof (_oc_PortableGroup_NoFactory),
    (char *) &_oc_PortableGroup_NoFactory,
    0,
    sizeof (PortableGroup::NoFactory)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_NoFactory, &_tc_TAO_tc_PortableGroup_NoFactory)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr PortableGroup::NoFactory::_type (void) const
{
  return ::PortableGroup::_tc_NoFactory;
}

// Default constructor.
PortableGroup::InvalidCriteria::InvalidCriteria (void)
  : CORBA_UserException ("IDL:omg.org/PortableGroup/InvalidCriteria:1.0")
{
}

// Destructor - all members are of self managing types.
PortableGroup::InvalidCriteria::~InvalidCriteria (void)
{
}

void PortableGroup::InvalidCriteria::_tao_any_destructor (void *x)
{
  InvalidCriteria *tmp = ACE_static_cast (InvalidCriteria*,x);
  delete tmp;
}

// Copy constructor.
PortableGroup::InvalidCriteria::InvalidCriteria (const ::PortableGroup::InvalidCriteria &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
  this->invalid_criteria = _tao_excp.invalid_criteria;
}

// Assignment operator.
PortableGroup::InvalidCriteria&
PortableGroup::InvalidCriteria::operator= (const ::PortableGroup::InvalidCriteria &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  this->invalid_criteria = _tao_excp.invalid_criteria;
  return *this;
}

// Narrow.
PortableGroup::InvalidCriteria *
PortableGroup::InvalidCriteria::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableGroup/InvalidCriteria:1.0", exc->_id ()))
    {
      return ACE_dynamic_cast (InvalidCriteria *, exc);
    }
  else
    {
      return 0;
    }
}

void PortableGroup::InvalidCriteria::_raise ()
{
  TAO_RAISE (*this);
}

void PortableGroup::InvalidCriteria::_tao_encode (
    TAO_OutputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableGroup::InvalidCriteria::_tao_decode (
    TAO_InputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method.
CORBA::Exception *PortableGroup::InvalidCriteria::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableGroup::InvalidCriteria, 0);
  return retval;
}

PortableGroup::InvalidCriteria::InvalidCriteria (
    const PortableGroup::Criteria & _tao_invalid_criteria
  )
  : CORBA_UserException ("IDL:omg.org/PortableGroup/InvalidCriteria:1.0")
{
  this->invalid_criteria = _tao_invalid_criteria;
}

static const CORBA::Long _oc_PortableGroup_InvalidCriteria[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  46,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x702f496e), 
  ACE_NTOHL (0x76616c69), 
  ACE_NTOHL (0x64437269), 
  ACE_NTOHL (0x74657269), 
  ACE_NTOHL (0x613a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/PortableGroup/InvalidCriteria:1.0
  16,
  ACE_NTOHL (0x496e7661), 
  ACE_NTOHL (0x6c696443), 
  ACE_NTOHL (0x72697465), 
  ACE_NTOHL (0x72696100),  // name = InvalidCriteria
  1, // member count
  17,
  ACE_NTOHL (0x696e7661), 
  ACE_NTOHL (0x6c69645f), 
  ACE_NTOHL (0x63726974), 
  ACE_NTOHL (0x65726961), 
  ACE_NTOHL (0x0),  // name = invalid_criteria
  CORBA::tk_alias, // typecode kind for typedefs
  700, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    39,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x506f7274), 
    ACE_NTOHL (0x61626c65), 
    ACE_NTOHL (0x47726f75), 
    ACE_NTOHL (0x702f4372), 
    ACE_NTOHL (0x69746572), 
    ACE_NTOHL (0x69613a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableGroup/Criteria:1.0
    9,
    ACE_NTOHL (0x43726974), 
    ACE_NTOHL (0x65726961), 
    ACE_NTOHL (0x0),  // name = Criteria
    CORBA::tk_alias, // typecode kind for typedefs
    628, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      41,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x506f7274), 
      ACE_NTOHL (0x61626c65), 
      ACE_NTOHL (0x47726f75), 
      ACE_NTOHL (0x702f5072), 
      ACE_NTOHL (0x6f706572), 
      ACE_NTOHL (0x74696573), 
      ACE_NTOHL (0x3a312e30), 
      ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/PortableGroup/Properties:1.0
      11,
      ACE_NTOHL (0x50726f70), 
      ACE_NTOHL (0x65727469), 
      ACE_NTOHL (0x65730000),  // name = Properties
      CORBA::tk_sequence, // typecode kind
      552, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        CORBA::tk_struct, // typecode kind
        536, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          39,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x506f7274), 
          ACE_NTOHL (0x61626c65), 
          ACE_NTOHL (0x47726f75), 
          ACE_NTOHL (0x702f5072), 
          ACE_NTOHL (0x6f706572), 
          ACE_NTOHL (0x74793a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableGroup/Property:1.0
          9,
          ACE_NTOHL (0x50726f70), 
          ACE_NTOHL (0x65727479), 
          ACE_NTOHL (0x0),  // name = Property
          2, // member count
          4,
          ACE_NTOHL (0x6e616d00),  // name = nam
          CORBA::tk_alias, // typecode kind for typedefs
          376, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            35,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x6f6d672e), 
            ACE_NTOHL (0x6f72672f), 
            ACE_NTOHL (0x506f7274), 
            ACE_NTOHL (0x61626c65), 
            ACE_NTOHL (0x47726f75), 
            ACE_NTOHL (0x702f4e61), 
            ACE_NTOHL (0x6d653a31), 
            ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableGroup/Name:1.0
            5,
            ACE_NTOHL (0x4e616d65), 
            ACE_NTOHL (0x0),  // name = Name
            CORBA::tk_alias, // typecode kind for typedefs
            312, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              31,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x436f734e), 
              ACE_NTOHL (0x616d696e), 
              ACE_NTOHL (0x672f4e61), 
              ACE_NTOHL (0x6d653a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CosNaming/Name:1.0
              5,
              ACE_NTOHL (0x4e616d65), 
              ACE_NTOHL (0x0),  // name = Name
              CORBA::tk_sequence, // typecode kind
              252, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                CORBA::tk_struct, // typecode kind
                236, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  40,
                  ACE_NTOHL (0x49444c3a), 
                  ACE_NTOHL (0x6f6d672e), 
                  ACE_NTOHL (0x6f72672f), 
                  ACE_NTOHL (0x436f734e), 
                  ACE_NTOHL (0x616d696e), 
                  ACE_NTOHL (0x672f4e61), 
                  ACE_NTOHL (0x6d65436f), 
                  ACE_NTOHL (0x6d706f6e), 
                  ACE_NTOHL (0x656e743a), 
                  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CosNaming/NameComponent:1.0
                  14,
                  ACE_NTOHL (0x4e616d65), 
                  ACE_NTOHL (0x436f6d70), 
                  ACE_NTOHL (0x6f6e656e), 
                  ACE_NTOHL (0x74000000),  // name = NameComponent
                  2, // member count
                  3,
                  ACE_NTOHL (0x69640000),  // name = id
                  CORBA::tk_alias, // typecode kind for typedefs
                  64, // encapsulation length
                    TAO_ENCAP_BYTE_ORDER, // byte order
                    34,
                    ACE_NTOHL (0x49444c3a), 
                    ACE_NTOHL (0x6f6d672e), 
                    ACE_NTOHL (0x6f72672f), 
                    ACE_NTOHL (0x436f734e), 
                    ACE_NTOHL (0x616d696e), 
                    ACE_NTOHL (0x672f4973), 
                    ACE_NTOHL (0x7472696e), 
                    ACE_NTOHL (0x673a312e), 
                    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CosNaming/Istring:1.0
                    8,
                    ACE_NTOHL (0x49737472), 
                    ACE_NTOHL (0x696e6700),  // name = Istring
                    CORBA::tk_string, 
                    0U, // string length

                  5,
                  ACE_NTOHL (0x6b696e64), 
                  ACE_NTOHL (0x0),  // name = kind
                  CORBA::tk_alias, // typecode kind for typedefs
                  64, // encapsulation length
                    TAO_ENCAP_BYTE_ORDER, // byte order
                    34,
                    ACE_NTOHL (0x49444c3a), 
                    ACE_NTOHL (0x6f6d672e), 
                    ACE_NTOHL (0x6f72672f), 
                    ACE_NTOHL (0x436f734e), 
                    ACE_NTOHL (0x616d696e), 
                    ACE_NTOHL (0x672f4973), 
                    ACE_NTOHL (0x7472696e), 
                    ACE_NTOHL (0x673a312e), 
                    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CosNaming/Istring:1.0
                    8,
                    ACE_NTOHL (0x49737472), 
                    ACE_NTOHL (0x696e6700),  // name = Istring
                    CORBA::tk_string, 
                    0U, // string length


                0U,



          4,
          ACE_NTOHL (0x76616c00),  // name = val
          CORBA::tk_alias, // typecode kind for typedefs
          60, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            36,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x6f6d672e), 
            ACE_NTOHL (0x6f72672f), 
            ACE_NTOHL (0x506f7274), 
            ACE_NTOHL (0x61626c65), 
            ACE_NTOHL (0x47726f75), 
            ACE_NTOHL (0x702f5661), 
            ACE_NTOHL (0x6c75653a), 
            ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/PortableGroup/Value:1.0
            6,
            ACE_NTOHL (0x56616c75), 
            ACE_NTOHL (0x65000000),  // name = Value
            CORBA::tk_any,



        0U,



};

static CORBA::TypeCode _tc_TAO_tc_PortableGroup_InvalidCriteria (
    CORBA::tk_except,
    sizeof (_oc_PortableGroup_InvalidCriteria),
    (char *) &_oc_PortableGroup_InvalidCriteria,
    0,
    sizeof (PortableGroup::InvalidCriteria)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_InvalidCriteria, &_tc_TAO_tc_PortableGroup_InvalidCriteria)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr PortableGroup::InvalidCriteria::_type (void) const
{
  return ::PortableGroup::_tc_InvalidCriteria;
}

// Default constructor.
PortableGroup::CannotMeetCriteria::CannotMeetCriteria (void)
  : CORBA_UserException ("IDL:omg.org/PortableGroup/CannotMeetCriteria:1.0")
{
}

// Destructor - all members are of self managing types.
PortableGroup::CannotMeetCriteria::~CannotMeetCriteria (void)
{
}

void PortableGroup::CannotMeetCriteria::_tao_any_destructor (void *x)
{
  CannotMeetCriteria *tmp = ACE_static_cast (CannotMeetCriteria*,x);
  delete tmp;
}

// Copy constructor.
PortableGroup::CannotMeetCriteria::CannotMeetCriteria (const ::PortableGroup::CannotMeetCriteria &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
  this->unmet_criteria = _tao_excp.unmet_criteria;
}

// Assignment operator.
PortableGroup::CannotMeetCriteria&
PortableGroup::CannotMeetCriteria::operator= (const ::PortableGroup::CannotMeetCriteria &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  this->unmet_criteria = _tao_excp.unmet_criteria;
  return *this;
}

// Narrow.
PortableGroup::CannotMeetCriteria *
PortableGroup::CannotMeetCriteria::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableGroup/CannotMeetCriteria:1.0", exc->_id ()))
    {
      return ACE_dynamic_cast (CannotMeetCriteria *, exc);
    }
  else
    {
      return 0;
    }
}

void PortableGroup::CannotMeetCriteria::_raise ()
{
  TAO_RAISE (*this);
}

void PortableGroup::CannotMeetCriteria::_tao_encode (
    TAO_OutputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableGroup::CannotMeetCriteria::_tao_decode (
    TAO_InputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method.
CORBA::Exception *PortableGroup::CannotMeetCriteria::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableGroup::CannotMeetCriteria, 0);
  return retval;
}

PortableGroup::CannotMeetCriteria::CannotMeetCriteria (
    const PortableGroup::Criteria & _tao_unmet_criteria
  )
  : CORBA_UserException ("IDL:omg.org/PortableGroup/CannotMeetCriteria:1.0")
{
  this->unmet_criteria = _tao_unmet_criteria;
}

static const CORBA::Long _oc_PortableGroup_CannotMeetCriteria[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  49,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x702f4361), 
  ACE_NTOHL (0x6e6e6f74), 
  ACE_NTOHL (0x4d656574), 
  ACE_NTOHL (0x43726974), 
  ACE_NTOHL (0x65726961), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/PortableGroup/CannotMeetCriteria:1.0
  19,
  ACE_NTOHL (0x43616e6e), 
  ACE_NTOHL (0x6f744d65), 
  ACE_NTOHL (0x65744372), 
  ACE_NTOHL (0x69746572), 
  ACE_NTOHL (0x69610000),  // name = CannotMeetCriteria
  1, // member count
  15,
  ACE_NTOHL (0x756e6d65), 
  ACE_NTOHL (0x745f6372), 
  ACE_NTOHL (0x69746572), 
  ACE_NTOHL (0x69610000),  // name = unmet_criteria
  CORBA::tk_alias, // typecode kind for typedefs
  700, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    39,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x506f7274), 
    ACE_NTOHL (0x61626c65), 
    ACE_NTOHL (0x47726f75), 
    ACE_NTOHL (0x702f4372), 
    ACE_NTOHL (0x69746572), 
    ACE_NTOHL (0x69613a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableGroup/Criteria:1.0
    9,
    ACE_NTOHL (0x43726974), 
    ACE_NTOHL (0x65726961), 
    ACE_NTOHL (0x0),  // name = Criteria
    CORBA::tk_alias, // typecode kind for typedefs
    628, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      41,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x506f7274), 
      ACE_NTOHL (0x61626c65), 
      ACE_NTOHL (0x47726f75), 
      ACE_NTOHL (0x702f5072), 
      ACE_NTOHL (0x6f706572), 
      ACE_NTOHL (0x74696573), 
      ACE_NTOHL (0x3a312e30), 
      ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/PortableGroup/Properties:1.0
      11,
      ACE_NTOHL (0x50726f70), 
      ACE_NTOHL (0x65727469), 
      ACE_NTOHL (0x65730000),  // name = Properties
      CORBA::tk_sequence, // typecode kind
      552, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        CORBA::tk_struct, // typecode kind
        536, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          39,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x506f7274), 
          ACE_NTOHL (0x61626c65), 
          ACE_NTOHL (0x47726f75), 
          ACE_NTOHL (0x702f5072), 
          ACE_NTOHL (0x6f706572), 
          ACE_NTOHL (0x74793a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableGroup/Property:1.0
          9,
          ACE_NTOHL (0x50726f70), 
          ACE_NTOHL (0x65727479), 
          ACE_NTOHL (0x0),  // name = Property
          2, // member count
          4,
          ACE_NTOHL (0x6e616d00),  // name = nam
          CORBA::tk_alias, // typecode kind for typedefs
          376, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            35,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x6f6d672e), 
            ACE_NTOHL (0x6f72672f), 
            ACE_NTOHL (0x506f7274), 
            ACE_NTOHL (0x61626c65), 
            ACE_NTOHL (0x47726f75), 
            ACE_NTOHL (0x702f4e61), 
            ACE_NTOHL (0x6d653a31), 
            ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableGroup/Name:1.0
            5,
            ACE_NTOHL (0x4e616d65), 
            ACE_NTOHL (0x0),  // name = Name
            CORBA::tk_alias, // typecode kind for typedefs
            312, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              31,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x436f734e), 
              ACE_NTOHL (0x616d696e), 
              ACE_NTOHL (0x672f4e61), 
              ACE_NTOHL (0x6d653a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CosNaming/Name:1.0
              5,
              ACE_NTOHL (0x4e616d65), 
              ACE_NTOHL (0x0),  // name = Name
              CORBA::tk_sequence, // typecode kind
              252, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                CORBA::tk_struct, // typecode kind
                236, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  40,
                  ACE_NTOHL (0x49444c3a), 
                  ACE_NTOHL (0x6f6d672e), 
                  ACE_NTOHL (0x6f72672f), 
                  ACE_NTOHL (0x436f734e), 
                  ACE_NTOHL (0x616d696e), 
                  ACE_NTOHL (0x672f4e61), 
                  ACE_NTOHL (0x6d65436f), 
                  ACE_NTOHL (0x6d706f6e), 
                  ACE_NTOHL (0x656e743a), 
                  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CosNaming/NameComponent:1.0
                  14,
                  ACE_NTOHL (0x4e616d65), 
                  ACE_NTOHL (0x436f6d70), 
                  ACE_NTOHL (0x6f6e656e), 
                  ACE_NTOHL (0x74000000),  // name = NameComponent
                  2, // member count
                  3,
                  ACE_NTOHL (0x69640000),  // name = id
                  CORBA::tk_alias, // typecode kind for typedefs
                  64, // encapsulation length
                    TAO_ENCAP_BYTE_ORDER, // byte order
                    34,
                    ACE_NTOHL (0x49444c3a), 
                    ACE_NTOHL (0x6f6d672e), 
                    ACE_NTOHL (0x6f72672f), 
                    ACE_NTOHL (0x436f734e), 
                    ACE_NTOHL (0x616d696e), 
                    ACE_NTOHL (0x672f4973), 
                    ACE_NTOHL (0x7472696e), 
                    ACE_NTOHL (0x673a312e), 
                    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CosNaming/Istring:1.0
                    8,
                    ACE_NTOHL (0x49737472), 
                    ACE_NTOHL (0x696e6700),  // name = Istring
                    CORBA::tk_string, 
                    0U, // string length

                  5,
                  ACE_NTOHL (0x6b696e64), 
                  ACE_NTOHL (0x0),  // name = kind
                  CORBA::tk_alias, // typecode kind for typedefs
                  64, // encapsulation length
                    TAO_ENCAP_BYTE_ORDER, // byte order
                    34,
                    ACE_NTOHL (0x49444c3a), 
                    ACE_NTOHL (0x6f6d672e), 
                    ACE_NTOHL (0x6f72672f), 
                    ACE_NTOHL (0x436f734e), 
                    ACE_NTOHL (0x616d696e), 
                    ACE_NTOHL (0x672f4973), 
                    ACE_NTOHL (0x7472696e), 
                    ACE_NTOHL (0x673a312e), 
                    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CosNaming/Istring:1.0
                    8,
                    ACE_NTOHL (0x49737472), 
                    ACE_NTOHL (0x696e6700),  // name = Istring
                    CORBA::tk_string, 
                    0U, // string length


                0U,



          4,
          ACE_NTOHL (0x76616c00),  // name = val
          CORBA::tk_alias, // typecode kind for typedefs
          60, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            36,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x6f6d672e), 
            ACE_NTOHL (0x6f72672f), 
            ACE_NTOHL (0x506f7274), 
            ACE_NTOHL (0x61626c65), 
            ACE_NTOHL (0x47726f75), 
            ACE_NTOHL (0x702f5661), 
            ACE_NTOHL (0x6c75653a), 
            ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/PortableGroup/Value:1.0
            6,
            ACE_NTOHL (0x56616c75), 
            ACE_NTOHL (0x65000000),  // name = Value
            CORBA::tk_any,



        0U,



};

static CORBA::TypeCode _tc_TAO_tc_PortableGroup_CannotMeetCriteria (
    CORBA::tk_except,
    sizeof (_oc_PortableGroup_CannotMeetCriteria),
    (char *) &_oc_PortableGroup_CannotMeetCriteria,
    0,
    sizeof (PortableGroup::CannotMeetCriteria)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableGroup)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_CannotMeetCriteria, &_tc_TAO_tc_PortableGroup_CannotMeetCriteria)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr PortableGroup::CannotMeetCriteria::_type (void) const
{
  return ::PortableGroup::_tc_CannotMeetCriteria;
}

PortableGroup::PropertyManager_ptr
tao_PortableGroup_PropertyManager_duplicate (
    PortableGroup::PropertyManager_ptr p
  )
{
  return PortableGroup::PropertyManager::_duplicate (p);
}

void
tao_PortableGroup_PropertyManager_release (
    PortableGroup::PropertyManager_ptr p
  )
{
  CORBA::release (p);
}

PortableGroup::PropertyManager_ptr
tao_PortableGroup_PropertyManager_nil (
    void
  )
{
  return PortableGroup::PropertyManager::_nil ();
}

PortableGroup::PropertyManager_ptr
tao_PortableGroup_PropertyManager_narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return PortableGroup::PropertyManager::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
tao_PortableGroup_PropertyManager_upcast (
    void *src
  )
{
  PortableGroup::PropertyManager **tmp =
    ACE_static_cast (PortableGroup::PropertyManager **, src);
  return *tmp;
}

// *************************************************************
// Operations for class PortableGroup::PropertyManager_var
// *************************************************************

PortableGroup::PropertyManager_var::PropertyManager_var (void) // default constructor
  : ptr_ (PropertyManager::_nil ())
{}

::PortableGroup::PropertyManager_ptr
PortableGroup::PropertyManager_var::ptr (void) const
{
  return this->ptr_;
}

PortableGroup::PropertyManager_var::PropertyManager_var (const ::PortableGroup::PropertyManager_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (PropertyManager::_duplicate (p.ptr ()))
{}

PortableGroup::PropertyManager_var::~PropertyManager_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

PortableGroup::PropertyManager_var &
PortableGroup::PropertyManager_var::operator= (PropertyManager_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

PortableGroup::PropertyManager_var &
PortableGroup::PropertyManager_var::operator= (const ::PortableGroup::PropertyManager_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::PortableGroup::PropertyManager::_duplicate (p.ptr ());
  }
  return *this;
}

PortableGroup::PropertyManager_var::operator const ::PortableGroup::PropertyManager_ptr &() const // cast
{
  return this->ptr_;
}

PortableGroup::PropertyManager_var::operator ::PortableGroup::PropertyManager_ptr &() // cast 
{
  return this->ptr_;
}

::PortableGroup::PropertyManager_ptr
PortableGroup::PropertyManager_var::operator-> (void) const
{
  return this->ptr_;
}

::PortableGroup::PropertyManager_ptr
PortableGroup::PropertyManager_var::in (void) const
{
  return this->ptr_;
}

::PortableGroup::PropertyManager_ptr &
PortableGroup::PropertyManager_var::inout (void)
{
  return this->ptr_;
}

::PortableGroup::PropertyManager_ptr &
PortableGroup::PropertyManager_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableGroup::PropertyManager::_nil ();
  return this->ptr_;
}

::PortableGroup::PropertyManager_ptr
PortableGroup::PropertyManager_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::PortableGroup::PropertyManager_ptr val = this->ptr_;
  this->ptr_ = ::PortableGroup::PropertyManager::_nil ();
  return val;
}

::PortableGroup::PropertyManager_ptr
PortableGroup::PropertyManager_var::duplicate (PropertyManager_ptr p)
{
  return ::PortableGroup::PropertyManager::_duplicate (p);
}

void
PortableGroup::PropertyManager_var::release (PropertyManager_ptr p)
{
  CORBA::release (p);
}

::PortableGroup::PropertyManager_ptr
PortableGroup::PropertyManager_var::nil (void)
{
  return ::PortableGroup::PropertyManager::_nil ();
}

::PortableGroup::PropertyManager_ptr
PortableGroup::PropertyManager_var::narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return ::PortableGroup::PropertyManager::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
PortableGroup::PropertyManager_var::upcast (void *src)
{
  PropertyManager **tmp =
    ACE_static_cast (PropertyManager **, src);
  return *tmp;
}

// *************************************************************
// Operations for class PortableGroup::PropertyManager_out
// *************************************************************

PortableGroup::PropertyManager_out::PropertyManager_out (PropertyManager_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::PortableGroup::PropertyManager::_nil ();
}

PortableGroup::PropertyManager_out::PropertyManager_out (PropertyManager_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableGroup::PropertyManager::_nil ();
}

PortableGroup::PropertyManager_out::PropertyManager_out (const ::PortableGroup::PropertyManager_out &p) // copy constructor
  : ptr_ (ACE_const_cast (PropertyManager_out &, p).ptr_)
{}

::PortableGroup::PropertyManager_out &
PortableGroup::PropertyManager_out::operator= (const ::PortableGroup::PropertyManager_out &p)
{
  this->ptr_ = ACE_const_cast (PropertyManager_out&, p).ptr_;
  return *this;
}

PortableGroup::PropertyManager_out &
PortableGroup::PropertyManager_out::operator= (const ::PortableGroup::PropertyManager_var &p)
{
  this->ptr_ = ::PortableGroup::PropertyManager::_duplicate (p.ptr ());
  return *this;
}

PortableGroup::PropertyManager_out &
PortableGroup::PropertyManager_out::operator= (PropertyManager_ptr p)
{
  this->ptr_ = p;
  return *this;
}

PortableGroup::PropertyManager_out::operator ::PortableGroup::PropertyManager_ptr &() // cast
{
  return this->ptr_;
}

::PortableGroup::PropertyManager_ptr &
PortableGroup::PropertyManager_out::ptr (void) // ptr
{
  return this->ptr_;
}

::PortableGroup::PropertyManager_ptr
PortableGroup::PropertyManager_out::operator-> (void)
{
  return this->ptr_;
}


// default constructor
PortableGroup::PropertyManager::PropertyManager ()
{
  }

// destructor
PortableGroup::PropertyManager::~PropertyManager (void)
{}

PortableGroup::PropertyManager_ptr PortableGroup::PropertyManager::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return PropertyManager::_unchecked_narrow (obj, ACE_TRY_ENV);
}

PortableGroup::PropertyManager_ptr PortableGroup::PropertyManager::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return PropertyManager::_nil ();
  return
      ACE_reinterpret_cast
        (
          PropertyManager_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &PropertyManager::_narrow
                  )
              )
        );
}

PortableGroup::PropertyManager_ptr
PortableGroup::PropertyManager::_duplicate (PropertyManager_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *PortableGroup::PropertyManager::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableGroup, PropertyManager)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* PortableGroup::PropertyManager::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableGroup/PropertyManager:1.0";
}

PortableGroup::ObjectGroupManager_ptr
tao_PortableGroup_ObjectGroupManager_duplicate (
    PortableGroup::ObjectGroupManager_ptr p
  )
{
  return PortableGroup::ObjectGroupManager::_duplicate (p);
}

void
tao_PortableGroup_ObjectGroupManager_release (
    PortableGroup::ObjectGroupManager_ptr p
  )
{
  CORBA::release (p);
}

PortableGroup::ObjectGroupManager_ptr
tao_PortableGroup_ObjectGroupManager_nil (
    void
  )
{
  return PortableGroup::ObjectGroupManager::_nil ();
}

PortableGroup::ObjectGroupManager_ptr
tao_PortableGroup_ObjectGroupManager_narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return PortableGroup::ObjectGroupManager::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
tao_PortableGroup_ObjectGroupManager_upcast (
    void *src
  )
{
  PortableGroup::ObjectGroupManager **tmp =
    ACE_static_cast (PortableGroup::ObjectGroupManager **, src);
  return *tmp;
}

// *************************************************************
// Operations for class PortableGroup::ObjectGroupManager_var
// *************************************************************

PortableGroup::ObjectGroupManager_var::ObjectGroupManager_var (void) // default constructor
  : ptr_ (ObjectGroupManager::_nil ())
{}

::PortableGroup::ObjectGroupManager_ptr
PortableGroup::ObjectGroupManager_var::ptr (void) const
{
  return this->ptr_;
}

PortableGroup::ObjectGroupManager_var::ObjectGroupManager_var (const ::PortableGroup::ObjectGroupManager_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (ObjectGroupManager::_duplicate (p.ptr ()))
{}

PortableGroup::ObjectGroupManager_var::~ObjectGroupManager_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

PortableGroup::ObjectGroupManager_var &
PortableGroup::ObjectGroupManager_var::operator= (ObjectGroupManager_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

PortableGroup::ObjectGroupManager_var &
PortableGroup::ObjectGroupManager_var::operator= (const ::PortableGroup::ObjectGroupManager_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::PortableGroup::ObjectGroupManager::_duplicate (p.ptr ());
  }
  return *this;
}

PortableGroup::ObjectGroupManager_var::operator const ::PortableGroup::ObjectGroupManager_ptr &() const // cast
{
  return this->ptr_;
}

PortableGroup::ObjectGroupManager_var::operator ::PortableGroup::ObjectGroupManager_ptr &() // cast 
{
  return this->ptr_;
}

::PortableGroup::ObjectGroupManager_ptr
PortableGroup::ObjectGroupManager_var::operator-> (void) const
{
  return this->ptr_;
}

::PortableGroup::ObjectGroupManager_ptr
PortableGroup::ObjectGroupManager_var::in (void) const
{
  return this->ptr_;
}

::PortableGroup::ObjectGroupManager_ptr &
PortableGroup::ObjectGroupManager_var::inout (void)
{
  return this->ptr_;
}

::PortableGroup::ObjectGroupManager_ptr &
PortableGroup::ObjectGroupManager_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableGroup::ObjectGroupManager::_nil ();
  return this->ptr_;
}

::PortableGroup::ObjectGroupManager_ptr
PortableGroup::ObjectGroupManager_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::PortableGroup::ObjectGroupManager_ptr val = this->ptr_;
  this->ptr_ = ::PortableGroup::ObjectGroupManager::_nil ();
  return val;
}

::PortableGroup::ObjectGroupManager_ptr
PortableGroup::ObjectGroupManager_var::duplicate (ObjectGroupManager_ptr p)
{
  return ::PortableGroup::ObjectGroupManager::_duplicate (p);
}

void
PortableGroup::ObjectGroupManager_var::release (ObjectGroupManager_ptr p)
{
  CORBA::release (p);
}

::PortableGroup::ObjectGroupManager_ptr
PortableGroup::ObjectGroupManager_var::nil (void)
{
  return ::PortableGroup::ObjectGroupManager::_nil ();
}

::PortableGroup::ObjectGroupManager_ptr
PortableGroup::ObjectGroupManager_var::narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return ::PortableGroup::ObjectGroupManager::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
PortableGroup::ObjectGroupManager_var::upcast (void *src)
{
  ObjectGroupManager **tmp =
    ACE_static_cast (ObjectGroupManager **, src);
  return *tmp;
}

// *************************************************************
// Operations for class PortableGroup::ObjectGroupManager_out
// *************************************************************

PortableGroup::ObjectGroupManager_out::ObjectGroupManager_out (ObjectGroupManager_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::PortableGroup::ObjectGroupManager::_nil ();
}

PortableGroup::ObjectGroupManager_out::ObjectGroupManager_out (ObjectGroupManager_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableGroup::ObjectGroupManager::_nil ();
}

PortableGroup::ObjectGroupManager_out::ObjectGroupManager_out (const ::PortableGroup::ObjectGroupManager_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ObjectGroupManager_out &, p).ptr_)
{}

::PortableGroup::ObjectGroupManager_out &
PortableGroup::ObjectGroupManager_out::operator= (const ::PortableGroup::ObjectGroupManager_out &p)
{
  this->ptr_ = ACE_const_cast (ObjectGroupManager_out&, p).ptr_;
  return *this;
}

PortableGroup::ObjectGroupManager_out &
PortableGroup::ObjectGroupManager_out::operator= (const ::PortableGroup::ObjectGroupManager_var &p)
{
  this->ptr_ = ::PortableGroup::ObjectGroupManager::_duplicate (p.ptr ());
  return *this;
}

PortableGroup::ObjectGroupManager_out &
PortableGroup::ObjectGroupManager_out::operator= (ObjectGroupManager_ptr p)
{
  this->ptr_ = p;
  return *this;
}

PortableGroup::ObjectGroupManager_out::operator ::PortableGroup::ObjectGroupManager_ptr &() // cast
{
  return this->ptr_;
}

::PortableGroup::ObjectGroupManager_ptr &
PortableGroup::ObjectGroupManager_out::ptr (void) // ptr
{
  return this->ptr_;
}

::PortableGroup::ObjectGroupManager_ptr
PortableGroup::ObjectGroupManager_out::operator-> (void)
{
  return this->ptr_;
}


// default constructor
PortableGroup::ObjectGroupManager::ObjectGroupManager ()
{
  }

// destructor
PortableGroup::ObjectGroupManager::~ObjectGroupManager (void)
{}

PortableGroup::ObjectGroupManager_ptr PortableGroup::ObjectGroupManager::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return ObjectGroupManager::_unchecked_narrow (obj, ACE_TRY_ENV);
}

PortableGroup::ObjectGroupManager_ptr PortableGroup::ObjectGroupManager::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return ObjectGroupManager::_nil ();
  return
      ACE_reinterpret_cast
        (
          ObjectGroupManager_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &ObjectGroupManager::_narrow
                  )
              )
        );
}

PortableGroup::ObjectGroupManager_ptr
PortableGroup::ObjectGroupManager::_duplicate (ObjectGroupManager_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *PortableGroup::ObjectGroupManager::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableGroup, ObjectGroupManager)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* PortableGroup::ObjectGroupManager::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableGroup/ObjectGroupManager:1.0";
}

PortableGroup::GenericFactory_ptr
tao_PortableGroup_GenericFactory_duplicate (
    PortableGroup::GenericFactory_ptr p
  )
{
  return PortableGroup::GenericFactory::_duplicate (p);
}

void
tao_PortableGroup_GenericFactory_release (
    PortableGroup::GenericFactory_ptr p
  )
{
  CORBA::release (p);
}

PortableGroup::GenericFactory_ptr
tao_PortableGroup_GenericFactory_nil (
    void
  )
{
  return PortableGroup::GenericFactory::_nil ();
}

PortableGroup::GenericFactory_ptr
tao_PortableGroup_GenericFactory_narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return PortableGroup::GenericFactory::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
tao_PortableGroup_GenericFactory_upcast (
    void *src
  )
{
  PortableGroup::GenericFactory **tmp =
    ACE_static_cast (PortableGroup::GenericFactory **, src);
  return *tmp;
}

// *************************************************************
// Operations for class PortableGroup::GenericFactory_var
// *************************************************************

PortableGroup::GenericFactory_var::GenericFactory_var (void) // default constructor
  : ptr_ (GenericFactory::_nil ())
{}

::PortableGroup::GenericFactory_ptr
PortableGroup::GenericFactory_var::ptr (void) const
{
  return this->ptr_;
}

PortableGroup::GenericFactory_var::GenericFactory_var (const ::PortableGroup::GenericFactory_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (GenericFactory::_duplicate (p.ptr ()))
{}

PortableGroup::GenericFactory_var::~GenericFactory_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

PortableGroup::GenericFactory_var &
PortableGroup::GenericFactory_var::operator= (GenericFactory_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

PortableGroup::GenericFactory_var &
PortableGroup::GenericFactory_var::operator= (const ::PortableGroup::GenericFactory_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::PortableGroup::GenericFactory::_duplicate (p.ptr ());
  }
  return *this;
}

PortableGroup::GenericFactory_var::operator const ::PortableGroup::GenericFactory_ptr &() const // cast
{
  return this->ptr_;
}

PortableGroup::GenericFactory_var::operator ::PortableGroup::GenericFactory_ptr &() // cast 
{
  return this->ptr_;
}

::PortableGroup::GenericFactory_ptr
PortableGroup::GenericFactory_var::operator-> (void) const
{
  return this->ptr_;
}

::PortableGroup::GenericFactory_ptr
PortableGroup::GenericFactory_var::in (void) const
{
  return this->ptr_;
}

::PortableGroup::GenericFactory_ptr &
PortableGroup::GenericFactory_var::inout (void)
{
  return this->ptr_;
}

::PortableGroup::GenericFactory_ptr &
PortableGroup::GenericFactory_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableGroup::GenericFactory::_nil ();
  return this->ptr_;
}

::PortableGroup::GenericFactory_ptr
PortableGroup::GenericFactory_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::PortableGroup::GenericFactory_ptr val = this->ptr_;
  this->ptr_ = ::PortableGroup::GenericFactory::_nil ();
  return val;
}

::PortableGroup::GenericFactory_ptr
PortableGroup::GenericFactory_var::duplicate (GenericFactory_ptr p)
{
  return ::PortableGroup::GenericFactory::_duplicate (p);
}

void
PortableGroup::GenericFactory_var::release (GenericFactory_ptr p)
{
  CORBA::release (p);
}

::PortableGroup::GenericFactory_ptr
PortableGroup::GenericFactory_var::nil (void)
{
  return ::PortableGroup::GenericFactory::_nil ();
}

::PortableGroup::GenericFactory_ptr
PortableGroup::GenericFactory_var::narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return ::PortableGroup::GenericFactory::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
PortableGroup::GenericFactory_var::upcast (void *src)
{
  GenericFactory **tmp =
    ACE_static_cast (GenericFactory **, src);
  return *tmp;
}

// *************************************************************
// Operations for class PortableGroup::GenericFactory_out
// *************************************************************

PortableGroup::GenericFactory_out::GenericFactory_out (GenericFactory_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::PortableGroup::GenericFactory::_nil ();
}

PortableGroup::GenericFactory_out::GenericFactory_out (GenericFactory_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableGroup::GenericFactory::_nil ();
}

PortableGroup::GenericFactory_out::GenericFactory_out (const ::PortableGroup::GenericFactory_out &p) // copy constructor
  : ptr_ (ACE_const_cast (GenericFactory_out &, p).ptr_)
{}

::PortableGroup::GenericFactory_out &
PortableGroup::GenericFactory_out::operator= (const ::PortableGroup::GenericFactory_out &p)
{
  this->ptr_ = ACE_const_cast (GenericFactory_out&, p).ptr_;
  return *this;
}

PortableGroup::GenericFactory_out &
PortableGroup::GenericFactory_out::operator= (const ::PortableGroup::GenericFactory_var &p)
{
  this->ptr_ = ::PortableGroup::GenericFactory::_duplicate (p.ptr ());
  return *this;
}

PortableGroup::GenericFactory_out &
PortableGroup::GenericFactory_out::operator= (GenericFactory_ptr p)
{
  this->ptr_ = p;
  return *this;
}

PortableGroup::GenericFactory_out::operator ::PortableGroup::GenericFactory_ptr &() // cast
{
  return this->ptr_;
}

::PortableGroup::GenericFactory_ptr &
PortableGroup::GenericFactory_out::ptr (void) // ptr
{
  return this->ptr_;
}

::PortableGroup::GenericFactory_ptr
PortableGroup::GenericFactory_out::operator-> (void)
{
  return this->ptr_;
}


// default constructor
PortableGroup::GenericFactory::GenericFactory ()
{
  }

// destructor
PortableGroup::GenericFactory::~GenericFactory (void)
{}

PortableGroup::GenericFactory_ptr PortableGroup::GenericFactory::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return GenericFactory::_unchecked_narrow (obj, ACE_TRY_ENV);
}

PortableGroup::GenericFactory_ptr PortableGroup::GenericFactory::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return GenericFactory::_nil ();
  return
      ACE_reinterpret_cast
        (
          GenericFactory_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &GenericFactory::_narrow
                  )
              )
        );
}

PortableGroup::GenericFactory_ptr
PortableGroup::GenericFactory::_duplicate (GenericFactory_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *PortableGroup::GenericFactory::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableGroup, GenericFactory)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* PortableGroup::GenericFactory::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableGroup/GenericFactory:1.0";
}

void operator<<= (CORBA::Any &_tao_any, const PortableGroup::TagGroupTaggedComponent &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_TagGroupTaggedComponent,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, PortableGroup::TagGroupTaggedComponent *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_TagGroupTaggedComponent,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      PortableGroup::TagGroupTaggedComponent::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableGroup::TagGroupTaggedComponent *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const PortableGroup::TagGroupTaggedComponent*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const PortableGroup::TagGroupTaggedComponent *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableGroup::_tc_TagGroupTaggedComponent, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const PortableGroup::TagGroupTaggedComponent*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      PortableGroup::TagGroupTaggedComponent *tmp;
      ACE_NEW_RETURN (tmp, PortableGroup::TagGroupTaggedComponent, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            PortableGroup::_tc_TagGroupTaggedComponent,
            1,
            ACE_static_cast (void *, tmp),
            PortableGroup::TagGroupTaggedComponent::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const PortableGroup::GroupIIOPProfile &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        PortableGroup::_tc_GroupIIOPProfile,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, PortableGroup::GroupIIOPProfile *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_GroupIIOPProfile,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      PortableGroup::GroupIIOPProfile::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableGroup::GroupIIOPProfile *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const PortableGroup::GroupIIOPProfile*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const PortableGroup::GroupIIOPProfile *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableGroup::_tc_GroupIIOPProfile, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const PortableGroup::GroupIIOPProfile*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      PortableGroup::GroupIIOPProfile *tmp;
      ACE_NEW_RETURN (tmp, PortableGroup::GroupIIOPProfile, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            PortableGroup::_tc_GroupIIOPProfile,
            1,
            ACE_static_cast (void *, tmp),
            PortableGroup::GroupIIOPProfile::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const PortableGroup::Property &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_Property,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, PortableGroup::Property *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_Property,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      PortableGroup::Property::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableGroup::Property *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const PortableGroup::Property*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const PortableGroup::Property *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableGroup::_tc_Property, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const PortableGroup::Property*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      PortableGroup::Property *tmp;
      ACE_NEW_RETURN (tmp, PortableGroup::Property, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            PortableGroup::_tc_Property,
            1,
            ACE_static_cast (void *, tmp),
            PortableGroup::Property::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const PortableGroup::Properties &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        PortableGroup::_tc_Properties,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, PortableGroup::Properties *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_Properties,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      PortableGroup::Properties::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableGroup::Properties *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const PortableGroup::Properties*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const PortableGroup::Properties *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableGroup::_tc_Properties, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const PortableGroup::Properties*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      PortableGroup::Properties *tmp;
      ACE_NEW_RETURN (tmp, PortableGroup::Properties, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            PortableGroup::_tc_Properties,
            1,
            ACE_static_cast (void *, tmp),
            PortableGroup::Properties::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const PortableGroup::Locations &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        PortableGroup::_tc_Locations,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, PortableGroup::Locations *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_Locations,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      PortableGroup::Locations::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableGroup::Locations *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const PortableGroup::Locations*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const PortableGroup::Locations *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableGroup::_tc_Locations, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const PortableGroup::Locations*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      PortableGroup::Locations *tmp;
      ACE_NEW_RETURN (tmp, PortableGroup::Locations, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            PortableGroup::_tc_Locations,
            1,
            ACE_static_cast (void *, tmp),
            PortableGroup::Locations::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const PortableGroup::InterfaceNotFound &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_InterfaceNotFound,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, PortableGroup::InterfaceNotFound *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_InterfaceNotFound,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      PortableGroup::InterfaceNotFound::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableGroup::InterfaceNotFound *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const PortableGroup::InterfaceNotFound*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const PortableGroup::InterfaceNotFound *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableGroup::_tc_InterfaceNotFound, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableGroup::InterfaceNotFound *)_tao_any.value ();
      return 1;
    }
    else
    {
      PortableGroup::InterfaceNotFound *tmp;
      ACE_NEW_RETURN (tmp, PortableGroup::InterfaceNotFound, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      CORBA::String_var interface_repository_id;
      if (!(stream >> interface_repository_id.out ()))
        return 0;
      if (ACE_OS::strcmp (
          interface_repository_id.in (),
          "IDL:omg.org/PortableGroup/InterfaceNotFound:1.0"))
        return 0;
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            PortableGroup::_tc_InterfaceNotFound,
            1,
            tmp,
            PortableGroup::InterfaceNotFound::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const PortableGroup::ObjectGroupNotFound &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_ObjectGroupNotFound,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, PortableGroup::ObjectGroupNotFound *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_ObjectGroupNotFound,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      PortableGroup::ObjectGroupNotFound::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableGroup::ObjectGroupNotFound *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const PortableGroup::ObjectGroupNotFound*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const PortableGroup::ObjectGroupNotFound *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableGroup::_tc_ObjectGroupNotFound, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableGroup::ObjectGroupNotFound *)_tao_any.value ();
      return 1;
    }
    else
    {
      PortableGroup::ObjectGroupNotFound *tmp;
      ACE_NEW_RETURN (tmp, PortableGroup::ObjectGroupNotFound, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      CORBA::String_var interface_repository_id;
      if (!(stream >> interface_repository_id.out ()))
        return 0;
      if (ACE_OS::strcmp (
          interface_repository_id.in (),
          "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0"))
        return 0;
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            PortableGroup::_tc_ObjectGroupNotFound,
            1,
            tmp,
            PortableGroup::ObjectGroupNotFound::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const PortableGroup::MemberNotFound &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_MemberNotFound,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, PortableGroup::MemberNotFound *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_MemberNotFound,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      PortableGroup::MemberNotFound::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableGroup::MemberNotFound *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const PortableGroup::MemberNotFound*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const PortableGroup::MemberNotFound *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableGroup::_tc_MemberNotFound, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableGroup::MemberNotFound *)_tao_any.value ();
      return 1;
    }
    else
    {
      PortableGroup::MemberNotFound *tmp;
      ACE_NEW_RETURN (tmp, PortableGroup::MemberNotFound, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      CORBA::String_var interface_repository_id;
      if (!(stream >> interface_repository_id.out ()))
        return 0;
      if (ACE_OS::strcmp (
          interface_repository_id.in (),
          "IDL:omg.org/PortableGroup/MemberNotFound:1.0"))
        return 0;
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            PortableGroup::_tc_MemberNotFound,
            1,
            tmp,
            PortableGroup::MemberNotFound::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const PortableGroup::ObjectNotFound &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_ObjectNotFound,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, PortableGroup::ObjectNotFound *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_ObjectNotFound,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      PortableGroup::ObjectNotFound::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableGroup::ObjectNotFound *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const PortableGroup::ObjectNotFound*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const PortableGroup::ObjectNotFound *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableGroup::_tc_ObjectNotFound, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableGroup::ObjectNotFound *)_tao_any.value ();
      return 1;
    }
    else
    {
      PortableGroup::ObjectNotFound *tmp;
      ACE_NEW_RETURN (tmp, PortableGroup::ObjectNotFound, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      CORBA::String_var interface_repository_id;
      if (!(stream >> interface_repository_id.out ()))
        return 0;
      if (ACE_OS::strcmp (
          interface_repository_id.in (),
          "IDL:omg.org/PortableGroup/ObjectNotFound:1.0"))
        return 0;
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            PortableGroup::_tc_ObjectNotFound,
            1,
            tmp,
            PortableGroup::ObjectNotFound::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const PortableGroup::MemberAlreadyPresent &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_MemberAlreadyPresent,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, PortableGroup::MemberAlreadyPresent *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_MemberAlreadyPresent,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      PortableGroup::MemberAlreadyPresent::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableGroup::MemberAlreadyPresent *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const PortableGroup::MemberAlreadyPresent*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const PortableGroup::MemberAlreadyPresent *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableGroup::_tc_MemberAlreadyPresent, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableGroup::MemberAlreadyPresent *)_tao_any.value ();
      return 1;
    }
    else
    {
      PortableGroup::MemberAlreadyPresent *tmp;
      ACE_NEW_RETURN (tmp, PortableGroup::MemberAlreadyPresent, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      CORBA::String_var interface_repository_id;
      if (!(stream >> interface_repository_id.out ()))
        return 0;
      if (ACE_OS::strcmp (
          interface_repository_id.in (),
          "IDL:omg.org/PortableGroup/MemberAlreadyPresent:1.0"))
        return 0;
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            PortableGroup::_tc_MemberAlreadyPresent,
            1,
            tmp,
            PortableGroup::MemberAlreadyPresent::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const PortableGroup::BadReplicationStyle &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_BadReplicationStyle,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, PortableGroup::BadReplicationStyle *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_BadReplicationStyle,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      PortableGroup::BadReplicationStyle::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableGroup::BadReplicationStyle *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const PortableGroup::BadReplicationStyle*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const PortableGroup::BadReplicationStyle *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableGroup::_tc_BadReplicationStyle, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableGroup::BadReplicationStyle *)_tao_any.value ();
      return 1;
    }
    else
    {
      PortableGroup::BadReplicationStyle *tmp;
      ACE_NEW_RETURN (tmp, PortableGroup::BadReplicationStyle, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      CORBA::String_var interface_repository_id;
      if (!(stream >> interface_repository_id.out ()))
        return 0;
      if (ACE_OS::strcmp (
          interface_repository_id.in (),
          "IDL:omg.org/PortableGroup/BadReplicationStyle:1.0"))
        return 0;
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            PortableGroup::_tc_BadReplicationStyle,
            1,
            tmp,
            PortableGroup::BadReplicationStyle::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const PortableGroup::ObjectNotCreated &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_ObjectNotCreated,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, PortableGroup::ObjectNotCreated *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_ObjectNotCreated,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      PortableGroup::ObjectNotCreated::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableGroup::ObjectNotCreated *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const PortableGroup::ObjectNotCreated*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const PortableGroup::ObjectNotCreated *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableGroup::_tc_ObjectNotCreated, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableGroup::ObjectNotCreated *)_tao_any.value ();
      return 1;
    }
    else
    {
      PortableGroup::ObjectNotCreated *tmp;
      ACE_NEW_RETURN (tmp, PortableGroup::ObjectNotCreated, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      CORBA::String_var interface_repository_id;
      if (!(stream >> interface_repository_id.out ()))
        return 0;
      if (ACE_OS::strcmp (
          interface_repository_id.in (),
          "IDL:omg.org/PortableGroup/ObjectNotCreated:1.0"))
        return 0;
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            PortableGroup::_tc_ObjectNotCreated,
            1,
            tmp,
            PortableGroup::ObjectNotCreated::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const PortableGroup::ObjectNotAdded &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_ObjectNotAdded,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, PortableGroup::ObjectNotAdded *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_ObjectNotAdded,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      PortableGroup::ObjectNotAdded::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableGroup::ObjectNotAdded *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const PortableGroup::ObjectNotAdded*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const PortableGroup::ObjectNotAdded *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableGroup::_tc_ObjectNotAdded, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableGroup::ObjectNotAdded *)_tao_any.value ();
      return 1;
    }
    else
    {
      PortableGroup::ObjectNotAdded *tmp;
      ACE_NEW_RETURN (tmp, PortableGroup::ObjectNotAdded, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      CORBA::String_var interface_repository_id;
      if (!(stream >> interface_repository_id.out ()))
        return 0;
      if (ACE_OS::strcmp (
          interface_repository_id.in (),
          "IDL:omg.org/PortableGroup/ObjectNotAdded:1.0"))
        return 0;
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            PortableGroup::_tc_ObjectNotAdded,
            1,
            tmp,
            PortableGroup::ObjectNotAdded::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const PortableGroup::UnsupportedProperty &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_UnsupportedProperty,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, PortableGroup::UnsupportedProperty *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_UnsupportedProperty,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      PortableGroup::UnsupportedProperty::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableGroup::UnsupportedProperty *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const PortableGroup::UnsupportedProperty*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const PortableGroup::UnsupportedProperty *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableGroup::_tc_UnsupportedProperty, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableGroup::UnsupportedProperty *)_tao_any.value ();
      return 1;
    }
    else
    {
      PortableGroup::UnsupportedProperty *tmp;
      ACE_NEW_RETURN (tmp, PortableGroup::UnsupportedProperty, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      CORBA::String_var interface_repository_id;
      if (!(stream >> interface_repository_id.out ()))
        return 0;
      if (ACE_OS::strcmp (
          interface_repository_id.in (),
          "IDL:omg.org/PortableGroup/UnsupportedProperty:1.0"))
        return 0;
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            PortableGroup::_tc_UnsupportedProperty,
            1,
            tmp,
            PortableGroup::UnsupportedProperty::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const PortableGroup::InvalidProperty &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_InvalidProperty,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, PortableGroup::InvalidProperty *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_InvalidProperty,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      PortableGroup::InvalidProperty::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableGroup::InvalidProperty *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const PortableGroup::InvalidProperty*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const PortableGroup::InvalidProperty *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableGroup::_tc_InvalidProperty, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableGroup::InvalidProperty *)_tao_any.value ();
      return 1;
    }
    else
    {
      PortableGroup::InvalidProperty *tmp;
      ACE_NEW_RETURN (tmp, PortableGroup::InvalidProperty, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      CORBA::String_var interface_repository_id;
      if (!(stream >> interface_repository_id.out ()))
        return 0;
      if (ACE_OS::strcmp (
          interface_repository_id.in (),
          "IDL:omg.org/PortableGroup/InvalidProperty:1.0"))
        return 0;
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            PortableGroup::_tc_InvalidProperty,
            1,
            tmp,
            PortableGroup::InvalidProperty::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const PortableGroup::NoFactory &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_NoFactory,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, PortableGroup::NoFactory *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_NoFactory,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      PortableGroup::NoFactory::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableGroup::NoFactory *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const PortableGroup::NoFactory*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const PortableGroup::NoFactory *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableGroup::_tc_NoFactory, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableGroup::NoFactory *)_tao_any.value ();
      return 1;
    }
    else
    {
      PortableGroup::NoFactory *tmp;
      ACE_NEW_RETURN (tmp, PortableGroup::NoFactory, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      CORBA::String_var interface_repository_id;
      if (!(stream >> interface_repository_id.out ()))
        return 0;
      if (ACE_OS::strcmp (
          interface_repository_id.in (),
          "IDL:omg.org/PortableGroup/NoFactory:1.0"))
        return 0;
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            PortableGroup::_tc_NoFactory,
            1,
            tmp,
            PortableGroup::NoFactory::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const PortableGroup::InvalidCriteria &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_InvalidCriteria,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, PortableGroup::InvalidCriteria *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_InvalidCriteria,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      PortableGroup::InvalidCriteria::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableGroup::InvalidCriteria *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const PortableGroup::InvalidCriteria*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const PortableGroup::InvalidCriteria *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableGroup::_tc_InvalidCriteria, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableGroup::InvalidCriteria *)_tao_any.value ();
      return 1;
    }
    else
    {
      PortableGroup::InvalidCriteria *tmp;
      ACE_NEW_RETURN (tmp, PortableGroup::InvalidCriteria, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      CORBA::String_var interface_repository_id;
      if (!(stream >> interface_repository_id.out ()))
        return 0;
      if (ACE_OS::strcmp (
          interface_repository_id.in (),
          "IDL:omg.org/PortableGroup/InvalidCriteria:1.0"))
        return 0;
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            PortableGroup::_tc_InvalidCriteria,
            1,
            tmp,
            PortableGroup::InvalidCriteria::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const PortableGroup::CannotMeetCriteria &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_CannotMeetCriteria,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, PortableGroup::CannotMeetCriteria *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      PortableGroup::_tc_CannotMeetCriteria,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      PortableGroup::CannotMeetCriteria::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableGroup::CannotMeetCriteria *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const PortableGroup::CannotMeetCriteria*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const PortableGroup::CannotMeetCriteria *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableGroup::_tc_CannotMeetCriteria, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableGroup::CannotMeetCriteria *)_tao_any.value ();
      return 1;
    }
    else
    {
      PortableGroup::CannotMeetCriteria *tmp;
      ACE_NEW_RETURN (tmp, PortableGroup::CannotMeetCriteria, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      CORBA::String_var interface_repository_id;
      if (!(stream >> interface_repository_id.out ()))
        return 0;
      if (ACE_OS::strcmp (
          interface_repository_id.in (),
          "IDL:omg.org/PortableGroup/CannotMeetCriteria:1.0"))
        return 0;
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            PortableGroup::_tc_CannotMeetCriteria,
            1,
            tmp,
            PortableGroup::CannotMeetCriteria::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<PortableGroup::PropertyManager,PortableGroup::PropertyManager_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<PortableGroup::PropertyManager,PortableGroup::PropertyManager_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<PortableGroup::ObjectGroupManager,PortableGroup::ObjectGroupManager_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<PortableGroup::ObjectGroupManager,PortableGroup::ObjectGroupManager_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<PortableGroup::GenericFactory,PortableGroup::GenericFactory_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<PortableGroup::GenericFactory,PortableGroup::GenericFactory_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::GroupIIOPProfile &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    
#if (TAO_NO_COPY_OCTET_SEQUENCES == 1)
    {
      TAO_Unbounded_Sequence<CORBA::Octet> *oseq = 
        ACE_static_cast (TAO_Unbounded_Sequence<CORBA::Octet>*, (PortableGroup::GroupIIOPProfile *)&_tao_sequence);
      if (oseq->mb ())
        return strm.write_octet_array_mb (oseq->mb ());
      else
        return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
    }
    
#else /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
    return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
  
#endif /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableGroup::GroupIIOPProfile &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // Add a check to the length of the sequence
    // to make sure it does not exceed the length
    // of the stream. (See bug 58.)
    if (_tao_seq_len > strm.length())
      return 0;
    // retrieve all the elements
    
#if (TAO_NO_COPY_OCTET_SEQUENCES == 1)
    if (ACE_BIT_DISABLED (strm.start ()->flags (),
    ACE_Message_Block::DONT_DELETE))
    {
      TAO_ORB_Core* orb_core = strm.orb_core ();
      if (orb_core != 0 &&
      strm.orb_core ()->resource_factory ()->
      input_cdr_allocator_type_locked () == 1)
      {
        TAO_Unbounded_Sequence<CORBA::Octet> *oseq = 
          ACE_static_cast(TAO_Unbounded_Sequence<CORBA::Octet>*, &_tao_sequence);
        oseq->replace (_tao_seq_len, strm.start ());
        oseq->mb ()->wr_ptr (oseq->mb()->rd_ptr () + _tao_seq_len);
        strm.skip_bytes (_tao_seq_len);
        return 1;
      }
    }
    return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_seq_len);
#else /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
    return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
  
#endif /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::Properties &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableGroup::Properties &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // Add a check to the length of the sequence
    // to make sure it does not exceed the length
    // of the stream. (See bug 58.)
    if (_tao_seq_len > strm.length())
      return 0;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::Locations &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableGroup::Locations &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // Add a check to the length of the sequence
    // to make sure it does not exceed the length
    // of the stream. (See bug 58.)
    if (_tao_seq_len > strm.length())
      return 0;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

