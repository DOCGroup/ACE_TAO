// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#ifndef _TAO_IDL_PORTABLEGROUPC_H_
#define _TAO_IDL_PORTABLEGROUPC_H_

#include "ace/pre.h"
#include "tao/corba.h"

#if !defined (ACE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */

#include "portablegroup_export.h"
#include "tao/PortableServer/PortableServerC.h"
#include "orbsvcs/orbsvcs/CosNamingC.h"
//#include "IOPC.h"
#include "tao/GIOPC.h"

#if defined (TAO_EXPORT_MACRO)
#undef TAO_EXPORT_MACRO
#endif
#define TAO_EXPORT_MACRO TAO_PortableGroup_Export

#if defined (TAO_EXPORT_NESTED_CLASSES)
#  if defined (TAO_EXPORT_NESTED_MACRO)
#    undef TAO_EXPORT_NESTED_MACRO
#  endif /* defined (TAO_EXPORT_NESTED_MACRO) */
#  define TAO_EXPORT_NESTED_MACRO TAO_PortableGroup_Export
#endif /* TAO_EXPORT_NESTED_CLASSES */

#if defined(_MSC_VER)
#if (_MSC_VER >= 1200)
#pragma warning(push)
#endif /* _MSC_VER >= 1200 */
#pragma warning(disable:4250)
#endif /* _MSC_VER */

#if defined (__BORLANDC__)
#pragma option push -w-rvl -w-rch -w-ccc -w-inl
#endif /* __BORLANDC__ */

TAO_NAMESPACE  PortableGroup
{
  typedef char * GroupDomainId;
  typedef CORBA::String_var GroupDomainId_var;
  typedef CORBA::String_out GroupDomainId_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_GroupDomainId;

  typedef CORBA::ULongLong ObjectGroupId;
  typedef CORBA::ULongLong_out ObjectGroupId_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ObjectGroupId;

  typedef CORBA::ULong ObjectGroupRefVersion;
  typedef CORBA::ULong_out ObjectGroupRefVersion_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ObjectGroupRefVersion;

  typedef GIOP::Version Version;
//  @@ Frank: Version_var and Version_out are commented out as they
//     do not exist in tao/GIOPC.h.  Hopefully, this doesn't become an
//     issue.
//  typedef GIOP::Version_var Version_var;
//  typedef GIOP::Version_out Version_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Version;

  struct TagGroupTaggedComponent;
  class TagGroupTaggedComponent_var;
  
  struct TAO_PortableGroup_Export TagGroupTaggedComponent
  {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef TagGroupTaggedComponent_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

    static void _tao_any_destructor (void*);

    ACE_NESTED_CLASS (PortableGroup, Version) component_version;
    TAO_String_Manager group_domain_id;
    ACE_NESTED_CLASS (PortableGroup, ObjectGroupId) object_group_id;
    ACE_NESTED_CLASS (PortableGroup, ObjectGroupRefVersion) object_group_ref_version;
  };

  class TAO_PortableGroup_Export TagGroupTaggedComponent_var
  {
  public:
    TagGroupTaggedComponent_var (void); // default constructor
    TagGroupTaggedComponent_var (TagGroupTaggedComponent *);
    TagGroupTaggedComponent_var (const TagGroupTaggedComponent_var &); // copy constructor
    ~TagGroupTaggedComponent_var (void); // destructor
    
    TagGroupTaggedComponent_var &operator= (TagGroupTaggedComponent *);
    TagGroupTaggedComponent_var &operator= (const TagGroupTaggedComponent_var &);
    TagGroupTaggedComponent *operator-> (void);
    const TagGroupTaggedComponent *operator-> (void) const;
    
    operator const TagGroupTaggedComponent &() const;
    operator TagGroupTaggedComponent &();
    operator TagGroupTaggedComponent &() const;
    operator TagGroupTaggedComponent *&(); // variable-size types only
    
    // in, inout, out, _retn 
    const TagGroupTaggedComponent &in (void) const;
    TagGroupTaggedComponent &inout (void);
    TagGroupTaggedComponent *&out (void);
    TagGroupTaggedComponent *_retn (void);
    TagGroupTaggedComponent *ptr (void) const;

  private:
    TagGroupTaggedComponent *ptr_;
  };

  class TAO_PortableGroup_Export TagGroupTaggedComponent_out
  {
  public:
    TagGroupTaggedComponent_out (TagGroupTaggedComponent *&);
    TagGroupTaggedComponent_out (TagGroupTaggedComponent_var &);
    TagGroupTaggedComponent_out (const TagGroupTaggedComponent_out &);
    TagGroupTaggedComponent_out &operator= (const TagGroupTaggedComponent_out &);
    TagGroupTaggedComponent_out &operator= (TagGroupTaggedComponent *);
    operator TagGroupTaggedComponent *&();
    TagGroupTaggedComponent *&ptr (void);
    TagGroupTaggedComponent *operator-> (void);
    
  private:
    TagGroupTaggedComponent *&ptr_;
    // assignment from T_var not allowed
    void operator= (const TagGroupTaggedComponent_var &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_TagGroupTaggedComponent;


#if !defined (_PORTABLEGROUP_GROUPIIOPPROFILE_CH_)
#define _PORTABLEGROUP_GROUPIIOPPROFILE_CH_

  class GroupIIOPProfile;
  class GroupIIOPProfile_var;
  
  // *************************************************************
  // GroupIIOPProfile
  // *************************************************************
  
  class TAO_PortableGroup_Export GroupIIOPProfile : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Sequence<CORBA::Octet>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  {
  public:
    GroupIIOPProfile (void); // default ctor
    GroupIIOPProfile (CORBA::ULong max); // uses max size
    GroupIIOPProfile (
      CORBA::ULong max, 
      CORBA::ULong length, 
      CORBA::Octet *buffer, 
      CORBA::Boolean release = 0
    );
    GroupIIOPProfile (const GroupIIOPProfile &); // copy ctor
    ~GroupIIOPProfile (void);
    static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef GroupIIOPProfile_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */


#if (TAO_NO_COPY_OCTET_SEQUENCES == 1)
    GroupIIOPProfile (
        CORBA::ULong length,
        const ACE_Message_Block* mb
      )
      : TAO_Unbounded_Sequence<CORBA::Octet> (length, mb) {}
#endif /* TAO_NO_COPY_OCTET_SEQUENCE == 1 */

  };
  
#endif /* end #if !defined */


#if !defined (_PORTABLEGROUP_GROUPIIOPPROFILE___VAR_CH_)
#define _PORTABLEGROUP_GROUPIIOPPROFILE___VAR_CH_

  // *************************************************************
  // class PortableGroup::GroupIIOPProfile_var
  // *************************************************************

  class TAO_PortableGroup_Export GroupIIOPProfile_var
  {
  public:
    GroupIIOPProfile_var (void); // default constructor
    GroupIIOPProfile_var (GroupIIOPProfile *);
    GroupIIOPProfile_var (const GroupIIOPProfile_var &); // copy constructor
    GroupIIOPProfile_var (const GroupIIOPProfile &); // fixed-size base types only
    ~GroupIIOPProfile_var (void); // destructor
    
    GroupIIOPProfile_var &operator= (GroupIIOPProfile *);
    GroupIIOPProfile_var &operator= (const GroupIIOPProfile_var &);
    GroupIIOPProfile_var &operator= (const GroupIIOPProfile &); // fixed-size base types only
    GroupIIOPProfile *operator-> (void);
    const GroupIIOPProfile *operator-> (void) const;
    
    operator const GroupIIOPProfile &() const;
    operator GroupIIOPProfile &();
    operator GroupIIOPProfile &() const;
    
    CORBA::Octet & operator[] (CORBA::ULong index);
    const CORBA::Octet & operator[] (CORBA::ULong index) const;
    
    // in, inout, out, _retn 
    const GroupIIOPProfile &in (void) const;
    GroupIIOPProfile &inout (void);
    GroupIIOPProfile *&out (void);
    GroupIIOPProfile *_retn (void);
    GroupIIOPProfile *ptr (void) const;

  private:
    GroupIIOPProfile *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_PORTABLEGROUP_GROUPIIOPPROFILE___OUT_CH_)
#define _PORTABLEGROUP_GROUPIIOPPROFILE___OUT_CH_

  class TAO_PortableGroup_Export GroupIIOPProfile_out
  {
  public:
    GroupIIOPProfile_out (GroupIIOPProfile *&);
    GroupIIOPProfile_out (GroupIIOPProfile_var &);
    GroupIIOPProfile_out (const GroupIIOPProfile_out &);
    GroupIIOPProfile_out &operator= (const GroupIIOPProfile_out &);
    GroupIIOPProfile_out &operator= (GroupIIOPProfile *);
    operator GroupIIOPProfile *&();
    GroupIIOPProfile *&ptr (void);
    GroupIIOPProfile *operator-> (void);
    CORBA::Octet & operator[] (CORBA::ULong index);
    
  private:
    GroupIIOPProfile *&ptr_;
    // assignment from T_var not allowed
    void operator= (const GroupIIOPProfile_var &);
  };


#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_GroupIIOPProfile;

  class GenericFactory;
  
#if !defined (_PORTABLEGROUP_GENERICFACTORY___PTR_CH_)
#define _PORTABLEGROUP_GENERICFACTORY___PTR_CH_

  typedef GenericFactory *GenericFactory_ptr;

#endif /* end #if !defined */


#if !defined (_PORTABLEGROUP_GENERICFACTORY___VAR_CH_)
#define _PORTABLEGROUP_GENERICFACTORY___VAR_CH_

  class TAO_PortableGroup_Export GenericFactory_var : public TAO_Base_var
  {
  public:
    GenericFactory_var (void); // default constructor
    GenericFactory_var (GenericFactory_ptr p) : ptr_ (p) {} 
    GenericFactory_var (const GenericFactory_var &); // copy constructor
    ~GenericFactory_var (void); // destructor
    
    GenericFactory_var &operator= (GenericFactory_ptr);
    GenericFactory_var &operator= (const GenericFactory_var &);
    GenericFactory_ptr operator-> (void) const;
    
    operator const GenericFactory_ptr &() const;
    operator GenericFactory_ptr &();
    // in, inout, out, _retn 
    GenericFactory_ptr in (void) const;
    GenericFactory_ptr &inout (void);
    GenericFactory_ptr &out (void);
    GenericFactory_ptr _retn (void);
    GenericFactory_ptr ptr (void) const;
    
    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static GenericFactory_ptr duplicate (GenericFactory_ptr);
    static void release (GenericFactory_ptr);
    static GenericFactory_ptr nil (void);
    static GenericFactory_ptr narrow (CORBA::Object *, CORBA::Environment &);
    static CORBA::Object * upcast (void *);
  
  private:
    GenericFactory_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    GenericFactory_var (const TAO_Base_var &rhs);
    GenericFactory_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_PORTABLEGROUP_GENERICFACTORY___OUT_CH_)
#define _PORTABLEGROUP_GENERICFACTORY___OUT_CH_

  class TAO_PortableGroup_Export GenericFactory_out
  {
  public:
    GenericFactory_out (GenericFactory_ptr &);
    GenericFactory_out (GenericFactory_var &);
    GenericFactory_out (const GenericFactory_out &);
    GenericFactory_out &operator= (const GenericFactory_out &);
    GenericFactory_out &operator= (const GenericFactory_var &);
    GenericFactory_out &operator= (GenericFactory_ptr);
    operator GenericFactory_ptr &();
    GenericFactory_ptr &ptr (void);
    GenericFactory_ptr operator-> (void);
  
  private:
    GenericFactory_ptr &ptr_;
  };


#endif /* end #if !defined */

  typedef char * TypeId;
  typedef CORBA::String_var TypeId_var;
  typedef CORBA::String_out TypeId_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_TypeId;

  typedef CORBA::Object ObjectGroup;
  typedef CORBA::Object_ptr ObjectGroup_ptr;
  typedef CORBA::Object_var ObjectGroup_var;
  typedef CORBA::Object_out ObjectGroup_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ObjectGroup;

  typedef CosNaming::Name Name;
  typedef CosNaming::Name_var Name_var;
  typedef CosNaming::Name_out Name_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Name;

  typedef CORBA::Any Value;
  typedef CORBA::Any_ptr Value_ptr;
  typedef CORBA::Any_var Value_var;
  typedef CORBA::Any_out Value_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Value;

  struct Property;
  class Property_var;
  
  struct TAO_PortableGroup_Export Property
  {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef Property_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

    static void _tao_any_destructor (void*);

    ACE_NESTED_CLASS (PortableGroup, Name) nam;
    ACE_NESTED_CLASS (PortableGroup, Value) val;
  };

  class TAO_PortableGroup_Export Property_var
  {
  public:
    Property_var (void); // default constructor
    Property_var (Property *);
    Property_var (const Property_var &); // copy constructor
    ~Property_var (void); // destructor
    
    Property_var &operator= (Property *);
    Property_var &operator= (const Property_var &);
    Property *operator-> (void);
    const Property *operator-> (void) const;
    
    operator const Property &() const;
    operator Property &();
    operator Property &() const;
    operator Property *&(); // variable-size types only
    
    // in, inout, out, _retn 
    const Property &in (void) const;
    Property &inout (void);
    Property *&out (void);
    Property *_retn (void);
    Property *ptr (void) const;

  private:
    Property *ptr_;
  };

  class TAO_PortableGroup_Export Property_out
  {
  public:
    Property_out (Property *&);
    Property_out (Property_var &);
    Property_out (const Property_out &);
    Property_out &operator= (const Property_out &);
    Property_out &operator= (Property *);
    operator Property *&();
    Property *&ptr (void);
    Property *operator-> (void);
    
  private:
    Property *&ptr_;
    // assignment from T_var not allowed
    void operator= (const Property_var &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Property;


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    
#if !defined (__TAO_UNBOUNDED_SEQUENCE_PORTABLEGROUP_PROPERTIES_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_PORTABLEGROUP_PROPERTIES_CH_

    class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_PortableGroup_Properties : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.
      
      _TAO_Unbounded_Sequence_PortableGroup_Properties (void); // Default constructor.
      _TAO_Unbounded_Sequence_PortableGroup_Properties (CORBA::ULong maximum); 
      _TAO_Unbounded_Sequence_PortableGroup_Properties (CORBA::ULong maximum,
        CORBA::ULong length,
        Property *data,
        CORBA::Boolean release = 0);
      _TAO_Unbounded_Sequence_PortableGroup_Properties (const _TAO_Unbounded_Sequence_PortableGroup_Properties &rhs);
      _TAO_Unbounded_Sequence_PortableGroup_Properties &operator= (const _TAO_Unbounded_Sequence_PortableGroup_Properties &rhs);
      virtual ~_TAO_Unbounded_Sequence_PortableGroup_Properties (void); // Dtor.
      // = Accessors.
      Property &operator[] (CORBA::ULong i);
      const Property &operator[] (CORBA::ULong i) const;
      // = Static operations.
      static Property *allocbuf (CORBA::ULong size);
      static void freebuf (Property *buffer);
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      // Implement the TAO_Base_Sequence methods (see Sequence.h)
      
      Property *get_buffer (CORBA::Boolean orphan = 0);
      const Property *get_buffer (void) const;
      void replace (CORBA::ULong max,
        CORBA::ULong length,
        Property *data,
        CORBA::Boolean release);
    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  
#if !defined (_PORTABLEGROUP_PROPERTIES_CH_)
#define _PORTABLEGROUP_PROPERTIES_CH_

  class Properties;
  class Properties_var;
  
  // *************************************************************
  // Properties
  // *************************************************************
  
  class TAO_PortableGroup_Export Properties : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Sequence_PortableGroup_Properties
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Sequence<Property>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  {
  public:
    Properties (void); // default ctor
    Properties (CORBA::ULong max); // uses max size
    Properties (
      CORBA::ULong max, 
      CORBA::ULong length, 
      Property *buffer, 
      CORBA::Boolean release = 0
    );
    Properties (const Properties &); // copy ctor
    ~Properties (void);
    static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef Properties_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  };
  
#endif /* end #if !defined */


#if !defined (_PORTABLEGROUP_PROPERTIES___VAR_CH_)
#define _PORTABLEGROUP_PROPERTIES___VAR_CH_

  // *************************************************************
  // class PortableGroup::Properties_var
  // *************************************************************

  class TAO_PortableGroup_Export Properties_var
  {
  public:
    Properties_var (void); // default constructor
    Properties_var (Properties *);
    Properties_var (const Properties_var &); // copy constructor
    ~Properties_var (void); // destructor
    
    Properties_var &operator= (Properties *);
    Properties_var &operator= (const Properties_var &);
    Properties *operator-> (void);
    const Properties *operator-> (void) const;
    
    operator const Properties &() const;
    operator Properties &();
    operator Properties &() const;
    operator Properties *&(); // variable-size base types only
    
    Property & operator[] (CORBA::ULong index);
    const Property & operator[] (CORBA::ULong index) const;
    
    // in, inout, out, _retn 
    const Properties &in (void) const;
    Properties &inout (void);
    Properties *&out (void);
    Properties *_retn (void);
    Properties *ptr (void) const;

  private:
    Properties *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_PORTABLEGROUP_PROPERTIES___OUT_CH_)
#define _PORTABLEGROUP_PROPERTIES___OUT_CH_

  class TAO_PortableGroup_Export Properties_out
  {
  public:
    Properties_out (Properties *&);
    Properties_out (Properties_var &);
    Properties_out (const Properties_out &);
    Properties_out &operator= (const Properties_out &);
    Properties_out &operator= (Properties *);
    operator Properties *&();
    Properties *&ptr (void);
    Properties *operator-> (void);
    Property & operator[] (CORBA::ULong index);
    
  private:
    Properties *&ptr_;
    // assignment from T_var not allowed
    void operator= (const Properties_var &);
  };


#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Properties;

  typedef Name Location;
  typedef Name_var Location_var;
  typedef Name_out Location_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Location;


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    
#if !defined (__TAO_UNBOUNDED_SEQUENCE_PORTABLEGROUP_LOCATIONS_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_PORTABLEGROUP_LOCATIONS_CH_

    class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_PortableGroup_Locations : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.
      
      _TAO_Unbounded_Sequence_PortableGroup_Locations (void); // Default constructor.
      _TAO_Unbounded_Sequence_PortableGroup_Locations (CORBA::ULong maximum); 
      _TAO_Unbounded_Sequence_PortableGroup_Locations (CORBA::ULong maximum,
        CORBA::ULong length,
        Location *data,
        CORBA::Boolean release = 0);
      _TAO_Unbounded_Sequence_PortableGroup_Locations (const _TAO_Unbounded_Sequence_PortableGroup_Locations &rhs);
      _TAO_Unbounded_Sequence_PortableGroup_Locations &operator= (const _TAO_Unbounded_Sequence_PortableGroup_Locations &rhs);
      virtual ~_TAO_Unbounded_Sequence_PortableGroup_Locations (void); // Dtor.
      // = Accessors.
      Location &operator[] (CORBA::ULong i);
      const Location &operator[] (CORBA::ULong i) const;
      // = Static operations.
      static Location *allocbuf (CORBA::ULong size);
      static void freebuf (Location *buffer);
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      // Implement the TAO_Base_Sequence methods (see Sequence.h)
      
      Location *get_buffer (CORBA::Boolean orphan = 0);
      const Location *get_buffer (void) const;
      void replace (CORBA::ULong max,
        CORBA::ULong length,
        Location *data,
        CORBA::Boolean release);
    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  
#if !defined (_PORTABLEGROUP_LOCATIONS_CH_)
#define _PORTABLEGROUP_LOCATIONS_CH_

  class Locations;
  class Locations_var;
  
  // *************************************************************
  // Locations
  // *************************************************************
  
  class TAO_PortableGroup_Export Locations : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Sequence_PortableGroup_Locations
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Sequence<Location>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  {
  public:
    Locations (void); // default ctor
    Locations (CORBA::ULong max); // uses max size
    Locations (
      CORBA::ULong max, 
      CORBA::ULong length, 
      Location *buffer, 
      CORBA::Boolean release = 0
    );
    Locations (const Locations &); // copy ctor
    ~Locations (void);
    static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef Locations_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  };
  
#endif /* end #if !defined */


#if !defined (_PORTABLEGROUP_LOCATIONS___VAR_CH_)
#define _PORTABLEGROUP_LOCATIONS___VAR_CH_

  // *************************************************************
  // class PortableGroup::Locations_var
  // *************************************************************

  class TAO_PortableGroup_Export Locations_var
  {
  public:
    Locations_var (void); // default constructor
    Locations_var (Locations *);
    Locations_var (const Locations_var &); // copy constructor
    ~Locations_var (void); // destructor
    
    Locations_var &operator= (Locations *);
    Locations_var &operator= (const Locations_var &);
    Locations *operator-> (void);
    const Locations *operator-> (void) const;
    
    operator const Locations &() const;
    operator Locations &();
    operator Locations &() const;
    operator Locations *&(); // variable-size base types only
    
    Location & operator[] (CORBA::ULong index);
    const Location & operator[] (CORBA::ULong index) const;
    
    // in, inout, out, _retn 
    const Locations &in (void) const;
    Locations &inout (void);
    Locations *&out (void);
    Locations *_retn (void);
    Locations *ptr (void) const;

  private:
    Locations *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_PORTABLEGROUP_LOCATIONS___OUT_CH_)
#define _PORTABLEGROUP_LOCATIONS___OUT_CH_

  class TAO_PortableGroup_Export Locations_out
  {
  public:
    Locations_out (Locations *&);
    Locations_out (Locations_var &);
    Locations_out (const Locations_out &);
    Locations_out &operator= (const Locations_out &);
    Locations_out &operator= (Locations *);
    operator Locations *&();
    Locations *&ptr (void);
    Locations *operator-> (void);
    Location & operator[] (CORBA::ULong index);
    
  private:
    Locations *&ptr_;
    // assignment from T_var not allowed
    void operator= (const Locations_var &);
  };


#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Locations;

  typedef Properties Criteria;
  typedef Properties_var Criteria_var;
  typedef Properties_out Criteria_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Criteria;

  struct FactoryInfo;
  class FactoryInfo_var;
  
  struct TAO_PortableGroup_Export FactoryInfo
  {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef FactoryInfo_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

        ACE_NESTED_CLASS (PortableGroup, GenericFactory_var) the_factory;
    ACE_NESTED_CLASS (PortableGroup, Location) the_location;
    ACE_NESTED_CLASS (PortableGroup, Criteria) the_criteria;
  };

  class TAO_PortableGroup_Export FactoryInfo_var
  {
  public:
    FactoryInfo_var (void); // default constructor
    FactoryInfo_var (FactoryInfo *);
    FactoryInfo_var (const FactoryInfo_var &); // copy constructor
    ~FactoryInfo_var (void); // destructor
    
    FactoryInfo_var &operator= (FactoryInfo *);
    FactoryInfo_var &operator= (const FactoryInfo_var &);
    FactoryInfo *operator-> (void);
    const FactoryInfo *operator-> (void) const;
    
    operator const FactoryInfo &() const;
    operator FactoryInfo &();
    operator FactoryInfo &() const;
    operator FactoryInfo *&(); // variable-size types only
    
    // in, inout, out, _retn 
    const FactoryInfo &in (void) const;
    FactoryInfo &inout (void);
    FactoryInfo *&out (void);
    FactoryInfo *_retn (void);
    FactoryInfo *ptr (void) const;

  private:
    FactoryInfo *ptr_;
  };

  class TAO_PortableGroup_Export FactoryInfo_out
  {
  public:
    FactoryInfo_out (FactoryInfo *&);
    FactoryInfo_out (FactoryInfo_var &);
    FactoryInfo_out (const FactoryInfo_out &);
    FactoryInfo_out &operator= (const FactoryInfo_out &);
    FactoryInfo_out &operator= (FactoryInfo *);
    operator FactoryInfo *&();
    FactoryInfo *&ptr (void);
    FactoryInfo *operator-> (void);
    
  private:
    FactoryInfo *&ptr_;
    // assignment from T_var not allowed
    void operator= (const FactoryInfo_var &);
  };


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    
#if !defined (__TAO_UNBOUNDED_SEQUENCE_PORTABLEGROUP_FACTORYINFOS_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_PORTABLEGROUP_FACTORYINFOS_CH_

    class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_PortableGroup_FactoryInfos : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.
      
      _TAO_Unbounded_Sequence_PortableGroup_FactoryInfos (void); // Default constructor.
      _TAO_Unbounded_Sequence_PortableGroup_FactoryInfos (CORBA::ULong maximum); 
      _TAO_Unbounded_Sequence_PortableGroup_FactoryInfos (CORBA::ULong maximum,
        CORBA::ULong length,
        FactoryInfo *data,
        CORBA::Boolean release = 0);
      _TAO_Unbounded_Sequence_PortableGroup_FactoryInfos (const _TAO_Unbounded_Sequence_PortableGroup_FactoryInfos &rhs);
      _TAO_Unbounded_Sequence_PortableGroup_FactoryInfos &operator= (const _TAO_Unbounded_Sequence_PortableGroup_FactoryInfos &rhs);
      virtual ~_TAO_Unbounded_Sequence_PortableGroup_FactoryInfos (void); // Dtor.
      // = Accessors.
      FactoryInfo &operator[] (CORBA::ULong i);
      const FactoryInfo &operator[] (CORBA::ULong i) const;
      // = Static operations.
      static FactoryInfo *allocbuf (CORBA::ULong size);
      static void freebuf (FactoryInfo *buffer);
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      // Implement the TAO_Base_Sequence methods (see Sequence.h)
      
      FactoryInfo *get_buffer (CORBA::Boolean orphan = 0);
      const FactoryInfo *get_buffer (void) const;
      void replace (CORBA::ULong max,
        CORBA::ULong length,
        FactoryInfo *data,
        CORBA::Boolean release);
    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  
#if !defined (_PORTABLEGROUP_FACTORYINFOS_CH_)
#define _PORTABLEGROUP_FACTORYINFOS_CH_

  class FactoryInfos;
  class FactoryInfos_var;
  
  // *************************************************************
  // FactoryInfos
  // *************************************************************
  
  class TAO_PortableGroup_Export FactoryInfos : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Sequence_PortableGroup_FactoryInfos
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Sequence<FactoryInfo>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  {
  public:
    FactoryInfos (void); // default ctor
    FactoryInfos (CORBA::ULong max); // uses max size
    FactoryInfos (
      CORBA::ULong max, 
      CORBA::ULong length, 
      FactoryInfo *buffer, 
      CORBA::Boolean release = 0
    );
    FactoryInfos (const FactoryInfos &); // copy ctor
    ~FactoryInfos (void);
    static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef FactoryInfos_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  };
  
#endif /* end #if !defined */


#if !defined (_PORTABLEGROUP_FACTORYINFOS___VAR_CH_)
#define _PORTABLEGROUP_FACTORYINFOS___VAR_CH_

  // *************************************************************
  // class PortableGroup::FactoryInfos_var
  // *************************************************************

  class TAO_PortableGroup_Export FactoryInfos_var
  {
  public:
    FactoryInfos_var (void); // default constructor
    FactoryInfos_var (FactoryInfos *);
    FactoryInfos_var (const FactoryInfos_var &); // copy constructor
    ~FactoryInfos_var (void); // destructor
    
    FactoryInfos_var &operator= (FactoryInfos *);
    FactoryInfos_var &operator= (const FactoryInfos_var &);
    FactoryInfos *operator-> (void);
    const FactoryInfos *operator-> (void) const;
    
    operator const FactoryInfos &() const;
    operator FactoryInfos &();
    operator FactoryInfos &() const;
    operator FactoryInfos *&(); // variable-size base types only
    
    FactoryInfo & operator[] (CORBA::ULong index);
    const FactoryInfo & operator[] (CORBA::ULong index) const;
    
    // in, inout, out, _retn 
    const FactoryInfos &in (void) const;
    FactoryInfos &inout (void);
    FactoryInfos *&out (void);
    FactoryInfos *_retn (void);
    FactoryInfos *ptr (void) const;

  private:
    FactoryInfos *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_PORTABLEGROUP_FACTORYINFOS___OUT_CH_)
#define _PORTABLEGROUP_FACTORYINFOS___OUT_CH_

  class TAO_PortableGroup_Export FactoryInfos_out
  {
  public:
    FactoryInfos_out (FactoryInfos *&);
    FactoryInfos_out (FactoryInfos_var &);
    FactoryInfos_out (const FactoryInfos_out &);
    FactoryInfos_out &operator= (const FactoryInfos_out &);
    FactoryInfos_out &operator= (FactoryInfos *);
    operator FactoryInfos *&();
    FactoryInfos *&ptr (void);
    FactoryInfos *operator-> (void);
    FactoryInfo & operator[] (CORBA::ULong index);
    
  private:
    FactoryInfos *&ptr_;
    // assignment from T_var not allowed
    void operator= (const FactoryInfos_var &);
  };


#endif /* end #if !defined */

  typedef CORBA::Long MembershipStyleValue;
  typedef CORBA::Long_out MembershipStyleValue_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_MembershipStyleValue;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Long MEMB_APP_CTRL;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Long MEMB_INF_CTRL;

  typedef CORBA::UShort InitialNumberReplicasValue;
  typedef CORBA::UShort_out InitialNumberReplicasValue_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_InitialNumberReplicasValue;

  typedef CORBA::UShort MinimumNumberReplicasValue;
  typedef CORBA::UShort_out MinimumNumberReplicasValue_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_MinimumNumberReplicasValue;


#if !defined (_PORTABLEGROUP_INTERFACENOTFOUND_CH_)
#define _PORTABLEGROUP_INTERFACENOTFOUND_CH_

  class TAO_PortableGroup_Export InterfaceNotFound : public CORBA::UserException
  {
  public:

    InterfaceNotFound (void);
    // Default constructor.
    
    InterfaceNotFound (const InterfaceNotFound &);
    // Copy constructor.
    
    ~InterfaceNotFound (void);
    // Destructor.
    
    static void _tao_any_destructor (void*);
    
    InterfaceNotFound &operator= (const InterfaceNotFound &);
    
    virtual void _raise (void);

    virtual void _tao_encode (
        TAO_OutputCDR &,
        CORBA::Environment &
      ) const;
    
    virtual void _tao_decode (
        TAO_InputCDR &,
        CORBA::Environment &
      );
    
    static InterfaceNotFound *_downcast (CORBA::Exception *);


    // = TAO extension.
    static CORBA::Exception *_alloc (void);
    virtual CORBA::TypeCode_ptr _type (void) const;
  }; // Exception PortableGroup::InterfaceNotFound.

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_InterfaceNotFound;


#endif /* end #if !defined */


#if !defined (_PORTABLEGROUP_OBJECTGROUPNOTFOUND_CH_)
#define _PORTABLEGROUP_OBJECTGROUPNOTFOUND_CH_

  class TAO_PortableGroup_Export ObjectGroupNotFound : public CORBA::UserException
  {
  public:

    ObjectGroupNotFound (void);
    // Default constructor.
    
    ObjectGroupNotFound (const ObjectGroupNotFound &);
    // Copy constructor.
    
    ~ObjectGroupNotFound (void);
    // Destructor.
    
    static void _tao_any_destructor (void*);
    
    ObjectGroupNotFound &operator= (const ObjectGroupNotFound &);
    
    virtual void _raise (void);

    virtual void _tao_encode (
        TAO_OutputCDR &,
        CORBA::Environment &
      ) const;
    
    virtual void _tao_decode (
        TAO_InputCDR &,
        CORBA::Environment &
      );
    
    static ObjectGroupNotFound *_downcast (CORBA::Exception *);


    // = TAO extension.
    static CORBA::Exception *_alloc (void);
    virtual CORBA::TypeCode_ptr _type (void) const;
  }; // Exception PortableGroup::ObjectGroupNotFound.

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ObjectGroupNotFound;


#endif /* end #if !defined */


#if !defined (_PORTABLEGROUP_MEMBERNOTFOUND_CH_)
#define _PORTABLEGROUP_MEMBERNOTFOUND_CH_

  class TAO_PortableGroup_Export MemberNotFound : public CORBA::UserException
  {
  public:

    MemberNotFound (void);
    // Default constructor.
    
    MemberNotFound (const MemberNotFound &);
    // Copy constructor.
    
    ~MemberNotFound (void);
    // Destructor.
    
    static void _tao_any_destructor (void*);
    
    MemberNotFound &operator= (const MemberNotFound &);
    
    virtual void _raise (void);

    virtual void _tao_encode (
        TAO_OutputCDR &,
        CORBA::Environment &
      ) const;
    
    virtual void _tao_decode (
        TAO_InputCDR &,
        CORBA::Environment &
      );
    
    static MemberNotFound *_downcast (CORBA::Exception *);


    // = TAO extension.
    static CORBA::Exception *_alloc (void);
    virtual CORBA::TypeCode_ptr _type (void) const;
  }; // Exception PortableGroup::MemberNotFound.

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_MemberNotFound;


#endif /* end #if !defined */


#if !defined (_PORTABLEGROUP_OBJECTNOTFOUND_CH_)
#define _PORTABLEGROUP_OBJECTNOTFOUND_CH_

  class TAO_PortableGroup_Export ObjectNotFound : public CORBA::UserException
  {
  public:

    ObjectNotFound (void);
    // Default constructor.
    
    ObjectNotFound (const ObjectNotFound &);
    // Copy constructor.
    
    ~ObjectNotFound (void);
    // Destructor.
    
    static void _tao_any_destructor (void*);
    
    ObjectNotFound &operator= (const ObjectNotFound &);
    
    virtual void _raise (void);

    virtual void _tao_encode (
        TAO_OutputCDR &,
        CORBA::Environment &
      ) const;
    
    virtual void _tao_decode (
        TAO_InputCDR &,
        CORBA::Environment &
      );
    
    static ObjectNotFound *_downcast (CORBA::Exception *);


    // = TAO extension.
    static CORBA::Exception *_alloc (void);
    virtual CORBA::TypeCode_ptr _type (void) const;
  }; // Exception PortableGroup::ObjectNotFound.

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ObjectNotFound;


#endif /* end #if !defined */


#if !defined (_PORTABLEGROUP_MEMBERALREADYPRESENT_CH_)
#define _PORTABLEGROUP_MEMBERALREADYPRESENT_CH_

  class TAO_PortableGroup_Export MemberAlreadyPresent : public CORBA::UserException
  {
  public:

    MemberAlreadyPresent (void);
    // Default constructor.
    
    MemberAlreadyPresent (const MemberAlreadyPresent &);
    // Copy constructor.
    
    ~MemberAlreadyPresent (void);
    // Destructor.
    
    static void _tao_any_destructor (void*);
    
    MemberAlreadyPresent &operator= (const MemberAlreadyPresent &);
    
    virtual void _raise (void);

    virtual void _tao_encode (
        TAO_OutputCDR &,
        CORBA::Environment &
      ) const;
    
    virtual void _tao_decode (
        TAO_InputCDR &,
        CORBA::Environment &
      );
    
    static MemberAlreadyPresent *_downcast (CORBA::Exception *);


    // = TAO extension.
    static CORBA::Exception *_alloc (void);
    virtual CORBA::TypeCode_ptr _type (void) const;
  }; // Exception PortableGroup::MemberAlreadyPresent.

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_MemberAlreadyPresent;


#endif /* end #if !defined */


#if !defined (_PORTABLEGROUP_BADREPLICATIONSTYLE_CH_)
#define _PORTABLEGROUP_BADREPLICATIONSTYLE_CH_

  class TAO_PortableGroup_Export BadReplicationStyle : public CORBA::UserException
  {
  public:

    BadReplicationStyle (void);
    // Default constructor.
    
    BadReplicationStyle (const BadReplicationStyle &);
    // Copy constructor.
    
    ~BadReplicationStyle (void);
    // Destructor.
    
    static void _tao_any_destructor (void*);
    
    BadReplicationStyle &operator= (const BadReplicationStyle &);
    
    virtual void _raise (void);

    virtual void _tao_encode (
        TAO_OutputCDR &,
        CORBA::Environment &
      ) const;
    
    virtual void _tao_decode (
        TAO_InputCDR &,
        CORBA::Environment &
      );
    
    static BadReplicationStyle *_downcast (CORBA::Exception *);


    // = TAO extension.
    static CORBA::Exception *_alloc (void);
    virtual CORBA::TypeCode_ptr _type (void) const;
  }; // Exception PortableGroup::BadReplicationStyle.

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_BadReplicationStyle;


#endif /* end #if !defined */


#if !defined (_PORTABLEGROUP_OBJECTNOTCREATED_CH_)
#define _PORTABLEGROUP_OBJECTNOTCREATED_CH_

  class TAO_PortableGroup_Export ObjectNotCreated : public CORBA::UserException
  {
  public:

    ObjectNotCreated (void);
    // Default constructor.
    
    ObjectNotCreated (const ObjectNotCreated &);
    // Copy constructor.
    
    ~ObjectNotCreated (void);
    // Destructor.
    
    static void _tao_any_destructor (void*);
    
    ObjectNotCreated &operator= (const ObjectNotCreated &);
    
    virtual void _raise (void);

    virtual void _tao_encode (
        TAO_OutputCDR &,
        CORBA::Environment &
      ) const;
    
    virtual void _tao_decode (
        TAO_InputCDR &,
        CORBA::Environment &
      );
    
    static ObjectNotCreated *_downcast (CORBA::Exception *);


    // = TAO extension.
    static CORBA::Exception *_alloc (void);
    virtual CORBA::TypeCode_ptr _type (void) const;
  }; // Exception PortableGroup::ObjectNotCreated.

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ObjectNotCreated;


#endif /* end #if !defined */


#if !defined (_PORTABLEGROUP_OBJECTNOTADDED_CH_)
#define _PORTABLEGROUP_OBJECTNOTADDED_CH_

  class TAO_PortableGroup_Export ObjectNotAdded : public CORBA::UserException
  {
  public:

    ObjectNotAdded (void);
    // Default constructor.
    
    ObjectNotAdded (const ObjectNotAdded &);
    // Copy constructor.
    
    ~ObjectNotAdded (void);
    // Destructor.
    
    static void _tao_any_destructor (void*);
    
    ObjectNotAdded &operator= (const ObjectNotAdded &);
    
    virtual void _raise (void);

    virtual void _tao_encode (
        TAO_OutputCDR &,
        CORBA::Environment &
      ) const;
    
    virtual void _tao_decode (
        TAO_InputCDR &,
        CORBA::Environment &
      );
    
    static ObjectNotAdded *_downcast (CORBA::Exception *);


    // = TAO extension.
    static CORBA::Exception *_alloc (void);
    virtual CORBA::TypeCode_ptr _type (void) const;
  }; // Exception PortableGroup::ObjectNotAdded.

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ObjectNotAdded;


#endif /* end #if !defined */


#if !defined (_PORTABLEGROUP_UNSUPPORTEDPROPERTY_CH_)
#define _PORTABLEGROUP_UNSUPPORTEDPROPERTY_CH_

  class TAO_PortableGroup_Export UnsupportedProperty : public CORBA::UserException
  {
  public:
    ACE_NESTED_CLASS (PortableGroup, Name) nam;

    UnsupportedProperty (void);
    // Default constructor.
    
    UnsupportedProperty (const UnsupportedProperty &);
    // Copy constructor.
    
    ~UnsupportedProperty (void);
    // Destructor.
    
    static void _tao_any_destructor (void*);
    
    UnsupportedProperty &operator= (const UnsupportedProperty &);
    
    virtual void _raise (void);

    virtual void _tao_encode (
        TAO_OutputCDR &,
        CORBA::Environment &
      ) const;
    
    virtual void _tao_decode (
        TAO_InputCDR &,
        CORBA::Environment &
      );
    
    static UnsupportedProperty *_downcast (CORBA::Exception *);

    UnsupportedProperty (
        const ACE_NESTED_CLASS (PortableGroup, Name) & _tao_nam
      );
    
    // = TAO extension.
    static CORBA::Exception *_alloc (void);
    virtual CORBA::TypeCode_ptr _type (void) const;
  }; // Exception PortableGroup::UnsupportedProperty.

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_UnsupportedProperty;


#endif /* end #if !defined */


#if !defined (_PORTABLEGROUP_INVALIDPROPERTY_CH_)
#define _PORTABLEGROUP_INVALIDPROPERTY_CH_

  class TAO_PortableGroup_Export InvalidProperty : public CORBA::UserException
  {
  public:
    ACE_NESTED_CLASS (PortableGroup, Name) nam;
    ACE_NESTED_CLASS (PortableGroup, Value) val;

    InvalidProperty (void);
    // Default constructor.
    
    InvalidProperty (const InvalidProperty &);
    // Copy constructor.
    
    ~InvalidProperty (void);
    // Destructor.
    
    static void _tao_any_destructor (void*);
    
    InvalidProperty &operator= (const InvalidProperty &);
    
    virtual void _raise (void);

    virtual void _tao_encode (
        TAO_OutputCDR &,
        CORBA::Environment &
      ) const;
    
    virtual void _tao_decode (
        TAO_InputCDR &,
        CORBA::Environment &
      );
    
    static InvalidProperty *_downcast (CORBA::Exception *);

    InvalidProperty (
        const ACE_NESTED_CLASS (PortableGroup, Name) & _tao_nam,
        const ACE_NESTED_CLASS (PortableGroup, Value) & _tao_val
      );
    
    // = TAO extension.
    static CORBA::Exception *_alloc (void);
    virtual CORBA::TypeCode_ptr _type (void) const;
  }; // Exception PortableGroup::InvalidProperty.

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_InvalidProperty;


#endif /* end #if !defined */


#if !defined (_PORTABLEGROUP_NOFACTORY_CH_)
#define _PORTABLEGROUP_NOFACTORY_CH_

  class TAO_PortableGroup_Export NoFactory : public CORBA::UserException
  {
  public:
    ACE_NESTED_CLASS (PortableGroup, Location) the_location;
    TAO_String_Manager type_id;

    NoFactory (void);
    // Default constructor.
    
    NoFactory (const NoFactory &);
    // Copy constructor.
    
    ~NoFactory (void);
    // Destructor.
    
    static void _tao_any_destructor (void*);
    
    NoFactory &operator= (const NoFactory &);
    
    virtual void _raise (void);

    virtual void _tao_encode (
        TAO_OutputCDR &,
        CORBA::Environment &
      ) const;
    
    virtual void _tao_decode (
        TAO_InputCDR &,
        CORBA::Environment &
      );
    
    static NoFactory *_downcast (CORBA::Exception *);

    NoFactory (
        const ACE_NESTED_CLASS (PortableGroup, Location) & _tao_the_location,
        const char * _tao_type_id
      );
    
    // = TAO extension.
    static CORBA::Exception *_alloc (void);
    virtual CORBA::TypeCode_ptr _type (void) const;
  }; // Exception PortableGroup::NoFactory.

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_NoFactory;


#endif /* end #if !defined */


#if !defined (_PORTABLEGROUP_INVALIDCRITERIA_CH_)
#define _PORTABLEGROUP_INVALIDCRITERIA_CH_

  class TAO_PortableGroup_Export InvalidCriteria : public CORBA::UserException
  {
  public:
    ACE_NESTED_CLASS (PortableGroup, Criteria) invalid_criteria;

    InvalidCriteria (void);
    // Default constructor.
    
    InvalidCriteria (const InvalidCriteria &);
    // Copy constructor.
    
    ~InvalidCriteria (void);
    // Destructor.
    
    static void _tao_any_destructor (void*);
    
    InvalidCriteria &operator= (const InvalidCriteria &);
    
    virtual void _raise (void);

    virtual void _tao_encode (
        TAO_OutputCDR &,
        CORBA::Environment &
      ) const;
    
    virtual void _tao_decode (
        TAO_InputCDR &,
        CORBA::Environment &
      );
    
    static InvalidCriteria *_downcast (CORBA::Exception *);

    InvalidCriteria (
        const ACE_NESTED_CLASS (PortableGroup, Criteria) & _tao_invalid_criteria
      );
    
    // = TAO extension.
    static CORBA::Exception *_alloc (void);
    virtual CORBA::TypeCode_ptr _type (void) const;
  }; // Exception PortableGroup::InvalidCriteria.

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_InvalidCriteria;


#endif /* end #if !defined */


#if !defined (_PORTABLEGROUP_CANNOTMEETCRITERIA_CH_)
#define _PORTABLEGROUP_CANNOTMEETCRITERIA_CH_

  class TAO_PortableGroup_Export CannotMeetCriteria : public CORBA::UserException
  {
  public:
    ACE_NESTED_CLASS (PortableGroup, Criteria) unmet_criteria;

    CannotMeetCriteria (void);
    // Default constructor.
    
    CannotMeetCriteria (const CannotMeetCriteria &);
    // Copy constructor.
    
    ~CannotMeetCriteria (void);
    // Destructor.
    
    static void _tao_any_destructor (void*);
    
    CannotMeetCriteria &operator= (const CannotMeetCriteria &);
    
    virtual void _raise (void);

    virtual void _tao_encode (
        TAO_OutputCDR &,
        CORBA::Environment &
      ) const;
    
    virtual void _tao_decode (
        TAO_InputCDR &,
        CORBA::Environment &
      );
    
    static CannotMeetCriteria *_downcast (CORBA::Exception *);

    CannotMeetCriteria (
        const ACE_NESTED_CLASS (PortableGroup, Criteria) & _tao_unmet_criteria
      );
    
    // = TAO extension.
    static CORBA::Exception *_alloc (void);
    virtual CORBA::TypeCode_ptr _type (void) const;
  }; // Exception PortableGroup::CannotMeetCriteria.

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_CannotMeetCriteria;


#endif /* end #if !defined */


#if !defined (_PORTABLEGROUP_PROPERTYMANAGER___PTR_CH_)
#define _PORTABLEGROUP_PROPERTYMANAGER___PTR_CH_

  class PropertyManager;
  typedef PropertyManager *PropertyManager_ptr;
  
#endif /* end #if !defined */


#if !defined (_PORTABLEGROUP_PROPERTYMANAGER___VAR_CH_)
#define _PORTABLEGROUP_PROPERTYMANAGER___VAR_CH_

  class TAO_PortableGroup_Export PropertyManager_var : public TAO_Base_var
  {
  public:
    PropertyManager_var (void); // default constructor
    PropertyManager_var (PropertyManager_ptr p) : ptr_ (p) {} 
    PropertyManager_var (const PropertyManager_var &); // copy constructor
    ~PropertyManager_var (void); // destructor
    
    PropertyManager_var &operator= (PropertyManager_ptr);
    PropertyManager_var &operator= (const PropertyManager_var &);
    PropertyManager_ptr operator-> (void) const;
    
    operator const PropertyManager_ptr &() const;
    operator PropertyManager_ptr &();
    // in, inout, out, _retn 
    PropertyManager_ptr in (void) const;
    PropertyManager_ptr &inout (void);
    PropertyManager_ptr &out (void);
    PropertyManager_ptr _retn (void);
    PropertyManager_ptr ptr (void) const;
    
    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static PropertyManager_ptr duplicate (PropertyManager_ptr);
    static void release (PropertyManager_ptr);
    static PropertyManager_ptr nil (void);
    static PropertyManager_ptr narrow (CORBA::Object *, CORBA::Environment &);
    static CORBA::Object * upcast (void *);
  
  private:
    PropertyManager_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    PropertyManager_var (const TAO_Base_var &rhs);
    PropertyManager_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_PORTABLEGROUP_PROPERTYMANAGER___OUT_CH_)
#define _PORTABLEGROUP_PROPERTYMANAGER___OUT_CH_

  class TAO_PortableGroup_Export PropertyManager_out
  {
  public:
    PropertyManager_out (PropertyManager_ptr &);
    PropertyManager_out (PropertyManager_var &);
    PropertyManager_out (const PropertyManager_out &);
    PropertyManager_out &operator= (const PropertyManager_out &);
    PropertyManager_out &operator= (const PropertyManager_var &);
    PropertyManager_out &operator= (PropertyManager_ptr);
    operator PropertyManager_ptr &();
    PropertyManager_ptr &ptr (void);
    PropertyManager_ptr operator-> (void);
  
  private:
    PropertyManager_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_PORTABLEGROUP_PROPERTYMANAGER_CH_)
#define _PORTABLEGROUP_PROPERTYMANAGER_CH_

  class TAO_PortableGroup_Export PropertyManager : public virtual CORBA_Object
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef PropertyManager_ptr _ptr_type;
    typedef PropertyManager_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

    // the static operations
    static PropertyManager_ptr _duplicate (PropertyManager_ptr obj);
    static PropertyManager_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      );
    static PropertyManager_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      );
    static PropertyManager_ptr _nil (void)
      {
        return (PropertyManager_ptr)0;
      }

    virtual void set_default_properties (
        const PortableGroup::Properties & props,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException,
        PortableGroup::InvalidProperty,
        PortableGroup::UnsupportedProperty
      )) = 0;

    virtual PortableGroup::Properties * get_default_properties (
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void remove_default_properties (
        const PortableGroup::Properties & props,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException,
        PortableGroup::InvalidProperty,
        PortableGroup::UnsupportedProperty
      )) = 0;

    virtual void set_type_properties (
        const char * type_id,
        const PortableGroup::Properties & overrides,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException,
        PortableGroup::InvalidProperty,
        PortableGroup::UnsupportedProperty
      )) = 0;

    virtual PortableGroup::Properties * get_type_properties (
        const char * type_id,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void remove_type_properties (
        const char * type_id,
        const PortableGroup::Properties & props,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException,
        PortableGroup::InvalidProperty,
        PortableGroup::UnsupportedProperty
      )) = 0;

    virtual void set_properties_dynamically (
        PortableGroup::ObjectGroup_ptr object_group,
        const PortableGroup::Properties & overrides,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException,
        PortableGroup::ObjectGroupNotFound,
        PortableGroup::InvalidProperty,
        PortableGroup::UnsupportedProperty
      )) = 0;

    virtual PortableGroup::Properties * get_properties (
        PortableGroup::ObjectGroup_ptr object_group,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException,
        PortableGroup::ObjectGroupNotFound
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);
    
    virtual const char* _interface_repository_id (void) const;

  protected:
    PropertyManager ();
    
    virtual ~PropertyManager (void);
  private:
    PropertyManager (const PropertyManager &);
    void operator= (const PropertyManager &);
  };


#endif /* end #if !defined */


#if !defined (_PORTABLEGROUP_OBJECTGROUPMANAGER___PTR_CH_)
#define _PORTABLEGROUP_OBJECTGROUPMANAGER___PTR_CH_

  class ObjectGroupManager;
  typedef ObjectGroupManager *ObjectGroupManager_ptr;
  
#endif /* end #if !defined */


#if !defined (_PORTABLEGROUP_OBJECTGROUPMANAGER___VAR_CH_)
#define _PORTABLEGROUP_OBJECTGROUPMANAGER___VAR_CH_

  class TAO_PortableGroup_Export ObjectGroupManager_var : public TAO_Base_var
  {
  public:
    ObjectGroupManager_var (void); // default constructor
    ObjectGroupManager_var (ObjectGroupManager_ptr p) : ptr_ (p) {} 
    ObjectGroupManager_var (const ObjectGroupManager_var &); // copy constructor
    ~ObjectGroupManager_var (void); // destructor
    
    ObjectGroupManager_var &operator= (ObjectGroupManager_ptr);
    ObjectGroupManager_var &operator= (const ObjectGroupManager_var &);
    ObjectGroupManager_ptr operator-> (void) const;
    
    operator const ObjectGroupManager_ptr &() const;
    operator ObjectGroupManager_ptr &();
    // in, inout, out, _retn 
    ObjectGroupManager_ptr in (void) const;
    ObjectGroupManager_ptr &inout (void);
    ObjectGroupManager_ptr &out (void);
    ObjectGroupManager_ptr _retn (void);
    ObjectGroupManager_ptr ptr (void) const;
    
    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static ObjectGroupManager_ptr duplicate (ObjectGroupManager_ptr);
    static void release (ObjectGroupManager_ptr);
    static ObjectGroupManager_ptr nil (void);
    static ObjectGroupManager_ptr narrow (CORBA::Object *, CORBA::Environment &);
    static CORBA::Object * upcast (void *);
  
  private:
    ObjectGroupManager_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    ObjectGroupManager_var (const TAO_Base_var &rhs);
    ObjectGroupManager_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_PORTABLEGROUP_OBJECTGROUPMANAGER___OUT_CH_)
#define _PORTABLEGROUP_OBJECTGROUPMANAGER___OUT_CH_

  class TAO_PortableGroup_Export ObjectGroupManager_out
  {
  public:
    ObjectGroupManager_out (ObjectGroupManager_ptr &);
    ObjectGroupManager_out (ObjectGroupManager_var &);
    ObjectGroupManager_out (const ObjectGroupManager_out &);
    ObjectGroupManager_out &operator= (const ObjectGroupManager_out &);
    ObjectGroupManager_out &operator= (const ObjectGroupManager_var &);
    ObjectGroupManager_out &operator= (ObjectGroupManager_ptr);
    operator ObjectGroupManager_ptr &();
    ObjectGroupManager_ptr &ptr (void);
    ObjectGroupManager_ptr operator-> (void);
  
  private:
    ObjectGroupManager_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_PORTABLEGROUP_OBJECTGROUPMANAGER_CH_)
#define _PORTABLEGROUP_OBJECTGROUPMANAGER_CH_

  class TAO_PortableGroup_Export ObjectGroupManager : public virtual CORBA_Object
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef ObjectGroupManager_ptr _ptr_type;
    typedef ObjectGroupManager_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

    // the static operations
    static ObjectGroupManager_ptr _duplicate (ObjectGroupManager_ptr obj);
    static ObjectGroupManager_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      );
    static ObjectGroupManager_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      );
    static ObjectGroupManager_ptr _nil (void)
      {
        return (ObjectGroupManager_ptr)0;
      }

    virtual PortableGroup::ObjectGroup_ptr create_member (
        PortableGroup::ObjectGroup_ptr object_group,
        const PortableGroup::Location & the_location,
        const char * type_id,
        const PortableGroup::Criteria & the_criteria,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException,
        PortableGroup::ObjectGroupNotFound,
        PortableGroup::MemberAlreadyPresent,
        PortableGroup::NoFactory,
        PortableGroup::ObjectNotCreated,
        PortableGroup::InvalidCriteria,
        PortableGroup::CannotMeetCriteria
      )) = 0;

    virtual PortableGroup::ObjectGroup_ptr add_member (
        PortableGroup::ObjectGroup_ptr object_group,
        const PortableGroup::Location & the_location,
        CORBA::Object_ptr member,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException,
        PortableGroup::ObjectGroupNotFound,
        PortableGroup::MemberAlreadyPresent,
        PortableGroup::ObjectNotAdded
      )) = 0;

    virtual PortableGroup::ObjectGroup_ptr remove_member (
        PortableGroup::ObjectGroup_ptr object_group,
        const PortableGroup::Location & the_location,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException,
        PortableGroup::ObjectGroupNotFound,
        PortableGroup::MemberNotFound
      )) = 0;

    virtual PortableGroup::Locations * locations_of_members (
        PortableGroup::ObjectGroup_ptr object_group,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException,
        PortableGroup::ObjectGroupNotFound
      )) = 0;

    virtual PortableGroup::ObjectGroupId get_object_group_id (
        PortableGroup::ObjectGroup_ptr object_group,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException,
        PortableGroup::ObjectGroupNotFound
      )) = 0;

    virtual PortableGroup::ObjectGroup_ptr get_object_group_ref (
        PortableGroup::ObjectGroup_ptr object_group,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException,
        PortableGroup::ObjectGroupNotFound
      )) = 0;

    virtual CORBA::Object_ptr get_member_ref (
        PortableGroup::ObjectGroup_ptr object_group,
        const PortableGroup::Location & loc,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException,
        PortableGroup::ObjectGroupNotFound,
        PortableGroup::MemberNotFound
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);
    
    virtual const char* _interface_repository_id (void) const;

  protected:
    ObjectGroupManager ();
    
    virtual ~ObjectGroupManager (void);
  private:
    ObjectGroupManager (const ObjectGroupManager &);
    void operator= (const ObjectGroupManager &);
  };


#endif /* end #if !defined */


#if !defined (_PORTABLEGROUP_GENERICFACTORY_CH_)
#define _PORTABLEGROUP_GENERICFACTORY_CH_

  class TAO_PortableGroup_Export GenericFactory : public virtual CORBA_Object
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef GenericFactory_ptr _ptr_type;
    typedef GenericFactory_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

    // the static operations
    static GenericFactory_ptr _duplicate (GenericFactory_ptr obj);
    static GenericFactory_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      );
    static GenericFactory_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      );
    static GenericFactory_ptr _nil (void)
      {
        return (GenericFactory_ptr)0;
      }

    typedef CORBA::Any FactoryCreationId;
    typedef CORBA::Any_ptr FactoryCreationId_ptr;
    typedef CORBA::Any_var FactoryCreationId_var;
    typedef CORBA::Any_out FactoryCreationId_out;
        virtual CORBA::Object_ptr create_object (
        const char * type_id,
        const PortableGroup::Criteria & the_criteria,
        PortableGroup::GenericFactory::FactoryCreationId_out factory_creation_id,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException,
        PortableGroup::NoFactory,
        PortableGroup::ObjectNotCreated,
        PortableGroup::InvalidCriteria,
        PortableGroup::InvalidProperty,
        PortableGroup::CannotMeetCriteria
      )) = 0;

    virtual void delete_object (
        const PortableGroup::GenericFactory::FactoryCreationId & factory_creation_id,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException,
        PortableGroup::ObjectNotFound
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);
    
    virtual const char* _interface_repository_id (void) const;

  protected:
    GenericFactory ();
    
    virtual ~GenericFactory (void);
  private:
    GenericFactory (const GenericFactory &);
    void operator= (const GenericFactory &);
  };


#endif /* end #if !defined */


}
TAO_NAMESPACE_CLOSE // module PortableGroup

TAO_PortableGroup_Export void operator<<= (CORBA::Any &, const PortableGroup::TagGroupTaggedComponent &); // copying version
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, PortableGroup::TagGroupTaggedComponent*); // noncopying version
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableGroup::TagGroupTaggedComponent *&); // deprecated
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableGroup::TagGroupTaggedComponent *&);
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, const PortableGroup::GroupIIOPProfile &); // copying version
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, PortableGroup::GroupIIOPProfile*); // noncopying version
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableGroup::GroupIIOPProfile *&); // deprecated
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableGroup::GroupIIOPProfile *&);
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, const PortableGroup::Property &); // copying version
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, PortableGroup::Property*); // noncopying version
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableGroup::Property *&); // deprecated
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableGroup::Property *&);
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, const PortableGroup::Properties &); // copying version
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, PortableGroup::Properties*); // noncopying version
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableGroup::Properties *&); // deprecated
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableGroup::Properties *&);
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, const PortableGroup::Locations &); // copying version
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, PortableGroup::Locations*); // noncopying version
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableGroup::Locations *&); // deprecated
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableGroup::Locations *&);
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, const PortableGroup::InterfaceNotFound &); // copying version
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, PortableGroup::InterfaceNotFound*); // noncopying version
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableGroup::InterfaceNotFound *&); // deprecated
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableGroup::InterfaceNotFound *&);
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, const PortableGroup::ObjectGroupNotFound &); // copying version
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, PortableGroup::ObjectGroupNotFound*); // noncopying version
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableGroup::ObjectGroupNotFound *&); // deprecated
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableGroup::ObjectGroupNotFound *&);
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, const PortableGroup::MemberNotFound &); // copying version
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, PortableGroup::MemberNotFound*); // noncopying version
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableGroup::MemberNotFound *&); // deprecated
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableGroup::MemberNotFound *&);
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, const PortableGroup::ObjectNotFound &); // copying version
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, PortableGroup::ObjectNotFound*); // noncopying version
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableGroup::ObjectNotFound *&); // deprecated
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableGroup::ObjectNotFound *&);
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, const PortableGroup::MemberAlreadyPresent &); // copying version
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, PortableGroup::MemberAlreadyPresent*); // noncopying version
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableGroup::MemberAlreadyPresent *&); // deprecated
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableGroup::MemberAlreadyPresent *&);
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, const PortableGroup::BadReplicationStyle &); // copying version
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, PortableGroup::BadReplicationStyle*); // noncopying version
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableGroup::BadReplicationStyle *&); // deprecated
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableGroup::BadReplicationStyle *&);
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, const PortableGroup::ObjectNotCreated &); // copying version
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, PortableGroup::ObjectNotCreated*); // noncopying version
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableGroup::ObjectNotCreated *&); // deprecated
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableGroup::ObjectNotCreated *&);
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, const PortableGroup::ObjectNotAdded &); // copying version
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, PortableGroup::ObjectNotAdded*); // noncopying version
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableGroup::ObjectNotAdded *&); // deprecated
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableGroup::ObjectNotAdded *&);
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, const PortableGroup::UnsupportedProperty &); // copying version
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, PortableGroup::UnsupportedProperty*); // noncopying version
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableGroup::UnsupportedProperty *&); // deprecated
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableGroup::UnsupportedProperty *&);
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, const PortableGroup::InvalidProperty &); // copying version
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, PortableGroup::InvalidProperty*); // noncopying version
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableGroup::InvalidProperty *&); // deprecated
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableGroup::InvalidProperty *&);
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, const PortableGroup::NoFactory &); // copying version
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, PortableGroup::NoFactory*); // noncopying version
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableGroup::NoFactory *&); // deprecated
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableGroup::NoFactory *&);
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, const PortableGroup::InvalidCriteria &); // copying version
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, PortableGroup::InvalidCriteria*); // noncopying version
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableGroup::InvalidCriteria *&); // deprecated
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableGroup::InvalidCriteria *&);
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, const PortableGroup::CannotMeetCriteria &); // copying version
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, PortableGroup::CannotMeetCriteria*); // noncopying version
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableGroup::CannotMeetCriteria *&); // deprecated
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableGroup::CannotMeetCriteria *&);

#ifndef __ACE_INLINE__

TAO_PortableGroup_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableGroup::TagGroupTaggedComponent &);
TAO_PortableGroup_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableGroup::TagGroupTaggedComponent &);

#if !defined _TAO_CDR_OP_PortableGroup_GroupIIOPProfile_H_
#define _TAO_CDR_OP_PortableGroup_GroupIIOPProfile_H_

TAO_PortableGroup_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const PortableGroup::GroupIIOPProfile &
  );
TAO_PortableGroup_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    PortableGroup::GroupIIOPProfile &
  );

#endif /* _TAO_CDR_OP_PortableGroup_GroupIIOPProfile_H_ */

TAO_PortableGroup_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableGroup::Property &);
TAO_PortableGroup_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableGroup::Property &);

#if !defined _TAO_CDR_OP_PortableGroup_Properties_H_
#define _TAO_CDR_OP_PortableGroup_Properties_H_

TAO_PortableGroup_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const PortableGroup::Properties &
  );
TAO_PortableGroup_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    PortableGroup::Properties &
  );

#endif /* _TAO_CDR_OP_PortableGroup_Properties_H_ */


#if !defined _TAO_CDR_OP_PortableGroup_Locations_H_
#define _TAO_CDR_OP_PortableGroup_Locations_H_

TAO_PortableGroup_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const PortableGroup::Locations &
  );
TAO_PortableGroup_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    PortableGroup::Locations &
  );

#endif /* _TAO_CDR_OP_PortableGroup_Locations_H_ */

TAO_PortableGroup_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableGroup::InterfaceNotFound &);
TAO_PortableGroup_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableGroup::InterfaceNotFound &);

TAO_PortableGroup_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableGroup::ObjectGroupNotFound &);
TAO_PortableGroup_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableGroup::ObjectGroupNotFound &);

TAO_PortableGroup_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableGroup::MemberNotFound &);
TAO_PortableGroup_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableGroup::MemberNotFound &);

TAO_PortableGroup_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableGroup::ObjectNotFound &);
TAO_PortableGroup_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableGroup::ObjectNotFound &);

TAO_PortableGroup_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableGroup::MemberAlreadyPresent &);
TAO_PortableGroup_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableGroup::MemberAlreadyPresent &);

TAO_PortableGroup_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableGroup::BadReplicationStyle &);
TAO_PortableGroup_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableGroup::BadReplicationStyle &);

TAO_PortableGroup_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableGroup::ObjectNotCreated &);
TAO_PortableGroup_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableGroup::ObjectNotCreated &);

TAO_PortableGroup_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableGroup::ObjectNotAdded &);
TAO_PortableGroup_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableGroup::ObjectNotAdded &);

TAO_PortableGroup_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableGroup::UnsupportedProperty &);
TAO_PortableGroup_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableGroup::UnsupportedProperty &);

TAO_PortableGroup_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableGroup::InvalidProperty &);
TAO_PortableGroup_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableGroup::InvalidProperty &);

TAO_PortableGroup_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableGroup::NoFactory &);
TAO_PortableGroup_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableGroup::NoFactory &);

TAO_PortableGroup_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableGroup::InvalidCriteria &);
TAO_PortableGroup_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableGroup::InvalidCriteria &);

TAO_PortableGroup_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableGroup::CannotMeetCriteria &);
TAO_PortableGroup_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableGroup::CannotMeetCriteria &);


#endif /* __ACE_INLINE__ */


#if defined (__ACE_INLINE__)
#include "PortableGroupC.i"
#endif /* defined INLINE */

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(pop)
#endif /* _MSC_VER */

#if defined (__BORLANDC__)
#pragma option pop
#endif /* __BORLANDC__ */

#include "ace/post.h"
#endif /* ifndef */
