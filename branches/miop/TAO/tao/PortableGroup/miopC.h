// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#ifndef _TAO_IDL_MIOPC_H_
#define _TAO_IDL_MIOPC_H_

#include "ace/pre.h"
#include "tao/corba.h"

#if !defined (ACE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */

#include "portablegroup_export.h"
//#include "IOPC.h"
#include "tao/GIOPC.h"

#if defined (TAO_EXPORT_MACRO)
#undef TAO_EXPORT_MACRO
#endif
#define TAO_EXPORT_MACRO TAO_PortableGroup_Export

#if defined (TAO_EXPORT_NESTED_CLASSES)
#  if defined (TAO_EXPORT_NESTED_MACRO)
#    undef TAO_EXPORT_NESTED_MACRO
#  endif /* defined (TAO_EXPORT_NESTED_MACRO) */
#  define TAO_EXPORT_NESTED_MACRO TAO_PortableGroup_Export
#endif /* TAO_EXPORT_NESTED_CLASSES */

#if defined(_MSC_VER)
#if (_MSC_VER >= 1200)
#pragma warning(push)
#endif /* _MSC_VER >= 1200 */
#pragma warning(disable:4250)
#endif /* _MSC_VER */

#if defined (__BORLANDC__)
#pragma option push -w-rvl -w-rch -w-ccc -w-inl
#endif /* __BORLANDC__ */

TAO_NAMESPACE  MIOP
{

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    
#if !defined (__TAO_BOUNDED_SEQUENCE_MIOP_UNIQUEID_252_CH_)
#define __TAO_BOUNDED_SEQUENCE_MIOP_UNIQUEID_252_CH_

    class _TAO_Bounded_Sequence_MIOP_UniqueId_252 : public TAO_Bounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.
      
      _TAO_Bounded_Sequence_MIOP_UniqueId_252 (void);
      _TAO_Bounded_Sequence_MIOP_UniqueId_252 (CORBA::ULong length,
        CORBA::Octet *data,
        CORBA::Boolean release = 0);
      _TAO_Bounded_Sequence_MIOP_UniqueId_252 (const _TAO_Bounded_Sequence_MIOP_UniqueId_252 &rhs);
      // Copy constructor.
      _TAO_Bounded_Sequence_MIOP_UniqueId_252 &operator= (const _TAO_Bounded_Sequence_MIOP_UniqueId_252 &rhs);
      // Assignment operator.  
      virtual ~_TAO_Bounded_Sequence_MIOP_UniqueId_252 (void); // Dtor.
      // = Accessors.
      CORBA::Octet &operator[] (CORBA::ULong i);// operator []
      const CORBA::Octet &operator[] (CORBA::ULong i) const;
      // = Static operations.
      static CORBA::Octet *allocbuf (CORBA::ULong); // Allocate storage for the sequence.
      static void freebuf (CORBA::Octet *buffer); // Free the sequence.
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      CORBA::Octet *get_buffer (CORBA::Boolean orphan = 0);
      const CORBA::Octet *get_buffer (void) const;
      void replace (CORBA::ULong max,
        CORBA::ULong length,
        CORBA::Octet *data,
        CORBA::Boolean release = 0);
    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  
#if !defined (_MIOP_UNIQUEID_CH_)
#define _MIOP_UNIQUEID_CH_

  class UniqueId;
  class UniqueId_var;
  
  // *************************************************************
  // UniqueId
  // *************************************************************
  
  class TAO_PortableGroup_Export UniqueId : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Bounded_Sequence_MIOP_UniqueId_252
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Bounded_Sequence<CORBA::Octet, 252U>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  {
  public:
    UniqueId (void); // default ctor
    UniqueId (
      CORBA::ULong length, 
      CORBA::Octet *buffer, 
      CORBA::Boolean release = 0
    );
    UniqueId (const UniqueId &); // copy ctor
    ~UniqueId (void);
    static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef UniqueId_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  };
  
#endif /* end #if !defined */


#if !defined (_MIOP_UNIQUEID___VAR_CH_)
#define _MIOP_UNIQUEID___VAR_CH_

  // *************************************************************
  // class MIOP::UniqueId_var
  // *************************************************************

  class TAO_PortableGroup_Export UniqueId_var
  {
  public:
    UniqueId_var (void); // default constructor
    UniqueId_var (UniqueId *);
    UniqueId_var (const UniqueId_var &); // copy constructor
    UniqueId_var (const UniqueId &); // fixed-size base types only
    ~UniqueId_var (void); // destructor
    
    UniqueId_var &operator= (UniqueId *);
    UniqueId_var &operator= (const UniqueId_var &);
    UniqueId_var &operator= (const UniqueId &); // fixed-size base types only
    UniqueId *operator-> (void);
    const UniqueId *operator-> (void) const;
    
    operator const UniqueId &() const;
    operator UniqueId &();
    operator UniqueId &() const;
    
    CORBA::Octet & operator[] (CORBA::ULong index);
    const CORBA::Octet & operator[] (CORBA::ULong index) const;
    
    // in, inout, out, _retn 
    const UniqueId &in (void) const;
    UniqueId &inout (void);
    UniqueId *&out (void);
    UniqueId *_retn (void);
    UniqueId *ptr (void) const;

  private:
    UniqueId *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MIOP_UNIQUEID___OUT_CH_)
#define _MIOP_UNIQUEID___OUT_CH_

  class TAO_PortableGroup_Export UniqueId_out
  {
  public:
    UniqueId_out (UniqueId *&);
    UniqueId_out (UniqueId_var &);
    UniqueId_out (const UniqueId_out &);
    UniqueId_out &operator= (const UniqueId_out &);
    UniqueId_out &operator= (UniqueId *);
    operator UniqueId *&();
    UniqueId *&ptr (void);
    UniqueId *operator-> (void);
    CORBA::Octet & operator[] (CORBA::ULong index);
    
  private:
    UniqueId *&ptr_;
    // assignment from T_var not allowed
    void operator= (const UniqueId_var &);
  };


#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_UniqueId;

  struct PacketHeader_1_0;
  class PacketHeader_1_0_var;
  
  struct TAO_PortableGroup_Export PacketHeader_1_0
  {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef PacketHeader_1_0_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

    static void _tao_any_destructor (void*);


#if !defined (_MIOP_PACKETHEADER_1_0_MAGIC_CH_)
#define _MIOP_PACKETHEADER_1_0_MAGIC_CH_

    typedef CORBA::Char _magic[4];
    typedef CORBA::Char _magic_slice;
    class TAO_PortableGroup_Export _magic_forany
    {
    public:
      _magic_forany (void); // default constructor
      _magic_forany (_magic_slice *, CORBA::Boolean nocopy=0);
      _magic_forany (const _magic_forany &); // copy constructor
      ~_magic_forany (void); // destructor
      static void _tao_any_destructor (void*);
      _magic_forany &operator= (_magic_slice *);
      _magic_forany &operator= (const _magic_forany &);
      
      _magic_slice &operator[] (CORBA::ULong index);
      const _magic_slice &operator[] (CORBA::ULong index) const;
      operator _magic_slice * const &() const;
      operator _magic_slice *&();
      // in, inout, out, _retn 
      const _magic_slice *in (void) const;
      _magic_slice *inout (void);
      _magic_slice *&out (void);
      _magic_slice *_retn (void);
      _magic_slice *ptr (void) const;
      CORBA::Boolean nocopy (void) const;
    private:
      /* friend class CORBA_Any; */
      _magic_slice *ptr_;
      CORBA::Boolean nocopy_;
    };

    static _magic_slice *_magic_alloc (void);
    static void _magic_free (_magic_slice *_tao_slice);
    static _magic_slice *_magic_dup (const _magic_slice *_tao_slice);
    static void _magic_copy (_magic_slice *_tao_to, const _magic_slice *_tao_from);
    

#endif /* end #if !defined */

    _magic magic;
    CORBA::Octet hdr_version;
    CORBA::Octet flags;
    CORBA::UShort packet_length;
    CORBA::ULong packet_number;
    CORBA::ULong number_of_packets;
    ACE_NESTED_CLASS (MIOP, UniqueId) Id;
  };

  class TAO_PortableGroup_Export PacketHeader_1_0_var
  {
  public:
    PacketHeader_1_0_var (void); // default constructor
    PacketHeader_1_0_var (PacketHeader_1_0 *);
    PacketHeader_1_0_var (const PacketHeader_1_0_var &); // copy constructor
    ~PacketHeader_1_0_var (void); // destructor
    
    PacketHeader_1_0_var &operator= (PacketHeader_1_0 *);
    PacketHeader_1_0_var &operator= (const PacketHeader_1_0_var &);
    PacketHeader_1_0 *operator-> (void);
    const PacketHeader_1_0 *operator-> (void) const;
    
    operator const PacketHeader_1_0 &() const;
    operator PacketHeader_1_0 &();
    operator PacketHeader_1_0 &() const;
    operator PacketHeader_1_0 *&(); // variable-size types only
    
    // in, inout, out, _retn 
    const PacketHeader_1_0 &in (void) const;
    PacketHeader_1_0 &inout (void);
    PacketHeader_1_0 *&out (void);
    PacketHeader_1_0 *_retn (void);
    PacketHeader_1_0 *ptr (void) const;

  private:
    PacketHeader_1_0 *ptr_;
  };

  class TAO_PortableGroup_Export PacketHeader_1_0_out
  {
  public:
    PacketHeader_1_0_out (PacketHeader_1_0 *&);
    PacketHeader_1_0_out (PacketHeader_1_0_var &);
    PacketHeader_1_0_out (const PacketHeader_1_0_out &);
    PacketHeader_1_0_out &operator= (const PacketHeader_1_0_out &);
    PacketHeader_1_0_out &operator= (PacketHeader_1_0 *);
    operator PacketHeader_1_0 *&();
    PacketHeader_1_0 *&ptr (void);
    PacketHeader_1_0 *operator-> (void);
    
  private:
    PacketHeader_1_0 *&ptr_;
    // assignment from T_var not allowed
    void operator= (const PacketHeader_1_0_var &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_PacketHeader_1_0;

  typedef GIOP::Version Version;

//  @@ Frank: Version_var and Version_out are commented out as they
//     do not exist in tao/GIOPC.h.  Hopefully, this doesn't become an
//     issue.
//  typedef GIOP::Version_var Version_var;
//  typedef GIOP::Version_out Version_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Version;

  typedef char * Address;
  typedef CORBA::String_var Address_var;
  typedef CORBA::String_out Address_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Address;

  struct UIPMC_ProfileBody;
  class UIPMC_ProfileBody_var;
  
  struct TAO_PortableGroup_Export UIPMC_ProfileBody
  {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef UIPMC_ProfileBody_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

    static void _tao_any_destructor (void*);

    ACE_NESTED_CLASS (MIOP, Version) miop_version;
    TAO_String_Manager the_address;
    CORBA::Short the_port;

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
      
#if !defined (__TAO_UNBOUNDED_SEQUENCE_MIOP_UIPMC_PROFILEBODY__TAO_SEQ_TAGGEDCOMPONENT_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_MIOP_UIPMC_PROFILEBODY__TAO_SEQ_TAGGEDCOMPONENT_CH_

      class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent : public TAO_Unbounded_Base_Sequence
      {
      public:
        // = Initialization and termination methods.
        
        _TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent (void); // Default constructor.
        _TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent (CORBA::ULong maximum); 
        _TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent (CORBA::ULong maximum,
          CORBA::ULong length,
          IOP::TaggedComponent *data,
          CORBA::Boolean release = 0);
        _TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent (const _TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent &rhs);
        _TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent &operator= (const _TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent &rhs);
        virtual ~_TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent (void); // Dtor.
        // = Accessors.
        IOP::TaggedComponent &operator[] (CORBA::ULong i);
        const IOP::TaggedComponent &operator[] (CORBA::ULong i) const;
        // = Static operations.
        static IOP::TaggedComponent *allocbuf (CORBA::ULong size);
        static void freebuf (IOP::TaggedComponent *buffer);
        virtual void _allocate_buffer (CORBA::ULong length);
        virtual void _deallocate_buffer (void);
        // Implement the TAO_Base_Sequence methods (see Sequence.h)
        
        IOP::TaggedComponent *get_buffer (CORBA::Boolean orphan = 0);
        const IOP::TaggedComponent *get_buffer (void) const;
        void replace (CORBA::ULong max,
          CORBA::ULong length,
          IOP::TaggedComponent *data,
          CORBA::Boolean release);
      };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
    
#if !defined (_MIOP_UIPMC_PROFILEBODY__TAO_SEQ_TAGGEDCOMPONENT_CH_)
#define _MIOP_UIPMC_PROFILEBODY__TAO_SEQ_TAGGEDCOMPONENT_CH_

    class _tao_seq_TaggedComponent;
    class _tao_seq_TaggedComponent_var;
    
    // *************************************************************
    // _tao_seq_TaggedComponent
    // *************************************************************
    
    class TAO_PortableGroup_Export _tao_seq_TaggedComponent : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
      _TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent
#else /* TAO_USE_SEQUENCE_TEMPLATES */
      TAO_Unbounded_Sequence<IOP::TaggedComponent>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
    {
    public:
      _tao_seq_TaggedComponent (void); // default ctor
      _tao_seq_TaggedComponent (CORBA::ULong max); // uses max size
      _tao_seq_TaggedComponent (
        CORBA::ULong max, 
        CORBA::ULong length, 
        IOP::TaggedComponent *buffer, 
        CORBA::Boolean release = 0
      );
      _tao_seq_TaggedComponent (const _tao_seq_TaggedComponent &); // copy ctor
      ~_tao_seq_TaggedComponent (void);
      static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
      typedef _tao_seq_TaggedComponent_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

    };
    
#endif /* end #if !defined */

#if !defined (__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef _tao_seq_TaggedComponent _components_seq;
  #endif /* ! __GNUC__ || ACE_HAS_GNUG_PRE_2_8 */

          _tao_seq_TaggedComponent components;
  };

  class TAO_PortableGroup_Export UIPMC_ProfileBody_var
  {
  public:
    UIPMC_ProfileBody_var (void); // default constructor
    UIPMC_ProfileBody_var (UIPMC_ProfileBody *);
    UIPMC_ProfileBody_var (const UIPMC_ProfileBody_var &); // copy constructor
    ~UIPMC_ProfileBody_var (void); // destructor
    
    UIPMC_ProfileBody_var &operator= (UIPMC_ProfileBody *);
    UIPMC_ProfileBody_var &operator= (const UIPMC_ProfileBody_var &);
    UIPMC_ProfileBody *operator-> (void);
    const UIPMC_ProfileBody *operator-> (void) const;
    
    operator const UIPMC_ProfileBody &() const;
    operator UIPMC_ProfileBody &();
    operator UIPMC_ProfileBody &() const;
    operator UIPMC_ProfileBody *&(); // variable-size types only
    
    // in, inout, out, _retn 
    const UIPMC_ProfileBody &in (void) const;
    UIPMC_ProfileBody &inout (void);
    UIPMC_ProfileBody *&out (void);
    UIPMC_ProfileBody *_retn (void);
    UIPMC_ProfileBody *ptr (void) const;

  private:
    UIPMC_ProfileBody *ptr_;
  };

  class TAO_PortableGroup_Export UIPMC_ProfileBody_out
  {
  public:
    UIPMC_ProfileBody_out (UIPMC_ProfileBody *&);
    UIPMC_ProfileBody_out (UIPMC_ProfileBody_var &);
    UIPMC_ProfileBody_out (const UIPMC_ProfileBody_out &);
    UIPMC_ProfileBody_out &operator= (const UIPMC_ProfileBody_out &);
    UIPMC_ProfileBody_out &operator= (UIPMC_ProfileBody *);
    operator UIPMC_ProfileBody *&();
    UIPMC_ProfileBody *&ptr (void);
    UIPMC_ProfileBody *operator-> (void);
    
  private:
    UIPMC_ProfileBody *&ptr_;
    // assignment from T_var not allowed
    void operator= (const UIPMC_ProfileBody_var &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_UIPMC_ProfileBody;


#if !defined (_MIOP_MULTICASTOBJECTGROUPFACTORY___PTR_CH_)
#define _MIOP_MULTICASTOBJECTGROUPFACTORY___PTR_CH_

  class MulticastObjectGroupFactory;
  typedef MulticastObjectGroupFactory *MulticastObjectGroupFactory_ptr;
  
#endif /* end #if !defined */


#if !defined (_MIOP_MULTICASTOBJECTGROUPFACTORY___VAR_CH_)
#define _MIOP_MULTICASTOBJECTGROUPFACTORY___VAR_CH_

  class TAO_PortableGroup_Export MulticastObjectGroupFactory_var : public TAO_Base_var
  {
  public:
    MulticastObjectGroupFactory_var (void); // default constructor
    MulticastObjectGroupFactory_var (MulticastObjectGroupFactory_ptr p) : ptr_ (p) {} 
    MulticastObjectGroupFactory_var (const MulticastObjectGroupFactory_var &); // copy constructor
    ~MulticastObjectGroupFactory_var (void); // destructor
    
    MulticastObjectGroupFactory_var &operator= (MulticastObjectGroupFactory_ptr);
    MulticastObjectGroupFactory_var &operator= (const MulticastObjectGroupFactory_var &);
    MulticastObjectGroupFactory_ptr operator-> (void) const;
    
    operator const MulticastObjectGroupFactory_ptr &() const;
    operator MulticastObjectGroupFactory_ptr &();
    // in, inout, out, _retn 
    MulticastObjectGroupFactory_ptr in (void) const;
    MulticastObjectGroupFactory_ptr &inout (void);
    MulticastObjectGroupFactory_ptr &out (void);
    MulticastObjectGroupFactory_ptr _retn (void);
    MulticastObjectGroupFactory_ptr ptr (void) const;
    
    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static MulticastObjectGroupFactory_ptr duplicate (MulticastObjectGroupFactory_ptr);
    static void release (MulticastObjectGroupFactory_ptr);
    static MulticastObjectGroupFactory_ptr nil (void);
    static MulticastObjectGroupFactory_ptr narrow (CORBA::Object *, CORBA::Environment &);
    static CORBA::Object * upcast (void *);
  
  private:
    MulticastObjectGroupFactory_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    MulticastObjectGroupFactory_var (const TAO_Base_var &rhs);
    MulticastObjectGroupFactory_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_MIOP_MULTICASTOBJECTGROUPFACTORY___OUT_CH_)
#define _MIOP_MULTICASTOBJECTGROUPFACTORY___OUT_CH_

  class TAO_PortableGroup_Export MulticastObjectGroupFactory_out
  {
  public:
    MulticastObjectGroupFactory_out (MulticastObjectGroupFactory_ptr &);
    MulticastObjectGroupFactory_out (MulticastObjectGroupFactory_var &);
    MulticastObjectGroupFactory_out (const MulticastObjectGroupFactory_out &);
    MulticastObjectGroupFactory_out &operator= (const MulticastObjectGroupFactory_out &);
    MulticastObjectGroupFactory_out &operator= (const MulticastObjectGroupFactory_var &);
    MulticastObjectGroupFactory_out &operator= (MulticastObjectGroupFactory_ptr);
    operator MulticastObjectGroupFactory_ptr &();
    MulticastObjectGroupFactory_ptr &ptr (void);
    MulticastObjectGroupFactory_ptr operator-> (void);
  
  private:
    MulticastObjectGroupFactory_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MIOP_MULTICASTOBJECTGROUPFACTORY_CH_)
#define _MIOP_MULTICASTOBJECTGROUPFACTORY_CH_

  class TAO_PortableGroup_Export MulticastObjectGroupFactory : public virtual CORBA_Object
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef MulticastObjectGroupFactory_ptr _ptr_type;
    typedef MulticastObjectGroupFactory_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

    // the static operations
    static MulticastObjectGroupFactory_ptr _duplicate (MulticastObjectGroupFactory_ptr obj);
    static MulticastObjectGroupFactory_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      );
    static MulticastObjectGroupFactory_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      );
    static MulticastObjectGroupFactory_ptr _nil (void)
      {
        return (MulticastObjectGroupFactory_ptr)0;
      }


#if !defined (_MIOP_MULTICASTOBJECTGROUPFACTORY_IPADDR_CH_)
#define _MIOP_MULTICASTOBJECTGROUPFACTORY_IPADDR_CH_

    typedef CORBA::Octet ipaddr[4];
    typedef CORBA::Octet ipaddr_slice;
    class TAO_PortableGroup_Export ipaddr_var
    {
    public:
      ipaddr_var (void); // default constructor
      ipaddr_var (ipaddr_slice *);
      ipaddr_var (const ipaddr_var &); // copy constructor
      ~ipaddr_var (void); // destructor
      
      ipaddr_var &operator= (ipaddr_slice *);
      ipaddr_var &operator= (const ipaddr_var &);
      
      ipaddr_slice &operator[] (CORBA::ULong index);
      const ipaddr_slice &operator[] (CORBA::ULong index) const;
      operator ipaddr_slice * const &() const;
      //Calls ipaddr_copy (used in sequences of ipaddr).
      static void copy (ipaddr_slice *_tao_to, const ipaddr_slice *_tao_from);
      // in, inout, out, _retn 
      const ipaddr_slice *in (void) const;
      ipaddr_slice *inout (void);
      ipaddr_slice *&out (void);
      ipaddr_slice *_retn (void);
      ipaddr_slice *ptr (void) const;
    private:
      ipaddr_slice *ptr_;
    };

    typedef ipaddr ipaddr_out;
    class TAO_PortableGroup_Export ipaddr_forany
    {
    public:
      ipaddr_forany (void); // default constructor
      ipaddr_forany (ipaddr_slice *, CORBA::Boolean nocopy=0);
      ipaddr_forany (const ipaddr_forany &); // copy constructor
      ~ipaddr_forany (void); // destructor
      static void _tao_any_destructor (void*);
      ipaddr_forany &operator= (ipaddr_slice *);
      ipaddr_forany &operator= (const ipaddr_forany &);
      
      ipaddr_slice &operator[] (CORBA::ULong index);
      const ipaddr_slice &operator[] (CORBA::ULong index) const;
      operator ipaddr_slice * const &() const;
      operator ipaddr_slice *&();
      // in, inout, out, _retn 
      const ipaddr_slice *in (void) const;
      ipaddr_slice *inout (void);
      ipaddr_slice *&out (void);
      ipaddr_slice *_retn (void);
      ipaddr_slice *ptr (void) const;
      CORBA::Boolean nocopy (void) const;
    private:
      /* friend class CORBA_Any; */
      ipaddr_slice *ptr_;
      CORBA::Boolean nocopy_;
    };

    static ipaddr_slice *ipaddr_alloc (void);
    static void ipaddr_free (ipaddr_slice *_tao_slice);
    static ipaddr_slice *ipaddr_dup (const ipaddr_slice *_tao_slice);
    static void ipaddr_copy (ipaddr_slice *_tao_to, const ipaddr_slice *_tao_from);
    

#endif /* end #if !defined */

    virtual CORBA::Object_ptr create_group (
        const char * type_id,
        const MIOP::MulticastObjectGroupFactory::ipaddr class_d_address,
        CORBA::UShort port,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);
    
    virtual const char* _interface_repository_id (void) const;

  protected:
    MulticastObjectGroupFactory ();
    
    virtual ~MulticastObjectGroupFactory (void);
  private:
    MulticastObjectGroupFactory (const MulticastObjectGroupFactory &);
    void operator= (const MulticastObjectGroupFactory &);
  };


#endif /* end #if !defined */


}
TAO_NAMESPACE_CLOSE // module MIOP

TAO_PortableGroup_Export void operator<<= (CORBA::Any &, const MIOP::UniqueId &); // copying version
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, MIOP::UniqueId*); // noncopying version
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, MIOP::UniqueId *&); // deprecated
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, const MIOP::UniqueId *&);
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, const MIOP::PacketHeader_1_0 &); // copying version
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, MIOP::PacketHeader_1_0*); // noncopying version
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, MIOP::PacketHeader_1_0 *&); // deprecated
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, const MIOP::PacketHeader_1_0 *&);
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, const MIOP::UIPMC_ProfileBody &); // copying version
TAO_PortableGroup_Export void operator<<= (CORBA::Any &, MIOP::UIPMC_ProfileBody*); // noncopying version
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, MIOP::UIPMC_ProfileBody *&); // deprecated
TAO_PortableGroup_Export CORBA::Boolean operator>>= (const CORBA::Any &, const MIOP::UIPMC_ProfileBody *&);

#ifndef __ACE_INLINE__


#if !defined _TAO_CDR_OP_MIOP_UniqueId_H_
#define _TAO_CDR_OP_MIOP_UniqueId_H_

TAO_PortableGroup_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const MIOP::UniqueId &
  );
TAO_PortableGroup_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    MIOP::UniqueId &
  );

#endif /* _TAO_CDR_OP_MIOP_UniqueId_H_ */

TAO_PortableGroup_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const MIOP::PacketHeader_1_0 &);
TAO_PortableGroup_Export CORBA::Boolean operator>> (TAO_InputCDR &, MIOP::PacketHeader_1_0 &);
TAO_PortableGroup_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const MIOP::PacketHeader_1_0::_magic_forany &);
TAO_PortableGroup_Export CORBA::Boolean operator>> (TAO_InputCDR &, MIOP::PacketHeader_1_0::_magic_forany &);
TAO_PortableGroup_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const MIOP::UIPMC_ProfileBody &);
TAO_PortableGroup_Export CORBA::Boolean operator>> (TAO_InputCDR &, MIOP::UIPMC_ProfileBody &);

#if !defined _TAO_CDR_OP_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent_H_
#define _TAO_CDR_OP_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent_H_

TAO_PortableGroup_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const MIOP::UIPMC_ProfileBody::_tao_seq_TaggedComponent &
  );
TAO_PortableGroup_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    MIOP::UIPMC_ProfileBody::_tao_seq_TaggedComponent &
  );

#endif /* _TAO_CDR_OP_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent_H_ */


#endif /* __ACE_INLINE__ */


#if defined (__ACE_INLINE__)
#include "miopC.i"
#endif /* defined INLINE */

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(pop)
#endif /* _MSC_VER */

#if defined (__BORLANDC__)
#pragma option pop
#endif /* __BORLANDC__ */

#include "ace/post.h"
#endif /* ifndef */
