// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#include "miopC.h"

#include "tao/Stub.h"
#include "tao/Invocation.h"
#include "tao/ClientRequestInfo.h"
#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */

#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "miopC.i"
#endif /* !defined INLINE */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_BOUNDED_SEQUENCE_MIOP_UNIQUEID_252_CS_)
#define __TAO_BOUNDED_SEQUENCE_MIOP_UNIQUEID_252_CS_

  void 
  MIOP::_TAO_Bounded_Sequence_MIOP_UniqueId_252::_allocate_buffer (CORBA::ULong /* length */)
  // allocate a buffer of the requested length. The buffer is allocated for the
  // right type
  {
    this->buffer_ = _TAO_Bounded_Sequence_MIOP_UniqueId_252::allocbuf (252U);
  }
  
  void 
  MIOP::_TAO_Bounded_Sequence_MIOP_UniqueId_252::_deallocate_buffer (void)
  // deallocate the buffer
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    CORBA::Octet *tmp = ACE_reinterpret_cast (CORBA::Octet *, this->buffer_);
    _TAO_Bounded_Sequence_MIOP_UniqueId_252::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  MIOP::_TAO_Bounded_Sequence_MIOP_UniqueId_252::~_TAO_Bounded_Sequence_MIOP_UniqueId_252 (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_MIOP_UNIQUEID_CS_)
#define _MIOP_UNIQUEID_CS_

// *************************************************************
// MIOP::UniqueId
// *************************************************************

MIOP::UniqueId::UniqueId (void)
{}
MIOP::UniqueId::UniqueId (CORBA::ULong length, CORBA::Octet *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Bounded_Sequence_MIOP_UniqueId_252
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Bounded_Sequence<CORBA::Octet, 252U>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (length, buffer, release)
{}
MIOP::UniqueId::UniqueId (const UniqueId &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Bounded_Sequence_MIOP_UniqueId_252
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Bounded_Sequence<CORBA::Octet, 252U>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
MIOP::UniqueId::~UniqueId (void) // dtor
{}
void MIOP::UniqueId::_tao_any_destructor (void *x)
{
  UniqueId *tmp = ACE_static_cast (UniqueId*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_MIOP_UniqueId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x4d494f50), 
  ACE_NTOHL (0x2f556e69), 
  ACE_NTOHL (0x71756549), 
  ACE_NTOHL (0x643a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/MIOP/UniqueId:1.0
  9,
  ACE_NTOHL (0x556e6971), 
  ACE_NTOHL (0x75654964), 
  ACE_NTOHL (0x0),  // name = UniqueId
  CORBA::tk_sequence, // typecode kind
  12, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_octet,

    252U,

};

static CORBA::TypeCode _tc_TAO_tc_MIOP_UniqueId (
    CORBA::tk_alias,
    sizeof (_oc_MIOP_UniqueId),
    (char *) &_oc_MIOP_UniqueId,
    0,
    sizeof (MIOP::UniqueId)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (MIOP)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UniqueId, &_tc_TAO_tc_MIOP_UniqueId)
TAO_NAMESPACE_END

static const CORBA::Long _oc_MIOP_PacketHeader_1_0[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  38,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x4d494f50), 
  ACE_NTOHL (0x2f506163), 
  ACE_NTOHL (0x6b657448), 
  ACE_NTOHL (0x65616465), 
  ACE_NTOHL (0x725f315f), 
  ACE_NTOHL (0x303a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/MIOP/PacketHeader_1_0:1.0
  17,
  ACE_NTOHL (0x5061636b), 
  ACE_NTOHL (0x65744865), 
  ACE_NTOHL (0x61646572), 
  ACE_NTOHL (0x5f315f30), 
  ACE_NTOHL (0x0),  // name = PacketHeader_1_0
  7, // member count
  6,
  ACE_NTOHL (0x6d616769), 
  ACE_NTOHL (0x63000000),  // name = magic
  CORBA::tk_array, // typecode kind
  12, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_char,

    4U,

  12,
  ACE_NTOHL (0x6864725f), 
  ACE_NTOHL (0x76657273), 
  ACE_NTOHL (0x696f6e00),  // name = hdr_version
  CORBA::tk_octet,

  6,
  ACE_NTOHL (0x666c6167), 
  ACE_NTOHL (0x73000000),  // name = flags
  CORBA::tk_octet,

  14,
  ACE_NTOHL (0x7061636b), 
  ACE_NTOHL (0x65745f6c), 
  ACE_NTOHL (0x656e6774), 
  ACE_NTOHL (0x68000000),  // name = packet_length
  CORBA::tk_ushort,

  14,
  ACE_NTOHL (0x7061636b), 
  ACE_NTOHL (0x65745f6e), 
  ACE_NTOHL (0x756d6265), 
  ACE_NTOHL (0x72000000),  // name = packet_number
  CORBA::tk_ulong,

  18,
  ACE_NTOHL (0x6e756d62), 
  ACE_NTOHL (0x65725f6f), 
  ACE_NTOHL (0x665f7061), 
  ACE_NTOHL (0x636b6574), 
  ACE_NTOHL (0x73000000),  // name = number_of_packets
  CORBA::tk_ulong,

  3,
  ACE_NTOHL (0x49640000),  // name = Id
  CORBA::tk_alias, // typecode kind for typedefs
  76, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x4d494f50), 
    ACE_NTOHL (0x2f556e69), 
    ACE_NTOHL (0x71756549), 
    ACE_NTOHL (0x643a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/MIOP/UniqueId:1.0
    9,
    ACE_NTOHL (0x556e6971), 
    ACE_NTOHL (0x75654964), 
    ACE_NTOHL (0x0),  // name = UniqueId
    CORBA::tk_sequence, // typecode kind
    12, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_octet,

      252U,


};

static CORBA::TypeCode _tc_TAO_tc_MIOP_PacketHeader_1_0 (
    CORBA::tk_struct,
    sizeof (_oc_MIOP_PacketHeader_1_0),
    (char *) &_oc_MIOP_PacketHeader_1_0,
    0,
    sizeof (MIOP::PacketHeader_1_0)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (MIOP)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PacketHeader_1_0, &_tc_TAO_tc_MIOP_PacketHeader_1_0)
TAO_NAMESPACE_END

void MIOP::PacketHeader_1_0::_tao_any_destructor (void *x)
{
  PacketHeader_1_0 *tmp = ACE_static_cast (PacketHeader_1_0*,x);
  delete tmp;
}

void MIOP::PacketHeader_1_0::_magic_forany::_tao_any_destructor (void *x)
{
  _magic_slice *tmp = ACE_static_cast (_magic_slice*,x);
  _magic_free (tmp);
}

MIOP::PacketHeader_1_0::_magic_slice *
MIOP::PacketHeader_1_0::_magic_dup (const MIOP::PacketHeader_1_0::_magic_slice *_tao_src_array)
{
  MIOP::PacketHeader_1_0::_magic_slice *_tao_dup_array = MIOP::PacketHeader_1_0::_magic_alloc ();
  if (!_tao_dup_array) return (MIOP::PacketHeader_1_0::_magic_slice *)0;
  MIOP::PacketHeader_1_0::_magic_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

MIOP::PacketHeader_1_0::_magic_slice *
MIOP::PacketHeader_1_0::_magic_alloc (void)
{
  MIOP::PacketHeader_1_0::_magic_slice *retval = 0;
  ACE_NEW_RETURN (retval, CORBA::Char[4], 0);
  return retval;
}

void
MIOP::PacketHeader_1_0::_magic_free (MIOP::PacketHeader_1_0::_magic_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void 
MIOP::PacketHeader_1_0::_magic_copy (MIOP::PacketHeader_1_0::_magic_slice * _tao_to, const MIOP::PacketHeader_1_0::_magic_slice *_tao_from)
{
  // copy each individual element
  for (CORBA::ULong i0 = 0; i0 < 4; i0++)
    _tao_to[i0] = _tao_from[i0];
}

static const CORBA::Long _oc_MIOP_Version[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  29,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x4d494f50), 
  ACE_NTOHL (0x2f566572), 
  ACE_NTOHL (0x73696f6e), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/MIOP/Version:1.0
  8,
  ACE_NTOHL (0x56657273), 
  ACE_NTOHL (0x696f6e00),  // name = Version
  CORBA::tk_struct, // typecode kind
  88, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    29,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x47494f50), 
    ACE_NTOHL (0x2f566572), 
    ACE_NTOHL (0x73696f6e), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/GIOP/Version:1.0
    8,
    ACE_NTOHL (0x56657273), 
    ACE_NTOHL (0x696f6e00),  // name = Version
    2, // member count
    6,
    ACE_NTOHL (0x6d616a6f), 
    ACE_NTOHL (0x72000000),  // name = major
    CORBA::tk_octet,

    6,
    ACE_NTOHL (0x6d696e6f), 
    ACE_NTOHL (0x72000000),  // name = minor
    CORBA::tk_octet,


};

static CORBA::TypeCode _tc_TAO_tc_MIOP_Version (
    CORBA::tk_alias,
    sizeof (_oc_MIOP_Version),
    (char *) &_oc_MIOP_Version,
    0,
    sizeof (MIOP::Version)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (MIOP)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Version, &_tc_TAO_tc_MIOP_Version)
TAO_NAMESPACE_END

static const CORBA::Long _oc_MIOP_Address[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  29,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x4d494f50), 
  ACE_NTOHL (0x2f416464), 
  ACE_NTOHL (0x72657373), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/MIOP/Address:1.0
  8,
  ACE_NTOHL (0x41646472), 
  ACE_NTOHL (0x65737300),  // name = Address
  CORBA::tk_string, 
  0U, // string length
};

static CORBA::TypeCode _tc_TAO_tc_MIOP_Address (
    CORBA::tk_alias,
    sizeof (_oc_MIOP_Address),
    (char *) &_oc_MIOP_Address,
    0,
    sizeof (MIOP::Address)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (MIOP)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Address, &_tc_TAO_tc_MIOP_Address)
TAO_NAMESPACE_END

static const CORBA::Long _oc_MIOP_UIPMC_ProfileBody[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x4d494f50), 
  ACE_NTOHL (0x2f554950), 
  ACE_NTOHL (0x4d435f50), 
  ACE_NTOHL (0x726f6669), 
  ACE_NTOHL (0x6c65426f), 
  ACE_NTOHL (0x64793a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/MIOP/UIPMC_ProfileBody:1.0
  18,
  ACE_NTOHL (0x5549504d), 
  ACE_NTOHL (0x435f5072), 
  ACE_NTOHL (0x6f66696c), 
  ACE_NTOHL (0x65426f64), 
  ACE_NTOHL (0x79000000),  // name = UIPMC_ProfileBody
  4, // member count
  13,
  ACE_NTOHL (0x6d696f70), 
  ACE_NTOHL (0x5f766572), 
  ACE_NTOHL (0x73696f6e), 
  ACE_NTOHL (0x0),  // name = miop_version
  CORBA::tk_alias, // typecode kind for typedefs
  148, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    29,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x4d494f50), 
    ACE_NTOHL (0x2f566572), 
    ACE_NTOHL (0x73696f6e), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/MIOP/Version:1.0
    8,
    ACE_NTOHL (0x56657273), 
    ACE_NTOHL (0x696f6e00),  // name = Version
    CORBA::tk_struct, // typecode kind
    88, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      29,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x47494f50), 
      ACE_NTOHL (0x2f566572), 
      ACE_NTOHL (0x73696f6e), 
      ACE_NTOHL (0x3a312e30), 
      ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/GIOP/Version:1.0
      8,
      ACE_NTOHL (0x56657273), 
      ACE_NTOHL (0x696f6e00),  // name = Version
      2, // member count
      6,
      ACE_NTOHL (0x6d616a6f), 
      ACE_NTOHL (0x72000000),  // name = major
      CORBA::tk_octet,

      6,
      ACE_NTOHL (0x6d696e6f), 
      ACE_NTOHL (0x72000000),  // name = minor
      CORBA::tk_octet,



  12,
  ACE_NTOHL (0x7468655f), 
  ACE_NTOHL (0x61646472), 
  ACE_NTOHL (0x65737300),  // name = the_address
  CORBA::tk_alias, // typecode kind for typedefs
  60, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    29,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x4d494f50), 
    ACE_NTOHL (0x2f416464), 
    ACE_NTOHL (0x72657373), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/MIOP/Address:1.0
    8,
    ACE_NTOHL (0x41646472), 
    ACE_NTOHL (0x65737300),  // name = Address
    CORBA::tk_string, 
    0U, // string length

  9,
  ACE_NTOHL (0x7468655f), 
  ACE_NTOHL (0x706f7274), 
  ACE_NTOHL (0x0),  // name = the_port
  CORBA::tk_short,

  11,
  ACE_NTOHL (0x636f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74730000),  // name = components
  CORBA::tk_sequence, // typecode kind
  200, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    184, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      36,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x494f502f), 
      ACE_NTOHL (0x54616767), 
      ACE_NTOHL (0x6564436f), 
      ACE_NTOHL (0x6d706f6e), 
      ACE_NTOHL (0x656e743a), 
      ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IOP/TaggedComponent:1.0
      16,
      ACE_NTOHL (0x54616767), 
      ACE_NTOHL (0x6564436f), 
      ACE_NTOHL (0x6d706f6e), 
      ACE_NTOHL (0x656e7400),  // name = TaggedComponent
      2, // member count
      4,
      ACE_NTOHL (0x74616700),  // name = tag
      CORBA::tk_alias, // typecode kind for typedefs
      60, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x494f502f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x7449643a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IOP/ComponentId:1.0
        12,
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74496400),  // name = ComponentId
        CORBA::tk_ulong,


      15,
      ACE_NTOHL (0x636f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x745f6461), 
      ACE_NTOHL (0x74610000),  // name = component_data
      CORBA::tk_sequence, // typecode kind
      12, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        CORBA::tk_octet,

        0U,


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_MIOP_UIPMC_ProfileBody (
    CORBA::tk_struct,
    sizeof (_oc_MIOP_UIPMC_ProfileBody),
    (char *) &_oc_MIOP_UIPMC_ProfileBody,
    0,
    sizeof (MIOP::UIPMC_ProfileBody)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (MIOP)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UIPMC_ProfileBody, &_tc_TAO_tc_MIOP_UIPMC_ProfileBody)
TAO_NAMESPACE_END

void MIOP::UIPMC_ProfileBody::_tao_any_destructor (void *x)
{
  UIPMC_ProfileBody *tmp = ACE_static_cast (UIPMC_ProfileBody*,x);
  delete tmp;
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_MIOP_UIPMC_PROFILEBODY__TAO_SEQ_TAGGEDCOMPONENT_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_MIOP_UIPMC_PROFILEBODY__TAO_SEQ_TAGGEDCOMPONENT_CS_

  void
  MIOP::UIPMC_ProfileBody::_TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent::_allocate_buffer (CORBA::ULong length)
  {
    IOP::TaggedComponent* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IOP::TaggedComponent *old = ACE_reinterpret_cast (IOP::TaggedComponent *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  MIOP::UIPMC_ProfileBody::_TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    IOP::TaggedComponent *tmp = ACE_reinterpret_cast (IOP::TaggedComponent *,this->buffer_);
    
    _TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  MIOP::UIPMC_ProfileBody::_TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent::~_TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_MIOP_UIPMC_PROFILEBODY__TAO_SEQ_TAGGEDCOMPONENT_CS_)
#define _MIOP_UIPMC_PROFILEBODY__TAO_SEQ_TAGGEDCOMPONENT_CS_

// *************************************************************
// MIOP::UIPMC_ProfileBody::_tao_seq_TaggedComponent
// *************************************************************

MIOP::UIPMC_ProfileBody::_tao_seq_TaggedComponent::_tao_seq_TaggedComponent (void)
{}
MIOP::UIPMC_ProfileBody::_tao_seq_TaggedComponent::_tao_seq_TaggedComponent (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IOP::TaggedComponent>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
MIOP::UIPMC_ProfileBody::_tao_seq_TaggedComponent::_tao_seq_TaggedComponent (CORBA::ULong max, CORBA::ULong length, IOP::TaggedComponent *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IOP::TaggedComponent>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
MIOP::UIPMC_ProfileBody::_tao_seq_TaggedComponent::_tao_seq_TaggedComponent (const _tao_seq_TaggedComponent &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IOP::TaggedComponent>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
MIOP::UIPMC_ProfileBody::_tao_seq_TaggedComponent::~_tao_seq_TaggedComponent (void) // dtor
{}
void MIOP::UIPMC_ProfileBody::_tao_seq_TaggedComponent::_tao_any_destructor (void *x)
{
  _tao_seq_TaggedComponent *tmp = ACE_static_cast (_tao_seq_TaggedComponent*,x);
  delete tmp;
}


#endif /* end #if !defined */

MIOP::MulticastObjectGroupFactory_ptr
tao_MIOP_MulticastObjectGroupFactory_duplicate (
    MIOP::MulticastObjectGroupFactory_ptr p
  )
{
  return MIOP::MulticastObjectGroupFactory::_duplicate (p);
}

void
tao_MIOP_MulticastObjectGroupFactory_release (
    MIOP::MulticastObjectGroupFactory_ptr p
  )
{
  CORBA::release (p);
}

MIOP::MulticastObjectGroupFactory_ptr
tao_MIOP_MulticastObjectGroupFactory_nil (
    void
  )
{
  return MIOP::MulticastObjectGroupFactory::_nil ();
}

MIOP::MulticastObjectGroupFactory_ptr
tao_MIOP_MulticastObjectGroupFactory_narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return MIOP::MulticastObjectGroupFactory::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
tao_MIOP_MulticastObjectGroupFactory_upcast (
    void *src
  )
{
  MIOP::MulticastObjectGroupFactory **tmp =
    ACE_static_cast (MIOP::MulticastObjectGroupFactory **, src);
  return *tmp;
}

// *************************************************************
// Operations for class MIOP::MulticastObjectGroupFactory_var
// *************************************************************

MIOP::MulticastObjectGroupFactory_var::MulticastObjectGroupFactory_var (void) // default constructor
  : ptr_ (MulticastObjectGroupFactory::_nil ())
{}

::MIOP::MulticastObjectGroupFactory_ptr
MIOP::MulticastObjectGroupFactory_var::ptr (void) const
{
  return this->ptr_;
}

MIOP::MulticastObjectGroupFactory_var::MulticastObjectGroupFactory_var (const ::MIOP::MulticastObjectGroupFactory_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (MulticastObjectGroupFactory::_duplicate (p.ptr ()))
{}

MIOP::MulticastObjectGroupFactory_var::~MulticastObjectGroupFactory_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

MIOP::MulticastObjectGroupFactory_var &
MIOP::MulticastObjectGroupFactory_var::operator= (MulticastObjectGroupFactory_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

MIOP::MulticastObjectGroupFactory_var &
MIOP::MulticastObjectGroupFactory_var::operator= (const ::MIOP::MulticastObjectGroupFactory_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::MIOP::MulticastObjectGroupFactory::_duplicate (p.ptr ());
  }
  return *this;
}

MIOP::MulticastObjectGroupFactory_var::operator const ::MIOP::MulticastObjectGroupFactory_ptr &() const // cast
{
  return this->ptr_;
}

MIOP::MulticastObjectGroupFactory_var::operator ::MIOP::MulticastObjectGroupFactory_ptr &() // cast 
{
  return this->ptr_;
}

::MIOP::MulticastObjectGroupFactory_ptr
MIOP::MulticastObjectGroupFactory_var::operator-> (void) const
{
  return this->ptr_;
}

::MIOP::MulticastObjectGroupFactory_ptr
MIOP::MulticastObjectGroupFactory_var::in (void) const
{
  return this->ptr_;
}

::MIOP::MulticastObjectGroupFactory_ptr &
MIOP::MulticastObjectGroupFactory_var::inout (void)
{
  return this->ptr_;
}

::MIOP::MulticastObjectGroupFactory_ptr &
MIOP::MulticastObjectGroupFactory_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::MIOP::MulticastObjectGroupFactory::_nil ();
  return this->ptr_;
}

::MIOP::MulticastObjectGroupFactory_ptr
MIOP::MulticastObjectGroupFactory_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::MIOP::MulticastObjectGroupFactory_ptr val = this->ptr_;
  this->ptr_ = ::MIOP::MulticastObjectGroupFactory::_nil ();
  return val;
}

::MIOP::MulticastObjectGroupFactory_ptr
MIOP::MulticastObjectGroupFactory_var::duplicate (MulticastObjectGroupFactory_ptr p)
{
  return ::MIOP::MulticastObjectGroupFactory::_duplicate (p);
}

void
MIOP::MulticastObjectGroupFactory_var::release (MulticastObjectGroupFactory_ptr p)
{
  CORBA::release (p);
}

::MIOP::MulticastObjectGroupFactory_ptr
MIOP::MulticastObjectGroupFactory_var::nil (void)
{
  return ::MIOP::MulticastObjectGroupFactory::_nil ();
}

::MIOP::MulticastObjectGroupFactory_ptr
MIOP::MulticastObjectGroupFactory_var::narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return ::MIOP::MulticastObjectGroupFactory::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
MIOP::MulticastObjectGroupFactory_var::upcast (void *src)
{
  MulticastObjectGroupFactory **tmp =
    ACE_static_cast (MulticastObjectGroupFactory **, src);
  return *tmp;
}

// *************************************************************
// Operations for class MIOP::MulticastObjectGroupFactory_out
// *************************************************************

MIOP::MulticastObjectGroupFactory_out::MulticastObjectGroupFactory_out (MulticastObjectGroupFactory_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::MIOP::MulticastObjectGroupFactory::_nil ();
}

MIOP::MulticastObjectGroupFactory_out::MulticastObjectGroupFactory_out (MulticastObjectGroupFactory_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::MIOP::MulticastObjectGroupFactory::_nil ();
}

MIOP::MulticastObjectGroupFactory_out::MulticastObjectGroupFactory_out (const ::MIOP::MulticastObjectGroupFactory_out &p) // copy constructor
  : ptr_ (ACE_const_cast (MulticastObjectGroupFactory_out &, p).ptr_)
{}

::MIOP::MulticastObjectGroupFactory_out &
MIOP::MulticastObjectGroupFactory_out::operator= (const ::MIOP::MulticastObjectGroupFactory_out &p)
{
  this->ptr_ = ACE_const_cast (MulticastObjectGroupFactory_out&, p).ptr_;
  return *this;
}

MIOP::MulticastObjectGroupFactory_out &
MIOP::MulticastObjectGroupFactory_out::operator= (const ::MIOP::MulticastObjectGroupFactory_var &p)
{
  this->ptr_ = ::MIOP::MulticastObjectGroupFactory::_duplicate (p.ptr ());
  return *this;
}

MIOP::MulticastObjectGroupFactory_out &
MIOP::MulticastObjectGroupFactory_out::operator= (MulticastObjectGroupFactory_ptr p)
{
  this->ptr_ = p;
  return *this;
}

MIOP::MulticastObjectGroupFactory_out::operator ::MIOP::MulticastObjectGroupFactory_ptr &() // cast
{
  return this->ptr_;
}

::MIOP::MulticastObjectGroupFactory_ptr &
MIOP::MulticastObjectGroupFactory_out::ptr (void) // ptr
{
  return this->ptr_;
}

::MIOP::MulticastObjectGroupFactory_ptr
MIOP::MulticastObjectGroupFactory_out::operator-> (void)
{
  return this->ptr_;
}


// default constructor
MIOP::MulticastObjectGroupFactory::MulticastObjectGroupFactory ()
{
  }

// destructor
MIOP::MulticastObjectGroupFactory::~MulticastObjectGroupFactory (void)
{}

MIOP::MulticastObjectGroupFactory_ptr MIOP::MulticastObjectGroupFactory::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return MulticastObjectGroupFactory::_unchecked_narrow (obj, ACE_TRY_ENV);
}

MIOP::MulticastObjectGroupFactory_ptr MIOP::MulticastObjectGroupFactory::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return MulticastObjectGroupFactory::_nil ();
  return
      ACE_reinterpret_cast
        (
          MulticastObjectGroupFactory_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &MulticastObjectGroupFactory::_narrow
                  )
              )
        );
}

MIOP::MulticastObjectGroupFactory_ptr
MIOP::MulticastObjectGroupFactory::_duplicate (MulticastObjectGroupFactory_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *MIOP::MulticastObjectGroupFactory::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::MIOP, MulticastObjectGroupFactory)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* MIOP::MulticastObjectGroupFactory::_interface_repository_id (void) const
{
  return "IDL:omg.org/MIOP/MulticastObjectGroupFactory:1.0";
}

void MIOP::MulticastObjectGroupFactory::ipaddr_forany::_tao_any_destructor (void *x)
{
  ipaddr_slice *tmp = ACE_static_cast (ipaddr_slice*,x);
  ipaddr_free (tmp);
}

MIOP::MulticastObjectGroupFactory::ipaddr_slice *
MIOP::MulticastObjectGroupFactory::ipaddr_dup (const MIOP::MulticastObjectGroupFactory::ipaddr_slice *_tao_src_array)
{
  MIOP::MulticastObjectGroupFactory::ipaddr_slice *_tao_dup_array = MIOP::MulticastObjectGroupFactory::ipaddr_alloc ();
  if (!_tao_dup_array) return (MIOP::MulticastObjectGroupFactory::ipaddr_slice *)0;
  MIOP::MulticastObjectGroupFactory::ipaddr_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

MIOP::MulticastObjectGroupFactory::ipaddr_slice *
MIOP::MulticastObjectGroupFactory::ipaddr_alloc (void)
{
  MIOP::MulticastObjectGroupFactory::ipaddr_slice *retval = 0;
  ACE_NEW_RETURN (retval, CORBA::Octet[4], 0);
  return retval;
}

void
MIOP::MulticastObjectGroupFactory::ipaddr_free (MIOP::MulticastObjectGroupFactory::ipaddr_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void 
MIOP::MulticastObjectGroupFactory::ipaddr_copy (MIOP::MulticastObjectGroupFactory::ipaddr_slice * _tao_to, const MIOP::MulticastObjectGroupFactory::ipaddr_slice *_tao_from)
{
  // copy each individual element
  for (CORBA::ULong i0 = 0; i0 < 4; i0++)
    _tao_to[i0] = _tao_from[i0];
}

void operator<<= (
    CORBA::Any &_tao_any,
    const MIOP::UniqueId &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        MIOP::_tc_UniqueId,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, MIOP::UniqueId *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      MIOP::_tc_UniqueId,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      MIOP::UniqueId::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, MIOP::UniqueId *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const MIOP::UniqueId*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const MIOP::UniqueId *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (MIOP::_tc_UniqueId, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const MIOP::UniqueId*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      MIOP::UniqueId *tmp;
      ACE_NEW_RETURN (tmp, MIOP::UniqueId, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            MIOP::_tc_UniqueId,
            1,
            ACE_static_cast (void *, tmp),
            MIOP::UniqueId::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const MIOP::PacketHeader_1_0 &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      MIOP::_tc_PacketHeader_1_0,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, MIOP::PacketHeader_1_0 *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      MIOP::_tc_PacketHeader_1_0,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      MIOP::PacketHeader_1_0::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, MIOP::PacketHeader_1_0 *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const MIOP::PacketHeader_1_0*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const MIOP::PacketHeader_1_0 *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (MIOP::_tc_PacketHeader_1_0, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const MIOP::PacketHeader_1_0*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      MIOP::PacketHeader_1_0 *tmp;
      ACE_NEW_RETURN (tmp, MIOP::PacketHeader_1_0, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            MIOP::_tc_PacketHeader_1_0,
            1,
            ACE_static_cast (void *, tmp),
            MIOP::PacketHeader_1_0::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const MIOP::UIPMC_ProfileBody &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      MIOP::_tc_UIPMC_ProfileBody,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, MIOP::UIPMC_ProfileBody *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      MIOP::_tc_UIPMC_ProfileBody,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      MIOP::UIPMC_ProfileBody::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, MIOP::UIPMC_ProfileBody *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const MIOP::UIPMC_ProfileBody*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const MIOP::UIPMC_ProfileBody *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (MIOP::_tc_UIPMC_ProfileBody, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const MIOP::UIPMC_ProfileBody*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      MIOP::UIPMC_ProfileBody *tmp;
      ACE_NEW_RETURN (tmp, MIOP::UIPMC_ProfileBody, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            MIOP::_tc_UIPMC_ProfileBody,
            1,
            ACE_static_cast (void *, tmp),
            MIOP::UIPMC_ProfileBody::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<MIOP::MulticastObjectGroupFactory,MIOP::MulticastObjectGroupFactory_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<MIOP::MulticastObjectGroupFactory,MIOP::MulticastObjectGroupFactory_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const MIOP::UniqueId &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    MIOP::UniqueId &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    if (_tao_seq_len <= _tao_sequence.maximum ())
    {
      // set the length of the sequence
      _tao_sequence.length (_tao_seq_len);
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        return 1;
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length())
        return 0;
      // retrieve all the elements
      return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
    }
  }
  return 0; // error
}


#if !defined _TAO_CDR_OP_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent_CPP_
#define _TAO_CDR_OP_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const MIOP::UIPMC_ProfileBody::_tao_seq_TaggedComponent &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    MIOP::UIPMC_ProfileBody::_tao_seq_TaggedComponent &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // Add a check to the length of the sequence
    // to make sure it does not exceed the length
    // of the stream. (See bug 58.)
    if (_tao_seq_len > strm.length())
      return 0;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

#endif /* _TAO_CDR_OP_MIOP_UIPMC_ProfileBody__tao_seq_TaggedComponent_CPP_ */

