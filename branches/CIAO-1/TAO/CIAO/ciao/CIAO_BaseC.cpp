// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_codegen.cpp:320

#include "CIAO_BaseC.h"

#include "tao/Stub.h"
#include "tao/Invocation.h"
#include "tao/PortableInterceptor.h"

#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#include "tao/ClientRequestInfo_i.h"
#include "tao/ClientInterceptorAdapter.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */

#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus -w-sig
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "CIAO_BaseC.i"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_FeatureName[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  39,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f46), 
  ACE_NTOHL (0x65617475), 
  ACE_NTOHL (0x72654e61), 
  ACE_NTOHL (0x6d653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
  12,
  ACE_NTOHL (0x46656174), 
  ACE_NTOHL (0x7572654e), 
  ACE_NTOHL (0x616d6500),  // name = FeatureName
  CORBA::tk_string, 
  0U, // string length
};

static CORBA::TypeCode _tc_TAO_tc_Components_FeatureName (
    CORBA::tk_alias,
    sizeof (_oc_Components_FeatureName),
    (char *) &_oc_Components_FeatureName,
    0,
    sizeof (Components::FeatureName)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_FeatureName,
    &_tc_TAO_tc_Components_FeatureName
  )
TAO_NAMESPACE_END

#if !defined (_COMPONENTS_NAMELIST_CS_)
#define _COMPONENTS_NAMELIST_CS_

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// Components::NameList
// *************************************************************

Components::NameList::NameList (void)
{}

Components::NameList::NameList (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_String_Sequence

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

Components::NameList::NameList (
    CORBA::ULong max,
    CORBA::ULong length,
    char * *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_String_Sequence

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

Components::NameList::NameList (const NameList &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_String_Sequence

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

Components::NameList::~NameList (void) // dtor
{}

void Components::NameList::_tao_any_destructor (void *_tao_void_pointer)
{
  NameList *tmp = ACE_static_cast (NameList*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_NameList[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  36,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f4e), 
  ACE_NTOHL (0x616d654c), 
  ACE_NTOHL (0x6973743a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/NameList:1.0
  9,
  ACE_NTOHL (0x4e616d65), 
  ACE_NTOHL (0x4c697374), 
  ACE_NTOHL (0x0),  // name = NameList
  CORBA::tk_sequence, // typecode kind
  88, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      39,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f46), 
      ACE_NTOHL (0x65617475), 
      ACE_NTOHL (0x72654e61), 
      ACE_NTOHL (0x6d653a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
      12,
      ACE_NTOHL (0x46656174), 
      ACE_NTOHL (0x7572654e), 
      ACE_NTOHL (0x616d6500),  // name = FeatureName
      CORBA::tk_string, 
      0U, // string length

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_Components_NameList (
    CORBA::tk_alias,
    sizeof (_oc_Components_NameList),
    (char *) &_oc_Components_NameList,
    0,
    sizeof (Components::NameList)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_NameList,
    &_tc_TAO_tc_Components_NameList
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_Cookie[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x6f6f6b69), 
  ACE_NTOHL (0x653a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Cookie:1.0
  7,
  ACE_NTOHL (0x436f6f6b), 
  ACE_NTOHL (0x69650000),  // name = Cookie
  0, // value modifier
  CORBA::tk_null, // no stateful base valuetype

  1, // member count
  12,
  ACE_NTOHL (0x636f6f6b), 
  ACE_NTOHL (0x69655661), 
  ACE_NTOHL (0x6c756500),  // name = cookieValue
  CORBA::tk_alias, // typecode kind for typedefs
  76, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4f63), 
    ACE_NTOHL (0x74657453), 
    ACE_NTOHL (0x65713a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OctetSeq:1.0
    9,
    ACE_NTOHL (0x4f637465), 
    ACE_NTOHL (0x74536571), 
    ACE_NTOHL (0x0),  // name = OctetSeq
    CORBA::tk_sequence, // typecode kind
    12, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_octet,

      0U,


  0, // data member visibility marker

};

static CORBA::TypeCode _tc_TAO_tc_Components_Cookie (
    CORBA::tk_value,
    sizeof (_oc_Components_Cookie),
    (char *) &_oc_Components_Cookie,
    0,
    sizeof (Components::Cookie)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_Cookie,
    &_tc_TAO_tc_Components_Cookie
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_cs.cpp:95

void
tao_Components_Cookie_add_ref (
    Components::Cookie *p
  )
{
  CORBA::add_ref (p);
}

void
tao_Components_Cookie_remove_ref (
    Components::Cookie *p
  )
{
  CORBA::remove_ref (p);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:298

// *************************************************************
// Operations for class Components::Cookie_var
// *************************************************************

Components::Cookie_var::Cookie_var (void)
  : ptr_ (0)
{}

Components::Cookie_var::Cookie_var (Cookie* p)
  : ptr_ (p)
{}

Components::Cookie_var::Cookie_var (const Cookie* p)
  : ptr_ (ACE_const_cast (Cookie *, p))
{}

Components::Cookie *
Components::Cookie_var::ptr (void) const
{
  return this->ptr_;
}

Components::Cookie_var::Cookie_var (const Cookie_var &p)
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::Cookie_var::~Cookie_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::Cookie_var &
Components::Cookie_var::operator= (Cookie *p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::Cookie_var &
Components::Cookie_var::operator= (const Cookie_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    Cookie *tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  
  return *this;
}

Components::Cookie_var::operator const Components::Cookie* () const // cast
{
  return this->ptr_;
}

Components::Cookie_var::operator Components::Cookie* () // cast 
{
  return this->ptr_;
}

Components::Cookie *
Components::Cookie_var::operator-> (void) const
{
  return this->ptr_;
}

Components::Cookie *
Components::Cookie_var::in (void) const
{
  return this->ptr_;
}

Components::Cookie *&
Components::Cookie_var::inout (void)
{
  return this->ptr_;
}

Components::Cookie *&
Components::Cookie_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::Cookie *
Components::Cookie_var::_retn (void)
{
  // yield ownership of managed obj reference
  Cookie* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

void
Components::Cookie_var::tao_add_ref (
    Cookie *p
  )
{
  CORBA::add_ref (p);
}

void
Components::Cookie_var::tao_remove_ref (
    Cookie *p
  )
{
  CORBA::remove_ref (p);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:568

// *************************************************************
// Operations for class Components::Cookie_out
// *************************************************************

Components::Cookie_out::Cookie_out (Cookie *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::Cookie_out::Cookie_out (Cookie_var &p)
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::Cookie_out::Cookie_out (const Cookie_out &p)
  : ptr_ (ACE_const_cast (Cookie_out&, p).ptr_)
{}

Components::Cookie_out &
Components::Cookie_out::operator= (const Cookie_out &p)
{
  this->ptr_ = ACE_const_cast (Cookie_out&, p).ptr_;
  return *this;
}

Components::Cookie_out &
Components::Cookie_out::operator= (const Cookie_var &p)
{
  Cookie *tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::Cookie_out &
Components::Cookie_out::operator= (Cookie *p)
{
  this->ptr_ = p;
  return *this;
}

Components::Cookie_out::operator Components::Cookie*& () // cast
{
  return this->ptr_;
}

Components::Cookie *&
Components::Cookie_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::Cookie *
Components::Cookie_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_cs.cpp:138

Components::Cookie *
Components::Cookie::_downcast (CORBA::ValueBase *v)
{
  if (v == 0)
    {
      return 0;
    }
  
  return (Cookie *) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char *
Components::Cookie::_tao_obv_repository_id (void) const
{
  return this->_tao_obv_static_repository_id ();
}

void *
Components::Cookie::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    {
      return this;
    }
  
  void *rval = 0;
  
  return rval;
}

void
Components::Cookie::_tao_any_destructor (void *_tao_void_pointer)
{
  Cookie *tmp =
    ACE_static_cast (
        Cookie *,
        _tao_void_pointer
      );
  delete tmp;
}

CORBA::Boolean Components::Cookie::_tao_marshal_v (TAO_OutputCDR & strm)
{
  return this->_tao_marshal__Components_Cookie (strm);
}

CORBA::Boolean Components::Cookie::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  return this->_tao_unmarshal__Components_Cookie (strm);
}

CORBA::Boolean Components::Cookie::_tao_unmarshal (
    TAO_InputCDR &strm,
    Cookie *&new_object
  )
{
  CORBA::ValueBase *base = 0;
  CORBA::ValueFactory_var factory;
  CORBA::Boolean retval =
    CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        factory,
        base,
        Cookie::_tao_obv_static_repository_id ()
      );
  
  if (retval == 0)
    {
      return 0;
    }
  
  if (factory.in () != 0)
    {
      base = factory->create_for_unmarshal ();
      
      if (base == 0)
        {
          return 0;  // %! except.?
        }
      
      retval = base->_tao_unmarshal_v (strm);
      
      if (retval == 0)
        {
          return 0;
        }
    }
  
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = Cookie::_downcast (base);
  return retval;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_init_cs.cpp:84

Components::Cookie_init::Cookie_init (void)
{
}

Components::Cookie_init::~Cookie_init (void)
{
}

const char* 
Components::Cookie_init::tao_repository_id (void)
{
  return Components::Cookie::_tao_obv_static_repository_id ();
}

CORBA_ValueBase *
Components::Cookie_init::create_for_unmarshal (void)
{
  CORBA_ValueBase *ret_val = 0;
  ACE_NEW_RETURN (
      ret_val,
      OBV_Components::Cookie,
      0
    );
  return ret_val;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_PortDescription[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  43,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f50), 
  ACE_NTOHL (0x6f727444), 
  ACE_NTOHL (0x65736372), 
  ACE_NTOHL (0x69707469), 
  ACE_NTOHL (0x6f6e3a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/PortDescription:1.0
  16,
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e00),  // name = PortDescription
  0, // value modifier
  CORBA::tk_null, // no stateful base valuetype

  2, // member count
  5,
  ACE_NTOHL (0x4e616d65), 
  ACE_NTOHL (0x0),  // name = Name
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    39,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f46), 
    ACE_NTOHL (0x65617475), 
    ACE_NTOHL (0x72654e61), 
    ACE_NTOHL (0x6d653a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
    12,
    ACE_NTOHL (0x46656174), 
    ACE_NTOHL (0x7572654e), 
    ACE_NTOHL (0x616d6500),  // name = FeatureName
    CORBA::tk_string, 
    0U, // string length

  1, // data member visibility marker

  8,
  ACE_NTOHL (0x74797065), 
  ACE_NTOHL (0x5f696400),  // name = type_id
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5265), 
    ACE_NTOHL (0x706f7369), 
    ACE_NTOHL (0x746f7279), 
    ACE_NTOHL (0x49643a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  1, // data member visibility marker

};

static CORBA::TypeCode _tc_TAO_tc_Components_PortDescription (
    CORBA::tk_value,
    sizeof (_oc_Components_PortDescription),
    (char *) &_oc_Components_PortDescription,
    0,
    sizeof (Components::PortDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_PortDescription,
    &_tc_TAO_tc_Components_PortDescription
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_cs.cpp:95

void
tao_Components_PortDescription_add_ref (
    Components::PortDescription *p
  )
{
  CORBA::add_ref (p);
}

void
tao_Components_PortDescription_remove_ref (
    Components::PortDescription *p
  )
{
  CORBA::remove_ref (p);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:298

// *************************************************************
// Operations for class Components::PortDescription_var
// *************************************************************

Components::PortDescription_var::PortDescription_var (void)
  : ptr_ (0)
{}

Components::PortDescription_var::PortDescription_var (PortDescription* p)
  : ptr_ (p)
{}

Components::PortDescription_var::PortDescription_var (const PortDescription* p)
  : ptr_ (ACE_const_cast (PortDescription *, p))
{}

Components::PortDescription *
Components::PortDescription_var::ptr (void) const
{
  return this->ptr_;
}

Components::PortDescription_var::PortDescription_var (const PortDescription_var &p)
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::PortDescription_var::~PortDescription_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::PortDescription_var &
Components::PortDescription_var::operator= (PortDescription *p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::PortDescription_var &
Components::PortDescription_var::operator= (const PortDescription_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    PortDescription *tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  
  return *this;
}

Components::PortDescription_var::operator const Components::PortDescription* () const // cast
{
  return this->ptr_;
}

Components::PortDescription_var::operator Components::PortDescription* () // cast 
{
  return this->ptr_;
}

Components::PortDescription *
Components::PortDescription_var::operator-> (void) const
{
  return this->ptr_;
}

Components::PortDescription *
Components::PortDescription_var::in (void) const
{
  return this->ptr_;
}

Components::PortDescription *&
Components::PortDescription_var::inout (void)
{
  return this->ptr_;
}

Components::PortDescription *&
Components::PortDescription_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::PortDescription *
Components::PortDescription_var::_retn (void)
{
  // yield ownership of managed obj reference
  PortDescription* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

void
Components::PortDescription_var::tao_add_ref (
    PortDescription *p
  )
{
  CORBA::add_ref (p);
}

void
Components::PortDescription_var::tao_remove_ref (
    PortDescription *p
  )
{
  CORBA::remove_ref (p);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:568

// *************************************************************
// Operations for class Components::PortDescription_out
// *************************************************************

Components::PortDescription_out::PortDescription_out (PortDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::PortDescription_out::PortDescription_out (PortDescription_var &p)
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::PortDescription_out::PortDescription_out (const PortDescription_out &p)
  : ptr_ (ACE_const_cast (PortDescription_out&, p).ptr_)
{}

Components::PortDescription_out &
Components::PortDescription_out::operator= (const PortDescription_out &p)
{
  this->ptr_ = ACE_const_cast (PortDescription_out&, p).ptr_;
  return *this;
}

Components::PortDescription_out &
Components::PortDescription_out::operator= (const PortDescription_var &p)
{
  PortDescription *tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::PortDescription_out &
Components::PortDescription_out::operator= (PortDescription *p)
{
  this->ptr_ = p;
  return *this;
}

Components::PortDescription_out::operator Components::PortDescription*& () // cast
{
  return this->ptr_;
}

Components::PortDescription *&
Components::PortDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::PortDescription *
Components::PortDescription_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_cs.cpp:138

Components::PortDescription *
Components::PortDescription::_downcast (CORBA::ValueBase *v)
{
  if (v == 0)
    {
      return 0;
    }
  
  return (PortDescription *) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char *
Components::PortDescription::_tao_obv_repository_id (void) const
{
  return this->_tao_obv_static_repository_id ();
}

void *
Components::PortDescription::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    {
      return this;
    }
  
  void *rval = 0;
  
  return rval;
}

void
Components::PortDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  PortDescription *tmp =
    ACE_static_cast (
        PortDescription *,
        _tao_void_pointer
      );
  delete tmp;
}

CORBA::Boolean Components::PortDescription::_tao_marshal_v (TAO_OutputCDR & strm)
{
  return this->_tao_marshal__Components_PortDescription (strm);
}

CORBA::Boolean Components::PortDescription::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  return this->_tao_unmarshal__Components_PortDescription (strm);
}

CORBA::Boolean Components::PortDescription::_tao_unmarshal (
    TAO_InputCDR &strm,
    PortDescription *&new_object
  )
{
  CORBA::ValueBase *base = 0;
  CORBA::ValueFactory_var factory;
  CORBA::Boolean retval =
    CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        factory,
        base,
        PortDescription::_tao_obv_static_repository_id ()
      );
  
  if (retval == 0)
    {
      return 0;
    }
  
  if (factory.in () != 0)
    {
      base = factory->create_for_unmarshal ();
      
      if (base == 0)
        {
          return 0;  // %! except.?
        }
      
      retval = base->_tao_unmarshal_v (strm);
      
      if (retval == 0)
        {
          return 0;
        }
    }
  
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = PortDescription::_downcast (base);
  return retval;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_init_cs.cpp:84

Components::PortDescription_init::PortDescription_init (void)
{
}

Components::PortDescription_init::~PortDescription_init (void)
{
}

const char* 
Components::PortDescription_init::tao_repository_id (void)
{
  return Components::PortDescription::_tao_obv_static_repository_id ();
}

CORBA_ValueBase *
Components::PortDescription_init::create_for_unmarshal (void)
{
  CORBA_ValueBase *ret_val = 0;
  ACE_NEW_RETURN (
      ret_val,
      OBV_Components::PortDescription,
      0
    );
  return ret_val;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_FacetDescription[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  44,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f46), 
  ACE_NTOHL (0x61636574), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e3a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/FacetDescription:1.0
  17,
  ACE_NTOHL (0x46616365), 
  ACE_NTOHL (0x74446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x0),  // name = FacetDescription
  0, // value modifier
  CORBA::tk_value, // typecode kind
  276, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    43,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f50), 
    ACE_NTOHL (0x6f727444), 
    ACE_NTOHL (0x65736372), 
    ACE_NTOHL (0x69707469), 
    ACE_NTOHL (0x6f6e3a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/PortDescription:1.0
    16,
    ACE_NTOHL (0x506f7274), 
    ACE_NTOHL (0x44657363), 
    ACE_NTOHL (0x72697074), 
    ACE_NTOHL (0x696f6e00),  // name = PortDescription
    0, // value modifier
    CORBA::tk_null, // no stateful base valuetype

    2, // member count
    5,
    ACE_NTOHL (0x4e616d65), 
    ACE_NTOHL (0x0),  // name = Name
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      39,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f46), 
      ACE_NTOHL (0x65617475), 
      ACE_NTOHL (0x72654e61), 
      ACE_NTOHL (0x6d653a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
      12,
      ACE_NTOHL (0x46656174), 
      ACE_NTOHL (0x7572654e), 
      ACE_NTOHL (0x616d6500),  // name = FeatureName
      CORBA::tk_string, 
      0U, // string length

    1, // data member visibility marker

    8,
    ACE_NTOHL (0x74797065), 
    ACE_NTOHL (0x5f696400),  // name = type_id
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f5265), 
      ACE_NTOHL (0x706f7369), 
      ACE_NTOHL (0x746f7279), 
      ACE_NTOHL (0x49643a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13,
      ACE_NTOHL (0x5265706f), 
      ACE_NTOHL (0x7369746f), 
      ACE_NTOHL (0x72794964), 
      ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length

    1, // data member visibility marker


  1, // member count
  10,
  ACE_NTOHL (0x66616365), 
  ACE_NTOHL (0x745f7265), 
  ACE_NTOHL (0x66000000),  // name = facet_ref
    1, // data member visibility marker

};

static CORBA::TypeCode _tc_TAO_tc_Components_FacetDescription (
    CORBA::tk_value,
    sizeof (_oc_Components_FacetDescription),
    (char *) &_oc_Components_FacetDescription,
    0,
    sizeof (Components::FacetDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_FacetDescription,
    &_tc_TAO_tc_Components_FacetDescription
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_cs.cpp:95

void
tao_Components_FacetDescription_add_ref (
    Components::FacetDescription *p
  )
{
  CORBA::add_ref (p);
}

void
tao_Components_FacetDescription_remove_ref (
    Components::FacetDescription *p
  )
{
  CORBA::remove_ref (p);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:298

// *************************************************************
// Operations for class Components::FacetDescription_var
// *************************************************************

Components::FacetDescription_var::FacetDescription_var (void)
  : ptr_ (0)
{}

Components::FacetDescription_var::FacetDescription_var (FacetDescription* p)
  : ptr_ (p)
{}

Components::FacetDescription_var::FacetDescription_var (const FacetDescription* p)
  : ptr_ (ACE_const_cast (FacetDescription *, p))
{}

Components::FacetDescription *
Components::FacetDescription_var::ptr (void) const
{
  return this->ptr_;
}

Components::FacetDescription_var::FacetDescription_var (const FacetDescription_var &p)
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::FacetDescription_var::~FacetDescription_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::FacetDescription_var &
Components::FacetDescription_var::operator= (FacetDescription *p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::FacetDescription_var &
Components::FacetDescription_var::operator= (const FacetDescription_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    FacetDescription *tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  
  return *this;
}

Components::FacetDescription_var::operator const Components::FacetDescription* () const // cast
{
  return this->ptr_;
}

Components::FacetDescription_var::operator Components::FacetDescription* () // cast 
{
  return this->ptr_;
}

Components::FacetDescription *
Components::FacetDescription_var::operator-> (void) const
{
  return this->ptr_;
}

Components::FacetDescription *
Components::FacetDescription_var::in (void) const
{
  return this->ptr_;
}

Components::FacetDescription *&
Components::FacetDescription_var::inout (void)
{
  return this->ptr_;
}

Components::FacetDescription *&
Components::FacetDescription_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::FacetDescription *
Components::FacetDescription_var::_retn (void)
{
  // yield ownership of managed obj reference
  FacetDescription* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

void
Components::FacetDescription_var::tao_add_ref (
    FacetDescription *p
  )
{
  CORBA::add_ref (p);
}

void
Components::FacetDescription_var::tao_remove_ref (
    FacetDescription *p
  )
{
  CORBA::remove_ref (p);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:568

// *************************************************************
// Operations for class Components::FacetDescription_out
// *************************************************************

Components::FacetDescription_out::FacetDescription_out (FacetDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::FacetDescription_out::FacetDescription_out (FacetDescription_var &p)
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::FacetDescription_out::FacetDescription_out (const FacetDescription_out &p)
  : ptr_ (ACE_const_cast (FacetDescription_out&, p).ptr_)
{}

Components::FacetDescription_out &
Components::FacetDescription_out::operator= (const FacetDescription_out &p)
{
  this->ptr_ = ACE_const_cast (FacetDescription_out&, p).ptr_;
  return *this;
}

Components::FacetDescription_out &
Components::FacetDescription_out::operator= (const FacetDescription_var &p)
{
  FacetDescription *tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::FacetDescription_out &
Components::FacetDescription_out::operator= (FacetDescription *p)
{
  this->ptr_ = p;
  return *this;
}

Components::FacetDescription_out::operator Components::FacetDescription*& () // cast
{
  return this->ptr_;
}

Components::FacetDescription *&
Components::FacetDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::FacetDescription *
Components::FacetDescription_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_cs.cpp:138

Components::FacetDescription *
Components::FacetDescription::_downcast (CORBA::ValueBase *v)
{
  if (v == 0)
    {
      return 0;
    }
  
  return (FacetDescription *) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char *
Components::FacetDescription::_tao_obv_repository_id (void) const
{
  return this->_tao_obv_static_repository_id ();
}

void *
Components::FacetDescription::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    {
      return this;
    }
  
  void *rval = 0;
  
  if (rval == 0)
    {
      rval = ACE_NESTED_CLASS (Components,PortDescription)::_tao_obv_narrow (type_id);
    }
  
  return rval;
}

void
Components::FacetDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  FacetDescription *tmp =
    ACE_static_cast (
        FacetDescription *,
        _tao_void_pointer
      );
  delete tmp;
}

CORBA::Boolean Components::FacetDescription::_tao_marshal_v (TAO_OutputCDR & strm)
{
  return this->_tao_marshal__Components_FacetDescription (strm);
}

CORBA::Boolean Components::FacetDescription::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  return this->_tao_unmarshal__Components_FacetDescription (strm);
}

CORBA::Boolean Components::FacetDescription::_tao_unmarshal (
    TAO_InputCDR &strm,
    FacetDescription *&new_object
  )
{
  CORBA::ValueBase *base = 0;
  CORBA::ValueFactory_var factory;
  CORBA::Boolean retval =
    CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        factory,
        base,
        FacetDescription::_tao_obv_static_repository_id ()
      );
  
  if (retval == 0)
    {
      return 0;
    }
  
  if (factory.in () != 0)
    {
      base = factory->create_for_unmarshal ();
      
      if (base == 0)
        {
          return 0;  // %! except.?
        }
      
      retval = base->_tao_unmarshal_v (strm);
      
      if (retval == 0)
        {
          return 0;
        }
    }
  
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = FacetDescription::_downcast (base);
  return retval;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_init_cs.cpp:84

Components::FacetDescription_init::FacetDescription_init (void)
{
}

Components::FacetDescription_init::~FacetDescription_init (void)
{
}

const char* 
Components::FacetDescription_init::tao_repository_id (void)
{
  return Components::FacetDescription::_tao_obv_static_repository_id ();
}

CORBA_ValueBase *
Components::FacetDescription_init::create_for_unmarshal (void)
{
  CORBA_ValueBase *ret_val = 0;
  ACE_NEW_RETURN (
      ret_val,
      OBV_Components::FacetDescription,
      0
    );
  return ret_val;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_obj_sequence_cs.cpp:103

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_FACETDESCRIPTIONS_CS_)
#define __TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_FACETDESCRIPTIONS_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions::_allocate_buffer (CORBA::ULong length)
{
  Components::FacetDescription **tmp = 0;
  tmp = _TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      Components::FacetDescription **old = ACE_reinterpret_cast (Components::FacetDescription**, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          if (!this->release_)
            {
              tao_Components_FacetDescription_add_ref (old[i]);
              tmp[i] = old[i];
            }
          else
            {
              tmp[i] = old[i];
            }
        }
      
      if (this->release_)
        {
          delete [] old;
        }
    }
  
  this->buffer_ = tmp;
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  Components::FacetDescription **tmp = ACE_reinterpret_cast (Components::FacetDescription**, this->buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      tao_Components_FacetDescription_remove_ref (tmp[i]);
      tmp[i] = 0;
    }
  
  _TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions::freebuf (tmp);
  this->buffer_ = 0;
}

Components::_TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions::~_TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions (void)
{
  this->_deallocate_buffer ();
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  Components::FacetDescription **tmp = ACE_reinterpret_cast (Components::FacetDescription**, this->buffer_);
  
  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      tao_Components_FacetDescription_remove_ref (tmp[i]);
      tmp[i] = 0;
    }
}



#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_FACETDESCRIPTIONS_CS_)
#define _COMPONENTS_FACETDESCRIPTIONS_CS_

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// Components::FacetDescriptions
// *************************************************************

Components::FacetDescriptions::FacetDescriptions (void)
{}

Components::FacetDescriptions::FacetDescriptions (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::FacetDescription,Components::FacetDescription_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

Components::FacetDescriptions::FacetDescriptions (
    CORBA::ULong max,
    CORBA::ULong length,
    Components::FacetDescription_ptr *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::FacetDescription,Components::FacetDescription_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

Components::FacetDescriptions::FacetDescriptions (const FacetDescriptions &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::FacetDescription,Components::FacetDescription_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

Components::FacetDescriptions::~FacetDescriptions (void) // dtor
{}

void Components::FacetDescriptions::_tao_any_destructor (void *_tao_void_pointer)
{
  FacetDescriptions *tmp = ACE_static_cast (FacetDescriptions*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_FacetDescriptions[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  45,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f46), 
  ACE_NTOHL (0x61636574), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e73), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/FacetDescriptions:1.0
  18,
  ACE_NTOHL (0x46616365), 
  ACE_NTOHL (0x74446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x73000000),  // name = FacetDescriptions
  CORBA::tk_sequence, // typecode kind
  456, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_value, // typecode kind
    440, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      44,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f46), 
      ACE_NTOHL (0x61636574), 
      ACE_NTOHL (0x44657363), 
      ACE_NTOHL (0x72697074), 
      ACE_NTOHL (0x696f6e3a), 
      ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/FacetDescription:1.0
      17,
      ACE_NTOHL (0x46616365), 
      ACE_NTOHL (0x74446573), 
      ACE_NTOHL (0x63726970), 
      ACE_NTOHL (0x74696f6e), 
      ACE_NTOHL (0x0),  // name = FacetDescription
      0, // value modifier
      CORBA::tk_value, // typecode kind
      276, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f50), 
        ACE_NTOHL (0x6f727444), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e3a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/PortDescription:1.0
        16,
        ACE_NTOHL (0x506f7274), 
        ACE_NTOHL (0x44657363), 
        ACE_NTOHL (0x72697074), 
        ACE_NTOHL (0x696f6e00),  // name = PortDescription
        0, // value modifier
        CORBA::tk_null, // no stateful base valuetype

        2, // member count
        5,
        ACE_NTOHL (0x4e616d65), 
        ACE_NTOHL (0x0),  // name = Name
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          39,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f6d70), 
          ACE_NTOHL (0x6f6e656e), 
          ACE_NTOHL (0x74732f46), 
          ACE_NTOHL (0x65617475), 
          ACE_NTOHL (0x72654e61), 
          ACE_NTOHL (0x6d653a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
          12,
          ACE_NTOHL (0x46656174), 
          ACE_NTOHL (0x7572654e), 
          ACE_NTOHL (0x616d6500),  // name = FeatureName
          CORBA::tk_string, 
          0U, // string length

        1, // data member visibility marker

        8,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x5f696400),  // name = type_id
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f5265), 
          ACE_NTOHL (0x706f7369), 
          ACE_NTOHL (0x746f7279), 
          ACE_NTOHL (0x49643a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13,
          ACE_NTOHL (0x5265706f), 
          ACE_NTOHL (0x7369746f), 
          ACE_NTOHL (0x72794964), 
          ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        1, // data member visibility marker


      1, // member count
      10,
      ACE_NTOHL (0x66616365), 
      ACE_NTOHL (0x745f7265), 
      ACE_NTOHL (0x66000000),  // name = facet_ref
            1, // data member visibility marker


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_Components_FacetDescriptions (
    CORBA::tk_alias,
    sizeof (_oc_Components_FacetDescriptions),
    (char *) &_oc_Components_FacetDescriptions,
    0,
    sizeof (Components::FacetDescriptions)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_FacetDescriptions,
    &_tc_TAO_tc_Components_FacetDescriptions
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_FailureReason[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  41,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f46), 
  ACE_NTOHL (0x61696c75), 
  ACE_NTOHL (0x72655265), 
  ACE_NTOHL (0x61736f6e), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/FailureReason:1.0
  14,
  ACE_NTOHL (0x4661696c), 
  ACE_NTOHL (0x75726552), 
  ACE_NTOHL (0x6561736f), 
  ACE_NTOHL (0x6e000000),  // name = FailureReason
  CORBA::tk_ulong,

};

static CORBA::TypeCode _tc_TAO_tc_Components_FailureReason (
    CORBA::tk_alias,
    sizeof (_oc_Components_FailureReason),
    (char *) &_oc_Components_FailureReason,
    0,
    sizeof (Components::FailureReason)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_FailureReason,
    &_tc_TAO_tc_Components_FailureReason
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

Components::InvalidName::InvalidName (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/InvalidName:1.0",
        "InvalidName"
      )
{
}

Components::InvalidName::~InvalidName (void)
{
}

Components::InvalidName::InvalidName (const ::Components::InvalidName &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

Components::InvalidName&
Components::InvalidName::operator= (const ::Components::InvalidName &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::InvalidName::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidName *tmp = ACE_static_cast (InvalidName*, _tao_void_pointer);
  delete tmp;
}

Components::InvalidName *
Components::InvalidName::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/InvalidName:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (InvalidName *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::InvalidName::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::InvalidName, 0);
  return retval;
}

CORBA::Exception *
Components::InvalidName::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::InvalidName (*this),
      0
    );
  return result;
}

void Components::InvalidName::_raise (void)
{
  TAO_RAISE (*this);
}

void Components::InvalidName::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::InvalidName::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::InvalidName::_type (void) const
{
  return ::Components::_tc_InvalidName;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_InvalidName[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  39,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f49), 
  ACE_NTOHL (0x6e76616c), 
  ACE_NTOHL (0x69644e61), 
  ACE_NTOHL (0x6d653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/InvalidName:1.0
  12,
  ACE_NTOHL (0x496e7661), 
  ACE_NTOHL (0x6c69644e), 
  ACE_NTOHL (0x616d6500),  // name = InvalidName
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_InvalidName (
    CORBA::tk_except,
    sizeof (_oc_Components_InvalidName),
    (char *) &_oc_Components_InvalidName,
    0,
    sizeof (Components::InvalidName)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_InvalidName,
    &_tc_TAO_tc_Components_InvalidName
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

Components::InvalidConnection::InvalidConnection (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/InvalidConnection:1.0",
        "InvalidConnection"
      )
{
}

Components::InvalidConnection::~InvalidConnection (void)
{
}

Components::InvalidConnection::InvalidConnection (const ::Components::InvalidConnection &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

Components::InvalidConnection&
Components::InvalidConnection::operator= (const ::Components::InvalidConnection &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::InvalidConnection::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidConnection *tmp = ACE_static_cast (InvalidConnection*, _tao_void_pointer);
  delete tmp;
}

Components::InvalidConnection *
Components::InvalidConnection::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/InvalidConnection:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (InvalidConnection *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::InvalidConnection::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::InvalidConnection, 0);
  return retval;
}

CORBA::Exception *
Components::InvalidConnection::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::InvalidConnection (*this),
      0
    );
  return result;
}

void Components::InvalidConnection::_raise (void)
{
  TAO_RAISE (*this);
}

void Components::InvalidConnection::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::InvalidConnection::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::InvalidConnection::_type (void) const
{
  return ::Components::_tc_InvalidConnection;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_InvalidConnection[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  45,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f49), 
  ACE_NTOHL (0x6e76616c), 
  ACE_NTOHL (0x6964436f), 
  ACE_NTOHL (0x6e6e6563), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/InvalidConnection:1.0
  18,
  ACE_NTOHL (0x496e7661), 
  ACE_NTOHL (0x6c696443), 
  ACE_NTOHL (0x6f6e6e65), 
  ACE_NTOHL (0x6374696f), 
  ACE_NTOHL (0x6e000000),  // name = InvalidConnection
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_InvalidConnection (
    CORBA::tk_except,
    sizeof (_oc_Components_InvalidConnection),
    (char *) &_oc_Components_InvalidConnection,
    0,
    sizeof (Components::InvalidConnection)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_InvalidConnection,
    &_tc_TAO_tc_Components_InvalidConnection
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

Components::ExceededConnectionLimit::ExceededConnectionLimit (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/ExceededConnectionLimit:1.0",
        "ExceededConnectionLimit"
      )
{
}

Components::ExceededConnectionLimit::~ExceededConnectionLimit (void)
{
}

Components::ExceededConnectionLimit::ExceededConnectionLimit (const ::Components::ExceededConnectionLimit &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

Components::ExceededConnectionLimit&
Components::ExceededConnectionLimit::operator= (const ::Components::ExceededConnectionLimit &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::ExceededConnectionLimit::_tao_any_destructor (void *_tao_void_pointer)
{
  ExceededConnectionLimit *tmp = ACE_static_cast (ExceededConnectionLimit*, _tao_void_pointer);
  delete tmp;
}

Components::ExceededConnectionLimit *
Components::ExceededConnectionLimit::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/ExceededConnectionLimit:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (ExceededConnectionLimit *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::ExceededConnectionLimit::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::ExceededConnectionLimit, 0);
  return retval;
}

CORBA::Exception *
Components::ExceededConnectionLimit::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::ExceededConnectionLimit (*this),
      0
    );
  return result;
}

void Components::ExceededConnectionLimit::_raise (void)
{
  TAO_RAISE (*this);
}

void Components::ExceededConnectionLimit::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::ExceededConnectionLimit::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::ExceededConnectionLimit::_type (void) const
{
  return ::Components::_tc_ExceededConnectionLimit;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_ExceededConnectionLimit[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  51,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f45), 
  ACE_NTOHL (0x78636565), 
  ACE_NTOHL (0x64656443), 
  ACE_NTOHL (0x6f6e6e65), 
  ACE_NTOHL (0x6374696f), 
  ACE_NTOHL (0x6e4c696d), 
  ACE_NTOHL (0x69743a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/ExceededConnectionLimit:1.0
  24,
  ACE_NTOHL (0x45786365), 
  ACE_NTOHL (0x65646564), 
  ACE_NTOHL (0x436f6e6e), 
  ACE_NTOHL (0x65637469), 
  ACE_NTOHL (0x6f6e4c69), 
  ACE_NTOHL (0x6d697400),  // name = ExceededConnectionLimit
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_ExceededConnectionLimit (
    CORBA::tk_except,
    sizeof (_oc_Components_ExceededConnectionLimit),
    (char *) &_oc_Components_ExceededConnectionLimit,
    0,
    sizeof (Components::ExceededConnectionLimit)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ExceededConnectionLimit,
    &_tc_TAO_tc_Components_ExceededConnectionLimit
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

Components::AlreadyConnected::AlreadyConnected (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/AlreadyConnected:1.0",
        "AlreadyConnected"
      )
{
}

Components::AlreadyConnected::~AlreadyConnected (void)
{
}

Components::AlreadyConnected::AlreadyConnected (const ::Components::AlreadyConnected &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

Components::AlreadyConnected&
Components::AlreadyConnected::operator= (const ::Components::AlreadyConnected &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::AlreadyConnected::_tao_any_destructor (void *_tao_void_pointer)
{
  AlreadyConnected *tmp = ACE_static_cast (AlreadyConnected*, _tao_void_pointer);
  delete tmp;
}

Components::AlreadyConnected *
Components::AlreadyConnected::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/AlreadyConnected:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (AlreadyConnected *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::AlreadyConnected::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::AlreadyConnected, 0);
  return retval;
}

CORBA::Exception *
Components::AlreadyConnected::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::AlreadyConnected (*this),
      0
    );
  return result;
}

void Components::AlreadyConnected::_raise (void)
{
  TAO_RAISE (*this);
}

void Components::AlreadyConnected::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::AlreadyConnected::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::AlreadyConnected::_type (void) const
{
  return ::Components::_tc_AlreadyConnected;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_AlreadyConnected[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  44,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f41), 
  ACE_NTOHL (0x6c726561), 
  ACE_NTOHL (0x6479436f), 
  ACE_NTOHL (0x6e6e6563), 
  ACE_NTOHL (0x7465643a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/AlreadyConnected:1.0
  17,
  ACE_NTOHL (0x416c7265), 
  ACE_NTOHL (0x61647943), 
  ACE_NTOHL (0x6f6e6e65), 
  ACE_NTOHL (0x63746564), 
  ACE_NTOHL (0x0),  // name = AlreadyConnected
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_AlreadyConnected (
    CORBA::tk_except,
    sizeof (_oc_Components_AlreadyConnected),
    (char *) &_oc_Components_AlreadyConnected,
    0,
    sizeof (Components::AlreadyConnected)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_AlreadyConnected,
    &_tc_TAO_tc_Components_AlreadyConnected
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

Components::NoConnection::NoConnection (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/NoConnection:1.0",
        "NoConnection"
      )
{
}

Components::NoConnection::~NoConnection (void)
{
}

Components::NoConnection::NoConnection (const ::Components::NoConnection &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

Components::NoConnection&
Components::NoConnection::operator= (const ::Components::NoConnection &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::NoConnection::_tao_any_destructor (void *_tao_void_pointer)
{
  NoConnection *tmp = ACE_static_cast (NoConnection*, _tao_void_pointer);
  delete tmp;
}

Components::NoConnection *
Components::NoConnection::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/NoConnection:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (NoConnection *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::NoConnection::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::NoConnection, 0);
  return retval;
}

CORBA::Exception *
Components::NoConnection::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::NoConnection (*this),
      0
    );
  return result;
}

void Components::NoConnection::_raise (void)
{
  TAO_RAISE (*this);
}

void Components::NoConnection::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::NoConnection::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::NoConnection::_type (void) const
{
  return ::Components::_tc_NoConnection;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_NoConnection[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  40,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f4e), 
  ACE_NTOHL (0x6f436f6e), 
  ACE_NTOHL (0x6e656374), 
  ACE_NTOHL (0x696f6e3a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/NoConnection:1.0
  13,
  ACE_NTOHL (0x4e6f436f), 
  ACE_NTOHL (0x6e6e6563), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x0),  // name = NoConnection
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_NoConnection (
    CORBA::tk_except,
    sizeof (_oc_Components_NoConnection),
    (char *) &_oc_Components_NoConnection,
    0,
    sizeof (Components::NoConnection)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_NoConnection,
    &_tc_TAO_tc_Components_NoConnection
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

Components::CookieRequired::CookieRequired (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/CookieRequired:1.0",
        "CookieRequired"
      )
{
}

Components::CookieRequired::~CookieRequired (void)
{
}

Components::CookieRequired::CookieRequired (const ::Components::CookieRequired &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

Components::CookieRequired&
Components::CookieRequired::operator= (const ::Components::CookieRequired &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::CookieRequired::_tao_any_destructor (void *_tao_void_pointer)
{
  CookieRequired *tmp = ACE_static_cast (CookieRequired*, _tao_void_pointer);
  delete tmp;
}

Components::CookieRequired *
Components::CookieRequired::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/CookieRequired:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (CookieRequired *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::CookieRequired::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::CookieRequired, 0);
  return retval;
}

CORBA::Exception *
Components::CookieRequired::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::CookieRequired (*this),
      0
    );
  return result;
}

void Components::CookieRequired::_raise (void)
{
  TAO_RAISE (*this);
}

void Components::CookieRequired::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::CookieRequired::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::CookieRequired::_type (void) const
{
  return ::Components::_tc_CookieRequired;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_CookieRequired[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  42,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x6f6f6b69), 
  ACE_NTOHL (0x65526571), 
  ACE_NTOHL (0x75697265), 
  ACE_NTOHL (0x643a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/CookieRequired:1.0
  15,
  ACE_NTOHL (0x436f6f6b), 
  ACE_NTOHL (0x69655265), 
  ACE_NTOHL (0x71756972), 
  ACE_NTOHL (0x65640000),  // name = CookieRequired
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_CookieRequired (
    CORBA::tk_except,
    sizeof (_oc_Components_CookieRequired),
    (char *) &_oc_Components_CookieRequired,
    0,
    sizeof (Components::CookieRequired)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_CookieRequired,
    &_tc_TAO_tc_Components_CookieRequired
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

Components::CreateFailure::CreateFailure (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/CreateFailure:1.0",
        "CreateFailure"
      )
{
}

Components::CreateFailure::~CreateFailure (void)
{
}

Components::CreateFailure::CreateFailure (const ::Components::CreateFailure &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->reason = _tao_excp.reason;
}

Components::CreateFailure&
Components::CreateFailure::operator= (const ::Components::CreateFailure &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  this->reason = _tao_excp.reason;
  return *this;
}

void Components::CreateFailure::_tao_any_destructor (void *_tao_void_pointer)
{
  CreateFailure *tmp = ACE_static_cast (CreateFailure*, _tao_void_pointer);
  delete tmp;
}

Components::CreateFailure *
Components::CreateFailure::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/CreateFailure:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (CreateFailure *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::CreateFailure::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::CreateFailure, 0);
  return retval;
}

CORBA::Exception *
Components::CreateFailure::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::CreateFailure (*this),
      0
    );
  return result;
}

void Components::CreateFailure::_raise (void)
{
  TAO_RAISE (*this);
}

void Components::CreateFailure::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::CreateFailure::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_ctor.cpp:66

Components::CreateFailure::CreateFailure (
    Components::FailureReason _tao_reason
  )  : CORBA_UserException (
        "IDL:omg.org/Components/CreateFailure:1.0",
        "CreateFailure"
      )
{
  this->reason = _tao_reason;
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::CreateFailure::_type (void) const
{
  return ::Components::_tc_CreateFailure;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_CreateFailure[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  41,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x72656174), 
  ACE_NTOHL (0x65466169), 
  ACE_NTOHL (0x6c757265), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/CreateFailure:1.0
  14,
  ACE_NTOHL (0x43726561), 
  ACE_NTOHL (0x74654661), 
  ACE_NTOHL (0x696c7572), 
  ACE_NTOHL (0x65000000),  // name = CreateFailure
  1, // member count
  7,
  ACE_NTOHL (0x72656173), 
  ACE_NTOHL (0x6f6e0000),  // name = reason
  CORBA::tk_alias, // typecode kind for typedefs
  76, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    41,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f46), 
    ACE_NTOHL (0x61696c75), 
    ACE_NTOHL (0x72655265), 
    ACE_NTOHL (0x61736f6e), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/FailureReason:1.0
    14,
    ACE_NTOHL (0x4661696c), 
    ACE_NTOHL (0x75726552), 
    ACE_NTOHL (0x6561736f), 
    ACE_NTOHL (0x6e000000),  // name = FailureReason
    CORBA::tk_ulong,


};

static CORBA::TypeCode _tc_TAO_tc_Components_CreateFailure (
    CORBA::tk_except,
    sizeof (_oc_Components_CreateFailure),
    (char *) &_oc_Components_CreateFailure,
    0,
    sizeof (Components::CreateFailure)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_CreateFailure,
    &_tc_TAO_tc_Components_CreateFailure
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

Components::FinderFailure::FinderFailure (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/FinderFailure:1.0",
        "FinderFailure"
      )
{
}

Components::FinderFailure::~FinderFailure (void)
{
}

Components::FinderFailure::FinderFailure (const ::Components::FinderFailure &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->reason = _tao_excp.reason;
}

Components::FinderFailure&
Components::FinderFailure::operator= (const ::Components::FinderFailure &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  this->reason = _tao_excp.reason;
  return *this;
}

void Components::FinderFailure::_tao_any_destructor (void *_tao_void_pointer)
{
  FinderFailure *tmp = ACE_static_cast (FinderFailure*, _tao_void_pointer);
  delete tmp;
}

Components::FinderFailure *
Components::FinderFailure::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/FinderFailure:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (FinderFailure *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::FinderFailure::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::FinderFailure, 0);
  return retval;
}

CORBA::Exception *
Components::FinderFailure::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::FinderFailure (*this),
      0
    );
  return result;
}

void Components::FinderFailure::_raise (void)
{
  TAO_RAISE (*this);
}

void Components::FinderFailure::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::FinderFailure::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_ctor.cpp:66

Components::FinderFailure::FinderFailure (
    Components::FailureReason _tao_reason
  )  : CORBA_UserException (
        "IDL:omg.org/Components/FinderFailure:1.0",
        "FinderFailure"
      )
{
  this->reason = _tao_reason;
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::FinderFailure::_type (void) const
{
  return ::Components::_tc_FinderFailure;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_FinderFailure[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  41,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f46), 
  ACE_NTOHL (0x696e6465), 
  ACE_NTOHL (0x72466169), 
  ACE_NTOHL (0x6c757265), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/FinderFailure:1.0
  14,
  ACE_NTOHL (0x46696e64), 
  ACE_NTOHL (0x65724661), 
  ACE_NTOHL (0x696c7572), 
  ACE_NTOHL (0x65000000),  // name = FinderFailure
  1, // member count
  7,
  ACE_NTOHL (0x72656173), 
  ACE_NTOHL (0x6f6e0000),  // name = reason
  CORBA::tk_alias, // typecode kind for typedefs
  76, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    41,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f46), 
    ACE_NTOHL (0x61696c75), 
    ACE_NTOHL (0x72655265), 
    ACE_NTOHL (0x61736f6e), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/FailureReason:1.0
    14,
    ACE_NTOHL (0x4661696c), 
    ACE_NTOHL (0x75726552), 
    ACE_NTOHL (0x6561736f), 
    ACE_NTOHL (0x6e000000),  // name = FailureReason
    CORBA::tk_ulong,


};

static CORBA::TypeCode _tc_TAO_tc_Components_FinderFailure (
    CORBA::tk_except,
    sizeof (_oc_Components_FinderFailure),
    (char *) &_oc_Components_FinderFailure,
    0,
    sizeof (Components::FinderFailure)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_FinderFailure,
    &_tc_TAO_tc_Components_FinderFailure
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

Components::RemoveFailure::RemoveFailure (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/RemoveFailure:1.0",
        "RemoveFailure"
      )
{
}

Components::RemoveFailure::~RemoveFailure (void)
{
}

Components::RemoveFailure::RemoveFailure (const ::Components::RemoveFailure &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->reason = _tao_excp.reason;
}

Components::RemoveFailure&
Components::RemoveFailure::operator= (const ::Components::RemoveFailure &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  this->reason = _tao_excp.reason;
  return *this;
}

void Components::RemoveFailure::_tao_any_destructor (void *_tao_void_pointer)
{
  RemoveFailure *tmp = ACE_static_cast (RemoveFailure*, _tao_void_pointer);
  delete tmp;
}

Components::RemoveFailure *
Components::RemoveFailure::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/RemoveFailure:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (RemoveFailure *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::RemoveFailure::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::RemoveFailure, 0);
  return retval;
}

CORBA::Exception *
Components::RemoveFailure::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::RemoveFailure (*this),
      0
    );
  return result;
}

void Components::RemoveFailure::_raise (void)
{
  TAO_RAISE (*this);
}

void Components::RemoveFailure::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::RemoveFailure::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_ctor.cpp:66

Components::RemoveFailure::RemoveFailure (
    Components::FailureReason _tao_reason
  )  : CORBA_UserException (
        "IDL:omg.org/Components/RemoveFailure:1.0",
        "RemoveFailure"
      )
{
  this->reason = _tao_reason;
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::RemoveFailure::_type (void) const
{
  return ::Components::_tc_RemoveFailure;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_RemoveFailure[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  41,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f52), 
  ACE_NTOHL (0x656d6f76), 
  ACE_NTOHL (0x65466169), 
  ACE_NTOHL (0x6c757265), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/RemoveFailure:1.0
  14,
  ACE_NTOHL (0x52656d6f), 
  ACE_NTOHL (0x76654661), 
  ACE_NTOHL (0x696c7572), 
  ACE_NTOHL (0x65000000),  // name = RemoveFailure
  1, // member count
  7,
  ACE_NTOHL (0x72656173), 
  ACE_NTOHL (0x6f6e0000),  // name = reason
  CORBA::tk_alias, // typecode kind for typedefs
  76, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    41,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f46), 
    ACE_NTOHL (0x61696c75), 
    ACE_NTOHL (0x72655265), 
    ACE_NTOHL (0x61736f6e), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/FailureReason:1.0
    14,
    ACE_NTOHL (0x4661696c), 
    ACE_NTOHL (0x75726552), 
    ACE_NTOHL (0x6561736f), 
    ACE_NTOHL (0x6e000000),  // name = FailureReason
    CORBA::tk_ulong,


};

static CORBA::TypeCode _tc_TAO_tc_Components_RemoveFailure (
    CORBA::tk_except,
    sizeof (_oc_Components_RemoveFailure),
    (char *) &_oc_Components_RemoveFailure,
    0,
    sizeof (Components::RemoveFailure)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_RemoveFailure,
    &_tc_TAO_tc_Components_RemoveFailure
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

Components::DuplicateKeyValue::DuplicateKeyValue (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/DuplicateKeyValue:1.0",
        "DuplicateKeyValue"
      )
{
}

Components::DuplicateKeyValue::~DuplicateKeyValue (void)
{
}

Components::DuplicateKeyValue::DuplicateKeyValue (const ::Components::DuplicateKeyValue &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

Components::DuplicateKeyValue&
Components::DuplicateKeyValue::operator= (const ::Components::DuplicateKeyValue &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::DuplicateKeyValue::_tao_any_destructor (void *_tao_void_pointer)
{
  DuplicateKeyValue *tmp = ACE_static_cast (DuplicateKeyValue*, _tao_void_pointer);
  delete tmp;
}

Components::DuplicateKeyValue *
Components::DuplicateKeyValue::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/DuplicateKeyValue:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (DuplicateKeyValue *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::DuplicateKeyValue::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::DuplicateKeyValue, 0);
  return retval;
}

CORBA::Exception *
Components::DuplicateKeyValue::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::DuplicateKeyValue (*this),
      0
    );
  return result;
}

void Components::DuplicateKeyValue::_raise (void)
{
  TAO_RAISE (*this);
}

void Components::DuplicateKeyValue::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::DuplicateKeyValue::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::DuplicateKeyValue::_type (void) const
{
  return ::Components::_tc_DuplicateKeyValue;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_DuplicateKeyValue[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  45,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f44), 
  ACE_NTOHL (0x75706c69), 
  ACE_NTOHL (0x63617465), 
  ACE_NTOHL (0x4b657956), 
  ACE_NTOHL (0x616c7565), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/DuplicateKeyValue:1.0
  18,
  ACE_NTOHL (0x4475706c), 
  ACE_NTOHL (0x69636174), 
  ACE_NTOHL (0x654b6579), 
  ACE_NTOHL (0x56616c75), 
  ACE_NTOHL (0x65000000),  // name = DuplicateKeyValue
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_DuplicateKeyValue (
    CORBA::tk_except,
    sizeof (_oc_Components_DuplicateKeyValue),
    (char *) &_oc_Components_DuplicateKeyValue,
    0,
    sizeof (Components::DuplicateKeyValue)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_DuplicateKeyValue,
    &_tc_TAO_tc_Components_DuplicateKeyValue
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

Components::InvalidKey::InvalidKey (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/InvalidKey:1.0",
        "InvalidKey"
      )
{
}

Components::InvalidKey::~InvalidKey (void)
{
}

Components::InvalidKey::InvalidKey (const ::Components::InvalidKey &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

Components::InvalidKey&
Components::InvalidKey::operator= (const ::Components::InvalidKey &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::InvalidKey::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidKey *tmp = ACE_static_cast (InvalidKey*, _tao_void_pointer);
  delete tmp;
}

Components::InvalidKey *
Components::InvalidKey::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/InvalidKey:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (InvalidKey *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::InvalidKey::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::InvalidKey, 0);
  return retval;
}

CORBA::Exception *
Components::InvalidKey::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::InvalidKey (*this),
      0
    );
  return result;
}

void Components::InvalidKey::_raise (void)
{
  TAO_RAISE (*this);
}

void Components::InvalidKey::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::InvalidKey::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::InvalidKey::_type (void) const
{
  return ::Components::_tc_InvalidKey;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_InvalidKey[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  38,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f49), 
  ACE_NTOHL (0x6e76616c), 
  ACE_NTOHL (0x69644b65), 
  ACE_NTOHL (0x793a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/InvalidKey:1.0
  11,
  ACE_NTOHL (0x496e7661), 
  ACE_NTOHL (0x6c69644b), 
  ACE_NTOHL (0x65790000),  // name = InvalidKey
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_InvalidKey (
    CORBA::tk_except,
    sizeof (_oc_Components_InvalidKey),
    (char *) &_oc_Components_InvalidKey,
    0,
    sizeof (Components::InvalidKey)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_InvalidKey,
    &_tc_TAO_tc_Components_InvalidKey
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

Components::UnknownKeyValue::UnknownKeyValue (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/UnknownKeyValue:1.0",
        "UnknownKeyValue"
      )
{
}

Components::UnknownKeyValue::~UnknownKeyValue (void)
{
}

Components::UnknownKeyValue::UnknownKeyValue (const ::Components::UnknownKeyValue &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

Components::UnknownKeyValue&
Components::UnknownKeyValue::operator= (const ::Components::UnknownKeyValue &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::UnknownKeyValue::_tao_any_destructor (void *_tao_void_pointer)
{
  UnknownKeyValue *tmp = ACE_static_cast (UnknownKeyValue*, _tao_void_pointer);
  delete tmp;
}

Components::UnknownKeyValue *
Components::UnknownKeyValue::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/UnknownKeyValue:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (UnknownKeyValue *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::UnknownKeyValue::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::UnknownKeyValue, 0);
  return retval;
}

CORBA::Exception *
Components::UnknownKeyValue::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::UnknownKeyValue (*this),
      0
    );
  return result;
}

void Components::UnknownKeyValue::_raise (void)
{
  TAO_RAISE (*this);
}

void Components::UnknownKeyValue::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::UnknownKeyValue::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::UnknownKeyValue::_type (void) const
{
  return ::Components::_tc_UnknownKeyValue;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_UnknownKeyValue[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  43,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f55), 
  ACE_NTOHL (0x6e6b6e6f), 
  ACE_NTOHL (0x776e4b65), 
  ACE_NTOHL (0x7956616c), 
  ACE_NTOHL (0x75653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/UnknownKeyValue:1.0
  16,
  ACE_NTOHL (0x556e6b6e), 
  ACE_NTOHL (0x6f776e4b), 
  ACE_NTOHL (0x65795661), 
  ACE_NTOHL (0x6c756500),  // name = UnknownKeyValue
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_UnknownKeyValue (
    CORBA::tk_except,
    sizeof (_oc_Components_UnknownKeyValue),
    (char *) &_oc_Components_UnknownKeyValue,
    0,
    sizeof (Components::UnknownKeyValue)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_UnknownKeyValue,
    &_tc_TAO_tc_Components_UnknownKeyValue
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

Components::NoKeyAvailable::NoKeyAvailable (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/NoKeyAvailable:1.0",
        "NoKeyAvailable"
      )
{
}

Components::NoKeyAvailable::~NoKeyAvailable (void)
{
}

Components::NoKeyAvailable::NoKeyAvailable (const ::Components::NoKeyAvailable &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

Components::NoKeyAvailable&
Components::NoKeyAvailable::operator= (const ::Components::NoKeyAvailable &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::NoKeyAvailable::_tao_any_destructor (void *_tao_void_pointer)
{
  NoKeyAvailable *tmp = ACE_static_cast (NoKeyAvailable*, _tao_void_pointer);
  delete tmp;
}

Components::NoKeyAvailable *
Components::NoKeyAvailable::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/NoKeyAvailable:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (NoKeyAvailable *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::NoKeyAvailable::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::NoKeyAvailable, 0);
  return retval;
}

CORBA::Exception *
Components::NoKeyAvailable::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::NoKeyAvailable (*this),
      0
    );
  return result;
}

void Components::NoKeyAvailable::_raise (void)
{
  TAO_RAISE (*this);
}

void Components::NoKeyAvailable::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::NoKeyAvailable::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::NoKeyAvailable::_type (void) const
{
  return ::Components::_tc_NoKeyAvailable;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_NoKeyAvailable[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  42,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f4e), 
  ACE_NTOHL (0x6f4b6579), 
  ACE_NTOHL (0x41766169), 
  ACE_NTOHL (0x6c61626c), 
  ACE_NTOHL (0x653a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/NoKeyAvailable:1.0
  15,
  ACE_NTOHL (0x4e6f4b65), 
  ACE_NTOHL (0x79417661), 
  ACE_NTOHL (0x696c6162), 
  ACE_NTOHL (0x6c650000),  // name = NoKeyAvailable
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_NoKeyAvailable (
    CORBA::tk_except,
    sizeof (_oc_Components_NoKeyAvailable),
    (char *) &_oc_Components_NoKeyAvailable,
    0,
    sizeof (Components::NoKeyAvailable)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_NoKeyAvailable,
    &_tc_TAO_tc_Components_NoKeyAvailable
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

Components::BadEventType::BadEventType (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/BadEventType:1.0",
        "BadEventType"
      )
{
}

Components::BadEventType::~BadEventType (void)
{
}

Components::BadEventType::BadEventType (const ::Components::BadEventType &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->expected_event_type = CORBA::string_dup (_tao_excp.expected_event_type.in ());
}

Components::BadEventType&
Components::BadEventType::operator= (const ::Components::BadEventType &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  this->expected_event_type = CORBA::string_dup (_tao_excp.expected_event_type.in ());
  return *this;
}

void Components::BadEventType::_tao_any_destructor (void *_tao_void_pointer)
{
  BadEventType *tmp = ACE_static_cast (BadEventType*, _tao_void_pointer);
  delete tmp;
}

Components::BadEventType *
Components::BadEventType::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/BadEventType:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (BadEventType *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::BadEventType::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::BadEventType, 0);
  return retval;
}

CORBA::Exception *
Components::BadEventType::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::BadEventType (*this),
      0
    );
  return result;
}

void Components::BadEventType::_raise (void)
{
  TAO_RAISE (*this);
}

void Components::BadEventType::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::BadEventType::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_ctor.cpp:66

Components::BadEventType::BadEventType (
    const char * _tao_expected_event_type
  )  : CORBA_UserException (
        "IDL:omg.org/Components/BadEventType:1.0",
        "BadEventType"
      )
{
  this->expected_event_type = CORBA::string_dup (_tao_expected_event_type);
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::BadEventType::_type (void) const
{
  return ::Components::_tc_BadEventType;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_BadEventType[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  40,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f42), 
  ACE_NTOHL (0x61644576), 
  ACE_NTOHL (0x656e7454), 
  ACE_NTOHL (0x7970653a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/BadEventType:1.0
  13,
  ACE_NTOHL (0x42616445), 
  ACE_NTOHL (0x76656e74), 
  ACE_NTOHL (0x54797065), 
  ACE_NTOHL (0x0),  // name = BadEventType
  1, // member count
  20,
  ACE_NTOHL (0x65787065), 
  ACE_NTOHL (0x63746564), 
  ACE_NTOHL (0x5f657665), 
  ACE_NTOHL (0x6e745f74), 
  ACE_NTOHL (0x79706500),  // name = expected_event_type
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5265), 
    ACE_NTOHL (0x706f7369), 
    ACE_NTOHL (0x746f7279), 
    ACE_NTOHL (0x49643a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

};

static CORBA::TypeCode _tc_TAO_tc_Components_BadEventType (
    CORBA::tk_except,
    sizeof (_oc_Components_BadEventType),
    (char *) &_oc_Components_BadEventType,
    0,
    sizeof (Components::BadEventType)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_BadEventType,
    &_tc_TAO_tc_Components_BadEventType
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

Components::HomeNotFound::HomeNotFound (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/HomeNotFound:1.0",
        "HomeNotFound"
      )
{
}

Components::HomeNotFound::~HomeNotFound (void)
{
}

Components::HomeNotFound::HomeNotFound (const ::Components::HomeNotFound &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

Components::HomeNotFound&
Components::HomeNotFound::operator= (const ::Components::HomeNotFound &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::HomeNotFound::_tao_any_destructor (void *_tao_void_pointer)
{
  HomeNotFound *tmp = ACE_static_cast (HomeNotFound*, _tao_void_pointer);
  delete tmp;
}

Components::HomeNotFound *
Components::HomeNotFound::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/HomeNotFound:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (HomeNotFound *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::HomeNotFound::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::HomeNotFound, 0);
  return retval;
}

CORBA::Exception *
Components::HomeNotFound::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::HomeNotFound (*this),
      0
    );
  return result;
}

void Components::HomeNotFound::_raise (void)
{
  TAO_RAISE (*this);
}

void Components::HomeNotFound::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::HomeNotFound::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::HomeNotFound::_type (void) const
{
  return ::Components::_tc_HomeNotFound;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_HomeNotFound[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  40,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f48), 
  ACE_NTOHL (0x6f6d654e), 
  ACE_NTOHL (0x6f74466f), 
  ACE_NTOHL (0x756e643a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/HomeNotFound:1.0
  13,
  ACE_NTOHL (0x486f6d65), 
  ACE_NTOHL (0x4e6f7446), 
  ACE_NTOHL (0x6f756e64), 
  ACE_NTOHL (0x0),  // name = HomeNotFound
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_HomeNotFound (
    CORBA::tk_except,
    sizeof (_oc_Components_HomeNotFound),
    (char *) &_oc_Components_HomeNotFound,
    0,
    sizeof (Components::HomeNotFound)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_HomeNotFound,
    &_tc_TAO_tc_Components_HomeNotFound
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

Components::WrongComponentType::WrongComponentType (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/WrongComponentType:1.0",
        "WrongComponentType"
      )
{
}

Components::WrongComponentType::~WrongComponentType (void)
{
}

Components::WrongComponentType::WrongComponentType (const ::Components::WrongComponentType &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

Components::WrongComponentType&
Components::WrongComponentType::operator= (const ::Components::WrongComponentType &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::WrongComponentType::_tao_any_destructor (void *_tao_void_pointer)
{
  WrongComponentType *tmp = ACE_static_cast (WrongComponentType*, _tao_void_pointer);
  delete tmp;
}

Components::WrongComponentType *
Components::WrongComponentType::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/WrongComponentType:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (WrongComponentType *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::WrongComponentType::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::WrongComponentType, 0);
  return retval;
}

CORBA::Exception *
Components::WrongComponentType::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::WrongComponentType (*this),
      0
    );
  return result;
}

void Components::WrongComponentType::_raise (void)
{
  TAO_RAISE (*this);
}

void Components::WrongComponentType::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::WrongComponentType::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::WrongComponentType::_type (void) const
{
  return ::Components::_tc_WrongComponentType;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_WrongComponentType[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  46,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f57), 
  ACE_NTOHL (0x726f6e67), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74547970), 
  ACE_NTOHL (0x653a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/WrongComponentType:1.0
  19,
  ACE_NTOHL (0x57726f6e), 
  ACE_NTOHL (0x67436f6d), 
  ACE_NTOHL (0x706f6e65), 
  ACE_NTOHL (0x6e745479), 
  ACE_NTOHL (0x70650000),  // name = WrongComponentType
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_WrongComponentType (
    CORBA::tk_except,
    sizeof (_oc_Components_WrongComponentType),
    (char *) &_oc_Components_WrongComponentType,
    0,
    sizeof (Components::WrongComponentType)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_WrongComponentType,
    &_tc_TAO_tc_Components_WrongComponentType
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_InvalidConfigurationReason[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  54,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f49), 
  ACE_NTOHL (0x6e76616c), 
  ACE_NTOHL (0x6964436f), 
  ACE_NTOHL (0x6e666967), 
  ACE_NTOHL (0x75726174), 
  ACE_NTOHL (0x696f6e52), 
  ACE_NTOHL (0x6561736f), 
  ACE_NTOHL (0x6e3a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/InvalidConfigurationReason:1.0
  27,
  ACE_NTOHL (0x496e7661), 
  ACE_NTOHL (0x6c696443), 
  ACE_NTOHL (0x6f6e6669), 
  ACE_NTOHL (0x67757261), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x52656173), 
  ACE_NTOHL (0x6f6e0000),  // name = InvalidConfigurationReason
  CORBA::tk_alias, // typecode kind for typedefs
  76, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    41,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f46), 
    ACE_NTOHL (0x61696c75), 
    ACE_NTOHL (0x72655265), 
    ACE_NTOHL (0x61736f6e), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/FailureReason:1.0
    14,
    ACE_NTOHL (0x4661696c), 
    ACE_NTOHL (0x75726552), 
    ACE_NTOHL (0x6561736f), 
    ACE_NTOHL (0x6e000000),  // name = FailureReason
    CORBA::tk_ulong,


};

static CORBA::TypeCode _tc_TAO_tc_Components_InvalidConfigurationReason (
    CORBA::tk_alias,
    sizeof (_oc_Components_InvalidConfigurationReason),
    (char *) &_oc_Components_InvalidConfigurationReason,
    0,
    sizeof (Components::InvalidConfigurationReason)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_InvalidConfigurationReason,
    &_tc_TAO_tc_Components_InvalidConfigurationReason
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

Components::InvalidConfiguration::InvalidConfiguration (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/InvalidConfiguration:1.0",
        "InvalidConfiguration"
      )
{
}

Components::InvalidConfiguration::~InvalidConfiguration (void)
{
}

Components::InvalidConfiguration::InvalidConfiguration (const ::Components::InvalidConfiguration &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->reason = _tao_excp.reason;
  this->name = CORBA::string_dup (_tao_excp.name.in ());
}

Components::InvalidConfiguration&
Components::InvalidConfiguration::operator= (const ::Components::InvalidConfiguration &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  this->reason = _tao_excp.reason;
  this->name = CORBA::string_dup (_tao_excp.name.in ());
  return *this;
}

void Components::InvalidConfiguration::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidConfiguration *tmp = ACE_static_cast (InvalidConfiguration*, _tao_void_pointer);
  delete tmp;
}

Components::InvalidConfiguration *
Components::InvalidConfiguration::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/InvalidConfiguration:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (InvalidConfiguration *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::InvalidConfiguration::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::InvalidConfiguration, 0);
  return retval;
}

CORBA::Exception *
Components::InvalidConfiguration::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::InvalidConfiguration (*this),
      0
    );
  return result;
}

void Components::InvalidConfiguration::_raise (void)
{
  TAO_RAISE (*this);
}

void Components::InvalidConfiguration::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::InvalidConfiguration::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_ctor.cpp:66

Components::InvalidConfiguration::InvalidConfiguration (
    Components::InvalidConfigurationReason _tao_reason,
    const char * _tao_name
  )  : CORBA_UserException (
        "IDL:omg.org/Components/InvalidConfiguration:1.0",
        "InvalidConfiguration"
      )
{
  this->reason = _tao_reason;
  this->name = CORBA::string_dup (_tao_name);
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::InvalidConfiguration::_type (void) const
{
  return ::Components::_tc_InvalidConfiguration;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_InvalidConfiguration[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  48,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f49), 
  ACE_NTOHL (0x6e76616c), 
  ACE_NTOHL (0x6964436f), 
  ACE_NTOHL (0x6e666967), 
  ACE_NTOHL (0x75726174), 
  ACE_NTOHL (0x696f6e3a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/InvalidConfiguration:1.0
  21,
  ACE_NTOHL (0x496e7661), 
  ACE_NTOHL (0x6c696443), 
  ACE_NTOHL (0x6f6e6669), 
  ACE_NTOHL (0x67757261), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x0),  // name = InvalidConfiguration
  2, // member count
  7,
  ACE_NTOHL (0x72656173), 
  ACE_NTOHL (0x6f6e0000),  // name = reason
  CORBA::tk_alias, // typecode kind for typedefs
  180, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    54,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f49), 
    ACE_NTOHL (0x6e76616c), 
    ACE_NTOHL (0x6964436f), 
    ACE_NTOHL (0x6e666967), 
    ACE_NTOHL (0x75726174), 
    ACE_NTOHL (0x696f6e52), 
    ACE_NTOHL (0x6561736f), 
    ACE_NTOHL (0x6e3a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/InvalidConfigurationReason:1.0
    27,
    ACE_NTOHL (0x496e7661), 
    ACE_NTOHL (0x6c696443), 
    ACE_NTOHL (0x6f6e6669), 
    ACE_NTOHL (0x67757261), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x52656173), 
    ACE_NTOHL (0x6f6e0000),  // name = InvalidConfigurationReason
    CORBA::tk_alias, // typecode kind for typedefs
    76, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      41,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f46), 
      ACE_NTOHL (0x61696c75), 
      ACE_NTOHL (0x72655265), 
      ACE_NTOHL (0x61736f6e), 
      ACE_NTOHL (0x3a312e30), 
      ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/FailureReason:1.0
      14,
      ACE_NTOHL (0x4661696c), 
      ACE_NTOHL (0x75726552), 
      ACE_NTOHL (0x6561736f), 
      ACE_NTOHL (0x6e000000),  // name = FailureReason
      CORBA::tk_ulong,



  5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    39,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f46), 
    ACE_NTOHL (0x65617475), 
    ACE_NTOHL (0x72654e61), 
    ACE_NTOHL (0x6d653a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
    12,
    ACE_NTOHL (0x46656174), 
    ACE_NTOHL (0x7572654e), 
    ACE_NTOHL (0x616d6500),  // name = FeatureName
    CORBA::tk_string, 
    0U, // string length

};

static CORBA::TypeCode _tc_TAO_tc_Components_InvalidConfiguration (
    CORBA::tk_except,
    sizeof (_oc_Components_InvalidConfiguration),
    (char *) &_oc_Components_InvalidConfiguration,
    0,
    sizeof (Components::InvalidConfiguration)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_InvalidConfiguration,
    &_tc_TAO_tc_Components_InvalidConfiguration
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

Components::IllegalState::IllegalState (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/IllegalState:1.0",
        "IllegalState"
      )
{
}

Components::IllegalState::~IllegalState (void)
{
}

Components::IllegalState::IllegalState (const ::Components::IllegalState &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

Components::IllegalState&
Components::IllegalState::operator= (const ::Components::IllegalState &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::IllegalState::_tao_any_destructor (void *_tao_void_pointer)
{
  IllegalState *tmp = ACE_static_cast (IllegalState*, _tao_void_pointer);
  delete tmp;
}

Components::IllegalState *
Components::IllegalState::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/IllegalState:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (IllegalState *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::IllegalState::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::IllegalState, 0);
  return retval;
}

CORBA::Exception *
Components::IllegalState::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::IllegalState (*this),
      0
    );
  return result;
}

void Components::IllegalState::_raise (void)
{
  TAO_RAISE (*this);
}

void Components::IllegalState::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::IllegalState::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::IllegalState::_type (void) const
{
  return ::Components::_tc_IllegalState;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_IllegalState[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  40,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f49), 
  ACE_NTOHL (0x6c6c6567), 
  ACE_NTOHL (0x616c5374), 
  ACE_NTOHL (0x6174653a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/IllegalState:1.0
  13,
  ACE_NTOHL (0x496c6c65), 
  ACE_NTOHL (0x67616c53), 
  ACE_NTOHL (0x74617465), 
  ACE_NTOHL (0x0),  // name = IllegalState
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_IllegalState (
    CORBA::tk_except,
    sizeof (_oc_Components_IllegalState),
    (char *) &_oc_Components_IllegalState,
    0,
    sizeof (Components::IllegalState)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_IllegalState,
    &_tc_TAO_tc_Components_IllegalState
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int Components::Navigation::_tao_class_id = 0;

Components::Navigation_ptr
tao_Components_Navigation_duplicate (
    Components::Navigation_ptr p
  )
{
  return Components::Navigation::_duplicate (p);
}

void
tao_Components_Navigation_release (
    Components::Navigation_ptr p
  )
{
  CORBA::release (p);
}

Components::Navigation_ptr
tao_Components_Navigation_nil (
    void
  )
{
  return Components::Navigation::_nil ();
}

Components::Navigation_ptr
tao_Components_Navigation_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::Navigation::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_Navigation_upcast (
    void *src
  )
{
  Components::Navigation **tmp =
    ACE_static_cast (Components::Navigation **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// Components::Navigation_var
// *************************************************************

Components::Navigation_var::Navigation_var (void)
  : ptr_ (Navigation::_nil ())
{}

::Components::Navigation_ptr
Components::Navigation_var::ptr (void) const
{
  return this->ptr_;
}

Components::Navigation_var::Navigation_var (const ::Components::Navigation_var &p)
  : TAO_Base_var (),
    ptr_ (Navigation::_duplicate (p.ptr ()))
{}

Components::Navigation_var::~Navigation_var (void)
{
  CORBA::release (this->ptr_);
}

Components::Navigation_var &
Components::Navigation_var::operator= (Navigation_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::Navigation_var &
Components::Navigation_var::operator= (const ::Components::Navigation_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::Navigation::_duplicate (p.ptr ());
  }
  return *this;
}

Components::Navigation_var::operator const ::Components::Navigation_ptr &() const // cast
{
  return this->ptr_;
}

Components::Navigation_var::operator ::Components::Navigation_ptr &() // cast 
{
  return this->ptr_;
}

::Components::Navigation_ptr
Components::Navigation_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::Navigation_ptr
Components::Navigation_var::in (void) const
{
  return this->ptr_;
}

::Components::Navigation_ptr &
Components::Navigation_var::inout (void)
{
  return this->ptr_;
}

::Components::Navigation_ptr &
Components::Navigation_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Navigation::_nil ();
  return this->ptr_;
}

::Components::Navigation_ptr
Components::Navigation_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::Navigation_ptr val = this->ptr_;
  this->ptr_ = ::Components::Navigation::_nil ();
  return val;
}

::Components::Navigation_ptr
Components::Navigation_var::tao_duplicate (Navigation_ptr p)
{
  return ::Components::Navigation::_duplicate (p);
}

void
Components::Navigation_var::tao_release (Navigation_ptr p)
{
  CORBA::release (p);
}

::Components::Navigation_ptr
Components::Navigation_var::tao_nil (void)
{
  return ::Components::Navigation::_nil ();
}

::Components::Navigation_ptr
Components::Navigation_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::Navigation::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::Navigation_var::tao_upcast (void *src)
{
  Navigation **tmp =
    ACE_static_cast (Navigation **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// Components::Navigation_out
// *************************************************************

Components::Navigation_out::Navigation_out (Navigation_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::Navigation::_nil ();
}

Components::Navigation_out::Navigation_out (Navigation_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Navigation::_nil ();
}

Components::Navigation_out::Navigation_out (const ::Components::Navigation_out &p)
  : ptr_ (ACE_const_cast (Navigation_out &, p).ptr_)
{}

::Components::Navigation_out &
Components::Navigation_out::operator= (const ::Components::Navigation_out &p)
{
  this->ptr_ = ACE_const_cast (Navigation_out&, p).ptr_;
  return *this;
}

Components::Navigation_out &
Components::Navigation_out::operator= (const ::Components::Navigation_var &p)
{
  this->ptr_ = ::Components::Navigation::_duplicate (p.ptr ());
  return *this;
}

Components::Navigation_out &
Components::Navigation_out::operator= (Navigation_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::Navigation_out::operator ::Components::Navigation_ptr &() // cast
{
  return this->ptr_;
}

::Components::Navigation_ptr &
Components::Navigation_out::ptr (void)
{
  return this->ptr_;
}

::Components::Navigation_ptr
Components::Navigation_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_Navigation_provide_facet : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Navigation_provide_facet (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * name);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Object_ptr result);

private:
  TAO_ClientRequestInfo_Components_Navigation_provide_facet (const TAO_ClientRequestInfo_Components_Navigation_provide_facet &);
  void operator= (const TAO_ClientRequestInfo_Components_Navigation_provide_facet &);
  const char * name_;
  
  CORBA::Object_ptr _result;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_Navigation_provide_facet::TAO_ClientRequestInfo_Components_Navigation_provide_facet (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * name    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    name_ (name)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Navigation_provide_facet::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Navigation_provide_facet::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Navigation_provide_facet_exceptiondata[] = 
  {
    Components::_tc_InvalidName
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Navigation_provide_facet_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Navigation_provide_facet::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Navigation_provide_facet::result (CORBA::Object_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_Navigation_get_all_facets : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Navigation_get_all_facets (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::FacetDescriptions * result);

private:
  TAO_ClientRequestInfo_Components_Navigation_get_all_facets (const TAO_ClientRequestInfo_Components_Navigation_get_all_facets &);
  void operator= (const TAO_ClientRequestInfo_Components_Navigation_get_all_facets &);
  
  Components::FacetDescriptions * _result;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_Navigation_get_all_facets::TAO_ClientRequestInfo_Components_Navigation_get_all_facets (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Navigation_get_all_facets::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Navigation_get_all_facets::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Navigation_get_all_facets::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Navigation_get_all_facets::result (::Components::FacetDescriptions * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_Navigation_get_named_facets : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Navigation_get_named_facets (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const Components::NameList & names);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::FacetDescriptions * result);

private:
  TAO_ClientRequestInfo_Components_Navigation_get_named_facets (const TAO_ClientRequestInfo_Components_Navigation_get_named_facets &);
  void operator= (const TAO_ClientRequestInfo_Components_Navigation_get_named_facets &);
  const Components::NameList & names_;
  
  Components::FacetDescriptions * _result;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_Navigation_get_named_facets::TAO_ClientRequestInfo_Components_Navigation_get_named_facets (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const Components::NameList & names    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    names_ (names)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Navigation_get_named_facets::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->names_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Navigation_get_named_facets::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Navigation_get_named_facets_exceptiondata[] = 
  {
    Components::_tc_InvalidName
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Navigation_get_named_facets_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Navigation_get_named_facets::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Navigation_get_named_facets::result (::Components::FacetDescriptions * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_Navigation_same_component : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Navigation_same_component (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Object_ptr object_ref);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Boolean result);

private:
  TAO_ClientRequestInfo_Components_Navigation_same_component (const TAO_ClientRequestInfo_Components_Navigation_same_component &);
  void operator= (const TAO_ClientRequestInfo_Components_Navigation_same_component &);
  CORBA::Object_ptr object_ref_;
  
  CORBA::Boolean _result;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_Navigation_same_component::TAO_ClientRequestInfo_Components_Navigation_same_component (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Object_ptr object_ref    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    object_ref_ (object_ref)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Navigation_same_component::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= object_ref_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Navigation_same_component::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Navigation_same_component::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Navigation_same_component::result (CORBA::Boolean result)
{
  // Update the result. 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

Components::_TAO_Navigation_Proxy_Impl::_TAO_Navigation_Proxy_Impl (void)
{}

Components::_TAO_Navigation_Remote_Proxy_Impl::_TAO_Navigation_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

CORBA::Object_ptr Components::_TAO_Navigation_Remote_Proxy_Impl::provide_facet (
    CORBA_Object *_collocated_tao_target_,
    const char * name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
    static TAO_Exception_Data _tao_Components_Navigation_provide_facet_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/InvalidName:1.0",
      Components::InvalidName::_alloc
    }
  };

CORBA::Object_var _tao_retval (CORBA::Object::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "provide_facet",
      13,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Navigation_provide_facet _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          name
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << name)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (_tao_Components_Navigation_provide_facet_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          CORBA::Object_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::Components::FacetDescriptions * Components::_TAO_Navigation_Remote_Proxy_Impl::get_all_facets (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  Components::FacetDescriptions_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    Components::FacetDescriptions *tmp;
    ACE_NEW_RETURN (tmp, Components::FacetDescriptions, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_all_facets",
      14,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Navigation_get_all_facets _tao_ri (
          &_tao_call,
          _collocated_tao_target_
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::FacetDescriptions * _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::Components::FacetDescriptions * Components::_TAO_Navigation_Remote_Proxy_Impl::get_named_facets (
    CORBA_Object *_collocated_tao_target_,
    const Components::NameList & names
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
    static TAO_Exception_Data _tao_Components_Navigation_get_named_facets_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/InvalidName:1.0",
      Components::InvalidName::_alloc
    }
  };

Components::FacetDescriptions_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    Components::FacetDescriptions *tmp;
    ACE_NEW_RETURN (tmp, Components::FacetDescriptions, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_named_facets",
      16,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Navigation_get_named_facets _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          names
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << names)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (_tao_Components_Navigation_get_named_facets_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::FacetDescriptions * _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

CORBA::Boolean Components::_TAO_Navigation_Remote_Proxy_Impl::same_component (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Object_ptr object_ref
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  CORBA::Boolean _tao_retval = 0;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval);
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "same_component",
      14,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Navigation_same_component _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          object_ref
        );
      ACE_CHECK_RETURN (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << object_ref)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  _tao_retval
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  _tao_retval
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  _tao_retval
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          CORBA::Boolean _tao_retval_info =
            _tao_retval;
          _tao_ri.result (_tao_retval_info);
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval);
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval);
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval;
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

Components::_TAO_Navigation_Proxy_Broker::_TAO_Navigation_Proxy_Broker (void)
{
}

Components::_TAO_Navigation_Proxy_Broker::~_TAO_Navigation_Proxy_Broker (void)
{
}

Components::_TAO_Navigation_Proxy_Broker * (*Components__TAO_Navigation_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
Components::_TAO_Navigation_Remote_Proxy_Broker *
Components::_TAO_Navigation_Remote_Proxy_Broker::the_TAO_Navigation_Remote_Proxy_Broker (void)
{
  static ::Components::_TAO_Navigation_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

Components::_TAO_Navigation_Remote_Proxy_Broker::_TAO_Navigation_Remote_Proxy_Broker (void)
{
}

Components::_TAO_Navigation_Remote_Proxy_Broker::~_TAO_Navigation_Remote_Proxy_Broker (void)
{
}

Components::_TAO_Navigation_Proxy_Impl&
Components::_TAO_Navigation_Remote_Proxy_Broker::select_proxy (
    ::Components::Navigation *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:225

Components::Navigation::Navigation (int collocated)
{
  this->Components_Navigation_setup_collocation (collocated);
}

void
Components::Navigation::Components_Navigation_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_Navigation_Proxy_Broker_ =
      ::Components__TAO_Navigation_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_Navigation_Proxy_Broker_ =
      ::Components::_TAO_Navigation_Remote_Proxy_Broker::the_TAO_Navigation_Remote_Proxy_Broker ();
}

Components::Navigation::~Navigation (void)
{}

void 
Components::Navigation::_tao_any_destructor (void *_tao_void_pointer)
{
  Navigation *tmp = ACE_static_cast (Navigation *, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::Navigation_ptr
Components::Navigation::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return Navigation::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/Components/Navigation:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (Navigation::_nil ());
      
      if (is_a == 0)
        {
          return Navigation::_nil ();
        }
    }
  
  return Navigation::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::Navigation_ptr 
Components::Navigation::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return Navigation::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      Navigation_ptr default_proxy = Navigation::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          Components__TAO_Navigation_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::Navigation (
                  stub,
                  1,
                  obj->_servant ()
                ),
              Navigation::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::Navigation (
                  stub,
                  0,
                  obj->_servant ()
                ),
              Navigation::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          Navigation_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &Navigation::_tao_class_id
                )
            )
        );
}

Components::Navigation_ptr
Components::Navigation::_duplicate (Navigation_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
Components::Navigation::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/Components/Navigation:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->CORBA_Object::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *Components::Navigation::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::Components, Navigation)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* Components::Navigation::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/Navigation:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

CORBA::Object_ptr Components::Navigation::provide_facet (
    const char * name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Navigation_Proxy_Impl &proxy = 
    this->the_TAO_Navigation_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.provide_facet (
      this,
      name
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::Components::FacetDescriptions * Components::Navigation::get_all_facets (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Navigation_Proxy_Impl &proxy = 
    this->the_TAO_Navigation_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_all_facets (
      this
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::Components::FacetDescriptions * Components::Navigation::get_named_facets (
    const Components::NameList & names
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Navigation_Proxy_Impl &proxy = 
    this->the_TAO_Navigation_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_named_facets (
      this,
      names
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

CORBA::Boolean Components::Navigation::same_component (
    CORBA::Object_ptr object_ref
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Navigation_Proxy_Impl &proxy = 
    this->the_TAO_Navigation_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.same_component (
      this,
      object_ref
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_Navigation[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  38,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f4e), 
  ACE_NTOHL (0x61766967), 
  ACE_NTOHL (0x6174696f), 
  ACE_NTOHL (0x6e3a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Navigation:1.0
  11,
  ACE_NTOHL (0x4e617669), 
  ACE_NTOHL (0x67617469), 
  ACE_NTOHL (0x6f6e0000),  // name = Navigation
};

static CORBA::TypeCode _tc_TAO_tc_Components_Navigation (
    CORBA::tk_objref,
    sizeof (_oc_Components_Navigation),
    (char *) &_oc_Components_Navigation,
    0,
    sizeof (Components::Navigation)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_Navigation,
    &_tc_TAO_tc_Components_Navigation
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_ConnectionDescription[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  49,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x6f6e6e65), 
  ACE_NTOHL (0x6374696f), 
  ACE_NTOHL (0x6e446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/ConnectionDescription:1.0
  22,
  ACE_NTOHL (0x436f6e6e), 
  ACE_NTOHL (0x65637469), 
  ACE_NTOHL (0x6f6e4465), 
  ACE_NTOHL (0x73637269), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e000000),  // name = ConnectionDescription
  0, // value modifier
  CORBA::tk_null, // no stateful base valuetype

  2, // member count
  3,
  ACE_NTOHL (0x636b0000),  // name = ck
  CORBA::tk_value, // typecode kind
  172, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f43), 
    ACE_NTOHL (0x6f6f6b69), 
    ACE_NTOHL (0x653a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Cookie:1.0
    7,
    ACE_NTOHL (0x436f6f6b), 
    ACE_NTOHL (0x69650000),  // name = Cookie
    0, // value modifier
    CORBA::tk_null, // no stateful base valuetype

    1, // member count
    12,
    ACE_NTOHL (0x636f6f6b), 
    ACE_NTOHL (0x69655661), 
    ACE_NTOHL (0x6c756500),  // name = cookieValue
    CORBA::tk_alias, // typecode kind for typedefs
    76, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      31,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f4f63), 
      ACE_NTOHL (0x74657453), 
      ACE_NTOHL (0x65713a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OctetSeq:1.0
      9,
      ACE_NTOHL (0x4f637465), 
      ACE_NTOHL (0x74536571), 
      ACE_NTOHL (0x0),  // name = OctetSeq
      CORBA::tk_sequence, // typecode kind
      12, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        CORBA::tk_octet,

        0U,


    0, // data member visibility marker


  1, // data member visibility marker

  7,
  ACE_NTOHL (0x6f626a72), 
  ACE_NTOHL (0x65660000),  // name = objref
    1, // data member visibility marker

};

static CORBA::TypeCode _tc_TAO_tc_Components_ConnectionDescription (
    CORBA::tk_value,
    sizeof (_oc_Components_ConnectionDescription),
    (char *) &_oc_Components_ConnectionDescription,
    0,
    sizeof (Components::ConnectionDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ConnectionDescription,
    &_tc_TAO_tc_Components_ConnectionDescription
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_cs.cpp:95

void
tao_Components_ConnectionDescription_add_ref (
    Components::ConnectionDescription *p
  )
{
  CORBA::add_ref (p);
}

void
tao_Components_ConnectionDescription_remove_ref (
    Components::ConnectionDescription *p
  )
{
  CORBA::remove_ref (p);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:298

// *************************************************************
// Operations for class Components::ConnectionDescription_var
// *************************************************************

Components::ConnectionDescription_var::ConnectionDescription_var (void)
  : ptr_ (0)
{}

Components::ConnectionDescription_var::ConnectionDescription_var (ConnectionDescription* p)
  : ptr_ (p)
{}

Components::ConnectionDescription_var::ConnectionDescription_var (const ConnectionDescription* p)
  : ptr_ (ACE_const_cast (ConnectionDescription *, p))
{}

Components::ConnectionDescription *
Components::ConnectionDescription_var::ptr (void) const
{
  return this->ptr_;
}

Components::ConnectionDescription_var::ConnectionDescription_var (const ConnectionDescription_var &p)
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::ConnectionDescription_var::~ConnectionDescription_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::ConnectionDescription_var &
Components::ConnectionDescription_var::operator= (ConnectionDescription *p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::ConnectionDescription_var &
Components::ConnectionDescription_var::operator= (const ConnectionDescription_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    ConnectionDescription *tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  
  return *this;
}

Components::ConnectionDescription_var::operator const Components::ConnectionDescription* () const // cast
{
  return this->ptr_;
}

Components::ConnectionDescription_var::operator Components::ConnectionDescription* () // cast 
{
  return this->ptr_;
}

Components::ConnectionDescription *
Components::ConnectionDescription_var::operator-> (void) const
{
  return this->ptr_;
}

Components::ConnectionDescription *
Components::ConnectionDescription_var::in (void) const
{
  return this->ptr_;
}

Components::ConnectionDescription *&
Components::ConnectionDescription_var::inout (void)
{
  return this->ptr_;
}

Components::ConnectionDescription *&
Components::ConnectionDescription_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::ConnectionDescription *
Components::ConnectionDescription_var::_retn (void)
{
  // yield ownership of managed obj reference
  ConnectionDescription* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

void
Components::ConnectionDescription_var::tao_add_ref (
    ConnectionDescription *p
  )
{
  CORBA::add_ref (p);
}

void
Components::ConnectionDescription_var::tao_remove_ref (
    ConnectionDescription *p
  )
{
  CORBA::remove_ref (p);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:568

// *************************************************************
// Operations for class Components::ConnectionDescription_out
// *************************************************************

Components::ConnectionDescription_out::ConnectionDescription_out (ConnectionDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::ConnectionDescription_out::ConnectionDescription_out (ConnectionDescription_var &p)
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::ConnectionDescription_out::ConnectionDescription_out (const ConnectionDescription_out &p)
  : ptr_ (ACE_const_cast (ConnectionDescription_out&, p).ptr_)
{}

Components::ConnectionDescription_out &
Components::ConnectionDescription_out::operator= (const ConnectionDescription_out &p)
{
  this->ptr_ = ACE_const_cast (ConnectionDescription_out&, p).ptr_;
  return *this;
}

Components::ConnectionDescription_out &
Components::ConnectionDescription_out::operator= (const ConnectionDescription_var &p)
{
  ConnectionDescription *tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::ConnectionDescription_out &
Components::ConnectionDescription_out::operator= (ConnectionDescription *p)
{
  this->ptr_ = p;
  return *this;
}

Components::ConnectionDescription_out::operator Components::ConnectionDescription*& () // cast
{
  return this->ptr_;
}

Components::ConnectionDescription *&
Components::ConnectionDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::ConnectionDescription *
Components::ConnectionDescription_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_cs.cpp:138

Components::ConnectionDescription *
Components::ConnectionDescription::_downcast (CORBA::ValueBase *v)
{
  if (v == 0)
    {
      return 0;
    }
  
  return (ConnectionDescription *) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char *
Components::ConnectionDescription::_tao_obv_repository_id (void) const
{
  return this->_tao_obv_static_repository_id ();
}

void *
Components::ConnectionDescription::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    {
      return this;
    }
  
  void *rval = 0;
  
  return rval;
}

void
Components::ConnectionDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  ConnectionDescription *tmp =
    ACE_static_cast (
        ConnectionDescription *,
        _tao_void_pointer
      );
  delete tmp;
}

CORBA::Boolean Components::ConnectionDescription::_tao_marshal_v (TAO_OutputCDR & strm)
{
  return this->_tao_marshal__Components_ConnectionDescription (strm);
}

CORBA::Boolean Components::ConnectionDescription::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  return this->_tao_unmarshal__Components_ConnectionDescription (strm);
}

CORBA::Boolean Components::ConnectionDescription::_tao_unmarshal (
    TAO_InputCDR &strm,
    ConnectionDescription *&new_object
  )
{
  CORBA::ValueBase *base = 0;
  CORBA::ValueFactory_var factory;
  CORBA::Boolean retval =
    CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        factory,
        base,
        ConnectionDescription::_tao_obv_static_repository_id ()
      );
  
  if (retval == 0)
    {
      return 0;
    }
  
  if (factory.in () != 0)
    {
      base = factory->create_for_unmarshal ();
      
      if (base == 0)
        {
          return 0;  // %! except.?
        }
      
      retval = base->_tao_unmarshal_v (strm);
      
      if (retval == 0)
        {
          return 0;
        }
    }
  
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = ConnectionDescription::_downcast (base);
  return retval;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_init_cs.cpp:84

Components::ConnectionDescription_init::ConnectionDescription_init (void)
{
}

Components::ConnectionDescription_init::~ConnectionDescription_init (void)
{
}

const char* 
Components::ConnectionDescription_init::tao_repository_id (void)
{
  return Components::ConnectionDescription::_tao_obv_static_repository_id ();
}

CORBA_ValueBase *
Components::ConnectionDescription_init::create_for_unmarshal (void)
{
  CORBA_ValueBase *ret_val = 0;
  ACE_NEW_RETURN (
      ret_val,
      OBV_Components::ConnectionDescription,
      0
    );
  return ret_val;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_obj_sequence_cs.cpp:103

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_CONNECTIONDESCRIPTIONS_CS_)
#define __TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_CONNECTIONDESCRIPTIONS_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions::_allocate_buffer (CORBA::ULong length)
{
  Components::ConnectionDescription **tmp = 0;
  tmp = _TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      Components::ConnectionDescription **old = ACE_reinterpret_cast (Components::ConnectionDescription**, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          if (!this->release_)
            {
              tao_Components_ConnectionDescription_add_ref (old[i]);
              tmp[i] = old[i];
            }
          else
            {
              tmp[i] = old[i];
            }
        }
      
      if (this->release_)
        {
          delete [] old;
        }
    }
  
  this->buffer_ = tmp;
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  Components::ConnectionDescription **tmp = ACE_reinterpret_cast (Components::ConnectionDescription**, this->buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      tao_Components_ConnectionDescription_remove_ref (tmp[i]);
      tmp[i] = 0;
    }
  
  _TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions::freebuf (tmp);
  this->buffer_ = 0;
}

Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions::~_TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions (void)
{
  this->_deallocate_buffer ();
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  Components::ConnectionDescription **tmp = ACE_reinterpret_cast (Components::ConnectionDescription**, this->buffer_);
  
  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      tao_Components_ConnectionDescription_remove_ref (tmp[i]);
      tmp[i] = 0;
    }
}



#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_CONNECTIONDESCRIPTIONS_CS_)
#define _COMPONENTS_CONNECTIONDESCRIPTIONS_CS_

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// Components::ConnectionDescriptions
// *************************************************************

Components::ConnectionDescriptions::ConnectionDescriptions (void)
{}

Components::ConnectionDescriptions::ConnectionDescriptions (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::ConnectionDescription,Components::ConnectionDescription_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

Components::ConnectionDescriptions::ConnectionDescriptions (
    CORBA::ULong max,
    CORBA::ULong length,
    Components::ConnectionDescription_ptr *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::ConnectionDescription,Components::ConnectionDescription_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

Components::ConnectionDescriptions::ConnectionDescriptions (const ConnectionDescriptions &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::ConnectionDescription,Components::ConnectionDescription_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

Components::ConnectionDescriptions::~ConnectionDescriptions (void) // dtor
{}

void Components::ConnectionDescriptions::_tao_any_destructor (void *_tao_void_pointer)
{
  ConnectionDescriptions *tmp = ACE_static_cast (ConnectionDescriptions*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_ConnectionDescriptions[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  50,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x6f6e6e65), 
  ACE_NTOHL (0x6374696f), 
  ACE_NTOHL (0x6e446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x733a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/ConnectionDescriptions:1.0
  23,
  ACE_NTOHL (0x436f6e6e), 
  ACE_NTOHL (0x65637469), 
  ACE_NTOHL (0x6f6e4465), 
  ACE_NTOHL (0x73637269), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e730000),  // name = ConnectionDescriptions
  CORBA::tk_sequence, // typecode kind
  376, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_value, // typecode kind
    360, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      49,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f43), 
      ACE_NTOHL (0x6f6e6e65), 
      ACE_NTOHL (0x6374696f), 
      ACE_NTOHL (0x6e446573), 
      ACE_NTOHL (0x63726970), 
      ACE_NTOHL (0x74696f6e), 
      ACE_NTOHL (0x3a312e30), 
      ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/ConnectionDescription:1.0
      22,
      ACE_NTOHL (0x436f6e6e), 
      ACE_NTOHL (0x65637469), 
      ACE_NTOHL (0x6f6e4465), 
      ACE_NTOHL (0x73637269), 
      ACE_NTOHL (0x7074696f), 
      ACE_NTOHL (0x6e000000),  // name = ConnectionDescription
      0, // value modifier
      CORBA::tk_null, // no stateful base valuetype

      2, // member count
      3,
      ACE_NTOHL (0x636b0000),  // name = ck
      CORBA::tk_value, // typecode kind
      172, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f43), 
        ACE_NTOHL (0x6f6f6b69), 
        ACE_NTOHL (0x653a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Cookie:1.0
        7,
        ACE_NTOHL (0x436f6f6b), 
        ACE_NTOHL (0x69650000),  // name = Cookie
        0, // value modifier
        CORBA::tk_null, // no stateful base valuetype

        1, // member count
        12,
        ACE_NTOHL (0x636f6f6b), 
        ACE_NTOHL (0x69655661), 
        ACE_NTOHL (0x6c756500),  // name = cookieValue
        CORBA::tk_alias, // typecode kind for typedefs
        76, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f4f63), 
          ACE_NTOHL (0x74657453), 
          ACE_NTOHL (0x65713a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OctetSeq:1.0
          9,
          ACE_NTOHL (0x4f637465), 
          ACE_NTOHL (0x74536571), 
          ACE_NTOHL (0x0),  // name = OctetSeq
          CORBA::tk_sequence, // typecode kind
          12, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_octet,

            0U,


        0, // data member visibility marker


      1, // data member visibility marker

      7,
      ACE_NTOHL (0x6f626a72), 
      ACE_NTOHL (0x65660000),  // name = objref
            1, // data member visibility marker


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_Components_ConnectionDescriptions (
    CORBA::tk_alias,
    sizeof (_oc_Components_ConnectionDescriptions),
    (char *) &_oc_Components_ConnectionDescriptions,
    0,
    sizeof (Components::ConnectionDescriptions)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ConnectionDescriptions,
    &_tc_TAO_tc_Components_ConnectionDescriptions
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_ReceptacleDescription[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  49,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f52), 
  ACE_NTOHL (0x65636570), 
  ACE_NTOHL (0x7461636c), 
  ACE_NTOHL (0x65446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/ReceptacleDescription:1.0
  22,
  ACE_NTOHL (0x52656365), 
  ACE_NTOHL (0x70746163), 
  ACE_NTOHL (0x6c654465), 
  ACE_NTOHL (0x73637269), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e000000),  // name = ReceptacleDescription
  0, // value modifier
  CORBA::tk_value, // typecode kind
  276, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    43,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f50), 
    ACE_NTOHL (0x6f727444), 
    ACE_NTOHL (0x65736372), 
    ACE_NTOHL (0x69707469), 
    ACE_NTOHL (0x6f6e3a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/PortDescription:1.0
    16,
    ACE_NTOHL (0x506f7274), 
    ACE_NTOHL (0x44657363), 
    ACE_NTOHL (0x72697074), 
    ACE_NTOHL (0x696f6e00),  // name = PortDescription
    0, // value modifier
    CORBA::tk_null, // no stateful base valuetype

    2, // member count
    5,
    ACE_NTOHL (0x4e616d65), 
    ACE_NTOHL (0x0),  // name = Name
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      39,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f46), 
      ACE_NTOHL (0x65617475), 
      ACE_NTOHL (0x72654e61), 
      ACE_NTOHL (0x6d653a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
      12,
      ACE_NTOHL (0x46656174), 
      ACE_NTOHL (0x7572654e), 
      ACE_NTOHL (0x616d6500),  // name = FeatureName
      CORBA::tk_string, 
      0U, // string length

    1, // data member visibility marker

    8,
    ACE_NTOHL (0x74797065), 
    ACE_NTOHL (0x5f696400),  // name = type_id
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f5265), 
      ACE_NTOHL (0x706f7369), 
      ACE_NTOHL (0x746f7279), 
      ACE_NTOHL (0x49643a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13,
      ACE_NTOHL (0x5265706f), 
      ACE_NTOHL (0x7369746f), 
      ACE_NTOHL (0x72794964), 
      ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length

    1, // data member visibility marker


  2, // member count
  12,
  ACE_NTOHL (0x69735f6d), 
  ACE_NTOHL (0x756c7469), 
  ACE_NTOHL (0x706c6500),  // name = is_multiple
  CORBA::tk_boolean,

  1, // data member visibility marker

  12,
  ACE_NTOHL (0x636f6e6e), 
  ACE_NTOHL (0x65637469), 
  ACE_NTOHL (0x6f6e7300),  // name = connections
  CORBA::tk_alias, // typecode kind for typedefs
  472, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    50,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f43), 
    ACE_NTOHL (0x6f6e6e65), 
    ACE_NTOHL (0x6374696f), 
    ACE_NTOHL (0x6e446573), 
    ACE_NTOHL (0x63726970), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x733a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/ConnectionDescriptions:1.0
    23,
    ACE_NTOHL (0x436f6e6e), 
    ACE_NTOHL (0x65637469), 
    ACE_NTOHL (0x6f6e4465), 
    ACE_NTOHL (0x73637269), 
    ACE_NTOHL (0x7074696f), 
    ACE_NTOHL (0x6e730000),  // name = ConnectionDescriptions
    CORBA::tk_sequence, // typecode kind
    376, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_value, // typecode kind
      360, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        49,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f43), 
        ACE_NTOHL (0x6f6e6e65), 
        ACE_NTOHL (0x6374696f), 
        ACE_NTOHL (0x6e446573), 
        ACE_NTOHL (0x63726970), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/ConnectionDescription:1.0
        22,
        ACE_NTOHL (0x436f6e6e), 
        ACE_NTOHL (0x65637469), 
        ACE_NTOHL (0x6f6e4465), 
        ACE_NTOHL (0x73637269), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e000000),  // name = ConnectionDescription
        0, // value modifier
        CORBA::tk_null, // no stateful base valuetype

        2, // member count
        3,
        ACE_NTOHL (0x636b0000),  // name = ck
        CORBA::tk_value, // typecode kind
        172, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          34,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f6d70), 
          ACE_NTOHL (0x6f6e656e), 
          ACE_NTOHL (0x74732f43), 
          ACE_NTOHL (0x6f6f6b69), 
          ACE_NTOHL (0x653a312e), 
          ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Cookie:1.0
          7,
          ACE_NTOHL (0x436f6f6b), 
          ACE_NTOHL (0x69650000),  // name = Cookie
          0, // value modifier
          CORBA::tk_null, // no stateful base valuetype

          1, // member count
          12,
          ACE_NTOHL (0x636f6f6b), 
          ACE_NTOHL (0x69655661), 
          ACE_NTOHL (0x6c756500),  // name = cookieValue
          CORBA::tk_alias, // typecode kind for typedefs
          76, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            31,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x6f6d672e), 
            ACE_NTOHL (0x6f72672f), 
            ACE_NTOHL (0x434f5242), 
            ACE_NTOHL (0x412f4f63), 
            ACE_NTOHL (0x74657453), 
            ACE_NTOHL (0x65713a31), 
            ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OctetSeq:1.0
            9,
            ACE_NTOHL (0x4f637465), 
            ACE_NTOHL (0x74536571), 
            ACE_NTOHL (0x0),  // name = OctetSeq
            CORBA::tk_sequence, // typecode kind
            12, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              CORBA::tk_octet,

              0U,


          0, // data member visibility marker


        1, // data member visibility marker

        7,
        ACE_NTOHL (0x6f626a72), 
        ACE_NTOHL (0x65660000),  // name = objref
                1, // data member visibility marker


      0U,


  1, // data member visibility marker

};

static CORBA::TypeCode _tc_TAO_tc_Components_ReceptacleDescription (
    CORBA::tk_value,
    sizeof (_oc_Components_ReceptacleDescription),
    (char *) &_oc_Components_ReceptacleDescription,
    0,
    sizeof (Components::ReceptacleDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ReceptacleDescription,
    &_tc_TAO_tc_Components_ReceptacleDescription
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_cs.cpp:95

void
tao_Components_ReceptacleDescription_add_ref (
    Components::ReceptacleDescription *p
  )
{
  CORBA::add_ref (p);
}

void
tao_Components_ReceptacleDescription_remove_ref (
    Components::ReceptacleDescription *p
  )
{
  CORBA::remove_ref (p);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:298

// *************************************************************
// Operations for class Components::ReceptacleDescription_var
// *************************************************************

Components::ReceptacleDescription_var::ReceptacleDescription_var (void)
  : ptr_ (0)
{}

Components::ReceptacleDescription_var::ReceptacleDescription_var (ReceptacleDescription* p)
  : ptr_ (p)
{}

Components::ReceptacleDescription_var::ReceptacleDescription_var (const ReceptacleDescription* p)
  : ptr_ (ACE_const_cast (ReceptacleDescription *, p))
{}

Components::ReceptacleDescription *
Components::ReceptacleDescription_var::ptr (void) const
{
  return this->ptr_;
}

Components::ReceptacleDescription_var::ReceptacleDescription_var (const ReceptacleDescription_var &p)
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::ReceptacleDescription_var::~ReceptacleDescription_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::ReceptacleDescription_var &
Components::ReceptacleDescription_var::operator= (ReceptacleDescription *p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::ReceptacleDescription_var &
Components::ReceptacleDescription_var::operator= (const ReceptacleDescription_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    ReceptacleDescription *tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  
  return *this;
}

Components::ReceptacleDescription_var::operator const Components::ReceptacleDescription* () const // cast
{
  return this->ptr_;
}

Components::ReceptacleDescription_var::operator Components::ReceptacleDescription* () // cast 
{
  return this->ptr_;
}

Components::ReceptacleDescription *
Components::ReceptacleDescription_var::operator-> (void) const
{
  return this->ptr_;
}

Components::ReceptacleDescription *
Components::ReceptacleDescription_var::in (void) const
{
  return this->ptr_;
}

Components::ReceptacleDescription *&
Components::ReceptacleDescription_var::inout (void)
{
  return this->ptr_;
}

Components::ReceptacleDescription *&
Components::ReceptacleDescription_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::ReceptacleDescription *
Components::ReceptacleDescription_var::_retn (void)
{
  // yield ownership of managed obj reference
  ReceptacleDescription* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

void
Components::ReceptacleDescription_var::tao_add_ref (
    ReceptacleDescription *p
  )
{
  CORBA::add_ref (p);
}

void
Components::ReceptacleDescription_var::tao_remove_ref (
    ReceptacleDescription *p
  )
{
  CORBA::remove_ref (p);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:568

// *************************************************************
// Operations for class Components::ReceptacleDescription_out
// *************************************************************

Components::ReceptacleDescription_out::ReceptacleDescription_out (ReceptacleDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::ReceptacleDescription_out::ReceptacleDescription_out (ReceptacleDescription_var &p)
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::ReceptacleDescription_out::ReceptacleDescription_out (const ReceptacleDescription_out &p)
  : ptr_ (ACE_const_cast (ReceptacleDescription_out&, p).ptr_)
{}

Components::ReceptacleDescription_out &
Components::ReceptacleDescription_out::operator= (const ReceptacleDescription_out &p)
{
  this->ptr_ = ACE_const_cast (ReceptacleDescription_out&, p).ptr_;
  return *this;
}

Components::ReceptacleDescription_out &
Components::ReceptacleDescription_out::operator= (const ReceptacleDescription_var &p)
{
  ReceptacleDescription *tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::ReceptacleDescription_out &
Components::ReceptacleDescription_out::operator= (ReceptacleDescription *p)
{
  this->ptr_ = p;
  return *this;
}

Components::ReceptacleDescription_out::operator Components::ReceptacleDescription*& () // cast
{
  return this->ptr_;
}

Components::ReceptacleDescription *&
Components::ReceptacleDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::ReceptacleDescription *
Components::ReceptacleDescription_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_cs.cpp:138

Components::ReceptacleDescription *
Components::ReceptacleDescription::_downcast (CORBA::ValueBase *v)
{
  if (v == 0)
    {
      return 0;
    }
  
  return (ReceptacleDescription *) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char *
Components::ReceptacleDescription::_tao_obv_repository_id (void) const
{
  return this->_tao_obv_static_repository_id ();
}

void *
Components::ReceptacleDescription::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    {
      return this;
    }
  
  void *rval = 0;
  
  if (rval == 0)
    {
      rval = ACE_NESTED_CLASS (Components,PortDescription)::_tao_obv_narrow (type_id);
    }
  
  return rval;
}

void
Components::ReceptacleDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  ReceptacleDescription *tmp =
    ACE_static_cast (
        ReceptacleDescription *,
        _tao_void_pointer
      );
  delete tmp;
}

CORBA::Boolean Components::ReceptacleDescription::_tao_marshal_v (TAO_OutputCDR & strm)
{
  return this->_tao_marshal__Components_ReceptacleDescription (strm);
}

CORBA::Boolean Components::ReceptacleDescription::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  return this->_tao_unmarshal__Components_ReceptacleDescription (strm);
}

CORBA::Boolean Components::ReceptacleDescription::_tao_unmarshal (
    TAO_InputCDR &strm,
    ReceptacleDescription *&new_object
  )
{
  CORBA::ValueBase *base = 0;
  CORBA::ValueFactory_var factory;
  CORBA::Boolean retval =
    CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        factory,
        base,
        ReceptacleDescription::_tao_obv_static_repository_id ()
      );
  
  if (retval == 0)
    {
      return 0;
    }
  
  if (factory.in () != 0)
    {
      base = factory->create_for_unmarshal ();
      
      if (base == 0)
        {
          return 0;  // %! except.?
        }
      
      retval = base->_tao_unmarshal_v (strm);
      
      if (retval == 0)
        {
          return 0;
        }
    }
  
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = ReceptacleDescription::_downcast (base);
  return retval;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_init_cs.cpp:84

Components::ReceptacleDescription_init::ReceptacleDescription_init (void)
{
}

Components::ReceptacleDescription_init::~ReceptacleDescription_init (void)
{
}

const char* 
Components::ReceptacleDescription_init::tao_repository_id (void)
{
  return Components::ReceptacleDescription::_tao_obv_static_repository_id ();
}

CORBA_ValueBase *
Components::ReceptacleDescription_init::create_for_unmarshal (void)
{
  CORBA_ValueBase *ret_val = 0;
  ACE_NEW_RETURN (
      ret_val,
      OBV_Components::ReceptacleDescription,
      0
    );
  return ret_val;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_obj_sequence_cs.cpp:103

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_RECEPTACLEDESCRIPTIONS_CS_)
#define __TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_RECEPTACLEDESCRIPTIONS_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions::_allocate_buffer (CORBA::ULong length)
{
  Components::ReceptacleDescription **tmp = 0;
  tmp = _TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      Components::ReceptacleDescription **old = ACE_reinterpret_cast (Components::ReceptacleDescription**, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          if (!this->release_)
            {
              tao_Components_ReceptacleDescription_add_ref (old[i]);
              tmp[i] = old[i];
            }
          else
            {
              tmp[i] = old[i];
            }
        }
      
      if (this->release_)
        {
          delete [] old;
        }
    }
  
  this->buffer_ = tmp;
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  Components::ReceptacleDescription **tmp = ACE_reinterpret_cast (Components::ReceptacleDescription**, this->buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      tao_Components_ReceptacleDescription_remove_ref (tmp[i]);
      tmp[i] = 0;
    }
  
  _TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions::freebuf (tmp);
  this->buffer_ = 0;
}

Components::_TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions::~_TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions (void)
{
  this->_deallocate_buffer ();
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  Components::ReceptacleDescription **tmp = ACE_reinterpret_cast (Components::ReceptacleDescription**, this->buffer_);
  
  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      tao_Components_ReceptacleDescription_remove_ref (tmp[i]);
      tmp[i] = 0;
    }
}



#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_RECEPTACLEDESCRIPTIONS_CS_)
#define _COMPONENTS_RECEPTACLEDESCRIPTIONS_CS_

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// Components::ReceptacleDescriptions
// *************************************************************

Components::ReceptacleDescriptions::ReceptacleDescriptions (void)
{}

Components::ReceptacleDescriptions::ReceptacleDescriptions (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::ReceptacleDescription,Components::ReceptacleDescription_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

Components::ReceptacleDescriptions::ReceptacleDescriptions (
    CORBA::ULong max,
    CORBA::ULong length,
    Components::ReceptacleDescription_ptr *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::ReceptacleDescription,Components::ReceptacleDescription_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

Components::ReceptacleDescriptions::ReceptacleDescriptions (const ReceptacleDescriptions &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::ReceptacleDescription,Components::ReceptacleDescription_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

Components::ReceptacleDescriptions::~ReceptacleDescriptions (void) // dtor
{}

void Components::ReceptacleDescriptions::_tao_any_destructor (void *_tao_void_pointer)
{
  ReceptacleDescriptions *tmp = ACE_static_cast (ReceptacleDescriptions*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_ReceptacleDescriptions[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  50,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f52), 
  ACE_NTOHL (0x65636570), 
  ACE_NTOHL (0x7461636c), 
  ACE_NTOHL (0x65446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x733a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/ReceptacleDescriptions:1.0
  23,
  ACE_NTOHL (0x52656365), 
  ACE_NTOHL (0x70746163), 
  ACE_NTOHL (0x6c654465), 
  ACE_NTOHL (0x73637269), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e730000),  // name = ReceptacleDescriptions
  CORBA::tk_sequence, // typecode kind
  920, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_value, // typecode kind
    904, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      49,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f52), 
      ACE_NTOHL (0x65636570), 
      ACE_NTOHL (0x7461636c), 
      ACE_NTOHL (0x65446573), 
      ACE_NTOHL (0x63726970), 
      ACE_NTOHL (0x74696f6e), 
      ACE_NTOHL (0x3a312e30), 
      ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/ReceptacleDescription:1.0
      22,
      ACE_NTOHL (0x52656365), 
      ACE_NTOHL (0x70746163), 
      ACE_NTOHL (0x6c654465), 
      ACE_NTOHL (0x73637269), 
      ACE_NTOHL (0x7074696f), 
      ACE_NTOHL (0x6e000000),  // name = ReceptacleDescription
      0, // value modifier
      CORBA::tk_value, // typecode kind
      276, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f50), 
        ACE_NTOHL (0x6f727444), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e3a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/PortDescription:1.0
        16,
        ACE_NTOHL (0x506f7274), 
        ACE_NTOHL (0x44657363), 
        ACE_NTOHL (0x72697074), 
        ACE_NTOHL (0x696f6e00),  // name = PortDescription
        0, // value modifier
        CORBA::tk_null, // no stateful base valuetype

        2, // member count
        5,
        ACE_NTOHL (0x4e616d65), 
        ACE_NTOHL (0x0),  // name = Name
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          39,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f6d70), 
          ACE_NTOHL (0x6f6e656e), 
          ACE_NTOHL (0x74732f46), 
          ACE_NTOHL (0x65617475), 
          ACE_NTOHL (0x72654e61), 
          ACE_NTOHL (0x6d653a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
          12,
          ACE_NTOHL (0x46656174), 
          ACE_NTOHL (0x7572654e), 
          ACE_NTOHL (0x616d6500),  // name = FeatureName
          CORBA::tk_string, 
          0U, // string length

        1, // data member visibility marker

        8,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x5f696400),  // name = type_id
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f5265), 
          ACE_NTOHL (0x706f7369), 
          ACE_NTOHL (0x746f7279), 
          ACE_NTOHL (0x49643a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13,
          ACE_NTOHL (0x5265706f), 
          ACE_NTOHL (0x7369746f), 
          ACE_NTOHL (0x72794964), 
          ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        1, // data member visibility marker


      2, // member count
      12,
      ACE_NTOHL (0x69735f6d), 
      ACE_NTOHL (0x756c7469), 
      ACE_NTOHL (0x706c6500),  // name = is_multiple
      CORBA::tk_boolean,

      1, // data member visibility marker

      12,
      ACE_NTOHL (0x636f6e6e), 
      ACE_NTOHL (0x65637469), 
      ACE_NTOHL (0x6f6e7300),  // name = connections
      CORBA::tk_alias, // typecode kind for typedefs
      472, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        50,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f43), 
        ACE_NTOHL (0x6f6e6e65), 
        ACE_NTOHL (0x6374696f), 
        ACE_NTOHL (0x6e446573), 
        ACE_NTOHL (0x63726970), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x733a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/ConnectionDescriptions:1.0
        23,
        ACE_NTOHL (0x436f6e6e), 
        ACE_NTOHL (0x65637469), 
        ACE_NTOHL (0x6f6e4465), 
        ACE_NTOHL (0x73637269), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e730000),  // name = ConnectionDescriptions
        CORBA::tk_sequence, // typecode kind
        376, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_value, // typecode kind
          360, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            49,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x6f6d672e), 
            ACE_NTOHL (0x6f72672f), 
            ACE_NTOHL (0x436f6d70), 
            ACE_NTOHL (0x6f6e656e), 
            ACE_NTOHL (0x74732f43), 
            ACE_NTOHL (0x6f6e6e65), 
            ACE_NTOHL (0x6374696f), 
            ACE_NTOHL (0x6e446573), 
            ACE_NTOHL (0x63726970), 
            ACE_NTOHL (0x74696f6e), 
            ACE_NTOHL (0x3a312e30), 
            ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/ConnectionDescription:1.0
            22,
            ACE_NTOHL (0x436f6e6e), 
            ACE_NTOHL (0x65637469), 
            ACE_NTOHL (0x6f6e4465), 
            ACE_NTOHL (0x73637269), 
            ACE_NTOHL (0x7074696f), 
            ACE_NTOHL (0x6e000000),  // name = ConnectionDescription
            0, // value modifier
            CORBA::tk_null, // no stateful base valuetype

            2, // member count
            3,
            ACE_NTOHL (0x636b0000),  // name = ck
            CORBA::tk_value, // typecode kind
            172, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              34,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x436f6d70), 
              ACE_NTOHL (0x6f6e656e), 
              ACE_NTOHL (0x74732f43), 
              ACE_NTOHL (0x6f6f6b69), 
              ACE_NTOHL (0x653a312e), 
              ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Cookie:1.0
              7,
              ACE_NTOHL (0x436f6f6b), 
              ACE_NTOHL (0x69650000),  // name = Cookie
              0, // value modifier
              CORBA::tk_null, // no stateful base valuetype

              1, // member count
              12,
              ACE_NTOHL (0x636f6f6b), 
              ACE_NTOHL (0x69655661), 
              ACE_NTOHL (0x6c756500),  // name = cookieValue
              CORBA::tk_alias, // typecode kind for typedefs
              76, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                31,
                ACE_NTOHL (0x49444c3a), 
                ACE_NTOHL (0x6f6d672e), 
                ACE_NTOHL (0x6f72672f), 
                ACE_NTOHL (0x434f5242), 
                ACE_NTOHL (0x412f4f63), 
                ACE_NTOHL (0x74657453), 
                ACE_NTOHL (0x65713a31), 
                ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OctetSeq:1.0
                9,
                ACE_NTOHL (0x4f637465), 
                ACE_NTOHL (0x74536571), 
                ACE_NTOHL (0x0),  // name = OctetSeq
                CORBA::tk_sequence, // typecode kind
                12, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  CORBA::tk_octet,

                  0U,


              0, // data member visibility marker


            1, // data member visibility marker

            7,
            ACE_NTOHL (0x6f626a72), 
            ACE_NTOHL (0x65660000),  // name = objref
                        1, // data member visibility marker


          0U,


      1, // data member visibility marker


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_Components_ReceptacleDescriptions (
    CORBA::tk_alias,
    sizeof (_oc_Components_ReceptacleDescriptions),
    (char *) &_oc_Components_ReceptacleDescriptions,
    0,
    sizeof (Components::ReceptacleDescriptions)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ReceptacleDescriptions,
    &_tc_TAO_tc_Components_ReceptacleDescriptions
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int Components::Receptacles::_tao_class_id = 0;

Components::Receptacles_ptr
tao_Components_Receptacles_duplicate (
    Components::Receptacles_ptr p
  )
{
  return Components::Receptacles::_duplicate (p);
}

void
tao_Components_Receptacles_release (
    Components::Receptacles_ptr p
  )
{
  CORBA::release (p);
}

Components::Receptacles_ptr
tao_Components_Receptacles_nil (
    void
  )
{
  return Components::Receptacles::_nil ();
}

Components::Receptacles_ptr
tao_Components_Receptacles_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::Receptacles::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_Receptacles_upcast (
    void *src
  )
{
  Components::Receptacles **tmp =
    ACE_static_cast (Components::Receptacles **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// Components::Receptacles_var
// *************************************************************

Components::Receptacles_var::Receptacles_var (void)
  : ptr_ (Receptacles::_nil ())
{}

::Components::Receptacles_ptr
Components::Receptacles_var::ptr (void) const
{
  return this->ptr_;
}

Components::Receptacles_var::Receptacles_var (const ::Components::Receptacles_var &p)
  : TAO_Base_var (),
    ptr_ (Receptacles::_duplicate (p.ptr ()))
{}

Components::Receptacles_var::~Receptacles_var (void)
{
  CORBA::release (this->ptr_);
}

Components::Receptacles_var &
Components::Receptacles_var::operator= (Receptacles_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::Receptacles_var &
Components::Receptacles_var::operator= (const ::Components::Receptacles_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::Receptacles::_duplicate (p.ptr ());
  }
  return *this;
}

Components::Receptacles_var::operator const ::Components::Receptacles_ptr &() const // cast
{
  return this->ptr_;
}

Components::Receptacles_var::operator ::Components::Receptacles_ptr &() // cast 
{
  return this->ptr_;
}

::Components::Receptacles_ptr
Components::Receptacles_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::Receptacles_ptr
Components::Receptacles_var::in (void) const
{
  return this->ptr_;
}

::Components::Receptacles_ptr &
Components::Receptacles_var::inout (void)
{
  return this->ptr_;
}

::Components::Receptacles_ptr &
Components::Receptacles_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Receptacles::_nil ();
  return this->ptr_;
}

::Components::Receptacles_ptr
Components::Receptacles_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::Receptacles_ptr val = this->ptr_;
  this->ptr_ = ::Components::Receptacles::_nil ();
  return val;
}

::Components::Receptacles_ptr
Components::Receptacles_var::tao_duplicate (Receptacles_ptr p)
{
  return ::Components::Receptacles::_duplicate (p);
}

void
Components::Receptacles_var::tao_release (Receptacles_ptr p)
{
  CORBA::release (p);
}

::Components::Receptacles_ptr
Components::Receptacles_var::tao_nil (void)
{
  return ::Components::Receptacles::_nil ();
}

::Components::Receptacles_ptr
Components::Receptacles_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::Receptacles::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::Receptacles_var::tao_upcast (void *src)
{
  Receptacles **tmp =
    ACE_static_cast (Receptacles **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// Components::Receptacles_out
// *************************************************************

Components::Receptacles_out::Receptacles_out (Receptacles_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::Receptacles::_nil ();
}

Components::Receptacles_out::Receptacles_out (Receptacles_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Receptacles::_nil ();
}

Components::Receptacles_out::Receptacles_out (const ::Components::Receptacles_out &p)
  : ptr_ (ACE_const_cast (Receptacles_out &, p).ptr_)
{}

::Components::Receptacles_out &
Components::Receptacles_out::operator= (const ::Components::Receptacles_out &p)
{
  this->ptr_ = ACE_const_cast (Receptacles_out&, p).ptr_;
  return *this;
}

Components::Receptacles_out &
Components::Receptacles_out::operator= (const ::Components::Receptacles_var &p)
{
  this->ptr_ = ::Components::Receptacles::_duplicate (p.ptr ());
  return *this;
}

Components::Receptacles_out &
Components::Receptacles_out::operator= (Receptacles_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::Receptacles_out::operator ::Components::Receptacles_ptr &() // cast
{
  return this->ptr_;
}

::Components::Receptacles_ptr &
Components::Receptacles_out::ptr (void)
{
  return this->ptr_;
}

::Components::Receptacles_ptr
Components::Receptacles_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_Receptacles_connect : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Receptacles_connect (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * name,
      CORBA::Object_ptr connection);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::Cookie * result);

private:
  TAO_ClientRequestInfo_Components_Receptacles_connect (const TAO_ClientRequestInfo_Components_Receptacles_connect &);
  void operator= (const TAO_ClientRequestInfo_Components_Receptacles_connect &);
  const char * name_;
  CORBA::Object_ptr connection_;
  
  Components::Cookie * _result;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_Receptacles_connect::TAO_ClientRequestInfo_Components_Receptacles_connect (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * name,
    CORBA::Object_ptr connection    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    name_ (name),
    connection_ (connection)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Receptacles_connect::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (2);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= connection_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Receptacles_connect::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Receptacles_connect_exceptiondata[] = 
  {
    Components::_tc_InvalidName,
    Components::_tc_InvalidConnection,
    Components::_tc_AlreadyConnected,
    Components::_tc_ExceededConnectionLimit
  };
  
  exception_list->length (4);
  for (CORBA::ULong i = 0; i < 4; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Receptacles_connect_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Receptacles_connect::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Receptacles_connect::result (::Components::Cookie * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_Receptacles_disconnect : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Receptacles_disconnect (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * name,
      Components::Cookie * ck);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_Receptacles_disconnect (const TAO_ClientRequestInfo_Components_Receptacles_disconnect &);
  void operator= (const TAO_ClientRequestInfo_Components_Receptacles_disconnect &);
  const char * name_;
  Components::Cookie * ck_;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_Receptacles_disconnect::TAO_ClientRequestInfo_Components_Receptacles_disconnect (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * name,
    Components::Cookie * ck    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    name_ (name),
    ck_ (ck)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Receptacles_disconnect::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->ck_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Receptacles_disconnect::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Receptacles_disconnect_exceptiondata[] = 
  {
    Components::_tc_InvalidName,
    Components::_tc_InvalidConnection,
    Components::_tc_CookieRequired,
    Components::_tc_NoConnection
  };
  
  exception_list->length (4);
  for (CORBA::ULong i = 0; i < 4; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Receptacles_disconnect_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Receptacles_disconnect::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_Receptacles_get_connections : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Receptacles_get_connections (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * name);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::ConnectionDescriptions * result);

private:
  TAO_ClientRequestInfo_Components_Receptacles_get_connections (const TAO_ClientRequestInfo_Components_Receptacles_get_connections &);
  void operator= (const TAO_ClientRequestInfo_Components_Receptacles_get_connections &);
  const char * name_;
  
  Components::ConnectionDescriptions * _result;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_Receptacles_get_connections::TAO_ClientRequestInfo_Components_Receptacles_get_connections (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * name    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    name_ (name)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Receptacles_get_connections::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Receptacles_get_connections::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Receptacles_get_connections_exceptiondata[] = 
  {
    Components::_tc_InvalidName
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Receptacles_get_connections_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Receptacles_get_connections::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Receptacles_get_connections::result (::Components::ConnectionDescriptions * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_Receptacles_get_all_receptacles : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Receptacles_get_all_receptacles (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::ReceptacleDescriptions * result);

private:
  TAO_ClientRequestInfo_Components_Receptacles_get_all_receptacles (const TAO_ClientRequestInfo_Components_Receptacles_get_all_receptacles &);
  void operator= (const TAO_ClientRequestInfo_Components_Receptacles_get_all_receptacles &);
  
  Components::ReceptacleDescriptions * _result;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_Receptacles_get_all_receptacles::TAO_ClientRequestInfo_Components_Receptacles_get_all_receptacles (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Receptacles_get_all_receptacles::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Receptacles_get_all_receptacles::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Receptacles_get_all_receptacles::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Receptacles_get_all_receptacles::result (::Components::ReceptacleDescriptions * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_Receptacles_get_named_receptacles : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Receptacles_get_named_receptacles (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const Components::NameList & names);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::ReceptacleDescriptions * result);

private:
  TAO_ClientRequestInfo_Components_Receptacles_get_named_receptacles (const TAO_ClientRequestInfo_Components_Receptacles_get_named_receptacles &);
  void operator= (const TAO_ClientRequestInfo_Components_Receptacles_get_named_receptacles &);
  const Components::NameList & names_;
  
  Components::ReceptacleDescriptions * _result;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_Receptacles_get_named_receptacles::TAO_ClientRequestInfo_Components_Receptacles_get_named_receptacles (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const Components::NameList & names    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    names_ (names)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Receptacles_get_named_receptacles::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->names_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Receptacles_get_named_receptacles::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Receptacles_get_named_receptacles_exceptiondata[] = 
  {
    Components::_tc_InvalidName
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Receptacles_get_named_receptacles_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Receptacles_get_named_receptacles::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Receptacles_get_named_receptacles::result (::Components::ReceptacleDescriptions * result)
{
  // Update the result. 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

Components::_TAO_Receptacles_Proxy_Impl::_TAO_Receptacles_Proxy_Impl (void)
{}

Components::_TAO_Receptacles_Remote_Proxy_Impl::_TAO_Receptacles_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::Components::Cookie * Components::_TAO_Receptacles_Remote_Proxy_Impl::connect (
    CORBA_Object *_collocated_tao_target_,
    const char * name,
    CORBA::Object_ptr connection
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
    , Components::InvalidConnection
    , Components::AlreadyConnected
    , Components::ExceededConnectionLimit
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
    static TAO_Exception_Data _tao_Components_Receptacles_connect_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/InvalidName:1.0",
      Components::InvalidName::_alloc
    },
    {
      "IDL:omg.org/Components/InvalidConnection:1.0",
      Components::InvalidConnection::_alloc
    },
    {
      "IDL:omg.org/Components/AlreadyConnected:1.0",
      Components::AlreadyConnected::_alloc
    },
    {
      "IDL:omg.org/Components/ExceededConnectionLimit:1.0",
      Components::ExceededConnectionLimit::_alloc
    }
  };

::Components::Cookie_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "connect",
      7,
      2,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Receptacles_connect _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          name,
          connection
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << name) &&
              (_tao_out << connection)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (_tao_Components_Receptacles_connect_exceptiondata, 4 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::Cookie * _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void Components::_TAO_Receptacles_Remote_Proxy_Impl::disconnect (
    CORBA_Object *_collocated_tao_target_,
    const char * name,
    Components::Cookie * ck
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
    , Components::InvalidConnection
    , Components::CookieRequired
    , Components::NoConnection
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
    static TAO_Exception_Data _tao_Components_Receptacles_disconnect_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/InvalidName:1.0",
      Components::InvalidName::_alloc
    },
    {
      "IDL:omg.org/Components/InvalidConnection:1.0",
      Components::InvalidConnection::_alloc
    },
    {
      "IDL:omg.org/Components/CookieRequired:1.0",
      Components::CookieRequired::_alloc
    },
    {
      "IDL:omg.org/Components/NoConnection:1.0",
      Components::NoConnection::_alloc
    }
  };

TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "disconnect",
      10,
      2,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Receptacles_disconnect _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          name,
          ck
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << name) &&
              (_tao_out << ck)
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (_tao_Components_Receptacles_disconnect_exceptiondata, 4 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::Components::ConnectionDescriptions * Components::_TAO_Receptacles_Remote_Proxy_Impl::get_connections (
    CORBA_Object *_collocated_tao_target_,
    const char * name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
    static TAO_Exception_Data _tao_Components_Receptacles_get_connections_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/InvalidName:1.0",
      Components::InvalidName::_alloc
    }
  };

Components::ConnectionDescriptions_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    Components::ConnectionDescriptions *tmp;
    ACE_NEW_RETURN (tmp, Components::ConnectionDescriptions, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_connections",
      15,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Receptacles_get_connections _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          name
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << name)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (_tao_Components_Receptacles_get_connections_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::ConnectionDescriptions * _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::Components::ReceptacleDescriptions * Components::_TAO_Receptacles_Remote_Proxy_Impl::get_all_receptacles (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  Components::ReceptacleDescriptions_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    Components::ReceptacleDescriptions *tmp;
    ACE_NEW_RETURN (tmp, Components::ReceptacleDescriptions, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_all_receptacles",
      19,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Receptacles_get_all_receptacles _tao_ri (
          &_tao_call,
          _collocated_tao_target_
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::ReceptacleDescriptions * _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::Components::ReceptacleDescriptions * Components::_TAO_Receptacles_Remote_Proxy_Impl::get_named_receptacles (
    CORBA_Object *_collocated_tao_target_,
    const Components::NameList & names
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
    static TAO_Exception_Data _tao_Components_Receptacles_get_named_receptacles_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/InvalidName:1.0",
      Components::InvalidName::_alloc
    }
  };

Components::ReceptacleDescriptions_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    Components::ReceptacleDescriptions *tmp;
    ACE_NEW_RETURN (tmp, Components::ReceptacleDescriptions, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_named_receptacles",
      21,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Receptacles_get_named_receptacles _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          names
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << names)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (_tao_Components_Receptacles_get_named_receptacles_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::ReceptacleDescriptions * _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

Components::_TAO_Receptacles_Proxy_Broker::_TAO_Receptacles_Proxy_Broker (void)
{
}

Components::_TAO_Receptacles_Proxy_Broker::~_TAO_Receptacles_Proxy_Broker (void)
{
}

Components::_TAO_Receptacles_Proxy_Broker * (*Components__TAO_Receptacles_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
Components::_TAO_Receptacles_Remote_Proxy_Broker *
Components::_TAO_Receptacles_Remote_Proxy_Broker::the_TAO_Receptacles_Remote_Proxy_Broker (void)
{
  static ::Components::_TAO_Receptacles_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

Components::_TAO_Receptacles_Remote_Proxy_Broker::_TAO_Receptacles_Remote_Proxy_Broker (void)
{
}

Components::_TAO_Receptacles_Remote_Proxy_Broker::~_TAO_Receptacles_Remote_Proxy_Broker (void)
{
}

Components::_TAO_Receptacles_Proxy_Impl&
Components::_TAO_Receptacles_Remote_Proxy_Broker::select_proxy (
    ::Components::Receptacles *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:225

Components::Receptacles::Receptacles (int collocated)
{
  this->Components_Receptacles_setup_collocation (collocated);
}

void
Components::Receptacles::Components_Receptacles_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_Receptacles_Proxy_Broker_ =
      ::Components__TAO_Receptacles_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_Receptacles_Proxy_Broker_ =
      ::Components::_TAO_Receptacles_Remote_Proxy_Broker::the_TAO_Receptacles_Remote_Proxy_Broker ();
}

Components::Receptacles::~Receptacles (void)
{}

void 
Components::Receptacles::_tao_any_destructor (void *_tao_void_pointer)
{
  Receptacles *tmp = ACE_static_cast (Receptacles *, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::Receptacles_ptr
Components::Receptacles::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return Receptacles::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/Components/Receptacles:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (Receptacles::_nil ());
      
      if (is_a == 0)
        {
          return Receptacles::_nil ();
        }
    }
  
  return Receptacles::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::Receptacles_ptr 
Components::Receptacles::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return Receptacles::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      Receptacles_ptr default_proxy = Receptacles::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          Components__TAO_Receptacles_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::Receptacles (
                  stub,
                  1,
                  obj->_servant ()
                ),
              Receptacles::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::Receptacles (
                  stub,
                  0,
                  obj->_servant ()
                ),
              Receptacles::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          Receptacles_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &Receptacles::_tao_class_id
                )
            )
        );
}

Components::Receptacles_ptr
Components::Receptacles::_duplicate (Receptacles_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
Components::Receptacles::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/Components/Receptacles:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->CORBA_Object::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *Components::Receptacles::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::Components, Receptacles)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* Components::Receptacles::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/Receptacles:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::Components::Cookie * Components::Receptacles::connect (
    const char * name,
    CORBA::Object_ptr connection
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
    , Components::InvalidConnection
    , Components::AlreadyConnected
    , Components::ExceededConnectionLimit
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Receptacles_Proxy_Impl &proxy = 
    this->the_TAO_Receptacles_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.connect (
      this,
      name,
      connection
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void Components::Receptacles::disconnect (
    const char * name,
    Components::Cookie * ck
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
    , Components::InvalidConnection
    , Components::CookieRequired
    , Components::NoConnection
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Receptacles_Proxy_Impl &proxy = 
    this->the_TAO_Receptacles_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.disconnect (
      this,
      name,
      ck
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::Components::ConnectionDescriptions * Components::Receptacles::get_connections (
    const char * name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Receptacles_Proxy_Impl &proxy = 
    this->the_TAO_Receptacles_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_connections (
      this,
      name
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::Components::ReceptacleDescriptions * Components::Receptacles::get_all_receptacles (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Receptacles_Proxy_Impl &proxy = 
    this->the_TAO_Receptacles_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_all_receptacles (
      this
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::Components::ReceptacleDescriptions * Components::Receptacles::get_named_receptacles (
    const Components::NameList & names
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Receptacles_Proxy_Impl &proxy = 
    this->the_TAO_Receptacles_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_named_receptacles (
      this,
      names
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_Receptacles[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  39,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f52), 
  ACE_NTOHL (0x65636570), 
  ACE_NTOHL (0x7461636c), 
  ACE_NTOHL (0x65733a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/Receptacles:1.0
  12,
  ACE_NTOHL (0x52656365), 
  ACE_NTOHL (0x70746163), 
  ACE_NTOHL (0x6c657300),  // name = Receptacles
};

static CORBA::TypeCode _tc_TAO_tc_Components_Receptacles (
    CORBA::tk_objref,
    sizeof (_oc_Components_Receptacles),
    (char *) &_oc_Components_Receptacles,
    0,
    sizeof (Components::Receptacles)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_Receptacles,
    &_tc_TAO_tc_Components_Receptacles
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_obv_cs.cpp:58

CORBA::Boolean
OBV_Components::Cookie::_tao_marshal__Components_Cookie (TAO_OutputCDR &strm)
{
  return _tao_marshal_state (strm);
}

CORBA::Boolean
OBV_Components::Cookie::_tao_unmarshal__Components_Cookie (TAO_InputCDR &strm)
{
  return _tao_unmarshal_state (strm);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/field_cs.cpp:744

// Accessor to set the member.
void
OBV_Components::Cookie::cookieValue (const CORBA::OctetSeq &val)
{
  this->_pd_cookieValue = val;
}

// Readonly get method.
const CORBA::OctetSeq &
OBV_Components::Cookie::cookieValue (void) const
{
  return this->_pd_cookieValue;
}

// Read/write get method.
CORBA::OctetSeq &
OBV_Components::Cookie::cookieValue (void)
{
  return this->_pd_cookieValue;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_obv_cs.cpp:58

CORBA::Boolean
OBV_Components::PortDescription::_tao_marshal__Components_PortDescription (TAO_OutputCDR &strm)
{
  return _tao_marshal_state (strm);
}

CORBA::Boolean
OBV_Components::PortDescription::_tao_unmarshal__Components_PortDescription (TAO_InputCDR &strm)
{
  return _tao_unmarshal_state (strm);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/field_cs.cpp:815

// Accessor to set the member.
void
OBV_Components::PortDescription::Name (char *val)
{
  this->_pd_Name = val;
}

// Accessor to set the member.
void
OBV_Components::PortDescription::Name (const char *val)
{
  // Set the value.
  this->_pd_Name = CORBA::string_dup (val);
}

// Accessor to set the member.
void
OBV_Components::PortDescription::Name (const CORBA::String_var &val)
{
  CORBA::String_var Name_var = val;
  this->_pd_Name = Name_var._retn ();
}

const char *
OBV_Components::PortDescription::Name (void) const // get method
{
  return this->_pd_Name;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/field_cs.cpp:815

// Accessor to set the member.
void
OBV_Components::PortDescription::type_id (char *val)
{
  this->_pd_type_id = val;
}

// Accessor to set the member.
void
OBV_Components::PortDescription::type_id (const char *val)
{
  // Set the value.
  this->_pd_type_id = CORBA::string_dup (val);
}

// Accessor to set the member.
void
OBV_Components::PortDescription::type_id (const CORBA::String_var &val)
{
  CORBA::String_var type_id_var = val;
  this->_pd_type_id = type_id_var._retn ();
}

const char *
OBV_Components::PortDescription::type_id (void) const // get method
{
  return this->_pd_type_id;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_obv_cs.cpp:58

CORBA::Boolean
OBV_Components::FacetDescription::_tao_marshal__Components_FacetDescription (TAO_OutputCDR &strm)
{
  return _tao_marshal_state (strm);
}

CORBA::Boolean
OBV_Components::FacetDescription::_tao_unmarshal__Components_FacetDescription (TAO_InputCDR &strm)
{
  return _tao_unmarshal_state (strm);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/field_cs.cpp:568

// Accessor to set the member.
void
OBV_Components::FacetDescription::facet_ref (CORBA::Object_ptr val)
{
  this->_pd_facet_ref = CORBA::Object::_duplicate (val);
}

// Retrieve the member
CORBA::Object_ptr
OBV_Components::FacetDescription::facet_ref (void) const
{
  return this->_pd_facet_ref;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_obv_cs.cpp:58

CORBA::Boolean
OBV_Components::ConnectionDescription::_tao_marshal__Components_ConnectionDescription (TAO_OutputCDR &strm)
{
  return _tao_marshal_state (strm);
}

CORBA::Boolean
OBV_Components::ConnectionDescription::_tao_unmarshal__Components_ConnectionDescription (TAO_InputCDR &strm)
{
  return _tao_unmarshal_state (strm);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/field_cs.cpp:431

// Accessor to set the member.
void
OBV_Components::ConnectionDescription::ck (Components::Cookie* val)
{
  CORBA::add_ref (val);
  this->_pd_ck = val;
}

// Retrieve the member
Components::Cookie *
OBV_Components::ConnectionDescription::ck () const
{
  return this->_pd_ck.ptr ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/field_cs.cpp:568

// Accessor to set the member.
void
OBV_Components::ConnectionDescription::objref (CORBA::Object_ptr val)
{
  this->_pd_objref = CORBA::Object::_duplicate (val);
}

// Retrieve the member
CORBA::Object_ptr
OBV_Components::ConnectionDescription::objref (void) const
{
  return this->_pd_objref;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_obv_cs.cpp:58

CORBA::Boolean
OBV_Components::ReceptacleDescription::_tao_marshal__Components_ReceptacleDescription (TAO_OutputCDR &strm)
{
  return _tao_marshal_state (strm);
}

CORBA::Boolean
OBV_Components::ReceptacleDescription::_tao_unmarshal__Components_ReceptacleDescription (TAO_InputCDR &strm)
{
  return _tao_unmarshal_state (strm);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/field_cs.cpp:568

// Accessor to set the member.
void
OBV_Components::ReceptacleDescription::is_multiple (CORBA::Boolean val)
{
  // Set the value.
  this->_pd_is_multiple = val;
}

// Retrieve the member
CORBA::Boolean
OBV_Components::ReceptacleDescription::is_multiple (void) const
{
  return this->_pd_is_multiple;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/field_cs.cpp:744

// Accessor to set the member.
void
OBV_Components::ReceptacleDescription::connections (const Components::ConnectionDescriptions &val)
{
  this->_pd_connections = val;
}

// Readonly get method.
const Components::ConnectionDescriptions &
OBV_Components::ReceptacleDescription::connections (void) const
{
  return this->_pd_connections;
}

// Read/write get method.
Components::ConnectionDescriptions &
OBV_Components::ReceptacleDescription::connections (void)
{
  return this->_pd_connections;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::NameList &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_NameList,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::NameList *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_NameList,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::NameList::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::NameList *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::NameList*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::NameList *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_NameList
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const Components::NameList*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        Components::NameList *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::NameList,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_NameList,
                1,
                ACE_static_cast (void *, tmp),
                Components::NameList::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/any_op_cs.cpp:56

// Copying.
void
operator<<= (
    CORBA::Any &any,
    Components::Cookie *value
  )
{
  TAO_OutputCDR stream;
  
  if (stream << value)
    {
      any._tao_replace (
          Components::_tc_Cookie, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying.
void
operator<<= (
    CORBA::Any &any,
    Components::Cookie **value
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *value)
    {
      any._tao_replace (
          Components::_tc_Cookie, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *value,
          Components::Cookie::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &any,
    Components::Cookie *&value
  )
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_Cookie
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (any.any_owns_data ())
      {
        const Components::Cookie *const_holder =
          ACE_static_cast (
              const Components::Cookie *,
              any.value ()
            );
        value =
          ACE_const_cast (
              Components::Cookie *,
              const_holder
            );
        return 1;
      }
    else
      {
        Components::Cookie *tmp;
        TAO_InputCDR stream (
            any._tao_get_cdr (),
            any._tao_byte_order ()
          );
        
        if (stream >> tmp)
          {
            ((CORBA::Any *)&any)->_tao_replace (
                Components::_tc_Cookie,
                1,
                ACE_static_cast (void *, tmp),
                Components::Cookie::_tao_any_destructor
              );
            value = tmp;
            return 1;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::Cookie, Components::Cookie_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::Cookie, Components::Cookie_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/any_op_cs.cpp:56

// Copying.
void
operator<<= (
    CORBA::Any &any,
    Components::PortDescription *value
  )
{
  TAO_OutputCDR stream;
  
  if (stream << value)
    {
      any._tao_replace (
          Components::_tc_PortDescription, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying.
void
operator<<= (
    CORBA::Any &any,
    Components::PortDescription **value
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *value)
    {
      any._tao_replace (
          Components::_tc_PortDescription, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *value,
          Components::PortDescription::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &any,
    Components::PortDescription *&value
  )
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_PortDescription
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (any.any_owns_data ())
      {
        const Components::PortDescription *const_holder =
          ACE_static_cast (
              const Components::PortDescription *,
              any.value ()
            );
        value =
          ACE_const_cast (
              Components::PortDescription *,
              const_holder
            );
        return 1;
      }
    else
      {
        Components::PortDescription *tmp;
        TAO_InputCDR stream (
            any._tao_get_cdr (),
            any._tao_byte_order ()
          );
        
        if (stream >> tmp)
          {
            ((CORBA::Any *)&any)->_tao_replace (
                Components::_tc_PortDescription,
                1,
                ACE_static_cast (void *, tmp),
                Components::PortDescription::_tao_any_destructor
              );
            value = tmp;
            return 1;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::PortDescription, Components::PortDescription_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::PortDescription, Components::PortDescription_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/any_op_cs.cpp:56

// Copying.
void
operator<<= (
    CORBA::Any &any,
    Components::FacetDescription *value
  )
{
  TAO_OutputCDR stream;
  
  if (stream << value)
    {
      any._tao_replace (
          Components::_tc_FacetDescription, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying.
void
operator<<= (
    CORBA::Any &any,
    Components::FacetDescription **value
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *value)
    {
      any._tao_replace (
          Components::_tc_FacetDescription, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *value,
          Components::FacetDescription::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &any,
    Components::FacetDescription *&value
  )
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_FacetDescription
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (any.any_owns_data ())
      {
        const Components::FacetDescription *const_holder =
          ACE_static_cast (
              const Components::FacetDescription *,
              any.value ()
            );
        value =
          ACE_const_cast (
              Components::FacetDescription *,
              const_holder
            );
        return 1;
      }
    else
      {
        Components::FacetDescription *tmp;
        TAO_InputCDR stream (
            any._tao_get_cdr (),
            any._tao_byte_order ()
          );
        
        if (stream >> tmp)
          {
            ((CORBA::Any *)&any)->_tao_replace (
                Components::_tc_FacetDescription,
                1,
                ACE_static_cast (void *, tmp),
                Components::FacetDescription::_tao_any_destructor
              );
            value = tmp;
            return 1;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::FacetDescription, Components::FacetDescription_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::FacetDescription, Components::FacetDescription_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::FacetDescriptions &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_FacetDescriptions,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::FacetDescriptions *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_FacetDescriptions,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::FacetDescriptions::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::FacetDescriptions *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::FacetDescriptions*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::FacetDescriptions *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_FacetDescriptions
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const Components::FacetDescriptions*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        Components::FacetDescriptions *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::FacetDescriptions,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_FacetDescriptions,
                1,
                ACE_static_cast (void *, tmp),
                Components::FacetDescriptions::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::InvalidName &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_InvalidName,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::InvalidName *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_InvalidName,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::InvalidName::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::InvalidName *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::InvalidName*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::InvalidName *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_InvalidName
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::InvalidName *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::InvalidName *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::InvalidName,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/InvalidName:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_InvalidName,
                1,
                tmp,
                Components::InvalidName::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::InvalidConnection &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_InvalidConnection,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::InvalidConnection *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_InvalidConnection,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::InvalidConnection::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::InvalidConnection *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::InvalidConnection*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::InvalidConnection *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_InvalidConnection
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::InvalidConnection *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::InvalidConnection *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::InvalidConnection,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/InvalidConnection:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_InvalidConnection,
                1,
                tmp,
                Components::InvalidConnection::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::ExceededConnectionLimit &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_ExceededConnectionLimit,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::ExceededConnectionLimit *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_ExceededConnectionLimit,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::ExceededConnectionLimit::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::ExceededConnectionLimit *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::ExceededConnectionLimit*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::ExceededConnectionLimit *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_ExceededConnectionLimit
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::ExceededConnectionLimit *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::ExceededConnectionLimit *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::ExceededConnectionLimit,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/ExceededConnectionLimit:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_ExceededConnectionLimit,
                1,
                tmp,
                Components::ExceededConnectionLimit::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::AlreadyConnected &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_AlreadyConnected,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::AlreadyConnected *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_AlreadyConnected,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::AlreadyConnected::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::AlreadyConnected *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::AlreadyConnected*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::AlreadyConnected *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_AlreadyConnected
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::AlreadyConnected *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::AlreadyConnected *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::AlreadyConnected,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/AlreadyConnected:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_AlreadyConnected,
                1,
                tmp,
                Components::AlreadyConnected::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::NoConnection &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_NoConnection,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::NoConnection *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_NoConnection,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::NoConnection::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::NoConnection *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::NoConnection*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::NoConnection *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_NoConnection
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::NoConnection *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::NoConnection *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::NoConnection,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/NoConnection:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_NoConnection,
                1,
                tmp,
                Components::NoConnection::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::CookieRequired &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_CookieRequired,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::CookieRequired *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_CookieRequired,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::CookieRequired::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::CookieRequired *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::CookieRequired*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::CookieRequired *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_CookieRequired
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::CookieRequired *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::CookieRequired *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::CookieRequired,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/CookieRequired:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_CookieRequired,
                1,
                tmp,
                Components::CookieRequired::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::CreateFailure &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_CreateFailure,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::CreateFailure *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_CreateFailure,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::CreateFailure::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::CreateFailure *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::CreateFailure*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::CreateFailure *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_CreateFailure
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::CreateFailure *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::CreateFailure *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::CreateFailure,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/CreateFailure:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_CreateFailure,
                1,
                tmp,
                Components::CreateFailure::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::FinderFailure &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_FinderFailure,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::FinderFailure *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_FinderFailure,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::FinderFailure::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::FinderFailure *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::FinderFailure*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::FinderFailure *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_FinderFailure
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::FinderFailure *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::FinderFailure *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::FinderFailure,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/FinderFailure:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_FinderFailure,
                1,
                tmp,
                Components::FinderFailure::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::RemoveFailure &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_RemoveFailure,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::RemoveFailure *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_RemoveFailure,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::RemoveFailure::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::RemoveFailure *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::RemoveFailure*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::RemoveFailure *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_RemoveFailure
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::RemoveFailure *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::RemoveFailure *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::RemoveFailure,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/RemoveFailure:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_RemoveFailure,
                1,
                tmp,
                Components::RemoveFailure::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::DuplicateKeyValue &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_DuplicateKeyValue,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::DuplicateKeyValue *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_DuplicateKeyValue,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::DuplicateKeyValue::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::DuplicateKeyValue *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::DuplicateKeyValue*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::DuplicateKeyValue *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_DuplicateKeyValue
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::DuplicateKeyValue *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::DuplicateKeyValue *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::DuplicateKeyValue,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/DuplicateKeyValue:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_DuplicateKeyValue,
                1,
                tmp,
                Components::DuplicateKeyValue::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::InvalidKey &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_InvalidKey,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::InvalidKey *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_InvalidKey,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::InvalidKey::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::InvalidKey *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::InvalidKey*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::InvalidKey *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_InvalidKey
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::InvalidKey *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::InvalidKey *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::InvalidKey,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/InvalidKey:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_InvalidKey,
                1,
                tmp,
                Components::InvalidKey::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::UnknownKeyValue &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_UnknownKeyValue,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::UnknownKeyValue *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_UnknownKeyValue,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::UnknownKeyValue::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::UnknownKeyValue *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::UnknownKeyValue*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::UnknownKeyValue *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_UnknownKeyValue
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::UnknownKeyValue *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::UnknownKeyValue *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::UnknownKeyValue,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/UnknownKeyValue:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_UnknownKeyValue,
                1,
                tmp,
                Components::UnknownKeyValue::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::NoKeyAvailable &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_NoKeyAvailable,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::NoKeyAvailable *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_NoKeyAvailable,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::NoKeyAvailable::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::NoKeyAvailable *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::NoKeyAvailable*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::NoKeyAvailable *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_NoKeyAvailable
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::NoKeyAvailable *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::NoKeyAvailable *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::NoKeyAvailable,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/NoKeyAvailable:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_NoKeyAvailable,
                1,
                tmp,
                Components::NoKeyAvailable::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::BadEventType &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_BadEventType,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::BadEventType *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_BadEventType,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::BadEventType::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::BadEventType *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::BadEventType*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::BadEventType *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_BadEventType
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::BadEventType *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::BadEventType *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::BadEventType,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/BadEventType:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_BadEventType,
                1,
                tmp,
                Components::BadEventType::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::HomeNotFound &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_HomeNotFound,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::HomeNotFound *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_HomeNotFound,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::HomeNotFound::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::HomeNotFound *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::HomeNotFound*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::HomeNotFound *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_HomeNotFound
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::HomeNotFound *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::HomeNotFound *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::HomeNotFound,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/HomeNotFound:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_HomeNotFound,
                1,
                tmp,
                Components::HomeNotFound::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::WrongComponentType &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_WrongComponentType,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::WrongComponentType *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_WrongComponentType,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::WrongComponentType::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::WrongComponentType *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::WrongComponentType*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::WrongComponentType *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_WrongComponentType
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::WrongComponentType *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::WrongComponentType *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::WrongComponentType,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/WrongComponentType:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_WrongComponentType,
                1,
                tmp,
                Components::WrongComponentType::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::InvalidConfiguration &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_InvalidConfiguration,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::InvalidConfiguration *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_InvalidConfiguration,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::InvalidConfiguration::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::InvalidConfiguration *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::InvalidConfiguration*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::InvalidConfiguration *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_InvalidConfiguration
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::InvalidConfiguration *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::InvalidConfiguration *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::InvalidConfiguration,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/InvalidConfiguration:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_InvalidConfiguration,
                1,
                tmp,
                Components::InvalidConfiguration::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::IllegalState &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_IllegalState,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::IllegalState *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_IllegalState,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::IllegalState::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::IllegalState *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::IllegalState*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::IllegalState *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_IllegalState
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::IllegalState *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::IllegalState *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::IllegalState,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/IllegalState:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_IllegalState,
                1,
                tmp,
                Components::IllegalState::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    Components::Navigation_ptr _tao_elem
  )
{
  Components::Navigation_ptr _tao_objptr =
    Components::Navigation::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    Components::Navigation_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_Navigation, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          Components::Navigation::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    Components::Navigation_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::Navigation::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_Navigation
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Components::_tc_Navigation,
            1,
            _tao_elem,
            Components::Navigation::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
    _tao_elem = Components::Navigation::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::Navigation::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::Navigation,Components::Navigation_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<Components::Navigation,Components::Navigation_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/any_op_cs.cpp:56

// Copying.
void
operator<<= (
    CORBA::Any &any,
    Components::ConnectionDescription *value
  )
{
  TAO_OutputCDR stream;
  
  if (stream << value)
    {
      any._tao_replace (
          Components::_tc_ConnectionDescription, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying.
void
operator<<= (
    CORBA::Any &any,
    Components::ConnectionDescription **value
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *value)
    {
      any._tao_replace (
          Components::_tc_ConnectionDescription, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *value,
          Components::ConnectionDescription::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &any,
    Components::ConnectionDescription *&value
  )
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_ConnectionDescription
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (any.any_owns_data ())
      {
        const Components::ConnectionDescription *const_holder =
          ACE_static_cast (
              const Components::ConnectionDescription *,
              any.value ()
            );
        value =
          ACE_const_cast (
              Components::ConnectionDescription *,
              const_holder
            );
        return 1;
      }
    else
      {
        Components::ConnectionDescription *tmp;
        TAO_InputCDR stream (
            any._tao_get_cdr (),
            any._tao_byte_order ()
          );
        
        if (stream >> tmp)
          {
            ((CORBA::Any *)&any)->_tao_replace (
                Components::_tc_ConnectionDescription,
                1,
                ACE_static_cast (void *, tmp),
                Components::ConnectionDescription::_tao_any_destructor
              );
            value = tmp;
            return 1;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::ConnectionDescription, Components::ConnectionDescription_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::ConnectionDescription, Components::ConnectionDescription_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::ConnectionDescriptions &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_ConnectionDescriptions,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::ConnectionDescriptions *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_ConnectionDescriptions,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::ConnectionDescriptions::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::ConnectionDescriptions *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::ConnectionDescriptions*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::ConnectionDescriptions *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_ConnectionDescriptions
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const Components::ConnectionDescriptions*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        Components::ConnectionDescriptions *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::ConnectionDescriptions,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_ConnectionDescriptions,
                1,
                ACE_static_cast (void *, tmp),
                Components::ConnectionDescriptions::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/any_op_cs.cpp:56

// Copying.
void
operator<<= (
    CORBA::Any &any,
    Components::ReceptacleDescription *value
  )
{
  TAO_OutputCDR stream;
  
  if (stream << value)
    {
      any._tao_replace (
          Components::_tc_ReceptacleDescription, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying.
void
operator<<= (
    CORBA::Any &any,
    Components::ReceptacleDescription **value
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *value)
    {
      any._tao_replace (
          Components::_tc_ReceptacleDescription, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *value,
          Components::ReceptacleDescription::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &any,
    Components::ReceptacleDescription *&value
  )
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_ReceptacleDescription
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (any.any_owns_data ())
      {
        const Components::ReceptacleDescription *const_holder =
          ACE_static_cast (
              const Components::ReceptacleDescription *,
              any.value ()
            );
        value =
          ACE_const_cast (
              Components::ReceptacleDescription *,
              const_holder
            );
        return 1;
      }
    else
      {
        Components::ReceptacleDescription *tmp;
        TAO_InputCDR stream (
            any._tao_get_cdr (),
            any._tao_byte_order ()
          );
        
        if (stream >> tmp)
          {
            ((CORBA::Any *)&any)->_tao_replace (
                Components::_tc_ReceptacleDescription,
                1,
                ACE_static_cast (void *, tmp),
                Components::ReceptacleDescription::_tao_any_destructor
              );
            value = tmp;
            return 1;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::ReceptacleDescription, Components::ReceptacleDescription_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::ReceptacleDescription, Components::ReceptacleDescription_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::ReceptacleDescriptions &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_ReceptacleDescriptions,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::ReceptacleDescriptions *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_ReceptacleDescriptions,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::ReceptacleDescriptions::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::ReceptacleDescriptions *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::ReceptacleDescriptions*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::ReceptacleDescriptions *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_ReceptacleDescriptions
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const Components::ReceptacleDescriptions*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        Components::ReceptacleDescriptions *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::ReceptacleDescriptions,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_ReceptacleDescriptions,
                1,
                ACE_static_cast (void *, tmp),
                Components::ReceptacleDescriptions::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    Components::Receptacles_ptr _tao_elem
  )
{
  Components::Receptacles_ptr _tao_objptr =
    Components::Receptacles::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    Components::Receptacles_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_Receptacles, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          Components::Receptacles::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    Components::Receptacles_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::Receptacles::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_Receptacles
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Components::_tc_Receptacles,
            1,
            _tao_elem,
            Components::Receptacles::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
    _tao_elem = Components::Receptacles::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::Receptacles::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::Receptacles,Components::Receptacles_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<Components::Receptacles,Components::Receptacles_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/cdr_op_cs.cpp:103

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::NameList &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i].in ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::NameList &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:740

void
CORBA::add_ref (Components::Cookie * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (Components::Cookie * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_cs.cpp:73

CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const Components::Cookie *_tao_valuetype
  )
{
  return
    CORBA_ValueBase::_tao_marshal (
        strm,
        ACE_const_cast (
            Components::Cookie *,
            _tao_valuetype
          ),
        (ptr_arith_t) &Components::Cookie::_downcast
      );
}

CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    Components::Cookie *&_tao_valuetype
  )
{
  return Components::Cookie::_tao_unmarshal (strm, _tao_valuetype);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/marshal_cs.cpp:44

CORBA::Boolean
OBV_Components::Cookie::_tao_marshal_state (TAO_OutputCDR &strm)
{
  if (
    (strm << _pd_cookieValue)
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

CORBA::Boolean
OBV_Components::Cookie::_tao_unmarshal_state (TAO_InputCDR &strm)
{
  if (
    (strm >> _pd_cookieValue)
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:740

void
CORBA::add_ref (Components::PortDescription * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (Components::PortDescription * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_cs.cpp:73

CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const Components::PortDescription *_tao_valuetype
  )
{
  return
    CORBA_ValueBase::_tao_marshal (
        strm,
        ACE_const_cast (
            Components::PortDescription *,
            _tao_valuetype
          ),
        (ptr_arith_t) &Components::PortDescription::_downcast
      );
}

CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    Components::PortDescription *&_tao_valuetype
  )
{
  return Components::PortDescription::_tao_unmarshal (strm, _tao_valuetype);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/marshal_cs.cpp:44

CORBA::Boolean
OBV_Components::PortDescription::_tao_marshal_state (TAO_OutputCDR &strm)
{
  if (
    (strm << _pd_Name.in ()) &&
    (strm << _pd_type_id.in ())
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

CORBA::Boolean
OBV_Components::PortDescription::_tao_unmarshal_state (TAO_InputCDR &strm)
{
  if (
    (strm >> _pd_Name.out ()) &&
    (strm >> _pd_type_id.out ())
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:740

void
CORBA::add_ref (Components::FacetDescription * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (Components::FacetDescription * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_cs.cpp:73

CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const Components::FacetDescription *_tao_valuetype
  )
{
  return
    CORBA_ValueBase::_tao_marshal (
        strm,
        ACE_const_cast (
            Components::FacetDescription *,
            _tao_valuetype
          ),
        (ptr_arith_t) &Components::FacetDescription::_downcast
      );
}

CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    Components::FacetDescription *&_tao_valuetype
  )
{
  return Components::FacetDescription::_tao_unmarshal (strm, _tao_valuetype);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/marshal_cs.cpp:44

CORBA::Boolean
OBV_Components::FacetDescription::_tao_marshal_state (TAO_OutputCDR &strm)
{
  if (! this->_tao_marshal__Components_PortDescription (strm))
    {
      return 0;
    }
  
  if (
    (strm << _pd_facet_ref.in ())
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

CORBA::Boolean
OBV_Components::FacetDescription::_tao_unmarshal_state (TAO_InputCDR &strm)
{
  if (! this->_tao_unmarshal__Components_PortDescription (strm))
    {
      return 0;
    }
  
  if (
    (strm >> _pd_facet_ref.out ())
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/cdr_op_cs.cpp:103

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::FacetDescriptions &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i].in ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::FacetDescriptions &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::Navigation_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::Navigation_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      Components::Navigation::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:740

void
CORBA::add_ref (Components::ConnectionDescription * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (Components::ConnectionDescription * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_cs.cpp:73

CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const Components::ConnectionDescription *_tao_valuetype
  )
{
  return
    CORBA_ValueBase::_tao_marshal (
        strm,
        ACE_const_cast (
            Components::ConnectionDescription *,
            _tao_valuetype
          ),
        (ptr_arith_t) &Components::ConnectionDescription::_downcast
      );
}

CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    Components::ConnectionDescription *&_tao_valuetype
  )
{
  return Components::ConnectionDescription::_tao_unmarshal (strm, _tao_valuetype);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/marshal_cs.cpp:44

CORBA::Boolean
OBV_Components::ConnectionDescription::_tao_marshal_state (TAO_OutputCDR &strm)
{
  if (
    (strm << _pd_ck.in ()) &&
    (strm << _pd_objref.in ())
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

CORBA::Boolean
OBV_Components::ConnectionDescription::_tao_unmarshal_state (TAO_InputCDR &strm)
{
  if (
    (strm >> _pd_ck.out ()) &&
    (strm >> _pd_objref.out ())
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/cdr_op_cs.cpp:103

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::ConnectionDescriptions &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i].in ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::ConnectionDescriptions &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:740

void
CORBA::add_ref (Components::ReceptacleDescription * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (Components::ReceptacleDescription * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_cs.cpp:73

CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const Components::ReceptacleDescription *_tao_valuetype
  )
{
  return
    CORBA_ValueBase::_tao_marshal (
        strm,
        ACE_const_cast (
            Components::ReceptacleDescription *,
            _tao_valuetype
          ),
        (ptr_arith_t) &Components::ReceptacleDescription::_downcast
      );
}

CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    Components::ReceptacleDescription *&_tao_valuetype
  )
{
  return Components::ReceptacleDescription::_tao_unmarshal (strm, _tao_valuetype);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/marshal_cs.cpp:44

CORBA::Boolean
OBV_Components::ReceptacleDescription::_tao_marshal_state (TAO_OutputCDR &strm)
{
  if (! this->_tao_marshal__Components_PortDescription (strm))
    {
      return 0;
    }
  
  if (
    (strm << CORBA::Any::from_boolean (_pd_is_multiple)) &&
    (strm << _pd_connections)
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

CORBA::Boolean
OBV_Components::ReceptacleDescription::_tao_unmarshal_state (TAO_InputCDR &strm)
{
  if (! this->_tao_unmarshal__Components_PortDescription (strm))
    {
      return 0;
    }
  
  if (
    (strm >> CORBA::Any::to_boolean (_pd_is_multiple)) &&
    (strm >> _pd_connections)
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/cdr_op_cs.cpp:103

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::ReceptacleDescriptions &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i].in ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::ReceptacleDescriptions &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::Receptacles_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::Receptacles_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      Components::Receptacles::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

