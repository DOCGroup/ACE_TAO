// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#ifndef _TAO_IDL_COMPONENT_BASES_CPP_
#define _TAO_IDL_COMPONENT_BASES_CPP_

#include "Component_BaseS.h"

#include "tao/PortableServer/Object_Adapter.h"
#include "tao/PortableServer/Operation_Table.h"
#include "tao/TAO_Server_Request.h"
#include "tao/ORB_Core.h"
#include "tao/Stub.h"
#include "tao/IFR_Client_Adapter.h"
#include "tao/PortableInterceptor.h"

#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#include "tao/PICurrent.h"
#include "tao/PortableServer/ServerRequestInfo.h"
#include "tao/PortableServer/ServerInterceptorAdapter.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */

#include "ace/Dynamic_Service.h"
#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "Component_BaseS.i"
#endif /* !defined INLINE */

class TAO_Components_Navigation_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:56:14 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_Components_Navigation_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_Components_Navigation_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22,  0,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22,  0,
     22, 22, 22,  5, 22,  5, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22,  5, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22,  0,  0, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22,
#else
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22,  0, 22,  0, 22, 22,
     22,  5, 22,  5, 22, 22, 22, 22, 22, 22,
     22, 22,  5, 22, 22,  0,  0, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_Components_Navigation_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 8,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 16,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 21,
      HASH_VALUE_RANGE = 17,
      DUPLICATES = 0,
      WORDLIST_SIZE = 13
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_Components::Navigation::_is_a_skel},
      {"",0},{"",0},{"",0},{"",0},
      {"_component",  &POA_Components::Navigation::_component_skel},
      {"",0},{"",0},
      {"_non_existent",  &POA_Components::Navigation::_non_existent_skel},
      {"same_component", 	&POA_Components::Navigation::same_component_skel},
      {"_interface",  &POA_Components::Navigation::_interface_skel},
      {"",0},{"",0},
      {"provide_facet", 	&POA_Components::Navigation::provide_facet_skel},
      {"get_all_facets", 	&POA_Components::Navigation::get_all_facets_skel},
      {"",0},
      {"get_named_facets", 	&POA_Components::Navigation::get_named_facets_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 22:56:14 */
static TAO_Components_Navigation_Perfect_Hash_OpTable tao_Components_Navigation_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_Components_Navigation_provide_facet : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Navigation_provide_facet (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Navigation *tao_impl
    ,
    const char * name);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (CORBA::Object_ptr result);

  private:
    TAO_ServerRequestInfo_Components_Navigation_provide_facet (const TAO_ServerRequestInfo_Components_Navigation_provide_facet &);
    void operator= (const TAO_ServerRequestInfo_Components_Navigation_provide_facet &);
    
  private:
    POA_Components::Navigation *_tao_impl;
    const char * name_;
    CORBA::Object_ptr _result;
  };
  
    TAO_ServerRequestInfo_Components_Navigation_provide_facet::TAO_ServerRequestInfo_Components_Navigation_provide_facet (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Navigation *tao_impl,
      const char * name
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        name_ (name)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Navigation_provide_facet::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (1);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<= name_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Navigation_provide_facet::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Navigation_provide_facet_exceptiondata[] = 
  {
    Components::_tc_InvalidName
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Navigation_provide_facet_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Navigation_provide_facet::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_Navigation_provide_facet::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Navigation_provide_facet::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_Navigation_provide_facet::result (CORBA::Object_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_Navigation_get_all_facets : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Navigation_get_all_facets (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Navigation *tao_impl
    );

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::FacetDescriptions * result);

  private:
    TAO_ServerRequestInfo_Components_Navigation_get_all_facets (const TAO_ServerRequestInfo_Components_Navigation_get_all_facets &);
    void operator= (const TAO_ServerRequestInfo_Components_Navigation_get_all_facets &);
    
  private:
    POA_Components::Navigation *_tao_impl;
    ::Components::FacetDescriptions * _result;
  };
  
    TAO_ServerRequestInfo_Components_Navigation_get_all_facets::TAO_ServerRequestInfo_Components_Navigation_get_all_facets (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Navigation *tao_impl
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Navigation_get_all_facets::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return parameter_list;
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Navigation_get_all_facets::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Navigation_get_all_facets::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_Navigation_get_all_facets::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Navigation_get_all_facets::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_Navigation_get_all_facets::result (::Components::FacetDescriptions * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_Navigation_get_named_facets : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Navigation_get_named_facets (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Navigation *tao_impl
    ,
    const Components::NameList & names);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::FacetDescriptions * result);

  private:
    TAO_ServerRequestInfo_Components_Navigation_get_named_facets (const TAO_ServerRequestInfo_Components_Navigation_get_named_facets &);
    void operator= (const TAO_ServerRequestInfo_Components_Navigation_get_named_facets &);
    
  private:
    POA_Components::Navigation *_tao_impl;
    const Components::NameList & names_;
    ::Components::FacetDescriptions * _result;
  };
  
    TAO_ServerRequestInfo_Components_Navigation_get_named_facets::TAO_ServerRequestInfo_Components_Navigation_get_named_facets (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Navigation *tao_impl,
      const Components::NameList & names
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        names_ (names)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Navigation_get_named_facets::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (1);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<=  this->names_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Navigation_get_named_facets::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Navigation_get_named_facets_exceptiondata[] = 
  {
    Components::_tc_InvalidName
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Navigation_get_named_facets_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Navigation_get_named_facets::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_Navigation_get_named_facets::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Navigation_get_named_facets::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_Navigation_get_named_facets::result (::Components::FacetDescriptions * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_Navigation_same_component : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Navigation_same_component (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Navigation *tao_impl
    ,
    CORBA::Object_ptr object_ref);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (CORBA::Boolean result);

  private:
    TAO_ServerRequestInfo_Components_Navigation_same_component (const TAO_ServerRequestInfo_Components_Navigation_same_component &);
    void operator= (const TAO_ServerRequestInfo_Components_Navigation_same_component &);
    
  private:
    POA_Components::Navigation *_tao_impl;
    CORBA::Object_ptr object_ref_;
    CORBA::Boolean _result;
  };
  
    TAO_ServerRequestInfo_Components_Navigation_same_component::TAO_ServerRequestInfo_Components_Navigation_same_component (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Navigation *tao_impl,
      CORBA::Object_ptr object_ref
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        object_ref_ (object_ref)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Navigation_same_component::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (1);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<= object_ref_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Navigation_same_component::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Navigation_same_component::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_Navigation_same_component::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Navigation_same_component::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_Navigation_same_component::result (CORBA::Boolean result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_Components::_TAO_Navigation_Strategized_Proxy_Broker *POA_Components::_TAO_Navigation_Strategized_Proxy_Broker::the_TAO_Navigation_Strategized_Proxy_Broker (void)
{
  static POA_Components::_TAO_Navigation_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_Components::_TAO_Navigation_Strategized_Proxy_Broker::_TAO_Navigation_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_Components::_TAO_Navigation_Strategized_Proxy_Broker::~_TAO_Navigation_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    {
      delete this->proxy_cache_[i];
      
      // Hack to prevent bug mentioned in 1204. Refer to 1204
      // for details..
      this->proxy_cache_[i] = 0;
    }
  
}

Components::_TAO_Navigation_Proxy_Impl&
POA_Components::_TAO_Navigation_Strategized_Proxy_Broker::select_proxy (
    ::Components::Navigation *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
    ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_Components::_TAO_Navigation_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_Components::_TAO_Navigation_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::Components::_TAO_Navigation_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


Components::_TAO_Navigation_Proxy_Broker *
Components__TAO_Navigation_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_Components::_TAO_Navigation_Strategized_Proxy_Broker::the_TAO_Navigation_Strategized_Proxy_Broker();
}

int
Components__TAO_Navigation_Proxy_Broker_Factory_Initializer (long)
{
  Components__TAO_Navigation_Proxy_Broker_Factory_function_pointer = 
    Components__TAO_Navigation_Proxy_Broker_Factory_function;
  
  return 0;
}

static int Components__TAO_Navigation_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  Components__TAO_Navigation_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, Components__TAO_Navigation_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_Components::_TAO_Navigation_ThruPOA_Proxy_Impl::_TAO_Navigation_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::Object_ptr POA_Components::_TAO_Navigation_ThruPOA_Proxy_Impl::provide_facet (
    CORBA_Object *_collocated_tao_target_,
    const char * name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "provide_facet",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::Navigation_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Navigation:1.0"
        )
    )->provide_facet (
        name
      );
}

::Components::FacetDescriptions * POA_Components::_TAO_Navigation_ThruPOA_Proxy_Impl::get_all_facets (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "get_all_facets",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::Navigation_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Navigation:1.0"
        )
    )->get_all_facets (
        
      );
}

::Components::FacetDescriptions * POA_Components::_TAO_Navigation_ThruPOA_Proxy_Impl::get_named_facets (
    CORBA_Object *_collocated_tao_target_,
    const Components::NameList & names
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "get_named_facets",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::Navigation_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Navigation:1.0"
        )
    )->get_named_facets (
        names
      );
}

CORBA::Boolean POA_Components::_TAO_Navigation_ThruPOA_Proxy_Impl::same_component (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Object_ptr object_ref
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "same_component",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::Navigation_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Navigation:1.0"
        )
    )->same_component (
        object_ref
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ss.cpp:100
POA_Components::Navigation::Navigation (void)
{
  this->optable_ = &tao_Components_Navigation_optable;
}

POA_Components::Navigation::Navigation (const Navigation& rhs)
  :  TAO_ServantBase (rhs)
{}

POA_Components::Navigation::~Navigation (void)
{
}

void POA_Components::Navigation::provide_facet_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Navigation *_tao_impl =
    ACE_static_cast (
        POA_Components::Navigation *,
        _tao_servant
      );
  CORBA::Object_var _tao_retval;
  CORBA::String_var name;
  if (!(
    (_tao_in >> name.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Navigation_provide_facet _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      name.in ()
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->provide_facet (
                name.in ()
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          CORBA::Object_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Navigation::get_all_facets_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Navigation *_tao_impl =
    ACE_static_cast (
        POA_Components::Navigation *,
        _tao_servant
      );
  ::Components::FacetDescriptions_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Navigation_get_all_facets _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->get_all_facets (
                
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::FacetDescriptions * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Navigation::get_named_facets_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Navigation *_tao_impl =
    ACE_static_cast (
        POA_Components::Navigation *,
        _tao_servant
      );
  ::Components::FacetDescriptions_var _tao_retval;
  Components::NameList names;
  if (!(
    (_tao_in >> names)
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Navigation_get_named_facets _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      names
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->get_named_facets (
                names
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::FacetDescriptions * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Navigation::same_component_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Navigation *_tao_impl =
    ACE_static_cast (
        POA_Components::Navigation *,
        _tao_servant
      );
  CORBA::Boolean _tao_retval = 0;
  CORBA::Object_var object_ref;
  if (!(
    (_tao_in >> object_ref.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Navigation_same_component _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      object_ref.in ()
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->same_component (
                object_ref.in ()
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          CORBA::Boolean _tao_retval_info = _tao_retval;
          _tao_ri.result (_tao_retval_info);
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << CORBA::Any::from_boolean (_tao_retval))
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Navigation::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Navigation *_tao_impl = (POA_Components::Navigation *) _tao_servant;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::Navigation::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Navigation *_tao_impl = (POA_Components::Navigation *) _tao_servant;
  CORBA::Boolean _tao_retval =
    _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::Navigation::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Navigation *_tao_impl = (POA_Components::Navigation *) _tao_servant;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = 
        _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_Components::Navigation::_component_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Navigation *_tao_impl = (POA_Components::Navigation *) _tao_object_reference;
  CORBA::Object_var _tao_retval =
    _tao_impl->_get_component (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << _tao_retval._retn ()))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_Components::Navigation::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  const char *base_id = "IDL:org.omg/CORBA/Object:1.0";
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/Navigation:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_Components::Navigation::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/Components/Navigation:1.0") == 0)
    return ACE_static_cast (POA_Components::Navigation_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_Components::Navigation::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/Navigation:1.0";
}

void POA_Components::Navigation::_dispatch (
    TAO_ServerRequest &req,
    void *servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


Components::Navigation*
POA_Components::Navigation::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  
  (void) safe_stub.release ();
  
  return ::Components::Navigation::_unchecked_narrow (obj.in ());
}


class TAO_Components_Receptacles_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:56:14 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_Components_Receptacles_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_Components_Receptacles_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26,  0,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26,  0,
     26,  0, 10, 15, 26,  0, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26,  0,  0, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26,
#else
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26,  0, 26,  0, 26,  0,
     10, 15, 26,  0, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26,  0,  0, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_Components_Receptacles_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 9,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 21,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 25,
      HASH_VALUE_RANGE = 21,
      DUPLICATES = 0,
      WORDLIST_SIZE = 14
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_Components::Receptacles::_is_a_skel},
      {"",0},
      {"connect", 	&POA_Components::Receptacles::connect_skel},
      {"",0},{"",0},
      {"_component",  &POA_Components::Receptacles::_component_skel},
      {"",0},{"",0},
      {"_non_existent",  &POA_Components::Receptacles::_non_existent_skel},
      {"",0},
      {"get_connections", 	&POA_Components::Receptacles::get_connections_skel},
      {"",0},{"",0},{"",0},
      {"get_all_receptacles", 	&POA_Components::Receptacles::get_all_receptacles_skel},
      {"disconnect", 	&POA_Components::Receptacles::disconnect_skel},
      {"get_named_receptacles", 	&POA_Components::Receptacles::get_named_receptacles_skel},
      {"",0},{"",0},{"",0},
      {"_interface",  &POA_Components::Receptacles::_interface_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 22:56:14 */
static TAO_Components_Receptacles_Perfect_Hash_OpTable tao_Components_Receptacles_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_Components_Receptacles_connect : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Receptacles_connect (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Receptacles *tao_impl
    ,
    const char * name,
    CORBA::Object_ptr connection);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::Cookie * result);

  private:
    TAO_ServerRequestInfo_Components_Receptacles_connect (const TAO_ServerRequestInfo_Components_Receptacles_connect &);
    void operator= (const TAO_ServerRequestInfo_Components_Receptacles_connect &);
    
  private:
    POA_Components::Receptacles *_tao_impl;
    const char * name_;
    CORBA::Object_ptr connection_;
    ::Components::Cookie * _result;
  };
  
    TAO_ServerRequestInfo_Components_Receptacles_connect::TAO_ServerRequestInfo_Components_Receptacles_connect (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Receptacles *tao_impl,
      const char * name,
      CORBA::Object_ptr connection
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        name_ (name),
        connection_ (connection)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Receptacles_connect::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (2);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<= name_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
        (*parameter_list)[len].argument <<= connection_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Receptacles_connect::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Receptacles_connect_exceptiondata[] = 
  {
    Components::_tc_InvalidName,
    Components::_tc_InvalidConnection,
    Components::_tc_AlreadyConnected,
    Components::_tc_ExceededConnectionLimit
  };
  
  exception_list->length (4);
  for (CORBA::ULong i = 0; i < 4; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Receptacles_connect_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Receptacles_connect::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_Receptacles_connect::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Receptacles_connect::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_Receptacles_connect::result (::Components::Cookie * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_Receptacles_disconnect : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Receptacles_disconnect (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Receptacles *tao_impl
    ,
    const char * name,
    Components::Cookie * ck);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    
  private:
    TAO_ServerRequestInfo_Components_Receptacles_disconnect (const TAO_ServerRequestInfo_Components_Receptacles_disconnect &);
    void operator= (const TAO_ServerRequestInfo_Components_Receptacles_disconnect &);
    
  private:
    POA_Components::Receptacles *_tao_impl;
    const char * name_;
    Components::Cookie * ck_;
    
  };
  
    TAO_ServerRequestInfo_Components_Receptacles_disconnect::TAO_ServerRequestInfo_Components_Receptacles_disconnect (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Receptacles *tao_impl,
      const char * name,
      Components::Cookie * ck
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        name_ (name),
        ck_ (ck)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Receptacles_disconnect::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (1);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<= name_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
        
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Receptacles_disconnect::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Receptacles_disconnect_exceptiondata[] = 
  {
    Components::_tc_InvalidName,
    Components::_tc_InvalidConnection,
    Components::_tc_CookieRequired,
    Components::_tc_NoConnection
  };
  
  exception_list->length (4);
  for (CORBA::ULong i = 0; i < 4; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Receptacles_disconnect_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Receptacles_disconnect::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_Components_Receptacles_disconnect::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Receptacles_disconnect::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_Components_Receptacles_get_connections : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Receptacles_get_connections (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Receptacles *tao_impl
    ,
    const char * name);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::ConnectionDescriptions * result);

  private:
    TAO_ServerRequestInfo_Components_Receptacles_get_connections (const TAO_ServerRequestInfo_Components_Receptacles_get_connections &);
    void operator= (const TAO_ServerRequestInfo_Components_Receptacles_get_connections &);
    
  private:
    POA_Components::Receptacles *_tao_impl;
    const char * name_;
    ::Components::ConnectionDescriptions * _result;
  };
  
    TAO_ServerRequestInfo_Components_Receptacles_get_connections::TAO_ServerRequestInfo_Components_Receptacles_get_connections (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Receptacles *tao_impl,
      const char * name
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        name_ (name)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Receptacles_get_connections::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (1);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<= name_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Receptacles_get_connections::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Receptacles_get_connections_exceptiondata[] = 
  {
    Components::_tc_InvalidName
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Receptacles_get_connections_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Receptacles_get_connections::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_Receptacles_get_connections::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Receptacles_get_connections::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_Receptacles_get_connections::result (::Components::ConnectionDescriptions * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_Receptacles_get_all_receptacles : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Receptacles_get_all_receptacles (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Receptacles *tao_impl
    );

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::ReceptacleDescriptions * result);

  private:
    TAO_ServerRequestInfo_Components_Receptacles_get_all_receptacles (const TAO_ServerRequestInfo_Components_Receptacles_get_all_receptacles &);
    void operator= (const TAO_ServerRequestInfo_Components_Receptacles_get_all_receptacles &);
    
  private:
    POA_Components::Receptacles *_tao_impl;
    ::Components::ReceptacleDescriptions * _result;
  };
  
    TAO_ServerRequestInfo_Components_Receptacles_get_all_receptacles::TAO_ServerRequestInfo_Components_Receptacles_get_all_receptacles (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Receptacles *tao_impl
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Receptacles_get_all_receptacles::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return parameter_list;
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Receptacles_get_all_receptacles::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Receptacles_get_all_receptacles::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_Receptacles_get_all_receptacles::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Receptacles_get_all_receptacles::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_Receptacles_get_all_receptacles::result (::Components::ReceptacleDescriptions * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_Receptacles_get_named_receptacles : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Receptacles_get_named_receptacles (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Receptacles *tao_impl
    ,
    const Components::NameList & names);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::ReceptacleDescriptions * result);

  private:
    TAO_ServerRequestInfo_Components_Receptacles_get_named_receptacles (const TAO_ServerRequestInfo_Components_Receptacles_get_named_receptacles &);
    void operator= (const TAO_ServerRequestInfo_Components_Receptacles_get_named_receptacles &);
    
  private:
    POA_Components::Receptacles *_tao_impl;
    const Components::NameList & names_;
    ::Components::ReceptacleDescriptions * _result;
  };
  
    TAO_ServerRequestInfo_Components_Receptacles_get_named_receptacles::TAO_ServerRequestInfo_Components_Receptacles_get_named_receptacles (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Receptacles *tao_impl,
      const Components::NameList & names
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        names_ (names)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Receptacles_get_named_receptacles::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (1);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<=  this->names_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Receptacles_get_named_receptacles::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Receptacles_get_named_receptacles_exceptiondata[] = 
  {
    Components::_tc_InvalidName
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Receptacles_get_named_receptacles_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Receptacles_get_named_receptacles::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_Receptacles_get_named_receptacles::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Receptacles_get_named_receptacles::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_Receptacles_get_named_receptacles::result (::Components::ReceptacleDescriptions * result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_Components::_TAO_Receptacles_Strategized_Proxy_Broker *POA_Components::_TAO_Receptacles_Strategized_Proxy_Broker::the_TAO_Receptacles_Strategized_Proxy_Broker (void)
{
  static POA_Components::_TAO_Receptacles_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_Components::_TAO_Receptacles_Strategized_Proxy_Broker::_TAO_Receptacles_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_Components::_TAO_Receptacles_Strategized_Proxy_Broker::~_TAO_Receptacles_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    {
      delete this->proxy_cache_[i];
      
      // Hack to prevent bug mentioned in 1204. Refer to 1204
      // for details..
      this->proxy_cache_[i] = 0;
    }
  
}

Components::_TAO_Receptacles_Proxy_Impl&
POA_Components::_TAO_Receptacles_Strategized_Proxy_Broker::select_proxy (
    ::Components::Receptacles *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
    ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_Components::_TAO_Receptacles_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_Components::_TAO_Receptacles_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::Components::_TAO_Receptacles_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


Components::_TAO_Receptacles_Proxy_Broker *
Components__TAO_Receptacles_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_Components::_TAO_Receptacles_Strategized_Proxy_Broker::the_TAO_Receptacles_Strategized_Proxy_Broker();
}

int
Components__TAO_Receptacles_Proxy_Broker_Factory_Initializer (long)
{
  Components__TAO_Receptacles_Proxy_Broker_Factory_function_pointer = 
    Components__TAO_Receptacles_Proxy_Broker_Factory_function;
  
  return 0;
}

static int Components__TAO_Receptacles_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  Components__TAO_Receptacles_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, Components__TAO_Receptacles_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_Components::_TAO_Receptacles_ThruPOA_Proxy_Impl::_TAO_Receptacles_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

::Components::Cookie * POA_Components::_TAO_Receptacles_ThruPOA_Proxy_Impl::connect (
    CORBA_Object *_collocated_tao_target_,
    const char * name,
    CORBA::Object_ptr connection
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
    , Components::InvalidConnection
    , Components::AlreadyConnected
    , Components::ExceededConnectionLimit
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "connect",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::Receptacles_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Receptacles:1.0"
        )
    )->connect (
        name,
        connection
      );
}

void POA_Components::_TAO_Receptacles_ThruPOA_Proxy_Impl::disconnect (
    CORBA_Object *_collocated_tao_target_,
    const char * name,
    Components::Cookie * ck
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
    , Components::InvalidConnection
    , Components::CookieRequired
    , Components::NoConnection
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "disconnect",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  ACE_reinterpret_cast (
      POA_Components::Receptacles_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Receptacles:1.0"
        )
    )->disconnect (
        name,
        ck
      );
  return;
}

::Components::ConnectionDescriptions * POA_Components::_TAO_Receptacles_ThruPOA_Proxy_Impl::get_connections (
    CORBA_Object *_collocated_tao_target_,
    const char * name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "get_connections",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::Receptacles_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Receptacles:1.0"
        )
    )->get_connections (
        name
      );
}

::Components::ReceptacleDescriptions * POA_Components::_TAO_Receptacles_ThruPOA_Proxy_Impl::get_all_receptacles (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "get_all_receptacles",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::Receptacles_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Receptacles:1.0"
        )
    )->get_all_receptacles (
        
      );
}

::Components::ReceptacleDescriptions * POA_Components::_TAO_Receptacles_ThruPOA_Proxy_Impl::get_named_receptacles (
    CORBA_Object *_collocated_tao_target_,
    const Components::NameList & names
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "get_named_receptacles",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::Receptacles_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Receptacles:1.0"
        )
    )->get_named_receptacles (
        names
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ss.cpp:100
POA_Components::Receptacles::Receptacles (void)
{
  this->optable_ = &tao_Components_Receptacles_optable;
}

POA_Components::Receptacles::Receptacles (const Receptacles& rhs)
  :  TAO_ServantBase (rhs)
{}

POA_Components::Receptacles::~Receptacles (void)
{
}

void POA_Components::Receptacles::connect_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Receptacles *_tao_impl =
    ACE_static_cast (
        POA_Components::Receptacles *,
        _tao_servant
      );
  ::Components::Cookie_var _tao_retval;
  CORBA::String_var name;
  CORBA::Object_var connection;
  if (!(
    (_tao_in >> name.out ()) &&
    (_tao_in >> connection.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Receptacles_connect _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      name.in (),
      connection.in ()
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->connect (
                name.in (),
                connection.in ()
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::Cookie * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Receptacles::disconnect_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Receptacles *_tao_impl =
    ACE_static_cast (
        POA_Components::Receptacles *,
        _tao_servant
      );
  _tao_server_request.argument_flag (0);
    CORBA::String_var name;
  Components::Cookie_var ck;
  if (!(
    (_tao_in >> name.out ()) &&
    (_tao_in >> ck.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Receptacles_disconnect _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      name.in (),
      ck.in ()
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            
            _tao_impl->disconnect (
                name.in (),
                ck.in ()
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Receptacles::get_connections_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Receptacles *_tao_impl =
    ACE_static_cast (
        POA_Components::Receptacles *,
        _tao_servant
      );
  ::Components::ConnectionDescriptions_var _tao_retval;
  CORBA::String_var name;
  if (!(
    (_tao_in >> name.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Receptacles_get_connections _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      name.in ()
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->get_connections (
                name.in ()
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::ConnectionDescriptions * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Receptacles::get_all_receptacles_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Receptacles *_tao_impl =
    ACE_static_cast (
        POA_Components::Receptacles *,
        _tao_servant
      );
  ::Components::ReceptacleDescriptions_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Receptacles_get_all_receptacles _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->get_all_receptacles (
                
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::ReceptacleDescriptions * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Receptacles::get_named_receptacles_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Receptacles *_tao_impl =
    ACE_static_cast (
        POA_Components::Receptacles *,
        _tao_servant
      );
  ::Components::ReceptacleDescriptions_var _tao_retval;
  Components::NameList names;
  if (!(
    (_tao_in >> names)
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Receptacles_get_named_receptacles _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      names
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->get_named_receptacles (
                names
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::ReceptacleDescriptions * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Receptacles::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Receptacles *_tao_impl = (POA_Components::Receptacles *) _tao_servant;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::Receptacles::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Receptacles *_tao_impl = (POA_Components::Receptacles *) _tao_servant;
  CORBA::Boolean _tao_retval =
    _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::Receptacles::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Receptacles *_tao_impl = (POA_Components::Receptacles *) _tao_servant;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = 
        _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_Components::Receptacles::_component_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Receptacles *_tao_impl = (POA_Components::Receptacles *) _tao_object_reference;
  CORBA::Object_var _tao_retval =
    _tao_impl->_get_component (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << _tao_retval._retn ()))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_Components::Receptacles::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  const char *base_id = "IDL:org.omg/CORBA/Object:1.0";
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/Receptacles:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_Components::Receptacles::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/Components/Receptacles:1.0") == 0)
    return ACE_static_cast (POA_Components::Receptacles_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_Components::Receptacles::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/Receptacles:1.0";
}

void POA_Components::Receptacles::_dispatch (
    TAO_ServerRequest &req,
    void *servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


Components::Receptacles*
POA_Components::Receptacles::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  
  (void) safe_stub.release ();
  
  return ::Components::Receptacles::_unchecked_narrow (obj.in ());
}


class TAO_Components_EventConsumerBase_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:56:14 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_Components_EventConsumerBase_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_Components_EventConsumerBase_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16,  0,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16,  0,
     16, 16, 16,  5, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16,  2, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16,  0, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16,
#else
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16,  0, 16,  0, 16, 16,
     16,  5, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16,  2, 16, 16, 16,  0, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_Components_EventConsumerBase_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 5,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 15,
      HASH_VALUE_RANGE = 11,
      DUPLICATES = 0,
      WORDLIST_SIZE = 10
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_Components::EventConsumerBase::_is_a_skel},
      {"",0},{"",0},{"",0},{"",0},
      {"_component",  &POA_Components::EventConsumerBase::_component_skel},
      {"",0},
      {"push_event", 	&POA_Components::EventConsumerBase::push_event_skel},
      {"_non_existent",  &POA_Components::EventConsumerBase::_non_existent_skel},
      {"",0},
      {"_interface",  &POA_Components::EventConsumerBase::_interface_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 22:56:14 */
static TAO_Components_EventConsumerBase_Perfect_Hash_OpTable tao_Components_EventConsumerBase_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_Components_EventConsumerBase_push_event : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_EventConsumerBase_push_event (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::EventConsumerBase *tao_impl
    ,
    Components::EventBase * evt);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    
  private:
    TAO_ServerRequestInfo_Components_EventConsumerBase_push_event (const TAO_ServerRequestInfo_Components_EventConsumerBase_push_event &);
    void operator= (const TAO_ServerRequestInfo_Components_EventConsumerBase_push_event &);
    
  private:
    POA_Components::EventConsumerBase *_tao_impl;
    Components::EventBase * evt_;
    
  };
  
    TAO_ServerRequestInfo_Components_EventConsumerBase_push_event::TAO_ServerRequestInfo_Components_EventConsumerBase_push_event (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::EventConsumerBase *tao_impl,
      Components::EventBase * evt
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        evt_ (evt)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_EventConsumerBase_push_event::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return parameter_list;
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_EventConsumerBase_push_event::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_EventConsumerBase_push_event_exceptiondata[] = 
  {
    Components::_tc_BadEventType
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_EventConsumerBase_push_event_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_EventConsumerBase_push_event::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_Components_EventConsumerBase_push_event::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_EventConsumerBase_push_event::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_Components::_TAO_EventConsumerBase_Strategized_Proxy_Broker *POA_Components::_TAO_EventConsumerBase_Strategized_Proxy_Broker::the_TAO_EventConsumerBase_Strategized_Proxy_Broker (void)
{
  static POA_Components::_TAO_EventConsumerBase_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_Components::_TAO_EventConsumerBase_Strategized_Proxy_Broker::_TAO_EventConsumerBase_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_Components::_TAO_EventConsumerBase_Strategized_Proxy_Broker::~_TAO_EventConsumerBase_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    {
      delete this->proxy_cache_[i];
      
      // Hack to prevent bug mentioned in 1204. Refer to 1204
      // for details..
      this->proxy_cache_[i] = 0;
    }
  
}

Components::_TAO_EventConsumerBase_Proxy_Impl&
POA_Components::_TAO_EventConsumerBase_Strategized_Proxy_Broker::select_proxy (
    ::Components::EventConsumerBase *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
    ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_Components::_TAO_EventConsumerBase_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_Components::_TAO_EventConsumerBase_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::Components::_TAO_EventConsumerBase_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


Components::_TAO_EventConsumerBase_Proxy_Broker *
Components__TAO_EventConsumerBase_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_Components::_TAO_EventConsumerBase_Strategized_Proxy_Broker::the_TAO_EventConsumerBase_Strategized_Proxy_Broker();
}

int
Components__TAO_EventConsumerBase_Proxy_Broker_Factory_Initializer (long)
{
  Components__TAO_EventConsumerBase_Proxy_Broker_Factory_function_pointer = 
    Components__TAO_EventConsumerBase_Proxy_Broker_Factory_function;
  
  return 0;
}

static int Components__TAO_EventConsumerBase_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  Components__TAO_EventConsumerBase_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, Components__TAO_EventConsumerBase_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_Components::_TAO_EventConsumerBase_ThruPOA_Proxy_Impl::_TAO_EventConsumerBase_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

void POA_Components::_TAO_EventConsumerBase_ThruPOA_Proxy_Impl::push_event (
    CORBA_Object *_collocated_tao_target_,
    Components::EventBase * evt
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::BadEventType
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "push_event",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  ACE_reinterpret_cast (
      POA_Components::EventConsumerBase_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/EventConsumerBase:1.0"
        )
    )->push_event (
        evt
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ss.cpp:100
POA_Components::EventConsumerBase::EventConsumerBase (void)
{
  this->optable_ = &tao_Components_EventConsumerBase_optable;
}

POA_Components::EventConsumerBase::EventConsumerBase (const EventConsumerBase& rhs)
  :  TAO_ServantBase (rhs)
{}

POA_Components::EventConsumerBase::~EventConsumerBase (void)
{
}

void POA_Components::EventConsumerBase::push_event_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::EventConsumerBase *_tao_impl =
    ACE_static_cast (
        POA_Components::EventConsumerBase *,
        _tao_servant
      );
  _tao_server_request.argument_flag (0);
    Components::EventBase_var evt;
  if (!(
    (_tao_in >> evt.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_EventConsumerBase_push_event _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      evt.in ()
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            
            _tao_impl->push_event (
                evt.in ()
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::EventConsumerBase::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::EventConsumerBase *_tao_impl = (POA_Components::EventConsumerBase *) _tao_servant;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::EventConsumerBase::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::EventConsumerBase *_tao_impl = (POA_Components::EventConsumerBase *) _tao_servant;
  CORBA::Boolean _tao_retval =
    _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::EventConsumerBase::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::EventConsumerBase *_tao_impl = (POA_Components::EventConsumerBase *) _tao_servant;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = 
        _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_Components::EventConsumerBase::_component_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::EventConsumerBase *_tao_impl = (POA_Components::EventConsumerBase *) _tao_object_reference;
  CORBA::Object_var _tao_retval =
    _tao_impl->_get_component (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << _tao_retval._retn ()))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_Components::EventConsumerBase::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  const char *base_id = "IDL:org.omg/CORBA/Object:1.0";
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/EventConsumerBase:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_Components::EventConsumerBase::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/Components/EventConsumerBase:1.0") == 0)
    return ACE_static_cast (POA_Components::EventConsumerBase_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_Components::EventConsumerBase::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/EventConsumerBase:1.0";
}

void POA_Components::EventConsumerBase::_dispatch (
    TAO_ServerRequest &req,
    void *servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


Components::EventConsumerBase*
POA_Components::EventConsumerBase::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  
  (void) safe_stub.release ();
  
  return ::Components::EventConsumerBase::_unchecked_narrow (obj.in ());
}


class TAO_Components_Events_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:56:14 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_Components_Events_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_Components_Events_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29,  0,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29,  0,
     29,  5,  5,  0, 29,  0, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29,  0, 29, 29, 29, 29, 29, 29,
     29, 29,  0, 15,  0, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29,
#else
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29,  0, 29,  0, 29,  5,
      5,  0, 29,  0, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29,  0,  0, 15,  0, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_Components_Events_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 15,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 20,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 28,
      HASH_VALUE_RANGE = 24,
      DUPLICATES = 2,
      WORDLIST_SIZE = 20
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_Components::Events::_is_a_skel},
      {"subscribe", 	&POA_Components::Events::subscribe_skel},
      {"_interface",  &POA_Components::Events::_interface_skel},
      {"unsubscribe", 	&POA_Components::Events::unsubscribe_skel},
      {"get_consumer", 	&POA_Components::Events::get_consumer_skel},
      {"get_all_emitters", 	&POA_Components::Events::get_all_emitters_skel},
      {"get_all_consumers", 	&POA_Components::Events::get_all_consumers_skel},
      {"get_named_emitters", 	&POA_Components::Events::get_named_emitters_skel},
      {"get_all_publishers", 	&POA_Components::Events::get_all_publishers_skel},
      {"get_named_consumers", 	&POA_Components::Events::get_named_consumers_skel},
      {"get_named_publishers", 	&POA_Components::Events::get_named_publishers_skel},
      {"connect_consumer", 	&POA_Components::Events::connect_consumer_skel},
      {"disconnect_consumer", 	&POA_Components::Events::disconnect_consumer_skel},
      {"_component",  &POA_Components::Events::_component_skel},
      {"_non_existent",  &POA_Components::Events::_non_existent_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,   5,  -1,  -1,  -1,   6,   7,   8,   9,  -1, 
      -12,  -2,  10,  11, -32,  14,  15,  16,  -1,  -1,  17,  18,  -1,  -1, 
       19, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:56:14 */
static TAO_Components_Events_Perfect_Hash_OpTable tao_Components_Events_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_Components_Events_get_consumer : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Events_get_consumer (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Events *tao_impl
    ,
    const char * sink_name);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::EventConsumerBase_ptr result);

  private:
    TAO_ServerRequestInfo_Components_Events_get_consumer (const TAO_ServerRequestInfo_Components_Events_get_consumer &);
    void operator= (const TAO_ServerRequestInfo_Components_Events_get_consumer &);
    
  private:
    POA_Components::Events *_tao_impl;
    const char * sink_name_;
    ::Components::EventConsumerBase_ptr _result;
  };
  
    TAO_ServerRequestInfo_Components_Events_get_consumer::TAO_ServerRequestInfo_Components_Events_get_consumer (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Events *tao_impl,
      const char * sink_name
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        sink_name_ (sink_name)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Events_get_consumer::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (1);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<= sink_name_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Events_get_consumer::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Events_get_consumer_exceptiondata[] = 
  {
    Components::_tc_InvalidName
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Events_get_consumer_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Events_get_consumer::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_Events_get_consumer::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Events_get_consumer::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_Events_get_consumer::result (::Components::EventConsumerBase_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_Events_subscribe : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Events_subscribe (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Events *tao_impl
    ,
    const char * publisher_name,
    Components::EventConsumerBase_ptr subscriber);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::Cookie * result);

  private:
    TAO_ServerRequestInfo_Components_Events_subscribe (const TAO_ServerRequestInfo_Components_Events_subscribe &);
    void operator= (const TAO_ServerRequestInfo_Components_Events_subscribe &);
    
  private:
    POA_Components::Events *_tao_impl;
    const char * publisher_name_;
    Components::EventConsumerBase_ptr subscriber_;
    ::Components::Cookie * _result;
  };
  
    TAO_ServerRequestInfo_Components_Events_subscribe::TAO_ServerRequestInfo_Components_Events_subscribe (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Events *tao_impl,
      const char * publisher_name,
      Components::EventConsumerBase_ptr subscriber
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        publisher_name_ (publisher_name),
        subscriber_ (subscriber)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Events_subscribe::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (2);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<= publisher_name_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
        (*parameter_list)[len].argument <<=  this->subscriber_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Events_subscribe::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Events_subscribe_exceptiondata[] = 
  {
    Components::_tc_InvalidName,
    Components::_tc_AlreadyConnected,
    Components::_tc_InvalidConnection
  };
  
  exception_list->length (3);
  for (CORBA::ULong i = 0; i < 3; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Events_subscribe_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Events_subscribe::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_Events_subscribe::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Events_subscribe::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_Events_subscribe::result (::Components::Cookie * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_Events_unsubscribe : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Events_unsubscribe (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Events *tao_impl
    ,
    const char * publisher_name,
    Components::Cookie * ck);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    
  private:
    TAO_ServerRequestInfo_Components_Events_unsubscribe (const TAO_ServerRequestInfo_Components_Events_unsubscribe &);
    void operator= (const TAO_ServerRequestInfo_Components_Events_unsubscribe &);
    
  private:
    POA_Components::Events *_tao_impl;
    const char * publisher_name_;
    Components::Cookie * ck_;
    
  };
  
    TAO_ServerRequestInfo_Components_Events_unsubscribe::TAO_ServerRequestInfo_Components_Events_unsubscribe (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Events *tao_impl,
      const char * publisher_name,
      Components::Cookie * ck
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        publisher_name_ (publisher_name),
        ck_ (ck)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Events_unsubscribe::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (1);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<= publisher_name_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
        
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Events_unsubscribe::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Events_unsubscribe_exceptiondata[] = 
  {
    Components::_tc_InvalidName,
    Components::_tc_InvalidConnection
  };
  
  exception_list->length (2);
  for (CORBA::ULong i = 0; i < 2; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Events_unsubscribe_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Events_unsubscribe::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_Components_Events_unsubscribe::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Events_unsubscribe::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_Components_Events_connect_consumer : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Events_connect_consumer (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Events *tao_impl
    ,
    const char * emitter_name,
    Components::EventConsumerBase_ptr consumer);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    
  private:
    TAO_ServerRequestInfo_Components_Events_connect_consumer (const TAO_ServerRequestInfo_Components_Events_connect_consumer &);
    void operator= (const TAO_ServerRequestInfo_Components_Events_connect_consumer &);
    
  private:
    POA_Components::Events *_tao_impl;
    const char * emitter_name_;
    Components::EventConsumerBase_ptr consumer_;
    
  };
  
    TAO_ServerRequestInfo_Components_Events_connect_consumer::TAO_ServerRequestInfo_Components_Events_connect_consumer (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Events *tao_impl,
      const char * emitter_name,
      Components::EventConsumerBase_ptr consumer
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        emitter_name_ (emitter_name),
        consumer_ (consumer)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Events_connect_consumer::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (2);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<= emitter_name_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
        (*parameter_list)[len].argument <<=  this->consumer_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Events_connect_consumer::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Events_connect_consumer_exceptiondata[] = 
  {
    Components::_tc_InvalidName,
    Components::_tc_AlreadyConnected,
    Components::_tc_InvalidConnection
  };
  
  exception_list->length (3);
  for (CORBA::ULong i = 0; i < 3; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Events_connect_consumer_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Events_connect_consumer::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_Components_Events_connect_consumer::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Events_connect_consumer::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_Components_Events_disconnect_consumer : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Events_disconnect_consumer (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Events *tao_impl
    ,
    const char * source_name);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::EventConsumerBase_ptr result);

  private:
    TAO_ServerRequestInfo_Components_Events_disconnect_consumer (const TAO_ServerRequestInfo_Components_Events_disconnect_consumer &);
    void operator= (const TAO_ServerRequestInfo_Components_Events_disconnect_consumer &);
    
  private:
    POA_Components::Events *_tao_impl;
    const char * source_name_;
    ::Components::EventConsumerBase_ptr _result;
  };
  
    TAO_ServerRequestInfo_Components_Events_disconnect_consumer::TAO_ServerRequestInfo_Components_Events_disconnect_consumer (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Events *tao_impl,
      const char * source_name
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        source_name_ (source_name)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Events_disconnect_consumer::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (1);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<= source_name_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Events_disconnect_consumer::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Events_disconnect_consumer_exceptiondata[] = 
  {
    Components::_tc_InvalidName,
    Components::_tc_NoConnection
  };
  
  exception_list->length (2);
  for (CORBA::ULong i = 0; i < 2; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Events_disconnect_consumer_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Events_disconnect_consumer::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_Events_disconnect_consumer::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Events_disconnect_consumer::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_Events_disconnect_consumer::result (::Components::EventConsumerBase_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_Events_get_all_consumers : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Events_get_all_consumers (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Events *tao_impl
    );

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::ConsumerDescriptions * result);

  private:
    TAO_ServerRequestInfo_Components_Events_get_all_consumers (const TAO_ServerRequestInfo_Components_Events_get_all_consumers &);
    void operator= (const TAO_ServerRequestInfo_Components_Events_get_all_consumers &);
    
  private:
    POA_Components::Events *_tao_impl;
    ::Components::ConsumerDescriptions * _result;
  };
  
    TAO_ServerRequestInfo_Components_Events_get_all_consumers::TAO_ServerRequestInfo_Components_Events_get_all_consumers (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Events *tao_impl
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Events_get_all_consumers::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return parameter_list;
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Events_get_all_consumers::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Events_get_all_consumers::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_Events_get_all_consumers::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Events_get_all_consumers::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_Events_get_all_consumers::result (::Components::ConsumerDescriptions * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_Events_get_named_consumers : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Events_get_named_consumers (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Events *tao_impl
    ,
    const Components::NameList & names);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::ConsumerDescriptions * result);

  private:
    TAO_ServerRequestInfo_Components_Events_get_named_consumers (const TAO_ServerRequestInfo_Components_Events_get_named_consumers &);
    void operator= (const TAO_ServerRequestInfo_Components_Events_get_named_consumers &);
    
  private:
    POA_Components::Events *_tao_impl;
    const Components::NameList & names_;
    ::Components::ConsumerDescriptions * _result;
  };
  
    TAO_ServerRequestInfo_Components_Events_get_named_consumers::TAO_ServerRequestInfo_Components_Events_get_named_consumers (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Events *tao_impl,
      const Components::NameList & names
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        names_ (names)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Events_get_named_consumers::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (1);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<=  this->names_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Events_get_named_consumers::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Events_get_named_consumers_exceptiondata[] = 
  {
    Components::_tc_InvalidName
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Events_get_named_consumers_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Events_get_named_consumers::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_Events_get_named_consumers::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Events_get_named_consumers::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_Events_get_named_consumers::result (::Components::ConsumerDescriptions * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_Events_get_all_emitters : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Events_get_all_emitters (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Events *tao_impl
    );

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::EmitterDescriptions * result);

  private:
    TAO_ServerRequestInfo_Components_Events_get_all_emitters (const TAO_ServerRequestInfo_Components_Events_get_all_emitters &);
    void operator= (const TAO_ServerRequestInfo_Components_Events_get_all_emitters &);
    
  private:
    POA_Components::Events *_tao_impl;
    ::Components::EmitterDescriptions * _result;
  };
  
    TAO_ServerRequestInfo_Components_Events_get_all_emitters::TAO_ServerRequestInfo_Components_Events_get_all_emitters (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Events *tao_impl
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Events_get_all_emitters::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return parameter_list;
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Events_get_all_emitters::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Events_get_all_emitters::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_Events_get_all_emitters::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Events_get_all_emitters::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_Events_get_all_emitters::result (::Components::EmitterDescriptions * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_Events_get_named_emitters : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Events_get_named_emitters (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Events *tao_impl
    ,
    const Components::NameList & names);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::EmitterDescriptions * result);

  private:
    TAO_ServerRequestInfo_Components_Events_get_named_emitters (const TAO_ServerRequestInfo_Components_Events_get_named_emitters &);
    void operator= (const TAO_ServerRequestInfo_Components_Events_get_named_emitters &);
    
  private:
    POA_Components::Events *_tao_impl;
    const Components::NameList & names_;
    ::Components::EmitterDescriptions * _result;
  };
  
    TAO_ServerRequestInfo_Components_Events_get_named_emitters::TAO_ServerRequestInfo_Components_Events_get_named_emitters (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Events *tao_impl,
      const Components::NameList & names
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        names_ (names)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Events_get_named_emitters::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (1);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<=  this->names_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Events_get_named_emitters::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Events_get_named_emitters_exceptiondata[] = 
  {
    Components::_tc_InvalidName
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Events_get_named_emitters_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Events_get_named_emitters::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_Events_get_named_emitters::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Events_get_named_emitters::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_Events_get_named_emitters::result (::Components::EmitterDescriptions * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_Events_get_all_publishers : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Events_get_all_publishers (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Events *tao_impl
    );

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::PublisherDescriptions * result);

  private:
    TAO_ServerRequestInfo_Components_Events_get_all_publishers (const TAO_ServerRequestInfo_Components_Events_get_all_publishers &);
    void operator= (const TAO_ServerRequestInfo_Components_Events_get_all_publishers &);
    
  private:
    POA_Components::Events *_tao_impl;
    ::Components::PublisherDescriptions * _result;
  };
  
    TAO_ServerRequestInfo_Components_Events_get_all_publishers::TAO_ServerRequestInfo_Components_Events_get_all_publishers (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Events *tao_impl
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Events_get_all_publishers::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return parameter_list;
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Events_get_all_publishers::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Events_get_all_publishers::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_Events_get_all_publishers::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Events_get_all_publishers::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_Events_get_all_publishers::result (::Components::PublisherDescriptions * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_Events_get_named_publishers : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Events_get_named_publishers (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Events *tao_impl
    ,
    const Components::NameList & names);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::PublisherDescriptions * result);

  private:
    TAO_ServerRequestInfo_Components_Events_get_named_publishers (const TAO_ServerRequestInfo_Components_Events_get_named_publishers &);
    void operator= (const TAO_ServerRequestInfo_Components_Events_get_named_publishers &);
    
  private:
    POA_Components::Events *_tao_impl;
    const Components::NameList & names_;
    ::Components::PublisherDescriptions * _result;
  };
  
    TAO_ServerRequestInfo_Components_Events_get_named_publishers::TAO_ServerRequestInfo_Components_Events_get_named_publishers (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Events *tao_impl,
      const Components::NameList & names
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        names_ (names)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Events_get_named_publishers::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (1);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<=  this->names_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Events_get_named_publishers::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Events_get_named_publishers_exceptiondata[] = 
  {
    Components::_tc_InvalidName
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Events_get_named_publishers_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Events_get_named_publishers::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_Events_get_named_publishers::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Events_get_named_publishers::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_Events_get_named_publishers::result (::Components::PublisherDescriptions * result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_Components::_TAO_Events_Strategized_Proxy_Broker *POA_Components::_TAO_Events_Strategized_Proxy_Broker::the_TAO_Events_Strategized_Proxy_Broker (void)
{
  static POA_Components::_TAO_Events_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_Components::_TAO_Events_Strategized_Proxy_Broker::_TAO_Events_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_Components::_TAO_Events_Strategized_Proxy_Broker::~_TAO_Events_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    {
      delete this->proxy_cache_[i];
      
      // Hack to prevent bug mentioned in 1204. Refer to 1204
      // for details..
      this->proxy_cache_[i] = 0;
    }
  
}

Components::_TAO_Events_Proxy_Impl&
POA_Components::_TAO_Events_Strategized_Proxy_Broker::select_proxy (
    ::Components::Events *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
    ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_Components::_TAO_Events_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_Components::_TAO_Events_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::Components::_TAO_Events_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


Components::_TAO_Events_Proxy_Broker *
Components__TAO_Events_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_Components::_TAO_Events_Strategized_Proxy_Broker::the_TAO_Events_Strategized_Proxy_Broker();
}

int
Components__TAO_Events_Proxy_Broker_Factory_Initializer (long)
{
  Components__TAO_Events_Proxy_Broker_Factory_function_pointer = 
    Components__TAO_Events_Proxy_Broker_Factory_function;
  
  return 0;
}

static int Components__TAO_Events_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  Components__TAO_Events_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, Components__TAO_Events_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_Components::_TAO_Events_ThruPOA_Proxy_Impl::_TAO_Events_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

::Components::EventConsumerBase_ptr POA_Components::_TAO_Events_ThruPOA_Proxy_Impl::get_consumer (
    CORBA_Object *_collocated_tao_target_,
    const char * sink_name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "get_consumer",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::Events_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Events:1.0"
        )
    )->get_consumer (
        sink_name
      );
}

::Components::Cookie * POA_Components::_TAO_Events_ThruPOA_Proxy_Impl::subscribe (
    CORBA_Object *_collocated_tao_target_,
    const char * publisher_name,
    Components::EventConsumerBase_ptr subscriber
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
    , Components::AlreadyConnected
    , Components::InvalidConnection
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "subscribe",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::Events_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Events:1.0"
        )
    )->subscribe (
        publisher_name,
        subscriber
      );
}

void POA_Components::_TAO_Events_ThruPOA_Proxy_Impl::unsubscribe (
    CORBA_Object *_collocated_tao_target_,
    const char * publisher_name,
    Components::Cookie * ck
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
    , Components::InvalidConnection
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "unsubscribe",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  ACE_reinterpret_cast (
      POA_Components::Events_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Events:1.0"
        )
    )->unsubscribe (
        publisher_name,
        ck
      );
  return;
}

void POA_Components::_TAO_Events_ThruPOA_Proxy_Impl::connect_consumer (
    CORBA_Object *_collocated_tao_target_,
    const char * emitter_name,
    Components::EventConsumerBase_ptr consumer
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
    , Components::AlreadyConnected
    , Components::InvalidConnection
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "connect_consumer",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  ACE_reinterpret_cast (
      POA_Components::Events_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Events:1.0"
        )
    )->connect_consumer (
        emitter_name,
        consumer
      );
  return;
}

::Components::EventConsumerBase_ptr POA_Components::_TAO_Events_ThruPOA_Proxy_Impl::disconnect_consumer (
    CORBA_Object *_collocated_tao_target_,
    const char * source_name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
    , Components::NoConnection
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "disconnect_consumer",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::Events_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Events:1.0"
        )
    )->disconnect_consumer (
        source_name
      );
}

::Components::ConsumerDescriptions * POA_Components::_TAO_Events_ThruPOA_Proxy_Impl::get_all_consumers (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "get_all_consumers",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::Events_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Events:1.0"
        )
    )->get_all_consumers (
        
      );
}

::Components::ConsumerDescriptions * POA_Components::_TAO_Events_ThruPOA_Proxy_Impl::get_named_consumers (
    CORBA_Object *_collocated_tao_target_,
    const Components::NameList & names
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "get_named_consumers",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::Events_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Events:1.0"
        )
    )->get_named_consumers (
        names
      );
}

::Components::EmitterDescriptions * POA_Components::_TAO_Events_ThruPOA_Proxy_Impl::get_all_emitters (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "get_all_emitters",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::Events_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Events:1.0"
        )
    )->get_all_emitters (
        
      );
}

::Components::EmitterDescriptions * POA_Components::_TAO_Events_ThruPOA_Proxy_Impl::get_named_emitters (
    CORBA_Object *_collocated_tao_target_,
    const Components::NameList & names
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "get_named_emitters",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::Events_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Events:1.0"
        )
    )->get_named_emitters (
        names
      );
}

::Components::PublisherDescriptions * POA_Components::_TAO_Events_ThruPOA_Proxy_Impl::get_all_publishers (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "get_all_publishers",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::Events_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Events:1.0"
        )
    )->get_all_publishers (
        
      );
}

::Components::PublisherDescriptions * POA_Components::_TAO_Events_ThruPOA_Proxy_Impl::get_named_publishers (
    CORBA_Object *_collocated_tao_target_,
    const Components::NameList & names
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "get_named_publishers",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::Events_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Events:1.0"
        )
    )->get_named_publishers (
        names
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ss.cpp:100
POA_Components::Events::Events (void)
{
  this->optable_ = &tao_Components_Events_optable;
}

POA_Components::Events::Events (const Events& rhs)
  :  TAO_ServantBase (rhs)
{}

POA_Components::Events::~Events (void)
{
}

void POA_Components::Events::get_consumer_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Events *_tao_impl =
    ACE_static_cast (
        POA_Components::Events *,
        _tao_servant
      );
  ::Components::EventConsumerBase_var _tao_retval;
  CORBA::String_var sink_name;
  if (!(
    (_tao_in >> sink_name.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Events_get_consumer _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      sink_name.in ()
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->get_consumer (
                sink_name.in ()
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::EventConsumerBase_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Events::subscribe_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Events *_tao_impl =
    ACE_static_cast (
        POA_Components::Events *,
        _tao_servant
      );
  ::Components::Cookie_var _tao_retval;
  CORBA::String_var publisher_name;
  Components::EventConsumerBase_var subscriber;
  if (!(
    (_tao_in >> publisher_name.out ()) &&
    (_tao_in >> subscriber.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Events_subscribe _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      publisher_name.in (),
      subscriber.in ()
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->subscribe (
                publisher_name.in (),
                subscriber.in ()
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::Cookie * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Events::unsubscribe_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Events *_tao_impl =
    ACE_static_cast (
        POA_Components::Events *,
        _tao_servant
      );
  _tao_server_request.argument_flag (0);
    CORBA::String_var publisher_name;
  Components::Cookie_var ck;
  if (!(
    (_tao_in >> publisher_name.out ()) &&
    (_tao_in >> ck.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Events_unsubscribe _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      publisher_name.in (),
      ck.in ()
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            
            _tao_impl->unsubscribe (
                publisher_name.in (),
                ck.in ()
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Events::connect_consumer_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Events *_tao_impl =
    ACE_static_cast (
        POA_Components::Events *,
        _tao_servant
      );
  _tao_server_request.argument_flag (0);
    CORBA::String_var emitter_name;
  Components::EventConsumerBase_var consumer;
  if (!(
    (_tao_in >> emitter_name.out ()) &&
    (_tao_in >> consumer.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Events_connect_consumer _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      emitter_name.in (),
      consumer.in ()
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            
            _tao_impl->connect_consumer (
                emitter_name.in (),
                consumer.in ()
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Events::disconnect_consumer_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Events *_tao_impl =
    ACE_static_cast (
        POA_Components::Events *,
        _tao_servant
      );
  ::Components::EventConsumerBase_var _tao_retval;
  CORBA::String_var source_name;
  if (!(
    (_tao_in >> source_name.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Events_disconnect_consumer _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      source_name.in ()
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->disconnect_consumer (
                source_name.in ()
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::EventConsumerBase_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Events::get_all_consumers_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Events *_tao_impl =
    ACE_static_cast (
        POA_Components::Events *,
        _tao_servant
      );
  ::Components::ConsumerDescriptions_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Events_get_all_consumers _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->get_all_consumers (
                
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::ConsumerDescriptions * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Events::get_named_consumers_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Events *_tao_impl =
    ACE_static_cast (
        POA_Components::Events *,
        _tao_servant
      );
  ::Components::ConsumerDescriptions_var _tao_retval;
  Components::NameList names;
  if (!(
    (_tao_in >> names)
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Events_get_named_consumers _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      names
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->get_named_consumers (
                names
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::ConsumerDescriptions * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Events::get_all_emitters_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Events *_tao_impl =
    ACE_static_cast (
        POA_Components::Events *,
        _tao_servant
      );
  ::Components::EmitterDescriptions_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Events_get_all_emitters _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->get_all_emitters (
                
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::EmitterDescriptions * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Events::get_named_emitters_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Events *_tao_impl =
    ACE_static_cast (
        POA_Components::Events *,
        _tao_servant
      );
  ::Components::EmitterDescriptions_var _tao_retval;
  Components::NameList names;
  if (!(
    (_tao_in >> names)
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Events_get_named_emitters _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      names
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->get_named_emitters (
                names
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::EmitterDescriptions * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Events::get_all_publishers_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Events *_tao_impl =
    ACE_static_cast (
        POA_Components::Events *,
        _tao_servant
      );
  ::Components::PublisherDescriptions_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Events_get_all_publishers _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->get_all_publishers (
                
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::PublisherDescriptions * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Events::get_named_publishers_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Events *_tao_impl =
    ACE_static_cast (
        POA_Components::Events *,
        _tao_servant
      );
  ::Components::PublisherDescriptions_var _tao_retval;
  Components::NameList names;
  if (!(
    (_tao_in >> names)
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Events_get_named_publishers _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      names
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->get_named_publishers (
                names
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::PublisherDescriptions * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Events::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Events *_tao_impl = (POA_Components::Events *) _tao_servant;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::Events::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Events *_tao_impl = (POA_Components::Events *) _tao_servant;
  CORBA::Boolean _tao_retval =
    _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::Events::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Events *_tao_impl = (POA_Components::Events *) _tao_servant;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = 
        _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_Components::Events::_component_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Events *_tao_impl = (POA_Components::Events *) _tao_object_reference;
  CORBA::Object_var _tao_retval =
    _tao_impl->_get_component (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << _tao_retval._retn ()))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_Components::Events::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  const char *base_id = "IDL:org.omg/CORBA/Object:1.0";
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/Events:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_Components::Events::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/Components/Events:1.0") == 0)
    return ACE_static_cast (POA_Components::Events_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_Components::Events::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/Events:1.0";
}

void POA_Components::Events::_dispatch (
    TAO_ServerRequest &req,
    void *servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


Components::Events*
POA_Components::Events::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  
  (void) safe_stub.release ();
  
  return ::Components::Events::_unchecked_narrow (obj.in ());
}


class TAO_Components_CCMHome_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:56:14 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_Components_CCMHome_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_Components_CCMHome_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18,  0,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18,  0,
     18, 18, 18,  5,  0,  0, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18,  0, 18, 18, 18, 18, 18, 18,
     18, 18, 18,  0, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18,
#else
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18,  0, 18,  0, 18, 18,
     18,  5,  0,  0, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18,  0, 18,  0, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_Components_CCMHome_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 7,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 17,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 17,
      HASH_VALUE_RANGE = 13,
      DUPLICATES = 0,
      WORDLIST_SIZE = 12
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_Components::CCMHome::_is_a_skel},
      {"",0},{"",0},{"",0},{"",0},
      {"_component",  &POA_Components::CCMHome::_component_skel},
      {"",0},
      {"get_home_def", 	&POA_Components::CCMHome::get_home_def_skel},
      {"_non_existent",  &POA_Components::CCMHome::_non_existent_skel},
      {"",0},
      {"_interface",  &POA_Components::CCMHome::_interface_skel},
      {"remove_component", 	&POA_Components::CCMHome::remove_component_skel},
      {"get_component_def", 	&POA_Components::CCMHome::get_component_def_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 22:56:14 */
static TAO_Components_CCMHome_Perfect_Hash_OpTable tao_Components_CCMHome_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_Components_CCMHome_get_component_def : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_CCMHome_get_component_def (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::CCMHome *tao_impl
    );

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::IRObject_ptr result);

  private:
    TAO_ServerRequestInfo_Components_CCMHome_get_component_def (const TAO_ServerRequestInfo_Components_CCMHome_get_component_def &);
    void operator= (const TAO_ServerRequestInfo_Components_CCMHome_get_component_def &);
    
  private:
    POA_Components::CCMHome *_tao_impl;
    ::CORBA::IRObject_ptr _result;
  };
  
    TAO_ServerRequestInfo_Components_CCMHome_get_component_def::TAO_ServerRequestInfo_Components_CCMHome_get_component_def (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::CCMHome *tao_impl
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_CCMHome_get_component_def::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return parameter_list;
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_CCMHome_get_component_def::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_CCMHome_get_component_def::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_CCMHome_get_component_def::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_CCMHome_get_component_def::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_CCMHome_get_component_def::result (::CORBA::IRObject_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_CCMHome_get_home_def : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_CCMHome_get_home_def (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::CCMHome *tao_impl
    );

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::IRObject_ptr result);

  private:
    TAO_ServerRequestInfo_Components_CCMHome_get_home_def (const TAO_ServerRequestInfo_Components_CCMHome_get_home_def &);
    void operator= (const TAO_ServerRequestInfo_Components_CCMHome_get_home_def &);
    
  private:
    POA_Components::CCMHome *_tao_impl;
    ::CORBA::IRObject_ptr _result;
  };
  
    TAO_ServerRequestInfo_Components_CCMHome_get_home_def::TAO_ServerRequestInfo_Components_CCMHome_get_home_def (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::CCMHome *tao_impl
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_CCMHome_get_home_def::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return parameter_list;
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_CCMHome_get_home_def::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_CCMHome_get_home_def::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_CCMHome_get_home_def::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_CCMHome_get_home_def::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_CCMHome_get_home_def::result (::CORBA::IRObject_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_CCMHome_remove_component : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_CCMHome_remove_component (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::CCMHome *tao_impl
    ,
    Components::CCMObject_ptr comp);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    
  private:
    TAO_ServerRequestInfo_Components_CCMHome_remove_component (const TAO_ServerRequestInfo_Components_CCMHome_remove_component &);
    void operator= (const TAO_ServerRequestInfo_Components_CCMHome_remove_component &);
    
  private:
    POA_Components::CCMHome *_tao_impl;
    Components::CCMObject_ptr comp_;
    
  };
  
    TAO_ServerRequestInfo_Components_CCMHome_remove_component::TAO_ServerRequestInfo_Components_CCMHome_remove_component (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::CCMHome *tao_impl,
      Components::CCMObject_ptr comp
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        comp_ (comp)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_CCMHome_remove_component::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (1);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<=  this->comp_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_CCMHome_remove_component::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_CCMHome_remove_component_exceptiondata[] = 
  {
    Components::_tc_RemoveFailure
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_CCMHome_remove_component_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_CCMHome_remove_component::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_Components_CCMHome_remove_component::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_CCMHome_remove_component::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_Components::_TAO_CCMHome_Strategized_Proxy_Broker *POA_Components::_TAO_CCMHome_Strategized_Proxy_Broker::the_TAO_CCMHome_Strategized_Proxy_Broker (void)
{
  static POA_Components::_TAO_CCMHome_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_Components::_TAO_CCMHome_Strategized_Proxy_Broker::_TAO_CCMHome_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_Components::_TAO_CCMHome_Strategized_Proxy_Broker::~_TAO_CCMHome_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    {
      delete this->proxy_cache_[i];
      
      // Hack to prevent bug mentioned in 1204. Refer to 1204
      // for details..
      this->proxy_cache_[i] = 0;
    }
  
}

Components::_TAO_CCMHome_Proxy_Impl&
POA_Components::_TAO_CCMHome_Strategized_Proxy_Broker::select_proxy (
    ::Components::CCMHome *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
    ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_Components::_TAO_CCMHome_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_Components::_TAO_CCMHome_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::Components::_TAO_CCMHome_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


Components::_TAO_CCMHome_Proxy_Broker *
Components__TAO_CCMHome_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_Components::_TAO_CCMHome_Strategized_Proxy_Broker::the_TAO_CCMHome_Strategized_Proxy_Broker();
}

int
Components__TAO_CCMHome_Proxy_Broker_Factory_Initializer (long)
{
  Components__TAO_CCMHome_Proxy_Broker_Factory_function_pointer = 
    Components__TAO_CCMHome_Proxy_Broker_Factory_function;
  
  return 0;
}

static int Components__TAO_CCMHome_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  Components__TAO_CCMHome_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, Components__TAO_CCMHome_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_Components::_TAO_CCMHome_ThruPOA_Proxy_Impl::_TAO_CCMHome_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

::CORBA::IRObject_ptr POA_Components::_TAO_CCMHome_ThruPOA_Proxy_Impl::get_component_def (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "get_component_def",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::CCMHome_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/CCMHome:1.0"
        )
    )->get_component_def (
        
      );
}

::CORBA::IRObject_ptr POA_Components::_TAO_CCMHome_ThruPOA_Proxy_Impl::get_home_def (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "get_home_def",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::CCMHome_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/CCMHome:1.0"
        )
    )->get_home_def (
        
      );
}

void POA_Components::_TAO_CCMHome_ThruPOA_Proxy_Impl::remove_component (
    CORBA_Object *_collocated_tao_target_,
    Components::CCMObject_ptr comp
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::RemoveFailure
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "remove_component",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  ACE_reinterpret_cast (
      POA_Components::CCMHome_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/CCMHome:1.0"
        )
    )->remove_component (
        comp
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ss.cpp:100
POA_Components::CCMHome::CCMHome (void)
{
  this->optable_ = &tao_Components_CCMHome_optable;
}

POA_Components::CCMHome::CCMHome (const CCMHome& rhs)
  :  TAO_ServantBase (rhs)
{}

POA_Components::CCMHome::~CCMHome (void)
{
}

void POA_Components::CCMHome::get_component_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::CCMHome *_tao_impl =
    ACE_static_cast (
        POA_Components::CCMHome *,
        _tao_servant
      );
  ::CORBA::IRObject_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_CCMHome_get_component_def _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->get_component_def (
                
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::CORBA::IRObject_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::CCMHome::get_home_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::CCMHome *_tao_impl =
    ACE_static_cast (
        POA_Components::CCMHome *,
        _tao_servant
      );
  ::CORBA::IRObject_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_CCMHome_get_home_def _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->get_home_def (
                
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::CORBA::IRObject_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::CCMHome::remove_component_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::CCMHome *_tao_impl =
    ACE_static_cast (
        POA_Components::CCMHome *,
        _tao_servant
      );
  _tao_server_request.argument_flag (0);
    Components::CCMObject_var comp;
  if (!(
    (_tao_in >> comp.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_CCMHome_remove_component _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      comp.in ()
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            
            _tao_impl->remove_component (
                comp.in ()
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::CCMHome::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::CCMHome *_tao_impl = (POA_Components::CCMHome *) _tao_servant;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::CCMHome::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::CCMHome *_tao_impl = (POA_Components::CCMHome *) _tao_servant;
  CORBA::Boolean _tao_retval =
    _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::CCMHome::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::CCMHome *_tao_impl = (POA_Components::CCMHome *) _tao_servant;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = 
        _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_Components::CCMHome::_component_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::CCMHome *_tao_impl = (POA_Components::CCMHome *) _tao_object_reference;
  CORBA::Object_var _tao_retval =
    _tao_impl->_get_component (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << _tao_retval._retn ()))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_Components::CCMHome::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  const char *base_id = "IDL:org.omg/CORBA/Object:1.0";
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/CCMHome:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_Components::CCMHome::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/Components/CCMHome:1.0") == 0)
    return ACE_static_cast (POA_Components::CCMHome_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_Components::CCMHome::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/CCMHome:1.0";
}

void POA_Components::CCMHome::_dispatch (
    TAO_ServerRequest &req,
    void *servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


Components::CCMHome*
POA_Components::CCMHome::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  
  (void) safe_stub.release ();
  
  return ::Components::CCMHome::_unchecked_narrow (obj.in ());
}


class TAO_Components_KeylessCCMHome_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:56:14 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_Components_KeylessCCMHome_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_Components_KeylessCCMHome_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17,  0,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17,  0,
     17,  0, 17,  5, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17,  0, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17,
#else
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17,  0, 17,  0, 17,  0,
     17,  5, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17,  0, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_Components_KeylessCCMHome_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 5,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 16,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 16,
      HASH_VALUE_RANGE = 12,
      DUPLICATES = 0,
      WORDLIST_SIZE = 10
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_Components::KeylessCCMHome::_is_a_skel},
      {"",0},{"",0},{"",0},{"",0},
      {"_component",  &POA_Components::KeylessCCMHome::_component_skel},
      {"",0},{"",0},
      {"_non_existent",  &POA_Components::KeylessCCMHome::_non_existent_skel},
      {"",0},
      {"_interface",  &POA_Components::KeylessCCMHome::_interface_skel},
      {"create_component", 	&POA_Components::KeylessCCMHome::create_component_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 22:56:14 */
static TAO_Components_KeylessCCMHome_Perfect_Hash_OpTable tao_Components_KeylessCCMHome_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_Components_KeylessCCMHome_create_component : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_KeylessCCMHome_create_component (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::KeylessCCMHome *tao_impl
    );

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::CCMObject_ptr result);

  private:
    TAO_ServerRequestInfo_Components_KeylessCCMHome_create_component (const TAO_ServerRequestInfo_Components_KeylessCCMHome_create_component &);
    void operator= (const TAO_ServerRequestInfo_Components_KeylessCCMHome_create_component &);
    
  private:
    POA_Components::KeylessCCMHome *_tao_impl;
    ::Components::CCMObject_ptr _result;
  };
  
    TAO_ServerRequestInfo_Components_KeylessCCMHome_create_component::TAO_ServerRequestInfo_Components_KeylessCCMHome_create_component (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::KeylessCCMHome *tao_impl
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_KeylessCCMHome_create_component::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return parameter_list;
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_KeylessCCMHome_create_component::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_KeylessCCMHome_create_component_exceptiondata[] = 
  {
    Components::_tc_CreateFailure
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_KeylessCCMHome_create_component_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_KeylessCCMHome_create_component::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_KeylessCCMHome_create_component::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_KeylessCCMHome_create_component::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_KeylessCCMHome_create_component::result (::Components::CCMObject_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_Components::_TAO_KeylessCCMHome_Strategized_Proxy_Broker *POA_Components::_TAO_KeylessCCMHome_Strategized_Proxy_Broker::the_TAO_KeylessCCMHome_Strategized_Proxy_Broker (void)
{
  static POA_Components::_TAO_KeylessCCMHome_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_Components::_TAO_KeylessCCMHome_Strategized_Proxy_Broker::_TAO_KeylessCCMHome_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_Components::_TAO_KeylessCCMHome_Strategized_Proxy_Broker::~_TAO_KeylessCCMHome_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    {
      delete this->proxy_cache_[i];
      
      // Hack to prevent bug mentioned in 1204. Refer to 1204
      // for details..
      this->proxy_cache_[i] = 0;
    }
  
}

Components::_TAO_KeylessCCMHome_Proxy_Impl&
POA_Components::_TAO_KeylessCCMHome_Strategized_Proxy_Broker::select_proxy (
    ::Components::KeylessCCMHome *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
    ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_Components::_TAO_KeylessCCMHome_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_Components::_TAO_KeylessCCMHome_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::Components::_TAO_KeylessCCMHome_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


Components::_TAO_KeylessCCMHome_Proxy_Broker *
Components__TAO_KeylessCCMHome_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_Components::_TAO_KeylessCCMHome_Strategized_Proxy_Broker::the_TAO_KeylessCCMHome_Strategized_Proxy_Broker();
}

int
Components__TAO_KeylessCCMHome_Proxy_Broker_Factory_Initializer (long)
{
  Components__TAO_KeylessCCMHome_Proxy_Broker_Factory_function_pointer = 
    Components__TAO_KeylessCCMHome_Proxy_Broker_Factory_function;
  
  return 0;
}

static int Components__TAO_KeylessCCMHome_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  Components__TAO_KeylessCCMHome_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, Components__TAO_KeylessCCMHome_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_Components::_TAO_KeylessCCMHome_ThruPOA_Proxy_Impl::_TAO_KeylessCCMHome_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

::Components::CCMObject_ptr POA_Components::_TAO_KeylessCCMHome_ThruPOA_Proxy_Impl::create_component (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::CreateFailure
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_component",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::KeylessCCMHome_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/KeylessCCMHome:1.0"
        )
    )->create_component (
        
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ss.cpp:100
POA_Components::KeylessCCMHome::KeylessCCMHome (void)
{
  this->optable_ = &tao_Components_KeylessCCMHome_optable;
}

POA_Components::KeylessCCMHome::KeylessCCMHome (const KeylessCCMHome& rhs)
  :  TAO_ServantBase (rhs)
{}

POA_Components::KeylessCCMHome::~KeylessCCMHome (void)
{
}

void POA_Components::KeylessCCMHome::create_component_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::KeylessCCMHome *_tao_impl =
    ACE_static_cast (
        POA_Components::KeylessCCMHome *,
        _tao_servant
      );
  ::Components::CCMObject_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_KeylessCCMHome_create_component _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->create_component (
                
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::CCMObject_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::KeylessCCMHome::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::KeylessCCMHome *_tao_impl = (POA_Components::KeylessCCMHome *) _tao_servant;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::KeylessCCMHome::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::KeylessCCMHome *_tao_impl = (POA_Components::KeylessCCMHome *) _tao_servant;
  CORBA::Boolean _tao_retval =
    _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::KeylessCCMHome::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::KeylessCCMHome *_tao_impl = (POA_Components::KeylessCCMHome *) _tao_servant;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = 
        _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_Components::KeylessCCMHome::_component_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::KeylessCCMHome *_tao_impl = (POA_Components::KeylessCCMHome *) _tao_object_reference;
  CORBA::Object_var _tao_retval =
    _tao_impl->_get_component (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << _tao_retval._retn ()))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_Components::KeylessCCMHome::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  const char *base_id = "IDL:org.omg/CORBA/Object:1.0";
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/KeylessCCMHome:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_Components::KeylessCCMHome::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/Components/KeylessCCMHome:1.0") == 0)
    return ACE_static_cast (POA_Components::KeylessCCMHome_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_Components::KeylessCCMHome::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/KeylessCCMHome:1.0";
}

void POA_Components::KeylessCCMHome::_dispatch (
    TAO_ServerRequest &req,
    void *servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


Components::KeylessCCMHome*
POA_Components::KeylessCCMHome::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  
  (void) safe_stub.release ();
  
  return ::Components::KeylessCCMHome::_unchecked_narrow (obj.in ());
}


class TAO_Components_HomeFinder_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:56:14 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_Components_HomeFinder_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_Components_HomeFinder_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28,  0,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28,  0,
     28, 28, 28,  0,  0, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28,  5, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28,
#else
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28,  0, 28,  0, 28, 28,
     28,  0,  0, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28,  5, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_Components_HomeFinder_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 7,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 27,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 27,
      HASH_VALUE_RANGE = 23,
      DUPLICATES = 0,
      WORDLIST_SIZE = 12
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_Components::HomeFinder::_is_a_skel},
      {"",0},{"",0},{"",0},{"",0},
      {"_interface",  &POA_Components::HomeFinder::_interface_skel},
      {"",0},{"",0},{"",0},{"",0},
      {"_component",  &POA_Components::HomeFinder::_component_skel},
      {"",0},
      {"find_home_by_name", 	&POA_Components::HomeFinder::find_home_by_name_skel},
      {"_non_existent",  &POA_Components::HomeFinder::_non_existent_skel},
      {"",0},{"",0},{"",0},
      {"find_home_by_home_type", 	&POA_Components::HomeFinder::find_home_by_home_type_skel},
      {"",0},{"",0},{"",0},{"",0},
      {"find_home_by_component_type", 	&POA_Components::HomeFinder::find_home_by_component_type_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 22:56:14 */
static TAO_Components_HomeFinder_Perfect_Hash_OpTable tao_Components_HomeFinder_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_component_type : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_component_type (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::HomeFinder *tao_impl
    ,
    const char * comp_repid);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::CCMHome_ptr result);

  private:
    TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_component_type (const TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_component_type &);
    void operator= (const TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_component_type &);
    
  private:
    POA_Components::HomeFinder *_tao_impl;
    const char * comp_repid_;
    ::Components::CCMHome_ptr _result;
  };
  
    TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_component_type::TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_component_type (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::HomeFinder *tao_impl,
      const char * comp_repid
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        comp_repid_ (comp_repid)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_component_type::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (1);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<= comp_repid_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_component_type::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_HomeFinder_find_home_by_component_type_exceptiondata[] = 
  {
    Components::_tc_HomeNotFound
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_HomeFinder_find_home_by_component_type_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_component_type::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_component_type::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_component_type::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_component_type::result (::Components::CCMHome_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_home_type : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_home_type (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::HomeFinder *tao_impl
    ,
    const char * home_repid);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::CCMHome_ptr result);

  private:
    TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_home_type (const TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_home_type &);
    void operator= (const TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_home_type &);
    
  private:
    POA_Components::HomeFinder *_tao_impl;
    const char * home_repid_;
    ::Components::CCMHome_ptr _result;
  };
  
    TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_home_type::TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_home_type (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::HomeFinder *tao_impl,
      const char * home_repid
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        home_repid_ (home_repid)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_home_type::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (1);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<= home_repid_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_home_type::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_HomeFinder_find_home_by_home_type_exceptiondata[] = 
  {
    Components::_tc_HomeNotFound
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_HomeFinder_find_home_by_home_type_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_home_type::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_home_type::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_home_type::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_home_type::result (::Components::CCMHome_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_name : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_name (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::HomeFinder *tao_impl
    ,
    const char * home_name);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::CCMHome_ptr result);

  private:
    TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_name (const TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_name &);
    void operator= (const TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_name &);
    
  private:
    POA_Components::HomeFinder *_tao_impl;
    const char * home_name_;
    ::Components::CCMHome_ptr _result;
  };
  
    TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_name::TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_name (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::HomeFinder *tao_impl,
      const char * home_name
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        home_name_ (home_name)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_name::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (1);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<= home_name_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_name::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_HomeFinder_find_home_by_name_exceptiondata[] = 
  {
    Components::_tc_HomeNotFound
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_HomeFinder_find_home_by_name_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_name::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_name::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_name::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_name::result (::Components::CCMHome_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_Components::_TAO_HomeFinder_Strategized_Proxy_Broker *POA_Components::_TAO_HomeFinder_Strategized_Proxy_Broker::the_TAO_HomeFinder_Strategized_Proxy_Broker (void)
{
  static POA_Components::_TAO_HomeFinder_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_Components::_TAO_HomeFinder_Strategized_Proxy_Broker::_TAO_HomeFinder_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_Components::_TAO_HomeFinder_Strategized_Proxy_Broker::~_TAO_HomeFinder_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    {
      delete this->proxy_cache_[i];
      
      // Hack to prevent bug mentioned in 1204. Refer to 1204
      // for details..
      this->proxy_cache_[i] = 0;
    }
  
}

Components::_TAO_HomeFinder_Proxy_Impl&
POA_Components::_TAO_HomeFinder_Strategized_Proxy_Broker::select_proxy (
    ::Components::HomeFinder *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
    ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_Components::_TAO_HomeFinder_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_Components::_TAO_HomeFinder_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::Components::_TAO_HomeFinder_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


Components::_TAO_HomeFinder_Proxy_Broker *
Components__TAO_HomeFinder_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_Components::_TAO_HomeFinder_Strategized_Proxy_Broker::the_TAO_HomeFinder_Strategized_Proxy_Broker();
}

int
Components__TAO_HomeFinder_Proxy_Broker_Factory_Initializer (long)
{
  Components__TAO_HomeFinder_Proxy_Broker_Factory_function_pointer = 
    Components__TAO_HomeFinder_Proxy_Broker_Factory_function;
  
  return 0;
}

static int Components__TAO_HomeFinder_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  Components__TAO_HomeFinder_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, Components__TAO_HomeFinder_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_Components::_TAO_HomeFinder_ThruPOA_Proxy_Impl::_TAO_HomeFinder_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

::Components::CCMHome_ptr POA_Components::_TAO_HomeFinder_ThruPOA_Proxy_Impl::find_home_by_component_type (
    CORBA_Object *_collocated_tao_target_,
    const char * comp_repid
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::HomeNotFound
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "find_home_by_component_type",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::HomeFinder_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/HomeFinder:1.0"
        )
    )->find_home_by_component_type (
        comp_repid
      );
}

::Components::CCMHome_ptr POA_Components::_TAO_HomeFinder_ThruPOA_Proxy_Impl::find_home_by_home_type (
    CORBA_Object *_collocated_tao_target_,
    const char * home_repid
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::HomeNotFound
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "find_home_by_home_type",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::HomeFinder_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/HomeFinder:1.0"
        )
    )->find_home_by_home_type (
        home_repid
      );
}

::Components::CCMHome_ptr POA_Components::_TAO_HomeFinder_ThruPOA_Proxy_Impl::find_home_by_name (
    CORBA_Object *_collocated_tao_target_,
    const char * home_name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::HomeNotFound
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "find_home_by_name",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::HomeFinder_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/HomeFinder:1.0"
        )
    )->find_home_by_name (
        home_name
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ss.cpp:100
POA_Components::HomeFinder::HomeFinder (void)
{
  this->optable_ = &tao_Components_HomeFinder_optable;
}

POA_Components::HomeFinder::HomeFinder (const HomeFinder& rhs)
  :  TAO_ServantBase (rhs)
{}

POA_Components::HomeFinder::~HomeFinder (void)
{
}

void POA_Components::HomeFinder::find_home_by_component_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::HomeFinder *_tao_impl =
    ACE_static_cast (
        POA_Components::HomeFinder *,
        _tao_servant
      );
  ::Components::CCMHome_var _tao_retval;
  CORBA::String_var comp_repid;
  if (!(
    (_tao_in >> comp_repid.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_component_type _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      comp_repid.in ()
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->find_home_by_component_type (
                comp_repid.in ()
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::CCMHome_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::HomeFinder::find_home_by_home_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::HomeFinder *_tao_impl =
    ACE_static_cast (
        POA_Components::HomeFinder *,
        _tao_servant
      );
  ::Components::CCMHome_var _tao_retval;
  CORBA::String_var home_repid;
  if (!(
    (_tao_in >> home_repid.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_home_type _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      home_repid.in ()
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->find_home_by_home_type (
                home_repid.in ()
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::CCMHome_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::HomeFinder::find_home_by_name_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::HomeFinder *_tao_impl =
    ACE_static_cast (
        POA_Components::HomeFinder *,
        _tao_servant
      );
  ::Components::CCMHome_var _tao_retval;
  CORBA::String_var home_name;
  if (!(
    (_tao_in >> home_name.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_HomeFinder_find_home_by_name _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      home_name.in ()
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->find_home_by_name (
                home_name.in ()
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::CCMHome_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::HomeFinder::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::HomeFinder *_tao_impl = (POA_Components::HomeFinder *) _tao_servant;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::HomeFinder::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::HomeFinder *_tao_impl = (POA_Components::HomeFinder *) _tao_servant;
  CORBA::Boolean _tao_retval =
    _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::HomeFinder::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::HomeFinder *_tao_impl = (POA_Components::HomeFinder *) _tao_servant;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = 
        _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_Components::HomeFinder::_component_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::HomeFinder *_tao_impl = (POA_Components::HomeFinder *) _tao_object_reference;
  CORBA::Object_var _tao_retval =
    _tao_impl->_get_component (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << _tao_retval._retn ()))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_Components::HomeFinder::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  const char *base_id = "IDL:org.omg/CORBA/Object:1.0";
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/HomeFinder:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_Components::HomeFinder::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/Components/HomeFinder:1.0") == 0)
    return ACE_static_cast (POA_Components::HomeFinder_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_Components::HomeFinder::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/HomeFinder:1.0";
}

void POA_Components::HomeFinder::_dispatch (
    TAO_ServerRequest &req,
    void *servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


Components::HomeFinder*
POA_Components::HomeFinder::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  
  (void) safe_stub.release ();
  
  return ::Components::HomeFinder::_unchecked_narrow (obj.in ());
}


class TAO_Components_Configurator_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:56:14 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_Components_Configurator_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_Components_Configurator_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16,  0,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16,  0,
     16,  0, 16,  5, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16,  0, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16,
#else
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16,  0, 16,  0, 16,  0,
     16,  5, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16,  0, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_Components_Configurator_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 5,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 15,
      HASH_VALUE_RANGE = 11,
      DUPLICATES = 0,
      WORDLIST_SIZE = 10
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_Components::Configurator::_is_a_skel},
      {"",0},{"",0},{"",0},{"",0},
      {"_component",  &POA_Components::Configurator::_component_skel},
      {"",0},{"",0},
      {"_non_existent",  &POA_Components::Configurator::_non_existent_skel},
      {"configure", 	&POA_Components::Configurator::configure_skel},
      {"_interface",  &POA_Components::Configurator::_interface_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 22:56:14 */
static TAO_Components_Configurator_Perfect_Hash_OpTable tao_Components_Configurator_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_Components_Configurator_configure : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Configurator_configure (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Configurator *tao_impl
    ,
    Components::CCMObject_ptr comp);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    
  private:
    TAO_ServerRequestInfo_Components_Configurator_configure (const TAO_ServerRequestInfo_Components_Configurator_configure &);
    void operator= (const TAO_ServerRequestInfo_Components_Configurator_configure &);
    
  private:
    POA_Components::Configurator *_tao_impl;
    Components::CCMObject_ptr comp_;
    
  };
  
    TAO_ServerRequestInfo_Components_Configurator_configure::TAO_ServerRequestInfo_Components_Configurator_configure (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Configurator *tao_impl,
      Components::CCMObject_ptr comp
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        comp_ (comp)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Configurator_configure::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (1);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<=  this->comp_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Configurator_configure::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Configurator_configure_exceptiondata[] = 
  {
    Components::_tc_WrongComponentType
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Configurator_configure_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Configurator_configure::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_Components_Configurator_configure::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Configurator_configure::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_Components::_TAO_Configurator_Strategized_Proxy_Broker *POA_Components::_TAO_Configurator_Strategized_Proxy_Broker::the_TAO_Configurator_Strategized_Proxy_Broker (void)
{
  static POA_Components::_TAO_Configurator_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_Components::_TAO_Configurator_Strategized_Proxy_Broker::_TAO_Configurator_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_Components::_TAO_Configurator_Strategized_Proxy_Broker::~_TAO_Configurator_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    {
      delete this->proxy_cache_[i];
      
      // Hack to prevent bug mentioned in 1204. Refer to 1204
      // for details..
      this->proxy_cache_[i] = 0;
    }
  
}

Components::_TAO_Configurator_Proxy_Impl&
POA_Components::_TAO_Configurator_Strategized_Proxy_Broker::select_proxy (
    ::Components::Configurator *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
    ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_Components::_TAO_Configurator_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_Components::_TAO_Configurator_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::Components::_TAO_Configurator_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


Components::_TAO_Configurator_Proxy_Broker *
Components__TAO_Configurator_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_Components::_TAO_Configurator_Strategized_Proxy_Broker::the_TAO_Configurator_Strategized_Proxy_Broker();
}

int
Components__TAO_Configurator_Proxy_Broker_Factory_Initializer (long)
{
  Components__TAO_Configurator_Proxy_Broker_Factory_function_pointer = 
    Components__TAO_Configurator_Proxy_Broker_Factory_function;
  
  return 0;
}

static int Components__TAO_Configurator_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  Components__TAO_Configurator_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, Components__TAO_Configurator_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_Components::_TAO_Configurator_ThruPOA_Proxy_Impl::_TAO_Configurator_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

void POA_Components::_TAO_Configurator_ThruPOA_Proxy_Impl::configure (
    CORBA_Object *_collocated_tao_target_,
    Components::CCMObject_ptr comp
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::WrongComponentType
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "configure",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  ACE_reinterpret_cast (
      POA_Components::Configurator_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Configurator:1.0"
        )
    )->configure (
        comp
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ss.cpp:100
POA_Components::Configurator::Configurator (void)
{
  this->optable_ = &tao_Components_Configurator_optable;
}

POA_Components::Configurator::Configurator (const Configurator& rhs)
  :  TAO_ServantBase (rhs)
{}

POA_Components::Configurator::~Configurator (void)
{
}

void POA_Components::Configurator::configure_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Configurator *_tao_impl =
    ACE_static_cast (
        POA_Components::Configurator *,
        _tao_servant
      );
  _tao_server_request.argument_flag (0);
    Components::CCMObject_var comp;
  if (!(
    (_tao_in >> comp.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Configurator_configure _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      comp.in ()
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            
            _tao_impl->configure (
                comp.in ()
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Configurator::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Configurator *_tao_impl = (POA_Components::Configurator *) _tao_servant;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::Configurator::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Configurator *_tao_impl = (POA_Components::Configurator *) _tao_servant;
  CORBA::Boolean _tao_retval =
    _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::Configurator::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Configurator *_tao_impl = (POA_Components::Configurator *) _tao_servant;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = 
        _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_Components::Configurator::_component_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Configurator *_tao_impl = (POA_Components::Configurator *) _tao_object_reference;
  CORBA::Object_var _tao_retval =
    _tao_impl->_get_component (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << _tao_retval._retn ()))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_Components::Configurator::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  const char *base_id = "IDL:org.omg/CORBA/Object:1.0";
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/Configurator:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_Components::Configurator::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/Components/Configurator:1.0") == 0)
    return ACE_static_cast (POA_Components::Configurator_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_Components::Configurator::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/Configurator:1.0";
}

void POA_Components::Configurator::_dispatch (
    TAO_ServerRequest &req,
    void *servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


Components::Configurator*
POA_Components::Configurator::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  
  (void) safe_stub.release ();
  
  return ::Components::Configurator::_unchecked_narrow (obj.in ());
}


class TAO_Components_StandardConfigurator_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:56:14 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_Components_StandardConfigurator_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_Components_StandardConfigurator_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18,  0,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18,  0,
     18,  0, 18,  5, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18,  0,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18,  0,  0, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18,
#else
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18,  0, 18,  0, 18,  0,
     18,  5, 18, 18, 18, 18, 18, 18, 18, 18,
      0, 18, 18, 18, 18,  0,  0, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_Components_StandardConfigurator_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 6,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 17,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 17,
      HASH_VALUE_RANGE = 13,
      DUPLICATES = 0,
      WORDLIST_SIZE = 11
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_Components::StandardConfigurator::_is_a_skel},
      {"",0},{"",0},{"",0},{"",0},
      {"_component",  &POA_Components::StandardConfigurator::_component_skel},
      {"",0},{"",0},
      {"_non_existent",  &POA_Components::StandardConfigurator::_non_existent_skel},
      {"configure", 	&POA_Components::StandardConfigurator::configure_skel},
      {"_interface",  &POA_Components::StandardConfigurator::_interface_skel},
      {"",0},
      {"set_configuration", 	&POA_Components::StandardConfigurator::set_configuration_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 22:56:14 */
static TAO_Components_StandardConfigurator_Perfect_Hash_OpTable tao_Components_StandardConfigurator_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_Components_StandardConfigurator_set_configuration : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_StandardConfigurator_set_configuration (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::StandardConfigurator *tao_impl
    ,
    const Components::ConfigValues & descr);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    
  private:
    TAO_ServerRequestInfo_Components_StandardConfigurator_set_configuration (const TAO_ServerRequestInfo_Components_StandardConfigurator_set_configuration &);
    void operator= (const TAO_ServerRequestInfo_Components_StandardConfigurator_set_configuration &);
    
  private:
    POA_Components::StandardConfigurator *_tao_impl;
    const Components::ConfigValues & descr_;
    
  };
  
    TAO_ServerRequestInfo_Components_StandardConfigurator_set_configuration::TAO_ServerRequestInfo_Components_StandardConfigurator_set_configuration (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::StandardConfigurator *tao_impl,
      const Components::ConfigValues & descr
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        descr_ (descr)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_StandardConfigurator_set_configuration::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (1);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<=  this->descr_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_StandardConfigurator_set_configuration::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_StandardConfigurator_set_configuration::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_Components_StandardConfigurator_set_configuration::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_StandardConfigurator_set_configuration::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_Components::_TAO_StandardConfigurator_Strategized_Proxy_Broker *POA_Components::_TAO_StandardConfigurator_Strategized_Proxy_Broker::the_TAO_StandardConfigurator_Strategized_Proxy_Broker (void)
{
  static POA_Components::_TAO_StandardConfigurator_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_Components::_TAO_StandardConfigurator_Strategized_Proxy_Broker::_TAO_StandardConfigurator_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_Components::_TAO_StandardConfigurator_Strategized_Proxy_Broker::~_TAO_StandardConfigurator_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    {
      delete this->proxy_cache_[i];
      
      // Hack to prevent bug mentioned in 1204. Refer to 1204
      // for details..
      this->proxy_cache_[i] = 0;
    }
  
}

Components::_TAO_StandardConfigurator_Proxy_Impl&
POA_Components::_TAO_StandardConfigurator_Strategized_Proxy_Broker::select_proxy (
    ::Components::StandardConfigurator *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
    ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_Components::_TAO_StandardConfigurator_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_Components::_TAO_StandardConfigurator_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::Components::_TAO_StandardConfigurator_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


Components::_TAO_StandardConfigurator_Proxy_Broker *
Components__TAO_StandardConfigurator_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_Components::_TAO_StandardConfigurator_Strategized_Proxy_Broker::the_TAO_StandardConfigurator_Strategized_Proxy_Broker();
}

int
Components__TAO_StandardConfigurator_Proxy_Broker_Factory_Initializer (long)
{
  Components__TAO_StandardConfigurator_Proxy_Broker_Factory_function_pointer = 
    Components__TAO_StandardConfigurator_Proxy_Broker_Factory_function;
  
  return 0;
}

static int Components__TAO_StandardConfigurator_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  Components__TAO_StandardConfigurator_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, Components__TAO_StandardConfigurator_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_Components::_TAO_StandardConfigurator_ThruPOA_Proxy_Impl::_TAO_StandardConfigurator_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

void POA_Components::_TAO_StandardConfigurator_ThruPOA_Proxy_Impl::set_configuration (
    CORBA_Object *_collocated_tao_target_,
    const Components::ConfigValues & descr
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "set_configuration",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  ACE_reinterpret_cast (
      POA_Components::StandardConfigurator_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/StandardConfigurator:1.0"
        )
    )->set_configuration (
        descr
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ss.cpp:100
POA_Components::StandardConfigurator::StandardConfigurator (void)
{
  this->optable_ = &tao_Components_StandardConfigurator_optable;
}

POA_Components::StandardConfigurator::StandardConfigurator (const StandardConfigurator& rhs)
  :  ACE_NESTED_CLASS (POA_Components,Configurator) (rhs),
    TAO_ServantBase (rhs)
{}

POA_Components::StandardConfigurator::~StandardConfigurator (void)
{
}

void POA_Components::StandardConfigurator::set_configuration_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::StandardConfigurator *_tao_impl =
    ACE_static_cast (
        POA_Components::StandardConfigurator *,
        _tao_servant
      );
  _tao_server_request.argument_flag (0);
    Components::ConfigValues descr;
  if (!(
    (_tao_in >> descr)
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_StandardConfigurator_set_configuration _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      descr
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            
            _tao_impl->set_configuration (
                descr
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::StandardConfigurator::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::StandardConfigurator *_tao_impl = (POA_Components::StandardConfigurator *) _tao_servant;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::StandardConfigurator::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::StandardConfigurator *_tao_impl = (POA_Components::StandardConfigurator *) _tao_servant;
  CORBA::Boolean _tao_retval =
    _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::StandardConfigurator::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::StandardConfigurator *_tao_impl = (POA_Components::StandardConfigurator *) _tao_servant;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = 
        _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_Components::StandardConfigurator::_component_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::StandardConfigurator *_tao_impl = (POA_Components::StandardConfigurator *) _tao_object_reference;
  CORBA::Object_var _tao_retval =
    _tao_impl->_get_component (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << _tao_retval._retn ()))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_Components::StandardConfigurator::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  const char *base_id = "IDL:org.omg/CORBA/Object:1.0";
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/StandardConfigurator:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/Configurator:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_Components::StandardConfigurator::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/Components/StandardConfigurator:1.0") == 0)
    return ACE_static_cast (POA_Components::StandardConfigurator_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/Components/Configurator:1.0") == 0)
    return ACE_static_cast (POA_Components::Configurator_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_Components::StandardConfigurator::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/StandardConfigurator:1.0";
}

void POA_Components::StandardConfigurator::_dispatch (
    TAO_ServerRequest &req,
    void *servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


Components::StandardConfigurator*
POA_Components::StandardConfigurator::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  
  (void) safe_stub.release ();
  
  return ::Components::StandardConfigurator::_unchecked_narrow (obj.in ());
}


class TAO_Components_HomeConfiguration_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:56:14 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_Components_HomeConfiguration_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_Components_HomeConfiguration_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
     35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
     35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
     35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
     35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
     35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
     35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
     35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
     35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
     35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
     35, 35, 35, 35, 35, 35, 35, 35, 35,  0,
     35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
     35, 35, 35, 35, 35, 35, 35, 35, 35,  0,
     35,  0,  0,  5,  0,  0, 35, 35, 35, 35,
     35, 35, 35, 35, 35, 35, 35, 35, 35,  0,
     35, 35, 35,  0, 35, 35, 35, 35, 35, 35,
     35, 35,  5,  0, 35, 35, 35, 35, 35, 35,
     35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
     35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
     35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
     35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
     35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
     35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
     35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
     35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
     35, 35, 35, 35, 35, 35,
#else
     35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
     35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
     35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
     35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
     35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
     35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
     35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
     35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
     35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
     35, 35, 35, 35, 35,  0, 35,  0, 35,  0,
      0,  5,  0,  0, 35, 35, 35, 35, 35, 35,
      0, 35, 35, 35,  0,  5,  0, 35, 35, 35,
     35, 35, 35, 35, 35, 35, 35, 35,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_Components_HomeConfiguration_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 11,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 32,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 34,
      HASH_VALUE_RANGE = 30,
      DUPLICATES = 0,
      WORDLIST_SIZE = 16
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_Components::HomeConfiguration::_is_a_skel},
      {"",0},{"",0},{"",0},{"",0},
      {"_component",  &POA_Components::HomeConfiguration::_component_skel},
      {"",0},
      {"get_home_def", 	&POA_Components::HomeConfiguration::get_home_def_skel},
      {"_non_existent",  &POA_Components::HomeConfiguration::_non_existent_skel},
      {"",0},
      {"_interface",  &POA_Components::HomeConfiguration::_interface_skel},
      {"remove_component", 	&POA_Components::HomeConfiguration::remove_component_skel},
      {"get_component_def", 	&POA_Components::HomeConfiguration::get_component_def_skel},
      {"",0},{"",0},{"",0},
      {"set_configurator", 	&POA_Components::HomeConfiguration::set_configurator_skel},
      {"",0},{"",0},{"",0},{"",0},
      {"disable_home_configuration", 	&POA_Components::HomeConfiguration::disable_home_configuration_skel},
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"complete_component_configuration", 	&POA_Components::HomeConfiguration::complete_component_configuration_skel},
      {"",0},
      {"set_configuration_values", 	&POA_Components::HomeConfiguration::set_configuration_values_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 22:56:14 */
static TAO_Components_HomeConfiguration_Perfect_Hash_OpTable tao_Components_HomeConfiguration_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_Components_HomeConfiguration_set_configurator : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_HomeConfiguration_set_configurator (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::HomeConfiguration *tao_impl
    ,
    Components::Configurator_ptr cfg);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    
  private:
    TAO_ServerRequestInfo_Components_HomeConfiguration_set_configurator (const TAO_ServerRequestInfo_Components_HomeConfiguration_set_configurator &);
    void operator= (const TAO_ServerRequestInfo_Components_HomeConfiguration_set_configurator &);
    
  private:
    POA_Components::HomeConfiguration *_tao_impl;
    Components::Configurator_ptr cfg_;
    
  };
  
    TAO_ServerRequestInfo_Components_HomeConfiguration_set_configurator::TAO_ServerRequestInfo_Components_HomeConfiguration_set_configurator (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::HomeConfiguration *tao_impl,
      Components::Configurator_ptr cfg
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        cfg_ (cfg)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_HomeConfiguration_set_configurator::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (1);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<=  this->cfg_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_HomeConfiguration_set_configurator::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_HomeConfiguration_set_configurator::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_Components_HomeConfiguration_set_configurator::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_HomeConfiguration_set_configurator::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_Components_HomeConfiguration_set_configuration_values : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_HomeConfiguration_set_configuration_values (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::HomeConfiguration *tao_impl
    ,
    const Components::ConfigValues & config);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    
  private:
    TAO_ServerRequestInfo_Components_HomeConfiguration_set_configuration_values (const TAO_ServerRequestInfo_Components_HomeConfiguration_set_configuration_values &);
    void operator= (const TAO_ServerRequestInfo_Components_HomeConfiguration_set_configuration_values &);
    
  private:
    POA_Components::HomeConfiguration *_tao_impl;
    const Components::ConfigValues & config_;
    
  };
  
    TAO_ServerRequestInfo_Components_HomeConfiguration_set_configuration_values::TAO_ServerRequestInfo_Components_HomeConfiguration_set_configuration_values (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::HomeConfiguration *tao_impl,
      const Components::ConfigValues & config
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        config_ (config)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_HomeConfiguration_set_configuration_values::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (1);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<=  this->config_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_HomeConfiguration_set_configuration_values::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_HomeConfiguration_set_configuration_values::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_Components_HomeConfiguration_set_configuration_values::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_HomeConfiguration_set_configuration_values::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_Components_HomeConfiguration_complete_component_configuration : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_HomeConfiguration_complete_component_configuration (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::HomeConfiguration *tao_impl
    ,
    const CORBA::Boolean & b);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    
  private:
    TAO_ServerRequestInfo_Components_HomeConfiguration_complete_component_configuration (const TAO_ServerRequestInfo_Components_HomeConfiguration_complete_component_configuration &);
    void operator= (const TAO_ServerRequestInfo_Components_HomeConfiguration_complete_component_configuration &);
    
  private:
    POA_Components::HomeConfiguration *_tao_impl;
    const CORBA::Boolean & b_;
    
  };
  
    TAO_ServerRequestInfo_Components_HomeConfiguration_complete_component_configuration::TAO_ServerRequestInfo_Components_HomeConfiguration_complete_component_configuration (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::HomeConfiguration *tao_impl,
      const CORBA::Boolean & b
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        b_ (b)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_HomeConfiguration_complete_component_configuration::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (1);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<= CORBA::Any::from_boolean (this->b_);
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_HomeConfiguration_complete_component_configuration::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_HomeConfiguration_complete_component_configuration::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_Components_HomeConfiguration_complete_component_configuration::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_HomeConfiguration_complete_component_configuration::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_Components_HomeConfiguration_disable_home_configuration : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_HomeConfiguration_disable_home_configuration (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::HomeConfiguration *tao_impl
    );

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    
  private:
    TAO_ServerRequestInfo_Components_HomeConfiguration_disable_home_configuration (const TAO_ServerRequestInfo_Components_HomeConfiguration_disable_home_configuration &);
    void operator= (const TAO_ServerRequestInfo_Components_HomeConfiguration_disable_home_configuration &);
    
  private:
    POA_Components::HomeConfiguration *_tao_impl;
    
  };
  
    TAO_ServerRequestInfo_Components_HomeConfiguration_disable_home_configuration::TAO_ServerRequestInfo_Components_HomeConfiguration_disable_home_configuration (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::HomeConfiguration *tao_impl
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_HomeConfiguration_disable_home_configuration::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return parameter_list;
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_HomeConfiguration_disable_home_configuration::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_HomeConfiguration_disable_home_configuration::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_Components_HomeConfiguration_disable_home_configuration::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_HomeConfiguration_disable_home_configuration::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_Components::_TAO_HomeConfiguration_Strategized_Proxy_Broker *POA_Components::_TAO_HomeConfiguration_Strategized_Proxy_Broker::the_TAO_HomeConfiguration_Strategized_Proxy_Broker (void)
{
  static POA_Components::_TAO_HomeConfiguration_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_Components::_TAO_HomeConfiguration_Strategized_Proxy_Broker::_TAO_HomeConfiguration_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_Components::_TAO_HomeConfiguration_Strategized_Proxy_Broker::~_TAO_HomeConfiguration_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    {
      delete this->proxy_cache_[i];
      
      // Hack to prevent bug mentioned in 1204. Refer to 1204
      // for details..
      this->proxy_cache_[i] = 0;
    }
  
}

Components::_TAO_HomeConfiguration_Proxy_Impl&
POA_Components::_TAO_HomeConfiguration_Strategized_Proxy_Broker::select_proxy (
    ::Components::HomeConfiguration *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
    ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_Components::_TAO_HomeConfiguration_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_Components::_TAO_HomeConfiguration_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::Components::_TAO_HomeConfiguration_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


Components::_TAO_HomeConfiguration_Proxy_Broker *
Components__TAO_HomeConfiguration_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_Components::_TAO_HomeConfiguration_Strategized_Proxy_Broker::the_TAO_HomeConfiguration_Strategized_Proxy_Broker();
}

int
Components__TAO_HomeConfiguration_Proxy_Broker_Factory_Initializer (long)
{
  Components__TAO_HomeConfiguration_Proxy_Broker_Factory_function_pointer = 
    Components__TAO_HomeConfiguration_Proxy_Broker_Factory_function;
  
  return 0;
}

static int Components__TAO_HomeConfiguration_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  Components__TAO_HomeConfiguration_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, Components__TAO_HomeConfiguration_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_Components::_TAO_HomeConfiguration_ThruPOA_Proxy_Impl::_TAO_HomeConfiguration_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

void POA_Components::_TAO_HomeConfiguration_ThruPOA_Proxy_Impl::set_configurator (
    CORBA_Object *_collocated_tao_target_,
    Components::Configurator_ptr cfg
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "set_configurator",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  ACE_reinterpret_cast (
      POA_Components::HomeConfiguration_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/HomeConfiguration:1.0"
        )
    )->set_configurator (
        cfg
      );
  return;
}

void POA_Components::_TAO_HomeConfiguration_ThruPOA_Proxy_Impl::set_configuration_values (
    CORBA_Object *_collocated_tao_target_,
    const Components::ConfigValues & config
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "set_configuration_values",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  ACE_reinterpret_cast (
      POA_Components::HomeConfiguration_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/HomeConfiguration:1.0"
        )
    )->set_configuration_values (
        config
      );
  return;
}

void POA_Components::_TAO_HomeConfiguration_ThruPOA_Proxy_Impl::complete_component_configuration (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Boolean b
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "complete_component_configuration",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  ACE_reinterpret_cast (
      POA_Components::HomeConfiguration_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/HomeConfiguration:1.0"
        )
    )->complete_component_configuration (
        b
      );
  return;
}

void POA_Components::_TAO_HomeConfiguration_ThruPOA_Proxy_Impl::disable_home_configuration (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "disable_home_configuration",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  ACE_reinterpret_cast (
      POA_Components::HomeConfiguration_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/HomeConfiguration:1.0"
        )
    )->disable_home_configuration (
        
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ss.cpp:100
POA_Components::HomeConfiguration::HomeConfiguration (void)
{
  this->optable_ = &tao_Components_HomeConfiguration_optable;
}

POA_Components::HomeConfiguration::HomeConfiguration (const HomeConfiguration& rhs)
  :  ACE_NESTED_CLASS (POA_Components,CCMHome) (rhs),
    TAO_ServantBase (rhs)
{}

POA_Components::HomeConfiguration::~HomeConfiguration (void)
{
}

void POA_Components::HomeConfiguration::set_configurator_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::HomeConfiguration *_tao_impl =
    ACE_static_cast (
        POA_Components::HomeConfiguration *,
        _tao_servant
      );
  _tao_server_request.argument_flag (0);
    Components::Configurator_var cfg;
  if (!(
    (_tao_in >> cfg.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_HomeConfiguration_set_configurator _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      cfg.in ()
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            
            _tao_impl->set_configurator (
                cfg.in ()
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::HomeConfiguration::set_configuration_values_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::HomeConfiguration *_tao_impl =
    ACE_static_cast (
        POA_Components::HomeConfiguration *,
        _tao_servant
      );
  _tao_server_request.argument_flag (0);
    Components::ConfigValues config;
  if (!(
    (_tao_in >> config)
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_HomeConfiguration_set_configuration_values _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      config
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            
            _tao_impl->set_configuration_values (
                config
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::HomeConfiguration::complete_component_configuration_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::HomeConfiguration *_tao_impl =
    ACE_static_cast (
        POA_Components::HomeConfiguration *,
        _tao_servant
      );
  _tao_server_request.argument_flag (0);
    CORBA::Boolean b;
  if (!(
    (_tao_in >> CORBA::Any::to_boolean (b))
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_HomeConfiguration_complete_component_configuration _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      b
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            
            _tao_impl->complete_component_configuration (
                b
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::HomeConfiguration::disable_home_configuration_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::HomeConfiguration *_tao_impl =
    ACE_static_cast (
        POA_Components::HomeConfiguration *,
        _tao_servant
      );
  _tao_server_request.argument_flag (0);
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_HomeConfiguration_disable_home_configuration _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            
            _tao_impl->disable_home_configuration (
                
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::HomeConfiguration::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::HomeConfiguration *_tao_impl = (POA_Components::HomeConfiguration *) _tao_servant;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::HomeConfiguration::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::HomeConfiguration *_tao_impl = (POA_Components::HomeConfiguration *) _tao_servant;
  CORBA::Boolean _tao_retval =
    _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::HomeConfiguration::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::HomeConfiguration *_tao_impl = (POA_Components::HomeConfiguration *) _tao_servant;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = 
        _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_Components::HomeConfiguration::_component_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::HomeConfiguration *_tao_impl = (POA_Components::HomeConfiguration *) _tao_object_reference;
  CORBA::Object_var _tao_retval =
    _tao_impl->_get_component (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << _tao_retval._retn ()))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_Components::HomeConfiguration::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  const char *base_id = "IDL:org.omg/CORBA/Object:1.0";
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/HomeConfiguration:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/CCMHome:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_Components::HomeConfiguration::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/Components/HomeConfiguration:1.0") == 0)
    return ACE_static_cast (POA_Components::HomeConfiguration_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/Components/CCMHome:1.0") == 0)
    return ACE_static_cast (POA_Components::CCMHome_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_Components::HomeConfiguration::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/HomeConfiguration:1.0";
}

void POA_Components::HomeConfiguration::_dispatch (
    TAO_ServerRequest &req,
    void *servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


Components::HomeConfiguration*
POA_Components::HomeConfiguration::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  
  (void) safe_stub.release ();
  
  return ::Components::HomeConfiguration::_unchecked_narrow (obj.in ());
}


class TAO_Components_CCMObject_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:56:15 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_Components_CCMObject_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_Components_CCMObject_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
     57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
     57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
     57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
     57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
     57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
     57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
     57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
     57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
     57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
     57, 57, 57, 57, 57, 57, 57, 57, 57, 20,
     57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
     57, 57, 57, 57, 57, 57, 57, 57, 57, 20,
     57, 20, 15,  0, 10,  0, 57, 57, 57, 57,
     57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
     57,  0, 57, 20, 57, 57, 57, 57, 57, 57,
     57, 57,  0, 10,  0, 57, 57, 57, 10, 57,
     57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
     57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
     57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
     57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
     57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
     57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
     57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
     57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
     57, 57, 57, 57, 57, 57,
#else
     57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
     57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
     57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
     57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
     57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
     57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
     57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
     57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
     57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
     57, 57, 57, 57, 57, 20, 57, 20, 57, 20,
     15,  0, 10,  0, 57, 57, 57, 57, 57, 57,
     57, 57,  0, 57, 20,  0, 10,  0, 57, 57,
     57, 10, 57, 57, 57, 57, 57, 57,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_Components_CCMObject_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 30,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 22,
      MIN_HASH_VALUE = 9,
      MAX_HASH_VALUE = 56,
      HASH_VALUE_RANGE = 48,
      DUPLICATES = 4,
      WORDLIST_SIZE = 39
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},{"",0},{"",0},{"",0},{"",0},
            {"subscribe", 	&POA_Components::CCMObject::subscribe_skel},
      {"unsubscribe", 	&POA_Components::CCMObject::unsubscribe_skel},
      {"get_ccm_home", 	&POA_Components::CCMObject::get_ccm_home_skel},
      {"get_all_ports", 	&POA_Components::CCMObject::get_all_ports_skel},
      {"get_all_facets", 	&POA_Components::CCMObject::get_all_facets_skel},
      {"get_connections", 	&POA_Components::CCMObject::get_connections_skel},
      {"get_named_facets", 	&POA_Components::CCMObject::get_named_facets_skel},
      {"get_all_emitters", 	&POA_Components::CCMObject::get_all_emitters_skel},
      {"get_all_consumers", 	&POA_Components::CCMObject::get_all_consumers_skel},
      {"get_named_emitters", 	&POA_Components::CCMObject::get_named_emitters_skel},
      {"get_all_publishers", 	&POA_Components::CCMObject::get_all_publishers_skel},
      {"get_all_receptacles", 	&POA_Components::CCMObject::get_all_receptacles_skel},
      {"get_named_consumers", 	&POA_Components::CCMObject::get_named_consumers_skel},
      {"get_named_publishers", 	&POA_Components::CCMObject::get_named_publishers_skel},
      {"get_named_receptacles", 	&POA_Components::CCMObject::get_named_receptacles_skel},
      {"provide_facet", 	&POA_Components::CCMObject::provide_facet_skel},
      {"same_component", 	&POA_Components::CCMObject::same_component_skel},
      {"get_primary_key", 	&POA_Components::CCMObject::get_primary_key_skel},
      {"remove", 	&POA_Components::CCMObject::remove_skel},
      {"get_component_def", 	&POA_Components::CCMObject::get_component_def_skel},
      {"_interface",  &POA_Components::CCMObject::_interface_skel},
      {"get_consumer", 	&POA_Components::CCMObject::get_consumer_skel},
      {"disconnect", 	&POA_Components::CCMObject::disconnect_skel},
      {"connect", 	&POA_Components::CCMObject::connect_skel},
      {"_component",  &POA_Components::CCMObject::_component_skel},
      {"configuration_complete", 	&POA_Components::CCMObject::configuration_complete_skel},
      {"_non_existent",  &POA_Components::CCMObject::_non_existent_skel},
      {"_is_a",  &POA_Components::CCMObject::_is_a_skel},
      {"disconnect_consumer", 	&POA_Components::CCMObject::disconnect_consumer_skel},
      {"connect_consumer", 	&POA_Components::CCMObject::connect_consumer_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1, -15,  -2, -18,  -2, -20,  -2,   9,  -1,  10,  11,  12, 
       13,  14, -69,  17, -69, -68,  22,  23,  -1,  24,  25,  26,  27,  28, 
       -1,  -1,  29,  -1,  30,  -1,  -1,  31,  -1,  32,  -1,  -1,  33,  -1, 
       34,  35,  -1,  36,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  37,  -1, 
       38, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:56:15 */
static TAO_Components_CCMObject_Perfect_Hash_OpTable tao_Components_CCMObject_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_Components_CCMObject_get_component_def : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_CCMObject_get_component_def (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::CCMObject *tao_impl
    );

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::IRObject_ptr result);

  private:
    TAO_ServerRequestInfo_Components_CCMObject_get_component_def (const TAO_ServerRequestInfo_Components_CCMObject_get_component_def &);
    void operator= (const TAO_ServerRequestInfo_Components_CCMObject_get_component_def &);
    
  private:
    POA_Components::CCMObject *_tao_impl;
    ::CORBA::IRObject_ptr _result;
  };
  
    TAO_ServerRequestInfo_Components_CCMObject_get_component_def::TAO_ServerRequestInfo_Components_CCMObject_get_component_def (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::CCMObject *tao_impl
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_CCMObject_get_component_def::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return parameter_list;
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_CCMObject_get_component_def::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_CCMObject_get_component_def::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_CCMObject_get_component_def::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_CCMObject_get_component_def::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_CCMObject_get_component_def::result (::CORBA::IRObject_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_CCMObject_get_ccm_home : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_CCMObject_get_ccm_home (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::CCMObject *tao_impl
    );

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::CCMHome_ptr result);

  private:
    TAO_ServerRequestInfo_Components_CCMObject_get_ccm_home (const TAO_ServerRequestInfo_Components_CCMObject_get_ccm_home &);
    void operator= (const TAO_ServerRequestInfo_Components_CCMObject_get_ccm_home &);
    
  private:
    POA_Components::CCMObject *_tao_impl;
    ::Components::CCMHome_ptr _result;
  };
  
    TAO_ServerRequestInfo_Components_CCMObject_get_ccm_home::TAO_ServerRequestInfo_Components_CCMObject_get_ccm_home (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::CCMObject *tao_impl
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_CCMObject_get_ccm_home::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return parameter_list;
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_CCMObject_get_ccm_home::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_CCMObject_get_ccm_home::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_CCMObject_get_ccm_home::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_CCMObject_get_ccm_home::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_CCMObject_get_ccm_home::result (::Components::CCMHome_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_CCMObject_get_primary_key : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_CCMObject_get_primary_key (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::CCMObject *tao_impl
    );

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::PrimaryKeyBase * result);

  private:
    TAO_ServerRequestInfo_Components_CCMObject_get_primary_key (const TAO_ServerRequestInfo_Components_CCMObject_get_primary_key &);
    void operator= (const TAO_ServerRequestInfo_Components_CCMObject_get_primary_key &);
    
  private:
    POA_Components::CCMObject *_tao_impl;
    ::Components::PrimaryKeyBase * _result;
  };
  
    TAO_ServerRequestInfo_Components_CCMObject_get_primary_key::TAO_ServerRequestInfo_Components_CCMObject_get_primary_key (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::CCMObject *tao_impl
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_CCMObject_get_primary_key::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return parameter_list;
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_CCMObject_get_primary_key::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_CCMObject_get_primary_key_exceptiondata[] = 
  {
    Components::_tc_NoKeyAvailable
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_CCMObject_get_primary_key_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_CCMObject_get_primary_key::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_CCMObject_get_primary_key::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_CCMObject_get_primary_key::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_CCMObject_get_primary_key::result (::Components::PrimaryKeyBase * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_CCMObject_configuration_complete : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_CCMObject_configuration_complete (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::CCMObject *tao_impl
    );

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    
  private:
    TAO_ServerRequestInfo_Components_CCMObject_configuration_complete (const TAO_ServerRequestInfo_Components_CCMObject_configuration_complete &);
    void operator= (const TAO_ServerRequestInfo_Components_CCMObject_configuration_complete &);
    
  private:
    POA_Components::CCMObject *_tao_impl;
    
  };
  
    TAO_ServerRequestInfo_Components_CCMObject_configuration_complete::TAO_ServerRequestInfo_Components_CCMObject_configuration_complete (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::CCMObject *tao_impl
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_CCMObject_configuration_complete::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return parameter_list;
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_CCMObject_configuration_complete::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_CCMObject_configuration_complete_exceptiondata[] = 
  {
    Components::_tc_InvalidConfiguration
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_CCMObject_configuration_complete_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_CCMObject_configuration_complete::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_Components_CCMObject_configuration_complete::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_CCMObject_configuration_complete::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_Components_CCMObject_remove : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_CCMObject_remove (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::CCMObject *tao_impl
    );

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    
  private:
    TAO_ServerRequestInfo_Components_CCMObject_remove (const TAO_ServerRequestInfo_Components_CCMObject_remove &);
    void operator= (const TAO_ServerRequestInfo_Components_CCMObject_remove &);
    
  private:
    POA_Components::CCMObject *_tao_impl;
    
  };
  
    TAO_ServerRequestInfo_Components_CCMObject_remove::TAO_ServerRequestInfo_Components_CCMObject_remove (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::CCMObject *tao_impl
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_CCMObject_remove::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return parameter_list;
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_CCMObject_remove::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_CCMObject_remove_exceptiondata[] = 
  {
    Components::_tc_RemoveFailure
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_CCMObject_remove_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_CCMObject_remove::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_Components_CCMObject_remove::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_CCMObject_remove::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_Components_CCMObject_get_all_ports : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_CCMObject_get_all_ports (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::CCMObject *tao_impl
    );

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::ComponentPortDescription * result);

  private:
    TAO_ServerRequestInfo_Components_CCMObject_get_all_ports (const TAO_ServerRequestInfo_Components_CCMObject_get_all_ports &);
    void operator= (const TAO_ServerRequestInfo_Components_CCMObject_get_all_ports &);
    
  private:
    POA_Components::CCMObject *_tao_impl;
    ::Components::ComponentPortDescription * _result;
  };
  
    TAO_ServerRequestInfo_Components_CCMObject_get_all_ports::TAO_ServerRequestInfo_Components_CCMObject_get_all_ports (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::CCMObject *tao_impl
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_CCMObject_get_all_ports::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return parameter_list;
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_CCMObject_get_all_ports::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_CCMObject_get_all_ports::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_CCMObject_get_all_ports::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_CCMObject_get_all_ports::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_CCMObject_get_all_ports::result (::Components::ComponentPortDescription * result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_Components::_TAO_CCMObject_Strategized_Proxy_Broker *POA_Components::_TAO_CCMObject_Strategized_Proxy_Broker::the_TAO_CCMObject_Strategized_Proxy_Broker (void)
{
  static POA_Components::_TAO_CCMObject_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_Components::_TAO_CCMObject_Strategized_Proxy_Broker::_TAO_CCMObject_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_Components::_TAO_CCMObject_Strategized_Proxy_Broker::~_TAO_CCMObject_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    {
      delete this->proxy_cache_[i];
      
      // Hack to prevent bug mentioned in 1204. Refer to 1204
      // for details..
      this->proxy_cache_[i] = 0;
    }
  
}

Components::_TAO_CCMObject_Proxy_Impl&
POA_Components::_TAO_CCMObject_Strategized_Proxy_Broker::select_proxy (
    ::Components::CCMObject *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
    ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_Components::_TAO_CCMObject_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_Components::_TAO_CCMObject_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::Components::_TAO_CCMObject_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


Components::_TAO_CCMObject_Proxy_Broker *
Components__TAO_CCMObject_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_Components::_TAO_CCMObject_Strategized_Proxy_Broker::the_TAO_CCMObject_Strategized_Proxy_Broker();
}

int
Components__TAO_CCMObject_Proxy_Broker_Factory_Initializer (long)
{
  Components__TAO_CCMObject_Proxy_Broker_Factory_function_pointer = 
    Components__TAO_CCMObject_Proxy_Broker_Factory_function;
  
  return 0;
}

static int Components__TAO_CCMObject_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  Components__TAO_CCMObject_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, Components__TAO_CCMObject_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_Components::_TAO_CCMObject_ThruPOA_Proxy_Impl::_TAO_CCMObject_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

::CORBA::IRObject_ptr POA_Components::_TAO_CCMObject_ThruPOA_Proxy_Impl::get_component_def (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "get_component_def",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::CCMObject_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/CCMObject:1.0"
        )
    )->get_component_def (
        
      );
}

::Components::CCMHome_ptr POA_Components::_TAO_CCMObject_ThruPOA_Proxy_Impl::get_ccm_home (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "get_ccm_home",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::CCMObject_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/CCMObject:1.0"
        )
    )->get_ccm_home (
        
      );
}

::Components::PrimaryKeyBase * POA_Components::_TAO_CCMObject_ThruPOA_Proxy_Impl::get_primary_key (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::NoKeyAvailable
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "get_primary_key",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::CCMObject_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/CCMObject:1.0"
        )
    )->get_primary_key (
        
      );
}

void POA_Components::_TAO_CCMObject_ThruPOA_Proxy_Impl::configuration_complete (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidConfiguration
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "configuration_complete",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  ACE_reinterpret_cast (
      POA_Components::CCMObject_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/CCMObject:1.0"
        )
    )->configuration_complete (
        
      );
  return;
}

void POA_Components::_TAO_CCMObject_ThruPOA_Proxy_Impl::remove (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::RemoveFailure
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "remove",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  ACE_reinterpret_cast (
      POA_Components::CCMObject_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/CCMObject:1.0"
        )
    )->remove (
        
      );
  return;
}

::Components::ComponentPortDescription * POA_Components::_TAO_CCMObject_ThruPOA_Proxy_Impl::get_all_ports (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "get_all_ports",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::CCMObject_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/CCMObject:1.0"
        )
    )->get_all_ports (
        
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ss.cpp:100
POA_Components::CCMObject::CCMObject (void)
{
  this->optable_ = &tao_Components_CCMObject_optable;
}

POA_Components::CCMObject::CCMObject (const CCMObject& rhs)
  :  ACE_NESTED_CLASS (POA_Components,Navigation) (rhs),
    ACE_NESTED_CLASS (POA_Components,Receptacles) (rhs),
    ACE_NESTED_CLASS (POA_Components,Events) (rhs),
    TAO_ServantBase (rhs)
{}

POA_Components::CCMObject::~CCMObject (void)
{
}

void POA_Components::CCMObject::get_component_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::CCMObject *_tao_impl =
    ACE_static_cast (
        POA_Components::CCMObject *,
        _tao_servant
      );
  ::CORBA::IRObject_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_CCMObject_get_component_def _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->get_component_def (
                
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::CORBA::IRObject_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::CCMObject::get_ccm_home_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::CCMObject *_tao_impl =
    ACE_static_cast (
        POA_Components::CCMObject *,
        _tao_servant
      );
  ::Components::CCMHome_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_CCMObject_get_ccm_home _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->get_ccm_home (
                
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::CCMHome_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::CCMObject::get_primary_key_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::CCMObject *_tao_impl =
    ACE_static_cast (
        POA_Components::CCMObject *,
        _tao_servant
      );
  ::Components::PrimaryKeyBase_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_CCMObject_get_primary_key _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->get_primary_key (
                
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::PrimaryKeyBase * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::CCMObject::configuration_complete_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::CCMObject *_tao_impl =
    ACE_static_cast (
        POA_Components::CCMObject *,
        _tao_servant
      );
  _tao_server_request.argument_flag (0);
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_CCMObject_configuration_complete _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            
            _tao_impl->configuration_complete (
                
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::CCMObject::remove_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::CCMObject *_tao_impl =
    ACE_static_cast (
        POA_Components::CCMObject *,
        _tao_servant
      );
  _tao_server_request.argument_flag (0);
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_CCMObject_remove _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            
            _tao_impl->remove (
                
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::CCMObject::get_all_ports_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::CCMObject *_tao_impl =
    ACE_static_cast (
        POA_Components::CCMObject *,
        _tao_servant
      );
  ::Components::ComponentPortDescription_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_CCMObject_get_all_ports _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->get_all_ports (
                
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::ComponentPortDescription * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::CCMObject::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::CCMObject *_tao_impl = (POA_Components::CCMObject *) _tao_servant;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::CCMObject::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::CCMObject *_tao_impl = (POA_Components::CCMObject *) _tao_servant;
  CORBA::Boolean _tao_retval =
    _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::CCMObject::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::CCMObject *_tao_impl = (POA_Components::CCMObject *) _tao_servant;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = 
        _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_Components::CCMObject::_component_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::CCMObject *_tao_impl = (POA_Components::CCMObject *) _tao_object_reference;
  CORBA::Object_var _tao_retval =
    _tao_impl->_get_component (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << _tao_retval._retn ()))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_Components::CCMObject::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  const char *base_id = "IDL:org.omg/CORBA/Object:1.0";
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/CCMObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/Navigation:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/Receptacles:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/Events:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_Components::CCMObject::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/Components/CCMObject:1.0") == 0)
    return ACE_static_cast (POA_Components::CCMObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/Components/Navigation:1.0") == 0)
    return ACE_static_cast (POA_Components::Navigation_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/Components/Receptacles:1.0") == 0)
    return ACE_static_cast (POA_Components::Receptacles_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/Components/Events:1.0") == 0)
    return ACE_static_cast (POA_Components::Events_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_Components::CCMObject::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/CCMObject:1.0";
}

void POA_Components::CCMObject::_dispatch (
    TAO_ServerRequest &req,
    void *servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


Components::CCMObject*
POA_Components::CCMObject::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  
  (void) safe_stub.release ();
  
  return ::Components::CCMObject::_unchecked_narrow (obj.in ());
}


class TAO_Components_Deployment_ComponentInstallation_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:56:15 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_Components_Deployment_ComponentInstallation_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_Components_Deployment_ComponentInstallation_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24,  0,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24,  0,
     24, 24, 24,  0, 24,  5, 24,  5, 24, 24,
     24, 24, 24, 24, 24, 24, 24,  0, 24,  0,
     24, 24, 24,  0, 24, 24, 24, 24, 24, 24,
     24, 24, 24,  5, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24,
#else
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24,  0, 24,  0, 24, 24,
     24,  0, 24,  5, 24,  5, 24, 24,  0, 24,
      0, 24, 24, 24,  0, 24,  5, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_Components_Deployment_ComponentInstallation_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 8,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 18,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 23,
      HASH_VALUE_RANGE = 19,
      DUPLICATES = 0,
      WORDLIST_SIZE = 13
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_Components::Deployment::ComponentInstallation::_is_a_skel},
      {"remove", 	&POA_Components::Deployment::ComponentInstallation::remove_skel},
      {"replace", 	&POA_Components::Deployment::ComponentInstallation::replace_skel},
      {"",0},{"",0},
      {"_interface",  &POA_Components::Deployment::ComponentInstallation::_interface_skel},
      {"",0},
      {"install", 	&POA_Components::Deployment::ComponentInstallation::install_skel},
      {"",0},{"",0},
      {"_component",  &POA_Components::Deployment::ComponentInstallation::_component_skel},
      {"",0},{"",0},
      {"_non_existent",  &POA_Components::Deployment::ComponentInstallation::_non_existent_skel},
      {"",0},{"",0},{"",0},{"",0},
      {"get_implementation", 	&POA_Components::Deployment::ComponentInstallation::get_implementation_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 22:56:15 */
static TAO_Components_Deployment_ComponentInstallation_Perfect_Hash_OpTable tao_Components_Deployment_ComponentInstallation_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_install : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_install (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Deployment::ComponentInstallation *tao_impl
    ,
    const char * implUUID,
    const char * component_loc);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    
  private:
    TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_install (const TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_install &);
    void operator= (const TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_install &);
    
  private:
    POA_Components::Deployment::ComponentInstallation *_tao_impl;
    const char * implUUID_;
    const char * component_loc_;
    
  };
  
    TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_install::TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_install (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Deployment::ComponentInstallation *tao_impl,
      const char * implUUID,
      const char * component_loc
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        implUUID_ (implUUID),
        component_loc_ (component_loc)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_install::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (2);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<= implUUID_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
        (*parameter_list)[len].argument <<= component_loc_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_install::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_ComponentInstallation_install_exceptiondata[] = 
  {
    Components::Deployment::_tc_InvalidLocation,
    Components::Deployment::_tc_InstallationFailure
  };
  
  exception_list->length (2);
  for (CORBA::ULong i = 0; i < 2; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_ComponentInstallation_install_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_install::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_install::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_install::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_replace : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_replace (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Deployment::ComponentInstallation *tao_impl
    ,
    const char * implUUID,
    const char * component_loc);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    
  private:
    TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_replace (const TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_replace &);
    void operator= (const TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_replace &);
    
  private:
    POA_Components::Deployment::ComponentInstallation *_tao_impl;
    const char * implUUID_;
    const char * component_loc_;
    
  };
  
    TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_replace::TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_replace (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Deployment::ComponentInstallation *tao_impl,
      const char * implUUID,
      const char * component_loc
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        implUUID_ (implUUID),
        component_loc_ (component_loc)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_replace::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (2);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<= implUUID_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
        (*parameter_list)[len].argument <<= component_loc_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_replace::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_ComponentInstallation_replace_exceptiondata[] = 
  {
    Components::Deployment::_tc_InvalidLocation,
    Components::Deployment::_tc_InstallationFailure
  };
  
  exception_list->length (2);
  for (CORBA::ULong i = 0; i < 2; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_ComponentInstallation_replace_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_replace::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_replace::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_replace::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_remove : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_remove (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Deployment::ComponentInstallation *tao_impl
    ,
    const char * implUUID);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    
  private:
    TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_remove (const TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_remove &);
    void operator= (const TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_remove &);
    
  private:
    POA_Components::Deployment::ComponentInstallation *_tao_impl;
    const char * implUUID_;
    
  };
  
    TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_remove::TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_remove (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Deployment::ComponentInstallation *tao_impl,
      const char * implUUID
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        implUUID_ (implUUID)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_remove::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (1);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<= implUUID_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_remove::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_ComponentInstallation_remove_exceptiondata[] = 
  {
    Components::Deployment::_tc_UnknownImplId,
    Components::_tc_RemoveFailure
  };
  
  exception_list->length (2);
  for (CORBA::ULong i = 0; i < 2; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_ComponentInstallation_remove_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_remove::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_remove::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_remove::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_get_implementation : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_get_implementation (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Deployment::ComponentInstallation *tao_impl
    ,
    const char * implUUID);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (char * result);

  private:
    TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_get_implementation (const TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_get_implementation &);
    void operator= (const TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_get_implementation &);
    
  private:
    POA_Components::Deployment::ComponentInstallation *_tao_impl;
    const char * implUUID_;
    char * _result;
  };
  
    TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_get_implementation::TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_get_implementation (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Deployment::ComponentInstallation *tao_impl,
      const char * implUUID
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        implUUID_ (implUUID)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_get_implementation::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (1);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<= implUUID_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_get_implementation::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_ComponentInstallation_get_implementation_exceptiondata[] = 
  {
    Components::Deployment::_tc_UnknownImplId,
    Components::Deployment::_tc_InstallationFailure
  };
  
  exception_list->length (2);
  for (CORBA::ULong i = 0; i < 2; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_ComponentInstallation_get_implementation_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_get_implementation::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_get_implementation::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_get_implementation::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_get_implementation::result (char * result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_Components::Deployment::_TAO_ComponentInstallation_Strategized_Proxy_Broker *POA_Components::Deployment::_TAO_ComponentInstallation_Strategized_Proxy_Broker::the_TAO_ComponentInstallation_Strategized_Proxy_Broker (void)
{
  static POA_Components::Deployment::_TAO_ComponentInstallation_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_Components::Deployment::_TAO_ComponentInstallation_Strategized_Proxy_Broker::_TAO_ComponentInstallation_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_Components::Deployment::_TAO_ComponentInstallation_Strategized_Proxy_Broker::~_TAO_ComponentInstallation_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    {
      delete this->proxy_cache_[i];
      
      // Hack to prevent bug mentioned in 1204. Refer to 1204
      // for details..
      this->proxy_cache_[i] = 0;
    }
  
}

Components::Deployment::_TAO_ComponentInstallation_Proxy_Impl&
POA_Components::Deployment::_TAO_ComponentInstallation_Strategized_Proxy_Broker::select_proxy (
    ::Components::Deployment::ComponentInstallation *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
    ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_Components::Deployment::_TAO_ComponentInstallation_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_Components::Deployment::_TAO_ComponentInstallation_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::Components::Deployment::_TAO_ComponentInstallation_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


Components::Deployment::_TAO_ComponentInstallation_Proxy_Broker *
Components_Deployment__TAO_ComponentInstallation_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_Components::Deployment::_TAO_ComponentInstallation_Strategized_Proxy_Broker::the_TAO_ComponentInstallation_Strategized_Proxy_Broker();
}

int
Components_Deployment__TAO_ComponentInstallation_Proxy_Broker_Factory_Initializer (long)
{
  Components_Deployment__TAO_ComponentInstallation_Proxy_Broker_Factory_function_pointer = 
    Components_Deployment__TAO_ComponentInstallation_Proxy_Broker_Factory_function;
  
  return 0;
}

static int Components_Deployment__TAO_ComponentInstallation_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  Components_Deployment__TAO_ComponentInstallation_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, Components_Deployment__TAO_ComponentInstallation_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_Components::Deployment::_TAO_ComponentInstallation_ThruPOA_Proxy_Impl::_TAO_ComponentInstallation_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

void POA_Components::Deployment::_TAO_ComponentInstallation_ThruPOA_Proxy_Impl::install (
    CORBA_Object *_collocated_tao_target_,
    const char * implUUID,
    const char * component_loc
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::Deployment::InvalidLocation
    , Components::Deployment::InstallationFailure
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "install",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  ACE_reinterpret_cast (
      POA_Components::Deployment::ComponentInstallation_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Deployment/ComponentInstallation:1.0"
        )
    )->install (
        implUUID,
        component_loc
      );
  return;
}

void POA_Components::Deployment::_TAO_ComponentInstallation_ThruPOA_Proxy_Impl::replace (
    CORBA_Object *_collocated_tao_target_,
    const char * implUUID,
    const char * component_loc
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::Deployment::InvalidLocation
    , Components::Deployment::InstallationFailure
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "replace",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  ACE_reinterpret_cast (
      POA_Components::Deployment::ComponentInstallation_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Deployment/ComponentInstallation:1.0"
        )
    )->replace (
        implUUID,
        component_loc
      );
  return;
}

void POA_Components::Deployment::_TAO_ComponentInstallation_ThruPOA_Proxy_Impl::remove (
    CORBA_Object *_collocated_tao_target_,
    const char * implUUID
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::Deployment::UnknownImplId
    , Components::RemoveFailure
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "remove",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  ACE_reinterpret_cast (
      POA_Components::Deployment::ComponentInstallation_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Deployment/ComponentInstallation:1.0"
        )
    )->remove (
        implUUID
      );
  return;
}

char * POA_Components::Deployment::_TAO_ComponentInstallation_ThruPOA_Proxy_Impl::get_implementation (
    CORBA_Object *_collocated_tao_target_,
    const char * implUUID
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::Deployment::UnknownImplId
    , Components::Deployment::InstallationFailure
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "get_implementation",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::Deployment::ComponentInstallation_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Deployment/ComponentInstallation:1.0"
        )
    )->get_implementation (
        implUUID
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ss.cpp:100
POA_Components::Deployment::ComponentInstallation::ComponentInstallation (void)
{
  this->optable_ = &tao_Components_Deployment_ComponentInstallation_optable;
}

POA_Components::Deployment::ComponentInstallation::ComponentInstallation (const ComponentInstallation& rhs)
  :  TAO_ServantBase (rhs)
{}

POA_Components::Deployment::ComponentInstallation::~ComponentInstallation (void)
{
}

void POA_Components::Deployment::ComponentInstallation::install_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Deployment::ComponentInstallation *_tao_impl =
    ACE_static_cast (
        POA_Components::Deployment::ComponentInstallation *,
        _tao_servant
      );
  _tao_server_request.argument_flag (0);
    CORBA::String_var implUUID;
  CORBA::String_var component_loc;
  if (!(
    (_tao_in >> implUUID.out ()) &&
    (_tao_in >> component_loc.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_install _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      implUUID.in (),
      component_loc.in ()
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            
            _tao_impl->install (
                implUUID.in (),
                component_loc.in ()
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Deployment::ComponentInstallation::replace_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Deployment::ComponentInstallation *_tao_impl =
    ACE_static_cast (
        POA_Components::Deployment::ComponentInstallation *,
        _tao_servant
      );
  _tao_server_request.argument_flag (0);
    CORBA::String_var implUUID;
  CORBA::String_var component_loc;
  if (!(
    (_tao_in >> implUUID.out ()) &&
    (_tao_in >> component_loc.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_replace _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      implUUID.in (),
      component_loc.in ()
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            
            _tao_impl->replace (
                implUUID.in (),
                component_loc.in ()
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Deployment::ComponentInstallation::remove_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Deployment::ComponentInstallation *_tao_impl =
    ACE_static_cast (
        POA_Components::Deployment::ComponentInstallation *,
        _tao_servant
      );
  _tao_server_request.argument_flag (0);
    CORBA::String_var implUUID;
  if (!(
    (_tao_in >> implUUID.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_remove _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      implUUID.in ()
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            
            _tao_impl->remove (
                implUUID.in ()
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Deployment::ComponentInstallation::get_implementation_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Deployment::ComponentInstallation *_tao_impl =
    ACE_static_cast (
        POA_Components::Deployment::ComponentInstallation *,
        _tao_servant
      );
  CORBA::String_var _tao_retval;
  CORBA::String_var implUUID;
  if (!(
    (_tao_in >> implUUID.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Deployment_ComponentInstallation_get_implementation _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      implUUID.in ()
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->get_implementation (
                implUUID.in ()
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          char * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Deployment::ComponentInstallation::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Deployment::ComponentInstallation *_tao_impl = (POA_Components::Deployment::ComponentInstallation *) _tao_servant;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::Deployment::ComponentInstallation::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Deployment::ComponentInstallation *_tao_impl = (POA_Components::Deployment::ComponentInstallation *) _tao_servant;
  CORBA::Boolean _tao_retval =
    _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::Deployment::ComponentInstallation::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Deployment::ComponentInstallation *_tao_impl = (POA_Components::Deployment::ComponentInstallation *) _tao_servant;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = 
        _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_Components::Deployment::ComponentInstallation::_component_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Deployment::ComponentInstallation *_tao_impl = (POA_Components::Deployment::ComponentInstallation *) _tao_object_reference;
  CORBA::Object_var _tao_retval =
    _tao_impl->_get_component (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << _tao_retval._retn ()))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_Components::Deployment::ComponentInstallation::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  const char *base_id = "IDL:org.omg/CORBA/Object:1.0";
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/Deployment/ComponentInstallation:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_Components::Deployment::ComponentInstallation::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/Components/Deployment/ComponentInstallation:1.0") == 0)
    return ACE_static_cast (POA_Components::Deployment::ComponentInstallation_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_Components::Deployment::ComponentInstallation::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/Deployment/ComponentInstallation:1.0";
}

void POA_Components::Deployment::ComponentInstallation::_dispatch (
    TAO_ServerRequest &req,
    void *servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


Components::Deployment::ComponentInstallation*
POA_Components::Deployment::ComponentInstallation::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  
  (void) safe_stub.release ();
  
  return ::Components::Deployment::ComponentInstallation::_unchecked_narrow (obj.in ());
}


class TAO_Components_Deployment_Assembly_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:56:15 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_Components_Deployment_Assembly_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_Components_Deployment_Assembly_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16,  0,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16,  2,
      0, 16,  0,  5, 16,  0, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16,  0,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16,  0, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16,
#else
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16,  0, 16,  2,  0, 16,
      0,  5, 16,  0, 16, 16, 16, 16, 16, 16,
      0, 16, 16, 16, 16, 16,  0, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_Components_Deployment_Assembly_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 7,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 15,
      HASH_VALUE_RANGE = 11,
      DUPLICATES = 0,
      WORDLIST_SIZE = 12
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"build", 	&POA_Components::Deployment::Assembly::build_skel},
      {"",0},
      {"_is_a",  &POA_Components::Deployment::Assembly::_is_a_skel},
      {"",0},
      {"tear_down", 	&POA_Components::Deployment::Assembly::tear_down_skel},
      {"_component",  &POA_Components::Deployment::Assembly::_component_skel},
      {"",0},{"",0},
      {"_non_existent",  &POA_Components::Deployment::Assembly::_non_existent_skel},
      {"get_state", 	&POA_Components::Deployment::Assembly::get_state_skel},
      {"_interface",  &POA_Components::Deployment::Assembly::_interface_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 22:56:15 */
static TAO_Components_Deployment_Assembly_Perfect_Hash_OpTable tao_Components_Deployment_Assembly_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_Components_Deployment_Assembly_build : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Deployment_Assembly_build (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Deployment::Assembly *tao_impl
    );

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    
  private:
    TAO_ServerRequestInfo_Components_Deployment_Assembly_build (const TAO_ServerRequestInfo_Components_Deployment_Assembly_build &);
    void operator= (const TAO_ServerRequestInfo_Components_Deployment_Assembly_build &);
    
  private:
    POA_Components::Deployment::Assembly *_tao_impl;
    
  };
  
    TAO_ServerRequestInfo_Components_Deployment_Assembly_build::TAO_ServerRequestInfo_Components_Deployment_Assembly_build (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Deployment::Assembly *tao_impl
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Deployment_Assembly_build::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return parameter_list;
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Deployment_Assembly_build::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Deployment_Assembly_build::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_Components_Deployment_Assembly_build::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Deployment_Assembly_build::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_Components_Deployment_Assembly_tear_down : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Deployment_Assembly_tear_down (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Deployment::Assembly *tao_impl
    );

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    
  private:
    TAO_ServerRequestInfo_Components_Deployment_Assembly_tear_down (const TAO_ServerRequestInfo_Components_Deployment_Assembly_tear_down &);
    void operator= (const TAO_ServerRequestInfo_Components_Deployment_Assembly_tear_down &);
    
  private:
    POA_Components::Deployment::Assembly *_tao_impl;
    
  };
  
    TAO_ServerRequestInfo_Components_Deployment_Assembly_tear_down::TAO_ServerRequestInfo_Components_Deployment_Assembly_tear_down (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Deployment::Assembly *tao_impl
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Deployment_Assembly_tear_down::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return parameter_list;
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Deployment_Assembly_tear_down::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_Assembly_tear_down_exceptiondata[] = 
  {
    Components::_tc_RemoveFailure
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_Assembly_tear_down_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Deployment_Assembly_tear_down::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_Components_Deployment_Assembly_tear_down::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Deployment_Assembly_tear_down::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_Components_Deployment_Assembly_get_state : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Deployment_Assembly_get_state (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Deployment::Assembly *tao_impl
    );

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::Deployment::AssemblyState result);

  private:
    TAO_ServerRequestInfo_Components_Deployment_Assembly_get_state (const TAO_ServerRequestInfo_Components_Deployment_Assembly_get_state &);
    void operator= (const TAO_ServerRequestInfo_Components_Deployment_Assembly_get_state &);
    
  private:
    POA_Components::Deployment::Assembly *_tao_impl;
    ::Components::Deployment::AssemblyState _result;
  };
  
    TAO_ServerRequestInfo_Components_Deployment_Assembly_get_state::TAO_ServerRequestInfo_Components_Deployment_Assembly_get_state (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Deployment::Assembly *tao_impl
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Deployment_Assembly_get_state::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return parameter_list;
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Deployment_Assembly_get_state::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Deployment_Assembly_get_state::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_Deployment_Assembly_get_state::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Deployment_Assembly_get_state::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_Deployment_Assembly_get_state::result (::Components::Deployment::AssemblyState result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_Components::Deployment::_TAO_Assembly_Strategized_Proxy_Broker *POA_Components::Deployment::_TAO_Assembly_Strategized_Proxy_Broker::the_TAO_Assembly_Strategized_Proxy_Broker (void)
{
  static POA_Components::Deployment::_TAO_Assembly_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_Components::Deployment::_TAO_Assembly_Strategized_Proxy_Broker::_TAO_Assembly_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_Components::Deployment::_TAO_Assembly_Strategized_Proxy_Broker::~_TAO_Assembly_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    {
      delete this->proxy_cache_[i];
      
      // Hack to prevent bug mentioned in 1204. Refer to 1204
      // for details..
      this->proxy_cache_[i] = 0;
    }
  
}

Components::Deployment::_TAO_Assembly_Proxy_Impl&
POA_Components::Deployment::_TAO_Assembly_Strategized_Proxy_Broker::select_proxy (
    ::Components::Deployment::Assembly *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
    ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_Components::Deployment::_TAO_Assembly_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_Components::Deployment::_TAO_Assembly_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::Components::Deployment::_TAO_Assembly_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


Components::Deployment::_TAO_Assembly_Proxy_Broker *
Components_Deployment__TAO_Assembly_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_Components::Deployment::_TAO_Assembly_Strategized_Proxy_Broker::the_TAO_Assembly_Strategized_Proxy_Broker();
}

int
Components_Deployment__TAO_Assembly_Proxy_Broker_Factory_Initializer (long)
{
  Components_Deployment__TAO_Assembly_Proxy_Broker_Factory_function_pointer = 
    Components_Deployment__TAO_Assembly_Proxy_Broker_Factory_function;
  
  return 0;
}

static int Components_Deployment__TAO_Assembly_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  Components_Deployment__TAO_Assembly_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, Components_Deployment__TAO_Assembly_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_Components::Deployment::_TAO_Assembly_ThruPOA_Proxy_Impl::_TAO_Assembly_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

void POA_Components::Deployment::_TAO_Assembly_ThruPOA_Proxy_Impl::build (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "build",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  ACE_reinterpret_cast (
      POA_Components::Deployment::Assembly_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Deployment/Assembly:1.0"
        )
    )->build (
        
      );
  return;
}

void POA_Components::Deployment::_TAO_Assembly_ThruPOA_Proxy_Impl::tear_down (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::RemoveFailure
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "tear_down",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  ACE_reinterpret_cast (
      POA_Components::Deployment::Assembly_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Deployment/Assembly:1.0"
        )
    )->tear_down (
        
      );
  return;
}

::Components::Deployment::AssemblyState POA_Components::Deployment::_TAO_Assembly_ThruPOA_Proxy_Impl::get_state (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "get_state",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::Deployment::Assembly_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Deployment/Assembly:1.0"
        )
    )->get_state (
        
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ss.cpp:100
POA_Components::Deployment::Assembly::Assembly (void)
{
  this->optable_ = &tao_Components_Deployment_Assembly_optable;
}

POA_Components::Deployment::Assembly::Assembly (const Assembly& rhs)
  :  TAO_ServantBase (rhs)
{}

POA_Components::Deployment::Assembly::~Assembly (void)
{
}

void POA_Components::Deployment::Assembly::build_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Deployment::Assembly *_tao_impl =
    ACE_static_cast (
        POA_Components::Deployment::Assembly *,
        _tao_servant
      );
  _tao_server_request.argument_flag (0);
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Deployment_Assembly_build _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            
            _tao_impl->build (
                
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Deployment::Assembly::tear_down_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Deployment::Assembly *_tao_impl =
    ACE_static_cast (
        POA_Components::Deployment::Assembly *,
        _tao_servant
      );
  _tao_server_request.argument_flag (0);
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Deployment_Assembly_tear_down _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            
            _tao_impl->tear_down (
                
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Deployment::Assembly::get_state_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Deployment::Assembly *_tao_impl =
    ACE_static_cast (
        POA_Components::Deployment::Assembly *,
        _tao_servant
      );
  ::Components::Deployment::AssemblyState _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Deployment_Assembly_get_state _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->get_state (
                
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::Deployment::AssemblyState _tao_retval_info = _tao_retval;
          _tao_ri.result (_tao_retval_info);
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval)
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Deployment::Assembly::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Deployment::Assembly *_tao_impl = (POA_Components::Deployment::Assembly *) _tao_servant;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::Deployment::Assembly::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Deployment::Assembly *_tao_impl = (POA_Components::Deployment::Assembly *) _tao_servant;
  CORBA::Boolean _tao_retval =
    _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::Deployment::Assembly::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Deployment::Assembly *_tao_impl = (POA_Components::Deployment::Assembly *) _tao_servant;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = 
        _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_Components::Deployment::Assembly::_component_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Deployment::Assembly *_tao_impl = (POA_Components::Deployment::Assembly *) _tao_object_reference;
  CORBA::Object_var _tao_retval =
    _tao_impl->_get_component (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << _tao_retval._retn ()))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_Components::Deployment::Assembly::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  const char *base_id = "IDL:org.omg/CORBA/Object:1.0";
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/Deployment/Assembly:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_Components::Deployment::Assembly::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/Components/Deployment/Assembly:1.0") == 0)
    return ACE_static_cast (POA_Components::Deployment::Assembly_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_Components::Deployment::Assembly::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/Deployment/Assembly:1.0";
}

void POA_Components::Deployment::Assembly::_dispatch (
    TAO_ServerRequest &req,
    void *servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


Components::Deployment::Assembly*
POA_Components::Deployment::Assembly::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  
  (void) safe_stub.release ();
  
  return ::Components::Deployment::Assembly::_unchecked_narrow (obj.in ());
}


class TAO_Components_Deployment_AssemblyFactory_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:56:15 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_Components_Deployment_AssemblyFactory_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_Components_Deployment_AssemblyFactory_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16,  0,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16,  0,
     16,  0,  0,  5, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16,  0, 16, 16,
     16,  0, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16,  0, 16, 16, 16, 16,  0, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16,
#else
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16,  0, 16,  0, 16,  0,
      0,  5, 16, 16, 16, 16, 16, 16,  0, 16,
     16, 16,  0, 16, 16, 16,  0, 16, 16, 16,
     16,  0, 16, 16, 16, 16, 16, 16,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_Components_Deployment_AssemblyFactory_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 7,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 15,
      HASH_VALUE_RANGE = 11,
      DUPLICATES = 0,
      WORDLIST_SIZE = 12
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_Components::Deployment::AssemblyFactory::_is_a_skel},
      {"lookup", 	&POA_Components::Deployment::AssemblyFactory::lookup_skel},
      {"destroy", 	&POA_Components::Deployment::AssemblyFactory::destroy_skel},
      {"",0},{"",0},
      {"_component",  &POA_Components::Deployment::AssemblyFactory::_component_skel},
      {"create", 	&POA_Components::Deployment::AssemblyFactory::create_skel},
      {"",0},
      {"_non_existent",  &POA_Components::Deployment::AssemblyFactory::_non_existent_skel},
      {"",0},
      {"_interface",  &POA_Components::Deployment::AssemblyFactory::_interface_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 22:56:15 */
static TAO_Components_Deployment_AssemblyFactory_Perfect_Hash_OpTable tao_Components_Deployment_AssemblyFactory_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_create : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_create (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Deployment::AssemblyFactory *tao_impl
    ,
    const char * assembly_loc);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::Cookie * result);

  private:
    TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_create (const TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_create &);
    void operator= (const TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_create &);
    
  private:
    POA_Components::Deployment::AssemblyFactory *_tao_impl;
    const char * assembly_loc_;
    ::Components::Cookie * _result;
  };
  
    TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_create::TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_create (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Deployment::AssemblyFactory *tao_impl,
      const char * assembly_loc
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        assembly_loc_ (assembly_loc)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_create::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (1);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<= assembly_loc_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_create::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_AssemblyFactory_create_exceptiondata[] = 
  {
    Components::Deployment::_tc_InvalidLocation,
    Components::_tc_CreateFailure
  };
  
  exception_list->length (2);
  for (CORBA::ULong i = 0; i < 2; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_AssemblyFactory_create_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_create::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_create::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_create::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_create::result (::Components::Cookie * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_lookup : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_lookup (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Deployment::AssemblyFactory *tao_impl
    ,
    Components::Cookie * c);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::Deployment::Assembly_ptr result);

  private:
    TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_lookup (const TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_lookup &);
    void operator= (const TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_lookup &);
    
  private:
    POA_Components::Deployment::AssemblyFactory *_tao_impl;
    Components::Cookie * c_;
    ::Components::Deployment::Assembly_ptr _result;
  };
  
    TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_lookup::TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_lookup (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Deployment::AssemblyFactory *tao_impl,
      Components::Cookie * c
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        c_ (c)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_lookup::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return parameter_list;
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_lookup::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_AssemblyFactory_lookup_exceptiondata[] = 
  {
    Components::Deployment::_tc_InvalidAssembly
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_AssemblyFactory_lookup_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_lookup::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_lookup::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_lookup::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_lookup::result (::Components::Deployment::Assembly_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_destroy : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_destroy (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Deployment::AssemblyFactory *tao_impl
    ,
    Components::Cookie * c);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    
  private:
    TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_destroy (const TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_destroy &);
    void operator= (const TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_destroy &);
    
  private:
    POA_Components::Deployment::AssemblyFactory *_tao_impl;
    Components::Cookie * c_;
    
  };
  
    TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_destroy::TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_destroy (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Deployment::AssemblyFactory *tao_impl,
      Components::Cookie * c
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        c_ (c)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_destroy::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return parameter_list;
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_destroy::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_AssemblyFactory_destroy_exceptiondata[] = 
  {
    Components::Deployment::_tc_InvalidAssembly,
    Components::_tc_RemoveFailure
  };
  
  exception_list->length (2);
  for (CORBA::ULong i = 0; i < 2; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_AssemblyFactory_destroy_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_destroy::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_destroy::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_destroy::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_Components::Deployment::_TAO_AssemblyFactory_Strategized_Proxy_Broker *POA_Components::Deployment::_TAO_AssemblyFactory_Strategized_Proxy_Broker::the_TAO_AssemblyFactory_Strategized_Proxy_Broker (void)
{
  static POA_Components::Deployment::_TAO_AssemblyFactory_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_Components::Deployment::_TAO_AssemblyFactory_Strategized_Proxy_Broker::_TAO_AssemblyFactory_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_Components::Deployment::_TAO_AssemblyFactory_Strategized_Proxy_Broker::~_TAO_AssemblyFactory_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    {
      delete this->proxy_cache_[i];
      
      // Hack to prevent bug mentioned in 1204. Refer to 1204
      // for details..
      this->proxy_cache_[i] = 0;
    }
  
}

Components::Deployment::_TAO_AssemblyFactory_Proxy_Impl&
POA_Components::Deployment::_TAO_AssemblyFactory_Strategized_Proxy_Broker::select_proxy (
    ::Components::Deployment::AssemblyFactory *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
    ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_Components::Deployment::_TAO_AssemblyFactory_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_Components::Deployment::_TAO_AssemblyFactory_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::Components::Deployment::_TAO_AssemblyFactory_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


Components::Deployment::_TAO_AssemblyFactory_Proxy_Broker *
Components_Deployment__TAO_AssemblyFactory_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_Components::Deployment::_TAO_AssemblyFactory_Strategized_Proxy_Broker::the_TAO_AssemblyFactory_Strategized_Proxy_Broker();
}

int
Components_Deployment__TAO_AssemblyFactory_Proxy_Broker_Factory_Initializer (long)
{
  Components_Deployment__TAO_AssemblyFactory_Proxy_Broker_Factory_function_pointer = 
    Components_Deployment__TAO_AssemblyFactory_Proxy_Broker_Factory_function;
  
  return 0;
}

static int Components_Deployment__TAO_AssemblyFactory_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  Components_Deployment__TAO_AssemblyFactory_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, Components_Deployment__TAO_AssemblyFactory_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_Components::Deployment::_TAO_AssemblyFactory_ThruPOA_Proxy_Impl::_TAO_AssemblyFactory_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

::Components::Cookie * POA_Components::Deployment::_TAO_AssemblyFactory_ThruPOA_Proxy_Impl::create (
    CORBA_Object *_collocated_tao_target_,
    const char * assembly_loc
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::Deployment::InvalidLocation
    , Components::CreateFailure
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::Deployment::AssemblyFactory_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Deployment/AssemblyFactory:1.0"
        )
    )->create (
        assembly_loc
      );
}

::Components::Deployment::Assembly_ptr POA_Components::Deployment::_TAO_AssemblyFactory_ThruPOA_Proxy_Impl::lookup (
    CORBA_Object *_collocated_tao_target_,
    Components::Cookie * c
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::Deployment::InvalidAssembly
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "lookup",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::Deployment::AssemblyFactory_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Deployment/AssemblyFactory:1.0"
        )
    )->lookup (
        c
      );
}

void POA_Components::Deployment::_TAO_AssemblyFactory_ThruPOA_Proxy_Impl::destroy (
    CORBA_Object *_collocated_tao_target_,
    Components::Cookie * c
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::Deployment::InvalidAssembly
    , Components::RemoveFailure
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "destroy",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  ACE_reinterpret_cast (
      POA_Components::Deployment::AssemblyFactory_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Deployment/AssemblyFactory:1.0"
        )
    )->destroy (
        c
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ss.cpp:100
POA_Components::Deployment::AssemblyFactory::AssemblyFactory (void)
{
  this->optable_ = &tao_Components_Deployment_AssemblyFactory_optable;
}

POA_Components::Deployment::AssemblyFactory::AssemblyFactory (const AssemblyFactory& rhs)
  :  TAO_ServantBase (rhs)
{}

POA_Components::Deployment::AssemblyFactory::~AssemblyFactory (void)
{
}

void POA_Components::Deployment::AssemblyFactory::create_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Deployment::AssemblyFactory *_tao_impl =
    ACE_static_cast (
        POA_Components::Deployment::AssemblyFactory *,
        _tao_servant
      );
  ::Components::Cookie_var _tao_retval;
  CORBA::String_var assembly_loc;
  if (!(
    (_tao_in >> assembly_loc.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_create _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      assembly_loc.in ()
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->create (
                assembly_loc.in ()
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::Cookie * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Deployment::AssemblyFactory::lookup_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Deployment::AssemblyFactory *_tao_impl =
    ACE_static_cast (
        POA_Components::Deployment::AssemblyFactory *,
        _tao_servant
      );
  ::Components::Deployment::Assembly_var _tao_retval;
  Components::Cookie_var c;
  if (!(
    (_tao_in >> c.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_lookup _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      c.in ()
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->lookup (
                c.in ()
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::Deployment::Assembly_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Deployment::AssemblyFactory::destroy_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Deployment::AssemblyFactory *_tao_impl =
    ACE_static_cast (
        POA_Components::Deployment::AssemblyFactory *,
        _tao_servant
      );
  _tao_server_request.argument_flag (0);
    Components::Cookie_var c;
  if (!(
    (_tao_in >> c.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Deployment_AssemblyFactory_destroy _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      c.in ()
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            
            _tao_impl->destroy (
                c.in ()
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Deployment::AssemblyFactory::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Deployment::AssemblyFactory *_tao_impl = (POA_Components::Deployment::AssemblyFactory *) _tao_servant;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::Deployment::AssemblyFactory::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Deployment::AssemblyFactory *_tao_impl = (POA_Components::Deployment::AssemblyFactory *) _tao_servant;
  CORBA::Boolean _tao_retval =
    _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::Deployment::AssemblyFactory::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Deployment::AssemblyFactory *_tao_impl = (POA_Components::Deployment::AssemblyFactory *) _tao_servant;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = 
        _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_Components::Deployment::AssemblyFactory::_component_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Deployment::AssemblyFactory *_tao_impl = (POA_Components::Deployment::AssemblyFactory *) _tao_object_reference;
  CORBA::Object_var _tao_retval =
    _tao_impl->_get_component (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << _tao_retval._retn ()))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_Components::Deployment::AssemblyFactory::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  const char *base_id = "IDL:org.omg/CORBA/Object:1.0";
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/Deployment/AssemblyFactory:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_Components::Deployment::AssemblyFactory::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/Components/Deployment/AssemblyFactory:1.0") == 0)
    return ACE_static_cast (POA_Components::Deployment::AssemblyFactory_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_Components::Deployment::AssemblyFactory::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/Deployment/AssemblyFactory:1.0";
}

void POA_Components::Deployment::AssemblyFactory::_dispatch (
    TAO_ServerRequest &req,
    void *servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


Components::Deployment::AssemblyFactory*
POA_Components::Deployment::AssemblyFactory::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  
  (void) safe_stub.release ();
  
  return ::Components::Deployment::AssemblyFactory::_unchecked_narrow (obj.in ());
}


class TAO_Components_Deployment_ServerActivator_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:56:15 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_Components_Deployment_ServerActivator_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_Components_Deployment_ServerActivator_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29,  0,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29,  0,
     29,  5, 29,  5, 29,  0, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29,  0, 29, 29, 29, 29, 29, 29,
     29, 29,  0,  0, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29,
#else
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29,  0, 29,  0, 29,  5,
     29,  5, 29,  0, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29,  0,  0,  0, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_Components_Deployment_ServerActivator_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 7,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 23,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 28,
      HASH_VALUE_RANGE = 24,
      DUPLICATES = 0,
      WORDLIST_SIZE = 12
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_Components::Deployment::ServerActivator::_is_a_skel},
      {"",0},{"",0},{"",0},{"",0},
      {"_component",  &POA_Components::Deployment::ServerActivator::_component_skel},
      {"",0},{"",0},
      {"_non_existent",  &POA_Components::Deployment::ServerActivator::_non_existent_skel},
      {"",0},
      {"_interface",  &POA_Components::Deployment::ServerActivator::_interface_skel},
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"get_component_servers", 	&POA_Components::Deployment::ServerActivator::get_component_servers_skel},
      {"",0},
      {"remove_component_server", 	&POA_Components::Deployment::ServerActivator::remove_component_server_skel},
      {"",0},{"",0},{"",0},{"",0},
      {"create_component_server", 	&POA_Components::Deployment::ServerActivator::create_component_server_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 22:56:15 */
static TAO_Components_Deployment_ServerActivator_Perfect_Hash_OpTable tao_Components_Deployment_ServerActivator_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_Components_Deployment_ServerActivator_create_component_server : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Deployment_ServerActivator_create_component_server (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Deployment::ServerActivator *tao_impl
    ,
    const Components::ConfigValues & config);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::Deployment::ComponentServer_ptr result);

  private:
    TAO_ServerRequestInfo_Components_Deployment_ServerActivator_create_component_server (const TAO_ServerRequestInfo_Components_Deployment_ServerActivator_create_component_server &);
    void operator= (const TAO_ServerRequestInfo_Components_Deployment_ServerActivator_create_component_server &);
    
  private:
    POA_Components::Deployment::ServerActivator *_tao_impl;
    const Components::ConfigValues & config_;
    ::Components::Deployment::ComponentServer_ptr _result;
  };
  
    TAO_ServerRequestInfo_Components_Deployment_ServerActivator_create_component_server::TAO_ServerRequestInfo_Components_Deployment_ServerActivator_create_component_server (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Deployment::ServerActivator *tao_impl,
      const Components::ConfigValues & config
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        config_ (config)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Deployment_ServerActivator_create_component_server::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (1);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<=  this->config_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Deployment_ServerActivator_create_component_server::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_ServerActivator_create_component_server_exceptiondata[] = 
  {
    Components::_tc_CreateFailure,
    Components::_tc_InvalidConfiguration
  };
  
  exception_list->length (2);
  for (CORBA::ULong i = 0; i < 2; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_ServerActivator_create_component_server_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Deployment_ServerActivator_create_component_server::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_Deployment_ServerActivator_create_component_server::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Deployment_ServerActivator_create_component_server::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_Deployment_ServerActivator_create_component_server::result (::Components::Deployment::ComponentServer_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_Deployment_ServerActivator_remove_component_server : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Deployment_ServerActivator_remove_component_server (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Deployment::ServerActivator *tao_impl
    ,
    Components::Deployment::ComponentServer_ptr server);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    
  private:
    TAO_ServerRequestInfo_Components_Deployment_ServerActivator_remove_component_server (const TAO_ServerRequestInfo_Components_Deployment_ServerActivator_remove_component_server &);
    void operator= (const TAO_ServerRequestInfo_Components_Deployment_ServerActivator_remove_component_server &);
    
  private:
    POA_Components::Deployment::ServerActivator *_tao_impl;
    Components::Deployment::ComponentServer_ptr server_;
    
  };
  
    TAO_ServerRequestInfo_Components_Deployment_ServerActivator_remove_component_server::TAO_ServerRequestInfo_Components_Deployment_ServerActivator_remove_component_server (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Deployment::ServerActivator *tao_impl,
      Components::Deployment::ComponentServer_ptr server
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        server_ (server)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Deployment_ServerActivator_remove_component_server::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (1);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<=  this->server_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Deployment_ServerActivator_remove_component_server::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_ServerActivator_remove_component_server_exceptiondata[] = 
  {
    Components::_tc_RemoveFailure
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_ServerActivator_remove_component_server_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Deployment_ServerActivator_remove_component_server::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_Components_Deployment_ServerActivator_remove_component_server::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Deployment_ServerActivator_remove_component_server::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_Components_Deployment_ServerActivator_get_component_servers : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Deployment_ServerActivator_get_component_servers (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Deployment::ServerActivator *tao_impl
    );

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::Deployment::ComponentServers * result);

  private:
    TAO_ServerRequestInfo_Components_Deployment_ServerActivator_get_component_servers (const TAO_ServerRequestInfo_Components_Deployment_ServerActivator_get_component_servers &);
    void operator= (const TAO_ServerRequestInfo_Components_Deployment_ServerActivator_get_component_servers &);
    
  private:
    POA_Components::Deployment::ServerActivator *_tao_impl;
    ::Components::Deployment::ComponentServers * _result;
  };
  
    TAO_ServerRequestInfo_Components_Deployment_ServerActivator_get_component_servers::TAO_ServerRequestInfo_Components_Deployment_ServerActivator_get_component_servers (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Deployment::ServerActivator *tao_impl
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Deployment_ServerActivator_get_component_servers::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return parameter_list;
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Deployment_ServerActivator_get_component_servers::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Deployment_ServerActivator_get_component_servers::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_Deployment_ServerActivator_get_component_servers::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Deployment_ServerActivator_get_component_servers::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_Deployment_ServerActivator_get_component_servers::result (::Components::Deployment::ComponentServers * result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_Components::Deployment::_TAO_ServerActivator_Strategized_Proxy_Broker *POA_Components::Deployment::_TAO_ServerActivator_Strategized_Proxy_Broker::the_TAO_ServerActivator_Strategized_Proxy_Broker (void)
{
  static POA_Components::Deployment::_TAO_ServerActivator_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_Components::Deployment::_TAO_ServerActivator_Strategized_Proxy_Broker::_TAO_ServerActivator_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_Components::Deployment::_TAO_ServerActivator_Strategized_Proxy_Broker::~_TAO_ServerActivator_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    {
      delete this->proxy_cache_[i];
      
      // Hack to prevent bug mentioned in 1204. Refer to 1204
      // for details..
      this->proxy_cache_[i] = 0;
    }
  
}

Components::Deployment::_TAO_ServerActivator_Proxy_Impl&
POA_Components::Deployment::_TAO_ServerActivator_Strategized_Proxy_Broker::select_proxy (
    ::Components::Deployment::ServerActivator *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
    ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_Components::Deployment::_TAO_ServerActivator_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_Components::Deployment::_TAO_ServerActivator_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::Components::Deployment::_TAO_ServerActivator_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


Components::Deployment::_TAO_ServerActivator_Proxy_Broker *
Components_Deployment__TAO_ServerActivator_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_Components::Deployment::_TAO_ServerActivator_Strategized_Proxy_Broker::the_TAO_ServerActivator_Strategized_Proxy_Broker();
}

int
Components_Deployment__TAO_ServerActivator_Proxy_Broker_Factory_Initializer (long)
{
  Components_Deployment__TAO_ServerActivator_Proxy_Broker_Factory_function_pointer = 
    Components_Deployment__TAO_ServerActivator_Proxy_Broker_Factory_function;
  
  return 0;
}

static int Components_Deployment__TAO_ServerActivator_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  Components_Deployment__TAO_ServerActivator_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, Components_Deployment__TAO_ServerActivator_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_Components::Deployment::_TAO_ServerActivator_ThruPOA_Proxy_Impl::_TAO_ServerActivator_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

::Components::Deployment::ComponentServer_ptr POA_Components::Deployment::_TAO_ServerActivator_ThruPOA_Proxy_Impl::create_component_server (
    CORBA_Object *_collocated_tao_target_,
    const Components::ConfigValues & config
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::CreateFailure
    , Components::InvalidConfiguration
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_component_server",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::Deployment::ServerActivator_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Deployment/ServerActivator:1.0"
        )
    )->create_component_server (
        config
      );
}

void POA_Components::Deployment::_TAO_ServerActivator_ThruPOA_Proxy_Impl::remove_component_server (
    CORBA_Object *_collocated_tao_target_,
    Components::Deployment::ComponentServer_ptr server
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::RemoveFailure
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "remove_component_server",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  ACE_reinterpret_cast (
      POA_Components::Deployment::ServerActivator_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Deployment/ServerActivator:1.0"
        )
    )->remove_component_server (
        server
      );
  return;
}

::Components::Deployment::ComponentServers * POA_Components::Deployment::_TAO_ServerActivator_ThruPOA_Proxy_Impl::get_component_servers (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "get_component_servers",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::Deployment::ServerActivator_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Deployment/ServerActivator:1.0"
        )
    )->get_component_servers (
        
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ss.cpp:100
POA_Components::Deployment::ServerActivator::ServerActivator (void)
{
  this->optable_ = &tao_Components_Deployment_ServerActivator_optable;
}

POA_Components::Deployment::ServerActivator::ServerActivator (const ServerActivator& rhs)
  :  TAO_ServantBase (rhs)
{}

POA_Components::Deployment::ServerActivator::~ServerActivator (void)
{
}

void POA_Components::Deployment::ServerActivator::create_component_server_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Deployment::ServerActivator *_tao_impl =
    ACE_static_cast (
        POA_Components::Deployment::ServerActivator *,
        _tao_servant
      );
  ::Components::Deployment::ComponentServer_var _tao_retval;
  Components::ConfigValues config;
  if (!(
    (_tao_in >> config)
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Deployment_ServerActivator_create_component_server _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      config
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->create_component_server (
                config
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::Deployment::ComponentServer_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Deployment::ServerActivator::remove_component_server_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Deployment::ServerActivator *_tao_impl =
    ACE_static_cast (
        POA_Components::Deployment::ServerActivator *,
        _tao_servant
      );
  _tao_server_request.argument_flag (0);
    Components::Deployment::ComponentServer_var server;
  if (!(
    (_tao_in >> server.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Deployment_ServerActivator_remove_component_server _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      server.in ()
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            
            _tao_impl->remove_component_server (
                server.in ()
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Deployment::ServerActivator::get_component_servers_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Deployment::ServerActivator *_tao_impl =
    ACE_static_cast (
        POA_Components::Deployment::ServerActivator *,
        _tao_servant
      );
  ::Components::Deployment::ComponentServers_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Deployment_ServerActivator_get_component_servers _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->get_component_servers (
                
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::Deployment::ComponentServers * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Deployment::ServerActivator::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Deployment::ServerActivator *_tao_impl = (POA_Components::Deployment::ServerActivator *) _tao_servant;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::Deployment::ServerActivator::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Deployment::ServerActivator *_tao_impl = (POA_Components::Deployment::ServerActivator *) _tao_servant;
  CORBA::Boolean _tao_retval =
    _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::Deployment::ServerActivator::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Deployment::ServerActivator *_tao_impl = (POA_Components::Deployment::ServerActivator *) _tao_servant;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = 
        _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_Components::Deployment::ServerActivator::_component_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Deployment::ServerActivator *_tao_impl = (POA_Components::Deployment::ServerActivator *) _tao_object_reference;
  CORBA::Object_var _tao_retval =
    _tao_impl->_get_component (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << _tao_retval._retn ()))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_Components::Deployment::ServerActivator::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  const char *base_id = "IDL:org.omg/CORBA/Object:1.0";
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/Deployment/ServerActivator:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_Components::Deployment::ServerActivator::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/Components/Deployment/ServerActivator:1.0") == 0)
    return ACE_static_cast (POA_Components::Deployment::ServerActivator_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_Components::Deployment::ServerActivator::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/Deployment/ServerActivator:1.0";
}

void POA_Components::Deployment::ServerActivator::_dispatch (
    TAO_ServerRequest &req,
    void *servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


Components::Deployment::ServerActivator*
POA_Components::Deployment::ServerActivator::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  
  (void) safe_stub.release ();
  
  return ::Components::Deployment::ServerActivator::_unchecked_narrow (obj.in ());
}


class TAO_Components_Deployment_ComponentServer_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:56:15 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_Components_Deployment_ComponentServer_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_Components_Deployment_ComponentServer_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22,  0,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22,  0,
     22,  5, 22,  5, 22,  0, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22,  0,
     22, 22, 22,  0, 22, 22, 22, 22, 22, 22,
     22, 22,  0,  0, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22,
#else
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22,  0, 22,  0, 22,  5,
     22,  5, 22,  0, 22, 22, 22, 22, 22, 22,
      0, 22, 22, 22,  0,  0,  0, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_Components_Deployment_ComponentServer_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 10,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 20,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 21,
      HASH_VALUE_RANGE = 17,
      DUPLICATES = 0,
      WORDLIST_SIZE = 15
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_Components::Deployment::ComponentServer::_is_a_skel},
      {"",0},{"",0},{"",0},{"",0},
      {"_component",  &POA_Components::Deployment::ComponentServer::_component_skel},
      {"remove", 	&POA_Components::Deployment::ComponentServer::remove_skel},
      {"",0},
      {"_non_existent",  &POA_Components::Deployment::ComponentServer::_non_existent_skel},
      {"get_containers", 	&POA_Components::Deployment::ComponentServer::get_containers_skel},
      {"_interface",  &POA_Components::Deployment::ComponentServer::_interface_skel},
      {"remove_container", 	&POA_Components::Deployment::ComponentServer::remove_container_skel},
      {"",0},
      {"_get_configuration", 	&POA_Components::Deployment::ComponentServer::_get_configuration_skel},
      {"",0},
      {"get_server_activator", 	&POA_Components::Deployment::ComponentServer::get_server_activator_skel},
      {"create_container", 	&POA_Components::Deployment::ComponentServer::create_container_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 22:56:15 */
static TAO_Components_Deployment_ComponentServer_Perfect_Hash_OpTable tao_Components_Deployment_ComponentServer_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_Components_Deployment_ComponentServer_configuration_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Deployment_ComponentServer_configuration_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Deployment::ComponentServer *tao_impl
    );

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::ConfigValues * result);

  private:
    TAO_ServerRequestInfo_Components_Deployment_ComponentServer_configuration_get (const TAO_ServerRequestInfo_Components_Deployment_ComponentServer_configuration_get &);
    void operator= (const TAO_ServerRequestInfo_Components_Deployment_ComponentServer_configuration_get &);
    
  private:
    POA_Components::Deployment::ComponentServer *_tao_impl;
    ::Components::ConfigValues * _result;
  };
  
    TAO_ServerRequestInfo_Components_Deployment_ComponentServer_configuration_get::TAO_ServerRequestInfo_Components_Deployment_ComponentServer_configuration_get (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Deployment::ComponentServer *tao_impl
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Deployment_ComponentServer_configuration_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return parameter_list;
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Deployment_ComponentServer_configuration_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Deployment_ComponentServer_configuration_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_Deployment_ComponentServer_configuration_get::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Deployment_ComponentServer_configuration_get::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_Deployment_ComponentServer_configuration_get::result (::Components::ConfigValues * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_Deployment_ComponentServer_get_server_activator : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Deployment_ComponentServer_get_server_activator (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Deployment::ComponentServer *tao_impl
    );

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::Deployment::ServerActivator_ptr result);

  private:
    TAO_ServerRequestInfo_Components_Deployment_ComponentServer_get_server_activator (const TAO_ServerRequestInfo_Components_Deployment_ComponentServer_get_server_activator &);
    void operator= (const TAO_ServerRequestInfo_Components_Deployment_ComponentServer_get_server_activator &);
    
  private:
    POA_Components::Deployment::ComponentServer *_tao_impl;
    ::Components::Deployment::ServerActivator_ptr _result;
  };
  
    TAO_ServerRequestInfo_Components_Deployment_ComponentServer_get_server_activator::TAO_ServerRequestInfo_Components_Deployment_ComponentServer_get_server_activator (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Deployment::ComponentServer *tao_impl
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Deployment_ComponentServer_get_server_activator::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return parameter_list;
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Deployment_ComponentServer_get_server_activator::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Deployment_ComponentServer_get_server_activator::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_Deployment_ComponentServer_get_server_activator::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Deployment_ComponentServer_get_server_activator::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_Deployment_ComponentServer_get_server_activator::result (::Components::Deployment::ServerActivator_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_Deployment_ComponentServer_create_container : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Deployment_ComponentServer_create_container (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Deployment::ComponentServer *tao_impl
    ,
    const Components::ConfigValues & config);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::Deployment::Container_ptr result);

  private:
    TAO_ServerRequestInfo_Components_Deployment_ComponentServer_create_container (const TAO_ServerRequestInfo_Components_Deployment_ComponentServer_create_container &);
    void operator= (const TAO_ServerRequestInfo_Components_Deployment_ComponentServer_create_container &);
    
  private:
    POA_Components::Deployment::ComponentServer *_tao_impl;
    const Components::ConfigValues & config_;
    ::Components::Deployment::Container_ptr _result;
  };
  
    TAO_ServerRequestInfo_Components_Deployment_ComponentServer_create_container::TAO_ServerRequestInfo_Components_Deployment_ComponentServer_create_container (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Deployment::ComponentServer *tao_impl,
      const Components::ConfigValues & config
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        config_ (config)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Deployment_ComponentServer_create_container::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (1);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<=  this->config_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Deployment_ComponentServer_create_container::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_ComponentServer_create_container_exceptiondata[] = 
  {
    Components::_tc_CreateFailure,
    Components::_tc_InvalidConfiguration
  };
  
  exception_list->length (2);
  for (CORBA::ULong i = 0; i < 2; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_ComponentServer_create_container_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Deployment_ComponentServer_create_container::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_Deployment_ComponentServer_create_container::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Deployment_ComponentServer_create_container::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_Deployment_ComponentServer_create_container::result (::Components::Deployment::Container_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_Deployment_ComponentServer_remove_container : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Deployment_ComponentServer_remove_container (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Deployment::ComponentServer *tao_impl
    ,
    Components::Deployment::Container_ptr cref);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    
  private:
    TAO_ServerRequestInfo_Components_Deployment_ComponentServer_remove_container (const TAO_ServerRequestInfo_Components_Deployment_ComponentServer_remove_container &);
    void operator= (const TAO_ServerRequestInfo_Components_Deployment_ComponentServer_remove_container &);
    
  private:
    POA_Components::Deployment::ComponentServer *_tao_impl;
    Components::Deployment::Container_ptr cref_;
    
  };
  
    TAO_ServerRequestInfo_Components_Deployment_ComponentServer_remove_container::TAO_ServerRequestInfo_Components_Deployment_ComponentServer_remove_container (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Deployment::ComponentServer *tao_impl,
      Components::Deployment::Container_ptr cref
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        cref_ (cref)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Deployment_ComponentServer_remove_container::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (1);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<=  this->cref_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Deployment_ComponentServer_remove_container::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_ComponentServer_remove_container_exceptiondata[] = 
  {
    Components::_tc_RemoveFailure
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_ComponentServer_remove_container_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Deployment_ComponentServer_remove_container::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_Components_Deployment_ComponentServer_remove_container::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Deployment_ComponentServer_remove_container::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_Components_Deployment_ComponentServer_get_containers : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Deployment_ComponentServer_get_containers (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Deployment::ComponentServer *tao_impl
    );

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::Deployment::Containers * result);

  private:
    TAO_ServerRequestInfo_Components_Deployment_ComponentServer_get_containers (const TAO_ServerRequestInfo_Components_Deployment_ComponentServer_get_containers &);
    void operator= (const TAO_ServerRequestInfo_Components_Deployment_ComponentServer_get_containers &);
    
  private:
    POA_Components::Deployment::ComponentServer *_tao_impl;
    ::Components::Deployment::Containers * _result;
  };
  
    TAO_ServerRequestInfo_Components_Deployment_ComponentServer_get_containers::TAO_ServerRequestInfo_Components_Deployment_ComponentServer_get_containers (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Deployment::ComponentServer *tao_impl
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Deployment_ComponentServer_get_containers::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return parameter_list;
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Deployment_ComponentServer_get_containers::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Deployment_ComponentServer_get_containers::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_Deployment_ComponentServer_get_containers::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Deployment_ComponentServer_get_containers::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_Deployment_ComponentServer_get_containers::result (::Components::Deployment::Containers * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_Deployment_ComponentServer_remove : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Deployment_ComponentServer_remove (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Deployment::ComponentServer *tao_impl
    );

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    
  private:
    TAO_ServerRequestInfo_Components_Deployment_ComponentServer_remove (const TAO_ServerRequestInfo_Components_Deployment_ComponentServer_remove &);
    void operator= (const TAO_ServerRequestInfo_Components_Deployment_ComponentServer_remove &);
    
  private:
    POA_Components::Deployment::ComponentServer *_tao_impl;
    
  };
  
    TAO_ServerRequestInfo_Components_Deployment_ComponentServer_remove::TAO_ServerRequestInfo_Components_Deployment_ComponentServer_remove (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Deployment::ComponentServer *tao_impl
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Deployment_ComponentServer_remove::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return parameter_list;
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Deployment_ComponentServer_remove::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_ComponentServer_remove_exceptiondata[] = 
  {
    Components::_tc_RemoveFailure
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_ComponentServer_remove_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Deployment_ComponentServer_remove::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_Components_Deployment_ComponentServer_remove::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Deployment_ComponentServer_remove::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_Components::Deployment::_TAO_ComponentServer_Strategized_Proxy_Broker *POA_Components::Deployment::_TAO_ComponentServer_Strategized_Proxy_Broker::the_TAO_ComponentServer_Strategized_Proxy_Broker (void)
{
  static POA_Components::Deployment::_TAO_ComponentServer_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_Components::Deployment::_TAO_ComponentServer_Strategized_Proxy_Broker::_TAO_ComponentServer_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_Components::Deployment::_TAO_ComponentServer_Strategized_Proxy_Broker::~_TAO_ComponentServer_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    {
      delete this->proxy_cache_[i];
      
      // Hack to prevent bug mentioned in 1204. Refer to 1204
      // for details..
      this->proxy_cache_[i] = 0;
    }
  
}

Components::Deployment::_TAO_ComponentServer_Proxy_Impl&
POA_Components::Deployment::_TAO_ComponentServer_Strategized_Proxy_Broker::select_proxy (
    ::Components::Deployment::ComponentServer *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
    ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_Components::Deployment::_TAO_ComponentServer_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_Components::Deployment::_TAO_ComponentServer_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::Components::Deployment::_TAO_ComponentServer_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


Components::Deployment::_TAO_ComponentServer_Proxy_Broker *
Components_Deployment__TAO_ComponentServer_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_Components::Deployment::_TAO_ComponentServer_Strategized_Proxy_Broker::the_TAO_ComponentServer_Strategized_Proxy_Broker();
}

int
Components_Deployment__TAO_ComponentServer_Proxy_Broker_Factory_Initializer (long)
{
  Components_Deployment__TAO_ComponentServer_Proxy_Broker_Factory_function_pointer = 
    Components_Deployment__TAO_ComponentServer_Proxy_Broker_Factory_function;
  
  return 0;
}

static int Components_Deployment__TAO_ComponentServer_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  Components_Deployment__TAO_ComponentServer_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, Components_Deployment__TAO_ComponentServer_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_Components::Deployment::_TAO_ComponentServer_ThruPOA_Proxy_Impl::_TAO_ComponentServer_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

::Components::ConfigValues * POA_Components::Deployment::_TAO_ComponentServer_ThruPOA_Proxy_Impl::configuration (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "configuration",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::Deployment::ComponentServer_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Deployment/ComponentServer:1.0"
        )
    )->configuration (
        
      );
}

::Components::Deployment::ServerActivator_ptr POA_Components::Deployment::_TAO_ComponentServer_ThruPOA_Proxy_Impl::get_server_activator (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "get_server_activator",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::Deployment::ComponentServer_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Deployment/ComponentServer:1.0"
        )
    )->get_server_activator (
        
      );
}

::Components::Deployment::Container_ptr POA_Components::Deployment::_TAO_ComponentServer_ThruPOA_Proxy_Impl::create_container (
    CORBA_Object *_collocated_tao_target_,
    const Components::ConfigValues & config
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::CreateFailure
    , Components::InvalidConfiguration
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_container",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::Deployment::ComponentServer_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Deployment/ComponentServer:1.0"
        )
    )->create_container (
        config
      );
}

void POA_Components::Deployment::_TAO_ComponentServer_ThruPOA_Proxy_Impl::remove_container (
    CORBA_Object *_collocated_tao_target_,
    Components::Deployment::Container_ptr cref
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::RemoveFailure
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "remove_container",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  ACE_reinterpret_cast (
      POA_Components::Deployment::ComponentServer_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Deployment/ComponentServer:1.0"
        )
    )->remove_container (
        cref
      );
  return;
}

::Components::Deployment::Containers * POA_Components::Deployment::_TAO_ComponentServer_ThruPOA_Proxy_Impl::get_containers (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "get_containers",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::Deployment::ComponentServer_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Deployment/ComponentServer:1.0"
        )
    )->get_containers (
        
      );
}

void POA_Components::Deployment::_TAO_ComponentServer_ThruPOA_Proxy_Impl::remove (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::RemoveFailure
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "remove",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  ACE_reinterpret_cast (
      POA_Components::Deployment::ComponentServer_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Deployment/ComponentServer:1.0"
        )
    )->remove (
        
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ss.cpp:100
POA_Components::Deployment::ComponentServer::ComponentServer (void)
{
  this->optable_ = &tao_Components_Deployment_ComponentServer_optable;
}

POA_Components::Deployment::ComponentServer::ComponentServer (const ComponentServer& rhs)
  :  TAO_ServantBase (rhs)
{}

POA_Components::Deployment::ComponentServer::~ComponentServer (void)
{
}

void POA_Components::Deployment::ComponentServer::_get_configuration_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Deployment::ComponentServer *_tao_impl =
    ACE_static_cast (
        POA_Components::Deployment::ComponentServer *,
        _tao_servant
      );
  ::Components::ConfigValues_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Deployment_ComponentServer_configuration_get _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->configuration (
                
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::ConfigValues * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Deployment::ComponentServer::get_server_activator_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Deployment::ComponentServer *_tao_impl =
    ACE_static_cast (
        POA_Components::Deployment::ComponentServer *,
        _tao_servant
      );
  ::Components::Deployment::ServerActivator_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Deployment_ComponentServer_get_server_activator _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->get_server_activator (
                
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::Deployment::ServerActivator_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Deployment::ComponentServer::create_container_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Deployment::ComponentServer *_tao_impl =
    ACE_static_cast (
        POA_Components::Deployment::ComponentServer *,
        _tao_servant
      );
  ::Components::Deployment::Container_var _tao_retval;
  Components::ConfigValues config;
  if (!(
    (_tao_in >> config)
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Deployment_ComponentServer_create_container _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      config
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->create_container (
                config
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::Deployment::Container_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Deployment::ComponentServer::remove_container_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Deployment::ComponentServer *_tao_impl =
    ACE_static_cast (
        POA_Components::Deployment::ComponentServer *,
        _tao_servant
      );
  _tao_server_request.argument_flag (0);
    Components::Deployment::Container_var cref;
  if (!(
    (_tao_in >> cref.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Deployment_ComponentServer_remove_container _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      cref.in ()
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            
            _tao_impl->remove_container (
                cref.in ()
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Deployment::ComponentServer::get_containers_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Deployment::ComponentServer *_tao_impl =
    ACE_static_cast (
        POA_Components::Deployment::ComponentServer *,
        _tao_servant
      );
  ::Components::Deployment::Containers_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Deployment_ComponentServer_get_containers _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->get_containers (
                
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::Deployment::Containers * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Deployment::ComponentServer::remove_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Deployment::ComponentServer *_tao_impl =
    ACE_static_cast (
        POA_Components::Deployment::ComponentServer *,
        _tao_servant
      );
  _tao_server_request.argument_flag (0);
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Deployment_ComponentServer_remove _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            
            _tao_impl->remove (
                
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Deployment::ComponentServer::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Deployment::ComponentServer *_tao_impl = (POA_Components::Deployment::ComponentServer *) _tao_servant;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::Deployment::ComponentServer::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Deployment::ComponentServer *_tao_impl = (POA_Components::Deployment::ComponentServer *) _tao_servant;
  CORBA::Boolean _tao_retval =
    _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::Deployment::ComponentServer::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Deployment::ComponentServer *_tao_impl = (POA_Components::Deployment::ComponentServer *) _tao_servant;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = 
        _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_Components::Deployment::ComponentServer::_component_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Deployment::ComponentServer *_tao_impl = (POA_Components::Deployment::ComponentServer *) _tao_object_reference;
  CORBA::Object_var _tao_retval =
    _tao_impl->_get_component (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << _tao_retval._retn ()))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_Components::Deployment::ComponentServer::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  const char *base_id = "IDL:org.omg/CORBA/Object:1.0";
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/Deployment/ComponentServer:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_Components::Deployment::ComponentServer::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/Components/Deployment/ComponentServer:1.0") == 0)
    return ACE_static_cast (POA_Components::Deployment::ComponentServer_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_Components::Deployment::ComponentServer::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/Deployment/ComponentServer:1.0";
}

void POA_Components::Deployment::ComponentServer::_dispatch (
    TAO_ServerRequest &req,
    void *servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


Components::Deployment::ComponentServer*
POA_Components::Deployment::ComponentServer::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  
  (void) safe_stub.release ();
  
  return ::Components::Deployment::ComponentServer::_unchecked_narrow (obj.in ());
}


class TAO_Components_Deployment_Container_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:56:15 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_Components_Deployment_Container_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_Components_Deployment_Container_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24,  0,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24,  0,
     24, 24, 24,  0, 24,  0, 24,  0, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24,  5,
     24, 24, 24,  0, 24, 24, 24, 24, 24, 24,
     24, 24,  0,  5, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24,
#else
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24,  0, 24,  0, 24, 24,
     24,  0, 24,  0, 24,  0, 24, 24, 24, 24,
      5, 24, 24, 24,  0,  0,  5, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_Components_Deployment_Container_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 10,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 20,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 23,
      HASH_VALUE_RANGE = 19,
      DUPLICATES = 0,
      WORDLIST_SIZE = 15
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_Components::Deployment::Container::_is_a_skel},
      {"remove", 	&POA_Components::Deployment::Container::remove_skel},
      {"",0},{"",0},
      {"get_homes", 	&POA_Components::Deployment::Container::get_homes_skel},
      {"_interface",  &POA_Components::Deployment::Container::_interface_skel},
      {"remove_home", 	&POA_Components::Deployment::Container::remove_home_skel},
      {"install_home", 	&POA_Components::Deployment::Container::install_home_skel},
      {"",0},{"",0},
      {"_component",  &POA_Components::Deployment::Container::_component_skel},
      {"",0},{"",0},
      {"_non_existent",  &POA_Components::Deployment::Container::_non_existent_skel},
      {"",0},
      {"get_component_server", 	&POA_Components::Deployment::Container::get_component_server_skel},
      {"",0},{"",0},
      {"_get_configuration", 	&POA_Components::Deployment::Container::_get_configuration_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 22:56:15 */
static TAO_Components_Deployment_Container_Perfect_Hash_OpTable tao_Components_Deployment_Container_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_Components_Deployment_Container_configuration_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Deployment_Container_configuration_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Deployment::Container *tao_impl
    );

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::ConfigValues * result);

  private:
    TAO_ServerRequestInfo_Components_Deployment_Container_configuration_get (const TAO_ServerRequestInfo_Components_Deployment_Container_configuration_get &);
    void operator= (const TAO_ServerRequestInfo_Components_Deployment_Container_configuration_get &);
    
  private:
    POA_Components::Deployment::Container *_tao_impl;
    ::Components::ConfigValues * _result;
  };
  
    TAO_ServerRequestInfo_Components_Deployment_Container_configuration_get::TAO_ServerRequestInfo_Components_Deployment_Container_configuration_get (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Deployment::Container *tao_impl
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Deployment_Container_configuration_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return parameter_list;
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Deployment_Container_configuration_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Deployment_Container_configuration_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_Deployment_Container_configuration_get::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Deployment_Container_configuration_get::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_Deployment_Container_configuration_get::result (::Components::ConfigValues * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_Deployment_Container_get_component_server : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Deployment_Container_get_component_server (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Deployment::Container *tao_impl
    );

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::Deployment::ComponentServer_ptr result);

  private:
    TAO_ServerRequestInfo_Components_Deployment_Container_get_component_server (const TAO_ServerRequestInfo_Components_Deployment_Container_get_component_server &);
    void operator= (const TAO_ServerRequestInfo_Components_Deployment_Container_get_component_server &);
    
  private:
    POA_Components::Deployment::Container *_tao_impl;
    ::Components::Deployment::ComponentServer_ptr _result;
  };
  
    TAO_ServerRequestInfo_Components_Deployment_Container_get_component_server::TAO_ServerRequestInfo_Components_Deployment_Container_get_component_server (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Deployment::Container *tao_impl
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Deployment_Container_get_component_server::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return parameter_list;
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Deployment_Container_get_component_server::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Deployment_Container_get_component_server::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_Deployment_Container_get_component_server::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Deployment_Container_get_component_server::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_Deployment_Container_get_component_server::result (::Components::Deployment::ComponentServer_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_Deployment_Container_install_home : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Deployment_Container_install_home (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Deployment::Container *tao_impl
    ,
    const char * id,
    const char * entrypt,
    const Components::ConfigValues & config);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::CCMHome_ptr result);

  private:
    TAO_ServerRequestInfo_Components_Deployment_Container_install_home (const TAO_ServerRequestInfo_Components_Deployment_Container_install_home &);
    void operator= (const TAO_ServerRequestInfo_Components_Deployment_Container_install_home &);
    
  private:
    POA_Components::Deployment::Container *_tao_impl;
    const char * id_;
    const char * entrypt_;
    const Components::ConfigValues & config_;
    ::Components::CCMHome_ptr _result;
  };
  
    TAO_ServerRequestInfo_Components_Deployment_Container_install_home::TAO_ServerRequestInfo_Components_Deployment_Container_install_home (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Deployment::Container *tao_impl,
      const char * id,
      const char * entrypt,
      const Components::ConfigValues & config
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        id_ (id),
        entrypt_ (entrypt),
        config_ (config)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Deployment_Container_install_home::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (3);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<= id_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
        (*parameter_list)[len].argument <<= entrypt_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
        (*parameter_list)[len].argument <<=  this->config_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Deployment_Container_install_home::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_Container_install_home_exceptiondata[] = 
  {
    Components::Deployment::_tc_UnknownImplId,
    Components::Deployment::_tc_ImplEntryPointNotFound,
    Components::Deployment::_tc_InstallationFailure,
    Components::_tc_InvalidConfiguration
  };
  
  exception_list->length (4);
  for (CORBA::ULong i = 0; i < 4; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_Container_install_home_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Deployment_Container_install_home::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_Deployment_Container_install_home::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Deployment_Container_install_home::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_Deployment_Container_install_home::result (::Components::CCMHome_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_Deployment_Container_remove_home : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Deployment_Container_remove_home (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Deployment::Container *tao_impl
    ,
    Components::CCMHome_ptr href);

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    
  private:
    TAO_ServerRequestInfo_Components_Deployment_Container_remove_home (const TAO_ServerRequestInfo_Components_Deployment_Container_remove_home &);
    void operator= (const TAO_ServerRequestInfo_Components_Deployment_Container_remove_home &);
    
  private:
    POA_Components::Deployment::Container *_tao_impl;
    Components::CCMHome_ptr href_;
    
  };
  
    TAO_ServerRequestInfo_Components_Deployment_Container_remove_home::TAO_ServerRequestInfo_Components_Deployment_Container_remove_home (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Deployment::Container *tao_impl,
      Components::CCMHome_ptr href
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl),
        href_ (href)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Deployment_Container_remove_home::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
    parameter_list->length (1);
    CORBA::ULong len = 0;
    
        (*parameter_list)[len].argument <<=  this->href_;
    (*parameter_list)[len].mode = CORBA::PARAM_IN;
    len++;
    
    return safe_parameter_list._retn ();
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Deployment_Container_remove_home::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_Container_remove_home_exceptiondata[] = 
  {
    Components::_tc_RemoveFailure
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_Container_remove_home_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Deployment_Container_remove_home::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_Components_Deployment_Container_remove_home::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Deployment_Container_remove_home::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_Components_Deployment_Container_get_homes : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Deployment_Container_get_homes (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Deployment::Container *tao_impl
    );

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::Components::CCMHomes * result);

  private:
    TAO_ServerRequestInfo_Components_Deployment_Container_get_homes (const TAO_ServerRequestInfo_Components_Deployment_Container_get_homes &);
    void operator= (const TAO_ServerRequestInfo_Components_Deployment_Container_get_homes &);
    
  private:
    POA_Components::Deployment::Container *_tao_impl;
    ::Components::CCMHomes * _result;
  };
  
    TAO_ServerRequestInfo_Components_Deployment_Container_get_homes::TAO_ServerRequestInfo_Components_Deployment_Container_get_homes (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Deployment::Container *tao_impl
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Deployment_Container_get_homes::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return parameter_list;
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Deployment_Container_get_homes::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Deployment_Container_get_homes::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_Components_Deployment_Container_get_homes::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Deployment_Container_get_homes::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_Components_Deployment_Container_get_homes::result (::Components::CCMHomes * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_Components_Deployment_Container_remove : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_Components_Deployment_Container_remove (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_Components::Deployment::Container *tao_impl
    );

    virtual Dynamic::ParameterList * arguments (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual char * target_most_derived_interface (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Boolean target_is_a (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)
      ACE_THROW_SPEC ((CORBA::SystemException));

    
  private:
    TAO_ServerRequestInfo_Components_Deployment_Container_remove (const TAO_ServerRequestInfo_Components_Deployment_Container_remove &);
    void operator= (const TAO_ServerRequestInfo_Components_Deployment_Container_remove &);
    
  private:
    POA_Components::Deployment::Container *_tao_impl;
    
  };
  
    TAO_ServerRequestInfo_Components_Deployment_Container_remove::TAO_ServerRequestInfo_Components_Deployment_Container_remove (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
      POA_Components::Deployment::Container *tao_impl
    )
    : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
      _tao_impl (tao_impl)  
  {}

Dynamic::ParameterList *
  TAO_ServerRequestInfo_Components_Deployment_Container_remove::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return parameter_list;
  }

Dynamic::ExceptionList *
TAO_ServerRequestInfo_Components_Deployment_Container_remove::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_Container_remove_exceptiondata[] = 
  {
    Components::_tc_RemoveFailure
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_Container_remove_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_Components_Deployment_Container_remove::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_Components_Deployment_Container_remove::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_Components_Deployment_Container_remove::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_Components::Deployment::_TAO_Container_Strategized_Proxy_Broker *POA_Components::Deployment::_TAO_Container_Strategized_Proxy_Broker::the_TAO_Container_Strategized_Proxy_Broker (void)
{
  static POA_Components::Deployment::_TAO_Container_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_Components::Deployment::_TAO_Container_Strategized_Proxy_Broker::_TAO_Container_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_Components::Deployment::_TAO_Container_Strategized_Proxy_Broker::~_TAO_Container_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    {
      delete this->proxy_cache_[i];
      
      // Hack to prevent bug mentioned in 1204. Refer to 1204
      // for details..
      this->proxy_cache_[i] = 0;
    }
  
}

Components::Deployment::_TAO_Container_Proxy_Impl&
POA_Components::Deployment::_TAO_Container_Strategized_Proxy_Broker::select_proxy (
    ::Components::Deployment::Container *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
    ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_Components::Deployment::_TAO_Container_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_Components::Deployment::_TAO_Container_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::Components::Deployment::_TAO_Container_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


Components::Deployment::_TAO_Container_Proxy_Broker *
Components_Deployment__TAO_Container_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_Components::Deployment::_TAO_Container_Strategized_Proxy_Broker::the_TAO_Container_Strategized_Proxy_Broker();
}

int
Components_Deployment__TAO_Container_Proxy_Broker_Factory_Initializer (long)
{
  Components_Deployment__TAO_Container_Proxy_Broker_Factory_function_pointer = 
    Components_Deployment__TAO_Container_Proxy_Broker_Factory_function;
  
  return 0;
}

static int Components_Deployment__TAO_Container_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  Components_Deployment__TAO_Container_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, Components_Deployment__TAO_Container_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_Components::Deployment::_TAO_Container_ThruPOA_Proxy_Impl::_TAO_Container_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

::Components::ConfigValues * POA_Components::Deployment::_TAO_Container_ThruPOA_Proxy_Impl::configuration (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "configuration",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::Deployment::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Deployment/Container:1.0"
        )
    )->configuration (
        
      );
}

::Components::Deployment::ComponentServer_ptr POA_Components::Deployment::_TAO_Container_ThruPOA_Proxy_Impl::get_component_server (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "get_component_server",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::Deployment::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Deployment/Container:1.0"
        )
    )->get_component_server (
        
      );
}

::Components::CCMHome_ptr POA_Components::Deployment::_TAO_Container_ThruPOA_Proxy_Impl::install_home (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * entrypt,
    const Components::ConfigValues & config
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::Deployment::UnknownImplId
    , Components::Deployment::ImplEntryPointNotFound
    , Components::Deployment::InstallationFailure
    , Components::InvalidConfiguration
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "install_home",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::Deployment::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Deployment/Container:1.0"
        )
    )->install_home (
        id,
        entrypt,
        config
      );
}

void POA_Components::Deployment::_TAO_Container_ThruPOA_Proxy_Impl::remove_home (
    CORBA_Object *_collocated_tao_target_,
    Components::CCMHome_ptr href
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::RemoveFailure
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "remove_home",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  ACE_reinterpret_cast (
      POA_Components::Deployment::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Deployment/Container:1.0"
        )
    )->remove_home (
        href
      );
  return;
}

::Components::CCMHomes * POA_Components::Deployment::_TAO_Container_ThruPOA_Proxy_Impl::get_homes (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "get_homes",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  return ACE_reinterpret_cast (
      POA_Components::Deployment::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Deployment/Container:1.0"
        )
    )->get_homes (
        
      );
}

void POA_Components::Deployment::_TAO_Container_ThruPOA_Proxy_Impl::remove (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::RemoveFailure
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "remove",
      forward_to.out ()
    );
  servant_upcall.pre_invoke_collocated_request ();
  ACE_reinterpret_cast (
      POA_Components::Deployment::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/Components/Deployment/Container:1.0"
        )
    )->remove (
        
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ss.cpp:100
POA_Components::Deployment::Container::Container (void)
{
  this->optable_ = &tao_Components_Deployment_Container_optable;
}

POA_Components::Deployment::Container::Container (const Container& rhs)
  :  TAO_ServantBase (rhs)
{}

POA_Components::Deployment::Container::~Container (void)
{
}

void POA_Components::Deployment::Container::_get_configuration_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Deployment::Container *_tao_impl =
    ACE_static_cast (
        POA_Components::Deployment::Container *,
        _tao_servant
      );
  ::Components::ConfigValues_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Deployment_Container_configuration_get _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->configuration (
                
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::ConfigValues * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Deployment::Container::get_component_server_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Deployment::Container *_tao_impl =
    ACE_static_cast (
        POA_Components::Deployment::Container *,
        _tao_servant
      );
  ::Components::Deployment::ComponentServer_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Deployment_Container_get_component_server _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->get_component_server (
                
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::Deployment::ComponentServer_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Deployment::Container::install_home_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Deployment::Container *_tao_impl =
    ACE_static_cast (
        POA_Components::Deployment::Container *,
        _tao_servant
      );
  ::Components::CCMHome_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var entrypt;
  Components::ConfigValues config;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> entrypt.out ()) &&
    (_tao_in >> config)
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Deployment_Container_install_home _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      id.in (),
      entrypt.in (),
      config
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->install_home (
                id.in (),
                entrypt.in (),
                config
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::CCMHome_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Deployment::Container::remove_home_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Deployment::Container *_tao_impl =
    ACE_static_cast (
        POA_Components::Deployment::Container *,
        _tao_servant
      );
  _tao_server_request.argument_flag (0);
    Components::CCMHome_var href;
  if (!(
    (_tao_in >> href.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Deployment_Container_remove_home _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      href.in ()
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            
            _tao_impl->remove_home (
                href.in ()
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Deployment::Container::get_homes_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Deployment::Container *_tao_impl =
    ACE_static_cast (
        POA_Components::Deployment::Container *,
        _tao_servant
      );
  ::Components::CCMHomes_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Deployment_Container_get_homes _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->get_homes (
                
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::Components::CCMHomes * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Deployment::Container::remove_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Deployment::Container *_tao_impl =
    ACE_static_cast (
        POA_Components::Deployment::Container *,
        _tao_servant
      );
  _tao_server_request.argument_flag (0);
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_Components_Deployment_Container_remove _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            
            _tao_impl->remove (
                
              );
            
#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
        
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
}

void POA_Components::Deployment::Container::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Components::Deployment::Container *_tao_impl = (POA_Components::Deployment::Container *) _tao_servant;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::Deployment::Container::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Deployment::Container *_tao_impl = (POA_Components::Deployment::Container *) _tao_servant;
  CORBA::Boolean _tao_retval =
    _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Components::Deployment::Container::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Deployment::Container *_tao_impl = (POA_Components::Deployment::Container *) _tao_servant;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = 
        _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_Components::Deployment::Container::_component_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_Components::Deployment::Container *_tao_impl = (POA_Components::Deployment::Container *) _tao_object_reference;
  CORBA::Object_var _tao_retval =
    _tao_impl->_get_component (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << _tao_retval._retn ()))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_Components::Deployment::Container::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  const char *base_id = "IDL:org.omg/CORBA/Object:1.0";
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/Deployment/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_Components::Deployment::Container::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/Components/Deployment/Container:1.0") == 0)
    return ACE_static_cast (POA_Components::Deployment::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_Components::Deployment::Container::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/Deployment/Container:1.0";
}

void POA_Components::Deployment::Container::_dispatch (
    TAO_ServerRequest &req,
    void *servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


Components::Deployment::Container*
POA_Components::Deployment::Container::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  
  (void) safe_stub.release ();
  
  return ::Components::Deployment::Container::_unchecked_narrow (obj.in ());
}



#endif /* ifndef */
