// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html


// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_codegen.cpp:597

#ifndef _TAO_IDL_COMPONENT_BASES_T_H_
#define _TAO_IDL_COMPONENT_BASES_T_H_

#if defined(_MSC_VER)
#if (_MSC_VER >= 1200)
#pragma warning(push)
#endif /* _MSC_VER >= 1200 */
#pragma warning(disable:4250)
#endif /* _MSC_VER */

#if defined (ACE_HAS_USING_KEYWORD)
TAO_NAMESPACE  POA_Components
{
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/tie_sh.cpp:89
  
  // TIE class: Refer to CORBA v2.2, Section 20.34.4
  template <class T>
  class  Navigation_tie : public Navigation
  {
  public:
    Navigation_tie (T &t);
    // the T& ctor
    Navigation_tie (T &t, PortableServer::POA_ptr poa);
    // ctor taking a POA
    Navigation_tie (T *tp, CORBA::Boolean release=1);
    // ctor taking pointer and an ownership flag
    Navigation_tie (T *tp, PortableServer::POA_ptr poa, CORBA::Boolean release=1);
    // ctor with T*, ownership flag and a POA
    ~Navigation_tie (void);
    // dtor
    
    // TIE specific functions
    T *_tied_object (void);
    // return the underlying object
    void _tied_object (T &obj);
    // set the underlying object
    void _tied_object (T *obj, CORBA::Boolean release=1);
    // set the underlying object and the ownership flag
    CORBA::Boolean _is_owner (void);
    // do we own it
    void _is_owner (CORBA::Boolean b);
    // set the ownership
    
    // overridden ServantBase operations
    PortableServer::POA_ptr _default_POA (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      );
    CORBA::Object_ptr provide_facet (
        const char * name
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::InvalidName
      ));
    
        ::Components::FacetDescriptions * get_all_facets (
        
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
    
        ::Components::FacetDescriptions * get_named_facets (
        const Components::NameList & names
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::InvalidName
      ));
    
        CORBA::Boolean same_component (
        CORBA::Object_ptr object_ref
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
    
      private:
    T *ptr_;
    PortableServer::POA_var poa_;
    CORBA::Boolean rel_;
    
    // copy and assignment are not allowed
    Navigation_tie (const Navigation_tie &);
    void operator= (const Navigation_tie &);
  };

  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/tie_sh.cpp:89
  
  // TIE class: Refer to CORBA v2.2, Section 20.34.4
  template <class T>
  class  Receptacles_tie : public Receptacles
  {
  public:
    Receptacles_tie (T &t);
    // the T& ctor
    Receptacles_tie (T &t, PortableServer::POA_ptr poa);
    // ctor taking a POA
    Receptacles_tie (T *tp, CORBA::Boolean release=1);
    // ctor taking pointer and an ownership flag
    Receptacles_tie (T *tp, PortableServer::POA_ptr poa, CORBA::Boolean release=1);
    // ctor with T*, ownership flag and a POA
    ~Receptacles_tie (void);
    // dtor
    
    // TIE specific functions
    T *_tied_object (void);
    // return the underlying object
    void _tied_object (T &obj);
    // set the underlying object
    void _tied_object (T *obj, CORBA::Boolean release=1);
    // set the underlying object and the ownership flag
    CORBA::Boolean _is_owner (void);
    // do we own it
    void _is_owner (CORBA::Boolean b);
    // set the ownership
    
    // overridden ServantBase operations
    PortableServer::POA_ptr _default_POA (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      );
    ::Components::Cookie * connect (
        const char * name,
        CORBA::Object_ptr connection
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::InvalidName
        , Components::InvalidConnection
        , Components::AlreadyConnected
        , Components::ExceededConnectionLimit
      ));
    
        void disconnect (
        const char * name,
        Components::Cookie * ck
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::InvalidName
        , Components::InvalidConnection
        , Components::CookieRequired
        , Components::NoConnection
      ));
    
        ::Components::ConnectionDescriptions * get_connections (
        const char * name
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::InvalidName
      ));
    
        ::Components::ReceptacleDescriptions * get_all_receptacles (
        
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
    
        ::Components::ReceptacleDescriptions * get_named_receptacles (
        const Components::NameList & names
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::InvalidName
      ));
    
      private:
    T *ptr_;
    PortableServer::POA_var poa_;
    CORBA::Boolean rel_;
    
    // copy and assignment are not allowed
    Receptacles_tie (const Receptacles_tie &);
    void operator= (const Receptacles_tie &);
  };

  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/tie_sh.cpp:89
  
  // TIE class: Refer to CORBA v2.2, Section 20.34.4
  template <class T>
  class  EventConsumerBase_tie : public EventConsumerBase
  {
  public:
    EventConsumerBase_tie (T &t);
    // the T& ctor
    EventConsumerBase_tie (T &t, PortableServer::POA_ptr poa);
    // ctor taking a POA
    EventConsumerBase_tie (T *tp, CORBA::Boolean release=1);
    // ctor taking pointer and an ownership flag
    EventConsumerBase_tie (T *tp, PortableServer::POA_ptr poa, CORBA::Boolean release=1);
    // ctor with T*, ownership flag and a POA
    ~EventConsumerBase_tie (void);
    // dtor
    
    // TIE specific functions
    T *_tied_object (void);
    // return the underlying object
    void _tied_object (T &obj);
    // set the underlying object
    void _tied_object (T *obj, CORBA::Boolean release=1);
    // set the underlying object and the ownership flag
    CORBA::Boolean _is_owner (void);
    // do we own it
    void _is_owner (CORBA::Boolean b);
    // set the ownership
    
    // overridden ServantBase operations
    PortableServer::POA_ptr _default_POA (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      );
    void push_event (
        Components::EventBase * evt
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::BadEventType
      ));
    
      private:
    T *ptr_;
    PortableServer::POA_var poa_;
    CORBA::Boolean rel_;
    
    // copy and assignment are not allowed
    EventConsumerBase_tie (const EventConsumerBase_tie &);
    void operator= (const EventConsumerBase_tie &);
  };

  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/tie_sh.cpp:89
  
  // TIE class: Refer to CORBA v2.2, Section 20.34.4
  template <class T>
  class  Events_tie : public Events
  {
  public:
    Events_tie (T &t);
    // the T& ctor
    Events_tie (T &t, PortableServer::POA_ptr poa);
    // ctor taking a POA
    Events_tie (T *tp, CORBA::Boolean release=1);
    // ctor taking pointer and an ownership flag
    Events_tie (T *tp, PortableServer::POA_ptr poa, CORBA::Boolean release=1);
    // ctor with T*, ownership flag and a POA
    ~Events_tie (void);
    // dtor
    
    // TIE specific functions
    T *_tied_object (void);
    // return the underlying object
    void _tied_object (T &obj);
    // set the underlying object
    void _tied_object (T *obj, CORBA::Boolean release=1);
    // set the underlying object and the ownership flag
    CORBA::Boolean _is_owner (void);
    // do we own it
    void _is_owner (CORBA::Boolean b);
    // set the ownership
    
    // overridden ServantBase operations
    PortableServer::POA_ptr _default_POA (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      );
    ::Components::EventConsumerBase_ptr get_consumer (
        const char * sink_name
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::InvalidName
      ));
    
        ::Components::Cookie * subscribe (
        const char * publisher_name,
        Components::EventConsumerBase_ptr subscriber
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::InvalidName
        , Components::AlreadyConnected
        , Components::InvalidConnection
      ));
    
        void unsubscribe (
        const char * publisher_name,
        Components::Cookie * ck
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::InvalidName
        , Components::InvalidConnection
      ));
    
        void connect_consumer (
        const char * emitter_name,
        Components::EventConsumerBase_ptr consumer
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::InvalidName
        , Components::AlreadyConnected
        , Components::InvalidConnection
      ));
    
        ::Components::EventConsumerBase_ptr disconnect_consumer (
        const char * source_name
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::InvalidName
        , Components::NoConnection
      ));
    
        ::Components::ConsumerDescriptions * get_all_consumers (
        
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
    
        ::Components::ConsumerDescriptions * get_named_consumers (
        const Components::NameList & names
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::InvalidName
      ));
    
        ::Components::EmitterDescriptions * get_all_emitters (
        
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
    
        ::Components::EmitterDescriptions * get_named_emitters (
        const Components::NameList & names
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::InvalidName
      ));
    
        ::Components::PublisherDescriptions * get_all_publishers (
        
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
    
        ::Components::PublisherDescriptions * get_named_publishers (
        const Components::NameList & names
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::InvalidName
      ));
    
      private:
    T *ptr_;
    PortableServer::POA_var poa_;
    CORBA::Boolean rel_;
    
    // copy and assignment are not allowed
    Events_tie (const Events_tie &);
    void operator= (const Events_tie &);
  };

  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/tie_sh.cpp:89
  
  // TIE class: Refer to CORBA v2.2, Section 20.34.4
  template <class T>
  class  CCMHome_tie : public CCMHome
  {
  public:
    CCMHome_tie (T &t);
    // the T& ctor
    CCMHome_tie (T &t, PortableServer::POA_ptr poa);
    // ctor taking a POA
    CCMHome_tie (T *tp, CORBA::Boolean release=1);
    // ctor taking pointer and an ownership flag
    CCMHome_tie (T *tp, PortableServer::POA_ptr poa, CORBA::Boolean release=1);
    // ctor with T*, ownership flag and a POA
    ~CCMHome_tie (void);
    // dtor
    
    // TIE specific functions
    T *_tied_object (void);
    // return the underlying object
    void _tied_object (T &obj);
    // set the underlying object
    void _tied_object (T *obj, CORBA::Boolean release=1);
    // set the underlying object and the ownership flag
    CORBA::Boolean _is_owner (void);
    // do we own it
    void _is_owner (CORBA::Boolean b);
    // set the ownership
    
    // overridden ServantBase operations
    PortableServer::POA_ptr _default_POA (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      );
    ::CORBA::IRObject_ptr get_component_def (
        
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
    
        ::CORBA::IRObject_ptr get_home_def (
        
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
    
        void remove_component (
        Components::CCMObject_ptr comp
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::RemoveFailure
      ));
    
      private:
    T *ptr_;
    PortableServer::POA_var poa_;
    CORBA::Boolean rel_;
    
    // copy and assignment are not allowed
    CCMHome_tie (const CCMHome_tie &);
    void operator= (const CCMHome_tie &);
  };

  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/tie_sh.cpp:89
  
  // TIE class: Refer to CORBA v2.2, Section 20.34.4
  template <class T>
  class  KeylessCCMHome_tie : public KeylessCCMHome
  {
  public:
    KeylessCCMHome_tie (T &t);
    // the T& ctor
    KeylessCCMHome_tie (T &t, PortableServer::POA_ptr poa);
    // ctor taking a POA
    KeylessCCMHome_tie (T *tp, CORBA::Boolean release=1);
    // ctor taking pointer and an ownership flag
    KeylessCCMHome_tie (T *tp, PortableServer::POA_ptr poa, CORBA::Boolean release=1);
    // ctor with T*, ownership flag and a POA
    ~KeylessCCMHome_tie (void);
    // dtor
    
    // TIE specific functions
    T *_tied_object (void);
    // return the underlying object
    void _tied_object (T &obj);
    // set the underlying object
    void _tied_object (T *obj, CORBA::Boolean release=1);
    // set the underlying object and the ownership flag
    CORBA::Boolean _is_owner (void);
    // do we own it
    void _is_owner (CORBA::Boolean b);
    // set the ownership
    
    // overridden ServantBase operations
    PortableServer::POA_ptr _default_POA (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      );
    ::Components::CCMObject_ptr create_component (
        
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::CreateFailure
      ));
    
      private:
    T *ptr_;
    PortableServer::POA_var poa_;
    CORBA::Boolean rel_;
    
    // copy and assignment are not allowed
    KeylessCCMHome_tie (const KeylessCCMHome_tie &);
    void operator= (const KeylessCCMHome_tie &);
  };

  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/tie_sh.cpp:89
  
  // TIE class: Refer to CORBA v2.2, Section 20.34.4
  template <class T>
  class  HomeFinder_tie : public HomeFinder
  {
  public:
    HomeFinder_tie (T &t);
    // the T& ctor
    HomeFinder_tie (T &t, PortableServer::POA_ptr poa);
    // ctor taking a POA
    HomeFinder_tie (T *tp, CORBA::Boolean release=1);
    // ctor taking pointer and an ownership flag
    HomeFinder_tie (T *tp, PortableServer::POA_ptr poa, CORBA::Boolean release=1);
    // ctor with T*, ownership flag and a POA
    ~HomeFinder_tie (void);
    // dtor
    
    // TIE specific functions
    T *_tied_object (void);
    // return the underlying object
    void _tied_object (T &obj);
    // set the underlying object
    void _tied_object (T *obj, CORBA::Boolean release=1);
    // set the underlying object and the ownership flag
    CORBA::Boolean _is_owner (void);
    // do we own it
    void _is_owner (CORBA::Boolean b);
    // set the ownership
    
    // overridden ServantBase operations
    PortableServer::POA_ptr _default_POA (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      );
    ::Components::CCMHome_ptr find_home_by_component_type (
        const char * comp_repid
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::HomeNotFound
      ));
    
        ::Components::CCMHome_ptr find_home_by_home_type (
        const char * home_repid
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::HomeNotFound
      ));
    
        ::Components::CCMHome_ptr find_home_by_name (
        const char * home_name
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::HomeNotFound
      ));
    
      private:
    T *ptr_;
    PortableServer::POA_var poa_;
    CORBA::Boolean rel_;
    
    // copy and assignment are not allowed
    HomeFinder_tie (const HomeFinder_tie &);
    void operator= (const HomeFinder_tie &);
  };

  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/tie_sh.cpp:89
  
  // TIE class: Refer to CORBA v2.2, Section 20.34.4
  template <class T>
  class  Configurator_tie : public Configurator
  {
  public:
    Configurator_tie (T &t);
    // the T& ctor
    Configurator_tie (T &t, PortableServer::POA_ptr poa);
    // ctor taking a POA
    Configurator_tie (T *tp, CORBA::Boolean release=1);
    // ctor taking pointer and an ownership flag
    Configurator_tie (T *tp, PortableServer::POA_ptr poa, CORBA::Boolean release=1);
    // ctor with T*, ownership flag and a POA
    ~Configurator_tie (void);
    // dtor
    
    // TIE specific functions
    T *_tied_object (void);
    // return the underlying object
    void _tied_object (T &obj);
    // set the underlying object
    void _tied_object (T *obj, CORBA::Boolean release=1);
    // set the underlying object and the ownership flag
    CORBA::Boolean _is_owner (void);
    // do we own it
    void _is_owner (CORBA::Boolean b);
    // set the ownership
    
    // overridden ServantBase operations
    PortableServer::POA_ptr _default_POA (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      );
    void configure (
        Components::CCMObject_ptr comp
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::WrongComponentType
      ));
    
      private:
    T *ptr_;
    PortableServer::POA_var poa_;
    CORBA::Boolean rel_;
    
    // copy and assignment are not allowed
    Configurator_tie (const Configurator_tie &);
    void operator= (const Configurator_tie &);
  };

  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/tie_sh.cpp:89
  
  // TIE class: Refer to CORBA v2.2, Section 20.34.4
  template <class T>
  class  StandardConfigurator_tie : public StandardConfigurator
  {
  public:
    StandardConfigurator_tie (T &t);
    // the T& ctor
    StandardConfigurator_tie (T &t, PortableServer::POA_ptr poa);
    // ctor taking a POA
    StandardConfigurator_tie (T *tp, CORBA::Boolean release=1);
    // ctor taking pointer and an ownership flag
    StandardConfigurator_tie (T *tp, PortableServer::POA_ptr poa, CORBA::Boolean release=1);
    // ctor with T*, ownership flag and a POA
    ~StandardConfigurator_tie (void);
    // dtor
    
    // TIE specific functions
    T *_tied_object (void);
    // return the underlying object
    void _tied_object (T &obj);
    // set the underlying object
    void _tied_object (T *obj, CORBA::Boolean release=1);
    // set the underlying object and the ownership flag
    CORBA::Boolean _is_owner (void);
    // do we own it
    void _is_owner (CORBA::Boolean b);
    // set the ownership
    
    // overridden ServantBase operations
    PortableServer::POA_ptr _default_POA (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      );
    void set_configuration (
        const Components::ConfigValues & descr
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
    
        void configure (
        Components::CCMObject_ptr comp
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::WrongComponentType
      ));
    
      private:
    T *ptr_;
    PortableServer::POA_var poa_;
    CORBA::Boolean rel_;
    
    // copy and assignment are not allowed
    StandardConfigurator_tie (const StandardConfigurator_tie &);
    void operator= (const StandardConfigurator_tie &);
  };

  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/tie_sh.cpp:89
  
  // TIE class: Refer to CORBA v2.2, Section 20.34.4
  template <class T>
  class  HomeConfiguration_tie : public HomeConfiguration
  {
  public:
    HomeConfiguration_tie (T &t);
    // the T& ctor
    HomeConfiguration_tie (T &t, PortableServer::POA_ptr poa);
    // ctor taking a POA
    HomeConfiguration_tie (T *tp, CORBA::Boolean release=1);
    // ctor taking pointer and an ownership flag
    HomeConfiguration_tie (T *tp, PortableServer::POA_ptr poa, CORBA::Boolean release=1);
    // ctor with T*, ownership flag and a POA
    ~HomeConfiguration_tie (void);
    // dtor
    
    // TIE specific functions
    T *_tied_object (void);
    // return the underlying object
    void _tied_object (T &obj);
    // set the underlying object
    void _tied_object (T *obj, CORBA::Boolean release=1);
    // set the underlying object and the ownership flag
    CORBA::Boolean _is_owner (void);
    // do we own it
    void _is_owner (CORBA::Boolean b);
    // set the ownership
    
    // overridden ServantBase operations
    PortableServer::POA_ptr _default_POA (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      );
    void set_configurator (
        Components::Configurator_ptr cfg
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
    
        void set_configuration_values (
        const Components::ConfigValues & config
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
    
        void complete_component_configuration (
        CORBA::Boolean b
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
    
        void disable_home_configuration (
        
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
    
        ::CORBA::IRObject_ptr get_component_def (
        
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
    
        ::CORBA::IRObject_ptr get_home_def (
        
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
    
        void remove_component (
        Components::CCMObject_ptr comp
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::RemoveFailure
      ));
    
      private:
    T *ptr_;
    PortableServer::POA_var poa_;
    CORBA::Boolean rel_;
    
    // copy and assignment are not allowed
    HomeConfiguration_tie (const HomeConfiguration_tie &);
    void operator= (const HomeConfiguration_tie &);
  };

  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/tie_sh.cpp:89
  
  // TIE class: Refer to CORBA v2.2, Section 20.34.4
  template <class T>
  class  CCMObject_tie : public CCMObject
  {
  public:
    CCMObject_tie (T &t);
    // the T& ctor
    CCMObject_tie (T &t, PortableServer::POA_ptr poa);
    // ctor taking a POA
    CCMObject_tie (T *tp, CORBA::Boolean release=1);
    // ctor taking pointer and an ownership flag
    CCMObject_tie (T *tp, PortableServer::POA_ptr poa, CORBA::Boolean release=1);
    // ctor with T*, ownership flag and a POA
    ~CCMObject_tie (void);
    // dtor
    
    // TIE specific functions
    T *_tied_object (void);
    // return the underlying object
    void _tied_object (T &obj);
    // set the underlying object
    void _tied_object (T *obj, CORBA::Boolean release=1);
    // set the underlying object and the ownership flag
    CORBA::Boolean _is_owner (void);
    // do we own it
    void _is_owner (CORBA::Boolean b);
    // set the ownership
    
    // overridden ServantBase operations
    PortableServer::POA_ptr _default_POA (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      );
    ::CORBA::IRObject_ptr get_component_def (
        
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
    
        ::Components::CCMHome_ptr get_ccm_home (
        
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
    
        ::Components::PrimaryKeyBase * get_primary_key (
        
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::NoKeyAvailable
      ));
    
        void configuration_complete (
        
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::InvalidConfiguration
      ));
    
        void remove (
        
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::RemoveFailure
      ));
    
        ::Components::ComponentPortDescription * get_all_ports (
        
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
    
        CORBA::Object_ptr provide_facet (
        const char * name
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::InvalidName
      ));
    
        ::Components::FacetDescriptions * get_all_facets (
        
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
    
        ::Components::FacetDescriptions * get_named_facets (
        const Components::NameList & names
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::InvalidName
      ));
    
        CORBA::Boolean same_component (
        CORBA::Object_ptr object_ref
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
    
        ::Components::Cookie * connect (
        const char * name,
        CORBA::Object_ptr connection
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::InvalidName
        , Components::InvalidConnection
        , Components::AlreadyConnected
        , Components::ExceededConnectionLimit
      ));
    
        void disconnect (
        const char * name,
        Components::Cookie * ck
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::InvalidName
        , Components::InvalidConnection
        , Components::CookieRequired
        , Components::NoConnection
      ));
    
        ::Components::ConnectionDescriptions * get_connections (
        const char * name
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::InvalidName
      ));
    
        ::Components::ReceptacleDescriptions * get_all_receptacles (
        
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
    
        ::Components::ReceptacleDescriptions * get_named_receptacles (
        const Components::NameList & names
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::InvalidName
      ));
    
        ::Components::EventConsumerBase_ptr get_consumer (
        const char * sink_name
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::InvalidName
      ));
    
        ::Components::Cookie * subscribe (
        const char * publisher_name,
        Components::EventConsumerBase_ptr subscriber
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::InvalidName
        , Components::AlreadyConnected
        , Components::InvalidConnection
      ));
    
        void unsubscribe (
        const char * publisher_name,
        Components::Cookie * ck
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::InvalidName
        , Components::InvalidConnection
      ));
    
        void connect_consumer (
        const char * emitter_name,
        Components::EventConsumerBase_ptr consumer
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::InvalidName
        , Components::AlreadyConnected
        , Components::InvalidConnection
      ));
    
        ::Components::EventConsumerBase_ptr disconnect_consumer (
        const char * source_name
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::InvalidName
        , Components::NoConnection
      ));
    
        ::Components::ConsumerDescriptions * get_all_consumers (
        
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
    
        ::Components::ConsumerDescriptions * get_named_consumers (
        const Components::NameList & names
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::InvalidName
      ));
    
        ::Components::EmitterDescriptions * get_all_emitters (
        
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
    
        ::Components::EmitterDescriptions * get_named_emitters (
        const Components::NameList & names
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::InvalidName
      ));
    
        ::Components::PublisherDescriptions * get_all_publishers (
        
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
    
        ::Components::PublisherDescriptions * get_named_publishers (
        const Components::NameList & names
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
        , Components::InvalidName
      ));
    
      private:
    T *ptr_;
    PortableServer::POA_var poa_;
    CORBA::Boolean rel_;
    
    // copy and assignment are not allowed
    CCMObject_tie (const CCMObject_tie &);
    void operator= (const CCMObject_tie &);
  };

  TAO_NAMESPACE  Transaction
  {
  }
  TAO_NAMESPACE_CLOSE // module Components::Transaction
  TAO_NAMESPACE  Deployment
  {
    // TAO_IDL - Generated from
    // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/tie_sh.cpp:89
    
    // TIE class: Refer to CORBA v2.2, Section 20.34.4
    template <class T>
    class  ComponentInstallation_tie : public ComponentInstallation
    {
    public:
      ComponentInstallation_tie (T &t);
      // the T& ctor
      ComponentInstallation_tie (T &t, PortableServer::POA_ptr poa);
      // ctor taking a POA
      ComponentInstallation_tie (T *tp, CORBA::Boolean release=1);
      // ctor taking pointer and an ownership flag
      ComponentInstallation_tie (T *tp, PortableServer::POA_ptr poa, CORBA::Boolean release=1);
      // ctor with T*, ownership flag and a POA
      ~ComponentInstallation_tie (void);
      // dtor
      
      // TIE specific functions
      T *_tied_object (void);
      // return the underlying object
      void _tied_object (T &obj);
      // set the underlying object
      void _tied_object (T *obj, CORBA::Boolean release=1);
      // set the underlying object and the ownership flag
      CORBA::Boolean _is_owner (void);
      // do we own it
      void _is_owner (CORBA::Boolean b);
      // set the ownership
      
      // overridden ServantBase operations
      PortableServer::POA_ptr _default_POA (
          ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
        );
      void install (
          const char * implUUID,
          const char * component_loc
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
          , Components::Deployment::InvalidLocation
          , Components::Deployment::InstallationFailure
        ));
      
            void replace (
          const char * implUUID,
          const char * component_loc
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
          , Components::Deployment::InvalidLocation
          , Components::Deployment::InstallationFailure
        ));
      
            void remove (
          const char * implUUID
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
          , Components::Deployment::UnknownImplId
          , Components::RemoveFailure
        ));
      
            char * get_implementation (
          const char * implUUID
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
          , Components::Deployment::UnknownImplId
          , Components::Deployment::InstallationFailure
        ));
      
          private:
      T *ptr_;
      PortableServer::POA_var poa_;
      CORBA::Boolean rel_;
      
      // copy and assignment are not allowed
      ComponentInstallation_tie (const ComponentInstallation_tie &);
      void operator= (const ComponentInstallation_tie &);
    };

    // TAO_IDL - Generated from
    // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/tie_sh.cpp:89
    
    // TIE class: Refer to CORBA v2.2, Section 20.34.4
    template <class T>
    class  Assembly_tie : public Assembly
    {
    public:
      Assembly_tie (T &t);
      // the T& ctor
      Assembly_tie (T &t, PortableServer::POA_ptr poa);
      // ctor taking a POA
      Assembly_tie (T *tp, CORBA::Boolean release=1);
      // ctor taking pointer and an ownership flag
      Assembly_tie (T *tp, PortableServer::POA_ptr poa, CORBA::Boolean release=1);
      // ctor with T*, ownership flag and a POA
      ~Assembly_tie (void);
      // dtor
      
      // TIE specific functions
      T *_tied_object (void);
      // return the underlying object
      void _tied_object (T &obj);
      // set the underlying object
      void _tied_object (T *obj, CORBA::Boolean release=1);
      // set the underlying object and the ownership flag
      CORBA::Boolean _is_owner (void);
      // do we own it
      void _is_owner (CORBA::Boolean b);
      // set the ownership
      
      // overridden ServantBase operations
      PortableServer::POA_ptr _default_POA (
          ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
        );
      void build (
          
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));
      
            void tear_down (
          
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
          , Components::RemoveFailure
        ));
      
            ::Components::Deployment::AssemblyState get_state (
          
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));
      
          private:
      T *ptr_;
      PortableServer::POA_var poa_;
      CORBA::Boolean rel_;
      
      // copy and assignment are not allowed
      Assembly_tie (const Assembly_tie &);
      void operator= (const Assembly_tie &);
    };

    // TAO_IDL - Generated from
    // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/tie_sh.cpp:89
    
    // TIE class: Refer to CORBA v2.2, Section 20.34.4
    template <class T>
    class  AssemblyFactory_tie : public AssemblyFactory
    {
    public:
      AssemblyFactory_tie (T &t);
      // the T& ctor
      AssemblyFactory_tie (T &t, PortableServer::POA_ptr poa);
      // ctor taking a POA
      AssemblyFactory_tie (T *tp, CORBA::Boolean release=1);
      // ctor taking pointer and an ownership flag
      AssemblyFactory_tie (T *tp, PortableServer::POA_ptr poa, CORBA::Boolean release=1);
      // ctor with T*, ownership flag and a POA
      ~AssemblyFactory_tie (void);
      // dtor
      
      // TIE specific functions
      T *_tied_object (void);
      // return the underlying object
      void _tied_object (T &obj);
      // set the underlying object
      void _tied_object (T *obj, CORBA::Boolean release=1);
      // set the underlying object and the ownership flag
      CORBA::Boolean _is_owner (void);
      // do we own it
      void _is_owner (CORBA::Boolean b);
      // set the ownership
      
      // overridden ServantBase operations
      PortableServer::POA_ptr _default_POA (
          ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
        );
      ::Components::Cookie * create (
          const char * assembly_loc
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
          , Components::Deployment::InvalidLocation
          , Components::CreateFailure
        ));
      
            ::Components::Deployment::Assembly_ptr lookup (
          Components::Cookie * c
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
          , Components::Deployment::InvalidAssembly
        ));
      
            void destroy (
          Components::Cookie * c
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
          , Components::Deployment::InvalidAssembly
          , Components::RemoveFailure
        ));
      
          private:
      T *ptr_;
      PortableServer::POA_var poa_;
      CORBA::Boolean rel_;
      
      // copy and assignment are not allowed
      AssemblyFactory_tie (const AssemblyFactory_tie &);
      void operator= (const AssemblyFactory_tie &);
    };

    // TAO_IDL - Generated from
    // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/tie_sh.cpp:89
    
    // TIE class: Refer to CORBA v2.2, Section 20.34.4
    template <class T>
    class  ServerActivator_tie : public ServerActivator
    {
    public:
      ServerActivator_tie (T &t);
      // the T& ctor
      ServerActivator_tie (T &t, PortableServer::POA_ptr poa);
      // ctor taking a POA
      ServerActivator_tie (T *tp, CORBA::Boolean release=1);
      // ctor taking pointer and an ownership flag
      ServerActivator_tie (T *tp, PortableServer::POA_ptr poa, CORBA::Boolean release=1);
      // ctor with T*, ownership flag and a POA
      ~ServerActivator_tie (void);
      // dtor
      
      // TIE specific functions
      T *_tied_object (void);
      // return the underlying object
      void _tied_object (T &obj);
      // set the underlying object
      void _tied_object (T *obj, CORBA::Boolean release=1);
      // set the underlying object and the ownership flag
      CORBA::Boolean _is_owner (void);
      // do we own it
      void _is_owner (CORBA::Boolean b);
      // set the ownership
      
      // overridden ServantBase operations
      PortableServer::POA_ptr _default_POA (
          ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
        );
      ::Components::Deployment::ComponentServer_ptr create_component_server (
          const Components::ConfigValues & config
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
          , Components::CreateFailure
          , Components::InvalidConfiguration
        ));
      
            void remove_component_server (
          Components::Deployment::ComponentServer_ptr server
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
          , Components::RemoveFailure
        ));
      
            ::Components::Deployment::ComponentServers * get_component_servers (
          
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));
      
          private:
      T *ptr_;
      PortableServer::POA_var poa_;
      CORBA::Boolean rel_;
      
      // copy and assignment are not allowed
      ServerActivator_tie (const ServerActivator_tie &);
      void operator= (const ServerActivator_tie &);
    };

    // TAO_IDL - Generated from
    // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/tie_sh.cpp:89
    
    // TIE class: Refer to CORBA v2.2, Section 20.34.4
    template <class T>
    class  ComponentServer_tie : public ComponentServer
    {
    public:
      ComponentServer_tie (T &t);
      // the T& ctor
      ComponentServer_tie (T &t, PortableServer::POA_ptr poa);
      // ctor taking a POA
      ComponentServer_tie (T *tp, CORBA::Boolean release=1);
      // ctor taking pointer and an ownership flag
      ComponentServer_tie (T *tp, PortableServer::POA_ptr poa, CORBA::Boolean release=1);
      // ctor with T*, ownership flag and a POA
      ~ComponentServer_tie (void);
      // dtor
      
      // TIE specific functions
      T *_tied_object (void);
      // return the underlying object
      void _tied_object (T &obj);
      // set the underlying object
      void _tied_object (T *obj, CORBA::Boolean release=1);
      // set the underlying object and the ownership flag
      CORBA::Boolean _is_owner (void);
      // do we own it
      void _is_owner (CORBA::Boolean b);
      // set the ownership
      
      // overridden ServantBase operations
      PortableServer::POA_ptr _default_POA (
          ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
        );
      ::Components::ConfigValues * configuration (
          
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));
      
            ::Components::Deployment::ServerActivator_ptr get_server_activator (
          
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));
      
            ::Components::Deployment::Container_ptr create_container (
          const Components::ConfigValues & config
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
          , Components::CreateFailure
          , Components::InvalidConfiguration
        ));
      
            void remove_container (
          Components::Deployment::Container_ptr cref
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
          , Components::RemoveFailure
        ));
      
            ::Components::Deployment::Containers * get_containers (
          
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));
      
            void remove (
          
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
          , Components::RemoveFailure
        ));
      
          private:
      T *ptr_;
      PortableServer::POA_var poa_;
      CORBA::Boolean rel_;
      
      // copy and assignment are not allowed
      ComponentServer_tie (const ComponentServer_tie &);
      void operator= (const ComponentServer_tie &);
    };

    // TAO_IDL - Generated from
    // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/tie_sh.cpp:89
    
    // TIE class: Refer to CORBA v2.2, Section 20.34.4
    template <class T>
    class  Container_tie : public Container
    {
    public:
      Container_tie (T &t);
      // the T& ctor
      Container_tie (T &t, PortableServer::POA_ptr poa);
      // ctor taking a POA
      Container_tie (T *tp, CORBA::Boolean release=1);
      // ctor taking pointer and an ownership flag
      Container_tie (T *tp, PortableServer::POA_ptr poa, CORBA::Boolean release=1);
      // ctor with T*, ownership flag and a POA
      ~Container_tie (void);
      // dtor
      
      // TIE specific functions
      T *_tied_object (void);
      // return the underlying object
      void _tied_object (T &obj);
      // set the underlying object
      void _tied_object (T *obj, CORBA::Boolean release=1);
      // set the underlying object and the ownership flag
      CORBA::Boolean _is_owner (void);
      // do we own it
      void _is_owner (CORBA::Boolean b);
      // set the ownership
      
      // overridden ServantBase operations
      PortableServer::POA_ptr _default_POA (
          ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
        );
      ::Components::ConfigValues * configuration (
          
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));
      
            ::Components::Deployment::ComponentServer_ptr get_component_server (
          
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));
      
            ::Components::CCMHome_ptr install_home (
          const char * id,
          const char * entrypt,
          const Components::ConfigValues & config
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
          , Components::Deployment::UnknownImplId
          , Components::Deployment::ImplEntryPointNotFound
          , Components::Deployment::InstallationFailure
          , Components::InvalidConfiguration
        ));
      
            void remove_home (
          Components::CCMHome_ptr href
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
          , Components::RemoveFailure
        ));
      
            ::Components::CCMHomes * get_homes (
          
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));
      
            void remove (
          
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
          , Components::RemoveFailure
        ));
      
          private:
      T *ptr_;
      PortableServer::POA_var poa_;
      CORBA::Boolean rel_;
      
      // copy and assignment are not allowed
      Container_tie (const Container_tie &);
      void operator= (const Container_tie &);
    };

  }
  TAO_NAMESPACE_CLOSE // module Components::Deployment
}
TAO_NAMESPACE_CLOSE // module Components
#endif /* ACE_HAS_USING_KEYWORD */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_codegen.cpp:1135


#if defined (__ACE_INLINE__)
#include "Component_BaseS_T.i"
#endif /* defined INLINE */


#if defined (ACE_TEMPLATES_REQUIRE_SOURCE)
#include "Component_BaseS_T.cpp"
#endif /* defined REQUIRED SOURCE */


#if defined (ACE_TEMPLATES_REQUIRE_PRAGMA)
#pragma implementation ("Component_BaseS_T.cpp")
#endif /* defined REQUIRED PRAGMA */

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(pop)
#endif /* _MSC_VER */

#endif /* ifndef */
